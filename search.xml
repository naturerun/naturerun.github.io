<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; if (cur_value == *cur-&gt;max) &#123; return true; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! U2FsdGVkX1+oTXUKpDv3dXWieJuDc/C4HJtNOSFe8vpxq2IbxlxrZnuvHfdFpQr4YoWJ35uqh1+QjKbsI+2xt1fWU7rLjb+A0yuTYoQxdlYzcZVpaEx2tDKzZNglxfTy76lEe8LUXQbVbeSWDtpD4l17tnErpDpjKPgn57tVjHIzZ/0W8uuMJ40fV01fuREwDCSG/DXWlbSvMrzEz0tRzg/RMnHLBxTkJjRrlnJqWq1tv7C4gCeUVLUqS54W6yV5HZl2YwvEDd0720GslHNyuWQVHWSuk1AgD1mNvugeuqfy+vVpf9WDW8yT2ovrBuYX1TaYbEUXJ6GwsiRK0Yo77A39iZ7hs2+mew08Wh4WSKLwc/Kmo/Afq1syWFcMiRzOOrdwjoUinlb4a4eF2GlL4Z9IzYww7m7QBjFLsD8lDGFWZXhhg/0JIQH6ptc5xCVStft9AKiNgbkW/RXkyCE4EUfc516HRI3XaIcNgbyaptWds/kxFoP+0u7aPm8RLb0GS1y56yLR/WVXPmLRXMA9/veH69W0TgJhJtJri7HJhdRaDWHxphVA4MBZcPN9WMx0TRvTCmJWZ7Dbxf8rmvYtSttTWi6XhxGuonhnkpwxwxinQoYoNbgW32IDuTSfP3RYDlNuBBoLzt7GyR0z/W5lEccGdi0zPtZJcbJVfWtTd0V3OmNDjetltWVZrJaZYMTvPWn2wVeeXhxj0Xgjfm/2PBLzXP4gbCC+Vql1L2kJwhR9/yharYS5aD4X+NKJdg5+BPBIf30pSq3zz4dBjT4R90JRzZHcAsuYnVwhq8RMpAY6f5pes6XDr/KbihS6v8o03dS5z6vcsShw6H8XMYfboZqzve8OnMb4dCiAhctpvvoLwjJjywr8SEjqVTx5kexrMoMe5zv91BNg9tYEqP+AXOoafZSZM0PvS+dm3olu784nt7OewUi1eun0f6hErM+7OwJWzSEAxJKFyP/cQIPzUBi+VVfyLYwFPMhOIq/+ePcFSY2cPNrxyCmgaN9RU7TXBehwBEyTMXnGk2gDpxhPBOU3zKTH4fowSrnjQ12EVNhYUCnVR40H33jO4SJlFapdR0w/ho1J6OXIHgMU2uh3lK6YIwJIKlyr8oKWV5xhcZo+NszonS+gL0M8fiOw3F7WagERciVmG0d4VTkB6u6ByavpV2yHThBceoORtPgePo448Pdq9V0/LV/Yz4KuW37NRP+pLfdMvmQIUP9JQfkRFRpMoCJu3SqZLfaHiPM6tE96HNxjfQ2BHUimmP9IqpkFqDuw/ZYAjUMz4+IgHYiR8ZPd6Ie73QvCC7rNvS2nsXovZzFvRCvOj9U9yPpnCiM2Ib19toBO/66pB8NElGOtXx6Jbdm2dOd3K8NiYg6Gfp04+miLv1WmWO6z7EPcldB4xqjWpg1D032W34F3TMBYoiZzgX29I0tfYeeXj4oejUHJwTwnHZEid6vIxevVLRTafZofi/UjyeuEvd3mq2pqZKTt12UmzYAvXawiwAYohcdonxq+29oSfXaJIyqe2f9SMOmEJBxvEv9I13xCOBWb1ECQW+I/Qpxja0hLfMG7uDuYCTHNzcNIzMUST2fvaxSEEIHylYqMp9zYfl4akHuT5AeUIvgnjhZceh7ndn/j+DkiJXw0tqZi+7vx948g6Fnk9p/EG+G1vy/0ZevS6gM3nIs1iXi2ralnl1LPQFlMsJjRIywM2jgK16OJzJjSkPa/M8gg1bNWXtlfK4402GNJ4SVqmqCaSDFLoe/AvZKSS7AbyawFASctclmwfjSE1saE55GucRSOiJYXD0tFUaVZFixLUFFj9UbraGtaxeanBS6GellyHJxYAoTUgPZ7DaLCz0/37zEGA2tZN1RFskmN7j89OQhmlqVXeXFuWVReZ8wWFfAwsC9kXa1jchFUhs9hhMsEaXw53IONRh/eShj1benOR0lvoHritxSbF3JtcL2jdvw/zh9phN8vwcbFsYrdP4FPY4H5PfYr5iCA5zw2HOas2Tb87uJNarQTeBmvEJqqU4v3Rw+b3hHNb3nix6jFO7uzP185VBdaRkVCMnzQsDtJE+ApE2Osn2e3aSMBKbqq6Q5jldMMN1vNHbZEW+Q+Nw7TamD4WoswscNpEdHu7cxtLP7av6mL647cMxqXRFTDo75sxFpS6AutmYBkopl9zbazbIgnAWHBppFlwysOTJJEy6/QwasBuX740umr3BJjQQvc8sxsASJ9HOBu8+br6+Hh4vmZaZLyfALPOrodveTiwSxl4ot3J5I58XEUJ6Poh/7QrXn7eoisaD2Xrki/7CI6eIsorvx+0dSGkM+W0f8I+jzbpkJEEvhYxO5+lYcycMRGm7/kxG2HQE/I2czIvUZ5bDEO5oHIpTY3CwVEBHIP5swFHk6ogKEol528A7pTS1lMAAwgxrh4pXyfYyGH45BgEu8vQTOnN7iY0d/L/P7CkfGSJIp+1KexHUR/ZcGhpGalW62DKwe9crVFeZpPCQNyzAWCz7K+H0/Tub9jjRttTKEvDsTC6keuw+no29fokuUjmd49mUAJWlpCsJM5R3I8PRnp8HALutS7JRkTK2SdXUjWcj6J2rTUl/tApaz6dWFXTUGzZmyAgho8iEm+Gb9mTSq/lCQt6xakqaISXfnopUHaPR9YQDXGp+2+CkE3xL2lZ2OnqsVrpkYiA7zv9tr4F9J4yPSVuWgazUHVaMCpPjvgcBCr2KvjE/RZWoMXQXCA7iUp4y48EZsoXwKUl1KYFhJfB9VkJEyzWlgkX+ZXMZxt63NHgF8Yv/0t+r6Aqzx/+kD5iBkQ+fPUNEFaNg7sraMQVzOp+uhf6jkKvpx259E5AOPKfKYdaEXrqum+JmJlQUvWSx9qEyBf9uqvhY7mPjuGuelWWxPZXOSj6sHi7zzu8VwP4dMDnYbI2TIG6pxYhBOa7WvCzDoo8y91XnFjiqvPxjtvrr6Gt7/R5DJd0w1kZ9g+fE7DkdFKebYcIP1cvB+77EdcvRbNV6ePU93AF82TQ615tEeOwog02388aoe9czwwnhuaxbP+G5TmwOPBY47b0QUhiDyHHoqbkyBSiRMpYeXVhjj+7PPDyRyN8x7rIAGU6AYcbXnBEdvWH5vCPISEA23stCPT69u2ERrzn3hspY9iy7h46Yt7FMbJCf4cCQF3InO3LKR2eX2U6ZOPsMX3LUx5c4Hx9GgrBOgQlWvYBsBnsCkoA0joN3vl4ggc11L4XzDtrpPn4tbdXC6n29Evax36GHF4dlgcYf469LiYk2Agq9qcR2BYQIeYEPiL0DESADIMApBR9fhYpGWyCL0FwIT6nR9P9VJTmHK+7tgzOjvxAceMBkD8hzcn2lSClqQMiIY7AvS4zZdOIdNYKUUyDPjMmdYOcDddhPwV2fjF5p4oWutlnMp9FbjNk1htGah8K9PkJ4vQRNf3EUsZzz4Lia+I/UQrjPJ5dVSmID38wdpkOSGMOTQD4gC1TOqRj0bxfnzPob0rChcO2h9QEktELWNi9RLFYUfRvafgcDLzJEOew+VuylWPtezievRfAUSQrBavnqVcSg7WlYnIGTaNtCrXFsD9QY2xNAeyuadNzIODy5Lw+BTD9s63CZSLhpxRvE8Pusp5kOUsjpB781LO8wDJ4QG4EJvqrcFXc7DK0fOWhJQGoPaQf4mHAQv27IpNc7WpUdYVyOqLfIGwHm3JUMRp6HOVErFl8pWsUe48RTZrFWOOtMWtngWuEyw50Q8CWleSoS5mxYBJVQGMaid4HPgXKiZ9yGy3z6ZBQXxLyEGiFrl98mqlTPIlx3kCioWFa53eUofqYiGrcd4U3LiVKQinEyxLHlzpDdUFL4ra+jlnZKcHwzwSYpkGuFc1mExGQjfUidWLPCAo8U9gsqjWuX5R1KiDpSimbop7+v7vuuwECmN/G9lYp1nNT6lh/YgtH/71t73pfr7cMjWICrsT4i+A7qnxIcx0XkPsSt2VyTrKVbGY41weQB38dMwCN7OPVSn/gRzTLJAjoVHEhH7MDbE2uyFwB+o/GNcg21818RXsAsdDb0v1fD/Z98STBXhebbvGCXTXdMp3A9P2ayS7dWE0x8zX1qOpglOicr44yrbUxXmGsGSXVcQ88KAdIynr5cmT4GHd4gPO3fDOGsTOKQGXchRp6oKS9/zGoDM5Ws3UrWI9sz+gm7XqI8dQHp+Yr6tO3sDVtHxObMv/Y4LBkKZVNT+mcom1cKrWPZS+6N3lSBBBhTSK5wJZhhB9mRRJ3IV9nHTNsXlE3ou9uCpHPV7cltZiPutIQGmDybRwbIms5VnVittO72QE36wya8Zr7JjptKQRYDKHfEk/rRGJUjKmJrWZkYdC3wNRcl6ZsUFSmtD+8zZ1AgyWktlMNpJ+Viw4VdYN5uitrpbcNNQ1zszzN9/Qvuph4Xqn6gf3Ig1zJR450ovbzJIo9Wzvwk/odQCB8mOwkbeDrpSzRbxLNpADBnN6XV3NqgtVwbe2YNtmbHHYy34ZQF2qcwrzVt+6RWUs49kDuNI0fcM1pcvtQdg+pB8oA5Y2SOLHYl4Nli6JIJGZEPUaLiFdm/da5bPaiiSTyI6MeSt1sYPDsy6vop2DaCse8QNEj7IK2BAnWbssA0KDTAViiu86x+ZChp+0wW8ofF4WfKVY5hIPtDYQKu69A4ozjtaBInQK1hvQTuoh6QYacji9dy5gePQPM7+sjzKXChw8BbbpdP+sLPhFV/nl9gWFfA3+dv2SzWz5B12IWunuRaYTkyg8raeat3th0q6jtx5z7/DEq3eXvA8MzlMslq1O/1vnnFekaT5AvuMc6fmRQOJQeqvzyixerzF249UbWJyp+IJyDLDwXeVPvSTTukgMaXC57ZVKdbbh6IT7Ir4alLCuwncyqCHEdq5Qmh5NapWQLZQAHUwHGHDSPWwbmSZ5dmfsBxqYPVK6i3iIu2VAb+CcgO04yj/+jiXrFICe6xaGuhNruQevbD/+pPuS5OI9J/4KuRfCJW8rstwJJtiv6FHkvpvxFsygUJBo4/arZN34RyiTvktaJqQ6tVkTn10esMcgkkXMlSlW00pQV+OodaIisbxjiLXxuBUvfEPhfWvSb3Xx05AnuwX44XTe5gg/rrPF/WuxV8x+nG4YiDL3tVztAezVLoKefrARTnuhsKyX/8n37660mtL+A0Z6qej5hppV52aPOWYNJl0BrhtisAoWOTpQSyCcvinBbehlTDNebWlIX8ByKAxTB0G220tdqP1R74OWBYgI76Gob/db8IcEI80Ut0PqvZ9YRnQj0yrkWroOYfooplj2mJb3OrMBkhXanCfAgTHKM5tjgu46s1ypLPedtqTe/VlqnHWbbxQUGUycbs9z82+FYrF8yw0kffn4rBu3bi4KHGQkDuGuGEHKTVB5XIZM2eMieS9/iXWZEfKIlinawjnsX/UsJmNx5k0saV+2ogXZXo30NBsUkSrvWxEPg31iJLidKe51WAqBZEdw3s35E6z/6EXAMpHt/MOgOIJBQe0FBGbES4rKsLJ+4I62iXDZajGynpHdBHYfbQXqIvsUDQJBSIZZtTz7HPRfbd9Q8htQJ8PFFH3SueHJ15Z8DeazUq3Uqtl5i8tUzBoVfc0kqys1VcbdmIP7fjvNusi3e0Ywyncrfj/MKpLuLuV7NO7wX7OTD9gvNXpYauiVt6d0R4vxrXESvWMqzpN2SyR5vEw+7339RM+0t5+j3u5XhMXb483pq7gJRjcCIgOAeB+Pr3PcRKJFKDWvzZM7WhG/8sWOAvhuUKYTWY8QioH549FRnj2sVqe86rHC1eXiBoZJT6Q4mCPB2TG9NTsv4kPT9p1L7Lpm1KC9uc7pL5TtQn9lpaTjq1CxHS6svNSudYDRz6B9D+Q4yr2cimWCIHjTUNw39Gtil/SZoU+ubKkezanMaX8/MJSSXy4x3N3vUsjsnLIDVBO2+DX02l/GqoOK/T8BsNDu4uHVibxsngDQyvKMVF4w2fCqpzDoFheQhKgCQ7EJ7wsT6S7rfq93sbLwPDoeOeprY5NYGsYNPofXwlaKUw7a/VUIjLC9XTWcChC2MUd0SWWKDKMM/bDFF7LDlQhq4OU6AvlqcwmPXnpiICWdHSi1MclI6EqLd8PTMQ6LgK5UvQC45LrDtKzHgBufjnNa7KPDblFBUFkr/Rm1yEK77i30zU3Ybnm1oRd/zZMc+apfrBIn3tW9ZZZqwdfMqd4GiPD9VuPaPbfGIsUCoJoEpdEF1O5OsksxytQA5kyj79oYvAGJKLm1mLborTQxZ6k1zgQH92YY0bo4+D4XdOJpIU0djRJX7Z1/XedRr/vn9YxCLUKdcpbjHwqPj1uHRAEZVvuImhpO069WK+25pqAWgDE8OTRbdxG1MkxDSsDkb8fHNTwkdIimc21rfA/ycC3zG/HRPTMgXU0bfc/O7jFe9MvNB4Z720fIV7f/XYJiMZnkTeT1zriqfoTcK29CPyUprCYn+bGNrh8CmLl5yzdfP0tuuY73/aEZqsZBFf3dPMXpYvVSWd5UNOwh7DQl5FeSa0vkg5jlNQhmb6ErExZkklYruCUlwQC5rdHMqGCmBQa9IbxMbpBdSR/1aaW5oRYtBD9Y6xKDuF7jQ+dp0Blszkwt1XZH2EPI3iPubyt/hG1qR2rkaVhwGBDBOJcvpefZ1ozYKr4GxULMFZgJSz06abeWe81g31wbyTCrAuv8UF0xVRus+KxM3ECL96JEJt/jAVxAEX2NW2fC7m2wLlCMix8vyFuGhSVU94XCdWmTM0Grrm5e+lumNyMJ43if2sDHZyucJmPlUk6j0d/6R+MKkYYSJe3Hy6SyBELilMtCngGg36uuj+0Y14tISGft3OnzAqB1YKm9YtVEJ0FowivWjJJL1Xh4zkqLLPEH11CNWPL4eqVtW1PqC52u3LHkSJ0sAZ31jZyLGz5EvBQ9essnsytfqTNEvYDGI3MHGrFByxhzvlv7Rn1rXJZ5ypgc0RaBMTyTnMSdHHkkpMDFBmCGpfafBKGGWiya8rRV9GmBJRN9g8lLV2iBfyC2/Cu7j/hle+HjRK85KBiX72Lm5U+409N6GAIKUBz32sZY6xjvt8vE2Z19ttOjfg7Z7B6xi84r4DMLPXzIr0DNEuvJL8uEH0LEwXmDjx8WyDem3YrqeSiu7RNgvDJb2JVQuoAzaQRdCMTkRrdKm1r6jaKKY0Rry8F1PyihpByEPIefnCLVOrQygpfcf/66qzHiYwAklm0OIKMCwaAwJsMlCNqfEKZUQM548YSXTQOxfP1pi8jjMMZuxpA5cSP7tgh1Iqj91BWnGnQX5EBHMu84kG5ZD5yrRSXfgL8kgGrUgVU4bNeFQbLTmwi1sdAYDNB29bKxOm3tcfRxqn8Qcz0jjPcczkBjIDMSDCkbaXLvYzSXDSo4IQdskLC9plpPnMwQ4/ftS9M4B2ktTvCTD3Hcoag00Ueknt9Vf3Xft+NXW1pTu6vseKrK8RRal2MeeAMIE9BEN8VmFq0OZzaXrnDHIoOjXqpbeh9OQQAkuUovqcdAtdX/spVxqEBVzSIDRimOFjwDKcq/GqKgWZEixJ2gfjsnGY+aQTtrWCQ3Vhg6wPVrMz7NNXDags16gDb2jhXt6509p0edxixmU8MQAu6I7nLLT3LOfbZJ0e2rGjFulIyNPzri+99UpuRX2RMKXP36JsgzqMoBuNPqBMIuv3Px8nOBmAVqK/DOs8oGRctwOmy0Tc+5ds+XgvPtKJCXjzUZjCKT9Dwc9cHg1iM3tPixqDI3jsw0WWoCs3BfwxR2PpzgclI/JpfGLWZzPH7Yh4ltKnyLFBP4HZrKUUlIVA+8/SMdFJhlWU7TxBo0c4tXbPNjPGOxfvn1xFdBVtNXR1cJb5xBKXp5eiw8P8oGsUDnWqVmvVJF/lpW6Z9aUXIHaFPkOUGfm/45nzte5Mtwo8kPxMou4f+EuFuD4H2fN8o/Ii7wcDoMQ/UG38xX/1QZom+kPNaEQg3vJYBk1lWgYNbrICwhfClcZUCTkOJSn9K+pI+MnKj1DWUrf2+rSZaTyBlIvnIgW705Z0SxdHOJ3kZGzxt7U3a1vrhC9ARAhxPNcoiJO1iu36QGcgmXjfgfqr47FSd5d8k9Gp9QktO8xfQ4JwWPdBcDD810uyfQ/wQwS9dQgg2ObiR+XGZODOmZs5ndPHGg9T9FYIPNNDPNDpt8rXqy8HKEmZ19kdoaDKp5Dzow8mZgmYOaTuWOPEgp7zxViaSWR8dLjJ6UTMLq/M8ios8MlHR+O6x4EjBwnzbJuBDvWYp2V4LLgxiSuJvqZbnqNHol+ozMDmZWqA59YeyoZIUmVmHK9Lt8OrF41I22vLpLC8lJUPVmbmYxJOl3Oj9U2/lP1M/7DPQVb41AkqebXaeTuz5HH1Rvse+SAjJ5HCvIE1HZhQ2U682QdFFfSs+nQ+q6Z+DVgRyCuS0nKE7+J7ImCefpGrtwboci6ssLTpIn1VFygT38rPydszM0S5t0EC8LbkM4RECI5NqOp3SjgCdDIXdJNfrfwrOAANNLoN3gugVNVUwQLpBkE2xccDgoOQt4fxkmvngQpY4K5fxlhv9kSqgKdZJAYAZyLsUM/+TkTDbvVyuu2a6OuRrjfdmnhfwaB5YnyxNfJf5coxfzp8Aqk9ve61jI1lhEjlRmE0pOEFh9fKQkr77Z2Jr6V9WrLZptFCn0dGpbTloO16jCWwgC6GOnnU9W/h+yqjvXrJdBE9VGd0T3Am7ra02d3FeCfnXCINM4PREIuFrQtHuGsCf5Qyzogre7dBGVKw3JNBLkuEfATySFv/jf4E73muExvKM5Jv5T4/+QDCjwSsX+UtGbNskF7+zlyi+mQT70DV7PvXjBJ337EIzd7rZOqHYkXZ01vU0HZtBzQ9irdL56EWLT/tCoHUn3l6EU6Oab5JcCFqnJ+aNOPCj5QcvslWCfdKKHDlOGxAM/ltDM1D1RQJ3jglGlH4jCEpZrUVDz4fgmZHDlRHq8YI5iIaz50dxHX4CnqsTERllitMtHddXwh4qsYxlBdNB/0EdGiplhO8DeYf8/vnVqUz5UJCXh7gTNVWDKmV3ENdoU3PskdHB2VrjL7rZ7bhq/oT5/tNCua+qt5CNmdd/cRazTpyJqbhNd2ByRK5k3VXXGK/IC2Ln5KLhxHo2oDje9jnCDbKf1FTWBUExhAJznVTYADDNEzCRrivl2kX00pEDOaYt64DiVxtXwbnJy8oZ66RkU0MxrydQCa2DT3ZnBtj9ygEFWZuUTy+vNMRHRVmSXKri8zXkRmcUUCMYRXwPli2oMI864S8vnFTxJbeQFGLgwK9KZZOF719kn8mI7k2eZ712uG1QcQyHeZPsLYT79EMkqKS12TSu62Ajqn67tTud+ABvts6o3F8Zl++3FpjXv5F6w/FsHTfxwF0oP0Rktv38onaI3TUfUqp7oA/FySEwt+1im+7CHZUnbY9pY3WA4yueSD76RPxMDwXgeM6oz84120jo5z3NSwTb8jx/QlJwLu9/49Q7H8inJJMdchXAEvZyp+uec+Y2r0yjDtAgb3gsoNCrzN8tS3Div0ZyZiK8RqBOunl36XaT/0mUXj/pdQn51F+TbSAvzxH0VYIh9PKcg0M22dPcuBLHbJbca1AcSr+Sdio8eB7u7vhPWX7er3arO6jPIAmop6GjdJPWnmyixATsFd8Orzk5E6QceIngGj5EuKMs9+91dOY2zhNRxBfl/Hyyune94IvozZ86vPbswTMw3mvmVJ6gyXz73fIdo70E36+E2A5/iF8g1o29cIgpaJqXYFThhV2lzt760frWA4/aoKvLb0zUtGfcg7lQdkUZpK3BYcxFuqu/CJp8MP0eF7aEGd6kgrq0OhWL23x8S4snshE63mnv4cAY+OTHU0KBaMyW1ZDmu+OdYI7My6eBMk2SJt8p1dHQXf/T4K+GWG87As/PFtqgrl6FFPcnVvIkcVq9bvG2+aNuVu6aVocOCUnG8AWx85mhDBPm9VLyr7BNz0+RCY/dTNOItc7Ajccxqpue8blU+e7Ij+qh4xFrn9K5DN4BQZm1sUL/cfwVZE4r/6ls/ZuI/kue56KZ1zs2fuh3rWN0kR/Uu+MI83ffONI5VcDxpFMLsWisz4jwI8aWdcKDFfB1mLnrlewLIpttC3j2hUs3x19+yYuXFL0r280AX7omfLOC3tXSfjuIBHS8Q5YtCXYFONsZxIPHmX1ba7yolYBLo5UpLUzSeW/fbJyo8n1w2NY9sxAmeAgIeRFdmv0htyFNZCEAN7u2GN657NkPSTICsRE602ffZvIRZRGZSlIAmkJRtBcBGHb/yBMswAmoFpQwfKFzJ8RtmfQwvCne2rCHi90sKrPEjYoeiOUd/K6XVCmvHXFQOSauaEFD8eCr+huNZSD+VdPL5/0wfbHEi4A2O3nvzkKKVu4CAmH6zkaXF5uUa3GcV52xyeMimVVZfKxjEmYVTtljKL8utX8rRVvuGBG0T0HzFI/mKqYNmqfDuINLDbT/r1/WG4f4xG2hSRlQbOIYrevxo7dNY4J1nMKK7QcB3ne0PgD17iy/hFdRe3m8nHoagxx1U/r3yBEobvzD6chJb8fpkJBdDXx0peDzm67IVCm9o57QwBpF2KgRGraGgwB7qCFtIxYp8m1J0i4U2wN2UMhKg+H/F0kJuoQ4Y8tXUip79aEr0cp5SDz7cQ4YwsLMMc3aq5x7cOs/yjj8S0XFq36/zwQacT5J1lquahcJ38IWYIPDaQFPX322FpVsmS3acnkBL0UNnkKiu8HgwHK26RNJkgt+2Hy7nL5oyUhQ5DsZGbjK3QNLs86jEVDARXTAmzoEEVN6j2jx9Ur2tpoV581dpcwsr7+irGF6nv26rH7L/Wmf03Mwvvb2xiOzsMlufyhejJJoQaZ/HWz7MX5uA7j+9GpM7E5mV559I75NNOVX7hABgcOo1EbNK74dhCBrggE3yn9xNE/DCX6XUeOVU8i8imByh+vMIU1K7zi7yfB+sevUhFyN0jKsoOGKhmsul8iyQnGj8YrVFccw+KLjnlrAnJvCs4sHvU+yJSq8SHv4TIn6N0+RR8pjU77fUQ24IZOKvj4zclKED1RE+4DhPoA1yrmy8radhgqgc4QikzKsDiic0LIbZvOwJj3tZXs9Z9BEUiMKwIl+djBFEdz4HKMLEFthUwflB215QzCEBt0PzzVCanQhMPap3FEOeHsX4QjaoiP5bex5sYiJRn3agQv78lEYVx02RRFKUjxpMjFtl+HoFUz3X5eADSJnnscnd0Woj8LUhBPP6JD5s/kBCsP5T54b0ucgjrQJyEEHlXjv1eGgG8ORu7fX++dIQcZPrBvnN5uiNlQG8p/jfbfArp6ybj/qvhaRxbQxznEyHVlD1FnVFSn1TSEDLpWikVEarYruk8OzwH+OB6WaNAlQTdh0s4jxBtYKKgGbLYHqyI067sXXGNmJl90Lc+pGXqvPsiyZDZ3RkDI+Cr5x3tPS5w6NLCSWHOq0+WBc/bLScRn92UfIqFrNgtOcx3kevWY5FpvN3u3LJ5XP9lNseqhV431XrvaSOr4cRecYhAvfJghOZbV9yPzQxVN7slNlD7Sg65vBmQV0RhKI9yRRBFBLWqJFiirPrLJdt1aSawrB6EapJshY7GC6Ql1oBVGi9YV/G3eNoZGFkWEburpxfVq29I+woKRtnPQCc8sDivz/FKJMN1kmJW0G2R3/Neu/kjYcKQTzjg5Dv7SY73rr30AM4feVj6Vhv4gdxPT5BztY/I70FhXeSPksdhgJ1dqcJqq33LiUdqMP8sy7S96JqK9oGSbz5TYh1WDWUfgJ5QnVwIhE+CPPdETEnTGSw+7Yvw4Z/3L4FUjMBM2hXTl6zstbEYjv0LZ5hjGmK8BQJmAmqdgROEUDipseA9JyVN2Vcun6WX9agedKGEtxr4FB6lLFvD964YhL0CDQuXxhk2YE2400EwM5bBdoWyfcfjTiM9cgZQRl6Q4TRjEqI2D3jEFmm5tJl2lSo3MfabSh77C30I0OgXEKUaMTUQWR7P8cNMYmLlIOmunI361K69ZBbpSjGKAVkcs2Z0ZlKBOUoAMu73NhudEL+tLNRUIncY8FgQS8SlO5EIoI4MYUEeT17srfTNHOWBadUzDU5cElHDF3sr4CgiwhnimtFXBg1aaabJoe4Ney2XoTTIaosfwDzl9Q78bWJsGJyLDzbNgt12Yd1PfimNycJOi1ZdxUS7w5Une3kRbQY21EGuOApMEhR4ho1ouFU35kEilzGwyrMJpqsku7cFsNI20pQ9znC6XsbW/2b2+9yf5M8C7NhiuHxAvZOa346x551Dsg28eangupYzbab1K3dASdYQEnfIYo3EqxfI0jNYBKTlSQ/u7WxnPM5+GI22BSyaJ0YoPV/m1gNmr1gGx63lRgHYEmeLzSdUgAyCVP7TfYnwL0jwRRO3uXF/9y4iMj0oz9fxPp43bWhaNc6X5wYDVPigtulCY7jg2oQu+k+Bnda1mF0fCU5iN36ojm0RkuPtPdb8Yt4DSI8tXknzDIEzer1yotZF2QBBJAiwWYUNOBJw/DG7aGCEve1+qG2bpzi8Ht/jXcQoMWBdCE8gsS/2K8p52Vv8yNmSfkcojtDIT+dsXAyaGHOeyhEXMSRjMRWci6R8OhYW4jeL0KM7bpcMtYQCFzJH2H3WseWf9Mzav0iMFzfg1jMeMOTlOG0yc2b7Q+LiSri5Jl42XmwPx3/yoxMBIa8six3xkxyBtuF1/0x81ozxSaNzQyijzIRkqEWAI7psLQBhVoaDwywOerHMdjIlOkxnTPVLFfxzbVCrRthuN/yPRAew3rfKo3LE0jFIEJhL/s9gDJRaGCOoK6mAdF/a8sO8eL3j9KdWv25o2BxLdwGWX24j3POzR96uwCoUm+OkQXW/HdGvVq3T3xenXZVQ/dVs3fuJ7no8OX71UzCx36wSsotVcxKEQSMVCVlo+W7yf6EJqjB8ciTSsmYZ6VyTyBHWYl6IFniZ7mcF8seH05I82dKhOOY75F5AEhDezo+rsLCjBGEXbm02iF57piywMOOG6lWWtXyHrogEWag7BtIDgBUJWk/mH6l42p//ZAE3m9u3OapMtzeJr1c1d73VxtH6hJ+U8Ltw8NRe9KmQZvMg2gqdUJmG17KAVh8piiCebEyqEYa7lKZjtgNISI1xP40VFrZpmuUNVzSb7PdDlwvqdxcDd7wISQ4WaiImaL1rccN0D2iDOqeUBmU+gsiY1ZNnlY4Qbx4Z1HwwmzUkoOWHa5QR9HRZSUW43vJQeljTMLI19RnfFeADYeUbfJo4+kYVHtWwbBGlfglEwOxEu577VXWOZ16yShNQeaMgoW/HGvgp0X3ktgnX3io9qTt9HP7gD4StFJa03A+UOFMpeVMcnIvVhUXhIhS9zgEpTrvmUONcndurKQui46hfvTlR+W/dL0oXpmu7GCjjd1D003WEQ+VXHCkfXF8gwYyjnE/fL58rW5X0nXFPw05fCGHdiEViy7arFw8Cw+mjRJrzv2FQtu1BKdIrc29FtFDEiLxIsv7LVo9dftx+iU2a3zrui2UTe7e5GDuVmtW6mn+iwd+10Vx++vZYkSwgcyKw1EbG8LZLFQGOYXqHhOatdYb4ZkgWEL6KivDuRc+h4hwsuN3FjPPdtTcsDxIaUAlkMU/1LYNGkp89vOVHwU4pDeA4gd7+bZFzWOhKMFgJzIlR3Ux41vkN5Jn3SkWgxuqF0eF5z8bgMtBMPTNkNH2OBF9D4Q5Z8YapHlhUd/HpSsIQiiJKJjK3L5PPXROqQdp5xi3bnJV0o510qCjGSXcDWsvDd2XuqZP8jDKK+Uhxd85z9o8DU9k7+oIcoGU/HOekJ2zzJML6h+H2H6Lh782IVDght7qs62j1riodxAhKFRh39N8Tnic+Gv+EQtDp6tE11oEIC8J+fMJFxxeraBwvgCIWoRu01QctqTScI60tjGr3Wtx7Vy3i33MtJ9ltNVGbkVUDO59utLP90fdilg8QBO4xYG15MdbuSESG6GcUPe37osYqngymki/0oIsCXj7Qku7SCh8QCcHbsgyehYxt5Oz/BATRXOMyZS5G7WyxYJ1fXXhrI7MdrCqPtNiKj7G7kU95CHm7dUP8GD5VgBnPBYcY6he00DYVn/WRMQNyXzCdr4EMvZE/3lTGUHwtcIr2rSXEVwrHE+5b55xYTA0hb1Uhx0uCXhlhQ9gIwyPdXoOz6zCg8tet6sa6L6QtLfkeURZY2y+CNVsMDMnJkpAlUWbnUEgakaItIFHJkDZQWrPRtUjdXgGhtO2msC+HM6GFLNTqGqg9+Ohn8iaSKKUBaZVydSmPmrDD9YJo22i3Y/d/aITdVoUNzLYQhdImrPf5pj/VrutJhxeTmELacL0AZENwMiYl93Ml53llF6OJd22LiXUoAq+cpqIpt38dtgg4M79rQyTkl/5iScPD0FgBJK02ApgdUnVg7Nax8MfFtUuSbWbOXZFZ30DPCYiMagxO3B7gTpkuM8qjFLgRRGjsVJsJzEgYt+AFDJbSi2Da3zsmSyISgJdgoxHuBdRamC53l5qrSV3Y8VlP787nNDqhHsua6MzAEAfsOtBb7C6x1xb+xXizrokKKBCorzvcRt5P/m2yg1+tEfyizPFlHfCutVpIe5x+LcUsJabqfYWjAZBwF+T92uE42G7hPPQAE6ywoTfgJ+6NipxD6LSX9fNpEYxfWnje8kP3iUHgnem2AW4I8pHkSHuM8sFVKl19n0phs+6KFvm+3FnBJLDO4oF71Pfm9DkiXNuAmKyBJzph9wGDc2M5XT+XE+yX5m9azoOhQODFVUI9jii7npF1pcfU/I9seh0w4cUfIWa8In7Mp2bTOM9jlD9TYwxDZ9AZbBFg+CsNG6Pcsy9o4zGsDVGg2BWAYiznpMdAAuTqjhbdWlsuW0h912X8YkSLJLK/Pcf4SBuWMEKzTi3Da6GfA9+/VHED2RwMOdyltxR0Z+tr5MRx1h55/2C2JJnnnTC661KErl5tlDyMhE27Rd0Pt9Sw0k32JiEe2jiK+cNg8FRRkLfvZnDOBIzGfr4GfW/XXGevKs2LzQoAwiOngnDxAFdy/XaB3UbdocVh3iKdvjsj77HNJajT2BuJP56k++UcBa5FIaPQqLWEz5HJnrakBeln4ijVTpsqQSDHUnxoJqRd2eoT1npNVmggUkG6xZ19X2EULjFD4RH6up9I1hSUI3iOryQKF+bH4Aku4dd1g3pJ3TxvGS2qnI6RaaRF69JCuJwBIMfUeBY1qYxaEiQOYO0iXQA7xcTyadz5zvwXjoDYbnLhYGdGGVFrMnkiOG9Mj6/1EUg+wrre/K3kmsdA8nt3sjcNQcK2NQlvzwvF7UW9z635Mb3s28BjoOdpI953dNezBEsW2NsmfRE2hNlp0AKi8Ap7ktRHfUsm1iaPi02DKl67QumSLljM78GYaBd5xA2OId2tz+pSkMcLQHPVjpqrUTZMS8wVaFnt9Js6IImiGMO+nTte7pY9XISKAdLq2LAg4cKozCwULm55V4hW3gX8462IAly2XcV8B53v9Vnr2DBQsGnwhNqS44noG++WR8gpsUuX2IWEGu6wo/sd70z4yh6WJp+wzJ3m4WH584YhSrSKfhn2Ex0R5I/xhMSSYkGuHyHepH49eTkJweAlBJignNRA2/MdFTuN1FXJ6IOujP6nNP1n5Uct6OLkJdDnrfYyqRXRdqH1Sw6u8gD5pdL4ktlSGwzoBdMJu0fuHJ3xAAcBndiqLUOEcVo8WgPAsD7NfSOENFGAd92Yem2BqxbyDnd+dKauIjBcVD4NhTuMuQkOWoKmVhQ8wfHYz1pLTmgP2MiNwaGNn/XnL09r0kxuwS/QjMZKckNTAoowOHiksf3mSuf4JNSz0JpG819L/qq5AD4cpX8pZQD4qYCYzxTMO5yiDz3dA61Jtm1K/MviGwnuKi+Zb4Gk082WyoKeFdxlMpV7PGj1buRVwRgC5rsB7e1de3Ue54TcOo6YjlL1hGtYwXyyBIyawoFANUqbRHxfbKtp03+Rl2DFj6jIPBSifVx/gw4tZFkUGvpGcUKKXRYkvcAyWaKTKoQ8oERR6oTR+dYxQIFE2gK0LDhucQOYzAxlbbKULMtFodPZRcQMezCvyJvgtxDx4HEwqIy9PmPvSjlE9cLFPIs+kKZNeyEKJFu+4unKHEYIRn36FvjWxoTlq10D/tQ1JskFCbwex2q0UuTxowwbhscY/+fXLSoHP4IjObjJYuEbg5WE8On5Fd+axOWO2jVMElxihYHMWwAYfKIAF1hTSjnaPdLIFZuekbz1U8gV1IvCsiQ5Qs3MP/e7RQq01evTFsOTOuFfa7wpQBqvKtZNAk6Df5ZsDO40NH/Xlkj27RvSC9B3Q7SwENZ61z2Ib+OJheOvK3pMOatiTcuduMKrs4zC1PzMBBH6AGmDubt73bYq4Mc39kiWeHRetSgLa0zMURKIT5DGTFsV0A+eYK0PRTSsWDUWibpOeWDWshSnLRDN1oQP3BZACCX96wa77BuOppQdK+EgsovkX7M+eX0SUUy/PfQotNc4RnjCMvg1KAiQrAXWzh8ZMkip66Db5r9hau1en6rmw7W9aqFgZqnkF8OburVQTF2Y6xyKoB7Fc8M5v6Ei+pGXHrPeb48lnkSAWQkbWoGXIvSNGPqjaps5fdmDk93HkvVX78GR23dClc7CaBgkPbCwOfOr4EQuWZ1yDmEa4b0PgynKrUrd8HJ93xNom/21fnp+vwaN9Q78WmqQfzCBGZ4/5vI6dvX6+Cpuvg+GJ8LxH1FkfUXTtwiJ4iISb1tKFdbh8gxrQeGZYQTHWcqbyNfTJSOtiHjRcgDi6EE5olD9eT6i1hmevuT9RY0+T5HrsHXPwZI2HhfAF/FnaDtlZvydqquRqPmwOxpYceMtKmI7YXmrGcWfVGvGejKCLcyzA0TLRGBM85HxgrwXtl0RAAvrL64u6CcORZg1Vv9AeLJz7kyO0dNwW11m61772JYh8CuRTGcCF3cMKSpzLQWnyV761SG4gA5BUtN0Chmr1c2hj3UrE4Se7gZJBMDZLaCYATEKHN5sEucwc6ZRvrOr3zj+Go++ibevdFt0WzGYiyX4EAWPKKaLjja1992k0M4jsAA32EySJB8QJeWEaCBt5KfNSKcpj8iAlhX1/fDe6vs2Qz6XJP7Qpx7Law7bIAXkOATmpcI+fduh9pG1aV5m7MDv5KlrBMNAKZvb57A2FqatZzLG/Tf2Iydse3Szm0gRB+5qSz6x8gPi/T3k3y+nKwI0Gr0x6wTw9C07EAczEmvl3u3af6sBoyj1nN7T7s+c6Dr8WVuto7B81sy0gsLSxdKWGxhFFbHVpatg8Sd7nokboCR8ejVlk4NKB5HsnktxuTINCqHvPuCJ3y14dl2d6LZiOd441Bk7Hk9RRAWg+0wybFckF/nrJaGoG4lQWxwRvN5/TrNIovTQmd8Xj5fFqQn7LjB0f4atdaKmeC9wHgThHKmqdhVFYXiHXmaXipUbClZiDRDB6v+3uhiOFS2tK5gfz9OGUwWhgeg5y2k3txPixinsGDPK8vXgNpCv+yKtSeENMt8BN3UeHG8tUVwthDALy7AAEjNO0EoABMqKDBrTtQHC7Vji3sGWJ/Czmdf8QrXpH7uTEswYbY5hIO2s+/UUXEY16lsi7Hex8P3FizSJi7FQ1nGaclVE5FCvqUHJ1DNejdJKZqt0tZpKr4IIABYJla0o18SPWoKENBpKkvekH/8BploxHjn8Z+2PwK8nxtxrsKrshD19kK4DfIkaRWZ6+/i5U4I6WkDhScez21GdHKGTVvIvUVawQuapZJGRQBBBGACg3rfZWKKoQmofkR4yPygK05WJayS6vFkxqcW7KOUpRKLQmkPTFOgsyLCOQPyk2+LmkzYYihh6UHR4PjIIBfwqHAvUivAg3OcItRLfrM7MtJOcuts4iJIbIhrCSn0CNhmQnBT/XCFAHrqn7pdsQoGKcwwK080UG75G4ie/JvaLU0hbVOTJVNmvQha5eX7tP8xRzNKPOZTdvOxWbPtYIz1jKRXQw5rW1Ziz+L/M/kk2DwY5lF9L+vYteOW0nbo5HEhW9h/Gk9tKcydK0Qmy8QaX4IsMs5mViYBqriAI/7gdOI1ACIcvYECDkmKDFTdlfFgKXR44EN73zPBGu7+gDoa/IEm9Tmaz+jHReYqJ7wv+8eHMMZLD9FBvCTwe5rwQchU4suEbrLMG2qnJDYvhKBy9BMX5GJzuLC5+NQEFp8HYs3gsDxVj0A7/6XUCTD+bllV9g18ORya0CrYaqbgw9mZAeNKbTfRjTp8XfyYK8uAPzGrpO8AZNMAJ7eqvggSuZMpGR95BiEcrpH3htKi5o4bfsM7tEtsxPmNTvApu1D2pYJK+iImhqIVr4vyjzhgfWN2bAYITYeTolDmeUmTg06X7M2DTnCFRcSMk4F78Va++1KvS0Rg+URnq2xKXshJDwU0QZDv8F6+ih2dBPwYoecYsxhs/qmPIQEIidDGUIcVtoqyph4d6LRBvbP1yYcj2sfClHQLTZtUSwTLCAy2Hk43VHwEMH6icxrjFwsJTmz1o+WDdlpJkfqlqnIGqAt3UcXQTURPyuktqXzR8bWgsGTYz3KaytMhRjdu+3j1xNV3axF6w8hN+xXWqgRGSR8E9YfZNPGFCh+LCVyFlKY8oFNOgk+qkXKgJvVHzhtZWWDiZCGjPY05yuEwpf57kjveTqoIallnSVQdP7OJP9cTsJrIlMPuN4wbQKpO9/Qob7HZQJz0kStD70GL+3jk2JSIwjpcTN/uQ4+ghHz9WVVwTHmt1RYqL7EnR2EbdWSekM/hlseokEzj1knJN/YuMCvTB3b36zfHAFp+LgEj5POxWM3wvKgLmeGUhglVjEGIXdDbe/inLUfdioeHiuVUqgOXvf9YdRyCpiXdGvdb0cf8CQcVw73kGXEmaZRwEf6Tj/vhONJXZd7KjEB76oP4jNdRtz/XXoVwn5OB3L0IOObzvoIEo8T76ZB7oZew+tnD1gl3PqEHPxDVulP8IHScBHmflRSySPIEjw5JI287A00G3f8VqbrnOQqNCWZKm7GfuYNHk1Y5bxnlsGhsQoAtIs3ILeqmH7J6lMHCAbH43+MvK+Nf62yKvlOOwcYNC5cPu61lCloLKQOgLk9+31iQb/CHh1kEvyrt0kgg5UccCK3z9U2xs7bKe1A/4e0pIpxFKIOmyeDZXe7ISMlLhaFvwl7RaEJqe+DNfl9tbxsoto07jIiVprkUJTaWSYxCDSozPRXr92k5LDyIYifyzV+viCdZnjxP6jGtQvwS9MLzY32b+gQkHpw2hsW0RlR3I91jMZft1bU/VBzk/lnM6qlbutN94E/4X2HKzlatIP1IXc8BnFPgm5P2DtJm7bq0kgmNMz0jXn7Ty+SZDDg1hP/rg+f5D6e7Zz+l1WyNHo/f3BODdEmlhfRWn0JHQkpIOjW2zhQr+teYSs1cJgca75JpS+lwlN55Uy87iD6MVxrOJYCaJwCQQNFAeNHOV3gPqC+TrtweOK5ig0lGEr9a3p1M328l6lTKHWW1zi6Ix3WUn569HNLjpSrVIK6qy+G+AYx4xeENvJ7KIrlJO21SFi6LgiRDGVGgjmA+lKt5kWVIFff62BZgfdosQVLUCBuhIQ+/I1nksKb5K/XYGdJzJ2Py4oWPKiNLoRSClYXiahGKcEUF+MX2Dbfy8UHIi7I3/XUi14RJD3o1yYpaQZqF3JSQxuDdhr2t1pEPPExbVkel2tf5LN7JKlAbMMYV/sr4iuN57clfm02c/M6RuH4fLBt9wcKh2yaugpwld679Icu5JcHIIBlQb9KWMztSQhMClkDBxeApYd7vYT3o8AG2WUzZ+r8But1Dvnj2OZGQ8qRG3E5IKVLjsIWWAao3Pf25M3IQfwJlqHx3eHwYg7MriO4bsrWqoE5S0uwaUN3sv44eNzgmuTTZtH/cmaeSiDacwD+iWn2TabgVUcl9nd/sPMq/r88AvAgT7OtTJgATHOWRkqfzbBYYvRAGHFJqoIdhlmyIlpdmtYHom0DoQI+USgJ4JQKPdYHyO9wfUXdIvvuAiDGLXfl6mtMn5iTboUbIay2e09oHKY+7R6TKfbqXwjW/J3Iq4IY66O/67iKkqxLfYUitWI2M35sVXDRX+D52MTCpUSJZqyA5ssZfqfvJwfbLLSfHzGzTrZhT35+9m4KvbXXYtxV3Jg3lqCAqm63RJWnfnsUWhknLQqPTwyShoG7qNgz34Rj3v+vdV3f8r5ZwV4vso/P/4jD0zsP/U+SWHPEiCxWyvtXg+8uRyaeAfv7udCxVmNzPdzs0k70PZEjluGnPmVgxlnQgR5HxhLM2KR08G6fF+ev7ZasxBEtdZXTIbLNM/lGKGLelfsG8y4LHDrCcsLeST76o1hLXJOyHdi9jjvFrIa08M/5amsOIjFruCDa+49hPwZQEXSZjqEJgWR1x7FjrW+oio3APTJSiAduBF9cSdaCpxj3qezzodcPdagSSXlBt5Y87tEl1eatrNQFR320hjc6A45KFLD/4QN4vFSxOafHGPIIPBDS5kDPITHIWxN34WA39o9U4FD68Yvi/2KnIgPxlnikrbN/+gefBJsoqG1JZzqNwZctrKgTk+fcIIra2fc3vdStfDN+Qyz0aa3L+1Uvl9XXkr392riyFZoomlzKrcMKCi5Q5LM+SHYci4RYTbPcB8WuDQeDs10r6VmeBXpMBVN8KiJej8V+IyP0p2dJWS2/UzhJ37CLMHa9oWYOp2w/kvsOwzG8vP6oIcgQREF3OcJk0z7YbGPQCCUHcyL+vW8RLpSfoele+viOqMbJO0XOPdcMOJaQvLWBe3SuiD2VktFvDjJu1nZgU4pRW6o4BDU+L9FyuHANY+fyMHhBSGJtR0T1zc1LGlEtT2V+XTTNe/f1kZGVZLf+GWo2gFoB918NKvczL0fhTXZTUIebVU6L8Q7gY9ZocNPy4ThCwBgMrY52kqKPm66WyxlX0CG3DZCo6jA00TK0g1/hKOrPaWhuZRb3YpwnPpAaX09EMcOVtQiqwfCMY+JbYCG50Ce90Mj14PRUtTOyUItdVf6L6VixJB31JAkKqdUPRXYI1vvJff5yrCoqaQ2TeMIlEuoJKYDQKBT4GEucntUUNim+Qdd4PfH1eJy/Xun3SJ0dIy4tMzzytu6okVjL4+uMdYhghXM8ejDfZ+0GhCZMDQrHwbKC24a2jhGy6+u9fPN18KM/PEh3hDxV5h4wb0JGL4DRHbZhMbxJeCnyrUkwq8VCqgDpK4KQOFxR0Rwm3MXg+JeY52Wt2hhhYP/+O9AaTA2ocliWqiPxUlSVwKpC0LQGkaiZ1UvEsFJh4yO12xePpu0hJjgGgi4AEDxEIFns5LWys0hWW2YIZOkU8yfqRLVutC6hnk72ogXE2NGq0y260ZKxXjRvI+qIHQKpOg62Ur67gF0Zm2OapQWVshk9ciPV5+KVgHQdmmJmI+fU2kb3C0r6aUn6XOpHwmrCZlXC5FnHLRtKvkPs+VYA03omL3Ruh9C/Py2Btwmva9xienwt/fBJ/1NTAAbaysB3v0+9TL/saVWBSdFGTqqbTlZ5c6I6Hu6MjA0fL04/ZjPDGIgSoycDMT5EncdgVnoC1lp+Ev0Nz6Ta69YrOrNKl8VsvhhAI+0UysFPvt/RdVE/JzaBtJRNbH1w27W06QlunyNOqTIvGVD6s/i9yo8Li9/WveDDsZ1p0WDNKJTH4bavFQxtqT0/MIbcyZNUzy1B30VKzZ377ReqAcEZC1qUdUzCXSXOoAX4+JYg1b6cX4Su72CIqd5Jnl+uIia0djcvP9QYdsdLb93qC6l6FCGAlsxBrk0sPKu4KoNW46lP2JGjc7k2VqPABwEV+IL7Mo7Q6FnhsVrheMea7NF0Z6MYqRrwXQXYjDl15cRMQAD7I9hNUpM8II+/gPqjFxnoJ5CSaFKvbLWZui18YZdjQulJaS5jCfL4zLI2GWWmBjl+KG4JJ9azoKQTsD6t+7n5Ywp3KpwVLMvgEITo7aedjlr3gTWphDu1LiC3XqzUcD8HCntmI0ubTRdIzZEAOgahT406/48CRsKN5HZhi+3ZoxXHbSF4BElFMObgak0zQFCAOE9f1cNuC2AFG35I0N8XGsuKmRu53DDcn8AGFVRLMZJ24J7PBB12KIoCn3GWsTq/C8lNjRspfhqZd10aB9MOcV3sRO/zEzD8igiNiMdOVx/QTmO+IXkSwnO0qimB1YDmOlS74/9+sPqCSp+rdxwzSgyD2uq6EaYD2a0E46CFtQ/4HmXxAqOJyQabvCrUHE8t67SwmyiMwDfFydDTKBSfSfI+LdOqvdc3PW8rKqZVGdXnDoxqnhFVPjeijpPzv560Iz1TsdkwJbo6ic6G/y62r2LuLVUAkXtKoUDwKmH0uQBzL1OUNZG31Ce9L66vWPvvaAhxG2dx+BgSRQRGv/H6V3cVpmZtracMAVT18D2qwftXrlsiigenSrE0bHK6yiP6F3I7weoMoGnvnr9ybIWcFg32l3WDMyj9V1/Tulav2Dn5R2HsTP2IpmnRsTUVYpZdsM8iyrFyWcWPLHtLWT3iF3zDONzhzXR4tIYwh2tUQSynp/d/PDox9yLTpyiTQP7HYOlYhWI9T/hBFpqglwybUn6gWj/kThKFNEm6AAid5unV1Sv8HX2YqRyDMf2p2wJ84Uu9GN/AdqQx0zhHDAT2NFHfewlG1BfeOwf4bvJ7sf8+rTYHc+S3sWtKsXOVHMRDN+/EWru8KHya5xzMo8Kea6VM+MIcI07FNQleZ1MZJR5SQ+lmcrM2T8wwxFlfo0Vj1L8T4j/MuMcoHdPApnG3N9WKnBaxuILoUXRXzyY598gCY0/Dq4umZ29lLPY+AoUfiH5Kw1eeHRBL5mhV9HbeX+vv6BJz8bjPO0IfAVLN+SLMoCjob+0oMOQP+BFDClQyCieKpSdhOcmbP1irtbISK2lvhHrln1NwuhJyyu7GmVYNaIXS7U2YShgG1vQ3vPDCYZEnirAXgIgANSStHgjtpDmo2DXwxTgjNEeDrlMgfIyu0RzPkj4bRstQZ9TJ3q40EDOsNpuRaP65bAoCHcmmgrueeCF1Pe4mhaTTKxS/DKl3EA9Dksxk2wHapN7/9tcFaGn1/GyxVxJaOXmlgnvpMQwfRm/m7G9T739p57u4DOYpoBuMPquSaXY95kcXr4V2U/aebqvbiXKlO9qwOd5YDGRRb9ecJjPW76JGsjbtRpt7PBScCzVd3Uom2GkmU+5KqTDZPkHD9E+B7EMbmhBBZsLSJPqjAsjipM+rPS9IP/BG4Ob7W1bzsgcNPQs9RUiKIY/w3Ze1s1okmjl8sxzHluZY5MCwnUdD/yGfN0OJETv3RERdYyFPvg1iWWMZjGymt0bGcG9NBPKnjj/oLnYsQxwlayZL5W2dC01h57Tpf6GTdJHIfzgbsKoQqouao0D/OrDt++YTZzEaESPCWD8pqfAMCh2rXwhkK0zObbphNe8dEnVbsZNEwS3n+MP6p5+TzJm4WLNRDnwhGJMpTjU5nF6D5LJJpJEKfDsjnZwBz2jY4BHLNtMWJoWbMIlEEqzX+WHRx26RzoKq6CH3q+s7kriGQyELduMDpQZ5rb8q4N3GCrmkkMUllPHPe2n/E+Op+ermt7LfpG+kxB3UNLuwUM9fC4ahS4kDPE2gt2PAhPBhIedP54KfIg+Z6u4QFcupQ9j7JZuf9PH5s6/zXcQTMbS3aJS5fuOCyurv9PV3eaLacRcFcrPwx2DxC0CFAPNq34shfWSjxL7CwWEQPrNgq+RXpZFiTKEV0izgsSW2L1MO82N+6/RbK17K2eVkj5YihIeJa91/RhQzPCbbJ6Ymun1rjdfLHmGXgqPjKVFG7OTdF1mRQOk2VVi/sFKFBjhHwKj7Mhjzpn/K5FzeuwJaLteflyQY+vYmL8jyaXLBOHLAYywcMMtT/ROQERTT2nYVnJ3xS3rmK/wDTVU0WBC22RWFUk0hmmRGxPP4tMd55W9eN8zvfKUfjsB/KQmL8mKecbeg2CjARsk6n3E8qwFVactdDuu021r+ZpQOdqfMebj38OSRxmAmslvw0CHnujh1vFMJ7BiFwplFeADaPvvU/f58OyVRgqbQ5IBziD+EYYMTQYxiSnfslxME/rZ21SLT7GbIbRYUkj08ESmd/lTnDVRd1FCLkuBsSEYBtxL1xm7KCRrHoS4tnD60GMtICgr1CBWY1YhmA3AmPB05qVeo0Shzk4csy4COov9uzhOrVHRQaVY33LiBMvr9JTPFE4vr+KVucrCSKf5NkVOuAt6UQGvI5bmd42bLHkLhX0HVD5+6a6GbXOFMoBVeoJBKFmxKI7ryX329mqK5p2DKi2uoVdInibxTMpvVxgkBGOkpcwaFNt2PFx2y25pO0bP0dt41kzJ7KiAFtSA2uc6POFANOmew45sPOxxYtDqjASG/4IOztO0TTwImjB8oDdxDg76OYm5M7hl4vE0xERXKVT5QBWURA3oYUvd0PxsMl+WfgJh54+PvXBnUwAc6tiHUod+oct9aYal+RlpWkYrcGtP4PsveD4GJx0jh/AjjKb7slNKSga2gxyI6PTvAYnlKjZ4IF4TrQed7FC2mYEtcTj1mX1YoXzrwT8VYui92/bAs8Sma9RdJBMFLwts7A+DOOryZ6NzzSvAMN1e7L5kbF6cumrebytE7r5DlS6W9HQrO1XdcQYH8DuVSPOKSUt2/JBHdNSIOKCdEkJGzprmgwEn3PtyWRSqIZko1PRPs2/xfI/AMkI7WR0UjcQvCurNOj/eYQF+J28dxB6OG6jrGDZlGBIIoci9wSfYz2S4XxIOcdUTCQv/U9Qxi8IyakGLwoY+PVZDd86cf7PzggvyCoVEDokzgbC/Pz3T1DwZ/3QeVIdmaPkcf5TkWYdbVz2dMEUtl1UuW4DvsqHMBbdknJWPI/1KPjniPUj5djjl9gE5aKVLtyMQBpZ7sCJb80TfvISVwSMz7pXUEC0iCFi1h2+yCrGkOpqKuBaYrlk18bc8Om40+DbFSgj3lxRTy8YIwBrZrz+XsneE1nyCVCCRQVQvSkIaboy7TZ7IxbjI/GJJdHwpL1DUaBjFWjreXYEwgs5jxF332zc5/aU2G+iI7CapzeUcVP6Glpm8jvG+p1sOEYh2GoO62OqRf94eUSLZl/tHSDOv/zbkxEVZc2a727K0Y4a2LxQUYgOBylqQTIY6Fmf9GRq6eLbZ7LQwPQ2h6gcXx1Bl1TDu0bZJmLhYTCbJZoeqPfp8dKHN7M8qXfQxabPuj/e/Wob03ak7Mt3JfZ/1jxoYRwDs7tKJbQfsZ4MGAHz2ixsq4iOz0OLJ10qLVBLW1UvjSZb4Efm2cgpa59ho4GA5jxnZBQFiI2ZkpteX7IlJWzfmK4qlTyLRyGW4/Al0IGh9Fxty+8PW33HnkRtcs39d9BmCt+GahdQCwfJeLQmVFjozIeAmUaNLnq7jE1aqb+sl3IbcezT0JQK6RalRTGfEq+0iXZC2SPCsH7XaWWQlTtpWBcGNIIlm2UlfipxfkPQ2ZI5JQ44smNTUEquQYNWuAtd/tPu+8WYNPwxg+w4ISXAYsJEyM32Jf61UqOp50kdtKjrjFwaxYdSPeZLIkBXFov7bh7k42fHsxHnjw1k5jNeQwSC0OvGsrzsvjuE3MzgHQ1OYtnA1oWg0at1PG9TJfFKUbS2VQzDa0lFBoRT5Db+vCQhmTtsTxe6WW/Jc3IDzVri5TzfkvVq3HBjpa0ysqc+HY5hKsJZ32tMK0e8brrCdKbq/1zKcvpH2dndaizNKPFf1M+//Gd0pjhhP+4BMTiIFVbGwVSwcme1I7dhmomRNO2KuzJsyQQe4p2b/MfD4bpkkHy0+5pTedO7+i5tVgTJoRuJl8QOQ1xSs7Rn2T7gysQga6XSjYtfr+TM39Att/E/33rT0EZSquQ3VRXSl1mxMf+d807L4r940A3EqQMo7OAeblHn8yzA7ZVfepE7bqdARF6M8KYTYnw0QcFYUu5W9cZFCplQabgA/9oG0lzfqRFOcLy2kIIARxidZHajcrGD5BP/iQ+SuheGZfOdqvwso/pVet2+8te9lyKV1MtO3NIRRA+DxqerNyLI2Uyk8bMohKLG1DYwg3KN5F918SSHvAWh774FoDPZWkDa9jaPnxuDZ+szoPQ1fbpvz+6Vz30ggqwkdpFbPX7smjQgCj1Na43nMpo5WkkhQeXNjzf/fOX7G4av3/xtz5aoZVrdqdpSap99QhewRLtvKuT+6fEzORTEPO0Aysvdpabk/jY+9/Taqnd3JoaGlw0/DxinyRk5wWo4628/80vnMPret+/Fb/Bf+51R0K+i4kkH4XfwTJ0COH+rVGwI1kV6aA91syPVYW/aaqFlU8vApTxJXGKKacAMIWe3s93z9yMt8pLwye9aBiMhrsKxiYbgEhnGOk75bENfwW9tSUtJ1uUXSvJUj8EJU+Qe5QW23Y+HDnvowfTCHV/HGZxEl+OSOOwHmr0d8QkH5yChddBgNJeduAXsN6lvwwX7Y4CDyKVCDqq07SVT1Zl3lspq4i/NE/7bBGj+NIBeS/8tPjL6bkgh/xNG/+K/GaHuVaNxp9LCp4gm3+XWvDtB67NaG942nmT+yRpZkT32oDSn0HPoDhRR/g1UZFia1xt3sxdku6v3NZG1UAmqJWzesFpv7jKD3YK82KVYtUaHIWXjsZ96f007eP03SLTXzMkiaAE/TXyl4pMsEHCEIccLLTg3xoGw8R+bzWES5H2nlYA73SZD2fwR64sZMkkHQnnaasRX0gRR2Ko/paPtfkkyI9OEZN1d4QHDBuA/dDtZRo3Rwk36FXzPM7eQC+YSEcWLqgHcQeSxANFlf3SKjUlOuNdsXq5CZxr5ACsHEGrcpR00OF85Yp4DYc+JMREPZ3If75+80xot1/Zr5VABBHYkj4usX6IgZVLWEj5Q1+H6n/fmi83U5JsocGUsuGy7HxHLLx8JkgJumNsUFYUB+W+pMVTcga6kfQn9hP1s4a6VfCmhUaoSVALGZ9Jdt1WOWHIJ+ZgS0fNEzQzNgCd9K6tPE/drf71rcmnwpYlfPmk5s8vTQxDapZnSlkfCBcwCLQReBc6oAAWerPhJCky316EWFsVF0Vvock3/HgS7RwO/evMRSacgkdkV6Ou/qqd2RO9NzfTN+bCXUYjRNW0oceK+Lh1QYiHXqxFN9tNJFEo1DQ+9ZLjetXpbj1KAAR7wHt1oEmsr3naH/qdn+/PNl6uC5zv6LmJXni07Rt90xdNcCFJ2mRLABqLQ5RST3bKMC/vyUGWViZ2mvelTG5QoUU22P4T/9C4T7jXrrfKQYz5JHhuBMIahSwGPWf5GdM40St7qZ5RT5jLRxLAJGRGxmrXbAMgCjDjpluGuHdVMrUzmS+iM/J42PcEml5ogNYM6TKR07uoaSQD5zWOEwXoNpJKF6HqjWoj+iNHeg9cjYSdHk3P6p+4JR7Rwozs+3cSz2cEZFJ7m9YdOjPi1fp3FAoR6BeFf+yRYXFvf1jPdnmKWXFXyP8mB3Q5fMAkZBoaNj8prBIawUkMjjNxB6Ojni2ABlvv4IgsNvsw2+bIrX9JwEAJMrGgQvoQSuLTfg4U2WLT84vShNK5yE72U63jLAJW87OJJMDFYfY6hYl+/pCHT3l+tqhY8LgiNog7VnlZNJ8Kq/mg0NuTOokvjT8tBGhcI8lyWkcPhWlXGAyCCuybJ9iTAb9r8HkREPvsPDbWVBU24rh7rz7CVcza4CEiTz1xIIW/+f3Oe/BdE6JwVIvli5fv45zVKPktQNPjMo6/7qjBCicXdcHwjHNJrcTY6ad19fHJn2kJxEJ7Nuu2MOZWBJtjUXi5+NQS5+1D3GupnHajy2x5kMf8dEWpWC/vT8q5LU9EDIJmKTKixcQZgDZWxyaABqMVLLPdBS7PRHthb06ZRtqxyZk+8FqgT4vDp13j7x7yNKoPfRHb+6PsuUVok1dt/qdi685ukjsdNlJaDEIRPnaJCxDJT5G2jtuPWTf+J3ZmYLCzIAtO6B+y+ZZRb+SXMu1ba4v+Th8RNnxmNQu/S/X+gZcuMGXkPHCZyi12gOhjORTkgyk/69azw4LbfKueH4+FLO/8io2Mskvs7KkyyWdbqlklSbH1eJDIkZ7gj3kAAjRWSaMaJmH9Un+UrLLIJ6lhApVPGjLkyVnfKKx0gHTbmoFJZ+xwkAh0vgElxVaxeAMHKMFVlqUYjOoRjwJBxowZp6ZmmM6hmcNaW4LTZj5vDpFQEcETYEcPw3quBfTGsx2VfDp8TtwpDHHYp9WGDHf/WpVrjOEd/MMO2ybJyhuQh3R3dkZPQ6PUVh4CdgkmzJZhRr4IGhYNKDnDk7BcyFizSz+TILfrBMzLddWgY7Rsv1CGbu5ayyZsW8hre956iQXxMsSUcsNiIxwGyBbitYb3cV2y4unq7O/GNgGI/mXMGJbfVWScKLO/awK1YuRZ9O3NK4SQGHvYICnJszlmlYFh4+vz1Jk72FuX/TgOCrAU5nFad3nfiPtyGbnsRzwt+FQPEebbeiEJm52igtoerVXlFrhAhZf/dxF9YJUXGv+Nh/1ZttA0JjUr6KbaAFjvgGExdbVI48kWu3ir8ijwOyZosnyqVmXMulrjOls1g3c6LJJq+tQVEwk3eqJ1rqFC7qEI11G+/+gLuvFyOphb0J+UExJXTw/4zatkdaoCS+27ZMUa3p0wsYTZsX+zaQiC7oKzGHtZYGr0hGe9e3ymL1RAZCXWwf1pA5nL9l3g/WnkyQC9bSJ8BIGsPWDmyXkS0dENzTMoYcCkCsGK/JhMyBFw3IE8/fJ11dNtRqQOeG54HQf7sPSHqtDjwoyaov80kHLxmmJMwFIvVtaWO4XiO3QVAelY8rthfTvqHX+CKSKXLKVKCc7infnxr9c8HTrb9TwoO6shtlB1+w0ERfNPEU3vV9cdzHCGPNNSjY9B4cIXwOY6Q9+ZwoSUWPxui8YmAikFD9E5duwLCPfoPdcFV1iX8GSrV+WKOH+WsvaLiGco6sZarqniu5OyP/szBnKBrMBZinm9/6XfAIssGXsZtaIhtP2S5BfngWxdx6YCJSqf+Xpc9tp9hkzUC9M9g/GQ8Qzf3wnFpWc6cUrTcK/oqfsLUXJBxLkhNtQ28eo3TGkZtUy1wrIoEmJ4QCxd7Iri6Laaloht8IFufuocZorh/RwErSrnJgs4hihOWcqjizeUjaIfIzcXxmudMSJRtHJNyedD8OICu89sSqG85pzXd8ZCzZN3Jx84yTEbP4mVaIK2AweQB1SWZkNeEJItWW4Hk32v43TFbfvMR/uwENjoO7TAWAzdcu2nnvo9Vr/xWmKEclpyzwNd2I1RP9cuiPRlcLJ8nRd0nb1/bKQG/MIU0yjFp2Yo1rkDdMcSMCpN/rO6x6j/Y3nMyqVUcUMupA9BhjwZHYHW2Pbb94SOHKBrr14Os2k9L36Hzllq8y11DhVU5AGq8SLCWFHRb7p3ldcitgcNzYqG5Z4/ozAnHkwsMse/qU9tCM7oNbc5NAE4Wk2V4u8Ee3FJF+w4rioEbTyGGZjWgOMI9vcBJO14GHgblbVBLm0sPBODZaGxb5EfzNGsd+ZvIMmv/CpZTtnxoW7HFadgw3LAeVIfDd0/vkikym2nmU1T5cQeTDyHz9YBIew93l6Dqehzq7D7IJAK10WIkit76T+t23iN5kmhFVMmG+2bA5L3C6ZPyRMPhHQZIW2DaaaYA4hM62CrnniUPQOI/saikAcbcvHQsgb/q33oCNaS/Z3KRIMrGNF43cOViILKNBSnHBT0dngiHf5MaR2PvhTr1dBO6vtAuH3pOKfNXRmxLkTWuxqre4UGShKyfgFSElNm2E0qqOZdfDUkh8h2yN1QIiUQs5gQawVmOh0CyvxbVuCBw74D0p+Fw/PCyPuPq9xZV3MhPb1//yG7I1TimvnM+QUpGpMcV5ZRB+enFUsxv4mgp5150A83034Sb62fxdbPRNsETQKTJs7edSwzMxa4yZ/OQpri0vQMmET9HXxYzd+LRKU1+TULAfPqDpMvZsgfrSIAqgn4Q5XDttd+FYZjyWZ8eGPvXOFMiLQ9IeFslFEvsnhAwvUKPyPqPDKUdfwvs4So7gjfaS2wQn5iGg8pl0NmpP8ngfkgx+gkR0Ukvma5H5/p0hinOTwCcDaoBRTzUsk062E8A/uLRL0T20XZtVOBXa66KVyFRLnwgjd9/eIvXYypxv9ubbI1dnRvp9O81XvIHRjkSJUsvvqmvMsqQbcZ8SzU/eT70M9uyZUo2q4xlXjiJGOJN185XITPuNu+U9GPhr7QW6AxFwObb3+U+z1yrP5BQZSaltV/tAMtZNWvA9+HizetLCEO763E9bOiqGA3lXZ4YiiOQA9nIyoIXI+Yn35v6X53kw5rKrRT1rkEV+aMa9MNi0aMsBVaM0E8GV30ZGgLvaInecaqbJXCgETuQAvwDmDw7QHySwR1VPhgjOnFDOZ89WyNhv2wCCCSkr/VgvZQgJMeCHuK546B6of3BGR5eyCkJtYv9UUqq/d5aeb7cp7+RBGYe2eG2T9vOlEfos3vvwH3EXe05nbeyEAv/r63Oum/jzwRT46lrWVP2lMO71IWpBoQma9Q6Ge3cfrODNMCaY6zW1bfgOgvzyk3cvSeUH/09AGa/wsWv9KpKOl1lpusaUCbDtXR2SQj9Y+GYle3hj31C9WbtUcqYkzHGfkOQOVPEG8kkdm5xbeVTlHZJwi/8zQxzFyhl0NEj/CeR9SOsuIMijAuKp9asijTIjRa6hd9w/PMuzdGGAnLRI/TueAdxqwz7TGiyoqXROCgdbrjoZTPCx/BRyNaSrZwAEmkd6QudM0/a/QGB5CehN27OciT2OlArCNi3cMIG1kMeRLSGiuBY0C4g4BKxYOhTnOtsqKdFVWTio4t2TW+uOQkKvtUoe9sQS9lmWyYZXt2AteU2PeOJj0Qmhfv2Qnd//9O1MtbFEG6HKDS6wprxvbTYbTNXroapRJcnlsKf3kJilrn17GX7rHJWuIRChfGr9mS9Z9bhdWuzbSmtlk52oQe81Pwq8cSz6jTQpyRanObB4TxrrH3BmRUuPQcc+FTNFJvb6iJx6zk7inQu8/FcSISGubr0SOaBdO978T9iyQCkYxIySS3WLzg1cQ0EkDHpqoUSE8ue29EAVywYYl6Sj4FStVjzYa61Eyw6DW2rGA52mtliB7yNrt/z9P/i7NDrKvZym1Bhhr3dq4WglbdBBrRNtvVZDsihh9DhBwmifFfzpNj2B0J7GmBv96H8Hmm8ERB79UFG2PY9tidihRkAMbTsWCttT/SMc8rK3bTIr/Ytq7bIHPAP54fpKPxeNN2qk0Gw/YRklflLThFubb9/nzCYFvwL6r00Ee63KtBRxEEpZInqI8Y+kKSD/f23+C5nLPC9HMe2mm+hpJA3SNZ+cwHglZKckGyo26YfB2ZAykCt75Ouki5+zFVcUq04eZqKi1PjgSjbwgngBPOjFOkON/RbQwb4BAWmvtTEpG5n2NQGLeTVVRJoXccHikqTT7Iuwtm7daN2N4h4dKIEUXYGB7laSkU+iIZ018aAbPUK0Ssvl8s5SaF2DAn+sZisZ1S2uPzEl0Dv8D9IV/saGPPxbfWfe30IeXgGZ0j1tiEXlVg5RarISmSiiYKgmimd/fQGcRfFtbOLQKvVPehOsv1l5PV53yCvBSRS1NLTtxYf36AUbWaNglMTNSNMpWBUt153HUBnnQnGkzUyrqRCztKVZsK78EbIY6YgLxb3YouUjSlfHSfAHxKHR+MPmbPjh82gU/DlzZjEWk1apJDcJGofhyHCeN+gWDQ4FWG86vtv00et4SmFZMaFx2WgelKANLQJX1occ52nGhv9yW3jWS4DbeT6N36GaZ0u8p1SndEDxF7cj1fJaCrp03kh70UtzyLlrDim6jBHy4iHnm8zdpKr/jcKb5W7IwfghSgqaIhZ3Ce3hReLfSTMYZ+ZXZZV1GULBbteJLEx2cIyRbDi4i4hra6RQtQDAnkBxzvJQygJqDyac9LQ2TJhG2sk8c7d3hOY9AlENcOBRT8hnB8BGgA4Intsdtv6/eXafrXluNNa/30cc4zlnKT3Reow+/e1Kt4YJhFIlLLTIJb2LOIda+pja4LLMag6RUdC7U6US/sMW1xzxki38RsMxzhz+tJadtnn/rSdcpveAnRj/I+f2Pz6bHpNvJLuLiwTeYY+ij162HqQ61IfJ0uKEwC+mhWrXj6HhNd2npntFofMprjeItbURixEM/lSVSFXQKYK8bWQQG11H4xDjnAxRpCn5a9KLs5d6YJ7+10kQNXY2PKS6cdpivWvLuR+uAGJDES1hwbie7Vbj0OzF7bPPhy+sMwysK4PMSjvIqu7yJlDXqM0i9B1nMjWJXYfZiZBl598N34NnmiiiA3rSUTFKMj1H86npPxs3icXBfEhI1YJOdQ3ctDZOrCeGWzUQpkch/hcc8ZATf0VqG1oxUFdCJ0cUIwA/W1le2KPJ3l/6Yi7PXdDLzu3hZmDi9L1BbVXo5Jv2hz9OqTgKz5tVbRLfICwwS0pubV6KhGCQbKbvDXw5w/3lxXkW0DeFvDgPlU6JdSqLy0qlJI6IIcgWJEHKTbphy6v3QTDKMT84MeqiSEGetPGcv1idhukUIqls2UUnTcsGUtpbmuIap6IsK/KJTJ1Iy2VnCTXao0vp6UsXwqQA/Eyy/LQtpwtgpb7Djlm3feqv6jgAkVugGHkoNR3XT0vtVErqmchsuf9Q4JLzxQMuv6Qi43sXPHPH9G6fT2d/qeVC8Efpv2juQcsnaiJMTWhrZglOJMzkrJEkkyMdOMM08ZWieZDgvVJbiTwVsq9mpoD46SxKYEp2wsuCWcxTI4+IBrL7cVx60ExXWTv2ACly/kC19/3BviZ0r6H9KRLYl1iuztdSXknhJETYV6a5SvmiK7rPmCSJMlBA+4dAIfArR85ODOMBbxqRAnwAbxE/D1cGlYWu3OFoBE9g2WxJmfQRzhM4/YIUzNO8v+WEJNeVG+w3eLVKdXC9wE4PJdJIwREShN+vZHyzUsSXDBqV7+vVZ2qLsBXtGqpWWv4W5HnZj/kouIFOAHP+BzksX9Ex43UhPOu1xvZGVtXYZAcbxCnkOuPKXBm+bKIe5u38aK8YJgPy+GEaEyzcQfClLcEgG/cT+kEga1K4QoSGL0CDUcR/gc5vKYpv8/RMEWQQqw+EDxjjk6BPEKRzjkqg4eCnVTZ5QCiw/BzJtm4lImhOkkn0zT7yJIlEEaeNtAZqBimIh3tf2E/hMZnCVLmiN49x5vxefo10PSNQwgBUyt14McKmgdCiTbn9FDz6gu35N5SCKeZ5gUgAT2vo5Btn/nJ4pkq1vii9qeQnqrLuW/IiFVMZ0SqsyqJIJH60pBBzOXe2s94vcbZ3U3YK/x4xAoBUDxBhRvbuuWynf7Kt/jdtpFR0gujytNmxp4L5jo643i8b3RXyXNKx7ZcXrqTf39sjJ8KAesYXhd08huyplxP6PrsE8g9RS5YlBZljOXXUHlVkQa9ps22DeVExUFPuIpbo5Gdfr9Mzh4YvMKSgm4ethzGc1v68K5ZwKCDwX+Na55oYQwlXtfOqdNCd3XPP5VnE8kWEparShm7jynCqrp6I3iXqnHZfNM8wakaTP7UU2oM9PYvZ/smWfDw6xhCDXFnkNl/fYlfvdP60GQ/m8CtDYWwffkwB+gxP3ZaeWFvuTivmbpYDVARAIu/eLJWEg5GFaJjeSSL8gmuB8JEHJdJBFbXnkdf9w1FgLsIu8+ZVAGnQ5e5JPRmooHgSPcD/B+R77BoqElSTDR2u4mnK4ZYCkpKcxc291KG1NpHLtKXbGfDNfQ+CQf1c36CZk6E9mo44Xa2XqQ6NlMNRte9awq215b03K0swaZB07sG2LPCDcaICkZU3PrmsNZICqrF9vs9stME2+IL3wE3pycx2FO+AS3uPkeX2sCaf2+lWfpLnW6Aik2b0wO2H8lNSOyB+btFnNNbG6ghrdvSs3pZCZ9086DDaw8yJCbAwX+KGbdULZ+RadJY7dU5xR3h+e/qn01pe0XhLCfgamHHxhCtxQanz+TMyi6WzJQI5ACMV7rJeBxIdhZ9QxamB50KQ0x+A34hx6HNmIyHGXyGDP+qsw7cjEnGpEaL0UxtWnOyf2g+awA/4Cu//aQJIDC0aNwCb8U1xOiPi+SdmRpCRMF49skDljeLC1fCIzi0CDqRSR91ynBhOHtSTIporAKXqpDRW/iv/jFx8lT/a5rgy82YATVFf/rbXJjGlNM+A6Iej4OcsL+dmnamozWRC7FqcpgM71A1JVelBdNNYjzp28vC04AY0w/xOer7gLjCysrnRM60Q+z4gBdSIVERKDNUrDdiG8mWQ7WOyWVuW3iLFDhz/6ykTk02J5wIwTpIty4Kwey7iYGgDLclzaVFWd9P5gO8dWHT8rUpEL6t0TYudA5slEDlEZhkxLWdA5fEMJ63nYi6FCb/AI2gbbHdklDZL0ORDSlSl0A8tGCdD6g8X4fd6fQ9su7K0tj1VfrgFFCJR3cgb4vFTp81lPNKL+CFvDJtvluQ9ZxSVHy/du1Lv5GE2HUqYKseHVtIdh/sYGmR1rZ3NMeoUngkw8BV6J2jSDlwHNxAhX4QqSVpg5ILfP8t+PbmuIzB1Ku751rgPDHxFDUwqAEcHEJnr7T/a+lJr8x/09P7bgzUwpGMXzvkH7IWOQPmMdGdi0iUM6qKk9D5s0tujMabVaIQCZo8Qah0B1oSkBKwNU5jDk8/KDTvYo565PesokXBAkKjnaLAVnV0xHY3HK1KZG4ceHVbaiqOM6f8w8j7XVZwSpovIqR/zQp2TXtuYv6FIl9S5X9HdamwpuJqLccF+XOFaXMvzROx9YcNTTk/8C+OSIAnw4Zq8ZFfp/EFhAKSUtfh/p1HJl9nFrBFL6tJl+s+IjSaahw8q9b2e50sOAF3w5gr+GRT55hjOiGh8H43cCq5YUYRiSPX3l9hlY/Votu1T5TDq3U3WDdUyofDb71kJ4OTwRF/pzXwgtjYMNWoCOsq3mLr1+uPdgjxu/VDfCl8aMTwruM98t7QmRm1VPJufQIx87D8HVeaOG5fA+YwREIsCgqa8MGIqgM7/OsM2pKT/MTatMSJZlb1gXJzYFl9WeuyFb299qd/CAvb/J9HVB/gaFF1Et8GISzP4PuFn9CdoCVLWuIFqTpa6LowT+NxI63MZ1axD73VHS6ynspRA0HZP9TAYdoHsQl+y8AgHwhpxN6hrGPFU7dzwQUVZEq7vC2rYGi+vEv0VQ905Z1vps4P4+sRR1Ww+olFe7JL2+1ILyCbW+7Afe8YEM/Y6lLSGN5yXhxJtBkuF0tS43NOEdRvt9T/mlZ7+hWg8KTK3orOM+ykY3XJvdoUdtM9hHy1M3XiDNQGYMUzBRx4bnOOx8qTgY0X3OsztdCnDi6nKWYN+vz3AlKcBt1sKbeuS9yKeGWKWIrLO31lMjen8uRS48x5nO+X09e4HcxZzQVWr3kwOP3Yeeh7WXFak1V6IlF1/kRlsNF66bXDg46l5rqN1PPTPjG+AKoz0DEXEayBNm3k4KfnrR0hFmevjvpVtu5lmC0PbrOe2p04KvGXEYXhbKhjOH5kr2ikigqTTj2JbQK6lHN2QFohFf6SgOzTZlRvtpodU/uyk2vwCTlYRL1YOPzOyOVbNEuO5A08NwEFiIFgjUEXFjGHD/VrDf/7tUMugwWWdLCmkSwnLWCpKCtMmWJAklq5Lz1RWbfqvQeLMmO1BYSGOOR1fTFCUG5qBN1v3kLF5B6XHq+YG3suoBGLcRHiOVNgcZpUdKqW//aLgzMj3AkwzXeTTeB45Kv+cNjf9pDg0+YsE3V6VODQIzbgwqjAZnhXiBwZ2P5dk0G+eLh7CvDOOSSVC0ZyK01reS9li6h/hQ+42whagKa9ZRBDwNJ5QHyrvtivMuDf7/iMTMtqC0ieo3jNx42q5GiSd83tVSC+V/LSoDrNOyzOmq8AjNoqBc1XBaMBfWRrR+bNKN3c1LKrVRzcJ9w/QgcF4YtGGmMPj48XlrZhQT4iHq33iqcoiejRvyYEBtH23dF3Q9HqX62n6yYkc8U/HFdJ/eZ4j9BZr5QYST5YrGlg7ZaRHMkeetFuMAPyfZLZlYB5p92hgPsmJB69kL/aJKSTQQ5xSQlq1d8OdYa07IKRjIeQ6SmnxJebCDZ6xf93Cxmnio2/BZ000wyOyH7mlTUU8UFf3kIqTGgaJKEuZ7zSUHN3kDz2TMVTyIIPoX0b7apB5eOipj7Kfi8JSvrG+L5dUEaFS1fC/5XJm9b5dSebS0dvJeSts7MlAr0me4BJz7hX5PnhYuGLY+mr6CV/cjQLq5n+JRoeSFOGeGDErNLW5NrxRoAq5hGSjGbIDBiE6d7W2jebtPhMTjXr1oLp+x3TE6i5bw4AW4/kzoXfNskfSQTSSjq4BX+D/ofWPXLRe8EA15T+X9G3HROjxC0q4VO1gvTWH0cqHFX4YZPyHU/8nSE6t+KhvZPwn/oEmwRcaDYYPsR+xTvI6cJ6M3HyXX0tM/mXvqT7CTQ0ciY9DS92rFrLMAFcZnfY5Rs8YURA0JRoqcllRAMbHbvgv/bHjjaFC99DOEmUG/gnM3fpd4Nfl7WcwVisqxiJ6FPau+bZH530kcWcA+A0mr3Mt+bHG61S8U48vL16lyq+AUvbliz5trT2S6sjAi94KE9qrduW6X4wARZgzDZvTNF6MI9DHOEQwB6bRgNtPuFx8d6vvcYV3C78tVq3WuFEFU/fhcq/CR7I/qS+XpGxvwQkEVfwZ3VJ6jcBjoTsfe8rPvWAzJ7J79ZDLwmm1VQ1StPSzs1wjNyoI7q+r2FukmDe9/mk8xLXCHyb0+v5CQAafghXcZQP0wHzuSvn2quDEDrWBGbRrHrt5UGmtOVCJadYEV+V++p+vHnShI6Tsdr0vGE8bJGrJGRT5z1n6/VqeF8atdsKfV8GyA2EhdLntgCMo41gcWySTT/etCe9hxFiu8xsv6m0r4Df7MWKam0NN7+kGm+pNv5yCTUKEAfWXsmD1NSm5owlmuvrFEVp/CRaY+sMsGR2BSaXKy2NZiCzPPTEaPgcKQZeK4FSCIU+KJA+US6kmA8ZvPFRQGdbP99EVNDfT60psjH2LP3rl6rc3DsvCKLQsYZTzwryWuXz/2K3UwkU86gsWB/MNRlyi1xhWQc592kxRt+9WOYKABa/Q2yRhM8oA/R4flsqLL+5B24+xNgoimBNt7e0BnZ9LAAmmQxHsSlgmkLEFKcfnFOwi1YJtY7NV8ab8gcOiGc9Hlydz38bUwu9r5ZUZx28//fM3AXWZzfKEyCFwuOF6ADXq/ldP5OtRHhgboMbQxV9Y8JsXcq1piVHf79bOpdVSeMaVZG56b/Hi4YDGR5vAeORS509k8wS3Z8JnbFfeqiOFvb0iZ+giLX1HCaq7BC8ti4GY23B6tHrYhkfq+v/gKmHQXA/ENN4Mr0HnImp2mlp0WMyhtgornAwx7DG8KsVLZ71QB9l6bDuIStW3ctUDDgr1bMwqiw/najl06eWS71fJPErT5Telnv3dxxK+B6naWr7HqZEAaGCcd0tAUW4KTEHQomhpYqnhbV//kqwSCGBYbzE2YRHrqG086eLJtn5gv2BHvGubBL0RGVAqKveZwuJzxFXNK0EBlO8awQDV9KQ9dWCKWBZ0ki+FI2PUVDSHR30a4dxVg5sr2x9Dam52SDofQgvN55LnLazRjEZzHOjDseW35JC+M0rNwFZdiq2lzr/HI+T+gvvVhw6/0lI0bgtuQiF6Y5GQz4yYevCKodum2nf5V4KMrq7sxJycBIJcvO+Dpbt4ab8Nm7PliESVVEWosEDb9GqT1lcWutDDCRcLFWRUElfkV2K/U6TBpm/L4CR8cshTx/LGb+RC8UMHif49dbSSH9e69SXc0bGLvxQKlsF1IaSX/Z4kdHe7TUpQGQ4vj6R0sfVYCpmjQdBPt1dd/ME/8ZnCmd2j/98vOn7NCdR7q+W0ys7WNvk8uGofqYDK81/57RR2Uc3nJ09N6dcsADJ6HnWBi+XJ+IPsYN+3hubrFm+r2D6yePDuJumpQvNybaUekztkQeMjbYyBuu+sm3KcdDeJ/Y+oaP/65wq1ldXoEAKencstJxeBSBwDTdF1NN6bKZ25Ekfz0JvKayfDk0rgHCPCXUF2UJqUe8vNeV/HmoYchMB4u/gv2vquGOKgayo2QO/t7woJtCSqY9lolTE3f16nCP1ZeO/yOpgEM2vy9b/z56/GfEkTDd/X7zwq8rhm/qzOBs73dQamkNuJ2BLtSIJOYC+x2ATC0KU8+DcbSg/9VbNH+oqWYUJ8Op8n1MrmGf5lFZJytNo/qYwN/sGvx7Ckj4+BA23G0+gGNrx4DHWQXEok5ieVRc3yAirh/35YcbvkVttP1zzu81JIYdPuLW4eW7+mG2IZy+qfak2Hvky3PNMMjzE9fP3RS5dw4kT1HP0QTnR5BVZME/wt1a8toGxFOSDJb0PwBf3egsXatemx2bGLqr4eFqer5Ry1mXo+YCNUKq5XMC0baBe6bHZuTA8xJ+03+sqmv9+7YMz0YjS9qkDULm73oqKUhtxODelhw/OrtT1Dsxpdnzkx9/xM1fxpwSWw40m+Ig3FCJUJjg/r9NsOqt2Qru2OTtaAXfbq1WBSy3kfQG4vvPQqGtj2ANZCJuS0KV3O3LH38o+jgBP5GHbEKMkrP9y8fNNCwVRjaA+hXy4SoVaWg5mouteS42HEy3jmmmJDltYiUFMHcJLYhnXTKH9vvvZ/DToqJ6ovUzQKM4kRj11rq2psv8EKLFQXUl7vtJKulnCWjIzZ/TPZIlTTz6JCt7xHU58/8Qt5fhP804IPTWVA779kDChwkliS0dG0+izeGbiF9mUNH1HMj2RslHxQ/D+ojQSI4r66Hir/GE/9INPJ2atqWC8C6/QiDxxhaSIVvviJxqGnnTvU9Z00tGDP9+sFXjRllcnOjKi2Cq04/dNREm2/igC3k1/Umr1Gyix27camCirZxlRmrZmbC07++gIw4BDUBOSGJHF8JtjkTLcN2vOQX685VyKmRXEe/0y5DS6fcl7Z/nujB5LPuC6hSyYBTDhtXVs7hb/8FfSSYYaO40JkkxwtbSLVbPdTcW22qdFUI1SMIJMevD4wL35HCD6yWHiN6kMZJ+7SQF15XIPd/yuY4mEUhYTm/7W47G+cEAAtXV1FvGOp5rtZ191TO5uIj9HBjx5Yp83/wmO+6xEwwrN4gKMjdrpUbdUpIsGPOn6ZQOg18q2vptR3DYr21euh0gsREkfltNaPSB6J5kJX84CzsZznEXW61lwOF6nao2nXZcaF8eUGkG5N4y47Vw8m38tBv43r7xJ4eZT3A/x1gW2YG89MaFQDUHhuTyI8MfBmOIYPXIDMOGrJ2B6ghzH+PZbcPirm9kEAO/Eo7yRJlT5+S1orD82QOA/EZbpieP8kHTrrYtGC0heNu9JtqHuz0be16FvthVfDlwMEun4xFQx1WGfOPTFCWOUy9S9iDHU/r8lB49Ch2MJvVh0w2rbAX0mW0o1czkYesngubqYtEBGm7tC/vNbzN9JzghHKh0MYNIGMrTtcGdzeXgT6KxFpImPv6ux49HBLXl7KZpnUjMp7lcOlMU3xO7qQEtj++OJ1LjCPiS17FsELcWXCGdYj8QV49FyEGM3KJGg4n0/zX1y5TB3VjGHGPnk72eCB8J10G9gSKPju2REy5PwvRwCRL1wnIE14e8eNTTZSkOfWHojeAyU4b7ARv+2M8EdEiyNEDT5l0PRbb/4a3FjrjoFFbOnEM6N4UTRHi1PVXcCmEkzi2pvWSVzOIB8eIioxY/VKSIbBlq5/JOss+vxXNM4iq/qMbCNctluxhz7Ifx8TsG3Ac/0Y3UEBFa8nPCjBa3JGYIHdLRQx2vuMMq41Po1cUdSdJU838GvzkZIrqvnoJb93MbYLvaK6BLIDpv+zoJD2kaNvu67PtxQvx8UosrsGMV9Ho6OybrAU4XucQR2I8zI20xUe2246HLpYKb42i8J9wLUgrUmaZHQRHhwewphkOUmORv3iKIKSFvwsoto1wIvPZBNdGrLbq191liSqxpoWz+eqaTiQlGwPR7zrkuBx5zLSqnolCU0bz1o/7st1EeGC4w678rygYoryi1nZ0Qbw2q4zYCaGlenLjgBhrpZVgVOQjYlj9Mx629rhect+m8Xu2L1AYBztfzwcFQsrqN3zD0FRc8eBaeNWeNkKUhh/RJDRVXLz1ICWg5cdKT7g+mGQ78umhTrKDWbN0SyIfupmQcXTb34Ql9RdnXQrsQysYEDa8g96Z/NQPs0E+B7Nch1rnUYbQjP2+mTvF1l1F/FWebmzUDhMKJ0UWuKAQllktmkdN/1mCP7wRF2YZzLb6OhxASzjKlcpn2JKPx0AXYraiIzrE1LlsUXuPescm1uk2r6n5hvWpg6UMwnr3fFAeNVBp0Jp9XoyL+FNkvQMUs9bIGqU1GnbtZk4/UGv9w4waznwgAf2Kl6MM7tpfAzlOPmD5eJEmM32kZc97JIa4eDJZ58R89VoX61zLIPwMbqMjZiQSEVYuXWY8xiGdQwZnNqel1we1lKZFIgr9fVh1N05FLJZ2QWvcaxhhhDdI4+RViFcs9o9EcjNWgxjKqFXy9VH5Ajs6wwuv12a5wQ1qfQg0egvMpq4eY7+Bh3XwtnJVn8kBkxj+zeRLm5rUGxZTjiosgqQA+JHaBJXvZ7I76qimvXs8pp3IYHLgghQIMpItQBGHgfY2Or6QzuwbzQSTnwe4F8K3MFLqk4T7ZAYtMnlRvz8xPt8j9HxNoVUYJ8rWzY+TgDqZd/d1ZbO43tJGTFnQsVQvooLqJOKC84g2tRQMrdLnBaIYSP/X5IHXxIocE/GgfDsR9myUQ1W4dlGZfN238q+j37s2MDjNE+IIis5eoxl2G01mxShOqMOfb9vcH1JZfv/lf4AdAF51FbK49B9B/pGcD9xkLO1Rib+m3XQWMD2x/xVSf10tXolZM0JxKHN/UofhxlU5RbDWtTmPQcPEda5mOF51vKCiE3IJaRmGuwnnnHAHBtapD6q73PaxnbzepccDrF5Yb8GaM1krSDA13wxRlhddxmBF+I9Aj+8yQWTyVKvSPM5L3Ta4yTmqlmMbEXMA9iVstg225W++CKULjpIzvuVEmoMaTwMlu/ljyGrZKdptJ0/ilp7I1XDZk4d7Rm2/s5yNjYrM4TGqpdxO/w3L0Jpw4MQgRFi05Q1wZ5EvHQtaIjBu/oHwlewGZX7MdUSP5n2SbXp40l8zk2YxOwTUZ/HjZaW9A1w5Rc3BT9u6zsBTZ5jZ3CU8rayfUK4SkUiK2rC/4RvXGoIRBCv0i9qrLA5kjVTDefi7rNcC50opAS+lZAAHgBcPK30dY+PSXPXhjzH8yaBMUJ1rK567+qfXSxsYzCcp3cy8//HCv0RMDyDisnShCBlqbkbQ0gE2gxCxjqD/2hQTWVNoqSzGKv517Q1tF3/6djBchS9CPiBkrlwvjTO7BVugBNL+xdKOg7I3jfkT4iXo7EyWpmHcqoQRHt622JHcsfKFZ5tqTzS9exg7vWYZd9GiB+G2Qigt3HQlqu3L0lbm4a4V0uh5WdhhCCV89HwneKjqQOAcItdxL60x8ceCwXdbDSFlwcxt6mw/dKLguIHc7T5dpHb8OI2CcRVIP+DM1rCXcse0+S7u7EEisFR4ktB8R1eCm2Tc1k+CuV22TNtqjAs0vGXh96MRaIwfXqYcgAcH0E1DPMdS0y9/j1GARG0G3kctYZZdfHCqPd0A/W92IkQpSF+Nj73rUyJtrtKe98qFAwO20M4MH3VlsqmF+nIPiVrKwZhnBGOtg50AZvs4klBsS45HdjWVQ9fQFarihIuIZBjgaoby1kT2zEKQ52X0UGhcicA3MRYYdj/poFcEpwi66ELceUi2afxx0ZVs44/I0zYOJRuAFVFVYwe3t4oHUnbkQYVWWi/GjXEMbpSZydxIydzesFqVqYxnEp1JJIu/1pdWCDDiPwldCTVRofqfenBY/o4QKZZPH6TDRWZC6N4Nyji4rM4mhVZclTMnD60WCUz2aPvNADgC3KuMZE/bZqIxPGyK2+mYgvHJ1vYh8Cu89A7dzgiLI5g03ideAla5lYa6bALt1iY9HQ7m3fEwYOwkJbRvV2cftQMCHdfpxn8OERMjyF5f9jpxvZtNrfRGYJrLu4HFD8RDrOaras0VA0SSoFIfgHJQK5gyVKGLGw/lUShAbRSDXzwt+Rknuc+fafSTg0PR2SnSGgAYOX4FZUsCW9S9hUxH6pitOI4ZCINL639uoijqekuiQMam+oS5u074HT9dGNUUDgC/y/YZV1ZwUXfB7iUcI58yCHCFE/EyVL7pV+erGN+nOsDEeEzCocqiX5LkcSS5do3K8F4JTIawzlOVDk7xJoUg0+mMIdAaQ3VIiBcHuXAFQhJRbElKCDqTIABPZOyM4gIJSdjH6vPkwKeIZibcJwlwY7k0ZeLbiXFKPY6X5jApL6d9NTC7Q3ZoKS8mMMhOaRWN7/59bpjR+yCU2RWtBfvY1AQwfRZaewMHDGxwyXfyM5wCMMdERcjS3LsZxEgIqGk6lATOhyxbpSMC163jfBhLqvu4EKW5HHtbkGn8fvdyPKFAaw8hYel9QYbg5wlnzZrJ7/8u53FFfHf4xZjKUsIei2FCx9HQ5A5jjHQZcwRWJGN5jIqO51/MxbQ5V9RqJ1kpVv+yA9T6YtUu6XF+kYAOwyNQb1K8ROp0jygeV3MotR2gyUEjl5NaZKU9ZAv0m7v6s8mIayBJpv+/zIKg8GTzMez/Rg4eLvuwbP5mLtZOMNj4Mnsfgaa0ajHfihMxVJH0Fca24UibmRHHF8QCZPo7Z3zFw3L5OuV+s4PQG23JJdZGceD4GfuLc/kbSejblRpodm1FzYPSEUDj4Sas0mKZUTwzR2XTE3/aGCB/lh79sjjytkk4z/xc02EQM0+V/DkpVJX4WjKiG83e31QnBk/O0lij6gKb78G8473jRjIBAYBfuwLeR1inMnkBy4rXRFg5ahPMj/7SlUOjddS/bIgWW7lm7L4AIYDuPhRYu96mlxb46NmM8m5icEHA+vT0kM/Vv+gT+J0ZlpiZIXHhNF1Q7Hr/dbosgYI5GS+0q2/35si4N2uvCoGloLx5CF2dm68yq5vaCqCDPT8LQS3P5OqDm5lueRr6YNbOre70gxENZpHeEx/ZmdCv+aYx0koPNwSpfYG3V3LcX+xgjLHwoWLLo5dTb7KccHELnmN1zCRtSGsjZAT4OrVQTiPNQ25Tg7uK8iT33AeZsXSV71CyPfG6NGRLRrFhGVlsCDGzPf8CsttzH9mk3ePanWuclsTKrgNN/SXVpWHHRfp8xaoHV6m9S7U1QiOOmEnwoXLkimmFKU/xcZ+CKprdaePpzjQlkAGJQvhyq7db8BSuRxPvDwlXZNc3ERtP8a30PlDaoK7Peoi3TUDleU3U4h5BBQYf5xh81V2U884GPnrYKCJJiVwJDJynI7ADdLiG1HxeCu9Ebg9sF+F9zzMF2Xhcb/5EOlhf8Vk58Gd2W6B6WkPe8fc3S+4GLiz00ID6mliXhFl8sTZqhZLLjStL5jhuRx9OMW2j8vx09gklxoRYHDs06SUCZKd49Oqk9sxCSPslsIhNrAfKi+LILR9CvVgouRSwyzfS86BmTsjJV06llGwL4Tp+oLl6YKa8D+63DG0nuZMDPrhsEQ+ymvhDpzE0jE2Vee8yzMSPjls9i/AfxX8/LbKY3kQGbRj5EF1GwXUlBbcV9sI/uqL8aKRRy2WA457ToEDsL4VHDNpM7H6OWWNb+esVKHRWf+K3EBoBxTvs2Qoq8xMREU+uirtcQcbAji2UX6tXRGgTEhq9Qojfx0NT255v7aI97rHh4kGKW7wt9bJxEFYzHjbN8I69x7e8aFn7LNwBmDq1kc6GBtI0qkvtP4WbviPRqdQ693Qkgd1SuNGxVdojl37AELl1GJxGAZvuCTUTOrv/LnT/Q/Qcv6qqsAtTccVg+fSoBRVyD5slETJLzYp2JA31yCQr7W9z5bD65OjO6DCQRVYLZ3KcSdkzfnDM3WSUz/cUKdSNYvkzjJzv3Zg3+ZmXCweh8GcjoKGwNqyslRiH5FGNyRzvA2Xmxej63cZMheo8YApbhYDr9TtZy+3i3xeUJXmxZJKF3S6v/ViZqG5U1dd2WNlsXokZGziQfTA/QL3OIltVtIzUdSEuUIEaGXmf+/bzZbYYgj1+9HZ3ZWBwbldIhVEzl+jjFPloD24zTQHeWpek0hB1htgP7TSgZiw8nwKIzqYZxOm+GoMpd9+rzSjrHOScGhEeoj/AymMTdu6xaZ+i0ZFdmI/LZvxS/a+ISOLPqqmoGnpfhx+8+z/v3iNeRgr77kXNkp4uAXjYAtvNi0d+3zhz82H3LMC7F//fDe4u00DcG+CuBhhETTTLhlbl4tDYe76hLH6DcB+mrh5zG5l13gTcadBb1zts8cQMSmyAJkXt0stbkaOnMuW8ZxvgVwcwjhDHlgLsulo9H2kezqS8tvoK8WK/s8HtpCibewBAoX6OyD7ezzuomPc0V/hBKb4SrjTt0mwifFa3MBSduOCmjivBuo6JYKhJxEgLh9MONdRzt3vNr54qGgP/uKCCLgIjS0nBz2p5NVXrIMfwAsv5sSb2qls1wa22xrTvyl+qnWUufDER4jTZKbELpxAPNXP+mkPXolpMTaU6fEOf5QIJte5Sy0rHWJnG4Y2Y5ggBMvHGt93a1TUtmyieubwgdM4Ndaz8oe3sNSwB5gLecXpZ8LYJ8nAbIBFDmhTBN65oHUeg4DLByBo0aaWk+cPCO3o6U1i6H2OQuDzz/+KR4KZFFRPyBy218v8nSLYD9crliDzHM1+MP7XJgaunAI6pMKm2OA5x51D7fuP3ifpfMlvUG+V5Xgvp/l6is0YdrAloFtWyDVr4yEGAhzjrICEqtVQuE10i9INhwBa60JC91OQ6e9frhoWc2TvG660DnA2IiU+ZcbBtJLp694z571X5OEt2RTMwn07HQaRcWnk7g3gTVmCsw/UHp1HhXatuph9gITAAVdXV6nkShcqiKFCm3W1Hirh5BdKek0AXnZS8ygwhtyxj7pMJ4EvNV1WfPwOyoYKK6tAaSm4cPq7sLvoaHEfJAV/fTWBVT44wshA9KVUn8L4KQCWMgWg9p8xkpv5+4IyDNvwwkEbu8t7w0UHzwpKOfc5v9glG5JCoQLlNGQhaBW1rPM/ao5Sw/o8Nmnh6yBvlLeAwZMiYGxcniaHDCHs2eDk6P8wBH04W+UupwPQy9PH0f7GoIajzAd1N2EQKH3qor9uuT1smKcXBtyY6/UgVnPTTcm4eC3Y27qifPZERF+OZ+Ju8UWDMHOch6x6svDJ+ejk44+0RDIC88GF4cC5sR+Vw2bjjSJ+3oEp0B2SYKCGIvWeRCyYtO2+AJ2BCzj+5EXMVK36yygiPHmpEMKPocs/zQ/CUbw2GNNuq2Wdpkbt0Oeasrq03ZTBuBEVCJRbZwigLaqx2JteADGaux8eyjXlyzRuzw+PhwXjxOgldssXYXqSVZxSI/FrAu4Hssky0pToZy1rU/el/b3GVMp7yRS7nCkDNROUumZpsS/FfvoBKlPI8JVGIdt7N+dnq7UMyx94mzJBChdhlEdSVzkx5A8JRKYgSlO1ej3wzfzfewQwBD9SxD4zpm9XQZj1bCzKWIeVzBXbxGZZVcGpyEVqz4yBEKaf98IR+VYmTRCR8/SoW3SUbRcaf92oB5/6dBrGGv85gkoMO3eqQVSbs+sfdo9hYaVQVXzHaJqFYx45ois8Sv6t0UUjtSYdAcwsqiVOBPkJZD776hQgNzm1T40/mIUTKko7EfKNjB48RczF4vj2UxH9i79Rj/AbepYl2NFwgznS+CJ1j33Brv3ASnqN0w66bRpVgk3O6D6isREN30Mttc9Eut1JPlHFr6xKeVHyASar/7UM129zlL5GJUs5fr4WsFH8+GBwcpxrTbLjoY0kll66jbFpWmQ4W8uVqEfvWhrpIl+3L9OND/4EA0TnHYp9tYNtEkfoLfEsmhMEJDe5y7dvAensfI82tvpTjt7PsX4ZdY5RXdTxL0gtUWZ7GF5wgNLQ9oGejOTsfU11Ml+goBdIYoZFQWo/RVzbcrKdRHshBrppw2rpk2ynRVhKt4ZiLvK4Hc2UPPcY/r6tEUuvT5BvKVVjw9hjVJvwfDhOKk8Ync8G7hJXrL34TeaJ6nlkmJG2Fdye596NXbRTpbsX2HmTGGN+HlsEZg9dDuIpoZa7JZADDw5JB5Oee+NUgCKdO6yGt15czoy1oSLoYBWJE8HIWhll5BEcx55jjTO4VJkBR2lTnkSMiG6+uOz0AFaLCUyrB5OJtkGt6EmBCIhJaZgfmKcJz0pune1RfquZGO/wBIOKvuZT2fIGQ2eMBEpcVILRG2ueJ8R/SthSjKrifIAh9VwdSqdQr9Fw+NW2YE8ZNgP3KRN+85XLWuWV/cNs3I5YBfjBCXtEXkmAE0FVOdSQcN4lzFFF3CYcsStNdXHmmZ5/Wt/oq9krOCMxaYU+DrqswHiPOlH2wZXtMY2Ve0idiHgFExxo6zabX59VBKiL38tO2U4reAnFTmB29YcB+Lrc6EbG1jzYsni0XelMHlRsiGsyFqYKGi8CG3jyN9YcEB/oHeD/3seK4hjrg3hfwHdxB05wVDpXrgXtwvcxYaL/xBQCN5Rdfnf6F63oMv1D8a2hXGjeTSbU3qGOUtqd70h+ceYAnSdjYSWNK9Ra/UyPw3535bEBckVC6ViZtfpVwJysoa188lHvQ67BLSeo1/TQkfSyFeAjeSMBjXL9DZiQtynOGzves5EngePCu3Z20kT79vZsTXmmHqd7sFsj9tb9NfkeMJDhAOGbZy7LvODDiCPRWfaYvjFc9+7ukH8eAMp4wDH/zIOUCkR/f/q7gglNXFV9QaKKlaWrxjq9ME2Z4ojwGr0JOFde/eq68E7eM1UKMaDTytiBKXbyu1NTH71St0uNP54bI4oUNmBy1rFoUfn8G1zXblEdUZgoDmvm9hC8DoXp2qaTOwMw9hvgTiztRTSCs4y0HSeba/sAS2gMgC/FnXob3HFLjAehDwf8st9uUvmas7gVhpmYQ9dwAIu6o09uddT5Q9I1PvDy/k7pk2qsQKc0AUpv04rz2BMCioByY8e9/S8FCFK4wm8rVXC6I8maiHe7hRnsUAnk2S4PEY1Z58K/8U0fB2zXqYactrX2m5UrOHcLgTaAXZsmBXypb0xWq8lMb/nCqLefRTp3YIM2VHZ1fHwrz2I4ap/LzEOqAF77xVxETdopEdipuXIsZh9J74p8zxaSyJik2409gQy8+IxDW/5ScDfcNxBSnMFMuFQbg3s8QlPFCRdD0lELfm+gz9g7UmI3zwnql1G3VyKThipUVW3mgYAdhYSX+j32dyMF3+MzwJp/quDMSR6U5WoqgBmKtrYUIc1xe/B2ogULcNPqaaMGTzqs52vPA+EQkNLKolrypZQ9aPtqTZbd1UmcGGQvcOmh5lNVH+BnRWg+x3WrqnvU4KRNnl8j0R4cPZldSjr4MXE5hcNtfyC3FZjph17dcRbZ5wX4vNInaCHmTuJ7a3M7D2yqcAReeZ272/ak6O4Qx7d/GdHGbJQ1VsVsUnV6YkIFdXBvOOvpEd456iiVGDW+WAAP2/oBcR2dBeACDlTfhKD8luC2L8JIqgeaeRaaG/JFQg+AipEs0Py33WJ10J5iyhG6JeBXptBhNrdRs+n1ykqOWk4tlotPZmmdprW6N8b7oZAyC7aWOZ5DrK4sjI6VOkl+bW6dRlIKpESobg+d868mWIinRyibv4kQpkIYJss38XdnmKBbKn+FOUqTiOxY+3RPapBGDrGOzlv3XINYQWc68XWcuvnA+haUl7dxbt9irWdOJNc8tnp2Q+udxX0PUMbA7H0kUPL89wdAsjVO2cDAPSd5xfzOZOm8KUqRTogEnwMbsaJPEQpg08NjgB1RUcJDLT0l72nc0saOjXmPViCsj4O6kpUoWNHmeQwF5kTbAmDY35OSPTeVEZKSOoP2ArJwUkWTFbbwyfJGtzdWBmJbjcfOR+6Vx4//8B9/UuAsWN56cuOEFnm5/+SAO5CrMegU19m1P4Xw+vHgmgs24CRVn2nALBAW0GWKWvfFiFZdeChaEKP9+/Y2Nu9HpLua+ovYcu8ce30z3PvSNnBCnPTWqU4JEA4TNaSMyX3JIgCfzolkmP1QnfbQJMjU2xWbMCd4TeOOpGgTiBOi+x3KAq5SkooN7WJnwaehGiQSI0JKqmBOjU+d9fIG6cFiaFRsJ1tlKwdza4gDvR+9OA+RLxMrERyWKAwZ2zsju6oCqu4PVu4zLL5we6/M/FE3lR7ef18LJwH6DsXNw3MZiPadcusRef7q2G3QhTjHIvtpZUfmsNr7fbo2zyrsa/Yi4qNyHzzO+1k50wwLJ3D2k6MVJe3LEVAbsuXFNr/e8lFUxOC1tCjQdgZLhqqKhJQ7PHoajAPCSWmLWqutv9WBhlUYIwbaROtuPhSW0WmGKYGysKbN1dp5YzjP7GfbxeMWJKaDbdsRCvRKqCOhdMVZdaOqyK5+VHNe7cJJnKctm2L4dbPcPYN3wYpxQV0kXmG/zulpIAv5XgeduYDxWOcjif+lPMQ5+9qy+aLkky2lN8qJ7cEgg+bP1hmPEOrFXC2tu/t+QH/8J9FN/8VNxtzcDMT8HolYS936HAx/IJ3L8NRueZOC2qKxAfHFj3apw+yAzO0EIsO2aSu/NNUVT/vko+k73EvnFK56IjnSdQ0zdzk1Yuj2MT1jOlbCLHGdKbQDxj/vSNzr9TC9iphKs2ASXd3krYjr/au4V4NtYjkXedXyZZXnotT0lZ56gi19AaYnp/g6X6fzJh7U7UFefAuKuArdBtwOBRlI22LpQjnSYCk7SwPzY/5D+cPsHcVgmQnQQzqfvT19DaraCLg6tXo4PzA9fVGsHENUFWFbU+E8PjBVtN7ULLy6i6jiomprgDSGxQsj+dWMCbHtXwI9Cz+LZ+vosKW+AgWUjQSy+1e874sqtci1LJds3F9yQRye8VzfraoloO0Q55jcV0cX8BxKIPA6UY467cj4VtfRktDhqX8jDN4sS/GsVPXUZAor2CWWsJqeJ9Rubmq6EO65oD//FUotdVIo2KCpJp3/PmQlDJMFqB+p+WuTYWmwhFZoUJ2ZYchmwuIbuqW9qq1hR7CpaQSJCZcbLmZlqbRIqaGB8EGot7k11OkdW7KmIqHwcy55r9Eav/efUhY9Ndm0D+kMCturTwh6CNxOY7DhYHOHLqQy8WnOAL53fO/VCnLpesAtCKRT4p8yQN7x5mLt6KL2Z5re8FfSz2EgBNnX/RJ4eybkiRoYiDAGJqORItxmZcdG/MIFHvHBt+MGIpA5bF9Nb7eODKgzhXs8Bb7kqfNTi7quXmbBfGc6vM/yFJPoEnaxnTjNP0/1pOLasvsVzKNA5Jb1dftE7vzClke+5MjcRHLP/7zvAkZweYMoTUPjc4JqWq+QFJdzWNtunikLnLpAY40f8tVrczH51q9+RfdRo3XkPYJidw6Hn5cOcUY00eGXjaQOFClPBv+CpLsBiqo6aJ7hPd+0NmhkUx0hG5H2d7tVFXpAiRWY8D94UkeTJ5rXNkkdXjd/3N+1hbNsmwNofuUaFX3OOi4o9pttyYnpyef0NpNq1KaYSV60u1bmFwathTdk8Yf4hEXWCrIo4q8VwnetzQ/wwdWB2xbxgSHsvAx4jIIEg8UtAp9miSq2P9R8hIsPucIfygn3+0W2cafctFkhZ/NQr8lx8FbXJWZ1OoLWp0GRqXYM2I8rCGEhX3GHQIG3aPy6e9/8iMkT0ACRNhaYscIdoKvPmmYBjQotUgyN37/6Zz2EzDXEKqM7bR+Ixk1CN2a2iOXNNzBJob5m2NHhyYDnnqciLoAOBNQiFOnteQ8eeR3FgJIVNBPz7P7r5EtufudbqSsJ6H0HxOFeZk6ha9TgxJKVd2iY3MzCn/a7RKQqlC2QLlc6CCVvfflUwnaGSUpVo03KM747i3Y/o+Zs3GPn/1MEZmYVLO+U2vc6AgqndzMBx/uASdeFU88N2Bz69bOYhSUXxJHSJGY3Crj6Lq73aXq6v1Cr/QE1wVp7q5ZW5yLJE8jK2oi9/XhMaUFPiGWqD2E7bk7riRTQsIwjdLIY9AkfLTQEGwrT2NF3jtiERfTxkDe9Jx0IT3twg7tSNJMNfzNcBQh/kT9xC4FhCPG9iOzZm227wmsF2ytaCx8Lk25z3i3gs0t84uaBViDGwcwXze7V1cqXyH0n4XYYDySUBxSTf9ngcZ/K2JLsFYnE0ss5XMbAtNtegMhGTHvHsnMtP97ugzrHhRfAVkCvjNnVI/pq8PaLpCSS7CIct0lLOPgu72wKVfNpI02dCtIwf8vCJ6gnQFWTy2ObNSvaCYZ8S6kAbEVDOhIBSJ05GdWsA7868zVxdZrLhhRNJxMwm+R232cr1Pt6SBYQ4BFejSKtyGJPPiJWG6BLxvU8ZfMKBhCpqyfleAOA8FnkGS2BaVzwjtzB6I4uk4COsmXN3X0cAsy5CKvWOqTqOLG3/ayZkZRsWQ4Nk3W31cxF+VA28FqkqV4FGNx5xnPai/7keBd2qw5WPKjmhV58VhljkcHivnaXY4w0Rzetuv2nj9zZi34DUzpQjvCcVav8BM+qSF7OgyWHwEvVQFhpluknGbdfy4XASYgl0GOQdhjXgoDugU6YMG9liwff3X5AqNRJMAPLR7csbdQagmXKw+FlyhLuxUPbhPXWf4ymLTMeCv4Pcfnzo6bnKFZ3K0/I5FN7AcnnMwA/pSDdUjTNiQIIqgKDlhtvIr2MiiSxaGm4duoevdl4c5XRgQ0chHp0ZVgY0dfshD8j2+DosPnIlgm3bbg/UUFOHfPGmTrnxz5p8pxmYbC9T1NHxiJl26TsOh/SOv6IeFnsk3fKQEmp+0o8l8qqEqywH28tMDZbGHjCR0ZAf+jsqn7gUFHqltLQatLRSyo675pA4cHqOoUJOAfdhxT2WOU5B3A80EQld/fjUt5LlzPZ2VOgsqjdrmcHtBvjppeGJkKhUEdQFAlmNoYgySCLcf8QJKFUMjdHZjXEL/VGa6ogddYyIkgcxaIk0BNVaZKjQR6vi6xUCWq9D3CCLl70kTqjZGLh6oASu1cN71nEcrWH9DLwI+qyNDwuROXUtPDwlJNYiTjcFKLL56CWYm3UWR7dm3wDo0RnUDsHLTypEjAa+cr1shayETLgpx48oaH41TD8R4ZgjKcLXX3k2jVUjpCL5aJs07yQOR6A0FcCVgwSz1zqWgDlET6j1BMAnPxBg1SRUbIjrFRcXLu9QsiZk0JQST2pDkfwmB9VdiQiu/tZcLlid1UbykQg8z4Ls2nOohXRFV3Q5orkX3gO2sAKuy8temAnyHNWq9mm4Ci6E4ulZLYaFxhxQfjnyJVYnaWjslildQg46psdC0nFcQ+YYEnOgqDwXPna3/8RCAwHTUUUkIIj9roDjfFoDYBuEsJmndOxy7a18rEE0oCr+Daw8ankhAVB4Xn01z2o6DBwsGy60NHaF7mzdQZCSZN8kvimdWxkVKZSIE5qghSdLoYpUHK12dEXBdvGMm3cZjdcc3uM4MWBPHB5kHRYuzkttYKHps8he7UFgW9o4ArqKFfAUlrRfPmerjbfboTqxvtVWVztaxOdBMVpWpphBHTsVrFxFPbIeXpTK5QQ5G3cs5czSABIJOTJTKSKLzsVGRIWY9hD4HViNeh9VC+/xa0ifhVIltwRxmDtQ566Ir4Ic98laReJag+SDJNEr0kYGG0j59tIMFxtn9nNW1MzlPWDCVRf9lYjaqKY1/R3BfF4IYnz1gUUyLjFBP9mLUokSyOh8niKi1rvLfESD0pWvpU768RUzJ9ASGgwk5I36rUGCyqWGCbqjCMralU0XnoaJMwvqlvkCK6biypHGJuOVj9FcO0ko3l17QMO+2660U6oEUxUKWDdDnnSh2rAv0jvs1/6JacjIp2208O3D1rOZ/jJtDSoGanyO6Vwpk81gCow+mXi6ezCMX8HNOjCeRLdvTIq4DgcQyOAHYZO/di8VyVDAH1G3MQXg+07+hCdqr57U8G87NHazCB3KMI0aAuq/f1YeDIp8WcOfyhe2YaNgodmKi5+WGbr+G/Cl2PpbOanu7O2Rm5ReKlkO/GnxF6dj0qkoLbB+dBSgS0Z3II9OehoXWtYcAjLkWQnmHUk/ojQJFtmcQFQ4OKb+w+753gXMTnGX6gCWxq8GPsl3DnmaGiJSSQfje1lCrXoeH1EqZzBE/eEMv1KeH0KGuel4GumsbuSx0SRxzv+8e/DPTeMACF6AKh9K/et3UDz7rW3scx1UeMMsKRusK71pO2XsRBz8iLbqV/UHrmukvU1R3G/ZVz/qf4WlF22Lb6ezmjhSWyMeKuRBeipf1tZw6STcBPdy7c4j3DsrCCAo4cPowhq4wZgzSzt2OJLbBCFD3IaGBdKE/V/m+afOmVCTEUP4NOiZYEGPwpeEDmVXTLvUVJpw68CU32SPT6oFPpPa9W/75ZX9+N/o2glpYE2YLidNzUDDgPQGejL+62+iKPKGwxZgRjsFG7zb00r9xwKaxXsJsfGrhg/+XgdnExQN4145tuPO6qCo4p3DTFnJZZTWMmWDTEv9FF+aUBl8tJMSgOB/TXhCFZ8UrLWDdAG1XUcgmEn9m72+JjawlbfeIsvdtl/f0cudMKOyqDaw9hHpOcvYELwwnEbzOS7jJCy2noAmQXvdpDb3rUszBgAloMCxgXTa+d9ux6u8+j5xUiZwgopasblfIvtWKicfDdvUkpdfem8Zf0xdI2a5T65j2/vjOVPonqQGEA7RV4a4Bqf/9YJT2pD4bw8ViBoOIRWH9NN/Al9SrwqkEITwJ3A6kt7fPTAg6P02ZfjYuKaZi5JYrSZWo1CGE4P4LPPvcmrwS7jOcdigX3lmnfhsINQg41le+vxk/8C55pQhMpbs3NCCfLEbVLzU6Wp26vE9HVGhADiZ6bvAk/Mj2POgYpS7qdBzoKzwUADpOoO1elqY7cYfeHDbWaR56MFAoLdPBop0pcykDLCbnvwEeaTuNakgfVQCYhuqw55HCS+GzaYjA9hHjyvxZylCfcIYw5T2Vy3ovcY8xRwoUVJqk0Ck3A0ZpSW7PcfaWVe4taWpJxwt3AFbAbklT4cWORp/PHoCX3lk+IY/5VS5j0Km56lS06XH9m1TlexHnsmGMW20rZvaurKd5f/k1p8JJpg4jeq6ByMYsPAYw8v7eLXcfrxxO8mLH4M36udKFkV3B6RjTrtaFO3jXgeDP7fx+XfN/OFg4GBKz/vaMFJ/OJeynoBdvgIqAdIvuqFblwYUPRxwJ5o2B//j59mhn5Hz4rf34GhRq8R6gMjK0eF3vD8IDc6ue/n4pBWDIRW/LfBPO44vXFqXpqBUU2oDEVRUprwDX6VggdUtEArgHJCSeoudmxYzQ22Q08JckjGfPKsc/qkNU5Qts3W7sOOFv7sPr0f5kNfomINYLbWFJDN43u0NtfawzpgA0hD3EpbsbfKb8aBkhDHd3E0WgnM4xDCs8TRjU+7C/mMkeFMbem0lSDJsOITlalZxHnKQs/jr0ItPwtz4dFhMtNMjdQII3IrQt997L6NPqBaoqfbVX2mhUj11guX6VjhDU40wUq1WnftAPm9VhOGR5iyc4rUk/p7OFm9Jehp24Umun+ltQHi4ApqBSR49WJQN0OEIRiOW14QNpDc0bx9nQkFSd6Qhpp+Gb6GrNUfeDsuGxeJEqW8c8VFgUisLMTSZOY0o0TFHrQPnX4yjU2T4jyhw10cSvPk9007dPCNOoT31LwZSmlVBZ24VscCIadVtV+wsNdioIvF3xBcPTo9nQ19X2LKUI+kgWmib7peTDD2rccIGYjwomae6/ndwIq7Xz2ZoxuI0oAkyZbvD537XdjLUYW5knqURfDUA+3xXshj/CqY4gjotgykuR4oNfcv+4k/yyBryJeOLX5mrf2CUnvFrNcr4FNpqgAQGqwdUDz1Px2oVbuZG52vLtvZEMZbNn0GburAkuMyynAW0kM5oOwTEB7E1uqQO2Tp2wHyZU9xbXMwb04ws+zw2k/oXtjft4NEWY1NqOtL+cgn64von/iFCMBXeyG4kU2ivC5vLX915eYRNKmpQrX2cJBCDLU22d6PXJfAF4EzFDlcK37sp6xrSO/6GLeOFOdZs4AydMpDhVVLDcKFbbf44HJklECSKpXggLj734PkGwGqP+zCCLR09QQXMJZYFPqGM4pUjN6rS/7ItwjmPkI7D+BLZm1D8Kf0w5COZcDbjN2eVszVha9QfN3wmBWBKA8SVHaQTjD5KkP6to25jJfGVrofood0h8pTZ7YT6fbQLWKZEL7ScWe7Zx3dorIY2FEi9oMBTajVU1NmATF/VPFxEw/gj96ITf4fR+/7RYFvdx0d8jPvwhJEYyy0ytZtrOR5VWqm42L4yzqrtCESY0yMa0rORI9lzHk6WSXsjoeVMUpHSOyDyJFSKuEIGKTL29nuyKm0NTlMGkMbpZEEO/+78uGIB3P8F/411NinBG283g35w3Rz4fmEC5ShCd8xQ2m+Gmi7LenXjKpPDSejUFceYhNVUCt1kk97LqUHIZxgSA3v170GqDtaKVZv63eg5YlTcI8GRS/9scg7GrT0HBo+x6+p8mw6s9DDZPrN3X5BTWgwjXbYpRZ84wGz8pzQK3iJ3tZm+6rgT85Wnlwt6wFNNkk241QyGoEXoabfX9q04ZC+OGgT2zKrZ3GeMBH8hFiA2NfZBozluB+jU+tdtRCnnK1D+jthmX+OMAXJWsp2z1wmiozBUd2FoSwB5Q4+EzQO1rkx/PxGG44aJUV85Ya5mpPMQBjjUN0xw5TPkE2To9Hz2PF7MbMQEPXPMMsQKdEgfvjPyYWERVgFA2XTPIimuJjRssFbpXTNRaCUAasD9PcWGWlQX9kmYFF0WxmZSidWodJQQ0MFjtB6RZtumz+PqALGXGMqRg7PDeI6Znyfzm3glGI+epKq42UAS9y//QdbRuXJGpcbumjYcmaZReqTm+vJS00ULYkZRETiQp3lPIeEW8BsFvH+mC0GerF1yYFC5QsZYD6IoJH/jwxAfERBH64BBf4EOmHQ40e4jTkT5GnvwAoO6dFbnhPsxoLDjm7ej5LKghTW1VYAZv+EPwjy3qj4RDGVxRzUZ3hrrWTXIBHkO4MvtcfPaD4mlRDrqj7xVG6J+Y9j522C01Inphh3va1p5u5K4wnwFwPh7Fz/aXkQWhZ6LmXizhbfUaNkkEKjps58FNsxFt4Jvd0jYIRs6HF2DVqOBih77L1Cbm0woM1YNfVvRyUfj43/U3aox4WbQfE6Gt/A+lgeiWkWhLFVtz9PMtOC+APV5pCHO+PCut09GbqU3HYUlQHbEUAqfv5OfOKJTapAtwsj0lOINQatGIqZFYsZsos/gt108d1MQhHu6FrnBSsZv8MZ7+s84bg4ZZWAOD95WI4/bJUqh5h8Mavfpx2m76q9rFzOi/gZgc+b+wXVjZKESA+BsYBQ8Y9asCEG/nzbiC4gzKv2MyInAtiVNsN6bj+S9FWmoCrWyy3KPg6xcmWMW4obwKaXQTlw8XQ+qH39juKuVZmX18jX1uMZp4KIWrSlOWnuKwieWa4cx1HlloIL/lpzDZXozsnKjdHAmPx1+Vvu2nW2gDmWoXWVYXTediIi3c/1AF8qTVADj9C69jcq/gXVtRFQL+87tS2wYiSAEiDnW8QYFEOSG80ci4PK+gX3MMR1u3wmVfkSg0o0VSCHOJ/tbdkUt40w7cilCj9BxMDtXXL75VgAVx39dq5t5YPwMGfCLYh8GSfOkwlbE2rKL3oAjBZgcB0wu+81Y3dhByhC8ZZqh5IsotdI+zPv52PQt6fW5HjB0kQ+0MWKdw/XSTid/3qlJi53TBE1Puqc5CWllHxRdGqITkg38UbjImaMVUG4MPsWbqytYDwVA8J3/V18uMsl3zngqH0LVJhtNADTnEpmW5kugrE9IEkaCL4zQL7gX8hbdq3emJOHA39v16OcXQnoN20i52wcfGg/7UYKL5d88v+raSSLbFEKGkM9KX/QWXH4wqD37U22HNpDBqd+PvEM8jri4YruBUD2lYBRjkVLhLnj/CVPNsEg8wIC9SFklDus7YVr7kQyaG9OZJJHl1IF1BuaNqi7vm/p9Ve1dUdNY9v8ZXiDWTuflfnQgcnXhTmUdY0U29+sGfg4sk/EEcl061xl5wIdGK0ZXP8hS4hmDUbkwdWomA94ZhsCaD8rLtS3xFtTh073NFmTgHfpuiTX+Winfcw4BLAUZFR67DNL+Mm6hYrqcNFRIkaVSo/soHQHkol6sLyHWN6vDtrYiqV5edEzNVehdSFKqRk9tU3WhkwqBZQImbRZPfTQieKrjz9a8pIyF8YrDs8wxLErQDMhJ5vlpqsqVnePrE5gQqIdcfKQ+nNcsVKg3ZpAY4v15egciGycoA2KvVH/C5nSdRuUpHqoEMWjhXg67JdXz2vBiX7sTS5A/idCyj/57sotu+dnOSLN8spfpyfVy5COeUz/Sb2b+nSNNSEb9Zo33i2PKQkuI8YkuzA7nSMB9SrtQwi6qhgCPqdUb3fIGeYy299OZmlMsILf9EwHx++3uUzGYI+IeaNjbSZHp+yQC9PqBfCO0amVpkpptsqcmMO+sbsP8dYJhD2vCieiD21bbQfHwJ5n/PzLgBLNd5eS0Q83Lwrf46V3WpSjes/24MY4aRT7qpQgA+gwgBsKxvSmbO2J5h6X/mrmUZwlvTn726F3HqYb07sS/TcCqAEzlbXWoSBx6QnUuuM5Cy4C6Y9f+UyAhIe/EkIe1QvOZQO9lPsntYGaV8Nc+V5s8vLc9TTYyBN4Y88zSO+dLSrztjCmn074vc9Wh+PPE2soQSdLIT10tCFtDv9prwVB7sk6O+0cLFyRTrn4tHo5vxBhmsmx0vAQyHe7oDiXd3T9YLQmYgJPn3UkA03sEB9DAh1gihIo+tYE4tV4fDRBgIyMcIjehKYOqnC8s8HeRPvVz8KSkyIuay+T4zXrbasQTJPDBiH3d+bucicTt80nENvLW+zOJ/W+MD+Iu3Q+DSTsds8r/EWuEpIBkpe6nL53Tc8h5yjl1olU1bElfbROElHc7oO7L6WAyZayopBJ1CWsLmyWz16skGo2HzGoBRw3EBclt61EgDmSTbE68e+eYvIZDeyToRfe2XZtoKpzUIejjTBdmaO7xXc2lW8TLJuEdX58xFJ4AVNFMpVn6RaHWdqlyy1RZ0MFAkVZDzlfoxEtfGod0eNHjL4rJkrc4nJ7gMJvj8pS80uZ6/9rjad8eVTQGTDNTSmgMJ/6Pw3ut7qYAsbKpyBiuDrIoAShxE0n2Nr1VBpvSsOiy6qMTUjNtUql4/PjpwFAP+s2x8vvxoXWLYtDxkgzITqSvnsiojV1m7xUv8pg8Qq63pYkuKJV4xKmRg6tQ3/Ad3VkvOwmlJ7xayo6hX+qL/gL83arZhsLajdS/XNiBaFgYUcc9ZJfpO25kDNSnz9vaFjDya/XkFBDge1Y1Y381BAwOoV+Mpf9gJhhMBKLn4CIsgzVG6DVsRpwg8tal10TZCIBvYZVHUTZ24njH/bhnfwH6azpA00B0WNAd9Al0j/azrnrSLWhgBnoBfQomTxraK54rw5g+7fkVst++GEHqVdJKKuTBUEuzqOaWlcNXN9ttu+Bsfki6ILFzYiD6T+rDD+o2cfeiDAQCgzHesDW9bQF4YenLAV6yazm3S4ZM/1+n/KYcIxQSvwPnaihb54fvSmJQBTkQ0TFhdNp5m08XAlx21YYJOfk48ppCOX47dcmVsWHa7IcPNzEdF4D+smL2PVQ9uM6nFKvpXluAogEKvEIqHz2T+4/XK1byaqr+2V5dcMeNkEd013pkuVjIBy22Upb4srtJb+4IN2bxdaKL2yMinK0q/t8Tw0eQa1fCct6WJEiBC0Frm4aDg37AH3+JepWLvZQMP5FBNsdFAn3VzAC/6GtYQpfKiOpJ0UcDrVbByi+XBX4hcC2WntPdGoK+yKpPTh5/7T6MeYqXy8tULaK9MWoorQ558Yp/YJvk+e7b9tOMXk6zOi0hjHu/XiA6mzagM5yT+Al/agmt6E7/U2xlfSiJ9cMJylU0Alq5E0XBXjuXFPpc8BXNzT4E9fSoys5zeRE3tsFKl+8sDjFPe22CBnL5f+XgOVSKE69FB30uK5LN/bkmDz2+LGgDMZk1Am9RSMOs9kn/YPkiizLEjIEA9939p2FVwdNjc+SEQdJ3BvRQ0iTWu8xiR3G9UmesSwtgojoQJi2jPRSmSmATBo7PfI0q4aCF5dVsoRS+lAGTxP0L2QevWtF4zesL9+fE72fxSGS+fvmcmW3e9xF/yxc8nVLQ/DPUMpnAt+C8jdOi/hhq7APsts6iKDgNg286YxXXQaMd6ll0pKyE7btKtYEk7yD03QeOdoLa+UvMWDAJwh98gIcFaMQAmQ4TvFo/aOn8mzB6UYW8gV6TuNXtxb+SBtxzG4Tu1eCDmfdWrJ1YDp9BTmdEqIDyI3QTdsvF1Uf/zW+fHxAc2PemGVsbotznsL1k5+wbZsYalKsW7A95EtTU5/bLBrJPbWFI3Kb08NiK6qAI6VSzseicCXuNDzQNgU2pyJoCw6PmFJ7WN+Rg/UGo/9fKQhmV8Yf3Yvc3nKBwjT8+KFpbQs/rIhTnhz7m87kEwwqHrdyL3pXcEiFv2z1SSZL5vO+9U8mIByj0ZlBonQCXE9mWangB5ixI0iP2yYab/juy+0mOG1AwUwnrbZ3XOxnbL3RvGIZbJg6M/qE8ccwPX8UCYY7fMMhYLlVbk7cblLMXuXqpmK0CEgiWKKxeqJ/PSoCmAgGj1m27ZGNLtU3WLSanm2y8XUl98DqhGD3bLWpxRyzyXUmfgGNyIiVXiQ190rqLytvAWz5YMMoqSkXz2t44atf3HF0cwoathYF7v5QmxhgyfvKBwrIMVGg4CQL4SI/bHSQ03cCqoQgD/UTceQErm1GWshhiC2ZbPMD1B//l9rzMUaE1DJywGKbATFZi3z3d1N88CMmPNz7JecPFzp8ZisVfDZ4SV7RAWbCXmz1JozwXwwBvVi5OoqOhvo2Ew7TEcWKLlGOrqFHjVk0dJAtQ4QD5ErmMwKx8nlpqOh56YCpb8zcb0uoIE0bHhUFRi3Cmqo0tDKscStK9pXq1bR42ShSAI2/C5MioHWxIb+faXEsvXE6B9cBmKqxJP3QXZEl5SP9pg384sCGWF/fNam8OpkGUhOtb4WrvesjQCUCtO7diEKv7JPFCsc5V5F9eTSkqvkKtyFEq9gBv1jxTYzLqqF4MG50eSB/xxS8e9UCOJd1qOz82DLM3me9ncwLMc2++QF6UIuRXUDnopDYKyPnNbhFsyFIAvjCIa+EN5dXAPGYu56zxHorv2k5rFm2FHNFDtU20oyFoxdfLe0L2hqyKBCzuFS3Ld3OaggZVWrG5jj1t65yqSfM9U7jj6MI84LQ7ZgzviOQD4bZ9GJpU5F4tI0k/lDNQXVQwvurYXfQDETSg94VQ5PaLFGQ1EgG+OfO97U+gncutO7woy9amTRkNZj6FPQ5jN0SA9gpaMSOOhL6x38+47gLIn9fb2TMv778DfxDOrX3rzNs9YKYUrzef77fiuByOLpx/0vMJEoMuGdEKau0igEJevE+tS9SQzXDu0yg+1kdTrsYTNcYGQT9JFnXX9xorrvYySfyxpJ8IVrk3nq30bfTYgErW2Js5bA6pAs/FCn5htiZYuTgFMLsTbZymayGZGIO7C17lbF2Ck5XqV4uSU5GHmsmKYkcDnWy9Uxyc6fiwLk4NYR6sCIeU5nmynEY0vjg7qzSi/E579eEoXbEO8bdHk9EvnEpeEW0lf2VgO54YVgfiq+O06mrMfXCDLbANkfNhXqgaCRAjR4A2WLJ/6mLCkOscbL418r8lPHoDpjKxBnknXQIfxoYlb/viVVAy71memcMqpfqvMhspXi7uF80I+oWyPlEC2jJQSav+2a2498UFJTN4KnrN6E/ibIaNCn7mZvmN9HWezAGLrACFZp2+Zd6r8Kp3t1ifB7uHBOlYs+CDXXqnWp08cyE6l8nWOWLHUE61BPHv/RCyEFHQJIPUi4CBlOkbt7aCbLePry56zOp5s+rtsjrmYATBXyJGjwc2LTK+BNQw7KdWuY6R9N/u1dnzREYEWldodPAbSyOXcDhOcPqZogMAH0GUEqYm0p7rqLYZ9QGu7MigmC1YhwppcRgDZ8OVM4dKVwP+R4pzW7vYKty0/QHTezrAXfNf0FEH9iv7BiaPIQbVS9N1g7WiAyCmeXT4fsAcPVRqSUxMWkPZJl2ys7NlpNa5Yt4rFpNrLzOmKitpNN+5Djv5gl6ldzoTq9p05yzrZMKwNaDeaXejGznUoFCm1qaWNQ6BaRdPE+lv4UFg+IKhyUPi/3hh87ZoWxG98ydlGJ5EyDP55mqjJzBjYfD5IqLuh91Xk9/hTdr1pXylM11wuCpCAM4HdhoVWsVQobJO5stA+FEDiieUAVaua2mB2chMLet701vAZpx5AvloMZtUwpkWuzuoWF/VdiyGSyTbY5CUNxlsEWwNwxlZztFxL1nMwnzQG1hh+L6k1pMYAAZrVBA9qUn1Ke6Ns/0pFVh1n2vH7vaR9O/sZTfM/MJ98T+rPdSbv0ZgZe/dGYZIQ/IW5jTdAmmoYxIs4XWnkwxFIRyOBFb9H94RSs3RrRLrxC0yAwbb1GDIn4KK1EqSUIi3mo6DoVvQu8fh9H3sCo6vqHTWZhC9qpKKfD+nFidxUwMHGheGj2J4CCIA3ajIkIsEpNhb9CkPKunkv47vwx5zxoAw00d9cpvn1nP+kLZ0zQkaR44nU+xqvxrzdtRfmbVt3HWHbqq/rX53kK1yR0bs5SMEywJCV/HOPq4jVUPCPDysqbcZ/buvwDbZwjCJMYv3vl0LGye8Uj6CbNiHaKFNWNQVtD+9uSkrkg02V2YL49sHEUwYHS1YVJcRxDZ/IKY6zR2egcKv6n8gTR2XdrUWhxva2eUpOgCG04+AeomBzZ7dragttxoKfTQ5+ufDhUjvSPx3FKp0o9aG/iOhkUZJIGl2mmli46hriILtSQ94PQAuXiUOWyPNtpCcseSSn3DxeErZfKTTtEeDF4HZM/6abK6Oj1+f3N6NekO81aL89OGBaJVAsc73BQWltJyIdyGzUacFWS8fpUOmYP4pbH7MJmn/r1pX9Ffod47vofgPRwIF2QCyhek2wmdmlO9ddO6z7lxT1pj1R6JU3t0TWArBlrdHG34HPwTsiBp17ljBQKueZ6t/I2HGEWnyfTthccPlt1Bm8XJpVspl0+TLfPCeRG1eG7ZKdvf5cC4buC3wmrXjW9k/WWQnZgIWkJEWpenWNkjApBsigb6nMQMjYFciESrSfdhe1mEAZXqFu5/nREkxmus6Y7+lnhUWIVagrzUNGssW5VwfbfHWNJ/R0WWORLMvsYEMrLPHu2eU3SoAN2KCHWZSsh2JCXUtp4hTmWfq5drGSIWqB0jaCobDPhw0X/TBEKNCCeflA5r6yBGoYOIYA8s/culd4rpJgaXIjjfOCVROJJvO49ORjwwjFVITQ+s/1f96qOUcP4vayrN/wTkgz3dE0HN2tczXgV2a5+MsvJ61P9UwF0kAJ6g6UrT8JXAV1JXaBPm/qXgwbs7pSC10IesVrmfpWXN4U4X9V4h75PADjNXq/6di67KjO6/vP6wOu8YqYmsGeFZxDkBbAxvqSQ+hiykFBTOZvF1+yiupG2RhnXYU1/W603Ajy7b7UR17z8P3h8dh5ADgY9kJMr/wNsX/LCvG9qwGjdm673x71ogdEZVoPp5G62MNdAtSB5diF3G9WSilRjDw4JKrqgpFqdC10+p6r30WMJKGeCUXP3y8ZCbXZtcrinM075WJm5QKC9eGJ9gl1JJcgZfOUl8Hi4jZJgIJ0elanlNHR5Num1W/10sIrvo5HAsL7deRd0YFzTEXnodnJFod9EQsXvy0XGR/oi2x/CItK50OFxuWlGp4ptOacTO4kj4rpfStTaticWzlDAbP+2M8t1ualvFpOkyhw5DSEzB8jCXhGHdz78C58Ag/Vs6UFZg2jg1riP9a8C9rC6g79PAnUyCMDNYWM/jMJMNSePFBYPUQL3L7S/CQxl+19mKAWyDuRb5SP5cSBeClTqF0meBlgjwZrwxUSplLk8jk6+xZ2vR4UjET1Qc9JZMXi1LAykFh/A7+ows7GCTn6+TTCoq0YEfD7M9xj4xWk8+EZ35n+lk4ChTbau0OP0L/GNCuE+VIq8ySfqjrxc7aEYN+nAZqx9a0sTdRLu8AjKxNcd337PG6KWEHo32JZTMjoKFEkweExM/ltgRCulPntzSILSyz4AniaFn5ujznpEOuq/9Th2JRwt+j0/PZjMjRKwKmZN8c7NkSTPT4CMmX1kqH2ZWY2lWEo6V1ipdLsKtKsOUeiDPxK6Oh2HWg8dXuTAq23SbAOmQFt441oTb6qH/zOzB9HbiPPrQJZK1WxD5sBc6zsU4/7yXVlGwRiZc7Cwk0eJF8YZoRnMa4dTPNPSV1bZgIQkwX2DASJkStnXQqNwWbdA04ycsor40C04zYJfiIFjccW8ft82WeQAhaAzbIZP5scGxFwyQ6NuBomlnvL8fPHfzcB9kCrsQftms51G/R6EMw3n/fVAGdq0Y0bdXEGQFNUuptFoyCO2Qs47Kry/bkNOwRJkP32QJyhvA7xdqgWugUhKKYLhn56IBnGxjtP3b7ZVO11DEe3CsBBbNJ9jwKOwU1mb03p4WNZIFFd6MRD2poK1TGdlQCGpzASEwd4Y81NRxVqcMmqBCKgCHJt953JrQUvI/g7uAfNnm7JkxyHr9pvsHAzpnr/Xwu26nr76mTlIhx8l8S2EQ8LWLXiZPDzveN2VczVK+F9Xo9PoqrSHe/6ww6/huibQQmTpDO7Pd75TRktypxk6w4aO77cd6r/BO5WMSqg+muG0948pZ1uwE1VsxaF7r4dKfppLUNbvk2gNwuFWdsWimF/t4mRnYRM2ZW5SFV4aK8Ejb41cJLAjxNDpVDVE4GyQUg2RRFo3UW6eW+HTPBQGoolEHp6K53skwCUT0aKv7bzc7MOG0/fEFs/ibqcb6imEK3ySYXAMtf2lhtxOVpH90upl0n/os+VyFh05CPlJ53CI5ZYftoynRgNJvxf/coVDcMN+iTbifBhg4/4xJ7Rfw+agNA9ndzAr3EWOw22Awf20INKxs07kRkHt8/Bt2S3F0J5zPDtJ7HdQS2Yil9Cht3RP2DHBqv+yplGNNej7psWJL2uIx8Bja5l1bBMj7kbdXeqE+uX4k0wCSThqY6QVn0skKcJw9BydDj07Ma9p2qEpc0bH3NRTm3ryzk6IUxAYcD4tuy6nmI+Y+rMxqezQ+BBwS5kTrLbKb9aQTmKOxm6wCHxpgiYNhmWGfFpCfNb0TgRiXUBcBE/5pfcbwHxuqeeGN0nssiXReSjfnXoWX8hKhtBd6yNu0Sifa43fC/vF+7yVjiagUCl6rwF861Up+pFPYDoAIw+dQK1FKC+r4mDQtlFfl8MU4i2HE+7Yuz70klC0NBz9mfF07AnHszLqlJazn8UVoZteYLlQ1jWnJWa9z8AVBlbk4KzQMRV3XXqzHt2sxthLOpTwNg6EhQVg28UCAgIH7kv1NIY0exxbtLn6QND8JjNADfr58qViOCxw/EzwSnbAyRvxBK3DounNfJN7SmpR6mCMbd+Hw2L30+ZEhvsD9j3kIMcISQUsM9dFcQvnx2z9MICyxcoXV3uJFSYwMoroB4yh6O23o+s/F5e6bWBeYNI5Cwz+5DQukCcZrpPIPpsddyK2U0KnzAC8VUXU5vnZmfYf+vopxHm6lON6ArvoMJXth+BODyzOwfsDUaDYS/aXAv39ayAzg6VSnlpTQp2I+xEK26gpOFxC6sZE24Ae+ecWRBfgG7ZYG/ZdSDTck2Zql4oV7fH9h52IC0fkyJDAshlFlEBgpfMjGY6l3bghaP7w8eYDu0vkh9Be2nknI3yJs/dj7Cj6qqOYMWdWIf+BW1SAq4xo9GZCKNAZNVmdoys4KkU2VYyUZMNAZ3waq0ZhFDwIbvIu/CP5e7YVJ+QQoNzA3rlx1cI4D2rEXcmY33Y3wyiDtY3Jf22+cUuxYYLdA81Bk72v4AxIXQjXN0xfXVmxcrAe9CPOdV7uz7ppMI6+y7fthSLymvCB2pttAuhZFcz/eN6O+CdeYBurEiptO5dCu0ULxbw11bMj6QCbN8PTTNEEJp/A2wTNQxSpsAiJ5R+L8BpYKwp+spSTA2V5ey4jW4R9Goq+77E7hyd1/+SZUxgRcVNlK/LQBNl/dufFqvHUwb0bW945H5Ikufxu0qDYv5Em4QILcXFoOOqXe2iyz4jowsOUb9vRzQFLNwlvj4qch/e0V/LNk5uTS5blImd8MOSJbthH2G3ISLkV5XWAqAr6VV/7z5VUqOQKFLc1Is/9OXiTuAHw+WgCavYSgeKpI+mhwnKeD4qwAUrdEUmiLEG+tg+A3JmLPgQr8vej4Zkl/87WMuqHNgOY73tqsuWfbuD8WEoqFIWJbA9eVmCrsUuXzJlE6koRjTYHg6mMAp3tMYqPD7D69ELUCSyl8IXdF1f1hVyAS92VfGOn2/gZfXckxfVav9PZ7mcO6PCzkXXGwx5LoKrgV1haatXVur/NXq19FescAFBllxu90kW55laiypZikUVNi+YK5bn7VWwdxCeh4N/knQnyfReWWdwp6K8xeTNOF85cUYz7Ykva+503dnhpnM6P2lRMzB/vVOskkOIqNxzj+4+pRbRPbagQ3xHyvJXspWLP++AGC00mz4LS0uKWF6L5qF+S/3F8NUwcV0z/jMRRXFTYFokwP6mhbvh8F99cg3EQ9hLq8L/28dxUdd0NFn93m5e5QQrjVEr/8dqckPKaJT8l6ZNiAvh+GDSm/E9ZLmROhfq+xkoFGPj6rUdeKseRykLRngz58wFUCkSC3h2b3HfktRyTP/+UMVsFQA1ka2SLjJOcS2oMWg75cFkydOZ1/Soxg9/KPi/yv4RqzxKBOm1A5Zz+H/Dpu7kuc2hAbDiWXBO/gOWP67aM4TBPZbRJpFQDJ6YquTpyANJMQaxAkVinKsAZEMsQXghRjy0ABLemjZbKT4UH3Wq9L6G4BYPx5rvJZAxkq95PyFqgDnqiJUlZm6t13TOk+YB+lv0D2SBQrRaHir1KnOPjA9ke1A2DfDrvloBVx8SMPMZ/EY+DUHNXAM8CJXsZ3rKaEFSmGW7nd2iBJYAP2zE3dNVyc17AV6KUnzL86QfQ5ah635Kl2a2iIWMHpvWyGy+rzmlMYzXBnTk6gBq5+fQjGFz95yBDpQrvndNjGtAJBFD/qmDxI9g0FT5jMU1OgI5JjKVrqh7GTMwVQtJOMJl0S7A7+bAt/ZOsUMltAg+9RWLxumHZLHbCsK5JiNWJOqaye9saPrl/uHjbTz7mmCjSwF1qyXxy8tKuKo+p1QLI6H51wfXzlwIwc8NXXlNFm1eky48Y7l1dVhF8blqFq7epmPkO/YFXgBhYFSOVbHGhGC+qhdOHGycr/qPl5AP5Qh/i4Zpw1AC+CQgz2ghdNMqVmUqnqdVOZwsSBtY9IIdV4VgKpuDatgqJK40NunKiNEDI9pl9eoEgO48Sra2MnWXKv6Mh7+1W9LMAjXxpwN4N+OT75wQw3WPv2E+IZ469WKUaI3k3YlFY3dz6zCO/QSCLHQAGNWeprf0yqR/rB0rHwrPHA8Qeib4KUfslpyWuwW4pp9rW0SYdN/KCeiZUBfCUQWIZsMUpF9Cpu1ns+VXc/hYuwf0hV382aNpGyX7DbowhiYirhXLV1YHUhCth4MfkadUEKT0/vWWnrdtr5+db0FYL+TqTEMAGPYPR9UQqBk/LSdUNjWMQVauozLYOiB5ZNSPWtOgQuS3qDR52IpmQ4YNQLPyQUY1ht0928iRZiM3IInKfPV2diBUXnwdLzOZjV4EYGOdbxLXm0z0ZUMzHS/ainufxt8KwZ/Btgc67nUC8b6g3FbxyJDg6cfRUN8BDF2GJ6b8UkE82JJ2xVsH3YYB57w8YA1LvhX/uB9T+xBhtpY0rIRE2lGSObWXzX/2RvFsBczLfXqrsevr/jLBALCVCylD7eFlDmRhV9U5Kma0pAZXoaAdBXs8DxmVVExktQX+e1G0NK0xThvRXruKH0XTP9AcmdkSc8UmfknyUp9jKZ92dSjYcO7JFc5RH0eZrh4QQ+qkmItXOzP8rx9nUehT9OG+OMTMVz2cB5Zo32CHBNxAMHF1kZI9/6ay9dUfNuVpGRvZPDEAYVaflfUQcmrYLY80J1GNiM7gair5yNVbDcTpenAI0NLSY2u8qiQHlHCPApCQ0it7dbX69ngxET1LSTILZkS/R2B/cECr7jZHKQu4xeFJd0zEW7z18ONVxG8e5+/TiikmscZVUjCYwd/v5hCzQP2r70ArEg9hTtIngf2KG0Gn6oZDzF8KZ9A4is3zFg8isgX+mCLJCenBmZf5LCJXPLjwt5kLPTazGPt0MS5bqZWSBp0VJt8JVBHkAsS0ZZOcAwLm/TLQFIG/iOLEM6Pt/JbaKwbS0s2Npcf6sdkHSDpGadRFuIqgAxeVPUHh30wCnPmWfj8oyiVAvUKWrMafnWNreq4r0n2Z0eij1pAtx3x8vowwiqnGnCGgv6OuZBVa/XrFdFNrlXdWPRItNpB5siqqkGg52ltruM5f5kr/wLrjqMTWGqBiUDBxztjWZskUe8rQuafPzxo1DNBiyy0fjzFX2iXBIGNVucMdrAE5Dd2BdA/6/+NjM4EoLpTpVlgT/XpCWwcrEo24GsLuY9m191IoX7SIEBVn3g7ICJTkHUAWPSZ1Z9lWPHxNvu7Lx5WmUz81q/6OR70i99ICQZiXhwsaEXE/GSd+8rcxC3rLuuAeYi9do/o+eGEYK7Zhijt0WIMQBtMLsv3LfAquIfGGWaf74P0kPilCqrtru5FFXs/XwvzaW7RTsIH6b6/bFjhad+TpyKkSlV6/zPsZwhaFZ0PmGpdAJqWcxaorhEuWAKAGZ8433JUs525KAmxbkXLpr4lvzQ1Qe+mYH/VnRxPInxJS1P4Gk8e+w249ZUx5apqYKNi1OM59CEbGkojnZHX2NEq7JQsk/IxtKbad8PcI59NQUrLvW0F/JXeDipbLmCvC/bAEj723GFGjiEndCVRI6ZIbDrijLYjb2TYw5uaYeQ4MSxKB7vDVDiHKYmhWgNPZVybglo7QGm2U0HWmRFgSHlC/oAk1ZPbOG9+fkXjGBd7e0Z2gaXMD/8wLgtz+ao8XKIkdQbJGc8xmdKAHssRXZaShetxMCArHTzvqO7K9b1N6e7aLucSYec1cHxe6SHEc7XPPkP1M7HO1nwNdMieAhiRVPnS5Dk6UBIRZ0c9xbxKEZ92BtMaQYkxoEhENb6rVOZIP6WDoGUjFOuqZjaIqpwc4gOXAPjIJBt0QviHnjKAsFU1s4IwRBKhyYI2XRjtTJDfg+TnH9OufnEwveeURdgTnxh2sUzFyYjR9WLKt047gtSv81eTrlC/bJj3K78LO/pbTpk0oPsrwHqGq7cuzg5gNdbOHZ9nRvygn+HBlhoeI3gmnF9nZTY4l++8UALXEwSDVmz9v/yMV3px6gsGOA7D1flWRUfN5b9T7/ERFgmJr2Xf/nbrZGW0d433iAFeoLdKRcMSdWt3iUHfCbED2Pl5zCs+x2Bzkg7ZPYDnWx2G/6/W8Jd7U5N/n+F8bCSTYpV6qFsA+qSMNFsnbVYSf2eRMko0I0zsQeE3Xy1nvWCgtCbEzQGVb7o1NSA4P6CvkSdp6CuywXnbbCxahjUJrV3sBqWRxKgRzcaeigSGMzjUd70jahJG6kphrxk1m/U4f6GOUvzc0tnog7NT3tqUS/w+C/fwGhF5gtmclqZSHrh8/D4Ej79jmOcJYHYA2pL+Tv0yvJXpZDXuMVTKGD4ZFdbMtJqO3z1phY+/LBrxvImoOw5Fg+xhTO3t/5MiGOJZyJy/hFFkjKd6dfzHU6gGXp3OofkK9ejvDhr64iDBBuO0x39gHsaejKXWXox12OT1U62WudS1dQnugVBcEiaI/q7WARvoELWV8a/UPUC5u74oUtmjUEBDQkSWpGZMc0GrvquBL/vir8KG6+21NiitIIDhkn8Hd0Au2aVfla+OtTabr2K4Y6zEXGd2zTppJc5twjgYHdBaIZO/gsiAwIHvlANzrjrYmi9e03EAWqzZX3awD511yyCS+EvchMgVH430X0zElocQFKRNCtXGSE2TsiIVRDbssZucISgAj918M3gSRiRxgyMUzmFyClZdNbLHbExWv9w8W6FP3rMLgyhZQDub9185m1AFt1I0VCSWeY3paHDNWHN4aJdUXbnyCkLpOHTk5cInkb7t2pNfJw6BVcoJgNiZ5kVrrwzqS5kdEB4HTYLPCAKKc46XwCR4sRpf1poG0x/VKOQfhvqGsQ95vxOseU0iLC6t/PWZoCuuUvQC2gODtqEvAZvkxVjeftWr7ioMEZu8eLAz0lqQjO7d7iW0UzAprbJuHvT2Dcl9Eug2ydDYblDff0a9pKjBUwYprPPnlnaY0woVICCst0u1eF65O3yAYTUI+xWmXYHQKtedMaCBaM2gxGBBtPnr5TL9K12ggr1fJ45nZ153YC5jfAiDLwxIzeY4TAtGezxrjAYYIkKItaDmI0OEyekrWwMjFC9XHrxtZoKd3tkJXt81jrj0mPImZcEopj0wdz2gt0s8FA2hMv5NP/lFGgetEObNjtc7s/4JKArWiOM2v3BJfpFcaXWSOl/VpDI4w8M5qp/kUFCCe1cevMSYlhcuxLVVEP5x6HaioJAWJwNtLmteXTz8bJar+K3V6WpKA7/koztg9MMCvHgisG4Vu2ZZIBg8wToAAOKxDQBFZE5ZZq2x9tDsWLJhuBgVnyAPofgSz5HiAqu31WHV+6daoVYanmQ0YPbSwIeFzJ3z1Lk+S7nrjD8i7qTfmhbGydxZNGl8R9K+Jbsf6wH/CT00merCneEKwgVkU9TNiIsvVQc7XZD8C854CN89D9pyxrooo4H0SdLoMuwRFT6CBlqQNT1XqjRIU/fEiBzp9UGTdDM4u5/UHW5z+3NBqm3rgmYh6pENvJk+EJv3znl3p/HLo0f3W5Ql/NW4QOwwhT10pxoa9DN0bZ5/rMZrRhuJ5AjSWf/ozK3MhBP2bxutmpmyA5lQWKTlTkvHk9U6+RO0MJcAJmC60x6k/a0+d0z8HK20IJUs86nBue89vo04/CYUuE4eE+5Jluaq5suGGdY32O+jQHjYfSYwc2MuzNW5DtlkCPZKgfczV7LXgx0Q4vuFPY6UrpmGSGhA7sSRciNIYiHDEfmm/+Tup39w0XHVae3MT6pkm1e0fttVebrcMRJeScPtzLUD5bTRxWUSsgrqaMECADpZBEu8JGrB6ewbH7dREO62UD3c+gA+YrQeFU+HDoNprkdVMRI+PlBhAcu/fiJc/QmDXhvwfKfhlQ3sZcDIltft8PgdJGnhPgbxvhUQo5/BkHHVeYjwKDSLbaedUPcDwKN4IMo3ROY2edBKlLtd2ygxHWBHBBKRrTOh/BN2xfF2jOW+3PWy0GdIAYzSJ8BNlWa+qC88w8U0H3IVWzT+Qn1rsIFRf5ZM/qr1k47/GTVgYaVLlt+WnqvpWvH9AB2SwVMSgE59k+c74LgvguxxXbQG47PqHpmiDzDESKMmg/2rBly35DLf/JUGkuFlKMS3onWOqYVp5De9DR/siFrPfHw9CGUgoJikVdM8ePiBocX1NTsgdI92zofoiSdzKrBeIGSebZkiGeUOzQ2E4PF2e2u84Hz953pZ3g3RznnlMBGdw2SVjdkgovV5lNL5niySrenU29AP1ipmfEKGYh240Zr4O4OB6zhXCHwQ6+xOYK1VGl9tDJ5PpzIvtlOSm1921R3IlKfnz872BLXSa6468jVrPoeb0BAIGZPFzhEAyr6uOZjUeYTT6mFDmiYHu9WxaZLrbV5TKk0yguZgKdRKoguKgIOBlz5s1LkMNQSuZ6WrReOjz8r7/XZdhhTuHZgudnOOb7AM/adjhN2ZTpBd37n7BB2iPoo2QsThw+cDsvRVSgVx8pDEg7OpSO6l20JEqfYCfzSvPbNglswWQ03q0ZJ0t4XekugIlIWkwUh93vneLAYPIE67OoGlCORUUgpCbPD6WV9mP89PlGOUyEjDn9lfueeiGf02bZKqoNLi5nDGASMBi5+6pGN2wnL22hX4q56x0UrKPslgQ6dFmGo01h14e8ilUZgXoGJHjJD/IYsm69ihZY97+X4gcc7dU6Ost3/zCkGkiHBxjpSqI7QJb62/aOgF5eKIR755pHpPb8HP/9jYGJQP6ZjtVs0HdxYQ0KVEvm5k/GrUVxRg6MqSMpXDuV+qwjXe/HTw/B/l90dkYhkS0dAN5FsKrq0T9696ZtbDzfZdF0UHPXM2x+BiQykhRbX1b/AmMa3HEtUr5kMnUvSfpJPQ75hdzknhUVJppN1UtcReBhlnIkJPZXkInHDa7uty9rhMS9nWTOAxeHPpE0U47JRk7Pu4KZzIx1xUzznbpFs8ezEqfm/eg52FABZIiMwxwl9Va6xM6e2V7ZjA/+7V7vvSJzNugzmxWxI1mxTYTwwN93qKGIOzo40iEkTh70uOtpXVUPeyyOMZ6vlzsD5MaBEyx5q/GnCyqdBunNTfwcWgA/dX7XppCHlBPULc1s/R3ASVCIA7NkPtq59KxeqjrnlP44Z6oiZr4g/eSkOm0hzGH/A2TVA7szk9bwp1rtR45oP7iUMzgVc6qKtXkAuCMJMzzxwJKNyQr6IZxKTCmqE7uDDrDdH4gI7uoa2z1hl3kDoRwPFZgJm0EK8kITwMNHChZkmyQ3Ldl8S/1cIM5GiNMFhBAw3CU/sTJy2zp8P5KhbXAJZcq1Cn6zFPH2+5zBiGucCT35YHbhTX2BV+Rf17uzBbOpJmeS9xevw5Ur1EFoTO3Yvnf58AeuWccKNN3qQEZJPT2ESsL+EvwlUjd1N8AMvGRbeYvjnSHVppml4pLDIgKWZwqqgFRPjM7bf73CtBe+dLG0sW1PfOtZflAWboiy+OSQosXQ3UTeRKIc2A2l7Tmip87p41ykm4+DwWHM4r3qMDGcrVhLuUSErjp3+0JNV5ZtyMSnJx9tKiiuro5ZkWj6j9PGYeQvuUXYasI4qZkhiVwLWf0Wrt3pK4vzzXgAXh5Dfb6fF2WswE6ZHFDhdZSLpD8j5WIvtQtcYXwntOetE+fcgxuD+MGl/AvA4/RyrfOtKVitSf8771OU5ZyxKfk6yyjO0Xtn+7kucZ4JRvOZagWtK11hvzAmKfhHid6EA+y41nedmKReQ5c8Ccav6XHAXcS9LyQYiYQ/jiQDv0uxQ+XZeqUMO6KG6gbmDZ5UcRbYKIkq2NoP5QESTaNPEY0pif+ZzN7rYdjgAmlsRRAiI3hjjywGlhGP4286kQo9A5LwfjXf7PFjFuOmreaED6Akka8mxG/MS59w061omxEieCLp7YEsg812lRuTYWqx81qZljSQEKaNtLjO5xztZyDzk9xJTg/4k7YBIUGbMC9ofo0qGi04ovFyfMtniM3MulNYk8ncTBg1X6SaNsd4UNNy7rogxqOD3OT7cNL2J3QvVnL4Uzxa/cyJIq1cK7yauBajDyt8KiUQ6btWj/oKVT6SIE7GGB8FWTiAt7mkl53Vl2FF6EaXxb6UYLD5p76V6SL8u63+VLVm8DGSf89bVUZ5ta7DJZ5KbT6vKfpHryqJDE59jfRODSf5P808w1G88Fq1gnEOUtC6zQysIgK16/dxuaTGR/rGqNq1muoB1xF+e6/UXpF6e3Nd/vBaN3QI0buCkYNEGMB8s+OXemIhtDu9FutfNuGUJx9dAPU1lzx0r3GYvV7wxF4lKbmG0VX1VLYJMYtD5M+8yxx5dE2uSDCyR7FNbyPIk6GZJr2FxwgtamY8EHH2c0lRHh7At1oCvPDywWktTJv/xhukzi9OBdYV+Qx33esNm20/qjVE987ZneoF37XUS8VSZqNq6QhDrndZegLyu3c7U0PRIk4BfsoirDYYVsJYkn2OT/mCUiFcgFSxvZbd81VuuJO17cjuuKm3Ixoow5/WDhAP0bFPcZI0NJkuHEqbHgQloROMQGaI6G1dzzbbac5+G7atBCuCBfeEImLlSv70QjL71B4GBUf5qWKw6u3MltMwHLnZRir7x+/zyDVD/Yln9xirH3ZEDubnom4goNXgjWSevdVNehKzRypWw9LDPeGRo3llZzbmdpD7b5pCjHGBaFrslVlUWTw9gD1iMO6Zifi56CNygHi94QRnpZN1q9Q3//dP3P5i/2eQAerLTvconcVXStvGpH55wm9ysO0pmUn4Ka6AI9vfr0RKuRShkK6naT//ZGQEPsQe07BWWEBswXiXS6KS9MOosyncTjFOZqxfgWAmknFhSIKwOtBYtANnqN7zcMvp15XOJ8PfO3SPYSOXU3li0bBYFbj7qO365GLmv6XYa/S41r3Uee07ylk7K6F1SVKrrqVyanygx6BnORDX6S9iUmKYJjUh+4wJJl5+voy36jBSIFfk0HXCKkkjDAFUg41HoAuUzi7y+ICTLwHYaV13E5owAy5lM8Z1maGppcem1FOsjcVGEFKUzLBIDQz4OUycTYwlGSoszTxPJWttDhwxiIv9vJsDMnpIOC+PFTPqGcxOtGRIikyAv1Rdoms8Nhf9dUGlxFCaMTDkz6ocqoIHKs8f2tIulZGzGyukdMRSORiuWFRFWj7RAvYuR8Gk1HQFXrkDWcxg1WC6FqOp5msWYFi8LxAWlJcchN77Gqv0WWuBSHGePhgc865MLVJbeTmEAnID+v/E5krV/WA8/bClPuwR+EFkvvJHEd1vslPDMDp4zHvZXMOXa6EQPzp08zvvBXvuywn+cQitPAZEfUUd7Ll7Jh8ODulFgSU4nWUgW2Jta1ov9obPG7hQ5DGAwj7o9iovILWIhCsuExBW7mZ01cH7XA2I9TIj4KdoXz4iQ+9nbOVreb/3A/8jqvPI4bhHwfW3+XVeYC9uG94EcN9D6jx/BqzW0jbULZlRCPU7kLhLj5pb69Fk34rgGU1ndeMMygwg7xV9diVKFRiKwcmofMC786o37wR7FDmmqQ+ImyULL2QXDafN5Q91ASG1dVYfTozrrzAaOddEKC1a2hxCF0o/OjdrDmn2Np1PSaLBNBkM1zmKDksJLJWKowbgfrsDqlngw2Rg79Vn2q03HsNZspf4bQ9Nw/VU1xJDgkCWbQkoAZaU2TqNR01Z/nQx3hZJUltcmy29OQNmnKIIvQ4qdicnGvT3Dgh+TX4AvDgRc5jyDjNsUirLlIuRzKzNKWtlqbJqsGSE33sx2G4J9malbodd3xY2WW8WAK8+liqBHwP95+k6ExAxjapTV/BZ/hR0BX++kRcBtGPJ76qHin4oLS8xk0oQqhqITZIlqn9XVCeJfFZCXd38beqh4za+ZcXx/L8ILXcnd8E3/ZriIT07KSvuWF8Ccbi7wrExk0KFxXzUcXxl0e5P+RHKdqPdrsjMFpUAX2MEyE60YO/FWX+pAJarcT5XgZ/OZ5qQPcEY7Vfa3xVV5QN7UyDbm3JWg9FdosLRNj5ukAI1hLl6SOswGmMEAvhMs2cRoQonprsFLyNEarzXy3KmEwe5rEqW3DHHv7edQn8l1ROKMBdOzAV61x7DQyR1QDIVHRYSfV3+H8fCkq9Jj4UvoZVK9F4rFZ+O7tPMN1Qgd0wtHmGYcIOvgx6Ie9T/XCaJWn4F+EqMx2/G3VeoXT6l8raYPpCSZ427r/uQGxcPsvfwqEgEpIhwIlb8RWwq9Mt/zBZiGGQotEhSr5RjNF9h6mOWZD6Sq3EwJSPw2xoQmFP8mp/G5Vjnq4fxjgXzigC8/4VKJOrVXqAni8FKKWYFZ8jJM9oewGP2OGaVcY8nJHDR93NjBLORKHlc7dZNYtSbVUNcDR1veEVzMm5k/PUgCvMfmJ62g5v2az8ZKBpcS8nU9jDxwqjNBcBUvMoACxu1rwugO/YhPvoHB6em1j6Z7TAoPKl4MlaExor7jEZGvgk3LXMMGkZQoWG9u0CwOQmMmcfG/cWYXYWnbv4fhYyHO3w73ziRoWmxIIWshDtrJYe/jit8qGt/OH9PWiir2MVBEYPer/CB2E97SN7V9DF0juSvyHKormWdSzYM39uNHQyEu/neqdZBDLSp4DV3hYhRDtfafr1Z1Yayo0K7G3XlYRYFB+qiBiljdqm0eP8YXNOlzI0sGj27pOp2iAqB9lDTVYQBAJ6sxi/hs4368XCgfF+8Suu8Zi51lvRYD7Fg4+/3nKcXG/b7HDMBxkc//ku0PLu1wqaqq8zOW9bT/W+8dksSIlNqzlNmZwPS9t7HT7+tJPlN1JgYi3ygm9FSm8JfxuWM6+dmp1ATUBmP/v5UEMlxuy6fX/yfv7ir8X1hfOv3rjhq7rXTdnKOkV/Hv6f3hsD/FifMnl6og8GMiXjcoswVyaWOqWQDSF0CSIKax/80UHhFLM6P7kd5w4oH9TzepfdoEUmC0PqrWq2LOvMwto4VFkpexHagvoZ43iZArGyrJmzHGLJB5gL+fi6oaa9PhL32ph2YtMmgluc40UBzxBkzYdjc3vPYxpKa1EWZ4Qk575fTQnNmzz9t2iWdW1tbEVIGI7qOc97ZLLOu/CUMJc08QhHfeMFsHP2FLgbCcrKsleFwO6wcYoRWUpQgNWRpW1e7nc5vJjfKT2gkSPVFRukOMnePH48uDWVUKZZK8Ad9rQP4ZlH+Qrg8+4rqBTVZWflTD2uKGWUYBgvmrc4bzTlfDmZqNDYBqeVMb6Jifr1BD3t8PbFd/k/kNFfS6JOgCkMErIT5+nIfi2YuB2Bk6G3KSgAWnNSCRt49pSFOZ9GNr5lDruMuC+wxw4cwXTh6mYdSh5FQDfATimgOFYSLt4YGdFMcWlo5aIu1vtnuQcOC5JuPyPFpUj95EYw3bI0OV+n2VL2U2z7I062B1bRc5TiMqDLn9yLIPY5uiJIXaW5jbq/vPGJw+E8+Fa+H/E2ydzoZlzjcl/uF9gqcTLB3VF+vkjngVfOF7QA2zYm42t6LJ5BQMD9eZ2p3UksjA66SqSxPJReP1+IUkvwmitFxgZxkaMBiwP/xpNAwQ/lgFZEtzyIMhzm/37wGkgmKZEAyDV6kmgN1L+Iqv60Y2klnptb1egOUWa7C5o1n6dzuuWhCFTdkefDTXC+yTr0KmL/wDYKWOCgW/Zgl05CJCdhJMl6fnnqdEFOlxBpwSGvPGg4W8Zmg9U+AV2ziHaqofnlXQjofldg/hBj+nQvi4AfGl462IFE8/hMDDkW6IZjmNFnn6JeNYjhWTvPt5x3Gw8l4QS/Olr/uz0cliIuA4qjQYcEHOGXBWfoPsgMkec9t94cJjgW1yekMwH8v4WkngTqNGxO//71sq4rXqkMBPn2BL2XQYHZW9RDinVgVuFTEOXGzQyLvw9FhWLv26mGUON/8bkZYCl6oBongYT5MRk74gGaP8wWSjp7JasVGV17Ce5rNvaMxogE7EFaFepk3kLfM0zOAjyf/UqKtUbDIJ5PnqdbPYbruCh3Azsi7IHHMp8LC2YZqoXOw34fo1DxKVdgkxHkpFTyT8tKgy/psf7ccigiVtHTxuPrsQoCnhPYccQUEu4rLlmzL7N0nG5jr2ljPPMAa7BYtk45y4W2jjQVId4KJuMq+Dg8lf4oFeW32b09lD5VM26VhGmHOy5jDRkq1PYf03NtYWLmi8s95wVJuJAHouc7PfEWhihw91ZfW1T4+CJLw63LEwCNh5lJl4OYolei76+BHv/g3IHJ4jSZhgYcoDEPK0nE4XVt1bnG+8SaN3cZqKBd/2HnW5GxSkfGZonn2hxxfkVGyrKwxvmB3GQrYTu8OVezLVCcf8pShkGDBOU1jfpBS10j5YcqKRzykaUOQh06cMM7BfVTSwbHwmAuQ1VzxLUfVJpcVEEL5fPjviEmi/i5y+xaX6T/TCA5W89xb6SHO4HDGd/Sa6IgctzE0nxq8ykiTUtmtTlGgySIlvr5rz7Ueb/jbmF0vCXs7yQhs2+dTki1nOqFSQlHrRd8fC3dl+acnK4MUkKoD3yfV+uk77xp3x8sq2FPDA9Z6ZrytrHY0GBUjJlRpq+jr1f4xDfpL++OEq5e9u/BMJoWey9O+KC5hStlWax8y0zyITUJPyIJnaVshc24uJjgxaGCV5zIN9BWgUvZM2MdMiQJtWQObmAlVhGEjwXQIEIvasvhgikTfCIeJQsqzLdsNF9o524iwAUw02feQyi1ty2V8qhBuQcQzkUClYTvNRCkzGEQMjTJaNpvbk3LLbXkHs48GEZhtZUnEE5badewhfQUkDz97DAifn/6pELL8Vrch/vmWaACoRLahjT8XhPdl02hYU9lgjOTW8oF3Hy12Mj5vVmKdG7rVRWgBeyGIF+F8IwwvqjlIlQj7yrUQXAjBEtvLm/RdGLVyYFAsNa6xeaYdPQGH+gLCOwtPwSpyrVSs9SHAfBQBpfZlbrsJ04BRSs1aWZI2XWXNT+PDXUEtW2fPgxTt7NUIjmYD9YPxbM+9wvsE0CzMkbgU/LxmqtKVAMSuCcfAte4WYlonwAVR38nfM2r8mFiyZEuo3kApM8Ygz862P4citT0P1gpUaB2+yND/v4QajXpcj2vJENPMvxqNL/0HL0q1LN0mTQZjytxQGn37oG4tKB0eBtHNGhPJEPKODVPESrH0UigcOv8+INf4RGJdk9oll6wWixPLCGTDeSWXhTXhlmpf3lvHeVI2lcHpE0Y89aL1cvvENslPegeThuwvsl5YvA85w1+rcfyx/Qr+hefFgvesU8X5KrKWzDxhj0jjxAYHeMfjwgbq9cggdKUuDPqXg0tRVi4HnmYOrVXR0kVH6ugqh1T+RUAZNb9begmcJYTbpt8GClKbBLDmVZY1H/wPah5l2ACfvH+4K5QXsvtfFAkHPupTt/xc5CktxofLUX3sNplWB9/DDLl7E/PnHazsCUqxWt1OC3lONGXJs5+YUg891NTjv8BBSTHjyhopeUw5AiosJ11UVW1HD35I65VKAghyT0hAI1Ss1v6t0bOPU7cE7l8W0LfwapyOAvaBVcnJk+wR27gdgqbo9/znxws30xe5nTIJcUkcgQytVPa5p5BZQdCOXx1V+CYCQJs9fnw1LWjZ7loaFWxf/vqcNRtc39IoBSKIFdUzNovCGo1fNL0WuTMtxI37qZRwvZA4hKQcHMfQkuREOt0OEyEfFPcANgK38SDReaaN+gJZpDC8kj26/pd9ShWYip5N+w5ehPL772fkejhjs5NYgSQbAjT6LmRPEyzj9IFdlioil0yf90RuVebXOnYOqJNVM2QdaggQ1D9yrrIAyfK3kl1Hy9TWoJbH0e3BUN+5KIujQQNfSngEYyVEK531QT24ulFuJ8UH/cBt1nurUGkpTKkBq3NdS0HfUdCKpDSQ8ZoN/hbAYQb+VUWnu5oR7Fb8ubCDVbrPTvc4hUHsnN0VQWKnKuBzgD4a98t1/+V73oZhnhIo8TIgR+t/ibqtdWXi9nY3LDGQaeT+Cg9J5yVU+nh6FsUmrKXmAzJdyKN93+FpFQn446/wKqaLj5AOR+ISG9oaWeterDeGehN6r82Wq2KKwbuq0r/qgvc9WiUt1ltAcUkw3NlDzViEvPmLML7wVE3AKsmAfgX0tSZfp3HzPu/K09yXtRZpWYRD+7tZWoVJIV/A1CyAuQUKRe4xIXtbr/0RptqRK4UtOlvDnojDzh1EIINuNBs8FzKh724NdQ/dza7HOruP/rv+EG7OV7eJ27MOtkbz+Oxo3yiiCTWTopmsw7pfGLMoWamKpBzNU4MyKWWi8IQ9qez9zlfqLuOLix1NyJ/ONrRrLGJk43s7oVfkMTNshX73w2x5nto/EyqMvrpm///3jTpZB7RdlWfZwJCj3YbH5r4VQAux+opucOhpm3qzPOyPJmLfDKy6USWPcQ0Up/tn8llSE5lN1KLuZwU7sFFIIbQNTQGRlk4+QoWu+yrEskCUFDsmmkdNaTbP42U/gCq7L3Gkw0BBAQTm4cvhqctGCTy/DHVPMZb1bBJ1knnmqvyl2nmKdrMWFFC/UAyIOZmadh1cz8LLszglpnvQCUXW6R5pl0oA5kr7TchaeUVV1jp2bv8jKsL8mfwZVtADTYnIitDcZlD7q0pxffDIb0MZd0EEE2PEgDEqsTz9EYfTrNb9ZV/pvvsi5oLseCdJ0bOmzD2XgF4p9FQfMIf7bl6YK4SQ2gbxQTj1OnPrc0nN4sT8XwF8EX3yAYixUJoGuws448NJ3ShG7VTsGvrICMtT1UwSmQIp+4d4ia0pKVqb8vx795ytcPnc5Fxe9Ob+LKG5/JzsFUSQLSK9Qbc9v6t95275VqTyFililW6iJ5vGgf+CW1N8PvLZjdfdU06CKXVLAStM0oHF855LxJ4GQTmLxffNw0plOVj1vedJTdUeCloIPRnVVmSgksD0MJRDQjQoZ/n8yN8u3YBfljgLm6JlAwVi19gvstMGze5pBep85BXBc5S0BDF5s5Nx1+30jusfyenmdzoj4MlzaNMnbJZpqW2OoO6v0Kd5uu3/Xtq2yPzyLmtETZJJFsCO/4OW5L4lxVQjGZOUHpYd5ZlLwWa7Y4M43y1+X1oPdTd5EuBu3OpBpXd5r60TPjSQDhjmHxyrpiNqkc81EuVlmVM007dMPNse5wFM7vodZnrwEFV0ihwrg5bi6F1cVEpC+IcA57tciMjpkJ3F22NM4XpQ8dcyzvKEC4Kt6OlaQZDSrrxZ+K32I7TicQ9KLwkoSbQhZAkJn9Wp5Y5PI3LcUkKSQgvhnvyVwvYtUM7l0i8p5vR85zbsRPP0VD6pWI5n7lqrws5ZPUPz01ZZlK05S1kSYvoDCLBRI0D419kIxhG+baBoKPSfPOodrJrfSjo/mscZNnOCmF2f6XaHweSELF2g+S6mZook5tlGY7zwB/AbbMf5Db/hArd/wVKPXYcj72Odv2XdhrItGMHaduFKtRWvtCfVnWeux8RXZXXXSHd3Nja7VIBB0LmEwYUEvl3v39N7VWo7Gish71LKsQtxpwQ8blxoucgbSZyPM76/WshkJFEULjfPwuVL/xxT9TAbZqZIx/D0v2nE7Egf2rO6clxODsmfJ3LtU0PZ6HCT6pGNhvjUUOXfY5DzS0pydy9G/pYYUvERsQhvYAVDOkT4XCub2Yf8Ip+WLmyVaGs9bn34ema7xlruK53OXeo9phRGeIYnGhyfjUqEDj1bMwf51A+WHszDUKscNKS9kHQFt6JVxgtobQ7ckOj4dgPBhAld7QygvFmBkR97PbroNDpAEtZfeLzC9EG3PhOM2v8W3hWAT1OqigFJAbpQpfwPdnFXtJOEbbIanM8UnnJQ9MDMns0I9xKyW5HciepRqVyu2x7joI0XD+RjG2YVhIjxDa4aTwPwyvkWihJ+r9kzk/UpYYclG3qmxt8CMl+Kg7gTd1LAja2O+/U365lwWpEujFbYgqSzTLx+mMkoWnqfZw7WKDRDW35TxSL5niVVXJj2PUvrZbA5+xisBPyZ74g+6z4sZTb8xNl1gxfO+KFpUBJKo0F60K4tuPy+EFroydXfMCPwMtvu/os5/R33v/KPc9DWvK+cY5jhszl+SySb4ZikqyRpJPdYtMlmgVXgHgiX8rRuwItfsVHNdLlJXH6LoWK4o7XtLTR69eA4JWr20gtDaRUW2ltldoGJRCVDoylj1N93LH36EkeB7S0cp7sIG7MQfUoi5DNpOuFRLUW/ugQKgS3iISiNahQQNXBcsQ2+wisxHQO/06m4eL5M8iLoX1J6SzhLlVTXoF7s+/Z5wt6hhKBlSSzrJsA08Zf/LtF5qOp0qDzSUvET6zWJOlMe3Zt6aLZ/hNfyW9GAlCVMzW9wFyeVzSM5E7sj9/2B3NbESOtG/X6o2Zz+rQCv1ySEZEnqo1trS+iL45SKK0AsbgvnEGvZkvLG0d8Uh9zlksC5ul7Tig3laW0IrwPJSSwm6LBfMzW6R06ivW2J5g2m43/GrG0ecOylsT3GKscIWDyc85Qm+1nsH7sAIdEYfxgSSKH6NO3CanMWEsEDwvapF+Sn6FpS1WwMhgd6Gm70YFECzcItXIcvYT278XmOY0uQdueJuJUvzbrrTszsUQLRjGS8DdKY3xXfdMrvkEBUAsNvwC7jPKxxuoO+Gr3+GhdD98U/oX7edjUFnxJpQ8cDGBIKeaLZe9inT2awjAkU/YWNfsF3r71zm9UvHjrBrTJRbA21QPBdWfl4Zt0K3Xp4EZfYtZotth5XQg6tmBIeSkAMfVYL7F94AHHzx3yUuvNVBA+++Jg3KMZJPLovFvHmUtRsQA6N+ra46z0JyTaHjcGB1cbWbj9ShXh48PiHjyYbU6aimR95sNGNkEF434pr0/j+zd/zSbWfJPoBVcKpGpI96vxEpHp24Gqen8qti92K4L1tszmIsXdHiY/XqL4+Vv16lD8uN8spFqWDOzloBjGv+MBJ6q+MVjDG7adWAJgZ5ktuAdvX5DNMYTWb0WPVaYDVJuwMCcGzcm/Wr8nnB0k/DdxaqwEGAtCRzAxpFuzESDPXHkTLoXvvzTMWr2mt/Szoey1cfFYQwzkbnJw1kEGLjSIzg+gQQGHb51ejC87PMl7lsBEsY8eqWjUlSXekfxv41QGB1jIQJbv+knZg7/KCqs7N57grMpVNFig5dVwHyiABCdadftEuF7s9QqdQfXxTCu3U8d3AT7+stamWyB6niJQZOetuKrtoHqwo0op9maufu31CbcxklUEXLGugquN/FlVBjufoDrn0jxDtAsVLCnbefqgfvaWW9rumWNaEopWeEHYN0V1Ry5ajOr3TIUVGb/8vm6lORWzTnoafv0Wgry+IgvNBWxXgXwVsEwhHc11Wr25ubfba0qVQtCSioFsnYM/+H6NmdXDQ4o2agTvS+dp6itKgDDLeaNILHRyaIO8+9rDmCLZf0hLGAYjzvkI8im9pTpgQo7wlL9gDtnCEjmwTkPIDXgbfig5O03KF5FJUw4/JAMRefFrfOTfXVTLCUcrQdZxbwx6EFLkjQWYOZNu1NBuduhvCnW46Y3gGc2p/BbABnFt1IjIQSQasoAqQ39bpYJjEUvcKfk0f8n7Sm5WUoKCfTdupOxL69RIAP2kkB603pB26rPEEA+7Eh7MuJuESKc+lCnjho4RIP5zRYzZmty5+z4F8fHpqeHUN0AlcLiRrWYQGyFt6pO0Dd2P5IdoMh1/79rO6lxAoFt6PVShYKgBGmWRJ4zMdXEpirpBadVSgEaKl75R1KBNWT8I8tFC/Eui9HeNIdIm8tVY1IFyB0L8Hye7sddT0F8KFfhs81YOCPvqaxWEjUF7MiPFHQM+bxfgh8/RbgAHZXmQ5aTngfSWeLA6o07LS17paAbYwUkBfFbOrT1sPyQCrreUhPnEMS9KkoBG2Ow38g/odHsjGhJxxptrHENvwzBvYupsO/v5jaQJD1b2dMqiRB3ioolh/c49i97KL7au9wtrQtRwYvhzdp2b+PkM6q970LXQN0FVr7Y6Mq8sMQAkHYFhzOgycboAS6YzadaMnepl4B9V2Dgy9lBiQDjyZdOwyUs1GJOboEXYLoFyVgU68MH5zXTEHSDlyWkOXTcxT92kiss+w82rigYUlOuLrW6GqNphuPw6hTJpQvrq1WyadG3huW3hch3hOmojdPtQ1o8DQFqAk6UgGhiLuLxfKG+QQldwRa7V0xO6jEOadhBbNBnqx6OLxSWra8cdzV4yvFpzQCeBQRvp/v5SLsP39RDhrMfvChCJ4mMI8pNv8mzBnzK39RliiH/xM8D8ibOxWI/pf0/dGlxBQo55go3RG7NBi2zMj4RrFVaWO1kyC8tmy/WNYrDuVqwsGQye2h+kC4Roks2fAz01O981JMmDBUtYF8+w8MRwxcKa1SBbstoosCbDEdets2qOD2WPOFYcsHz06OixWRsijy3ENSmYjKbNH628B/QAvljIAAC95cbETTgbDceljjXU0FC6o33hot+d31hbSWCRGJT9qNiOIDj/TzBwzRk/0+x+cqRs8L7w2Y6lFoYIWfw4fkvEDCYMR+QsqEgdxzz4AAjHtBF2C4JIFgp88/NuPEufzSyxuajiLsHcLB53iB5PhGCj8hy4hIU1sZeZ9JRDoYcnZwBZwEV7L820rYvOqYwkUwTCakQ5a2ivtXSWdVWojgKCrHgWl1laSNObkWuwzDH61d6xq2IigHEB7U1i+v/kBcuCHd6zIi+BqLveNwBOAIfpBR+vDxKTidW2G/fyYemfqwgMYcN6KjgmySPfeAKh38wN+KM69vBvUOY8zkIBqKFp010QTx5sZRUdDZvdqQ10/NtTUME9bnbWh+SX0fJEsBKuTe5EWuqadJ+6XVFD1hoFg7KM6+Ha+epS8VNjOvwVfASS/P/dmS6X+OynlpY8tYqUUQ1tTGx/QfIFA9VcYK4gMrhS5QPh2saKJiFkZ/VLbcghVZL980CYvLZF9XftyX4acxN1t6AwxqkUvM0Ej/hbQpgEvHkyOeYFx9BJPIDHwB/2jZzUP3JF+eKKnjXZ2VxzMCJ5zF5x2lXcPnADOpx4ZMOGhHKIpkZln6cba4hkUVZIeCJS2m/msWhkADIHHLCrDItUEfCOfqPZGbqwHkmky0X05ynGUnZhL7psly7LebrlaI5mVSImdPfKcD0O9a3GmUKa+z//1JPaHHxS6sO01hz4lFTuIUU0iDwnCE7uxKSgP+ZaQrp5nLKx2leap41xWoknWh7+M4kuSIsF/TBZyps2kYm2AXlDvUMksEOZlgb6T8eQnFkUOksvUZ/HmAlmzXOiS2Rh+aWqUoTHgU2L82re/NWoB/VHWZvX3W3wltZKC8GUZsHHdN1g9t1bUDK7g6X3utsuwvd//5RbNvDRkc7rc4fkpkS/F+5hA/dsBKsN1Y0OUERV2F2ZpUTZF9K0l8xs3nRXw84bOwgnCwmRSkDtmHR7PIu99N7bovUWHXgS6sj3CuzrDdKiE+3lCnvVeL4PRp8KZim/VSvR2I4qNjrEm13ZlSiL9NgOlMy7cJrtJGU3wBfPnEqwXE+x+8fU41gAbeqUUwCENINIlkZzzH839sIah+382YHzbdRR3v9+I4LNmkfxqAIpA+03o0+qoqUjRfrhJpmMSr5jlygxQXTYQ9I53S0Qlal2L8Ur6fMmSKrFQFX04kwkUCUyTWEPReKMzoYruACDhDuYnsCHs+ULT5XjJcAphQEn8U7c/pSx8vCWoqu0XhO72W0TDjZ6+TsvJwrROzSmP1T1nuFPBERdVng68ptkQqYMRild2aDscxxrUcXpGJ7+5N7KJoNAWeacbAlzPdat2FcCuna1pwOUMYRVUfNy9ejdFwbRQHlhsggEtKW5N0BMb82gTig12fFC6kcUTK3MO/AwCZiX8UwF9Gj/xPUDUqh9CFbAt3NlA5ruUAFOZfW4VZee4xqINsUyhV5fLJqlw3asJqsj41ByKnwPmYzopwDwPcMv0ixfie4pZndoh0lOphvhBTJUlbh3mGS16Kna6Y5wX0w/033Tbe65g9zUFr/PWHn9/e5Rnx58ZogIhU/7xFVT24JnMs1AnqUneNVRYbTBoknFpOlcDsr83LsIoeh7U0pFaGotmLKq8Nsf3c5qiqgkaz/Py8pz9cRkgk9V2RxqpxFYy0hbR8mvhndgyEif/bH71ULEe+b8YvRn10XelroMQ0TO8bOso2VbEBk6GFcWvZUhh/lo2EzcshC0apO2YwR9p1SgWCpzIsxJDTNdKddj2M40EilPYq6qlygw5cY9PgcEv/sUyZ9ft0T+am6U/u0oDZGuSrPCYTrNXdPoXRHHxNJZ+tQJbVfG3MoavJ2h3NMfnGTqvMQaQZj4jgmx4V0hE6Z8AXAsfcCU95cOCS/Q0bmVdLW5y7TjLLXX/pYrwHZ/Ek0IPGLzRomjCOEKkyluHY1U/EoAffsIpvXvZGPvvAVy2/vwqPh+id04pPc/0gl/mCnYEB7uooySjCvilBpTQGM8sdF222YxG7IqHq/BEhqFVZTof0ZJxdgDwAIg0FcBcZe6t3Q0/lYfqqjN/jLTxFmptD/AP2xRdb4x41RThLgm9+vL+16OfffcPus5K+NVbhIOlg4zvzb+XvqC5PNvQ5cPsdFzAfpFz5p69IhW+bnmasR4pIgcH1X4tbWIcfiqhlvAK6ZBrJASX4W+r4LEWNq+3dDPak9Aq8Eh00Ir1RddgdPIpNPiBdVEJhWzsLMW0sdXU19UFuyRhcFj0vvxjqwchS8aWCeeREx/qZuA6H6axw/pgDSzeSc58m2nXvBf2sUMLu75k7CHFg+Uk4hQ7tJmEQkND9/rSLAuDpA/bwRVHrKlvs2Fediqw68pWyaDLfTCpq6lfuiGfwO6j/sRWzzrlDFR5e+RqE/WuuFagDiJhwmQdum+i8PjdxkZg4Jj/M7KYkAoFgJw2D2dizy3r345QAyXfzjD93z3Sin85v1ZD8mmPu30Dn6Ys8/L4B1U3odGkFH1EwcZMoR58huUTeshMY1X1GYx+CRAdyEo23Dk4WV6Z+pkiyK8MnducVmgcBhtj8R7m0mNUZ7DZPrcGoUSIG/FBSMLsymMaDrUrVRejrvwzdZ7pEFOp8lM/oaLNl8RG3CJgS18pUGeN1iX0Ba/zQI1XuZWal6FFyDtz4hHC5ixHy6NKsLGh3SLWppPQJ+JXHK1gYcroXeBx6WBLRK7bMLdk2TA9q7b+S85A049K9UHbzyqwvhmgEfxkcpnPCGEVxk6SWWZYouMJZKj6+8KgyngmPPo4T5PQa9hh/znL97+dhTTQi5OyFNJRZEbxN/XpCZ6CjpeUoOM0AO6LHoA8++HeFoU693nXxuQHvCtye2iACn2PMRvxH9IO8kn/Lu4ixWhN1+lpkm7P9quwAlsTJGa3GjLdR9hs3XoAtgNbZBZdnlGdTw2nYW+fKhgvRoDUgcRc26s75wXdFIUu1kRvooZaYKPva/KUdgXUIN9CmkYgDb5hz7rkUKSiZ6GOPlvPQPQFIHgdrDUpfuC/qdWhYQsK62PFkAlgkSiLQ2VBbMIqqRSFcyN/HkpWlw4BDpcuGjIcB6kO/4N/oPxmTwBx2WlejNEutmPaq6KmsIekd6T3qWLdGFCzAKJo4dd/aw50k42o8AmP82OqJDZE8x6Fr2XAUNblcps/lcQ3UJFZX904PeFTaar17DIlAKQqTexQvzKP0XxycQV8pUU7ifur6ZbISqsU1NuoREOMHQj8wC+K5iJrpc10rMReMBzERh+pd0sRrfwFX2Ng1JKgEvKsZmg3Cb/Iympx6jZ0FpskrhcUY4ctGjvZbawF1n3gZnm9QLtlkB20Fs4vENyyKGBaj7BtIisO5Iw3ZxrP9/JAVzNCSSvjxud2O5EbztWgK2HmMKGsPc8DTZ65zEr/VEl/+/TYhN2fjDtlYLOxNRehsW/iSbgKJNMTyhfInHHR8wuWLmdIJSHAzDYlqg2fI3ixP84TqTLyHo+dNzI+IUwbkaOKi/em3MkHVoOPzUCv87iYbf+7WOAdUaMgdDKA/nd2fYxwGo4DmGMVfTC6YBA4ad6CiuoowQzmxRWWE4n4DkBXyqDvdX5rCxMD7q79BB/TugU+G6OvN+FE0sH8TZsIwPIZA7MFqRxGsEdrZxeOnoIrKTpNazYXYdarosBRVgVQ5iiinYht6plGq502txbHlt+L2meFlHTnznzlkE2Ajj0yVO6zPj4CnYXtdkbpKf6+kOo1ZL7kVhEMWgSQ7+zsb2nf1Aqhw9ecUQxxql7Rk3yD3kAyliIAC05JTIpWlSsVfUcCpDKsuo+tAQtX/+FPpc/NMooYZVDnx0z0rl6aSc7IWhtq+WDKuPgwa9ktAfNrsUiUkEQc+Oxp+sWb6mepmKicfwpZswOPfaLE5gRR3JRIgxF/0PZY78mkrkB7SSAk/VQi327i28DkqF8+UvmdwRR291uJxce5HdRfJhtz7AFiBt7RMG7+CkdaJfjRgtEBpkDchTeFWNBBkVR29jpEkKQq6Z2zPK7UoewZVkUa6ypi2BUHsy3LQ9y3+6mvGl4ncPvYsBYDu0jhkVUpBIR506FBS2jWWvoF+PojVw5sWh0n1B4ifbkREdwzsIDUEucfyrqoZDXIT5Qt2soFVKTqWD22eezS2XUTT2Dhp6XJucq8zNjF/jo8mIeB1pgkiMn9yEta0eiR2amif9Ks109EyV3Cz9YxOXCnkcCZq7MdLbJYITjcQeaLCD+H1e6PyYg85aZFhK0rdeLD4NlSdMn2YMHs81yvWRSeMYiLD2C2yMCdEofTktH9Ulfveu75BNbfFjwp/YCxxT9mAWsEZbNroR7Fh9cJsPaWa60NUZ1Bdw7enkCIM7d79YWUT30QPwtsBWPdMVn1V+/OwvgzLFbG9DanSi8p0bRtiKFYmoqzJQIyIIOsFQC1V7y/B7MAG0iG7ivt4bAeLai/MYnqO13Or9CFV+7hmbuXG4bLSlHv/OSogqnv9ptsRGi0pDyXuUaY0+IBLt1Rg07ipr1yIFCoMq2vdexa4dQDLZnakOiJtMLHz1NF7nQeqELJhRcM6Q3d6zlYSe++PEC8JMRjub4JwDKA/TqCxW+3V4UJKh2OTryH9n3T404xONAhPwAfFEPayugYEOeB+I34ynge9Co8v/1iO/JAiPE9x4t3gPDNu5NdORKpO8Pssrjb69dT4uf113jHQ1hFnzJHiTlO4qBRq5KwWyUAD3qRAC4MlId6GhXC4MgQr08FtHyq0bFT9JbL2AqFnUuSWEcyQkXFtTY8IBNbIRjO3nOlDzklqK1DHweeX6Tq6xdK2tDMnpRz7Z8SVHpb4AZ3Mun0QrA0zWjvLQYsnQgEYlsG+0Ohn+LjuP5VCJmkDnJxSmMJOAR0QzNxN2f8aME3SldF8iNsOfp7+BuLo+63NFtI3p6MQejLOPYVw3o1VtghrJmKZwM6abmN5Gznm9Pf/Ub+gyygUbqsfnaV5Ag9PhyYPrWrd8nRvpIgtMd3ZYi4EPIn4T4SYtDSQmqiOGT3MsH90eAajqFrn0lPFdNOtutaCgw9AwgVK3c/aFISK9AEExeK3VIroRA6p3V4bVP5h2DDas/aGVu76r9Vcz+enKqxZvhXsKDpGVgEIG6HZIn8nPSAEgD7hX3lAUYGCeqDPez+uHpk2ikW9NnQ9eFEMJDDtwwwGXY2UkvenOIftRxGl+LtlsGXcbyER32PS4yBLFLv1lzMxnGo8n6l/lOp88H5f53XZZ9IlYgTjyfS+NfwPF5Cn1noxjyXx+YiiknZE8ww4YFk/DqU+4TcjN8Ypz+7KQyA6JwPWFnAl2KebOWx5GQRIdyb9sTeirbhna+o180RziEi4AtxmwwMDMIm1L6/OnkQNEB/7QXG4gbYAeuCZojYX2YbwwtFStHvftIhocAfnhGc4SoDF6oGahPSLLxN4kIq+AWuOL1ICR3CJpECQebMSIey1WN8pdA6GMs3tbXakIjL0NEksa4aIN7kWhgehC1QRic25bBaaDTOX6qh6s1bjHSc+RLM4BxJ821AdOFWT6GGoH9LmhJ9d/WgftHVDopkRqQLRJefe3hvqaSisv5G6wZJMjwG465TPOR7Emkm6BEVr2zzhLGACNGkSCzaFCCc7F28eRd21xwQoojp1AXpdPXK40AqMOEfiRK5FYVxnRgpGwYrU6+YCGIz6Yt9BaNoEhMhOvur806ki9WfjhZrwDzJKhb7LpLDQfSgLU+3gXi17epLvsjSYlm6QEWJ97qxH65uGdrygcOzKC+8DXKGZbYGlld9JMBH872gUIuEVtZWvGxAflp9qSZScf2zjnH2EYCshb8pohJmXhGZK3z4xPY9sPv9hwnGGhXqGZ870JnOUDSZoARUvhu9Q80pjdN2t4bb5vjsrl8d7MRr4pGSuh10CPUnkJI6KwELVHqHwWshyStYCSiBYGb4N+awJ/YBL9P9ROC3xS687f5ikKI2K3S1AJg+EUXhnQv397tl9NrP73NEBZOEugqreKUfnkKWCFaNX/+tpAhvcZpnQhO9UNBwC8qX1OHOFhEUjGE30UeH8BOYp7yjcQo+ADJQ5y8q5T2whJo7nqaWFhWi8lU3vaGTaXfsvF1bo0WT5HhZi+K1mqK719zTSvbGskuLSdlQect7QEHXQBQoN2Lu2gD8eWcVFZ9OkhUax/uBuulz8XYKvRRIWSsO6e6GOMU6T1jO+9FsUt0NjorwcKudLSoIigR6EUrBKOFbcQqmSbmOvn2b2g53yMwFHyV8W9qIg8Rkvy/ECJQGhtQgwrOR927AlACEFYK0zx6ST2z2jBu9DnuhPmWzv4N+DZBJoy1JX5Yoa1Qm1GxKnmgC08DWRIfIZq58o73Qk7BIuIyMJFsl5S6J39BwXTgW2T8grFhzPs3G9uP1e2cWJImdvqg2v8QEkdE2nuQ2GAPxSqjzL1+9MryXoUPAqA3XYgw0aI8ZTV0ZnnOB0rofs9/Xt4wF6SxsljU6H27FnPFEfemo32lAj3/sxzTB9CNnttl3UTkQosE6v7Brh1NEXpEqHPE7etZPFfifT7GjT2M3AXdCq5d+ZEgDbmHwph20Fu+R51YNgt+KAFxuQBXwjFH6a29i7UYzFRLYVHFJUl74zstFG6+xLUtWw0zg3BcXc6K43NcM/IiCZtU0nxjPNsX1eyOqB88tsDmIwLY6Mp155ow8VatjLpiCm/fb9CdhH9/H5ae8rgsHP+52Ug6wDZmETLGnYOlZO4yTpKKDp39COGo26Es97FtYgoKJbTvH48iFqgCMWWQ5c2+jtIuIYZNBhvCcq2OvbmUamdqYd52cl2lRitOZddY5Cn1MBJT8WoHCgd0EbG7cvcA8jhpY3t3CxyqmMYvW9fe/s27qwPxqX8/aPbHeOVAyPL4a3HtAFedZmLBCJxpyGJZweqIpPStHKkokjzrXCWsw0+rMpH8GJygIdmdeiY/2go1CsCSP04nWlFuuMnFjxCRad6qFGjdKnI4b9d/RCbmWR2Iqa0wrxVtbwbE0gSe0czTzoqMFT0PMz7K/Tcjqs0i73Pm9rh70Lj7X3vOWi307fPaqUiPL2JHMGkiIg4lJfJDXmEHH2COYXN25JcCZfU0TGle6fXFHr6uzXlrc34DumU6llpDDaiFEZoTaL0WUQ384c5mPZoEqo62SPVtc9s49TYL5xKtWBvjn8u6oXj8k/lw6hy6pgnO0kLuse2+VMZTYghAPQfWvmiEKqQLcWLfMJGi0d3+NmXz/kwCU1t+jhG9OGLE8/Gk8d8o28xcLi5r+/fIrlfJwYIxAco0X+agr56CCr6+u+BSLx8Zv/JYkbpqKUUJZQ8Ouzkwu+dphfHpaNo7FORUFhiJJJkT9agAkn7QjRCLEhL0CmjgrCdQq+iMafkLOUKNKahdrzCh2L0fICMZoWJSotVeWag4OwXgcDoHfKmzB+s1sYRmc8mtvP6/sTOFIMrCTyIbfKdr439PkS0S0N5W7aR6xx/x2tdXUAOjTyieQ+Ao9CVlcYoC2NET5G8FAiLQQWz9zPcjg2LMv+MW36H4SqurVZupXax5GcgfS5Ie/Wy1PBETl+SsOqW7qewMG6FzeWxnLcuq4Pk4YzvtGz2NwYuK1lwf5zezuyoOAPyi3gL0hafzz2U+0o4rvP3L0IJVp6Rs0B7EZg/bhOSHE0tCTQ9bdBLGcg4vh2cZyT7Q5/z2lwZ4bYqZR/4ir6DJyolgW0gBCyHCK3oopQ/kbCgvw20imvk/IxdV7+UmdFyGEyZUn3yFatagYk8b2LqYCoOAi5V1nJl5aAcMyaOfQ8Z6sORP2hV60v3IRdV4fqVV+11ZddY2+4VhN3Q5Gj1ynVIlW46h7hMlAWEqzuBPdve61+yhy+gtzSGS1vGQZ3V7siOF6WxhKu7ktXWdViHy27Vcsr73dm/PndQluubCvY2mCD1t9Jie8wlzUx+w0g5CTDqE9N6fbjudLGIJdXYZ+We7/0VrOe2AEK9GgsNSyDRIXkdQ4IA1AV9LyaNlkOUPyVsO3VWzOiYJIa0vBLzWM4CXok1w0CETY4/AK8mT8Rvm6+nKoYbjUiHzjlUco7aG5c7nerWxm7NJ/9d90QYQBFou0OpF/r+I5NlRbzIckGYbYEm47yW6/Orv2YW5qGNpbs5fRTeVlM5jNAeiQrvvhacsOYV52u9tkPtBhOgiMtnTOI0KPSMjykvpVhfovgBhNX83YVFfDAHIxrd/j8J4dx5/img9cZMT7QJCXoo94WJzPQ1x+h5kavKdHdp0UTA3Nb4ihvimtMePx6czyCB94cWi1UaZfv9mTwX6lItTPFKRzNj32fl9yQ8QQjT4OQ0mO4H8A5Jl9Ax2nk/vijMkDedWWbEplvJUnmTIQcNAWjNQqlqsBcR4+zr7ELcuGYzq5/I8pz1IzqMMa2IEdBK0LX8hfyxAy9ffTwdFrpPyHDCsUkxOb1kXjZ0niWoB4AffxpzWTEtS0/8oWOan2rNKVORiHY5uxJ3w8zv5Lg73ZLzHMAb7kHiRT4pU0g2VqWDn2OFTb+rDL2D7ZLYhDfFX39SDVxMMTCFSjZ27CqfDL4OcIah6JvLIE+gqpgS/hJzL2YgZBhImCVtvC/2iCAR+y3OESdARDkBG4pcFGOlh9fGvw17MCK4L+4IpvyPYPHJ+wI5yDskeZjmzrLavOvkOps5V1meKHhfffgUlzVGTPyNdvxW6bgIANic20jFXmVCXfNqEFlnrA+bUZmPfVbzsPP6fcZ3R3JtcQBJQ8h8AscilkwiDoJRw+ygJAxlvFNgISUOSpzn7GF825KvMsIDRskUVJ7F5VWSLtEjAdPHVN6GpYz2UYERmF1UH2MntU04hG/LHbP6kSZwCzZzjCz8uQHns7+TZBCZ0Z+9FhYvi9qDY9bekRB55Z8R53btsfQzQUGkeQb4rjCBgbFUy+VaOA7WZrUP7eHfI4Oq6/BfPgiWf2FammRZio3FuBlhv2/sWdARKHIXVmmdIZa6Hydn3ttUagPO0KXAtvsVn9fIWYdQ74ykG3/2JgTs1EEZ4pMyc7R8RjxR3ObKOu4sGNaYNJ7BPH+oUo/QQJbO1KXjYbv1/8Sd6r1dyZdK5izTwdUUz4T6XevU68FfgYv1i+CltvSg9lQ7ViH5ErKe+ZVowQTjk50IWoxmbeOfROdpaDSFv//wMYsxHhViiXK/MMjNZIP4lIZFQji6JMDGZf/Qg7CShwuPJh53mWowbpg+sdc2YP/yWAjtOsEzx8M1LOYkB20fwbwlJx7KEra6oyPBD+7rq1wOp7mT6NHi6HMcwOlnGa1uRd7eIahKEWKTHLZz7ZoWkJB8pvYN27a8qV7IMbDKOqkWKImAafGm4sOfTaHMn+2A089ARn06s30y+PqznUgoERT2L9oyeM7iMW1EnaP6X/e7c6ofdHRUOHBVVr0cUJhARdxaTPKtsScnjhQFHFDtQwVIwrbMjPC3b10NrVYxM3OvpuJM0CG6e5QD81gBJo2RWm3hgpb63eHanaCaNBvPNlPggxd28qH1kongM8OxEy6VRHegrdlbCLD8H5/fKiKidDF+bewo6YKSc9BnYjGkiKvfdZVkPOatm9QO1Kj/8EGz+GKWxGWog3NX9I0iklyqpO62J/19QlJ72gFggKetkvRXLGS4PveqwCjF3S6v8SDNiPWWwipPiJyJuH9Y/gx9MBuZMYMfge4wJ9iOahsxa5ric3qSspXq3wRiX8u+TqZbW4skpgaBhMz7L7URI9JryoxXzuYS3lnZgWkX7SjWuUJLsJj5OmqTl0ZLzvfrv+SMHld1VVtPMxGz1SksImlDBOFG0koKM5Y856fDEfnfz4HCZ19/WyHjcvxKZm7e+DAjs8qEXbLePJQd2N2r6xDra9O202eMlkb/lrpskKGPXc14n/OrJkqI17iBH8K3v7nhhcDOPXOdPpSON2AgNZyrlHzqMV3dN/Iu6NCpighiAOHH2YAnzPta4UGN+glPRQFrTmuhehoeDlLw75wcFJuH9LP5mxf72GLtsvEHKV8PGv+2YyjEqK9B0O6ayhTEsQm+HyMpTwPIqlL6b2UhVOiYB3zowbUCxxEthKwtGPbNF45BnG1O5oLOh36hLXIDqbKolS4734Wf93C+4rGVM9J2UAA31JzmwCls3KvHIESpj8DZowKDwT5noSJn3+fojHsx7co4d7KFeNc/UIsJ+DLIMLeYJxlXyhd7eWOePIG00necrIZTyax5D6ljtd9osyzcDKLGtX6NlHpeiFLUEfH5CELPIAY1KxXF5/5z2QyR8BojC4GTDfUBpyQ9M/bFXaryLmdPZgqKiueqkYKvSEoRYHUyDGuUHdfFZ2BkLybsy1nWnl0L7CPp8bAGBbOyiRwxmGzXg97F2C0r2ilnv2HOTdKf3r8pNDnj5cdt0bL2EPXB211Y8fAJE6xtiNyGxWC+s0/jsOEOitSzkjuR3KDs1Jw50xMPin0iRO3fT7NXbgIu3plB6t5Y2UqpWT/10dwW198gy1HsohhWFwkTtE4wjizL3dyaMD5dOzvRlEBHHHoLN1opCUdu2eambj8krSRRN/B82YjtKKa6oGK8WQpgqO2sfsxAy/R4XLIx/VBOn6R2lTfz/s05yOgTDkbH9GCNbW0NJT5Of8ZbSWKUBkx9D8Wvxei43f7vhwbzUqLUQpIRt8q+Oc3E5r7M23LNWJDJRYP/2CvAV0nuVTt8RRUP7zAQjQiafrVNfsp4lLBw3mwZ0BXJUdQ6qQQZPFlwTcXHIE2x2PZBUdlzXz6l4eqj/HxZbiqLFm1+Qf6vgICQdcHixA2DFbVs9FN+5YhKvRb5dMjcwqo0X9OHduZBrgWYfJc27q1dC1NtffCwZcHePzuYijEubRJ8/0NmInZpON9JZEqvrLy4u5bTViO4nxlIuysfSkEQSqFvWYedwjbj7K4Rvm1OIzoPBii63ksFx/Okej6WuMIjct0IJd1pjgFY8PnygpFD65QxKTv7D8dX5UpVU7wjIqjMJczyAiIVJVwcBfy1JngM5HFI32VVqfUW/BnbtyaC/fuEQJOMglP2peuwYFOPQ+HR7DEBZ4jpdCM6iEjNNw0kOdwSwFfqyGbgtXIs+Ivi8HA785U7R9BHw1Kpd3oaIVR5eICxSUlnADziOLrp41M1tyyhaw4u5wtEPy/VH3/mab7YkR5ddiOjCcsRJ5n1qllT2RGQMWZqahHGdLaFHcwl/gARixZojIRH5o9zhP04qS5/sXBJUIjEGX6I9C0KPXqq70KWZUFjnkyT+60OGAfzZGwtwIGsqPmoAgn0wKtfxg8kqe31z8PbuDkTT7xxB5BqJRR8jJgBKAd657QBisAIFSzaw6DkjTCphBf8b5beRSVsdETVJnC3ZCdMISIDhQT/s6Met5MTlmS9/oL8Ki6kQx3YsAtwb/jjLQRiUNtmflvRdVn6cbHTSps8NAwGznm+8W9VhxQhdrAQoAxGbvwbJxjgiCoR1DbzJH1aBAw6K3/wkiuqXGjVhSg4sr5KNQ+BrUjjkjscYC8oogQ0YoM8SpWO5KY/k8qAd1AoH0JRAS2/Mqrybv08GzZ1vhLZXv55TCHO/dRm8p2DWMSaskCST1bvvUM9tmwUBI/5W/HwUJbYDEuvpLYJRh44gB39vgS7qTSLucGt5M5BObfxLEos0acwGy1NummSl4TQ83NFMx3IS/lmpQdoKG6T2qC8nOTNZsG9chBOfLsBmB8rYZ0jhoziCRpGwc+Pv9k7TQYMcifYvykcZmLj6LHlCZU65do0BgNruz2vW123j8gt/8JzOfOmWGXoT/wq2qomiiDVdpiHfxvB9Hkm85duVDf9nGm9xa2JRV+1C7xZamk9V+Af7apDazyZBm4bclcBbaNpf0xzSR6MBVLLyxHD49uJxsRpMDePwsf2ZrfLtowAGj9/dzyHQRtrDPGDtINnRp0l/ku/Cmm4PKkKiwxzKwC29u1yMu6HO5iw/gQpT3yKzWxPsz/mPeSZoIVBI4Svk94goMUJDrPMMPlCSnOi3P0YbkeF1NHyvYv/cOwmVtyERErDC7c5mme5ZhLJ1+NpQQOMQ5luEiR6bQEid4YCAM0mKHpBvzP9EoP6E5dktK3gM/az6iOdoeYiRcm8cnwYU/lJTjIa0Rxu5QWDqYIQ6sv8lNSq/7ZADkrKeA4JLby2Wdw2lcLSLyox4yxq44ycYmUaij+vup01QoMYBIFWm9g6OYaIFeWuYY+bU+PMyQ+Go/sJyk7tVGwKSmS05ERKf7DR0IyMszGGtlw/fRDYyKcALOKlz9cli1k9+SBGjbeST5oeRSLbImXJrM2Dh0SPEnFGYDYcTj4MMRsTgDrR0h3j6FgfyyqzK6dVP6HRy7sjmNF14B5AXk4xboeKBRy/cXdub+nDhJEXB7L3DYHhn0jcXXMTJib+Tc2Z6N1NRjh2XBAmx724Y+KNdw8AV16UMvm5/mihQoIxdyUfJIqw1XDsxInKYjpWkIHkylO6bvxYyRhjw3gSkdoUxxfUmi2tIIrX2la857rVefb/DGPzj+fN3waOlg5EGP4ZTTY14RjdfAWT71922+hgIrQZC9fB7P3/iPrRoUqqIDO1vH1JFYPZdrvyR94EUmMCrkzBHhXw2vos9uiuzPnhBOv8ldIZLcLUvUyJAVBke5W5gPKsfXbSzTvj46co9yLXcpbfEWnMHvuVVRZY96P/Xk2pvvHyh5uF+RFFuEGKvNHzl9moVYeYoCwNgifDF24lJ3tuMt6vlRxvDgPj5iQYsWDkZoJtNENobzd/dX7AyGw+V1ElQlc/xNwHpO3uUK0EabQowrCh1ZsEZWURgFRFuos7i5JzFXRxBYa+qSmy2mFwxfI0RoceDL0qtAvfM5T3pzkzD9pVXx/iNz7R23+iwsA47NJmK33dzrZBr+SM5iLEa/dTNqv43QP+fbpPK6fLL4FwA0NMBgcy4XYcwPUz8NV+gV759gQCr8a19egEjmqVZFxmaB/hMy3kCf1ZxiaPzMsgWkRHIRqj8VxXXSNlGdVkOu/J5FOC6wSVVSnYJ+2DpOMQ+yAoBUDI8pC+zxwUHaMRVE4WSWHtyRbj1SfUNHVJlUVjfYL/rh0f+52Lmy97liaPTi57o+zmk3Zj/tXMJASVAFikbEW3zazwp/dLeggEoA8a5IVIdDiIsV0ie/g9DdUFScT2utLX8FfJ3X5DUGaY2w/+XRmADAM17axbihkpaewCN5uf7RF1++VPxmFVyz4WcBQEK1DpIvX7qxVMJAZ/cS2UrOv4A0LiNZZLFylvMggVyOMDmDJlywza8H+RP8VmLbWbmzx0FfZIUjUJnCNsdVEUv2w7kmaQQb3wTjDoH8jUolFq6m0VJkA9lsJsAqWDQIrW5QPOfu/I4l6o632i5m2iEqgJAc4hQTUyhW1v/DDnp2QxRi5Ozz2p72sbZ9K07Uk+TEgxfTpbt6RhsOKT/w1Ym0Dl4iM0H7FD/K0oREUTGzvJCxARcwv1joetYVEI7GP8HJLc1lcEllyBCURUR1Yi66J7QJgBMymaFRY3TG9lXRuzsY7zDxvtWq8GIlZEWXQsxku6zpeoqx+0IH+uQhuh9f+SwXDbQeCCcO90tbe5+DlXv8WqyFAZVa6/0QI6SmZD+fnqsD9hV4Sdk+uiLfgNv7LxNSuxlz9z5esTCuFGYL+hwhkdtgtyQ+/mNy+eZp8ZfYhdcF6nFSUTvaFVwwwir84yfYg13GFB3oK5evlh+xQ594WuvNTtUo8CPVPCRUb0olmRsJtNHOa6WxSqM+5e8/tD1Puo/EvgvTUK3Hmr1RqTgcqs07/G9ba+kRlyC+eXcgEBPizuVaUvfM2iAdQj7qy0xW1CNo2GCtX8UHmsdMu0rSFMY5TALqAqbQy8FWNchzl8BjmTT84VTl43jIzoJ+JTLSSAiukRH/ZzF0xKlyYMmUfcJunr+dTSzuCnnC0ZVm1XkwBxMw6WjL5QQfuUBSM6IGu7mYHy5yjiSW9Et9S3/bAjKu3GVjmXsrJfh5N0O1inmsDA27g8APcDYeBF+uHsnQYgvTDysCj/z/GCXbnJxy+JyzRopbwv2rY57LTYBQ/DbIwcPAU4r0xbskn4AJlrYVL6uC+NMlfKvjRn45BRsjPWPMQjzX1ZppxwnOk5S4Fc94qfbPbWVy5pSngkEdsCt3qFX3mgw69S/gHGXvyvUHzceXSyxYU9oK2Py9beRN1wuPwQIkfWgkybcETlf3JPubB8U5knrJSe2uuKrjHWPPSZ/pmNLxbPKY7u389nTgm84fPKmcJOPCCGWAg0sb/EpoSJvfonI22O45v/fGT8J5v2251esQOqBkP89kTJFcqT8klfMW7Jv0dc1wlDM3hj2pimq7OFIBIsDY1b3hEXBtM2mthMBYCGXjxxKXSjQ4MNi5HfuJ8XDWRnq8ZaE/qRLqvSyyKHvyfd5OhmGAvSdjCGcuaQV3oQ89OXCZdAom3vDKvne3EUiTXxe/987QUb9GVvhl52b9goemnzuhVcWfXt6ECaq1ty69VnHV/hsYhO6dgUx/gNeKxXT+VG+qo+2LRMepPTBu2OAdvxAhOKuP9caUlv9Mbh331vR1dGEc2Ctca+hVj+0hgwZ6EFRSB8C9rvgXhEIjGIj8xhBFJ7dCu3iX/GsQJzkEMv99DYtlFAHeQGDw1rGCCw7XE+AAixYQUTmo/ztBe3rMTZ06R4mb4qcv707Dt7zSQrlUh1yJANpyK2/NqLwZlWbOHdqRkrB8nQNRckUCwCJdP+kBZ063mInjeg7p0OAGDFJwRpf058SXODCOONQ4YqfEpDzfI4UkZ3zv0hEihfZkKGu07SDlMBSGEa3avAcdO0Rt/4HjVX3nM23Ps89GRD2GEMBtDCJAbRik92mo4wB5Ugj06eqri3rgpGFhPJmpenmxPRudVrvH1ctP/P9hrhNZL2iRtMzBpUW9dIDWQ+8ScRnIUajk3EgzF7aXO01Cc+NFAcIVX3mIf6xC/X0T6kLdoKf+M+lveiDp0ASeaxDltQ1OeXsgmR+6A+9kUNazBWgvPL1Ozyv0mymucc0ZnXBDgtObMPgVPZgcDzHy+tpeXjE1R1b9uWUeC4doL2p7/Qi93myQvDoGA3ttjiNsYkUXjazmg0ofbBZELPg/50w4C/jv0nbznnKGIXAkqmijHD/RePeeleXuGe52wWi/jnaw3oU/6CqY1h4Hhmoy+/Slvl8tTKp5rsc5bQD2yRD5tAxDyuemM7a1hbJrgRHRzVeLDCpJpc6UC09DEvblsGMjK6dzKLqG9eBEVHwnX+BolLPffkU2kziI3p+z11BDYU3xfVdMUIj07kJZrI6NOKC8Srx/XYQ0X6TlS/MIQOs/Y4T9jprlMGxuNJflKu2UeqP3p9CXGJt99kGiIT0OOcDKJXuO8mjoNLMFoQqj+33cXdv+KvZlKBhk/xGEBATZs7P+U2+jH93Uod4Q2pLYI2Jr0HIM/A3yaLMtYCH145iUNY8Q1VEK+qxBFB6I2MexLENDBE8VOu666saxsj4NsTPPB1y7+KSvDu+Cryar91tt0N8TGNjq8ZdNY0hjALoOMFqxvB4ckOtz1m2RwSlEf2KjAH0mJf8YukiuojtU1r3v39Gi8ppSVfYW10F+eP/Zems3xSCrh6VgkgH49Xlmc8wckSDtc5dtZwrAbjwJs594VVnmhQJmxNtNloooaz9me5TEeYUOO39+Asa5dgtV3VR/RTgKaXtnYv/89ZHsPZPNYKJyt66o2r9xFyjp5/zeNZvuVncc+w+A+JDPSj0eZHrenWopqfXbOhLkWe0RR4xmg78R0rbEAkeCQ4uWNbi1uPFTlyIK6Si0lfUgqr270ZA52aKV8zS6Iq4FWicniD4ieLxrSDjQvi1fHv68NTpYrHWyjM5OYJwE9j35XCwcYGXECNr8x4ubz5UpVzEC01ay1rv0f5jL1q74eq3bvRkpzyjfYm5jV4MbarApKY3hdxykfB7UVPub7b31S+BtiZfBEVXbdi/X7mPo28d9ReeIihIR54GFVwgGBRw6kKQriv/C51Mxg5TDX5Lwer8Mle/SIe/VIV4vHKwtFGJNtEgYCVRHCIgG4PsiDWF1AP5Jsqdu3JLwlCMxDgvmudbGG2NDmYXSqSq4cQ9Fy+HVMckK1LEf4LnlkXU0MhX5lHFatbm1eG2sGKy08I8CJrCGoJo3glP6Dx8CIIaY8vM8ycPZZDWoaCkNUySWLAjni0K7+e6D2C+TGLMZ+994yc3DJXSjq8JxqP0p5iP/uYHiS3eqV7HKRV78WLUZCnccveNKIHJpfFSkiiKGinUDpT6O6XNjtfVzcOQ/AoOK/R3Ab4hnoHp3ql14orSUXlittchCUWjlrcV14cNtjmh16a1oPxDZ/arYVG+VEVa9RmlrVpPKGSgVw/OQNJzqpAZdKp03PZ4s09G6xggnUnTjLPe02WrjsLhrIsZub+9KY9Jm/fVL3fvTpw9N6hJBH9ddEraE5t5q/3o2gc7Iq9qOh7Mk/oCJh9Q65jmVwUYt+eUZVg9tTmix3zHUCpGjlKUvpwpbD15uTQfBqhJZOrmUEZ+Pt80lws1+ZicS4kflCd/139YsQtyqmxzP7IT9GklZk9mRY+Pv+IMRQDArqYifXLzGaapPYYW7TI4IPs7ZE0+8CeYcVHDORseyfEajalrbngfnse1DT9SA5007A8cd8JqyiwNv64uy374yL9l87hrxVaYmKZVCQ9SSzDnrFbRj2n/vkPkCvffA99RFXd1lwihjYzqNSOSwq50dAsiI1xKUqwXCHyo2bwWZWEYY4+MJ0CGCmp2Yz9liz1lUYWK0acsvJDpJyfgdVHyHQHaqLPBydChuhzaY7Ce+5phDxFAiXvq2P6TFa+0gEvdlomnWMzXfJvQPLol4OYinlG9ki/mA+iw2B/oiN8Vamada0+cQ2iQ2AcgQUrAgm/Hci+1dYggvSURgu6KWJg++MpsSRannyqBb6Jqs0AkIdWqnVO9EOUOEeaeyz7mmnmsUDyjUXBt6ZrkJ9+d2ylh2RLtbt5EOBQiDPyBw5T07iZM41iLsiiBFpBJXvM7L1yUkJgx5cmhzyhynnVXtIbqpYkW4Gi+ugFScAwpunemVHQnzxkkLIhxopb76GKLh+a26DpjOk27x4hDWIsQi9SKH/jMovb6JYGc4ny2IIDLoxfamAh2yJbCQH7+XWabJxlE3PZ9yoFHHN/yvhA6P8AwAptLy3Mm8J4Z7bdXZissoMLtgKom7qEP4cHQV1GmnIDHj2NOMNhEL4GeYsHI5N54gWfIu8oZ2ZsLE1MpBarLGNJ9XlGmMbsK2kCwNNOBU6Tj+WucDKnudgkzt9XxYnqV6+KEVMst/KldchO5U3FnZY0dr6AX3MXhmmrjYK6cJEvZh/BdNJoFrk9qW0SfVmQOxjHMAFpLICRC7oLj1yN+DjYTBKKzJHc5ZIjt5QXVEWbTp1FdI7DhHhKDw2CZM7jVKAnGo4rufENEByqTxiFJdwRPyDYReljK+2IajbaqQiQZhylGAkLW9NptPFGZ0pSuQ/Pkp0p0ETeoWgW76LdOFS1SOjtdbloxWF+NPbNjnUxPsEhAQSwD1fMxqWGkFA4jk1ER2c/wql6Aj9nkfNV1CR/+sIEw5yOuIWpfXa+1P3d031i/uXAGqxHWT+SFqthDpm2uFBIQgBQO+mVajPrGGQ5GLX4Suhv4RPU6o0cY1GZc2rms/uVQdnHtfktrdf0agbe+RGKfMv1ukDHYWDbXagIL8M1p5f3Zvd0GoRSW8Y/KaHpWfpzfXGqxruH2IpNnvazcHvRtEJlooaP5P/ddVEo/3OqIoAFX+Dgf/rEoU1h+7o8DAFyPmLm6AGp2JKclr1+GHCMRk4OeIC3LygbITe4zDaHqgLd476O45A+6RFsjnSzFnmj04LWoQNKf7b7RGqiP0r2tsfuGeG+/7+susUKY7o7ZLlHX7EAdi/XccX8uLekXZ41cakXv6gxRv80Q4bI+5FbL8dc2ENE2DF4MD12nD+AlICqJbrn8foSTM5AkHXDGvR4TjEqs+OBcqPi02NHEcGTTycY8mOhXYvlU4RWQ03CFrFFWFuKpIrD+PubFwjw+7QJT1qkNcBbgAiCjN1CpB85ZwcgVbqb7P5cKqIb0VYrc2Xyh02cUy0kMhaEfO8dUwDoqqnNeilAHXaP5XToNdwkpiPIDG/JQWxs7V2XlRPWAL+cnMfGSnRzo2p/1Oik7pl6qy9anwjWmMpjkMtQZfO5FFVhhOjcWyWVBM6mS4oqHASv/D3jjWZxt9MEL0FK8lOpuC2Zof2gEGOST64XUc1GZ2ounbCgceopsDYamBIUA37sShr6Lssfoy2+JFhlpK+e1ormUgIdl2a3BowooM/zfVYOQsz9fsGzwY4zp7RhegYW5V8vHDxCzmzFKGXPlY7t5bOf8RQjGpYmkFzCG9JxERQza8lMw1WKi6tWQGU0VzfJmjGUAz38v+sVjkNMavJQfDiNrV/JuJA4AeCTjKx4oK3mLy/jZDAM8WOL5nyRMP6J95ke33FugKgHDXXgNM+u3H0LVTuJJxEHHkAeDSoKN0NpF9xpjQRwzdPOwNQel5OTJd18z59gFrii0WfUEX3KHk/Ata9awXNh3gXQgIWQXAcoWZ2CAo2o4C95wZcaCK/3Ifd9hb1WeLvPMXSVMtK0c7AtyKgmFh0nv8lEWxWgLOHVbgTSO5YiCy7HHds52kh9wClBdSUuujJn9BBipt74Nn6YNuqsqF0Vv/pKVi3d94HYkie2w+rVI+J41TVCURK7XfhVue3Q45Hd0kFJiTz7OzEvq+Ai5bVknePXFZU2IeBbLjgRL4dMJ307C+56j6XnWp8XXJT2ujowvaYaPhJVbqYFvRSGjh9rMIjlQaWtPpE7LiImIHco/BvX3uCLOQNJSiWQquzFZpJVVWMi76u2UDF5FOCZWID3zzWb6QVI3t/zeBxLc3FNpnXBRnJHk9g7xtA8DTpZT8E5un/UjEUxcqaRsFIjw0rmXtWZE+cYXP5oIdzDdnE7055irYd/bjAGkJrU469ArSI9jcPqrMdiH2T1iYpH0ECo5Z4RKVc/ps2G1mL4Q+oXRzWd5ixWRu1gFkUfiovrr6WdU5KENM7riAL3LxiITH683Wt1KFBuAD896iQ0GpOSZlmVwRtEtsAgh/QCDRTIbZ8QmZ0sqX/urRm5T8D2i/LiILPkZBD79p3itOJrva09n2FLW2+8b+tKEqzx7KOpD2vUx2O+mVt6gjlqQlW7oge0xMF7Gfn3APZdUxW68sZDOGDUUSu88DH6nAHqFSElhYrHfFOxng5fjVsY7wffqGjAd/VkQP0zW6m8ynUCoAmc0ktS+aw4xco753J9//pnDqkBeJD5dhCoDqZqg8w1AL9c5BwttZNnCkMicyWQUztyvpBPu0GkMjZOvl2sjGTFeZMLv5Ehr0c/GVq7rCWEFUUMt2A9jUQeCmfjwJVEdEnCAt4Yvso6m4516uwZXvr60EMqVr3xgmg5+HYD7boG/T8GwcQGs8Gv60p0IyhLJwvxl7r7Co/ZJUJNls3TY2gmWGkVQ7Wunk4MKo60Q1dTWjMerM2SvOmRZ4wxXQOoM9XWECRgJfG8laZZYPsMjy4fj1pnG7sGTZDM6HCDfXYUZtQxQkT70oHpj80jOy+d/DYF+j1KY2pxeA7uV7hF46SzJrzJMKuj/zgWmaKge+96bUBNm0YuNHWBd17zClpK/tO6ZXSyxStoFlCxyMCAX6Kio1ZCeu9U/3KJowbislSEzPC3WUOWarrXx6tJuLkA3uWe7Q0qedq0RNUFvBw24G8G9J+Y7nDwAIT7TfeRjmg3v9YV9aSyH0DsY+QYpary+JMoK+ktmvchnvAiFEOfkwnGPjh2Ikv4NgO9FduAN5islEihY+GL2c+u7v5Eojml+p9yCbGxO6Hz//whTxtkZHM8D5O5GMYJvhFAJHWo7LdjTJlNwC8BSzx4VfE3NEEILw3Um5j+Pi2rrYwm+S7jMmSzzQjnUe2Z1Dd7hZseSJN9Md6XyWfpU/ey2c4GP1IHMzBSfD9cIOPtDBqX/ONKeKvJ/EcscG0zlKgICurQddj4BgIgbSaa0kwU7uJFEQUYPhN/xDXxcmWjKmeX6JYab689SGsBSQSNfGM5YtoOTUmBqsT6IUBWFGAflZdmwa/KOd4YuMol0tidlreWrneCvbTUQKw803VW9EF1oh63yhgvwm9DMQhKlvc+ut+HbwRXaNEd3qfr0NME+mpoYuxNxX8MR8p7Vwba/jIPgryQF0qULIa6hbimCHGB+WPGvAlIv19M669cOPKLjQlT64iLTHafixr4ij3y4k/emV2r5466yBcaRCzsCUkfuit+W0tqYHkrmoYr7K/zyUzzVxm10oB0zHzAcmOBVRp5cfWJwUos7OyKnFlNyfnJtEZSwhZK5AyVlcG8YcwNIxC2DyIIHoSjjVQ/F8e57mT8CcnqZzGOt4mWuIxCFKin59BJS90Fo5FdCK9IGzq3zO0aIbO342IkKdUzRay1642caO1GKw1J+ULHgwGrCWagYq0/me2KxKkLIuG/o+JfHvNwTp9we6n+BkB0J+zAmIRfrvERSeMdHcgwytlqiA0OV0Pf0CSSZeAGghREQrUaniKAeZXQ+IpqLq8ar3VD8SkpmiYXk2ufrbHASQmj9xe5duemPQY6dhGoahyqfLg5A2HYIYtSAP6dmvDyFihSiO1AM/jqgJVMJ6U8GtJfk6/6GmcrXNUxSenEydTwscw/UTBcJQP9s2Wb44ISB0yArd3ZSVlqGrJWTBrFC1B5YW7Yt5gEjYfzdonQAjV75wham96iH8l27E1FNn41v6hDnNOkf1oyYQQiZrOdlgreEDgywGO4D53mAUId7gjJr1gKnGFK8Vcat1sL7rCnK4Jg3y5+Oc7cSW5v7/kNkri0ryzZkkj0STxC4kKcGNpvmUMrA7AeyeM+U8+X8qcb47/1tKkAfdQClxG5ESGLnAThrafs0itU9J9xtGdHC3ZiURfXIOgN1cwvXYCxfJdgWvxCLkBKaU8Mkggu8xIxbA8S9HoiGg/Q4su3bnU5wYZk8JVLhr7wwcdBZOdzbA3hjSm7lMBc5cBSH9ENJ+H/gsXMCz5bEQY7RYsw+T8k3880UfW8ne4q70uOrYte/69BK/J2naSIvyE6zmq6khSBnnpBOqwzsMRz0aCJp2ED3TUH11A4R3DwQQ1Lg8guo3qcULPo/KVcGvkRBvpg9pRQlaomhEWqxd32LOU32zAv8mKc1ZZfKMaEu7XldkypiSgrqBRZyrCq/B6gzgb7Uf2UNY9n0SxH8NneYN9vRoVrkKelvqhJx9lT8o8WlFij+GHlJ0lAnvWmRVr0hhc2XiA+kw5JxCDH+y13gWEk4FDO25yGh673hcqjjKJb4phK7CB9tSjyoCLT64gh/tlo9YIzRHOAfX1pGSfhYsazDF2JjcoEuZzjtP+6QFp99XVCaes/LMXpgCVbr67SgBQJU61XeYYoTbrkaEMAvPZssssdSWp/JGdpTweQIYo3UyAU39DUdYdlL86CvPSsIbAHaqQ5eQ47g/sifmgJrFnyuucJLQdLs+RAsMlxpd9/SqZ3bhXDxwIbnVZXaw9NrM5lUafixDZOFClCMz+z6y17/s/kC66UAh+6SH53lmHYC8NXu0JKPjG5Q1kmi2Sj0UE++lZTbK8tJ5NC3tcr4DyGehueSS1cJ2SoBzkPpI4Y9labZz2o5BvDygLnq1kHT9I+LHz1MeyJdhwF5RM4iPAAdVyVns+HRiiBlK8ibQXJzgxcwO5WhaUet5sP7uELod5xAA4BbhV2c0OGusCpf2lsp5EMwDbz8bAMGJIZ3hyB9Exwv1Lnzb0e4f8L7829Vxxf5EeK7rQ6SkdU0hq2Jz8PwdzejhMPeNYISs/bS1ae12VqS93BNjd5hIcCL0SCsuppmxWB7helLzmNJSH/WvcJr/al5tuaIVEL2BhUgGJj+lfh1ng9+4yPmt4x5k690hSGjOzbUMjsmIZN/frgUAfw1dA+yU5FkjEDxwDZKCnzB7Xikt6SamWjqsW+cm0QGf70M6RBKB+j0JgcK41KqsKR5Qqx2oubFV7Q3puxzQi6XKUcQeScAHMunbZ0NJei45YhgigOkp2kmmtyt8CHUb5Aoatt++aUSAuN68Wav1AJrfqHQYMNKdt6JHZeSpFa19/8F59J6dV1QSpueXG7E+2SHTAGit7wSx92r5T2eztOxAgVd7ZyNkdPzxEgQ8lnnRj7V2GAYDtMMNnr72KdNJ0xyOPVrQB0acB5Bot5fs8ryir91rRgttSOq7gywjAWsfyIodZ2eksaUhenuCowMfP6m+ltENDSJXiSkrbaM2hiAFOK5vKbNtr4ddD2Pumu1K57yp8lT88nwrNBQqCjCZGjeCr51cPO67ImwmkfNC1WYAbt0/sa6MaHY1BumvERo7XyLpVpXkj/fSc51n1Jkr4TPplHBjIufIwCGLz9ZmQ3Wl2usxdRh26nHyxMcuBxGdSlJAf70yrThxkTT2BDaPPM2CNfUz/8KrXKRNGDF40rY0Ajj18Piir2bS8L3aLwwzdzeGEzIf6RZZXpiEpL4/Y9kLE28vQBV0d12H0i1LTAEN9jmZIEatns4tGhuXA6Clu1iUvODcnmDGZhOOmc0amFsJEYuODTNGn37Lvmx2c9JIDolz9K5gO/WS0103ylBuhYTj6qUGZTtsnTs++WnARxNVtQhcpf56Iy2cV0PgeSRrSci9anaJw3YlMQd/1QtoGZYmTSE2JsGGNeQkaj7UUHh6GgEka7X8ICb6PXQEyjt+qs0Zon/uiEiypVwKJjJrZxphdCW/8hKTkTpZ5fXwitXW93BLhBxqPAcGIcZw5qC9VjBrGujaXgG3O7UZbOozBIfN56d0n5P5TdJ24FVfLhqi7c4rh7Fl2lYIILzjn63kYR2z34ykKFwnmMMOCpoeN1ZY70cnvdGpxku6vCdgxiYUJG4N6So1ZItVoe1oxLxj8NhP90bCAQXk89juRxUJIR/C7d+wDRqPuUuFJDC9wxBQ69yRCwkcQRQI7mRpPTI6+MiFaANXPDFpPVJ5H5qEOx+oEzirSa6HWrevL8DozmTZDqL5QZxQTAJIhvFkbhFCMuWG6pkckZhou29bJCAjrc+3a25fCfgrvdPFE35GcRyHA2m+r/EsuDmM2iar3basYE++MBtmSOCqy5Atg8g1YUhbRwfGsu25V0fJKRUpZ8gF4fGmCMAYRFf5YHUfheQLyl+JNvmwxU/DmsErj2H2O3mvm43/AI6mNnGyuwQgAo00FD5tBWFZZR/ooiWCZHwZ8UzpIG6VzUToHth8MdSYtU211DH7RKm4b+aGNDDXDSSjGo4QE7AQYDD2dB9PbW/UUJM8ybPZvs5bmwdFL3bW7NhPDXcLq+2BWYSyNci3ijuZ4YL3VJM/y5QHwJjwHfG6XHZ0UqgPoRc/1OpYwgchYjXHUcMw36aJFHvZMwlenGax4EjOLRYOn689z7S0ckPeOmFTYgwHKYEqi95NSiEvKz+qWPANi3Cx50bOG6vlIs+b9S6EcLC/aWnX7P0GaMshS6a5z2FbI/G350+oj6bmC0mao4jB8+TGDcWmlE0TSkgmf6MJ0i7LL96lInTmc84zP1vvv/3/3m6McMCeagqiLaccsZa4Co6r971CkGzOjjIUzWNT3XlL7/+4quL0uEsDrQjguo1JIZ2PxRnUgMhJwIRCp1rIxdo3/qsgweTr25n9vDWl/kd1XRhvKasrwYd7J6qd6u8hiWTNmQNJLNMcsGfLG46bBgK8GL1hEthxmlXLrn6wQcqX71R+Ps6lb+Egv+XA/Abywj+9fZc4+ZslQX3wRAYxeJDasYx+yYq7cEwPDL02uAmEUMStGmhENhD6KyRG/qQZW1zkeXT2RrcdLbI3U3H6qiaSiCU4eBqRyMCLd4OM5tNAXUYPRG4zbrLWMWfWr6udzecAHYEgVxDM02ogncT7Hy9F+5rKILmBPJzH3ZzTj0d8NN4qsAg3BEiVTi2ojBH0GX+4xGd94RBynHS/e2GAM2S6XF4NwDoa7Olgi5qxBrBUYMyXd+BSjy5VtZHrDTGmX6n3iiN4p5UQOpMm5evfzV7PHlhWUk1V/RUc+XoNHMf44lBO0/oAb9ox2l5Eel7IwUe+Tyk865AJwqh1cSm/nO8PKYOzEoLEx8at2cUsRSDXSimak1ctLsWSy+mdXiAjA98aN45hH8Yfg4/4ihhrH8HgTF7HbK3xDXDzbdM/PKn7uBg7enm0ehxx1CfvFGD2zKTWmP7JFZgqzfLW7Q/Ky65AhlEK0bdyAJAwYmwTY8kNNh06hgSrnzfhw/WeTq4m+4AF2ID0iQMAkhpv8s8ri4JLInQ/pXOHzv6AVsRn1erwfNrOuclGSGdTn9KgJ3t3SNMQVJmgyWlFdHUcpXVDfRs1E+wfQ9FZNnF0QRn4bXV/PmTgNA3hMOUiktOMqjX/gLlZFB7mzIcLRajsQwdRfIXHijhxDVrtrczuFmPz2L/riAKGaTmX2lvl7RoAHHCBJGeq90JjrFJq2xhDagXaO15cSrWTBs50x04KWMIZparAnuR4KnGiKG8aL02QY5wg8wp8zSjRl8hPvT54/BppU1j5kfGjNS+N10ckCXpoBAxhXEnVMCm/CU6nAHXlPw4QTl1PGrWwNIbu8TLVwo5pz8uis6uImiUxwc3lhi1TOn1A40m4K1txs9zGyckVODsQVzfR2p3cUQYlV9yIO0QelBaKuUfEUmTCX2LOuWlKhITEBEcY6cRlDpsckGbqxqJNDcVm/lfmQtyv2nN2hXuGU72UiBjj26xIF+2Qlnm/77TQSXJSuGEyy4qTI0DVv4sEoYlTxuFe/4pSibdvUpR8TaRgcn+n3WDKs4H/68RvrNG5X+BLLbrwjvEK9X6WTxnZahWpM9zzPujjKYXfntch4AgTQHr9nEExDvpabnsx8ewwLxcPSl7XJlCvFdWAlu36NnTk8AWnX4QUh+vQruytM+dLtMqFw91nM1ogqcromoWxQ2O9lLEA4Df4GgkhMnLd7+F9DVi8gzTKdQFBx8itgN0LkrNsn53qlD3imFZFBZxuoG18kRHonwfrr3mQp65zJTMbTK1qbzydg/gFV3/oTfbF+hmbnksyzOWxtusvZ5TLmK6KrxMTIKJv5si7+kh4E9HoCmyrsrZfSOT/ctDPi4FAsoWw/iSgnKBJS3BU0zXVO3wJOBc+IeXInLJxmta953HrNdhgr+Mg0lcAixGVBg7uAwPnFHg7OseLUO+OvHEe4XOJVCtXWTMw16SpLbNsJgEm1O9lUEGq/48/dTv1qD1uuXPfp6CpyBqozhMcHrJwZp4VKctuRItp4xX4LSJmw3OhC3bFjwLg+TVpP+SuAASapUdp3+0GfEQmLrhtM8NX5kluOg4YK6l6HH7ocZBBwhG5hwtKopE09DHGsVPai9LQu4cda3jD3pYnrE3eM+x3wKlhjPGmL09zyenILKtCbRkXbduWhly0PqXPANmC/xpSV2QCcfDnnkCrFpm5+HlowF1f+y9KZ46D+4JY/fsw43v881rmT1qp8RhSVs/kNARGS1Q7Oq9mvbtuJi369/w9SYxhj3JWE68Z3BIQTKRLmvmluEBk8Mcgk70ZdsSYcWhsGwlTF2FUUr68KajeIVve/Uatha9PaMZELPhhALTLpwckFgLBdXs8sHRsPgZvKSuNwHjG4RHxoaeFdYoHZzNAG/VDgh0JFAxj6Gk/QkQlCgdZLtk1JP+59i2RyWfEjckC+Ja2FxbyHwkhtPGIqRhgI+EkUz2J3aYEBUn6fIGUvbMgtg8fynDLgp8H5TdLGk+fFFZRRUi8uBtUM9P7SDCu0eGRXvBQbCYS3bV0+I6R5c56wM2nv0QRR8+1W4JInMTjxE3xxZbNu8OXkpJAQ55W6LSbLtarR/bPJPOlfQPnjgoejA1ehBi+UUoAhCORph849czpDFjsaE6IgKTa8zRkkKJQdPJaEyuiBzvoM/CyPz3fJ6asYfouAZZVnbB5Br/ImblLW8KPxjN2Clcv9f6rZnzXo59oqn+DZLKLfdSAOFPC50yaBaZLhG/lJSdDm85jFO3ywWcdYL0r7W06vfS6hWunuCvibAm56BvM/6MzNvT3gf7kGFVnwFiBhNXq/mYSYcqa9asdLn52hQViqwEDHNIFGYLHh/Zi3ate6L7h40Gj1cq00OZaPSQN9clhlCjnao276teJ6+9jPx3oDzcCWXrChqfBCzCv+sVNOPVGJbXEqnbSOSFXmNicGW6rFTcG83BTPw+ptrvXx4bkjCGNLPaV0VMuMVkHwEY7emOf0cXKe43gKFeyNezc8/YdfPiObhhN0FNlGkr/PDU4PPI5G3JMD1Y6yYjTUDHNmGCNJ0KKCmjZ1xNWUFvnUMm7lBaZFSAPOg4ZUGNEKvIo1nmhZd6ImrfMNfkNGI33f8T+xD9UMhins6XgsXehZjrf4rtOVwLrSuI7KG/nBa+H5/wRrpWT8lZJHuaAtLmW4eQ/N+Be0XnrgAre1HhJLAelia3URn4FfhMDyEZ2fa/E3pWCDR3ekn1RYcSU7Fu+sK3buvi4VczncadYf5UuZOwiPoWKONHk67qJUoVM7AxwTJXYrgdx5OB7R1ptRKhiM2XI8Ik7I1X6slCmYwXsDNyN7AyiHap1PUCNIqp2gNmksqQtP6nXdXqQ7pF/e13Jhd9CyQZVA9G3gWntUe28I0GVccp8QUpCymIYwU2tIXnS+hanFC9JtQsVwN7z3bGJyGOpjO+SKQe6prwrrCuQzUAO9JOELEYEMCTQJGV0mmAUGN9rHiEJzoZLN5PXHhPRAwefrB956r/iaB516JSSR5s89LPOUvoXsfe2xou14E057h+1EioZFqoMwnzinfyGkSoEDLKez/eQQTcc9hfawilyn589MYfg8yoSfTwVbYtr/+0G9HskcivXrgoUHcQrpNsavnUkgYFlbwckK4wQvi2nfs4Rl2OFRdgc9WMITkXoFXEZ1aO2sYWKfHG5Q47IM4p7vfaf0yl0kgrTjP+urD422sfniAgVx5oO4hyCPes9yY80Wu1Aa4xQXk6f6WK9E6ekDuJ+VHHeVN6qyKqKQuBRo/mvBFNBwhNi86ENkz5VesMdd1PPeUGO+hx4GK7EzwFVxPKX6tvveiZT2fRxrBcKqAVVNWaz5QNf0KMrTSlWALPf9b8gU/H9Ps9NZkL3taYBHjepIfGS1h3mJZ35MMpqGDyoqRhKgg0f5z82nDub/8EL2Eyd1Ktmr2vJI4fB8k8tKdeSsKqSYH8c9nZSsr4r5AC1z9GbXZyaxKfKvP2GH5PE2EzrLhzxUqtK7sNPM8ifjD9p84Lt8kb4UtJWx2o/3QkA7BS0UX4UWf0Bn1jzKw0+/ljxL8RTwFAL0g2e53zyYNESgE0uTOuG12BuVLKSFae7t4GgGsFfovUITtF1ND8fFo0BQOhicaXGPfdX9MqQI5XP8bl67NHzSanTMRu0ooXeVUceaKEiMMfpG7cqDbvInNhB0srXg19U0byaXTfsOlSQEzWSZkJsdrExrYPgB51wZEht5xqTV5bSwqYwMS2HpMVb+eAZE8g4eRU357F+xXcKCqk8XbrMXUBTzn4E117AuC6bvlmaqMvGUmcQ7QEMn3qyLOhRyAaWyeglU29xvzNTUiIYCo506nxJ0XdXMfjBgVwlXTKeNngnYSta2CDXCOSXbTrj9yHzUgU4vl0kWJYgd3lhVjk1yPg6JL+3dA+lFkgcW7c2fOAd6ogjz5tBnp2wIEGnsXBQe9zXuS58AnJmQ+AQcaU2w8pCHOf6huwwHpqcuJ48FKxdSYDViHEjJ5eG0SuAiCTTeMfXUaPss7xIF03DKx4Qu10hKTUNoKHXAmR/qAkSzmenYv7MxDQg54yjF9XLRLmTQvNy0qK5XyxPWUbpIP5V78YXn1HX+n7VuyHWIVf/H9B60Hvx3sOHXTEeNWlgwWp/8sJ+auxEimktOydueqJt1p2QTbFm7WzH/vxLId0kfrT/VjIstI2973bntPYL2F3g00Lu2W287pATuE5eX/PF1ApxDL8GQYd4Wrjb0RWbX19f7jJRh7pVzT6TkmmUgo+pDGBID1tVh4r9P2rJ44kgF0fxSNZlBiPU4XfsTC5EpGu94AKloqensjewprTnNKOSF/3++dh6GKLISiZ3hViENatXI6Z+EqO/8AYuqgsPWh2LTQ8xUsIOWnyxT0Pe7jY0oK+0ElUTxC5D1eXkFkYhNtkiWdCpwfTtvJji972opPAwGCxikXkSDvhyxd8zB3XYfGizMsDQ1EnSgzd7zmVHZ47Q4acMDIKSCunrkshPIXq3ZQ7UC59wLYvlvMzLGXiwWeg2Y3X80SCwXmE6sulrxPLwX0fKYAKFoS8U22MqMCYJMQdwkMFpeALYGfhOTvoQNXrCyY5DUCYLT+TC4iR3+UiCZwb7QPOxaBhsLsHKIjfw1zSHiVuV29mPXowQvBnZWuf5eSs5iWkXBblaqxjHd4PSSBdlSCw671wLk4xKqMaCUD7y9NnsQkLd3dD0rs1ke6HUUHS/WRnXd7HZitYmNbBK+VLC3w03HXcqTFccJgmk1HCoAACCAn9FUfeSnQ3gOEBbXrtFAmGxRkyZmjNw+nmTkN1P2u0DfUZBrUoCbNxX6/r/UWR/dUNzk8dJ7tEhrYtAoH4K1p34vKaSMlQWgkrB7pLq44bQt3SE6Gma1ci0qZeG+Tswt5/F3n1E7WecuDQq6BaSAnpmnNei6BCutjb+0XnIpHPVx4USGffkXdz9EPqgqGcUPy/1Ts0JlUPAd/Gwu9jDV9TbVXKrMBeb9d9BuL+yotrydStB4CUvAI1ecLQ0JH5cu+EI9SlONGNP4DqyaOoovQGM3ODF6Xy95sr1Ci4xdFh2JhUbOeZ8tkwFJmMOnZxZgdYE7QOLJcCAaoiTiaQ7LHIDJqvqr1+/YI1fi2j0GfqK6u4zI/F/LBwPFH3cMucSibINsvnwqJ2ug7qMkjLczpn/SBE8BsMnWq+SI3rDds1iP5EcuV9TsCNO31fjIRksV7k6oLgthOxMm0L0nm34VEgwncQbnn2eA8gqP0nC9gQCa0MtvsFKGjMYmbP/Sb6W6gOJwDbYhpG8o97s87VV+40ekRQDkghUmc1EpCc5Ea/piz9R9WVYm+p/IwzUUQi6M/vQCFkBcghQfSzB6kYSXG2pp9RV0a1PF21vZiL2GdKM/YCLqagJXKvkhHFb3i+H50fkdiMvIkHpBVFbs2LKfRjO2VTFMUwL6ToQyK7B0bubzdLZovGGIU/FZuRqykZZsHOiBj47LGKn7u5juQ7Wi+JZcK2drmJRlSqPPGvE+73mcemyRadghKWVHMlvdz3EzOmJVB2oUkaPZzwFW1FvP7YQHTsJs23YgT5278SALR9qGRxn7VjNEOCHeNuYFyA7+BQRj4fF2znO14H+U/MgOObj9F8czagUptnyNlOtmoU78YUxgPyICZgZ23CPG9BAVmo+BB7/L9XDVjjrjDA5D4r4JtpsEKk8XA4bFCBg0fMwAR5/gCIbjPg7MYeQBkecNjbPuu1PcBx2Fwb5aEQrvFZdq3Z5dQt6+DGy1LpOSCO0kDaNmV3NKQeML6mmfdz2FxoySakgkNwGqqBshxOEaoXnEGp24r8XNZpGMhiFv8AQtYgK96VYJaTfoJ14aeVtw2V8V8xt5ARRtXolyJ2g2Zxn/3Gd2swWvP4tmZiezxobmEz++Vi8eyVhB0dClF2Gnao0Ya6agCkl3AbiYMm7lc0buw7pvfzfyVMkF2InAMGT84nEnjFaHrLYyrdyh6/mZoKsHbcFMK+WtEZPkwncM8OO/8l9sEtemS2tOxEpfPUEdCi1MAnGnE0jZwJRyIfeCUYmcx/E6woIrD9v33ZTKG0XdsjAFuLa0HjbUYExXinY3QOR2GGyPR1yA1YCIJyzCzjmESMWlG/8V54vJI/6q+PaTYjXRrtmSkJNOJ4OOaAOS0VP5J0RIWaw0DDw+j1Fq2N2CGLePbOVy9w6kxsJ0xWc3kF3acKKIp5TZ4Z5KZnh0/csvd3qhwpJHIaaCkA7SePL5LDxlZ14S7cnH2Tu2KigIm2FjTiVcsptF6xTk5m4DjJKWnidchDhlWwRUYkJK32WA7YAOYWgIhPBLzwvsRZncvWF0XIql9Q45Rof/aVwOhng2llgcvXiV8FchpitbLZiOvTC364cv4oplkXiaI0QBNBdb9dRcRpeH7hk7EpglKIrG1TWlPT+axFsnWTi+caRn+xEF+UR6hxFZ4ymJH98IVcq/miZE0DXlvjVoZkp47x7QMONfJHxY1lod9oLdlltHKsivOvhxiXYS8f5/NjM3RnXKByK9085cS71PUlVzjBU+/m9Q9604yQLREy/DG3AO5uiXAHsWEbakNTpXSQxAvpthxBnqgrwLZZFK5Jhd/TcV03oxsK7VZhib852uCpUzTmSPWgMLl6GDsPHkPVzyEgJq4GN8imVjASF5jnSSFL53QVLSOtDFv7JzeacIuKyf0pv9quuutXTtkSWHfU1Ac6ksMTmfn4uDwSLa6C21W5/URDzzPI48ZUtTodCBwjAEGVRaV3Ou27Mm9ZSlx0O7FxfQzc4Y16nnjaNdt/NegH4MnbijX6gE3c69FqUQBRgams/Xi5tJod+j8Yt+WfZS5PNvC42XWjzTyWSaowbSWJmRbXfC4S1YqPthEPJOR761hTfU7/DgxRdX/p/KB52QA067EySqZVzQHuOYfLJwswj2EjvNUIxviOGAw0UE0LycdhkpMsBdCkGqg0I7aukTYRSSELHsUO4S9ZvR3qagYJcA2rtu6ql6BF7nigV01hb9QJm4SyKmxgvqzfrgpnfK0ZH0IXcXVMtzFY2aFOiwRcaLqxx8D4H8O3xuHzVT7j+5GxWYnsqomvV8B+WHSubKVTnqcYaVHA+hPGDr8gKLPWzRHRRXxi4j2BIEBllSa6f6JAx4yg0/8RVVv4sPnQWOBrCuv+ML2nZVFIcA8cDVM/9Tu2nGmzM+vkxxWOKI4nbiSttKlROprFvIVBpZtwmzFu7TUGXyV7mTqTTzwC+Q8u/kbdyKLVUvqaSPUmAVXHGycQEuXdc3BIgPHU5n8PFmyu1eK+G51pCX5qJ6wLfgXDPJVwU/68GXd1Fqmd3yA5YdQZ9AI8Rg4E5m08v/byeKZLCfHDmaJl9XVF8tx4XBJQn8/7eC4M65GP/lMspA+3GFBpzKnT73B5DkQghev53mEzENTB5JoOojm8746hAJNsEHHEVTKRHGApYcrTFBYD8d0oRel8xCtdT+iZQ8sUQg5i2KF4nSIhn4nub4zPt2b1UpsvhzfrF9hHgsSZbM68+6efKqqrP+TvVR/aSagDuxP6oni4z8Ny0uCgwI0wgw6EDtW0j3C1ldWt7n43oA6C0pSZZSbIUWriRLbjvFmcGhrfOkkFDFjhFq2DDH8itzDGaXwkkfOvO/2ushOdjPK2Ffx65I+611mQAfUQrPWR9+agTr/aIjAtpR6noHCsRd6/FEZXCqmb7miCLAzvpx/G09cvu4C41r4qlx5MDeCrTAJLa8BPZp2KaOqREH0+qHpQMqpjM+eI4l6IYt1UKw4+DqNl9uV4z9yx3OF8BSUlu88BWCJG/aKquZYSvYj9EDegQck58A2CTfSABZ9+FWu55svZwQykUUOFKgu3ztgVKJVdEtJNYl/+E2MR4MTUmo6T2V02ELXma9Toiz0yiTblXXbpDwe+gZhtqY8voqwqZe5mJppoJCsREaTretfhlcnb4iBRF966aIobHHTRTZpmBNaRMeQhKngryzMaaz8z7edPAjQlp1ArbhGR3ApQ7+3a09M1ulpNWmgS+uQRJsGmGp4wkEQ3CqGESL//GYN2h5bVjfRAzo4w+tt5OVgMt+/HRf728ayfXGPvPerxg1cvBn4DvXsqEWBUGxPtnC/X/WWT3gSqp4fvc4UsEuhDeii9AoTXNPMd8+G8oduQ+hmEaIF4vHxSTC2X8tfwsFIBxtKylKB0Yxc0RfdTYfHAorAcsgwJym8xZPZCtfg3g2fLlvvw0Z7K1SIeRL0o9Yr/O3A+ImmtTVb7zCCxhm6gu9Q55qTl8GHfBPgICxVchNYXtDTWO7i5Q4ECoOa9eKp2mDT7KD8kNHXc2zCScZ0+DhIrGofLnyEv/vm4YGqn9/CiInyZVxpZYxowf5qeY6ATOvmc5sNMYsT0QjYGm5957lYbzKWL4XqEBsxXCcmZgMtSq6pMFJqntkspTr52t2UEy13jVi5fGofJYkmRCwwwOWURSdRC/I1hyv9pKEpy9CaCDbxgn4hfWH78x3qgIRbU/FqrAqYr5wjbE52xqcSuRco1SDREE4C5BKgEg8hrCi0k9L8BT27ULJRCyzqiwNuqLJ1M7XoAuLMOwkL9xssLbIk4edaSgiEGFiUitU6Uavt45Hzss6Ny3kiF3ud8Vm46nSv6EZ/yUOcX+K7YkJF8T741XnJGXaahQk1bljSrDN9JCoMfy+e5qbWAsyu4p9dCzjtQ6f+FuIUQt1tQDgp93HKX9LklRUG4SZTh01Euxl5c0AY2DTznkcGEoP/aB5tZbdZi/4GVgm7nPhV9aTv+7nCWoMmaq0CbAzvN9rQp+mICHP7/X7jOUU6AVUvvLBQxQpbBSvpBhLyNFz4pCMCSPWZtFqmdy7XLqOqzr/VKp+Hdh3xGEBUWRhHzHzELPLXFmcXngRuYYWSkQFyrsUw6pvfN4M524yZ7u6j7Wtxqv8w0OD0ZDRov2gBDxcCDskswdiDgbK6WlqGy+JZVlheibDrfqot7V+MNr3f6Tp09dCVW+vBgNkqzFNeioxFPB0hJq/VLgx1TSS5r+nT/7zcgWEp+xKcQOkI8m3K69yLLmKASeV4mJmPW/wCEnmWrM0qL/zIRVE4Iuk7iq5kVhXLHRL3nc9uj70ckabJ0GIu3+dwlpQQtb9v2DNyIKjgS0MRsOF9xso46PSe0YbHYt9cQCkKoZ1DqqTEP2WZ2nG6hCKCiHarVGVujv+lcX0PiPwNps8IhRjxsRoO7XwVseSEsPgIBJ8FhahhdkDPk0st3scUu7dq7Q9r1q7igpmHv/kpAaSTre6ajicsvMV4bEbYe7cdyM6N5G93JymaeZSkvalM0LzvPgvdnZGpMnhlqVo6sy1vNxTf58OYnK0zJJu6G7wnt2r1YzjfNR0wva+KcIteZYm/Ycbw0wDhybaUBX0SiRJHtr3r/oZc4BM/8ZFOzUOlMtZqrdq/DI22Y77eS/bHYKY/8TIkfjcZcDUQxAa28kT1e/H1LwvzCUjrrNLBZHVwuDdLYe6y0Re6xYP1t80jhvX4wDjN/K3RiTW25xTxdfDzC5pyUuY4SnX7MzpgfBtZeVEJ8oXpsYKI2mQ3ySVc6zv2iDtpaXDGUyK17XDGWIh4FP6Pth9J7OYQFiKmmVVD+j9ER/TLGlOmeXyZnR/xrwORvw+PFjqgAVlCW1PG+9mG5qplOnK7c3RZPi9ZeiZE2ieXg/RpAfnwcsxjeczmjdUUQEdAAecx0ThvcM2/cFYaAYC1kTPsqyPzAveNelHSR3mrSuCbKd4fhSkobdwH3PX9t65mHxF268qnqAkEkZVInRKj7krs09swB3VoCKLkwNZibpSWgls5c+DwMzFPJsJH997KEoH4/dFoFfylYo7ZWx2wIseMX3kOcOEdhmhVgnIE/qQLPyR6sKhLN+8SOrWd5nZCtQSbnfTwhecW6mGuNCPRM3Jy/+vJbSdZ+lC0K60zTl3EUTlXoZr4l/kRNhqoyWzTrSc2AMVgVykkpsZQ1HtENPE2EAROLFBHBCbhbGsaUWMuzibSpFvA+D5txdzv0RYkFvCIjoxJ8oiAPTIhJvX6DnkQItrcP3BCGcotIP+XCO8hDnofkEF9JtP1keoY+sGRqKbS0p9hrcfsNdRKDMHRi8Ozkg6f3ZnD3MnC1o/ieLwfY28NR3hYPNt7Zqjkv2hthxlpa+u73Q+x/FdbFLaKxanC2yjo4jQ9LTnLSmlChU7VqqTy5V1XHCNFpa5XqGWDjD7N+Ok5xRm7Omn0TIoqbRe0/kUgHy8+Wv5noaIttznUsIIkZwouxv7+SfmDaoPI22G+oCGmU5ywVpNa7x4UkWZNSSH1wwu1pzsCI6IC+f5aU6Jr/dx/eeWjp6tEigIXgFefYhZN504nHlnDCc4UISANKqEsZJjdxCzXB1nUhlHkcGiFIytFK6Kj8CXQmYFdvlxXebR4lJFNQaVdeW6mGYf4zfCMaPStSVahGcFQutXQZcjEhDcSKP8EaZbXmqbRDCnKN92qX9bL14f66uVK0ry/C2syOSQOuoGSpgI8hHatHZGZgCLJI6xm28E/KxnkTQ8H6MMI2Pe/WXbhdnmj/Qy08QO09dpCYeHLDFtr2kjtQGe9krgbojSujD7B6K4vdF/vxrrwWQi6ZC3h+Ubn4ouDp/LaE3Gz89o+YGOZfmXixyDGkJVmnRtKyusYNIPUq00jTMTqZGDfDuyMP6dvuZs99MZddyySufiI3Wl3yzzLgIvWAv8wKshgJjRlHVW+z/LwcJMY9nJee582p0O6T6nDw4IfVqTUDZf1TnnULxubHISE5oTLNkKarUyjlIuXeghsoZ0WTI3FX02IPoNODnFXuuZCCAbiptlKP0+0DhVl1d7AW7soVCa5N5Pff9WcL2+cgGUuND7XBdSTX23LW839dukMA1WP21ITHLC9BADTr6AQCZyXrdiSKqzuSyugNroMQvEI/8OChcsQ522H2YltYMuGQtS5MAooBJJetZ66eFiWNN3IDtCcCLuZXQkrYvYH0UGf41s6CMwG3uxZi2bNkC7lkhLDa1uPQtSFknxpj1QPq4vxnyvIXUxSdzaQGa1YS//oymtbZ180/SxUsvGM5tI9814/m2vgGmkzM187IduqFBVgOnh0KiySmEQ2itZHuC6tbouqaDUreS5+32vpF2IKAllup0QYcNPtVkpHzhKEGu95QvQv6+gu2qT1MvTVuGotihcjWHXnDJR18k+1q2R5rohECrI3cxzvsI8O3j8K6XGdbepPZCqO5sWzXxd2Ylh8Dgd/TgYCukeX4siocX1MJy85EWWeL9M9IELl75XaEYa/j5KejiDk4tJGu54pDELD8MnJf8CIxxJNms4QZ5u19qVdhU+nx74Sb1kB5CgFhW5v00czvGkKCnP4TBvNU/cCluixyjNPum2quLnnOF4UOBCCx41IS+8z4p4gXZ0wOGWcEBMWKuzpkjkn3vjeGVCaJc6ZyX4flQ0i0bw30zpDJfoTzEGoK6vj82KCyoOT/eCgGbWdaSYRFijcMkMzAiim3nByKs4HCzPP+2DBO8yPc3rlPM0OXT27Bo++UoQbGdpQwBbshBfZz5iFKMaioYcRNy+eZak5Jtidx8Y2s8gMhEUtBsC29G0jv8I2MKEyfsN2dWFXMmyh7pQ4W5T3OU7T3OpLLyb7AY7scOyLT3lZauCvG6pgnB1yeLQBz6y7juph++YUR6RSdRyNBdmo50a5az+RJT56JRAda4V8FCT9V1m89sSK1PT8c2TacLo6FBcGkDh5QsiOzHtZMvraycNzm3u4PvSZ1At+D1WkM0eexvAZjlRFWarpfBP9SL4xJyX3nPLORgQx0j3iz9hD2B182AsN+V94uQASkWBBSlrjMYoU9BNouYK2oWdNydVc3zTOMKCyo2jY8qCZvjYRpgytYo/tXMSFYdA7XVY/3XN5ippiC/cNTJyRC60nJtLhHH6BozvW3GJzqvw09D9j9AXZR7YI6FZop+LBLGn0qAwxlE+8gVOmmOTRgXrMAgrqHNepNelB/mSFptFAWi38yH+SFM8okZ9xqQfULAKhJ/h1+nmp40ld4x9f3P0llHaqy2ATvjKtt1rXlm4Ufqv/vpcZY7ZQDfHRQqIdbcYtCCwr5lJlpzEcp0msdc8UQ/DiMiCC7REjYvUcbfculNgzEvTgpVh2dOliI+wivki2DSAmWx/ObJ33bQxQeZK790/yBp/1V7+QXcth9ENjqY20W+BRXRu8ySWhqr6II0YvyHfuQhRPSdyjC879ccq7Wqqeey6ZErgmXk2tOI1amyQVXxEHCTOnkTCAdtopFWQ0KXZXMGHDjeh7Vzp/EePbjaaABKDv31AbCLz5APSNofI62y7+F8Qb1AGBiYnJJ2CL0Ydjmhi/Xuj+BLWfrzWr/2UG4mGHhYp7TxmMlKI+Ox/0vKzpfYoHV7r/cfP0C57z9SQLPuHxOSS1Fx+cF1qplVPLg+tET/6B7iokaUIe0gZIVdgPV0QlRR8FfAzaKf1uJLLDiuuqPTVVtNQR6tHhxSXGZfn+PpFEnWJlgDhLz7hPb/bzQYNxL/XLpWds4eGJP/mETZ8t79nfrHup2a7YcJJW6Rj5h2ziufnenYPq1AlAkwlh82hLJ++EwPzX4l4rwUBfIWjQYWcjCAkH0v0redMse2n8u/49yofMpCzUf/Hwg4kqyqKQ/7IaLEf484TAkWQ5dCxxhqerBshCdUOXCNroCIR64iLAo5zhv3YR8WLrxkY6XCjhtiQK1tUOunubsVjDlEn5nom2TZorCjfscI7WawBocmFuSoa1R/OQ6E73mDSSrCQLjlTyGqjuiDPNcSv4HsmLJbQHBKkjcdgFDWilTE2d9fQbp+A0PPRMdSDbHsOqx+nN1YmDij/l+bEu76jT0g0lSgM1Arbv8wbB1Ves2ixwSSam3gR2ofZt52ROfaywqr7P6R1GY7h5Ls/Ii/t47a/iGdjIvN7O1rX9Mmn+/6u0DgwHOINZmUe67r3Hfsz7Lqjk4dBkLETJhDfpPIcGaRLUN0MROGwtvObcJ9V6nL153JB2uPDYtVyoT6dfFQxwiC/W6yxT3LMy4vzXhimD3FaO2BNrEtny9+5lCBAy/e1CIAhxL4G9Ml+czaG6sB5hbAK/6PsZm7GdCgnipho3pO/CIfvzA9ppLgPllca3el0M3gBiiVrA1ubaUTkXVxaXU9atX8yAkInekMjGzPup/RfTf6rYlMj+MQDVDwGui8lvvYsTPypCGQ4V6jbRo6qGvNSDtSX+CdjMIqGinRbCtSjT902YGvi+7W8oWVfbe893ZdgyS2l+AapZDdwOGMDF5UTQUrrVbu5cB1v1bxcbgFT2kDNFmUTGZ9a34LX2JwQAJVvGkPiPcmODo2W3qW5l7xhZ0kgVUY7gpXujq8EKoChYZpY7m6RCWvSwWlv3miKs5AeubxkSCQVrQrw2OS4R3HFHaxHPwcxanbsMJLG/x6ZEhmtYhI6FqjUcGTvGB5/m+ajVRoT2JKpfNtZAx6dQBQpscWkVpJcxg5NWZ3ZhUdSkWpclq+VVP3EmnDVocrCaWux5e/haVa58CA+QtaHgajVRkRiw7s+aONoFwf2pODreyT6QnnaBiBJH1xSO2n3LpiGlcFMdPhkW2BaVTZtw1aWq4ZMYRl3GQ8bqlEBzpucmHmIMgwZcpwRtNwtSUWFIYZxAcCsbRXfGlmps3iDKFAda3J8e4yhDxgxFdP+nEvxKWwGxb9LcIZpIN8K7zLNepixGxztP2erBVPQihhBt+I/alDxa1YTHXw9HU4sVlXX4kzzl+tCpbfqhN6UrMI1rOksUL2IkNppQI7k5BNkkOs6vHj3dn+hV646lEdEFbroBIM8Ema3S11BE+gf1w25vvo/Pd3TMfIIiEmgeoio93BwARWJhAw2PbQXFDvg5WJGgz8d+mHTEaVmJ53pR4ROBSWBtsxueBKct1z3j/vGET83CtltVzikxuHXN3KNXXMFH/4xAq28VtDWnq9C7GPKY/QD5dC2FXiyWX0isHTSdRJsjuABOCx95fwrKy5RTiXIzcB+jM4nMmH3b1OdnAktzkl6bn4JgN+keZtTo/7SrHtrlo2uehMHMHEO6DKJAMMVSfRvnQzpZFkG7NrJmAD6QA6MzlyHpwdVyv3giAEYYXr+kR5o3Yk/wo+321Ht+w4RAJeLyF3m6COaEKNo55TXA6TY3ZJAOTv3t7WJjlrPl1koW3++mkDqhjVjBkw0jjF8NHiSSRBoihnbIyFIT4wi5+qP2m7ZwG8E80vuJbRrXgloUtNT0gD4gMpN+iHe1bIMilKfY/iD8zSPf3V76EzZyD4Kdjw4rv5wTAWWiCtvaE0L5pMqMJgoVdIHgxHeO+Z257m7qcn+O/w2xyJGBLRtu/N4VoVBhhYpZApyAza3dG4/hP5wDb2p8AgRMB/0aFlAOmy6NvzFck/ZlTR42U3U/E3cp8v5uGUkWXt+8uFbAibhbWuLd376nFdwPS2zTQf/LBEDg8U0ZuGXx6ouF7x/A26qy73opLR81nMBnJ1+ripsfMrlHcmtCrnk53jpa2CVyHbUBX0+zUGCtq42pt/BZFoxe+cGumKlML61mIj24Ai76gef7HsCEx1VNCwTlbNFPTtB7pBtISQNhlhMP0zsxRjjSCvS9mcqyZXRR/hzruHHCZ4NrLGVn96k+pt4ejh7jXIEIJ1LYdNDFx9CRX7teIP4cBrz/nwH7qOTd4LBtMSqNb9BM/O8Gxg1iiNB8UNTi+QIpWC5WRvjQ/u33BbEqQz1xHFLs3hYV16HAHRO98YFwQZsziR6p/F5GiJIJGNwJVqUZmjr30eYZf4uFRZaIY379cJsDTDNS5+1JmOTdYv6wAcl12QS18FeIO/nMzJTHI2qZYTjRecQBloAFa2WpwFpJkZtGgTPKtCmyH0pbEZGGp40dzpC7MKDY8e6s+eiVszbuGCVF++31dZuZL+tS29OMOk8YYD6FRXnnUDjjRWDp+7kVd7GY9PZrhNho/SvI9qYZdNjNxj3j5zKQ8vpacIlqy4Qy5VOG8ZdWnxNJYbKevQj9P52ntp59GdAHdVVy3MS9bHh7BQIFXSFCLLnJLFGP2TEqX82XN14C6bY4jihlXFnmKgdGknsUrX+o/9PF3CNVxQYGaRSQw3U8okIUsV4TMBMMokmoCPsGd1/s8pYZQseYrUYeE45a4rDyO/lOw7dxQQGEiyBZxCfxlYB7RL2wg4lRMRozSg7Tuc854ivcO55V5dxlHuzcXXRwFqFLM3cQsTk8K/TCJa0mgKRNAWcMrXPGvpNus/kWlotKriIrGKFXMGve71hRKIowpWW/hI5w/s+uDRVRB/K6FKIWiP5J3Rv2YOzVofYX8b+hsRKOwWAEaEBVb8eV+VfgQ6iVjkplqUjqnNfTkkEkTKwlri8jH4ChPnVYZ8nzgB+vN728+N97aNpOYLwmNBM6aIebyPV+gacSWdBZfQnjnJ8UmNTQ040eaxx5UxJvr6zxDN8XE5Z274cKyNsH2TekDAsr6Tx9gRES/S3fq07xvHsgc9EJfb4rZrb2AkekaQ1gsGR0mEICBKHMBx47aMpcErmDH52GdOJ60WfD9F/VQAGh3BkqbnDxjPJd4DViRfwAwtxCMEVNVwC5Qno94pTC5bkQi11wf3z6cxukV5YMdDD9W6EplIK5t6HPlGQxHceey+7eTzdfcgypjfs2Mp8Jbruq5NO1qoouklshhoygD9C4Tvkvj2u80VTF5zR56+fUnxphadJgn9x3jKTh/zIWEoBtokVp0ShD8Iy3ITN3/UFsUduwibfrDYU+sxWLmlmOuk1XtjBs+6dP3imgjVjC6mreMd8nnbdXoRSyzGAHZ1t+b4kvnD7/T6c7YX6ETCi8DzHqfREDonB1kD/nN8vZuaAcGe8BOh8Ufg5ntVpJFTxopXoJkZzoVk1FIFN+td0Cvn7aTydhQQsIwvzbt0nBpj/hNgfddFo8wGkw9kCcalI4gJp7MbwfAVwXGEZ0JTUY12UXKnpwXE1HfvltVcHH20REPdH1Tp/VBj7FBtqeY9gVQzwEPpkJQCrn5MhOAV+Ve7Zdot0SnBO//Kodf0vtV9MtZK6dkULHFhVo2rqOch6ypUFz4U1kqL8HAceNlsr5YUw1QtKJzLbRyhoqldZhIXi2kdP1nPtfU9JpWWAR1iCZqr/gC0SaI/+PBZlcafazChUh0AReVaomnQPnzuUDON5dSTjgGSxDK4JiSMBjUe4qxBOMoXNlsDE23mWueq/XsWv+yuCeiSPLXct2cRRuiROqi+RJ5TM+P4hPdyNq8jYlk07xncRfuhm4Hx8rS9f26eNJEotQd414aSGRxiy5VmSVGaO1SCfMAni4r8pXlBihgRmjb35PxV07Vb6ZHX4PvV4HorGqrkbLPTlTJXQDa1mBBPxmHcU4qUBsnsj94EapEGVac5N5Zrcq7qKTkBqx7t+MZm+Ze10x/K6wTK6yG8O8s06uhOmEo77HhFng0ThB+p3iGhI0QcdSuVmVJXoO8ucpOk72AfMrN9sQljxzHAeUgX0GXjOBIj6ArEmwRG64Jrm3/1F1aiUHlBfgiB+uMnFcABFMvTuUofmm8A0Daa0bX1WDZo0sAShwxNszqkRFal9IIaNbpVP6BjXiPSRBFeOo6tLr16rRjZ/COeLjew6q61W6ou2h5l1Llvx8Og10Yz9clcVzOH6THxtp7KYM5EAZkwUXVVep5PxXLjWv3tTWT2X5gfG3n/61pKYqvMk3M/5PtXYYaRpgPlF9stzEKW5gZcdlDsKBXVeOjU8K9FuV8iS+o+uHDaD7HaAfhR1rMe7I9IvvN2XcwrcY0SG/nJUt/5vT2hcljMMe7ByXevpTIbMMSCuqwS5iCW0XkT5hun9Mm/bBORoedjClaEDBTM0m+sPPM/pE/vPTA5O5ZNcDcW21Y6GirMVx4+lzMqEWgJWHeM1/7f023rAyfgoVvJIQoLmVpOaZ2r49KkqpU6lgWMD1xZ+qs0SUnRBxnuXrBPfNNTRJCk0LvXJLyAe/qDEn/TmDNJ04pExPoaBTJaoK9BLfGmbjG322Ny4whgUUyMZerF/U/AScl1fYVvZBdjflGTBhTvEuN0IqGfC+DYDXff9/UD2t3UMBmHliIK6xAdZ0kfZFMeU9ixCBZqbe7heIRBz45B/VCtWp4D986JOiBwJe1Gpft3gSxko5Y7USNcZW0F4fH1Shy/EDb3kjff5Wke9Lx4r6Oczn713fatPcc7CjDFW4P6pdGH31SF/6SD84rtku9HW/LrdMpgzPPP/H47P0o+5LMxGMdMGkcfV4ro+GGgLb8xmvgurQv18Kls/Vc1w+aE7N4iOlJSTgGKGD5BdOVtQjJTx+1zFBiqv/2n9VWeZh/cs9RfAwU17NlbS7DRjH89WuA4vwGcT1Xou/jmjZHHswq3UjtAn7n+VL4YJATBIg0BqseozGdk+BK+RnhWdictZfAlTWFsQaqti19eauoNk7oGqSZWbs/GRAb6rSnopKo3vt+plPWAfvfnB/C/TGLNtO7fTmNxb/JMTFoBnlYhaL7xkc/M362+XfXgs2Rf50LCSHxfhes9ov4YjVebmowsiDCgUnbZTgdVoTOw8cmOn8ZRwDXj8miQz3oi0SiYRIicK1pdLlisVeQI7IGsxbDkypIy2ElBTdZfe1JKCiSEAPw76FZbRSknv7S8/r1ahnmcMEkB/iyxqQ0wnJVmlADvgEevt5Y0st8JDRxSPjMkB2ohD/k9hgE2JPFNYJ98mHBvdRYXNJXO0SWlt3UZTyqVHq9igKFj6nIHAWrEPwx4sTRsnAWcJhNp1SH88HDPIjUbRqm71PHFjIcMO30ooJgqD1uglRIL+zrhuvFKaOUJzgZQtEpFkfBC0ZA5BfUrmqaqNTQN4PqbiQ75HqqxtBDyF1BvBFqgEMqdIPKI6huGx2Iarsag5Grnt7DFomKztcyj3GbxvCeLiGS8ltXeziLecUQ7tGqU8I0PTwI3vjx30Fi0GyTYm3Iy6hUEQB5n7ZZYpv1elKP+zbzaLyCFU1pbmiE4bkq/+2puCwdnA0HZ7JcZHYUVzKtvr1YjhkelPVryvW4PH4jzyS4ZU/aAfCYbdphfENch1XEpZEWfY5WUHlJebYkhPu2iQCfFzF0zntWoc+Lug3ZFKn9Vunp0OYlu2Vf/hx4DUgehPFMzgkOgXZAtbOdmfx1AvsiBIe+eV5U4JO1Gm+PmNSfiVPQ1I4W/9kxPaUeHnAyBJSgMnLWRsluM5fCKRomdHNmnBumjkw2MmlAdxV+/MccXd8JPkLrII42rj9MxHh44TZ292bbpBW6Z1ExzeUWttlXg7IHgCdSa13tbX+jkVXQaXOPmy2XlupI6l36Ls0z14FS4bE2UQgbTZJtsoTeUHrDeF20Uu4HmEKBehlfwuNVseYmMaE7uHtBTNF0amnPA90ErtQr1ILSJeMuKIkmRGq7SyFgkWAQkQ58BoYg6TqpOVSMOTw7hM0CZ8d4L88Tuh4qjWHtADIQdVeyag8Lz2riN8jw+OSM8ob35Vj11lIfieRScFfmfIIhfhm6fW6G61LqWsIaJdfZQ8/oD3Tspauo7Dn9A+sB/CgmUEYChg71OpWP3JFoNQFMS7Do/6Y6EjNLv72Gb10ZVaujbmnr+fkztSoInsxsDXe32I0t/pKq1oCXhAwXnQIkwLTfimfYDWENijpZhl2d35UQJyDaxcJfF5iMciw0IN9BKp34TSxODiZvBau1jrs0TDnyfu+Zjuo5y2lcFXCrEy6YTBBsncEcElswGsdFttoW8iAQS2hcT5sVS+/KQRUwQ4KPYrFuHrCJTNfzL7t0Dgr/usJ+7Zur3cnUaPYZX2qGtb2X/SCylOPo4nqJD49Zfj4RaRFWRKH9t9Nsu1k7sMXFfDBRY5H3CLSz/nenLf87N8bijM7u1I74yP7stwGt+3WzSU5CYnQSeoUOVCJe2h5MGIp+wt2z5ofHZNeuf4Uz/3OXvmOnF5t7e/ZbLDWqBkMEoLFZe0IQiNNYV88mw9ACYGbYDBYLUHQixW9F8OJH5G/4A0/0w6XV9rjHaaql9ufxE/7MVWDM3bJ67tXo61cKrppXnBitZfBJxixGh1wud3JNz9fUOLLysPbO0E+dxlprZ4zot5aAzlxFeFfi4m5SMieXnpfYzzlHp5JpPbejji/Nh7GWZDumSaZckiwc5015yk/z8pjRSUiiPYc0ierepNqEOuVKNJ8O75dQ+KgufPtN5gMqMEDVLUFEvfU+fcFNch3YnLeV3S8CPWsduyp6w20p/Cz8VT0PDkEcYok/oUOY1JlmYQnj+pgirZcJ3wSX2NYOWE2ZMrdq1NN0h0flSiF/qH218Ue6PU0hC89UeUklNNWZgkYZOUen9oB94VsJgRlaTPcCQZjl04lvGuLYAiKKWSVXTCPKDyaG0EqqKoecKH2y+r+0x255YkSf+9EZC/RxFrYsf3yLFzANBeN9nc+JWOxXhsKTaoAWTbT7zgsV/nkAR9r5oh5KRBfOkUJCQbxfQdL4LTZhCKakmBi+IcqndR+mF1bN2wuJyKhoVxqpsEndNi2PXKXh3xZNeV0EF0cdWKTompdXFYfeidhk+U3CniHkXrY58DVnsEXdRDVEoCCiVUXAPJTVMq4TuCjzj1q2MgcuU+HBG5jpitdm3p7X2EHIWTlIc1m6o0+aetAIMr4dMBvjqLj7NWTtvQsBoXgirvj+Q9rlRIUmCpH1dhy+ewAft48XMuFGnHPDdrN69vsF7lYwX9PI7+vsFvQ3C9dYCPIbddmhVnJIi666+/XT6HOaXtMaTcAM0AZyD+hZXF4u+Fbm/scOUQYgmYR4LBgCNifcHDClZrDxsSDY8vIGGBBwp7Cq+GguFFMJBPyeWczpdnImyn5F8J0VwdAqjih9dB8CS8ZR4PePyQ5qX81S3c1Al6t89KvOHmHCHlHOwnPmnI0FBTt9nhnhCITj+bPkQ2fHPcK833RAZOAKjMHhYOqYTXsyiGBhBI7N9TRG4DZt4CJglmIPnnG5W5XF4+k21TwQ+O/S5Yeh7jxexguoEjd5I2dY85IEtSbPYjNsAcCIuNiwj8waHzT9P3pddzjbbktfKUPZKt7Mrodvlb1o0PLRxaaa3mTRk6n+sAPCgINKDKQFtZkDvLfcFYfgSfQeTuZMCLcUXkoC5icfzLtgGsPx4+bOhQS4Ax7AlZa28jOnIC8dtAOVs8JzTTXGqCylssMXMhy17fVVzpalvEweVsy6z1OTs6c192ymR6dJceDKiMtU85UCBWLSUmL4ZFbNjYWyBBESIRbB0s7rT/1oAG0yfyb5+K/34mIthtGZRwUDfDkxnzjmktL5kmtbvuOVExaXjqldSjCm/ZuiRCWO6P5nBT6B3jpleNFFaqEfuScARUCrWpjoLINSwj0IVQVloG9Vu/BcZFm5ni2xqMqWfEyqjtO9BBDP9eXRfAWtDMhUiEBc0jLSFYEuYEHXZVht04BhLnqLuTbBdFb3Y4Qf+e2IiHlbn/P89FSbhGH8Da8LUr7x7i9yoxt25k4U8iMzaMY7zOQdKZ5b8WEl1PeEoi7RRypkRxLvHy63edQqMWZfXVaO7WF4HGYmHijnnXjwain9B0Hn+zN8ouwV5pGMXisWV/JfYBIXItF1Dw74kJu6MxeIfkuDgroflVkpsELqt8Ayo9D3mHiQ1UtxgFNfRCC6hynN+ZMjp79/fy8NLMEF7xPD4y64HdgAwZ045ax1V8rptSUw7dktyRiZs4+yujtpLtTRe7dAsEnGHmDygMdNBAA7WTBcju7kVTGJwvgYUPzHz6mvY9BpIa8LsffmlF+k8jCEGTvg5oIW8pc4lk682PNeV6cvYQOAmICKbbF/djnTQ22zG6C7UDyK0YFilPU8W60bdXhjnCNd3VmkCA2LZOYZegJ5YuUcPKeOAskhEVRR1srCXGdgAZQFJ3IZl6pMaucpWcHrC1xXXQblFpDnewAnh7LAFcjY1VhglEMqOtCpufZ4q98TnMJ/0E7bxKaQSHADPgihF2onSrWVGlTjmYleTvEyvn3wByyHh4eZagrN6YQ6T9s1rDLyNZZM0J9CLshFLqwHRWcC09s76xAkzwjp7N8kbdR/pA1lSulilEB5yaJ9eAewM6sHPsOo/suBujDVNHKRxNaEfN3cG9S2BN86NDYIcuUFFSfcMNJzXDb8zeFcA2av1KodXRrKQ78yv4DQArHhPhgXdmh2VN0knrXGSvpRunWJBKFVeVC+sbY/m4YjuRaikSUc3gAObywQN3iZYImKB9oZfwV2fR6807WfFzIGRD9uQLYKksnOTpgAVm++CcfeYIsd2n/fNOTeO4tcxNLcoHLD+gSz3UlsYCLT0K8p4t3p8W0ZzuhEzMzgFoF3cYgu5EwM5KborC9c8biWQHsXXh4rR2GfOn3ewl3T3H4tqZzIAEzjEd3yY/e0simcCAZ8tedITYnONsXJPePnKJROtE/42VL4GNij8F+USgghw/qt6uHq6VRwUV5Jw998MgKtpWVxwkZA6+25Fw/hwTuZ2Vr1FdhLoUVD1A2huHJklZjKlV4bDwoOfk6MIwAYqKsqt8y3mU+SCSdMERiqfkEjVr8xGPG8ImGis2ijaEhe9Mt24B+8xcsaxSmn4yneU6VGr21qhf2Xy3iVRDjnKEWEtTZh1k+6EvBbCOOAkvrYR2A/IKLmDNl6aZnQ6U0oAW9NaHafwv5X6iss4vXsoWKuU78A6w09lJNMpx0Q+RGE8txLgZeMk7BN1vssM/x5X6E67SNOwt57moGu5gh/hziDvaq42VqCWIv7tFgpO2FjHC0wvy/euGm9mRpf9QBV76oNFA2KDDGklmoHPPJN0AGJuxIco0EUWZZiNzG+QZuvJNIA/mQtr9PjnmSWbA/8Akquvj5KPek5ZkjnHNb4tUQg/bPGSZdJ9wU8Tj44423KGQTXJNxTsaJEODy/8zAZA213AVS5rrx1V1GskEoEgquyquYBKK4vNV3uUiMLdqvcMUVzXrEziwvCH7Mxo18mqQaTSOl8DaZajIlQJDJcv6oOnZex/75h7cNZNGUcE3AVLsyrw6BhN9bZGJbM4xsQUwT7dA2bbE2SJ+y6XLG+3EoTh2FPGAju1OzW9DFZP1Odn/gHP+1SEfLcG6SgZcEJ8wv00HhyIKqI3vlaBptrww8WTPD00Jp92dS+qUGZ3LvHZdvR2qoqPLM1eMHlYwUilPkMiJeX2hrCvIQKoTpkx0BUSrdfDSFq8gaksV3Zk0LR3+J2Ri+YI6UmSL+xtJFnNChbaLsfm8vLSLSzus9sFnugLRIpSjsr29LofCRIo7Rynok7tpxJpvSOOn8PjtAr8n3lXHCa63AvnfXvCRor128G6xybHVYJQrdqKbAZ2eW1rQD7iyAJSqQdDlsbIX8dRy7YYw5APR5u+NJoDJazCJJIltlJSA25dgyfyzFQb43YtqGPGRmVscKagKSpdmOpQCO7u45afBl1c+7MwwYqMBZBNbYNS9U1kN4SVYc3X/opZv5eBLiOLlZOoXUqqYBm8j85OdhOQUOM3djF+rEhXynEOfRCVnq5HnmE1z/aCTaFEjxJ1pz1KjILYqnddBXH6tXU7ckE0CAkIDGkfXj2Akzc96AiMlWsq69+caa5Z8eHf92jEkiUkXYaFUrZdNt8iWyf6b0vv8dEAAVcEGS5IJ4Re4Od3NBIHhSpgIIxbi3NZiVpss1C3Hz0wVGMMx7cd8ZqoeYvha22QN9Lx9xWUWCg35yBzd7Yd+2CLCJ1r1N3DMGANHwicwn0aBu3rjKItHyP58zutvAQCD1gnZ0XaWh0zd/vTkOeaPd5uvAP0jGtLDRf3Il+4RtxUwERV+WMw18PAmL5irItGwg3OQUE0HTUUeujWapz3ApKvxIfsNj5Wl09WgYD6dFuIfulfhS6kC7W+OAwa8OrgciTvP8mj8RWiiJ0X1KWJEo9f+wEGlITO2IHBdcOTV+G0h65dwi7VfjNBWUFIIHmvNe3QLUSsbMM2Q2CAxL9cAsxlw8bxW35nlt+BeEa7ih79gUTctMt9aX/I4zarRar6NVvQjqN89ZGLLslUyofuvAZBlKe+5qT86/I+iQRYlahR9F/Y5J6TyWAOkmNY/M2nfINrRd+7uh/sLcauU52ufcuTBd+ZVXzIod8vGEI3ccoVHejbww3ZX4vi+fP+IpuWssJDFfUw02lqEnT/vgrAodVMopE06gC3I2PSGUSJHR3bmf+L8ncMynCZUbXfSFxiMGqvMHHTUBq6rHkNmu2BFHIT2N0bhkmimB3KXJWRIhCD7CBj62hGc91YAkPpemRM+RdgAS8CBQBWCx9n7xMTY0jo0lrHIdnoZDNQoScSEtAfWw7Hpo5FCNMnm5xDgDwiCK+ksJqmruZR6AEctxwYsWt4qtylgZy5HXzRyl4wx6cjKQlozYWbWH4xTrbW+1vmdDbwe3Dv+tIpt8B/siqgVxPGKbnRGzqGsaXRiBqQxMBR+ub3w/DEwWHq8u+nJm1MMW3o527td2dn3W2QmX3UNkb+Afyq2vXYY5P12XVWPmuUEHXPxqvwWaN4TcB32Scszl5ZPVg21IV8n4dkXdM90hAdW9fEQoM7N812HtdyH1A5ZSMUwrJdlkv/l1lz7JfVRDYoe8ljE+tDSO5CJrklPcB2WjSG4h5pIbhU4i3HyYRclGhlcgTb4rdLdsTBqV+yW5On1c2A8xtOjQQVL5W4BnouTkUq9b3BIG6SRe0wxJ7m11L5f37n1wqaIbgy3sJGCRIKLTwKMN3r6e/aFL+Vc4zQa8ojfScz/rlQsysaW81dN6G9OURzAJjo7uBri1qt3rDovTm5+meJd0FcSC9QMTDVYRJhjY0+6aU86roWblgsvqC8xykWKATuzIWeEPrrZUPfYMaBNF7Q6WbXOL4ozl2SOPaAOv9p7eD9KuvG9s3Kn7ZF0NxOnuYcjih/tc0bozdLk7rgeE9tBt12t7SVQiTkAcWNAdgQ0gfb1ShFW/g+JfmqFf9YkRcsObdr7NGX8Q6t04Bj2p3gKkjxS3emnTbEVjrQrCZEEwx2rJLAcBZK5eJa+FmWZ8Axc6fkfV3ybxFbywn9OpDDKNMsZoz6ZchdjmO38qqHegbWHL1+WKAHOvTd/ajq5OBpeo+8yKRUovQT//Z1LG/oatEc8LQ6m0NM1UtkHMl01C2g0g03xuzD/PgrAxYvx1q19dZAhF2hz51vlQa8O/U+Ds3vrYsTTaR32MXNNadgM07IJ/VFTMiag9iVcSC7LW/XHbeFn5vl4GK6D49DEf5m34qvmEFg3rSrjydQ7bOdMaqsndUyl+MerR0p7peNSipk+hd1Cgqqb8vDJ6/7Oi9WwvWWxpQoYup9cpegV/f5755tXodPsoMdbqeDuuNceJfAD1Xpe3GFGtDKvxt5SA6jYimHS14veNi2U/O7leH887gbN1lv3lgllKNmQ+iWApUc1HpLOnJwAYYyMasjFg5Co3iKa8IquumJl12BOC1ltzyPbbqCTqn6f9gXhZFG8Sn6MPJI7fiG2hVkYPU0eh7tyS3l89ckrcOq5pY6yzi9SBym6iJfLz/8E2Z5nlVj9WBPzp411ggvuiFJpiTYlobz+lkOg7fEzneTx0OHYH1nQz8kLGFAEjPLIyy+E7YGWg2xpD+WxDX81PGBHh+hG9Vwo/WK9NyvYgGvkcpMDb/WsYY0tFqGw/goHjzswXss5CUFQmvImdVscXcsLXR8/V1qQBQ0lc7CQQsEjWeP4q7/i4wRsJrU6fGYZvZowjnTPmQA4ukfCZB/FCDDp83VfJYXfObilz83CVRnBMC5D7f6Q2Bq6zlXJFaqpOJVJGXox5zmX7T0WMbcao778N8/zfp0AUJoQbTOAuCJJAg6w3GxJbkG+FUADxYGnWH9DnHdR8+mxmslAWp0FFFSvpYnBMZdZOK+uDDPGOOn0r/9fz00/zW/eeYIuBTsXXizA1uy0V4o89Tqk24KJ+XslNsljijfnTDdCoNyzd80xHsuaWfL1Wj+DhfWq5sz2hXyKJqddjimUHNjVcjVFJRwmRYC4QRBohfd1L8eMpUdXP59QRAIcPa9NY+gnPG9BUzGYmbaxGSSgK2/5EmmF5mM0X4IsKEFEwIMcZAVjsMz91miLLxpv2zcUCloyZS72bvF2CZD1xKSKvQX4udDKGu+YxmrmkcLg2aNvS/v7Lgp3tCCcMi5zuMudDaxNyPQ7QWSdttiPO6lQOUv3M34krLC0oY0Gkz+JAHGkzwpe5bHUPrrwiRW2pp9cKySnWgSTZdViz5HrraxvGLPY9JCWJEQKlbT9Bssh6NwY57XxjVqWPX4484uQ2127S2BV6oK4e6vpa3Mt87UZlFzPBCODNkEqpsKWrecDC1/XlOM5ON5VVLy9gq1w9SN0PjYWLjM04ffLx1kJYK9IwDSEbL3iGOtsiKdLxnZMGHdB96pCmR8whOfswXnfuxQi2YJ5Lo0xchXmd2YgNwea/dC1RyEXy0V0IdRLJYfT4vpnUnTlKL1+wmF/Au5iHY4537xotP2MqGFMY9KIiDpMSEFoZLzf321NG52Lu4hy4H92wpAShxprQrhSDl5/OTfPiNaoUVoa7ZfkZcyFiRdModJJ/N+Z6Orc6WUmZoo1CBZKT/X6ngdXgZraxfBbSISqBjjZVPfmRgUykhBObN5gihU4RLmj23Cn+PwE7vDpG5DTKYnmOOZaqDmI/tNPE3EDtAoze4/vgaTfYUxK1bsm5sCN0lh5cp04ODSCp5zbBbAoMUUfOl2Ww+9Zyt/idIpHQf7dR8i+ipejiwhtftUIMnfUlnRKY7yKjejtRYK6AoXcIs30TAttK3K+Q4jWvST1/SwadH3p3OX1TsBlbZgE529ojAaxlmcEa8H8YPeowNFooN+2Ie7C/XA/8mA+xuUiMeKUFH+JxVKpivy2eH+DrdwWtC/+1CBS1Hje1qFjVf6BNu59gNm+uTdBXKsx4mGH1oEqicgjdEMjgaGMZlFT/IrZVQSFsEIqhoCQSf/5v4etPGOPE5ZZEG7M/xa1bVoVSd/IFDPSP1Z5VVBg1N3a9DZS6GkWr/5dq5cnL/ueoMbvTC4QdXqKFLwW5i76CUsZl13GW/kgn25iVorFU2n8kdpDwqcPb3xoWoIrke9ltFShFcWG7cCtUxZ+yOYyd/zrd0DazpoUQuy+485gxn7FSbbHksdOCAkw2ATjoDwI7Lymymid/Zypb6MpF8tF1y5CAtKYwGsdS7h5CAfQSv0RLuKTAz20gsyfebSok1fcfjx8i3JNVIdLotAaTefkFypoKwQL0QC3bMozKyVRtdQF/vp9PiH2U22KDM0bIUY9rVJ0Segh1Wy+d4Hw/27yiClBAXsrBVhplTYdwJC+5fKEf340HjZixFxjlxD8OkAOv0RRLnwmGIqvD+Rjz2ZyXMlIQ5Vhmd1aqHWGFUemYw1gubTLDFimWHLZgpowGEkHgbBZ2HzaYXuoT0xgj/H30OmzgUUs8zdF7qCPT1w25RTGroBUKFiGjQIOgL5A7raTwBCYxo2sX2O4SJSOYWCmGTuoXrAtUCNK09+jJFJYbG/4ttJJZhnJ7UK/vgoNvSekLuD/azJIGZ4VB4voUDKENI9jDz5MmyIbtqp4myPiQ/bsmBBNidFRzJ68BTfeNs07BqxEhCcivog9acEJ2ryiPr3GADhve0W8f9sWLuKiujYVYeDpt25UdNRqCrZprE1nX7b4xIlWRP6oV/8dN0rctfS5ui1Z7vpbHcIEQ9n7Nq2uCLHaap/d0v5TeQjo1SOoSV/RbsJI4Sq9F/hjVr+BhNI5AZLunic0MAlQpcqVK61h7MfDrt6UX9qCefJQQwfIABBKB/edIp0glwyLpuYgr+33QHR7D93Kvp5DejVJudjz6H1emL3usYZYRFQYUeLD5/4LKIluhsCOHU6L28dKCpEWNesCWazac4x90jeBrVxjjqQDaSaSPmpy0tI9pAzvRhDGQ7Tw2ypHIwK6HAlDArCRceLLg69wYqG9nUsgQivWjKJp9onCzTJKICOcIq3UfMO2UbF2oN0XmcCuf0gaZyQ+L/eksf+qNTkW+1ji+4GWQEmP7s0P/OIM7JxcrBHNbPWMptvfNy7yYQpN67fxguXr/tLsh2EWo6yuPFTjZ8mRQ92MAspvR8CGeQ44AZdSuMCycnfUfpWIhnWJ2KWHDSW4bIQxk/ZSYW4uTk3rYrW8+7+NyhbRIx0EP7T4Y1AJKSwlxwWqfRrs3nEs0AeAjHqKpExftWmOMfhhjAc2Wf6SQ9zukvNhxKO2Jtkw3dFLuQob7b7xzmHRBjA/XEUeMd/uJ74qVRYB/moT5lQl1YVq2I7H0o7qa/XrHdS3Imyk7xmsxoBFBSi/ZEXxIX4Mgh3yMuR8FRFLWP//KgfPVW425wCHwrG49sdeSftaE8CJ7o2WwCGzyCnSdgJu6SP5BJqZJrvwxfo63G2epZG/VxwtsQKHgI1YPmbpTciJ+nbtjlUimS5J30ywzRxlNwPEmvWsMLUe8xN5LUhY16A5+UbotI8CHyEv0QAI+dNGvIUkSfNw1nlW2U/pnxRf9DYuwMabD7Ezrs7D2sfYWOV9VOMdtXjK/d2SP0Ot9hCvaMn70GPDFDRaViYNdC2VQA6Kd/vxL0q2yimMAXLF5kk4T6dnc1Qb+4PWEeZNRASstHP+QeNJ+EhLXU8I152pi81uSV2CHMz7QAmvoVXpnns5wF7LwSCd4PoGmBQkJjYXsgZReElXNa2i9pkZ1Yo/fRExvgM2dK9u3CN5sCKUWhlRlScMoWn8S9RMz8+lG2o2m4Kr8aXNyWSC1yc1aiCDexhFZPU8HQmxQvQH8CEVLAg3D8gTnqeHrPMQXlawpivCkSuRez/0CtRM8zLTrCuTKAWWfayTZtXJp4vw23Eb2KMQrzq2sBjLLeFGSweanj8U215B99hnP9Pb5U+MF63fZFffcBFmU/RfFw05jFAS7kkOOImfISNLboq5to6mQB/822RfaIWYQ3c6Pgvnlyjb3Sz7UpVMxHpQc5eGPSiLzC0XClZn/SgUQV8nUHxFMf8X1GE78BFLa1LVItUqscyGQPmCILNHIxtjLfjjUeFk6PcA0FaX3TYalAZ5NYW4uscsdTF5zpFDrEf5ETVx0IPh4co3NyV3C6xtOXvmXx8j393oxVvQh4UbwZ5jmHLrgHpe53Em/0Q5ODYhRTAbI7oQ+qY3gOq2y2Y3lbyOuN/7XhMJM9xOsP5jSyZGh9S3FypmkCCYzhiFcWUdPX2XWo4AZvGJJih/N3kG/pxmYV8rg/uRO4lD5AtNpLyE1LrXh5aAzqxFAuxRFkTgpzZo5mUYs1mHP7gXKBt/1Q/PaKSgPxFgznXYBf24WC6oZvGcTqKD/KBXgVwXTvTvJkHYJs4KYbPSr1EDC2RIucPme2DIRpFerCIq8xpu9qVkPHlCZmSXl4iQquqVQEFcrI4VuQ20mg7U01RAYNtdkpiU21jAPx9gEUnus+InCyHYQZt2Elk1ixrMpdKQciP10M8wpiOpYOdx7x0q6hvYAVZ+FkOr2WJnllH5iCMrYXCQJ+L5w8EkZdAtHx8Pw+JkGq0phGZTr9oqFDNfxP5wv3iXwZbyOrI840RvEMAfBVZiHmodwFhqVh3dWaX77g6pvvBGJBIZOkneY/60EaTp4n0kEGRNG7RuFkce7YEMv6fwaI5MEXsase61dGxgXkq4etWYiYyKWJwxrjQBuPF9Fk0M5CD0FtvqSmSeTs+5B0PfxedXwzTMmCsieND7vrd5rFvtqVOuqPdg7nk41YJfTu8k/K6/P0OIDFDrt7lPCrGgWBVYMf7A/0TzQJXEbr1sroO56OLrKw1oVLisnX18OLPTGpNkGr6fkmL+4szSaS6UhXLOkpQZiz+EEWcFgvopOVP2B5jmxg/wWnhXnv0aWLQSU+aj7OR91OrQHlhIZL3OEJEssT/GdXfWOS3YUreP2R3wzk5Z5+rcv1b3dvWZxPLTrknK6eCI6csLqwVMvOKyGr8DJzaGAKVe5vcVRNxyGsU8haTSq++BaN0Nen2Ku60UUlnx/2qsWtmEbQJAAJqT7SphjCCZUv86Acc99xC78WxBLFmYMASRhAObqFb50CiZKzJtmRtwOZYosHaU5cDumUR8eTn0hisNH3GdsQ+bGqhS9aLAhsRmJZ4GK8pDGcl9jRamUS+CkaGx9JqD6GVTpWhj4wibh0jJNu4eevh6vfC9qvdH9deJc9rq/ZPvIIFj0suINAVyRSwTb33ADq0plhTXtcRIM1FsGeWJRYXdi/r11C0Fgw6WNlegd94PoARGUZL0bgl6jxxXWiTizu0yBp6tFr/tqUvvJgR928ULDRIJlol9WlNcF1Z4wRl+3Zv0PeeGeJZWiL7iL2oBv5UiqoA0/ND3TAlWV4/jiEZ3Ys0hB605sb7kbrZu84oA/YHSsopEGdKNgXPe92Riq+yFqhrltlF48/q39JdzGhjh2BzKOmSB6EGUgnVcGb/Mr5oePIVZNxP9mAbvEPOJ0S5BNYTxv37KcM+6fG/KlL41trnazWAMDd3RuDJaGmrbrJWIKGEDVhiigGIagYesl6E3/jqfT1ezI1nGhjbhrwbzV0cEz8BaHnkSxCEc+KoZyZsfOPZ3sJ/gtpOQBV+V88QpZqOLPB9SdB+ypAlGMwonpP0J4W70TnIAtNNA9pVJY9N0vjghpLuBMuR98iraMi1LmVDrdZgq/uCqW2NhRydfK+AiWW8UbKzF/kPIFdEcmWN9uRck1TYt85K+qvsgXEE5g+MW43LrVAkz40F38iSHcD5JFISENGTc5Y6PKg3PjEHP85owNTb0TsMAX3krPpUCseE0wTMG+EEU7s86DXSmd3mBw4Xj46v1Ft56Uo0V8tGS5Qf+ETlKLYsy6wq3xmrQhgUabnM6+wf9V52gF9NYLgooR3MwwgOvKedM+bGdEgoKgoNjzmg9DDnqhnUQm9pAlzBKliJzC8Wma35ISiH6j4OFvdPYSLUpnoNMwjmw2n+Lah+Nzo55ucjtNLyqsA1SCmQIgpfNLJIakihKMbDfd5YuCPUQTJaWbGyFBykKsDbwvORYWzqC5Gw5shwzX89mvnV7kgDZ3j3ZSQFrdoe9kt+eQcW7sZcaP/8PIfzmyMF0zEerTijdPJJCNjKvMWkmPv3KPYGb7qqt4ft0D1jFBRHluhoCHo2Kk29btUslXv1ve0ZLsdu0wHib/5CWItdbkzrxzyv6VTggmqxpXkWl5vDVMHHTrGqQHPkySK3ubbwj+uzJwB/0Sx4IrtC392cv3ckDTCdtzzCnKWp8hFxo4dRP5fUYDQOvAdbMzvju8UtxBPIKIcqwWf758mGPXxYngEk6fxgiZ+GI4b32DOv7u+/mNfwv7WjqZnL+YORJlrhfPoTB0QYWHsrIteH/FE84VTmVjYiJFrNYjAyIiaaI2XVR8wvNCEejWVfCIB5ATYzwaowTRnQ4/W7BN8Fi4spWimoQNeDNTKO0bb1e48O+zNy1h9e4P96n3LaA74zL84hRbzrkzDgp3Cn/syaNF6s5Oj2eL5089DAiwPYVXGq1DpqVEV5/Mgc5Jxwn6T18+3Cz8XHBq0H2jGllhaHLiPF39MagAsTYXnIvxXho4ktwZ+RYhOyOdVFxOVgVhQcLVC1Y22PkhCM99ay90/CD6iVxO+QhoQarALQdfIfflsqUuus/FsUB4b2ZWxj0Av9rBW4qzKGPYDAmwlUo/XWqgwdxyipO7JbS2JpXPQpNIyc4wG9jXUAX46HfH+Ld0d3FEQAXRgXe9YkjDUhVrwYFFkQlYXqK9rKYnj2B9VhbTyGGy/mxyxdjQon7R0rvDih+NmIGNjPRsnHn8CvCepiqCgiRgVwceTnBL359ahReP5sS9O90LSP8p4Nnh8pJhVlXH+FNITQO7/lL99ZyM7TXNc6pd8lwpAq7vArOjkpebLBVld846Iy5MZsmO/TZ2ITZYWQZQs2YIEouwBpMTWc//vauh6qLPd1BZsuug3TlSyZmnv6m0lFH1Nb0Fc6gorWf+3uAzPuh4r2hsgjlSMnQ4nM68dalwAryf9KvMWVB19qngxP6Cz9feg+8dBPomdBW7osGiUJdRqPfX99ZwxnfH6VmfQdjOIYZdDs+CsBsAqrvXGNC3LR2OBaLI8iam9iA0VItCLTZjHVjgtHOFDW1bynShgOrNensGNjQbMwbzfzXQ8kA5qT0Ko7UFEE9jBSY8BHVS4pxusNrawneGINbF9x3rXvsNR+y/4zfUhAyposy1EM/pUKLhjlBqxx9cfB2ibGuUcEWjGn9bRKnfhMS7uIcA7paQcYTSims65uqMYDIhAG1GoAWlrLl4I5gO124BvIyNuQFX7LsTLzLFiorBI7IEWxXiIvZtzMl10m7SsUQcrVNwQ/hE9h2HDzNzHB/754uTJAJcm+X10Cz2TRSk2yYaqUPFVT00W2ljQkFQPcDyVcOE719vpy3h0HwICBdOIV/V5oGJp6Mx9xvcz1S3MNXvixtCrrGCJspVhvTBfouEwtUNRtPdyT8prNdWgrDsERPZBlAM9hlr5yB5Ycajy2FWeiQR2w3hzTHoM2n0KzVAOJf5XTNpwmnonhC7hKd6y/bPygOhEByv6iXCB16wgeGlbG6qbzwEAzUEFmW16xlb+x1qBL0/qzmmDRz0kVNW9/ZTeqbWB/YY3M9B3L/VpS9iEUtgboXDDjcVaISY3ZcEWjJmBxXjwR5I6FEa0pMwonM/O8sB8eWRiFWpZVviwvM4ZlNKQ2kZOEAYak8zJuLZFkqFiiGEF4/Qly1J1GLHOICn19kKN9RKRxxlv4lJA25xEZQcvi87UbFUwEaqoFf2uRJwPkUF7/AbywOp8dwKiVVznyqEhoOEtyXXLRktZeTj9kxcrKJ3tv3ZV5sXnYH/NOjJv1vsTNF3NQIocHlDyF+JCTxLvJoXfpeaXI+IPlCZDvCTEhq+lLRm/LTZTMWiMplXmsfBXzbT/Ms+6YjQR6hxvgkhmM0NTHuOLwgtDh9SvCH7JncGhPtgDPhM77MV00I8gnBpyfvUwtK57ESnEn55p6nXHRVuLG7/jCi7RV54pKQb0WSLBuVbJjwdjgdUCPfSZb0fHu+HpSaWuh2jrf9lXsqepeuaeKpI3j68TtL9WLKaLoYgf5sqF5MdIS9CBAIR8xBiFvfqF1xeA9grhf4F3zMfHjLFX1VWzV6AanbljOz88rZuBxhMkNH73PJIkarLaHx/yjcwN2P0EUqsV8xzZ2ptnqcU1K9Z15hAhu9AdD+JBXuPGptKgbqVofPrdmrixHELR+3CnwJC51rfLJxc5Wt2HQcGV7qf6pBo9fHqZir0KhPUEPpAGFSG4ngy10BQ31qozWWR3CBeGxy4g9GjRkiMWmI1rmyzktjDEhX3Wi2ILmuIs59coeoUzaXDoHp0btDsbZhJsj0d0+qFkjvmqA1DC1aEhGfWnUVpsWsVoOY/TCv4J/u9s/pqYdJIF4XAhEWp3dqxJ8RIIdrmeigfytIW8nq41NULZDUC7zImgAi4pz7vwMtgm73dASSlOJxRabjL6eR7J0DQZSiG0SFCHWc5Ul7EWiqafnLt9qtlsmxMUZoZ0UMHItFH4I2zsbvxRs41EoSFiRsYlM9nruUEo1RHtF/mFSi2LoMUGmxawv1VeyvR6anLtEjXlddf/flbMYWh4L0pMRZ7z+NE1EnezBn0w/0tKoTZJTUz/KxFoWkVHUrVCq4fHRkPhHacmUCIfp1OGBVd9qcVVkOaRn9D/8DO0qkqnME597KsVlp3mrOnQXgiCOHQpQ1Grz1Xsw+lcInlk1YWGimEoRU1l0YwIIvoFyoFcfmpnlrIAIT8tVzS/e4Cn7iQKj+VZO/1+Klfy3/vkvs9zMCIsetqZu4BS8ziAN/05yolpnrakGo+3M2Ly/LFYQAwlwk2MQIFdGJKVkTt1nkRJKdBxjfb36NzboPKMfKKUIZVW9vpiXrNg6eKGiJG9RwqPiWcVPtqVcgZrS1vNdVABYnJPOYtBebKSiWnNv7hMn1oS85giIsLwUgeFmORPyH4QVlBFXo4qDf1UlLn7Uhb4r4lpe1mC094P8y3BzC8rXraR0ACalT8KlvZJ8SvjXpUQbG+xirqtPOU0uacRmoFw5TEyLrBDtUCt4g7n4h8Q4Cz7e+Fy8a+aewBX5N/yLRLEXa7XeZB+l65TjyHrKhz4NcMcez3Clf+jBaf/Ssdt26F2+fwj9R1+/TvQxyFwaZ1Y/X2K5Ahfkv/9sEidl07aBO6G1v/VNGRLDB1eSu/9YnaNHWg5lo2jUhdikzK+IJGF3YcW/h/Iiq9Eo6QeRCHjHXDnk1HCgGV9UbMOgrlIk6YtdOzPgQ1r8wJrBDJcK1nGMe3X1pT+NM23x1XHq2+hpX7AzJYoPdGoU2igstOTkU98GiM8OA4yDwqpV7mxr9ygR85O7LvPTuZJyQ0a2vhpPKiphYp6pxQGH+RWkf6ny654OHKdpbDMlq46seWwHBFRkTzBky4ZBmaTLS6juGmuAY662hXux3ybg+V6MCGb1VBuor1QR/GmyxK0JTB/U01ZXe0D6PwwaRItlFzWqPbL4nuHLi+RwFDXM0NR02BmHtgSB5gH9PU1eao+JoTeEpIV3NRjWLxS4rK7cYQKW3x1+Tk37OV3J1BvRLSrSRm31Vor7FEzwiBih/Kkzb4jrR3u+Z1aDNHVqIKeNdNas520mWi3iRWhvFImLbspXlh5zTNYSeg0NsGROB5IMc7fMXmfRXRj3XmX0YWnt8HVggYmg8LNcZOwGqmRaZ3psYqyVumX8MO9pHzAh8NCh1T6YVCAMWsk08UdccG9sduclZGUpLerx+NwOq5xjmus316V7SSzEKKERXUl2qn+bsKIFXnmyWt8rcgxXKj80y/hRpjJnuH/B3NMFsITbcqdwlrAieePYLGsI+fRh9kCqsPGuS/HsRddANaVwaCDtTYql8vurl3qlQo6B3kQzaiKJPq++CDfuaAiF80pOgocCIDw+w8Czb2mhEvyU4QA7piaEBu7uJRM0sVA7EYaC0+GSkSYMTShjHrSOW0v0VRYmku3gGMpkPKFx8lfrlabNoK8KFFdiyQJklGC/lglAD68ndoA7UCqAkeV/ZJO1PgL5Kucii5NQ1xO32Bm0crg4z5Irc3w7+7yZqGSkXdDo9zWBBDL8XMvkNylky3xzObCMESQvXhGoSHKyFbzp7k6A00NuKiXA9wEVp9f+IwG+uvGEisxS6HWwAwlhWPgbLJlGat2YmeOflEqqHK1jlqHAty0z1cAOX6vkr3KhspuFnKT/2De0OQnQq4Lubkt5cjzNJanDkP6lt0gktG0HVr5+TPsCyxw4eHXGTOngYnjzW2+6B2uYuBkAGJeP9I1li6nDR0HoLCFaYui+Chh1586i24oP1f5eSdIXBLhdd5GetG8aqb16aU3qqrGiBvmj1tcV5bscVMFg3Yne2qi+Fz7rUOWuEnagSIffbeZgknJdjVISsFqdXlyhPJV0iYSTToKVVibtD053QWWj0vhXm8tN/PB3DboFo4gY9RpQnXLxuYP5y/WJT01QV8iKisnHxlT/CWq6Xcchw8lvNOsyKyovtIYIZkob1/Lxyh/pwdLsKQhUmZs1sEIxbE+4lZYYFktQ3ZUW191b67HgXrPjts5Px5rnTNmqmiTe7/M0803iaMlyYT1dxmHtK2h8QYmvJiPFt6jWZJpvKAzHu4EggQuO6PIB0a+L8Sns786aZhWZGuENKnyA+ACbjCMcdb7Qq4SMwflpt19bvIr5zz3xAXuMcGqTSrAX5Zxi6/HPOjtApLAcWU4D5sAFtAxX8TMWuaPzy5Xtl7Zf72bDLhU6zWJoZP9uJtyOQLufycIlUD3IOJYh5Kiit2aeqBkMvvbw3TlGrE7VNm8DHQhZ/M0dpQ1MERFbvRjTHCl5mxikzp69DELGlQMpR9Mgla0/ZhT6ilFGKiDVdcn8mVpByGJhGTq+HccJ1xa0AMow/QzDZgOltlDx3oAMSSAM7jIM0IKJffHnjL5DIdNDYVfAfumS3Dj6EgF3GIXQEMAcIjiECZ0z30l54EK4Qp63OtNOc23y7H/Oi1gr1WEwvYnd61+ogdOHI+jxhmyU/tF//oCKDufqjwFIfSyKvVEaRqPVin2x6eKUILREfeQ6fEljmk68/imHcEKv2ePVrZzdir0tU28H/ntu0EWBwrhSQRW+UAIDwYXKaOJ0qoKK016pjjkBFD83DqamCu8+F2Deo2ZL7D5kkOGtOXlCyxR1BetWUapq1GryC/NuKEfuMN7kC1CTpHxdnqEh+m2vFzV5HZ1NlGVuDe92sHUqN8vJyDm8IIB9cwOpNBKw39GvjgWZijUTw+WcwFNewZq8xdmQhDQ1jG6i93+SaDpUMPC7izdD34k3XZcJEDKRpRdfJEuGao5pZM/faTERMeAdqO2ym4Q6QZU1hI5tnUUIGp3ErJyRTzCJnaPADqfEIUXnwkyoN92O8DNtqx3WGpqO4dohgQRJrHiq8sPE31fxwSQkdBlcyZPKz+tBvMBPVBWK2mOV1A1P6gkI4PPH1ba1dfSLerQ2jsixRrS7zCl+MlzigT3GoXJs2PvWE0csh+TV3NSmIKccXCMGxDRd60AzJazJr6tP8sbzIgpTUIOhWGvJNpuASkaYJ9bFj0h2VBw3iAnrF0wZdq8WLTkgC13q3Y3TlXKRrKDSjA76sa7fU+oTytLbU86ji+rc+aacHQHEEwXfa+73u2gpe5ySNVEvoD9SlJpSdj58nIX9kgYagHf9kF8PKVPiLN4RvX88gTx1KViK0WgndVdwjmWJlPM9vweWkeI3eoAG5k1lU0R1WifbQq/tZlzxSG8FBsF5fFm8YYKfJ2SgajXcWLSQBHL/SmhVB/C5iwpO+TtNMLeAc0r9vgB5lEgGyLlann5Gt0y8CKtBctZ+widYaWP7Fy5frlBGH4sMEf1ltrkr22T1s2fI7wNBsFgPvCyP5x7Q0QbOT4vqtZEaFrovOkeUWGRrvLjL4QRDJa6dlRjaWHdLPP6qz7Lu7ypD8WLtE2N1hQa6VmuztWn7g12STCcEBZvczyIl83WEMx+Ik/ZJxKhqW6j+Dm/jCbdR1MtcAHfzve3aZ8+rxm0YY0P3Wh5cWyvmKjejWADaHgdlAtMFTwqSB707wlLHI4s7huVoBGPfyYzJCnh8F05nM7uJ9crMksHUDeEOpjZQlDRKtjoQ5OZIac7D/Ubbl7rDA/nO6t9xKRIOzpOzVbaXgEXbFV3Fkf8oaMXguKrtB7gXF61nemBQh85bhwPiz1qP5ZZg1phF8hWIXeaNHCB+R77cOQzdLrJbxPTu6vsNmrwllvLoV2ebL2tfXjR3pObMrKxpkqOC3hoQiDkcLRXdpkQn8fAz/JskoG7drPS5EEjoVIMe/aN0dl6zaCLEGzVwYKfk0hy29635+MG7giRxJWXofDRKcFkFOqky0XRogcjHVl10B1idRGy1sy789/3OydC55WyHYZF43GDJgvP5hbQV/mZdGjar5JrEIBd8UVutO0Lv0faMnuk5dqTJbv5Y1SOvTSgek7D0GVDVPAuOoIRb7gUxgUCmj6x2TtmQZCKV3uDr3DhtaVRuvFZvEuWR8BGieX1XJNaFV4vAs7cJwcHhcq6BfZ/nBAmfXFfUkDtndR6p7LIlFapXzO7HptrXkpH8DzVHGQXE/PVRvvUFGfpGp5scy2vhZ841u5j5wrY5zvGbiHPUBdudUCzbFcLqtKuofu+MZxWekw6/YTmK5/d0zOlJGh1mhFwBXBooaV6Iw53k8LkmyKmnBzyOmFxALXO1AGO8Brvnwd2+SGubhtJGhvtXmGH/+awDTA0iP2wv/XKEgLqClIOXbiV57Idmicvc3T1jMAGHsgaE00XKeL79YCvk+T1dv78AW/cJvj568Y9Vc1v6/Q7ICF2ra9Zfxsvj6R05/P6pL2ZrUbGrJzTJA3BpVvO1T9UcV2GW0f6cBMZNHLQwRxkXJXNQc9gfoyR6QAj67lgTSYNJ+7NDtR5Ow/ZmyxrAd6TYbSKUHkgAQIC+GneZCf3AOBsgBA03ZtTXRQLLz66HNKZ2vcX7SETyxxSjpmQnY+/eWtYHjCq+9eiG5FcSaemaOR8+wOo3NYBRTeAFU8uQgBY3qp3AH+T4SCZzWiCaZ5WDWhOxcjJMMyDymZZaYgNN9u9Pcg/K20i/nb7ZV9cXIrAQz6yMg7ic/W+oEYammtQDcV/YLjdx9qju8/HxEMJo3A7Z7MsmPkc651Nw1KkE5tCfHYHh2nTP/+4bE9BAiTJUuu91MF0PCCeYBxU/x0DOIBXXHLL4aLUfsHZtIwflYE3VMOUbf+kPXhwE2mkbCr2ssA0a8R7w0hDNSL4rSD9n0iJ0wZUijUf50a9R5sSUVr3w8NA8n596fsLqDYMbiYYwq2L3i6dX8CUDoTrEIFOkO5eFsEUUENf4GwK3BzqPHQSpYYm0LlxdKFqCY6QUK7xZ2QDD9b7Jl/kw/qNVauNq6EkGY9/PnwupTUBj5OOTgkCqrTcoUVndYkiM1S/AvhemfIou1pyy2dBDTSSie/x8IYjkb2hRHBULNoIfB1oRjb89dtuSu7sENBnDGyLiXnDkkI3tfBbVEdBJEWXvmv++80RWXHI7SQB33CbsRlGz1wh50p/HsnNumptLStWEXJJ9fD3+pl0jOPBdScciBbbMJr6IdnZDZDzKI33j6ZvZ/NX+eqpwTEVhMGp45b/vNzjUqJIvLvPqPdD/n8XimcjKQXViFvPhFFoLCHJZxxNi3nUQ7CM8M/WL0DwDwlT3ncg0LmHuYvF3e5uw3CSDoJmY14RyIwQI9/lUmWhy42uv0/QM7jbxi04H8Ch8l2Q61jvV8Lgb8ptzhs4zLBM5o7racCkdBrivprEJW9VJBGcVj+GUER5EcZQeJOJAyVW8TjQnZTM5OwEzjNc0Ne4dhu5GpAf6B3WlxXsK45y/eM2rD63AjmMGOZDbSu34FP74gFWG4vgYPGRwWcuORltq1dCiHLoFWiWxZffv3xargp1xJia1BfV60b31zu7dmS0DU/r6AffayKGvj8LiNExstBbnHMOGN30wTzOMfHhQmcBD28tTBYIQCP71HpEzcnvVP+mb82T549UhQRCnw3OSEAZmOCb6GbQTfXBLIaVL6TYg1ZpA7hFVpQST4r8CbblPlh2Z1qHxMjHID3RXVPAnaXD3nBbw5Z+1JuEmu8UPobHIWJTY3Tzkbkl33r8x+tJSPWc8arjG7wub2/H+2KOZtQEzNc9JgGAzcAx7L8ZizK6fsFN3bT0y9++jg8FNgWStkeH82poawR60yBG3gDSZSccUGVg86Woo01fXd/ydsk3eKJiEO1y1JhvmKmT1qSX2xov4i4QV09phRNSLQAt/W7/rlWBWLlOf6EBIYaPUI3/9EDjPyPYhkstQq7LxOlaJVRFaC87BhGpA5yBj6R79Cc30a4Dar4aoh6UFlCo9kdsEL3aDkEuPIfG093s32bJ3pRE6r+OlLPAIDGcT9+29JPd540yy2hb24QPjegUxVdMgLRvEwYDI1QN2ewC5KU4rlIKWGXPOFxJaURIegIA92EvW4AfVSLLS3Qp/AF4eFaeNLhhsj4sd05CMg8MN9EoSZLmmg4I2qRysOkiDW9epU72c4PP+ZczgiCzpvmyGIJ78opJej5RRJZhGkE/PtqCUTGuGIEbUQi68NONZWgtG7d6+3FU74TFXx45Bz+1IRnFSu8qp+++X9P/0EmyNLvZHK6fiPWW4baVtu51TeyV6J03oDdp7uQzAIQ1KUHO+ktjQKAZO9vHZXFcYVk7sqWtpolainPljjuz0eTRa8raD1gmAZXRglylUDMaytsWl5cYC33mL6rf5Pqm/t6ccT7Wcs6oAie2vrJy14SpSqkEPQaxN7DiCKTgnCdyfVkHKxEZ2ZxUjuLfxx07l7VfANqH9oXbvji4j1zifbmJfOCzDVcprl1ED0CSVsXkgefWmQRERoIpyf4+GLGaZZHGyLCyXZG28Dye6PhVvfJBX1amw0DGPjEByQBVnKldOcBObFD4IGnDRnV4RmeLLPjvy1UuCEYO16YAl8Z4efoPLizHQZeAj3uMumj9CshUehCUkfMoGcyLBgZur9wsH2nljYl7Gk7YfKD8F3mFYS+/BUwfkrsGudBziaUuxcJUl4r+jeW4RkB/IjCwz1GWfMkE9pabXQbt2gbGKDw1XBs7r7ZXjWJgoQhLLbgpuvRIVuuBBpPZve59YmambpfOyGixX6kUehkJmkC7qKs8n7WqAr2ApaBIYpxN1jMtdAMI1zpOGEuUK7O8lErZf7FHnsxoIp0m1poAO47LDSpokR7mrEoa824trRS6HflGXDPU0wkluS4y1EJ+7o71Q1+32Sq9vzYhGk8EF8OjRcxCWKjHkKvv7xhx2GELjRCNqoxS32b0LuTwkDDnKXs1ZKasnU4ZGwQWEcLvwkQpMivX6Rzlzwbbb1HnQO/UkOgGEe/7kBCbQmuYhW8MaskJpYln1qrWz4ssgvh0PqkuGrTFu61h/RGxtCyvvGUd9AOAnQOz5VvvNopba/eYf9nU8OxQ6TXwG2T5UU3gb4sSpCa0VOxEp4wC93sX6GqUPYtiI9vSbUzSsNJbmwbQtwX9KnwP1oowM1/9uCwBZm3tfiPWGaiWqq7s0OhuFWvKtiZeGTSKn0HfNW8Szlap7eFC226miy4AJjuvrmmtaqpRrKyUuTQuBXpfNOD4CwZWSuRPwYvNUT1WVkiH0YXoa3SynavbhM7z9llO0imz3GIIdZPycWRRUTfoB48mxE0fhdwR0kNmd6L8f3RYAdKUwpr/XPUWoqf/DnjWsw/cPESL71tsJDZGlb2OVIb3Y7eR7MewUgcLg+0KUdXF9vGJCYKWJwOvfiYA7j6k0/b+Kq12JELHkFmMDsvH9pku4rHscS+amU/QBTQ3THbDEZRbV0gDRe/frdCYkB+EERwJnC+8dQLzy/4KQV9gBOtVS+mr1OmZJjJ1nQkKTd0hahjxG2ZuBLJjqi1jrLpzQBZdfE9A/hRGKuDOlJAVj+hLgWs/fY/Ne0/SjUYezIqs/AIVmR0XClKepM4LOPpc1W5y2vRuuWe2GHsgmj+AYhHrBNpDhKC6Rhvzc0V9c7FVYL2zBtZ2MxFQbd8wBKTzMzsvIsz8AkTVIbDOxdwXzEhqtLQFuunxi3KS6HwbKh5U6pEySAfq50ooj7A2K5t0chl8Y4sM+KEXo9nf14p3+UF0V3g8sq55GoIApU98c3FeLEbPngP5KUWdGJ3odZ+Db/mQu92nEUQKcbGNoEIGrM29lLdW8OYAHyOL9G4gh1KdRUUr1fgpcTxLqqXXLzGnWFPLMgcMxhRckbATT2kQZu/bZ81edio7c69eu2ZTQzI6MwmTIwxSM3ClAx3h6d6DyjMwivC9GZxZXf41nhLCDQh7TGlJnU+mPJTLyoxyJu1ocLKoguIm2wkxGO60kVZ+c661+VW0I8pSxQiM4qLDWQUvJg4tHdT8nc0BOOklaYISeR93SohRwQ2qkyhZibWX3j1cpJtuJKiwJATWu9N2ODmK6TVrOnlyM5VOxtrINPNHwHbBHZQ0KsX34jPeg8MseZWEMLnaiv4difRmIK1WGJUq6FsiI3GdXwLQD5TiaThpdDohQOoIwXjaoQ8f0vCyY9ih8QIomiLXjJ+1+3N54qjNa2OMmNDgBLdCO9+7Jr7sP//04u++uTOBwZyAFTxMLSvBZd61SvDTJpncNhLOUJ8jAQD8j/OP6PzniFnbKNicxdIRuh+9140HhoNJcI2CADPPQthHwP2Mz2DFrPmelB7aanonUSQIglsOnk+Yfc08QIvkcbJAz2fZZULEe3qf6CxDTxggwpq/WtW6dwQ8zLE+X5vVV9qS0zD2oI5LoKxLcCJccghZQTkhtRx1mtke5RGlQ11ruQW0VLoyAbql1bun0htMvYY/6b1fTS733HMlyEebyO526lECgIioZ9LRdnFvXqwcnW5J/c8Y43m6FOiO9mpelB8+lXgCRhKTfOLzMdZCQo0t+n6L7mjivCzzQ+4mA6XGeI5LY5KOgKDFB5+kzA03SkstKlMWQHgqMYxHuJ1hFsLd2n0onzFveRboQA+o2paRHI87mu7mRdENGKoWHM02PwyUfqbezICnlQu/a9zGWJ2BiZ2htNZ/2c++5a7hFQhdHI4IR772GisJTUl7ugN9RtPVlg4w6rgrGI+OHTwA6SZU/WaVA0GcDFJny9f3efNk3GFeoSJllXG1OvBfCCQ8HAPRMBoXx4UXQP2OfOkqxTOrkcU8xbaWMYhdUZNYzQNM1Mmsx2gXl5PoTQZIGVsADRlkaZXIfai2acKrVqn2EQYCmjTy1s1m4JP00lVGDc5RuUuqLEuO+y5edfKOGq1mJOBWiexoQaS9ptsxGnIPx51Gognyg/vpTBjBBxtheyD3lw0hClzeNM7xlyOb1j8pMZDh67n8l5GuaSV2y0Az3P5NRTwWrqA7WsZwerDLS8oTxYeBJIecry9b/99FAztjxiflynSHuxr9KVRwLYPjUeA2MCafBYRHPZor9/KvHi3MZrCxR3mhu2T52AvFMXVwgQ7kMt6OoQp85L9z2DZArf4zTq0dHrYxVHCDh8XRUgEmeY9aOrArS1ZKZgC6EZz2rECnIOGNNScaRd7EMs2EoZrln5hEb2Zy8+haqx1NsZ4bjBpB9oEwuBs+avfef/ERyHgZo2nvO1jlrnAgyhHxWNCtq93o1eW7J5cCIWv1ygSJTmxIOhfqOlFAN2pcFbtNESNhpkRVhbFWlRaBkv+OUi1xqlNPj4aCj2PJllg62yaX2x4j77FDHl3vvRVdCKyjsnk+rWCFLOPiUHoG4sIrJIdL4qb6l79ZHCuWZF1To5+qftxK7WKjmUh/My0uJk6W9DDtF4cgOex2XI2JQppaepVkJVfT/IW5uITxh3ZLMo/BoQY0+qBWLKYPoD7gdDbIfcwlvWqrDti48Xzfe7M9dzQT00/j5KnAYJAzlQ6WlN3ActlRbs00E7X7H2Rl6e9fyGlHV/jbJzlXIyosXAKK0BA/1iffNzlRX9ZKG9Mdno9/MwFelDzFW6TVDlOu67Zqwlb3K/xFiRP+ZppcTUVZje+8noeBGLcMBfzYLyJCfFuRRxfqwb++WNiWx6j8BlbGEC5WojcueyzzdNKqlUIuQQ3TwSU2jbhbfcU+ZFqN+lgHwq82pnOdjg57CLkCaDTY51MyrGNa+bhL/RuhK5njl/EhqoMFNjb74Xfl2zsAEea5KoAJdQ6SNNmn8asA2mGEHWnBHtTqMfxWLmBHAOIVK8OvY2AC41PhUWUyzC+2knbOjue2+c+5QtK2k7ToN3cy7Moqe461pg7UPHJiDFfSKa4MbP2EYV3DB/OYBPZnbetQdYRY4hF/jlCt/TxKKV+i27vGVIIIVG7ybNuRVQ2tdVp1gL8gwSUFNmdIe6dWQjdpF3naejHqfHbVbsXGrNYqpRdjGB6y0eM+oDsCQWfS20PHC58cw7iYP+XSTDZk1f/kb0a9mD4NX5yj9wvwQEaNzsfM3pk663bGkoxDxy1iL28efMlFxiKFxLFJ/Fze5oDGJ3lrdfKRajBOQWHl/0E1OxZBif0S2OwTpQlnzeCz+Nns0i/5SH9rljblhxLfqsMj9uS0U0ZAG783EecC5/petoEl5ASdfmQMIbRtQIbQ0GPbeQjL3nCKMxHk56ljjsAFcvmS73kh0Dkc6PI6uS3RixZqvMYAudBQA1omdz7oHCl0OCgjBW99qAA3HfA/L5GjLh9M8S0VkUxoQcExH+VjyBpawkYSmGKvPJ1MPRbuPJ3TMyPtAWWDTQZcleiAqDIxQRosjjJXIoSmYZSIb1fNKaoZZ2NElSoYYWt8xpdy0VndIyEWDqriy4eEDn/GZhE474RhyCCzNhF25AjinUHormAzDUK3ucdB4pRcURQPiOQq212vj6PAdQ4uHss7riCpggzzB4M/Wf/E+YX8je/UWbBFVW1Otd93fbI1pyogWl9Z9iranSgJ2ROc2q67yyV3DVIePgmPA9Pvy6pPiB6oPuvrVkZhhhJHcqQ574oXSdDNn+kF87364rJuOlL/152wO9fOWGMgmalWZdxGClUd0dwz6Fg0Z4lys5ughzwMQr3oGJiKiZ2BYVeGPZ+JCWFfzHw29Zsfyh5sjPOT30WfW/x2aXbmhVCQtEzU8oF15EmqsP+Uhd0nsainjAkbqKnW6qzidyvDUeG2OHYnNLQ0ovLLm73W4xXrhycsCWPmrhmBMNlPUs9m89yVsnQQlV5/eeoWCgFLzZL3PEYtmEVokraG0WBWu7jmzySmAaEWl0NJ1fGEISLGrZpPoimQSe0eISnM2F8VQ8rJALDZta1ix4mXn4SNI2pvS7orPlZBtnMsa3/UEeoBN/m9+cJCL92P8Tl1hNiZKlO0m7noG+a7DtImtfhrROONwufvFTKWLd/UhTj54xHvvLdNIkP+bCSQnSSDNOhGhqDTuuBaFluzJrTW0OCDmlhMefs/EA0dgY+KIqAMaUCludDoJAxh2QlC+fi/qF1P8JI7d7Rmkud3Bsex4u1DHE2NhivL81e0l24Akunh1joD99Bjt+JMsAn2T2vgoIHsk5XO2ehaVTOTvy5iDktti63KeAM7FIs4Hrc2KhbgHiH6KKkR7ZV2rCrJXUBST8qqAXFMGAYUiT8kr8VWQw1SD6FIaD0/XGrliFy7NWrKpeU/CMyz1e6JpAubhDmiZDBEhFgH+IwYNWxhaIuvNsP6pCqR3uLbGrK7Jhk679W5QCcOGbVohPVFCXTn36GjOEnGafpqvSX4o2WNIS01oDOvuQfmrqOYCzGXCKOPJyJ1YJP4jlzq6MbMchKokS9UyRkjOEYB/X3QoZ/J6+tezjbHJW979H9lhZzcIoY8v0YDTFKmPA5rslctb062FR4Pq3/w2XgA1yiY24zvIJAR8HcV1fZw59ZQcafPkU6eNAEPl/IcybMnAjUNRsbZklLOpXDHlMicvHfwjBCGn0xst0/ZdpsiHS3pBZ9kImnMlVsBcQtJ6Z4NN1+CufbGm9t/Qt6L3HfEnQNL6YjTCUJBO89PCChTKlsjgHCbbtTlx5QZSEvlHFyT4UFCe0ejY/wU/AQAeZOOUka5HXAS3FtJ9pGo5fsCopLyGLdrTmSavjb5Mvl9oWu+PO6WAtWQm5r50YsFsW5F9Hb8YJ3cXQEtTwdZo7GOdXY1VWsNp7LUCw01G/loroO1kp0gEP5v7Cgfm7PPcopUKlhag5LUDwvRqZCvcQ1MGQCxLQWUtp3wy0kmJKFjoGVoElIQPiiCR1ct05802lsZqAxvZ0sOWvPqxEzMiHCvbR8hKrzZkZknDLhwEDLmW4ia27uHmBry691EHLXS2w5k6CwIVfDP4zt5UFrGXhkILwF2YTeZ8Ea0g330Xku0GNuvCjGCuy1nXZQUtMttWceBibGDo1kqNbS3vQW08hz3GSACApl4AyoDjGpIYkXWclwwaoeRNwBip7Ul6c7IgwxJoEicOpIqj3hpdIquU2ZSLQEFbyTmUb6dKTZ/NkoncBnt4oAYu34wM6Y7LCHI2bY/SfnuHzeoYPFDwIWXgcH1jITCfg6x4CZhF1hzsVfN7jgaChTMDbalFtxk+ZIa7pfdCqhbw/lWsSdsPgbfMg63QYgjJk8sqCjBI+i3p46xEbjBXIy0OSmDZA3NUOFkZk1mDqdmhVSj2mV2rrZpk8JRIV2we0BpnhSOmv6BQjymBG6Bu3ynWldwQaGa3EL4dsaGsAGGaYz69PbDgP/6bdZScz48jyIqwY/0r87iiuuaRZCCx+IQaxB6Ab0rh7Fj2mHSEV2cLSoa6tHwtKXW0tr3v5PASItEpeBWynEd5YFIsAPy82Zf3vKSKp0Bqd9i6qLHjZYu/7y3bRMJu+N8r4yTPTpnSewyUs75f0qYn9lEpYl/XHUjhhxH2ycrksZkDlCBmGEkPLAT8YF1wzUlliCID/YrRHdNBpVZ9434tMfRLLZb5uZ1NdHM1YDfjcZvWuFI3AQ5BXPxh5qyml/6d9g5sP19DfgfHknJk5ut/UJT0CBU4/fAZRiwKJ7Onum4SyNm5cSBn/JAsNgDI25rSxCpmDTbK5s/7gEG2QTRwHca0vKBIXJmYedDSjApetmcxDL3KMH/e/9B6kBqClzKJXMKvcXkdCz2LAiDKGvjPjkjNsR6Sqe5lFRwTW1xUCAUTWPKsWX8gEGzENEZlgpz5xQLld5hoFoQ6mlZjxi+UDteLH/Tolw1Ou9NDXzQ/aF/04qFyUi7Im7VOcBGdJ3r2wtnMNnWf9vEojFDLJurNR8y5QH/IY+mtlhwsgpMtCBz+LoySrsr9lVN38OnQfhuiJY6soj9EYT7ugPVpaHKNmRSV3gC2bKN8iSAkPxvjpWXfxsFYIHqO6367My41P4V4afoU9/C8o8khxPBgBh97RnqeebN8ZI7cj4mVluXEbX4s92wRnCPr2d0j3qo7c5rlW+WiePODg79As3/gVuZfSalBfVMnjyhGbStHKfLUActGMg3yX4WjJZs+P0uWbHiIMSXDj/wlk22ye9upTGE2KpvtkSs+Redh9I292mrDAxV9TI1ERiwpjwKvD66vKVysuy3r5jeErxHOpokCPZ3lRHBkPcYKEN3KEK133Vfa0/dwhtCyeLfEcvlOX9MMTdcV7lcXlhch2zsJB6RM4ihP8tFwZ1Szjon6wmtPx+zM+Z4EHipHfLJMSgMJk5/BFKUebITHivA4aaeHBhFIYUcLdjFUGHlLxY1h2tjYZIXVIS+cYxl75vNtJgRYYlSairkdq3J+6dRYqT8+gNnhI74lozhR0SUPsr5VQhnVmFGJw6leZrZRbCZvl/d35fBpDdT6ymHlQpZFr6Dy9bvjYYb22soInkcYHgrbhLvV5LlAnkc5dYNMIPL1CiTcnKFNsFpI/Rc9OTwXmQiE3SrI3G+/qX0TxbS/Zo470nJ9gdDcjzpJ0vYQgppADbpNkrFWtXPX4JEAQTgnwTtDbQwsGNhDoiKrPpEUyabWseJshV512VzG3WpHR/LcyEGlSyo+jm/qvT0boFsCvtKm9oqGF9wZlU6w+kqcNJLR47lNxL/AyIV34u+qKB2ZxZVDTOMyR/hlgcqN2GNTRQLcujAt0JpWkaMZd35UCw0Jav1Zfi3W6rZcihlNLzs5Or/l0mDXAl4zeOxfBsFfhaz7P6tk6iFWm+TztqZFLOlnwYH1wsOFgDkZV9phk0wZnHN5aNeV4jaoAo+ySxabHvJoeoCtrbu/SbnkHYgonPH3MyYpxmRWYH/bXUzfV/Tu3A1s8fau3adl3mD+IqPd7b5vIoAZ4BywD/UF16C8cetojoc24344TJ52qVMerWFulEEMp5ijwA/RPwunk5hzKHIUEKI1g7Vvnk3CCGKhQiDjYXlRpv1CY8tDLFMcS2ospwfrsqYJe675+OsSa6O7kRCQRUW7NQSoak8Slv4//EAviJ06SJ2/+VJCvYtRzEOatHV32hUUyCC0X4UsDsR/y5k8x4+swKbNw3MypVE+OZjGtyER7WCia8nLj71kK1gD+dED2JegUnxodZJ1CbXvb7neVD/ir6XEJDSGgD/T9wB0f/BixOoZbg85WIgbrewpT2/ELIZuXSbKY5/0hH5xdzgTVT4alrs/Q+C2Rj91nEyhM3RlTnOCl0Ay0cPRl//b/XG+qYgdUhTe8VLcUoQkakzrC6cnIz2SjT5A/XxkFPpLuA6r+pFCNAHjHyvrdA81JMeQGCWKf0FEJ+3No4961sp9wUTTXGWDxcWW8HlYhybd8DCPgK/7nokoWiHqGPhFABi0EWWDLgcYt9LYwuyC8Sq/B/MOdPyv1UZjFwNVkFfL6gFwHEUTDq8UbAh03YG55gEVN1lIQwvppMZ+uYTXFYLRQGkIDl1OqVgKVxsxRMwqnYDimA+S0bvMGux4eOXoqIwzLzKKC3RIVfTHrKEIgXehuSc0p1APpeKdODjvT8PAEfQJXFB4am+1Y1tvpHUWoFPCVR/zbeGJpvU6i6JS+VoQGxRdljJqLoa8K09OvhI/L2PTTJRb5LDG3mfXlYPCPxkNsxMmyT95hW+FoJa5EuH3jHt1LTedr9RHpBjwFbuJBVG953+aAJunRA3nKQHnH+oFc281rW8Now308cqf+vL9DTVrH+XR6R9SlJ6A06CdMR8vyklYy5n5VcJykuUmdZQ0hbkBVMi7PR75C+/n+/aWaBR901Vipl+lXrN0H09uvad4l77jwGORda7ByXhMhF/x+yC5n455lJOuf5ACTDwo3hwEZW6hCd6ej5qN4YE75VVC7GKfwN9lBbBhPdcvN8ZztrOqxK7+s8+iR1jzy3m5GAJJeTYhyqXjUXf8sCBL/ddCMralDEbr7t6I13b7HJWGmIRekvubfKtnB3NfiTwodnW+qG1OH+pS+1xUJfNMIoJWttBC7rjnEN6rVT1J69BXlVlqxd++o6wuIX+GBjF6FgkrUMu4LY3VFdomK4bdZy9/dVpgVcKO1WKcTPxNmLUXbdGFTEyra5jdQEpBQFEiz2UDVPyfpaWCpqok088qEM8I+1mQizmbs1m7UF8XWtyUWt+XOsgBxNdBRt4UcK2DPyB6SWd5bbnZEMbawvA84lsYGmO01Av0OzRIP2dFrQylP9IgV7nyEXOxZFdxStIpr0tdglx8T95Nyv4DzhUc09mJs77C1nNIRkI4fTrzA1Nf8QNuUzWvg+zmHpVKNSW73P80kKQWZ1WeFsTGKzFq3z9LrFY6Qi/2h4HPGBt7+pfkhaUWnFRcm0Sqq1Z3Yw5yAk1iCE8pVV4koxQbbm1XdL4RLet32vrh1WokKQX8fiMyodETZkVyU+RhbV+Stq0WUQ60l54rjQG54DZqndrinQ0vWcx+U2sKpzGPSEC147wvA0mAhY3XxuYRgPt9YcYCySlpl38yNPhm+cfbYTjSCRAJpRGfi3CRhGDKiUv74qRByAOjOzsCOiNgELPLgQawoKBegTe4FbsU6uhDfPgt6TPBS71OEyoj2IRmBnKf566/Uy5KjjLU/y+0DYuuObuszJc2NLDetN4TDKtKYSZZ9E9kGtoJotP4f0MiqVIHcoK5rKps+QsOm366ZSlWRw7+f2RXB4+yhr0yoXCtm/Ps+tHBGjYd/B0rRYyypDP0k/e6HQxPm6XE6F+6yB3n03JVdXz0Ssc48jZi3mMC1Mew5iknAILFFbkggLdd/3b5yCR7smpTZyVHXJtUW9e1NcArNt1F4g9qS+sj2WpnXwRGmdOQZ511VY+eG9ytI4LB+8J9bHEfZCKougkIW42TCb5qSNMfPLuRnDKJoeQLI896I+PB1rca6Ah9HMaWy4xN5UIdz1OL1985sZ30JfyACDXIiod1k1yOl56onz/uWs7iQP49OjSRxhzBgWEDqrIUxALGBnPxspRFCNjQrDlnEPLPrwTwIUB8C+KUHWwRyl/SpNNPAy5e3Xl90MKv/n+yyuahSTbANMzLmsgAdOTmmHgLT3Gru7Q85AQIvOTbBc5PmaB9kVpf0xewystCQNwLZUyliMxrcD6ep9hxaY54wqdEHeKe555+viiNLUXsHSG2QpQKAUPK1c3lQL6MMSoyhGTUYD89euOqmcXxbQSf9rYpInexIrexhbkRSCsCwj8OrPSGSQxfWLcIHtabfOKeDiowCDxaUK5u8VWatXdq+jb1eOSxbZzUBh5RFW8y2mRlcA1Y0iHBJgxOX3t/bFcOiGn3DxnVTz/YkCaTD/rpXkX0EnjpLbCvfX3n4mEZZxEbIM+Uc7tQwvsPuNHB9JOnKmiRNMuVNDz388W3wHi3AjqNjpO3RHkr00N3Zq/k1vOyQjcva2KJ2RVioAGwOjMLHPFdwWSZpfEGsA/xyrogvgjABNwKDcVwu5HAIOl+lRPjEkIjDFvOemk33mQa6+Bkk1G/h5AXmXbURGgyrpyl8bzf069KSint9GbW8N0GmMeLYilNQ+xe+6+oGDkOKV04p6I8bnkg3onmDAJEwVn7Eyb9z3obOWKN5x1KnzEyYm1aO8VldevoDFSpZRei3JnoeooC0SA5PEpwjYr9StOpYDubm4QbZwJrRa8+BApYSbLJqLXiVPkfQc3KwvpkfQCy7l/WSPK7adNkjkrrUtPJperZ903BAGuW6H1xEMd63dzNVpDZCGUGMSngpiGORDTBNIDMLy6UQO5MC4Q5qKlHLzcSyiy8SKM9w3Z8Rw91UT+WRo7H4VBPYjpjSBmg7YF4S22xWV0rTxFGekKd272zaPD/KCGhwn48mY/DUExkNdQ7gkvMYeFljhXLkelUJcDYTzj8xXRXDVoeN0ED02fRNSAQwfGWT3GFoBWmeP7XXKn2RekN8fKP+Rif7nE1vUign4fCDCTYj9FhRCvfc5l5qsPg6SDlqe8PV0s8+/+KuyYqunn5bu/Jh/8XAvio4/VG1yxGjwKm6XrR/UVOM/9PR7EigqEwXdT6kDSYIPQ3mXlO/PdHd9BIzYRaVFV4YNv9/IISd5DhM6j1jUgi9j17rE2rbJYYncVsV7NqoSwweGI3kGkwkTN/FHndSwDb1l4C88yoUgu8uAXNKf1QZaV8bVJYUdxg1o9C4U3ybYwDS8+9rycbfYjY8AKtV6fQ2BG9q1byvbF/xcjKq3ZCNxy/HzeYbWPd8H9nFG245vr4nger7W8R2zcSHv2kS8jpH/+nAFslwE3tHgNb9NcIeZQU9Ss7KnOtFhfzTdYKCtX2Xl3SukXV6Nt/DO5VNGj5xw4b8fHuS9RQYC4t0M8K0bsx8CHPWy4WE8h+2Mbab0EO2H9u4liEfqQV0qNH44lUwSdA/socFoTMIZd6ajDPLM4qjSRQv/ksCM1WQ6+0lkZyHITfgMFfWmxiiDVox/dOkMv915YqDzlSrh5JwS7KyA/EVvvBC5QtZiFQbId7pa35qNTsBcS3RiWASzJpK502QWA5ZQIa2ylPie6dUw/9HRzntXsLCh9bUAMFVNXlcN60JOQj+BMsCoF6ZE1OYPVXM0DWm+koTVZj+2ppsjoXG4IpNDEFtAXIrZuHa4WspIaIDoTdx3hZbHZohM1xRFlJi3VWJ1xdF0oBSdp+x6PZpk+FLOU2oVCQxoKzjSFuvUe8zcnX9rxbYcF47OBvHrtGUkSPdSyfh3rDuO6Bk8d02sGir4Io0CjTtOEPitvmWzTH976gphgJK9bTOMkwmOIQGSHHvrGM5Ahm2sTreUMJ/OOLYJQzHak07qYf30FrKG7QZbIHXf4aXJi+RqhvpuzULAdg5AD5736tZbUxRfhAPC1F5jiWJ02UT5hD/I5Patx9k3nDG1D8P39pLIsZxJlFOciXZfrlY5JI/Rq7hieFNdN1KooM1JovPi+nlaPTZSqbX28t7uOxfl+1qJVEAEsjx7zANUd4Of3yjjfSgkLSqU2J7xXXsdNhIUaqZC2oXiX4kLpgKGu4eSkrgZZvJGgdxpEWje+h5Crq/0vjqcvkudoFR2zWFBeDzQ3NmTEeV/AlpYd3zCIuZQC9NAY9X2zI2fCS4cProcJOC6BS6fzEh5QyD1zfyEAsGvOBeNAYbsi8bVOltKrL3SQZ7/UD3vM2tbPGCxeLQNoYS44HQvTUn3ID3KUuNU9LFwTPc/H00ntR2Y26q8RwvPcLql/h+ikAoWTqShCU2wO4gGUqKG+B56r8FwW2ZNyIN4IWXVwgFK6bNd3qJc5PXy1My7dLwRTz2Vk3ejdy46vhoin6e6Pe/jx7GuyP7aY/3PyG8uKxYoWL0zFaQcvEWljAoyzz72KI32MzWX+yvdrZ/EWEznxxPfkLEtfIlMo6T/WKtdtu73CcBrcBXcXiw5e7l88vN9TAMIwCHkoKbyZj19huE95eDLYlHuurhJemrtkWn0iQd3+WCXK2OyHC9Xvye3W+5gtsEpcrwtB9fMe5pzfqLjPJ+42ar+pkOeBh32u8MEPzUVN4yvTmdbgkDgePk7kEGrdK5slryVFgtDEuHumGeNkajnTF7HsCDZM9clrldRRRRtzAvfIjdUhDKRfuHIfT2IFsXlqqdsewzJuhyrqhZUUHs6OOCgCycRxHj4d//eEwrpkYowCu1PH6cUCBSbKK05L50wM63h4z7g1aeRkV1zoXKMLzCBpyeUa+yKnuad6qU2IOTLnzZrs0SKNPDZA9sC2YRW8ixbRBbudutax+DLF7ZF3GcUtt1DDoUl2ewYSyla1OUmLeVpqesJja3uMr6K+yxtARGxBBiQw9L2ct82V6KZ/4uRmv+p47oiE+YtYi8maq/cpxYtFQCYFWgd2+oEOCwNYnEU4YPb4AsWY/cigOLK1KXEFFQLIN1wmU1DJd9ntwERVXdHpeVvt2t+awQbYDm+yjg3x785JOVsiR5K+0LoAueNLm/jFSdPfX8ASYHiLEg5yW4dYPAlFbWUlKXNaqlv+lMlknrtHIB3XtTXTmQXZKz+h4LynnXd8CYsBYZenCJOawruNbRZ1Iu6YHEdqqrljU2E/UhH9QiDRgER5KZzaRXm1pOYoEsgDOFjn7cGjsHAovC3wUSmK6f+lPe8qI0baYk3Yr5yZuv2qMtUNBv6S058wS9xiA2yqpRgcq1xq25xES5wfkq5lJWfFCzTZz/FZNlEiB4r7wF8Go5dW4EkXh6PHKlovRn4D+nj9LmylJMkpz67S63fZAkmvUVaymyr39uv3nAhUdNrOt/0miHjs4dEam7OWqgsbmKpLgpSiHU55NYo2gHDIW8sqtewivP12ujLn7DN3AS0BN5XZ/QS+Y0q1SQ0+jwL5I9zuVa9FcyOQUYrAKX7BDQkbv+vHtua+DK19q93CQ9DgXPqp5rMwAuXd4hl2t4QE8sZHjCLz29RDt6GbWG1oqfGWy1bghU35Zw+iLmxCWWty7Y9De+iJ1xjOp9CEw8lm2nmHAO20GzZb27sG29EDnWUrSiP+DtuSSFk0yGXPJOseMkfDY+QOEtipgJi1aP++ABaGtKrRYZNDgBQjHlSgj/vQYiGMqpGspc1NmoG1SmO7sqMLCCi9PjWWqWaw2TGkbV5diOIlBPxLdp2HI/syvoxVhrSJbiGSVlv0wlO5dHPzQc74KJecCS770/ODNDfYGtaewcYht9sXlb2NYWwPM44g3cmWvW82p6xCYoTxH1AOiAc4vuRaKqVAPJIqmfYhlOPBjfYoyuBTot65WBcL3yT5Yvh0khl7ToSh5D2k+m2nTwtxkHb3vMQNudUwmXrcpVM3zaOBgnZfjDl+v5ew3XvDp3dUy0xYROpUjAaxxrnU1K+SHmHg4JhWEgZGOs9uuo7eaSC1Cj6R0oDOfWy6CsY6Ts9zZYBT8RVbon3QSrpU/IS4aJdBbYrkUluxo5BHh78UxQBI5/ORYC9QLSaRnawMgbaAe6mmCZRGsDBh78b+Xhzho3FdJIiw+4qJsHLNWa2SDIci6M5x4ehDr1Vlm0dvEaTRUiWC1Fi35qoByZDakFAkCwQLPcEu6ItkaqCWSKXGp/DpfI15E3WK8aIb4K/7pgQCOe57TOi/RZBPK1iO8Q1A8jiWScdnSjEcHIwuhfGvTywCwXGAClgAQFWrSkUE6gzb380gfu+RHNuF2MN86bnk9ULiuO94U+WnHp0z4rWSPL6d5BEzBYHewG/f87pRSAm/nsQ/uWEzDHLg1yMrtWWdijLGO/qFNrBCEcknRyCQ+jFqyDBe+N6JMLqu/C4LPIKgYxxrJgT8yxcpjHySVlIB6gTUHL8MRFYySCkJLu+XnaXT0gi12O5mMOZ3R8nfQQkNZ1JGD4WstFqJgxZhWV2QZywbNSMH+hWBmTzoh8y4HplVAJUYR7dclHejMEf2YCIaP2DsJre8FiuBeRrbqffx/lZrdFoquDFomiKtrhspusS/CCcQlTKg7uxaupHTuHo9qKl0Be+E8QcAOrx+ivBRszhga7ukxBLK0YxWNUAcsCGXUfq+ue3awzCgt7VrkUMGkYlO88+b6B9svulebc/WKbBGLqZzAoXiC/62c4U7FaCROJNbYRalm8MH3Q4ObRVE++77i5zxcthZM0uEUtG1qYcWAknDbUH1g4tLbO46sV5mttJbDDa9eb4CHyof+eJhGSyI7Wa7NPUoTxcNTVcN6OJThVRHOL5DDcVe4hWt66h7xl62rFbX58Kipgtbx5Jz/5pCDjzoJU8thN7a5JR6d3QRrrzysGOW1MhGheoQ1c481u6Z155dAoAFkvhCTskp3xsrzZ4g7OI/Ezi7vZtKUgim8Sw+UFJTcDUfVuVveLsUvVjna1HN+nax6oBjrU66QKEvHqCJy9jb+xERmgxNPiZtSDF7TwW9WqwfPvyrAhWAbiLdRbk96i7lxsOgbLxaVWpuaTrMVYW3HYNuVFWu7UV0Jc9pyfrRLWQXwSdvAvaG4trpGEiOyiT/qo/yUDroOefbSjSKZumlsiE8mgk4y5rIeYkuwDGg0V/Ctk7xiM9ptpRhX4gmcs77zKLBQDoCFmG3m54FAzToP5yImTxFW6/PuLih10eD3YDpNYCbucTikE8PinjwqXLjDVplBlZi8mI1DbQ7GQ/L0Vk702Dhwlclb4Me/pQJf7RNcQBvwaK8igmi4O1IWQqDIvixjoUVYJvnHY3RRxnjov28OQ4z6gIFgpkHIBg23FMcBo4PH4TGQvwkvQCW/4I0KF8xTA+drPOaYrvi2hjAvyfWtRoyOv9KJZ6VthTrsf66qjwF53XbPNZEzmVuUnoyg3BssBjI0LKSNEVGBoXEK01RZHKbm7/SL8UPDK6c3uC9H9WbH4y/dPgqTUWaxQEKevtn1IYUDMx1rDub7s3JqoTVng6p0cCmRFnN5UrHi63OFLHRUZF1Fi1ScME+mfJrirlSZ4HvCAx1jaKkBXiClsAqXch8NFSU5bSrESTPgVUggYYa0taHl9LXwLEHmHpwzblr0Be57CZnw1LuXfyzjDIyBiGtv/LkIR1mkfS3TIs7Ar4lqFYAXdc+3GUATpUrbVPuA1GxjTos/dPT6I5chMwn8SGGClJikVVOx8RFaOugABnml8J5N3Y3StKltbCNOWYAbpWrh5YEL6cVO/A1MaR7KYxAi5QuJCO7n1W0ut0MZFJf1q6Do7rdjX1x84ifk7mtLIdGDMYDFjmvPYLb9UHFgUj7SdmA5102mrR3HuZobvUwiYPTVMzTdTclFywENobsxlBEuRA7248Cpk97nToMwxUxXWY/eSopLTG8HDMg6tXoWtiX2XnCf6nUmRciPe7bMhv9AhxoQJb4Xr9LKoNHiuPZS1AXXL6DVnSqP59EVaH3bT7V2actFaFrZt4KmR141kJuZtcHNKg0d2qRfj8vgqDjStfgdgKG/eCZ0R8M+VYpCQNKZZaIfzzSM8BxDQVPYOGvrnJpPFFN27+NWBLzOnqJMY4aTAXpUid92YAvz3bLf5Ot/Y61WIKbNwXHtaykciYa5DV7vW36lUBjU13p+aohr5LSZkI5f+mLEzKOv43RttO9yt/LkDlYL4EEBsgZHtI68eUPXzlYE2jSCPLS1s+X9OxW87OLVUxZJZ/4rslCtc+a6Y5Z/mCJUVQFjHEY0ehdE7vIKGClgsm98IeuJVZO5+QtLAyK2YuoncdGnYsYtsDKXlEhrmsCEmvk8y90Xt5HrSEdK5SlzHlewkWCbam48/+3yQmAhbj6a9P7t74b3vqeba05OE3s3OmaY+RYF+51JRgZplyiG2krqn00OlSMt5RvDM7/tj9npfkF1t/HKZwZgCpNzXlmC7N3SAzmd1SLZXsw892bzQ7CrItKsd1A2joH9vby+b56ZW2VmFhG/xsO8aLaR/fATUtHRulp8o72tSrFi6xnQXOZwKQN+72H4gT8ly6zGcwKcDBcmyvuOVuaJFLW0eziNaDocLDJbR2ZVal4z7BxdabLafvFEbeLQnXDlZeG1DG4KV/gZg0pGCcvEAK+TPFdkZBTp5Y0XdWB94Mv9ehVrX5ykr9HoRcyqnlhxQ6hsaV3HYFMnnC8QSxTHMJhm10F6+9/R6yfyIG4dKn1BVIZ3wYM7gf6KgirSkvBE/q+0xfZ+WV/vX+WZ6h0UhwCo7UyybsRgsLxA3ihh44stf5nMnwAQsmsPmWs9NSH9uJaXkNHalPDjRtEYOU7FNuhOaBmPhX6T2kOKRrUEbH+gvg/s40t5YGyM390eVeDHHxcl7sV5Kyvq3bwedbtRx5sM/HVflvqfA9XcyTZxSe/5HulNqyZTN7ul29cP2xHq1rHJymW7loCHxtamP/KzEUf7fBJwJ5fiIp79Zo55bRFkInukW7eY0luAMONw7Xjl8zpFFS00OQh5Y+Q4ojI+yCoxdXdm/GLqwyBab0w0tvHEod2q3p3jaflBwS9PYKJ3GPzp8dtnWU12cpJGq0H0gPt2FKRiIXeWIelg9R5/CeRnEFEuL+XOPmReXaCxRaVeqnxFBGdfK5gYiPJHkmNtcY77EPyNKvsdf/WLPoQ6NCAJU7V1NQJRAoKgSQI8RiaUA+cZD4KO5Yec2czOue3xlqm2fStNzwYZ/1g6zsBt7laTqbyWXBchdHB2g3R977eCQLNYV9QDDq9VdYV/WTvDubNXowWuv//zbNH7k777ArUrnNBt5CirSdjfi+sfVhqvfnZq6nQ2SCZoBkEdGCSJso5YY7mhbIEZZ5udXAJ3BrOn+sfnje4FhTaBsm2lNI4v9s6qKT1lh1IZ00d9VJcIsk4ep8tTuNJmjido9zFDlP0C6mK1EVm+m1yuQBBLki/VjPQYYMKmt/NzhBlj/l2O7eH3oxfxuAVp0CXL3M9mDpB34wZZ/IA13NtTLfRqZqjfaOkiVK8QLxwSictnQtWwt8ztRQBsfcItm8ITOA1Ejg26iVzvt2E+DIGtFnjxhuXxxi6uZ+BGCFYwhSk8AXIC9aL8JOd9njEOtPryOrFWvoE8Z3TU4hB8TSeuFHEouZD/ehPjnYQgG9++SUtWbujtdsHitYqVQMd6F7VlaeSWlxIHzT+k1/eYLkl3BqRKcLkQ6FgTZlkUWXcqa5nNERavv+CD0lug1igfJpqVbH70FDmUYeC5RO4rrIcWk0frdV1HmGERtKF2YJZ8+pBpgrJq0wib/yGJvixR1yfTeZjElb69Dl2H0JzKhvxWMSDN1LazLBlmYM0CF6EQTLkT3mUoUW6B16+Cr1NC042cMcYti/Z4VSQQ1s3Ht9n/2ZPz4upmoznETzSxhoweVHFNGRT5SQQcbEroSQx/70oOjcq2GR0cAiC9MQu0IXSuTdPnYq4dF8TUUVsspLvLR2qiXbBu2tSPiGTJkNKDTPeHa4UicA1GUS+/p+UWTEuWchNd3HyZ85cy3FJNGIhQ4gH1cN7eQ2EPTSCXkw04ItMy2PLbKxGTXVAxvRCVHiJaNfHMpKeT94SnETtiFlKNnBw8mXUewn0aL2S7TCp7yZgr4/pO1e7xiVRyWrq9P3zDd25rGFa8WT9clpbHfU5nO1yASXqRnGeOnlbvc11rBK2prS/vZo1bL0kDp4XeTu1/BU0LQa0SIuVYcR59pxNrfGNndPOaaqsEfxQzg5xC5AkCXB7vMG/46qjRmDwlc6SRosfBnlRYddTyBQ/Szt4P/spWmbLYi7tg+rIz8X/aHna55T0fwJI8304wX1hX0qmQYrhe81f3ggEPHBY2VFv0FxTtWsVE4GSxyTrsPBUM+JeUl6wkMbnuwj5JqhI1DNIkZwqn2nlb9AnLs7yil/DVdKpHZ3fSaiB0gQQhGHp/XjrRq6BwUwijPC5M85nyDjc7ZuKK0O70GDx8jHMDCCj/VzcAscSSAPmKY06UMEWY03zROGa60EZNzRvGMyvJbtZXogKLIN3UVsYuVYvz3f9nSjWCwlad6r9rF0s/1BD8FeIlrLoe+cHa4gyZNic4SoVNp6fLAtJTlj+L+vqvqMeWMK1KopKTnKmZlwC11K6JHvCTV4f6NsKtp0xJrpB/rkQ1YaCBYjImMbauCCGom6/T6TBZJ1Fj4VVAJb0841ABEERluwt7cC8ZmHSTIMefGAt6VVQaH//gXbUC2jHIXj8jOVFmt+HUtOb1ISENsvDh+MLfeJL5J/ElzK/lbW/AS8f/PNnKwhTFAKYOogTtZIel4k7WXkbgRC+7Vep+d6dAxb/gag8Gz2CtROqQDG4FbTT0zntdTRIr8YM5dupQP8c+DtaOvx2/qeuTBbgsXbjL67TqulHSkvtnFxowx4oq5PtTPddmRBUpNyfHfR5Feh/FJ0H6voNmeMb12+Ah4ictRPa1Zg8j0R1sopwioJ5A1vqpw+a4rKCSiY4tgJN1lpu1EqQQwhUoFJkQfVrWOEts2NhHMPT4Yxlojiqmf0LMWhvsxWtzMjnylUn2P9KSzQYJO/Nq2k/vqDpyEmhCSeAIrAIXlxJxs99yN5iybs2+AJ4/t3VPgBwt04V9z3z4GShLw/8k7fBKN5auwVLpRsvYLiKtNK/c7CLle8HazxJWhEfKyVzpR9pzjsi64na+FfQIEVZZSbO0sMg3Vyqc/LjOoz9wk1st7LWNW6tihwtcCio9PniMxpJVRK9jzDEQjsb9kyoIyoBeIMnBrooRGcyzAauqLUUWKIaWYtyrjaOvrmBVRUdr/QuFPfUfM10X6VadSflqoXX/OOT9yt5NwH47GGQ3oyMSuY388KDJBUEcOgmc3GedUILDWNODrpsdhThUWVsvU1Mii+ouWFX83gcjLP9y/mosQp1HU78/+YYK75uqqGi2oDGOZ2IuX8Kumkm4OyooK/WIMSJft8awm9pqzGBLsF7rLBdWZye6/bfGjdvQofP+fFEfSp1GIOlMMpwvbR1LCVI5BdAzZs0G8ntxqMaP9NC7WCgUC9f+x648P8bq9ZHU38Pmj/EKDOXmzZFETI0loMtY4xrhyGxvxf1WknxfUBbwYJOxovakLc0SGg+uHWxcaf6CghNZxD+DBNou0gWobmeOkpC5hM6I7VOf1TWd0Nj4aAJgzy7TNlWomNnSIU0k4BFt0ZgOXw0Srb53Xc/OjkdC9OnQI0f8ZYO1tFF+dwj/UghD9j3WNeR4cKkcRFYeTRc7/FRbk57TvLhCMznnso0+HEdjg/mV2Tl2qW7XtbmSd6ZYC9XjV2+CGEXEzZu5z24RTIjXWWUGHIuNRJaoPvYPeVrUZ1QyAvKqDpoYPpOmpbR90BV/ZwYYDXtMHoBWDpGGpRzDOfOKewcK0hqoZDFQZ59kvpUjjl3V4XmMXwIsbY1d2fFELatvkhly9E3RqdzRN6gA7OgS7E0d1GkcMI2KoNDePDtPSitQURMRrVYJTvrFtC7qd8ZiPh80JuXr0vn/nGsFfr/YgiwUL5ifTRXuEK/NchHo5C7jt1Ckmzep8ZVZBALs5zwP4EwS4Da5EAjiANpNw+ltoWCk2tId9GPWz+j3Y79Gflu6f4QViqZ1yxP0ukpY+TsHw8AoO7N4K+9BD5ojcNMphvEKK3A8jExP7TDactf8SkNFMiMD5Abey7vAGcaShCVNiICD/23K/Ara7svV5r3OwFll4jVo+WpFrxx+NPBMrPqaCVjymbHLEz2GAAU9SKgU33j+VH2unF/TIkYXGMo4Rn7e6s8PrkVnTEUZN6zawcYwuCGhgII2O1Zy/eSb/FA8huCdK6FWpmPdPpmUbUPaCP8gM/pLGJzAUGIwSY1Js3VqbAouq1cRbkkwKinyn2S7GC82Yl9pWh3yGmLphff4O+j/VtWgsRrWeS+4WooDARR7RtiN7h5F5ROIQYmb5eDTIWUh5T0KLHF46iZPW8uirBhTSGuB+oZMVH+Ovb5plp/Vgvl6IqU05aWFcLB7nGt1CqfwoXcx7qAIF7WdZOTz9WEql3LFFOEa2+swJz+BwUVLAzgfW1OEy4LhUjdnCF8xKkI62P3Ixtu1VzubkydAcN7beaUkAGNOe/o3AuZWeNYd+Z4xlEqC01Ub+u2pINZNdfzzs/KmL1+n/8slxGflRW6U27/kl2pOzFMt6ZB4o15d/8m30Btp+T4GBgO/qavELDHWJUD2LsnP0ldfoHSgLB1cXzNhaooR2Uf1pVNsnvahzfHuD4tBewXChgIYQ0CYRhiGvI1uSwHrpOvqiRAU9kHdLF5D9yzAG3WtXwj2MfO3HmKhnui1YTwg0p8cHCzFBJuyEqiz1dWmzmoM0i5wAMiBv325HVcoLhueDzFi7VxkUJWMAYn0OWUGWW8r945sgj8eFM1uedY3d6hFQhIZa/eMKEAJAcsDsX7AU616+1N92jgRLV+pdS7tNbLw0jGjD/PQ2ifKPAziGCKWpQhxPknTYFMb1TpkWVRAKMwBBD3uJysoeh/deFxGX75MEpEfRHiDjI56XTQ2Sy5N1MvSkQehYBsYhbLzOtVYBn4RIKk49fs0OPI1g3r+pLw/ngE243zjtxhXTbKQb+kbPd3ZUTYFo5gfpM6HumpSQActyMMAzjQP7AaB+e8NOddZT/CRw+mI5zeY1g4qaV7fTX9O/KKkQ7vgB0mW1XWsu9kQ18w9ykhwe8GYsin52/0n3K4Refe9Se2LMTf66sCJpy/owGSNQ9u/YvpTtE9jjxVvcHdp8A0ASl4U3UsaIpXpuaLixrSZRLXG9Nmeuh8iHjHAK7WDn9e/wtqPmeWLvPbfp6W+i4RHXxnesKN2dZY2bWEMhlOtTpLYfz9Hs0RcDIQK3xvz5wpb7s0/RA1ljIbwLdAL/6xEgj/By/dgA4ACOQePl4LhOVfwzjfc+4xWy+uLgcTamNbahoQ9xwMYfxEk80Yf9g6nVDtuaMNhecnMS7H6Nqkn3MSJvDehdv4b/161aRjfDCr8VoSOq8rJEbhGIx06snx2ND/zV3r/qziAeFrC8WZnT0dDj3x0xsZyPnVcWFyL8GufKYaJ4XeFRHLOLGFhogjSgfUlqiAB+ezEGl31Fu1JFymokW0kLa7Xx4jc5pvG3rnUk5xQUTiKw8sl5EjY2kZrs6Brx4PeK/MOxxrPLCjlp5hJICrjS/ZDVTiGo9YNpVtLa+ANYJGCX5S92FdxgDt+omLi8nWzCt05MFYBiNhRL4yLlGi8FNzKMnParh5IoMr23gtsBW8S1BdXS+JrLn8pKYVXn95SMAwE8qCCH4YxxzkvwcVNmt+POyPSZat+D6G0bvKrRCsb3+XJrO1L2bAnU3gPo8WuKhhO0c6VFLuWaM+dEGuamyW82Zlkv3baKjQwQ5qoghcMSVVGTjwFibHlW1BpX2uTAqj3fmAyNUsNmVGfut/iCAQ2PsQTwNbY+C7F9myZyyWXVbfrSMSlfAAoHpHT5bQaIvdQHWT7PQIVXgdMMYx5q7jfFpfTTrQesiez449hNnu+S+4ebuPfY5QM1XQZEZblAjSy38V1A8L36KgcCQDWT8rphEuak7iZKauDbDVja4gDPdxEV9bqbjJEYMichMyHXYiToIQebHp2IfTLwBZnAaPLDS44AXP9Ib6tS9ClVlqprCvOtWTXsn5x/bVcN/Z9YWix/V+/neZdRNy3ex0GLutevjzy0dMrDRv2+6ckvGCXliyoZQ1+A1sE3DPCeFolgJp13g0f8E4pp7LaD1CvkqoZIWDiJbhIjrDN+V2cemOe8HEYid9RqcTfY7SJG1RByie4eRGAo5S3Gd5ncFGM4Q68T9egXJzWeCGLicUY4qlQoJI9B6g3Je0jKjIkYpshgCASXM9ua29Nhq3CaroitpHzbj8wBKNJWxLaC8Ox/oTtyUGzQsezINqd1ogz3+pfXJSaVgKtMTgIL5Zs3rKU2zo7cO4JXyhOxCCMBdNyqCLzV8NFWhYkeSW5G29fSZAwwN6EToQka4YSESX+1jDRYk7mDTlDsNlndfj6G4nw1k2/LTeoQ3O+SyKR4+0PAhWrhYKHe2zTSb14yTZbvwSqRO+/yGZLRghoVZHfEZY2yPT7JHXxBxDVjgCVfGgw6f2G0o962tJIc+Di1tGAinwoMEm1EntBsIaO3b1zJIg1mIackKS+/qpF0BVy8uqVZ3JHXrjlgBY9s7eJftwcX52oyiaQGTaXJJORG/y9RQxqqJNgcYWWdntFR12wX0nXEMGS2V7pu9trLfW+L9sJrS2eK2xm13rApZDztzGhAlO7hPhx9Z8uxpCcaHfF+VxLARFMgGTUxJ931KCQQ3nOQPXq0ytM4UB912W+k1Jn1jdbEwp5TgnAMek/Sovi5ijLEHlMXiOZEoXzdnqqCIX31ATeta8JdYejuLRI6hNCy7vpudDxtiQY3sLQrCc9FM4aLP/8ULswrv1OkYS2zcGOroBzQ60qBGdS6y/4hZ6ITYv6ckmvRwLhRkxL78iqdGFJScqZd4XOdqP71R3kC0Zj4M6xC8G6qFTBgpma6roFc0vN7bYImHDGTridhpaO5E4OzJCPOE/DZrPjGWUhxZTPTX70cRXf+rR1ph2dK7Lr7DIcY1Qkvok74Q5o/P4kYNo3yZCdr4HWuHcE1welBCYwuP8aYGg2xSXpRT1tcdNnRcmEcydHv/RCWsbyMr7QlAXAPeF8upHLwzGHiNkpvo8kVSGjp9VO3taegbl6fYor7++sLKrCg6f1SyBAhylFus7YEZBpMAPrsSAqmjRuTNPuP5vfu2QAula42ZopHc75/q2aCNDsGQDW7Vwv8qpYOT4RFMwmQSJXEHq7dWpt3yXM/FJcg5UC0h3lIykFbAybdwuVyiEucGGP1NR3pjpaMx6eBzpbjjs9QrukL9FNYwfvDurVstQelXPwwXjvZQdlq5Jy3HJ1cSVVU19KiCe787GmpbX1tJHt/Q6XFApw/buzXFg+nYc8I4DLXzr4RcRVTiQpJ4ZEVcWVxgyho3SQG3VaxiMpQvY7xKYlz4/UJE9F5x/PBXtNYb7OvaF8rsFCrfC0LwFk0vuNphF0TdjwxdpmQKzDc9JP4Qm356WseZzJ8R7a5x3zCIc+6uZitl7Q0gKSw/sA7cLgzXjJ/pLTSZ5+gXFsq/rKXU+4Zas4+ie1z51Oiw9Dfhpx5Fu1iJTcKfIJQ2NQThGoIMeJw2IyPRjHF+vekbsbY1eNifjTPqOzlXaXLOajrGNhfTCMJk1SiZ8SGPvva44Gu0+79Szzyk0YFKyAyVhh6acrdRPcfNJj9b5h/BLHUG0Oq+JQwbbadho3zpbYry9N0EjlkwYlWZE1eIRafjERTCa0Ul2/f3+oZQ1cViP3eVEz8GN70cOLJgYX2GIjY8SEkD5JxRMNllzsuS7Tv3b9XXhby0YYWs8B2CPooai3EWCEvMcKvF9Qp1bzUrraIuFKKx+WGBbO6eABVAzhsggrxISEr6RkjVYSDzERuSegC72Qb3AWHk9Vi97CRyjmHHVHVVAx7f/B7eTGw0+ghboWeGyu7Mo4CvSF5Uj6lbg/HDEOvSrlV7h2s8od4DPekyj3QsgQ/TGtkGKiC+xBl277U+GTjlVTUH3CbA7JTwMEtfV5LgWwPYsJG6V+E/yQIH/WJHVUVutPuxQYx4IidawEU02s/Q/9o8Z2Zr7svxEz7pn9o1KAOwgWRogVSwHBQ6w1bzG4eDcX3nzdFNHHaMyih1J9oxDDO9tXqFUADu8pBRSBTgDLSVxCBQBgaejb2bkz6X939Ath36nVIlMsoqqJnd1we23vQwjoY6WLCIUI5N/rDVXN2o5vBAEbqS8p3jOkYMKOSJlqwSZlsZ6pXrVc0o9oTFR90GHMa11dpQ1g434/7io5+RxDQmiWgLmPSCb/+VVMWsrCdFkDqtt7uxtk9tQxJUiFoXzKy2iNUaFs4LbFMYcd6g8CEJNqlmVpoga6m5JTDIVrC/bdR7Bx3DYXpjyZCm2SJuFzQswsc/Lmv/NuH+5m+3a8x87jx2HDyaU4rg86RolMl7KIzT1vvLXbVr1D/hGpe6gJPiR4n5XnQs3KW6cxE9smbHqC9a9Xyrfv9KzzoFH7mgpGnVAFryLXG53zzumm2zZBcEZx81Q1Ko1upbo/EeElSdQBGGfsRc7OPHA0THaMITgyrovVvbF4ayLdCVIqP3OWorjMVB4UYG2clndXqfeNUTJBQE6EEkXzT0YmtIMq4teD7et4klOrDNISsrHsEUERbg6vf7C4O+ZVhJoJwJe6sbUU+qA+vJkzAENtHUIySVYZ1AdTRrK3GCWxTW+6Jqk3xITj9+uUxE2TYschYgdmjEtFQZkqvI9m4TpXZvA26HyML0KV2CGprdLmcCFodpKhghUcSXU4uFEo6xSQZXEvnle/hkiWR8YSkeCS+fZzB6ikp5W9YKl9zDraVeKNSDXyGeN6g8m+xJApMPQeYrBFu9atWz2eEFR9ul1mgUTG0sKo+Tu2hI3Zku6GXTiw7Zzwn2XJ3P/txTFwqDWWDy93LtN1aK/XpD8yzHhSjVqnj6DnS+gMgfhDxJKQBJXoKPP27MISchnHwWtBxKjXvvD2LkRdsBZLiiPA2Js3RSNvsa4RBpqVqS4Llcz01uQ0Cf1W8Qno2P9ROshVXAtHUVtxmyqsQz3thgeMkeU1oo0RxF2j+QKgG44aBwT3QvwQHB2Z4tNZnszvclz7tF/FKVP2QJ0GHe+tkZ3MotQWp0oblU4zT+IjJZznnJclOv5Lvu9nPO3bhf2dJBkA6hgwZ3dLoaXskJ74b3dERcaIFw7mQzsufftEA1qzPT+Fp7alQNoG6uZdIWGqbxkfsFVwK67cr71Bw5yORR/ym0xMLu/0koYobnGdS7Mn+HglU/gu9KjVbg4TKolcJN8OIXWYzROEyPjyJOXUj5snjc6LuFSFHCxZU1RgNLRkJwXH0iN5hAdjMkrUiatWf3Ls/jaFpl7w0EL/zhOkBsempJZdLeikxatccFfIQQEHQSFHJKXXEURK3EZ0frn5QMnJSi1GzjjuWnwwD/u6Ukv1gWjus3QaFdLnRhg2vHYRmG6/FrFgcOjsnR4TDoRBjJngYfrbAGkKnvhDIgxger0t7kedO3RWEtfqccbfkux2hVqkTnB5yaVBnJqXDYM00UeCRg5b+3/otScU+vXx4xBloVf61zIG1TKkJR77uti8VEbNKAxtiIyHbWF6wzeevSf8yEY0OmYa+VAXU0hvKyA/7tMtHaWw9/Rooivxhl6U04+EK14m+zsaf78ni/Z40jfu8k0ho/PVOK1w9ogSO9vtQbClv+INfIRxW0sO6tpw9N8hqAGx6ju6KGEj1cciDOJWBQsKU8UcVmBpHyDfrGNau3aptFKpdYAq20A6MtenEYI3AcWfL29B0HjCd+/2ipkRtbFmaaE5G+srQtRmuFirm3Bg0/YHtdfh+TxQ8g/8bf5DGCKAx/Ugk+vfj/8J7ZZ9u6SWpQBuYhuMVm9SAQ7ysh82/rwPM4tzCrnaKJA0PSdEUP8qMXtEW+uWFPrnHOEVuSzpLMG5YPO88O+QBckQM6vwTGS/0gR3lbOxjdyGoZ+8/KCaamVa8OFBU4ihbWiMa7kavkfUA157YDIb4Vt8J0CMInHel0iKCfw5F44B/fJZaVW9Thnz1EvTWR81EzcDNlbuUgbeWLn6QC4UavVBaUU8sPr6SpdSqcYRapqBKAb32IsrA/CJF25eRJTa7+k+bL4zX06YLEIkTdfye/rUeEwR80v1UhreAgNJTGNFUTUanqsE7fZFlHVbHnmED0V8wW3crxsajsIPBh3JEwkOkpIsPyu38DMI3IvqFPcFE27mVo3xuNThrDdORDAfCBvBgLsZHOQpd5SGHRgGEC7lfpn6CD/qEUzW93Q/Iz54sgxzJVn4xXSsCB5ol3u5vy3qqfg/iv87l/vJhi4zNIF7UTQbpTRTi761Di7kgUwQJZRHYdT1D0Vw9X/IKdU3EpxDvDMiVwLFiMeW16xekYnrMT9D7iWxVR6pyAVj4QHa64sEsbVzYfEAjvDBc4QWmrvpNDemeae1QGmxqCQdw6nuYN0aY7nSoYf1KBtEnwjWGW/8HcYlMemStrTD1wja4L8e1SNiz+yZKt0FP5Dljvh5xie72hJm04ShR6K02ZEF6vg3ch0tqnhtwGttII8beC2VrWzfLXRny3zSWcfrV8SUHD+aaLYwY8DQbNiU5iRVtBKIGbLlLUQY/O/PwqvSMKglgdNLOBrkePjFa55yjqWP1vUFHGUW84/yzDQWFAtnWgv3xhSGzt0ov5IiQKdO7DpiNiC50xpvu/mu6lsT2K8phK06zeeedVhEgpa4x3W9T+7ruekq8SQvbLA/OjEF/nyd3iNY8inBN2PaDnUgwEu0I1B+UOmiI8ljir+cMqxS9gMSWIfzbmV1LypBeBJE8cbN8hbTgH6vhEcajckQtXz/P3UVqsBk96XtktDZyCD/7mOlhE34FXeC/hbPsgEXotOuQPRVdRWkBp9x2isReb9AdO/0pr4l3DpmyQdRQ+ApuyZ9OCFjYJbRA8IBqNwK6rMolrhFq7yyIBqSpEPp6+vb/0Au2AFTQz6BGNhRHcZuYa0xomkv3L4I8WvkqeuV3ub55PyO2M+eODIijsYKeefm/YhE3SLeuP7KmJLi/uF0cdJp5Iin7/FVGrL4rqI8AuEi/4FGHt0e0oZjWBakqJrYLBa03b9gzWVkf24m/TXgvtSCvBT2WOE9Ahtp9XGnHzCc0N/iGDnvbRm/ylHv3b2fyslkmwzS4gzPLRE4yLYkIsCg/UImq4VfvoipGZjqm+iROY9y64h0Y3rcoSuk7IPCQ1pMN+z6D+28E1KyQPdoAKZ2pZFcr+GhNgwPRU26gWN2ilGsfLMtsNf6jq960uHDqx3hybkzedjvLU08UhaBn223XP6cZfesIrabwDFdTExLqZGrF+6ButBiET7luWkGTFggZu9Pl14ZF2JAF9znIISWq1m3U1QEJG57Z4FV8OcW1v8XzDH1ts+ohQLHa91cJyQociKFgNHmajKE+7J255gP6r+vuIeVGMfJQmvywOuSFcJWHsTMfIQAVV7isUjzeI/lzj/ICjj5nbjqkBhgyMz/KbBjDj4GzVJ6UvDdpW6Qe76G4fneeG6FXr4k2iS2kiNuvqKqT773EJX26O2qzc3FQ2L0yGec35+v6u0inu2nHS+K6BAbip1Xxudb0o5abm05Ghmv9mWKpKRVLJxQcsfmB27iHLMzBP8thw/XMSadgp5JuI/+EZQLvEkCg5o8WJs4bg/RiGhHXbjWZrs/EOlQGYOQBu12Q5K9ct4VkAUhcb6XeFctzvm/MvlBx57XYbA8DJq3ZxAs+2N8CyIVBYCCB8aB3NuGuYzb1SBlPhrrwgLiQruRiNwtdWwYU+b9+MlS+8SKsnzP8MmAAtvaEQeqnGxImHKII8k6MpSMZoGdrAEz2eKsRO4ikB+46b8IWfpsewjYp+82ReETkBCqq2Dn/O57xNsKU8hxd13FKF4gAoL+eYF9VZZaWSW1gvp8DGCJ3IkyTJVXPwSLpkPblacCDUInOOSutu9Jvq1Ua7/V7ouSyoWwal6uOxDCtFLd2CxpTqzmSzZ39ZwFmUFnfgEl2aEJpai92JmnUbJx3qdp1EnYwQDf8qacNjz0jA8/0Qn4jYD6m9qB3A90dMeQyoQLQAyxb7yVXyiqhojA44GLTPVsnnMBWSxDNSYOB8oJ3K7KvVfaTlUUtgEIF9DKZmEUcl/RvwOLhjBQ0hzYg/qgBCIk2gSlsoBzCniKOr54pweCXYesAj+JEWcjqSwxaE3kTKJlKCOdZZD4aKVuV3jpEf3Yhakmo8L6NmtnyNeIn6nhzjOXv1FOwIQ0VnuFFRYMpRwI3uMSQYOhWw84RVSG5YGA4DXdkOkEzkjkeg6hek58tlW/xMtLTNBcH2YbUjbqAmv/xeX++eDBp+6ntiH/8M6+kSsRmAXVutBtBwtmIjhbGaeL8Klc0rFZjbXScAyT89Hidx3G2V8pJxxsOeD3a+nWAMGQs+Q7AMC0YSNPSg9LySTmzDihXyqFu15w6CpOHo0d+2vBf7s/2fT1NEzMVQuUxCI4p81DOjgy7nI3WtwvHf1xk2Dp5BFZqKKVb0oQ9HujnPTFvrjT2qTdZz7u1SA8eWacIIjSQAa9lR6r87V46MDF46v0Hftkntm40pFiPNiacETQEDu86akOa4rII/JG5uYIXtJ42h8TLgdteEz7eSIr3SpdcatevVZap7K8xfqrtRbV/2jYDq2/BmcOe/nRKcq1LHkJGdMLlQVbfOQZvNkS6FBMU7JdmQ9UvBHatjDs9cUuKP0dG0lIdZhpKfntzR5cqAxZ/lMMXxeEa1lUs5ZT6svINErKxU7GMiO2vjLHooumGr0cXbqoCaqgUR5BMk4QHVMBZy5aERfwhhIb9AUFXKNHx/gR4vSyWSmbRSI7wb8rziQIFUApPwvrmxYt/kr3w3XIb6LBiXWfwTdqvqjY7bBWfQYu1Axo/5zjAzqOg3kGSIma0lhHujHriyI7yu0FMHIQnrxTjyxW+DZfgiiGbgHf6GFQZ1Hz/PYC8YPkV4yz6Qn+RLTmysbF+P8eJY/7yiivqjyBWjsU6y3lgAJZTO0ZDFE8E52KhQQA+uTGoknYa4D5azxYJcAny90vi/w8b65+YQPwqoU3ZorhVay7l7O+3IEe4uibqmholxPpcSsvL0a4be8GBW0msZrMsos1cop7ofsgP+oZyVIkpCOd4Gj8PyYtbmJ2ppwYORvRxKfa8umhjw8C4ZwBizm7w7MfCrNRTOIydBp1SGehWNpc2k/wPXWJnZAaM4Hy1RLWq2WN2LbjtPCNBO3aWcL+E8TFObLmvRXkuv/7Pq5SW/SqflSewIjyZeayjUrtYf4rCUIA3OKLhJ70YEAWZrS0CUAqqO2wvptSKNeccoEuM5jLEEJD65dO7CV28WaSo2V0JHiMMGs8sTfOIPQgc9y9enGoEI8JlIj45os4trmJoQeMTW+OxlmfSb+93KXvCw4GXup0svTX7aIK0oiXIRo4Isn+7Cd/vyQxyXdtoI++Tv2N6RiiLaxts7AFqmgF+BjO3PIizbFytY48g0xMJmXYyQwIgnX0iggHpAUJy8kP/aGZJWDWLpiZ+r+Z3sYOLwZdNO/EyrO9zlLnGUspwmMiO62W9NVnSD+oLdkbt3QU5xtov4e9AGRo9GVPrNqtHaznQfJPkqrBwjPCU+2Px1SEa4FeSMnh21/MeTa910HrbNmILf7wNcr4VIhGTIkyKDKROK1H5sb16++Df/zhexltyBI0tI5y08J91oEO1CcPXH5D6e0ghhkEDdwAGFejAxsGi0N7lkhFsCsv4hhybCN2Sup1PRJtAA1HsFzUaK0ljXrbm73fWFBVGkHJuoCgkLqciz2lyR8S6+w70vt0vu/dCBSdpe5gZ7zjjzPB3zlEb7yYN67TligxnNJDqEogDtiz6Ouca/urNjhYFCzZxumhQ803CX/UgPZ/GoFJrjtoa3QbMovYWljRSiXT5JDPeq92CiPiK7WOcTWW9ltqTWKEllj8UXf9qCCUqQ3QGfcdFID9gtbeq7Ubmii9/D7mYtIXyLJzQ8t6k46uxtQdIyGzZ4n6L3G5P+xPu/NOH7kIaUh4Ffu4IhEBFJ+r6bxov5SQbQ9w/g+aBJmG/KqvG0a/mAHz1MlPVrBIcoXTsE2nBZaOzev3yPWRWLlesNSyS8ZEM4nqz3+2g+ULZ3Kk5DJ4vpVDXrJ5vPPxFejukP6yOif2VAuDAk4vxx0Hu1a7WQmlshvhJj2/PjaxQ2HwZeoedPOZsaHkimZ71OvKcuKmGEK4NbfK/Btzird6is+Z4Vy7bmUDs+jeO4gYCLl8snri0yfI27pkgoAbTm+qJcYSg0wzms8NuwZijwYaaotH42fr31+D2CX3IC+QjbkTeeVH5u8l81mG7Pc1D5Igu6l9Tp2CfdWJDRU2WbhDsrF2tV2VqWaXTKunhz5ws1V67j8PM1ZPEdcm/n8BeByvB3rrnjxHEHbxfA3Zi+uN10IZ2mS5JKeciZeZSflWY9MYQAuYZAnd4hCWq97aK8T64YFMwq+ZWzgVUstHbhSgRYcOLuvh2wjHQnyY7lfqIDjPsaKsMjcufexqGvwW9In90/4w5lGxigfWcFzh8/VxBBQ6qySsNHrENPofiZ/6+buTrordSoRHBOOPmJEdKvcUEI2FYGa66YDsEsKfyMieOTNyj+eeuU3R91Uz1FKtF05KfqETxxXpQajIlIkXhac6Vsnoq25w9AIAE7xoVyVKguFW+f2ZokbF7EWBa8LCIQH8upr0nugUKi0ZAOYUItUR1g8Ha2iuzWYM1ouWIQtC0CedVKBo/xjrH+L6XMbD/FJnH0AuIuJ+jUDZb4lcGsXXPkOrVC8lLPNlusB4eHrt73Eq26TTeCHfOU4ykw4cei8i9pj4nlcYK0Tx5kbvPnz4GW3V5cyod+adO2Pf/aKaL2a/orWfpA0uyr08CRDYfs52rODv99B2hcnfp7U/lR2GeNbcYlJG9icTnVstW9ujE2/X7qy5hcOhKt0Fth5aIob9Ce680od+xbRFWvinj+M8eft+gAHr2aoVVF3EUVqiA3x2cIiyS22v5ppuai7WalISWKDmED2Z3V9hMQtTwef9Kn2LV9+Tr8OPJhtTQLqE8JQFytSKICZp36VPDwoIhoWsxlyq0dWZpMuP8LMotPB71luYvN4OLH7SJShuiWAH+IDCNI31NS2fwntsnz+OUNc/zoUiAKVsJSbof+RvgTFw6B6XYYWhLHxn4wuItwjhNzvtbFj5E5BSNIRh+2fiodtJwX9jxHb6TUdm6AVcoOu0Xp9vvPms7Q3r6IegJ7IXNluGF8U74FR0VzlCUdxuImiK7Kyzp5Jgc11ccb64a9CsV/7ilhK1EVt4m0XFJkqoc5Qvu9udmx/cTHxgNWGN3f9iRJL+zn5symxN1hwvgBbQ0Pvz/OCBPBs3OgxLDBgSWzCw3iuCr9mt4mxeWuRWSApD/HSPVYYAV5ubol0Y1Th65l601DJF/RoIByr4m9NbHGmoNvJH5p2EdlMwrZ4K3yzcg6Iymc2hrXd5HR59jH44J4Av7JQPwHKdQOejJRTcuXH0KhobWUPYdZWkwp8irk7MQ6lKkAXlFavKeRSqjFKKmsjo9H+6TTmK2men6RWNe7R3xNPknlg7tCa1ITAubI2GpzzSynaUoVWzjv9jb5yerXINIfDxtl5HjbFFAHPC4+h6el/ItRm0aqGhwy3IBCcFea+Tf8w4kO6VhCiD1wYhZv0yXTDJg40lHuNSlwZ47L0b9UqrG/oNk24oQdEa14SKszln+Fx8ZeAvijCo0Q7AWiun+3Vxq8SqPUL1J2bWUBYeP96CSdwBTOioZOwmoKJ0C5my0dH33rwF+0XZdUIKn5S0lNE2QONv08D7NY8WdOFtpei7SjndZ+bg+RXM75c3Ld/mQJgRWDD5IBDTPVabBmw7mu+wob2yegqP9N0XNlLwsVYVm6q0kRTxTb3gMutZrCw6MrExrRvBb9MEsBfabwyoFtn3KTHzUPzWwvDJG8hvdx4Wj2d0WBt/6X9NqZZh08+5NEGnuqNHKpFmdbSpfU5M0f87KGOOPQHdjMOAfrGgSAPzEZjGQn3o2TW3PLmsEQDupuF3tMn2B7g/cZbS/jqBJYRHVr55v5lHuscsC5C2ftep9NiXmJQnZWygXfM2VDBKpFSIum12AHbfQWYBFxjbyXgssdA/kt3HKercHZxY+9R6xu9g9RJs5uPUbd0GqMlzNwuBLHrwanNxzd0jAkDdpsAaxQi3+zL3k7j3h4fv9pYGYIjK0MqsXML4k4bV6bwkIWGB3+cX3Fu9iuRNGDnuFOUSMnkMOR8XOyx0nrfoSILdj6j0nPmLGL7A+LyPpZmcQQ7SkMInjZIik6vQcv33Ox4PzEgxzvx22aRQHjU+qr1csc4uFzoWAQ9DYCZ4gXPOn+NcRSrvpqeWBQ8EZcsce3Y5ITPD/dPTiDreZLYDouu+Ckb0Nh27+4mxEvEPqWW5Bg10uDQ7ETQisfy/Kthkwkb8DnQGehcie3MQ2di5DBXLhHjysTm7d4ZU30a+EwkrkzNEhvPZO7/U+f35SOvOTfMI1yIa8TRbpWlW2gIlUW+L7oDYRWGt8myCFMM9neHa7ienZMMbLBXp1bfjOdpibW2QIzmlwr1GjHTgixVu4vZvZ30m/vbMz8tiYHJLUyYqC+w6qRO3qy23nwGijSpU2UHr/C+nbUqEfyZ6WNmGHknGMl3RGVHh/dXLFDAeltMAw3gVSaaS39eMFKJWW+XT0oU6sAIYXVWvJ273uvuBmIWmvkM+tcDnCpsm12KKeKelHYtK2QizuZKS5cZWDGviyoi20lxM7YOn7QTpowRqgruImY0gY/+g+bHpksLYfojGMoLF/1KJxYOPEbMESiNJcyoNrQLAFxi6uCYOD1f+dPvjmE00KDoLMxnkM6yH4n6eHe4i1n7jjDSK0T4gbJNzheHLR/phbYZ3yMFO0eaKG7nzGz0sBNzbSJkui19o9s/yWhsp/c7c/JN6JIPJlpY+HZd82H/O7G7TMWSKUJRN3Q+kx+pQX6zR4o1WYVnDkmtKOdiHgnac8kaaPK0J4GHQNAV2qQP31DcyCt0UozPS7f3GTs+z7XvTHws9qu8Hd2VKaoB3XTYnfABK/xSfRoSrN96GLKJyTWY8dGm0xp/CxHowHM7lzvkzuKDp5ZouYxBmWAZVYBroxFg53whht2A5zSxCidK/K4xcTYnjk3D55nPYUN3xB0jDHwHfTu9lMpbmtrtn8aIStE8MmT2B2VFmKfzLBLZN+Z5349Uis+rZlnK21lKzyTt1L8msD+W2fdhAWbvwYrRT7drqeBdgeb6CyADDU7IiCazBsog1qGbxu3DDRShgWtyI8HmNNBwB3KZExQBOjWn0STJhGvcNQLhhhQfFeVnni/bkKVS9DO8cLe4FPePLWh6CRtDrL2OIb4oeFeLIp59XKlxfzTFnnOWqr9hRj9OQZmeh50DnSTitS7pz2q7brXcGBfPj4F1l9d37wddGGFqBBW3AxuFFwAaq6kmhMW+G04qFA6Nuj66Vuy/o9oUY4cjmQ2rVxgJDkabnGDNWBp+yDv2CKA+YGzH9Xcri8bDvjqBAtYHRRf81XFcPonGWR0h7FxMWYKAx6Dsge4d22I3MRf5YfGIdvvauPcipyTb2bSsT2BTk7TUvakoTmML1ibHQBVAKROgx/YfmrY0ApGiA2gO+ATU2Wc9hV7xt1YOH7LDRbA2I61H1MughZ5sTEpyCh7CKY8/llYqulUOh/nHI6E23Xf1RIlZoda0nZus3wLm/YtwP5aYx5qZV5W2UAdg0hNseDtY4ghZb34SDmLCwRojFHsjmEit9q1qYkgy/w04f4Mgn9pczZjAHko7EwvCCpnWRsigFEXCJxOKQjvWlSI+dIzWP1E5LNfGRnOSU2lC0jOWKAQZpJ9+BV6AGVnIcL5l0AVL0iIgRkbcQ2+8j1xmGdHLNoxEzofA3eyod3jVETdMhfhrT9mleb5NLyEO0W2pOHy5b+CgqCc6yLc/SwhOKdQ0pr+YZBQOsdyN8Pm0fXu/ysmwEKkccBuvnHcV1yMIdDVxt7r711+KXcxUfTCYbV3fr2rzm91gNKELPdQWKBae9UqMG6OBTHrs1UPsvOurze1SMekrW/lBx0xYAW/X7v8PKCv+oVXtXDYXrJOZH2z+k1EFpjUQbs3WbqlJgHGf8t0PLJWAzeVnAKKzR12V/m2VNl6kpgbv0EkQOichX5Ix8omV3q5N6fOIonxM5jtNTrnrU7McclJ9r1N3uRdvwi9JUr3hblUhaSbBXItcvItn6FIES1ED66zTZoiI7z3dvand00uMuvucrr0yUErpc05rGlGnYUvBT8K6MXivEAOoyQQmrUxYe+XPiCYK8uJXShzqnEI+1+mda91+Q9vGQuGUj2rz9/TfQlUUei9UT0T1LJedpffkYplzdaQdYyqNxblyYmWDBhZXQ25ZiFGLYWkrTwplclmjNvf3a835gs9szChq0Uir7QoXu6HNgHhVo9nIPgkYoijM3AskqlNHeup6vSGpQujiLdQoRVeOOtf/KKuhgVjQtemIQMt+LovTAm4I18UGye8UDbpUcESJxAeua3SAXiPh7paYbJ6sbcrImdPSdqen0Yva5vBXbtHgXUWl08c5gNVuPUtQp2wene5aJvJKaNS1UYf5112BbTwFMszH11jlBYf0dN5NxzNaNl+NFKly2WL6TfnI2FngkId6NNGKtmBPDemiujAzlOFzWqmkaZt3xiGOut/iht3XzFGp0zYtf7sELBGvsrIAhh8B6MtCtzwBX0ge8ky1LTVXUD5vCw/ZSgMKxpsCy2TeBZkUvC3eFTiYjOPkb3isKv8AXQ9irFEVrCU9KDY8QbWvouLUxejOB+dUsF1x8FLCK6cX50SSxU4DrWH/VuQ8Ydz7NPAes2ysYbygpQ7QeANU98cenBW1dVSTZEDJtYbouT9sV9ga0hQQRYoiF47zPbOFoMcK6OOvg4+h1+lNnqmryYplX5Ltm7tXQ9/gg3ijOzFm9bi7D2oR8lHaGturMpZKrVcw2xururenMTfnrj0Ir++hcUi5jnVQu7x1MKrM6LIpbS+x96A/j0/YLVWbPaOxjK4bSJTcbM65aSov6uRpLIgwbk5Nn/lgzlMtfZmRoj4B2sFVk6wlsS8dk3LDgeTQ0srOB67nzdm0sUDR6JIY0zzkEvivmfk2G5a8WAlGmHEVEryuHjqDxCPd4S8Y6rQR4AfJPzkyr9mOrHeBnVTMt+QMOx2VyPVWAvtbb2PyPMG0+1ezwCmV1mzTm1B8/rgqm7iXr54zwxNOyYQmpvuZCkQHHVM8EUoSGYVg//z9p4yIcASScQ4HSFQOSeluDtWBn/zsCjJgQ68PnjSGS6AFDZZxoVqkuG2ETMjTXFE6OfyeryiO5DGLl/6TOwlCbP8OqIATLFPRE+9nwW3aqJH0NlsYfimF7309jjDgdHzDkriSWm6xlk3s6qPW2ymXvnSKe/46dAf7yPyr30nZrUkEvvKfBOlI6zh0qSBm8gSMgdph77NVAohSQ/q0FUTBDQECif0ZMzSyvdS97LmBRRwCXXEiMdD91WzLMCSOr8rDTujzmBdDZ8UO6sJi2XzfUD71pQO4a5HNe60QhqymTf4Jip9heT1FiJlS0XxOpN/N1Ze3abixG2daVuaoKnStOKM+h87T8WsfUxVWTT1o51VEFjp+scVaputClfalX6JphhrdT3b22tiHPzeN2skmnn6JGk7NnXjhZVwKclBGqlpXSOEdffyCJHMoRkFkkqBH0jwF37JSO7PWgtKofWnXqKDj6iRkaMrm9xerIcz/ISl9yh2eCFQmZTGTdp/UG5o9Km0hUit6OHMM8zdU7qH0xgGwunNI0DDtzrfVI7ZDfEgKrqfoWpIHKjuKmlDK8tQ74/z1+l2IqccEb+BnHAMPTsFb8d6KwoY67kV2eV0zJBbXt2dCKhPjXmGWg8g210uzQaqHJh+6qDppBQepIcw8qhKKjxxL5r1GZLKSqo3323dIOHZN6eITDebZf+ZccBNNHaj87QES7WRp2WBZ9aG+BScDvEbK5qWCYs3MAtSiq3A3AS7IqkFknSSQe3dBQEI2USS4JlL/mBrr7l/e2owXKOwe2L1teT8+sXfJvj+373en9Jh3vCAJPpP9sPrpa0DL7/4ybu+1S6evz2W9urdqIjNd37b5STibeC7xuhZ2OLsZMt1cOy6UC9OPhqp9Owb1FwE5llmp4f2ahwlKoDUUI+Mrb+C8A5jXoVauUslA7v7Ps5SWaIMbHlXSAxZvaYid0BNNrvQqCoigQn20i0cQ8xqko0gNxdLtVs8xn8J0RAqCxVpKvfOrc0QflemUaes4iLd/dyK/8SxX6yjdYnqGaA/QtVa00JozGEbl8d/kyoyoIfSjxjFraQNVBDMleejHDD+FfScRtcS7I83SeF/X/IL640+kqcSygQR6R8AZXzqQi/48SAlUB7gF889jra7khBWVWN6FQNSBm2cAQo56zocjCjUccUMdMOnTkefpRL0wNUrsuXs3O6pb9UkxT/1CFZrRo1qYxHLj7nsHdmniHyF/vo0fCM8psAvQVHJu2zcq6hQpydPZOhj+1xW/+kKnwIeQtAWuc0pcsWH2NKGB8jRQpvsorV5DWL7UXeu9Hcz2GJnp2qcJIV7klU4b+6F/Hky1Jg36RvudvOAqyyhF7M7SBNySeeQBD/3CVaSJjZW2sLkn/D1IcKmMMVXXW8X8AJ3ifRQtumJxh3b7iSBYODBjFSBxE18+rB+OtYufQoKmbuPS+WrXhfZfY56p+nsCo48QVagywDmMUwK7alvU7Cm5Ry1AWte2irf54hM1vVndRnzpN3prlR3AU4aum6/R1iAYmkT+lfNYW6b338EJLeUyXKYG5yApV37zGLBtct3qWpAS/Wwtgd6ESRzuCYA81Ne7nZ03DaJbr6gUCOTBUd/SQJXo/T4o6nfPj2eJYRi3afrLudG+x5xfj6Z0Eecj+7hVuhhoLgzM0ei9/RJvCztPeRQUPiJ2aAvTXLsb+YiDWm71MuPB4scHMhec/Fos0oVv4eKNkpArWVChcNhErCCnKkfJUHAQkUFYYrI0AjVZW8ebLN3Mj4peI/x7TjvcocnQlRQh+thE9ISzOpTk9oNonCu95hoqF/hwSkvU3YRqQ0vNH0hC8aK18ZGpe7rWUUlv1kZpEw8A4+5B2MIU+AcalYWoMTVcy8E5zmFzJNEND0W6qfRfKztIbo2EyNhiVZ2bggpqd4n4tIJemRWHKetm21rS2WpaHLLUmTG5V20zjNZGSsJmwZZt6NudqfmrQ2QXsfwsfhFVRNDB7WHZcbd22jNs2RVAArxOyCe/MjTXA1X1EJrSlMRHARInxru29WMSb+OTYfxRRvQT29OMvGPjKDWv1qlkABnK5VY2MtoLu8+lTlWj0tx+qrIgq6uc6k9OS5DTqlN/Mnxfp6t1wPlteiRlFV9vBTgHZLisHHDGzTFSeHsCLt55PerpwvVIEcsY8SF9b0U+0iuDB9YPSOFr+dlC4GEYBIG+1QFrE+tcIJz92aNxKNe1g9MX37XKghhZkMqZjea+RTpn018XrrkLiSl30310z/dTz5scmtk1HOV3aMdUzYIWvSACSe7zuunn85BiR6caFQ4bIBzRUWU6RYbXfhj2drCjDDaF6D1os1KlO7uzS3x1LQf5muYGrESPsVJqud34AwlRaIMMHeY5tf44H5QE1S7GrtRicQWuU0/V7LqnBgkdUsRqj8jGGj4pQbZEgDkYcgzD6HZQ8gvgBIp0XjyySIH/CQH1FhdFxtF8fzOXSp0hfNA74LZGVWEjdrLVNX2df7FM0l+ItVdMxy+ifaL6tYS3BR8TXywBHQI93OzRlQtgEh4ILP/J3wwyAI08AGkTwPpZAAKXP3TErZzxnaNqJGmJig7yHTD6w4YbhVHnaZgJ736wko5X7+iCi13OcfV9hFLEQILA6dHPgxxUI6lrBOLbeviOQgFPhDLEkPW+Yb3y6/cCf61bRh+txwQoVwdiH8G1+srYtDni+6ZfNhhqCGodY+cJUy0hMMpywUp74zhrQMCocghxeleP+yDU1Z2qRMVw0ilFH3Srzqpw5dJh7sqTP+7pUkHFoTSjgxXzwuBYyc+fac3q0bI9qfxSbofvV3Tp+VIJhXEFT+JmHsTOyKQi3LHL1Ljbe3NV5b4bWp5MuuQjki9oS5o9wbYc7RVhyRqN8VDf3FAt5wrcYuRuZsHmIZt9/AMBtF9zyrKtRoCdDELApx5xeehR2imgYo/eF/7YFQPQ/jnCCR0aLkJ8cnFZOihz0F3Emcc0mPeKHpkgyPFUwMhvHvrJPepZ6zE90Nj+4Zfi4UruYllqhEF56WGdUQf9Q/AsTT+SBVZD0rw8muPjNA0vZ7jnYxF+6TgkeofFalIA6UCfnnX5v/Iq9ez8XSYS7tXII2fAbhVUglSi/8jz/ZYLSzd36LZqqKKSTHeB0HPtEBzVzd4E7xLSZwAQwULgILrZhlRAxni8idi7MZ/HEYc4Sq/9Phh2e4BKDNcYKULNsFG8fX4CR+msFatNSIh41ydyD0kW79+edc/ziC3FrJW/Q/volCiyCIve6gEPotopfHPKIxlaYiIfu7anrFyu0nrK1JNqbITowam1wbGVR/EYvzzqayZhfeq10d1UtILPa3xmrRdbS0o7cSF4xoohAoUoT2XiViBJddQVJ3JSgDK/PN0+yuLpUg7ojzNCHFz/dK0xqbtyb/2DDkmX1F1JCoaypPhYohjt/SD1ySVAegEGLoZuvV5NQtqq0ssmmu1xiKcEDYVrn7eIoUVCHWsY9YuOj6ff9xPqzvMm0NaN99p/6GYgNBMrbvd7qZ+eakVjYk0HcD1RXjp09tOCGzcLbrf0sivDWjoboPXLpj74MS0Wz1OOlGs/MTHz1iDQLFZjN9zL66wBY+Ty4F9CfvhRWhM/4tV6AXU5uZfndo0jGRdnJOFzGqI3jTQxwM1PdfLgKivFyrQ0kidTq+QmuDJMU7FtPdGoHLSi7oBLNGKXkG5jmX6Rbo6OI3XBx5TeGu6TWDNeO7rPA7zoCOycGJ7yMQ5100mrv4GCpvs79grDRE9ZrcwYEv+8zvP225n8QDyPU+Xd5gxwQU38k/oQsrL3mem4Tw8/Os8H17iqN4MG74EhpTE9rGM2kkSHA3/S8FA7XeYx4+fz+GRJm1KknJO2aysdFnTVucFQlouZReJwKT5NfEm44PaEjKxDZNRxW1Vent0TxYy9WPL/v1bZFmNv8olZVildInMxthUKxaMpKJxVaP4/oSECZkt+rkf8OrbVxfZXzjd/QXzxUjn0OOIMx3MAEt1Il50mmtv8JxyXxSjXa3EUBBG57yGY9ElzdzP1XqqIaB21R0yUNZ/k9/PQA6totnnZwqIY7j9zAM0N/4169wMTKpUszSCpBTWFBU2nXqw/om8NLv1pDVjtCPWUAy3j548Bi+StKNaGeDujbDBxPyl+7w+gxept7ME5nQHWJ6E+hX21PjeTGsf7MFMDAJEZS5O8tzxqRSPyXcbMQ3yqQi6rObgqkoB2JJKhjPK+mip6vKVh+/PkIgZ+Z7KPfjZkoaV3g/27oh+F7Wz4iVjsz5rU910Uu+wquxY7zswq0r1WNUt+M8WP2lbsa8KSVBzGLSx0/jGmSCKMyBDJu5tXTge1qfALA4tKUXSAqLL0UXizarKocRn1dl+l4F3jFh8qsSNJ3HLB3IVQ1gJaenslsVNaI2R5UM297y2acdxLaHgEc4bnG6Ubeop8BPw0ReOdktghUGwnf5EAgSwAoq9Ktlmck/hT10TQqspKv4eUD9c86kqVwNBJAp+4/kwOT4pHikZJX5xv8kg98uZDskPaNdPUFcw3uL4+phW+0E+444tMpUOglrd0kdFWKfZVSQXZ9OTWPyRYr8/Mgxau/dyWrdR4tbc6rzGcgNRhgcDjst8rtVKu52goV9Wkx8SLe06FOuAn8dhi87pGIuLK/dv7rLkF+hOpDkoG13c76ffPcw+FicK9ro4RvMUzKw8BGTQOW9s3HNKWXlYCPZa8SDAJi/xKsMQ78tQ6OQ4bYYL6Psu3YbiRog2wH3A8p7aX+v6waBGfHMr0EISZLSyEbpumGFB/CfDMkPSiOEAk1wqZyR6jdEug1LdhbSRkBDwZQxE78XIOu7ctbo9JSqmkw09dYU+2b+WxIW8maJF2ihjIGNZ67IiBXrn0Rgf8fmH/Fx0bkMJmq7FGcdDAbKv8RuOVcn3fhSWJZZ1NXyY23OEhinPR3KDVJRPMIx9YQcBTn6D10nDRF/GEWKT/qGnWjXhZYfnPBIaOij9RdPIzK1BiqWGy8oh3VwiAyxyj809CBLJEH/KX6Tz0+vTxBCsh9nbh3CoshBztUscJECn753bswcZpaeFX7u5d/2E1RkM6kGt3A+Ecg+gNS81yq6PyeNvV/Z2IMmMRHmLXmmntNptcAbNLDWJGoBmCG1zpF89CiSZYee5u1skJLV5XmObGq8OXW7jDoOW5irbDPPbX1I3QABPkPhTr9xPr+6GPsfEwD42i1kg/mVOQRlvzBrAXwZmz8jzdrjUyrESCo4l3RXO7nULbXfEtGB7MDv/u28Xa/1QkR/NvFKck/wW3BIRUDmGOFHsFuSh/7tJKIEu/Wuj5TE6bh7gNrEV9cMjhpz+Nz7Dqkn/txPl08ikxUqfiYeRKujqsz7DLkcXBctPOx/n/oUkc8os9QPN0psJwVX7y6Nro4lVhoejNXdnJ50C2XiF6huDG+NdZQrpDOxTWj9G6kzusQNL9T3SlenjgRM/boQj0dqh5BXB58gziihpxpAM0VBfuGBawkm+82ln6doHqJGhvpCmhaRKyarUjgBOlY01yOJPODRnlgqdMP57NmhTefFZ66aam3tnJP4/U+69zLeZluzfQtKhyprjiUgj4EvbkbhtyV6uea7eyY7N7qJO2D2ioVRGMgzXP1F4oxJTkWjiBXytZu7e6OYNc31X1mtqYKcjTYIv0xE7J+4DoT3wK2k+shID4buCxcClkHePHK4Vpws5yYZtPhIT9NeePJXRLWQfl0HrOb+jcbpwyK8vXZEk6WIURw0I806s96rUujhxRMkuH8W3K+BuLgMLdDHam/v+g+2S9ffk6+d9wxomq6VaTR++n7C/nMxGxMOlmG2W02FetlyX9x6bBj4l1sugCiv/lvgYPJiJDtRon+PJKYrdIkqfuB1K6WMvUgf1XD0/LFqpQjgtvvgnnqj3RtCjDEIYXzgnv24B6gc8vH/1cEU01XXhXP/VZaqc0LcFnm/Z6TCG37tfhJQOEdQJFTf7vaX+NNrqLJRq1p9zVpC7O11JGgIZscovmhLciZMq2peHiJ3wVt26w3dT5UBzhG4gun45EpvE87LgwMU0NSifjd3tJJ6xBimgtBrswgUsdBbGg6KqM/Gfu5z7z+rI7k+NpBjUx2K/K4gLLM0WWUP/LiwWz6ixTNUpCmh4+Zs4ySf2/xwXgYgpUPQrwqwyf8jlcCBSDqB3xCNjduCio1GaislX81DiUEoWZEb5sLsHq/y0PO/5+R2/dk7B/P4jlNFgFLCw5unWr7P4MKGlGcKEGBMAlCcNhSBwE2oOCBeqC53AVeOKPXRqvv7tvr4Ti3SYAMl8GOtJdcXEtZdVjIDsWiUucpSxTc9uBj0gYMA7QbNKDWQqJg9h19Oh6XKgpUsDXzInFFVu6Ne1919y0iLoHicRmrfsX0Mtm8sh6c9RwnI2vASvwXPeJmAS8rk3rIsRLPb5riRy211d3ziGV+uIgHFWYv1SDpWn9Bw6l3CpNhj25NV4gyfbMQG2Q1cW0FVqqOb4KIkew2SRMCleZeDCDcOqosZBlWR0yBBXGDSZSRGUMBgnLljG1QifCvW+ifh57JNlyLrazGYtRlq/KogCUjVjbR5vJfpq1u0bujgE1e+Du/+PRvvUFMdt4FPsdDVPVBKIPpsQ31ikqE0Q341a3j0hkbq6lgzcYiQhkiZMVbP1zfhKMR49ABuWo4+iIhQnQ6MhH/dgWjz8/JVeHz0AoHNqy4Lk2gW+yE8IpvcTi0GYomYbis1X+FadPvX3+TSfrpYdc5I6DL53DdxAjG8H4ePAp/9xx4dv2g0xNsp1N3HxczjeIRQxpfCF03zX5FJ+zkZfvubQGoCuDYLmPw2qp/hz36Ywsp1LrNNbmFQY97Xz/F9u1lJMSbBm7Qd7Z4P4I5ED7MV2dQD+22MYM4XIrt8tXJWDoyUyAPTS9d0Qyj//mLKUuXzKdOnpT4tlmtz1ycm8g6KdxwugcGvO5yf03tt/dD9+0FcRt1GxZzrPydOhEFbilo/vGJFYLy2o97wY7CvCe8DS+H4pNHUfZ8ZRuwTi+C1Vayy0uqcVZl1PSpY/nzDBzBxRDZmIEfR2Xg13+D/cmNT2FtyssXnJS9cdAQSSFszEbSMtZNwvJ9HBRdkKr1w8xV6vnjG+v8cP/BSXTeA+i11VX3paJihU2DLs2mE6u352MCtYJrtc5/8DifIhDfCKuuj5c0vKK1PQshF7yKPmgDkQawYVLGN8ogMj/8Tk7kHQ3y9o98MrRWYCQlwVp8JHjOa7qcIcZ2I6vdfE0kvftGwXQS6dBtvZotYSLtvjsMG7yU9slKqBXuOygYuXKQFPSQ2GvQ8btYANGoZnazU7C0RN7Mqpf+FnTBekGyoM0jRd2qVdAFjHIXk2mvNzd6WryMUHt8ZgzJIgOdN63/qYFUhZKEMzasmeVKZzvgqNQ6BwbdLBU9mzw8TLb8ams3EdnWoSntqasGstFOW+HNKnXAjMReGB1jPdiEn75ggtJT6i81AW4RVEWLntWyOW6/ljHblsVS70JsXS7CI6R1WzqoEI5MvcBCjy3lPPuU6yNsF8rqp6bMx9yVPchMJkhMyFkNMjUQIZfrSwjOaMSPeUJgKph9R5QKPMPJnS1QAmRaQafdKTAe6GBu0Oq+eE2ICojJb5gTkOsMf04PvU6Ig8/qY2aNhuSr2DMmIEk0polNhZWBl2cL8z1RwuEXhGgogbU36vyzIQ4vezyVEeNfbS0WAMuAkpJH8kf6iIYXTqggHQKM0ZzvX4wdWwwg22yMiN5s2oGT8KaEw/zwM/fcYsTvbSjAm4YDhXTZLbSoOAJMva4rtD2YlQdt5ZX7lE+CvwPDtSopomC7vpFjkILiCjVJCb3JLHNb92KGRbbOS8SkXU6tKzyHM8mmZSxNT4S05i+G9tuM5+CT+ToUZTffB02X5MeFTuxixQ8p3IvuDbLcnRh8zSsa/j2Oq2bnzepXdg2hMLAZoZUCIZWSFon86sSQ7/7vEPPU77FklR+lQcNWgmpXb+dnTK/A9k4gIpheKJCBWpUGMXyQfg14L/cXSwXoyUlxL2wj1GiRPtsDV6Nv/QpPdE1JNUHHeWtcsX6c3GnUBkGetQDmSao/vAuXOFNVxCt5ZlPzVrnuGRWpCTbrkjE1PVYYy9qyNwqipUCaRw/0Yiv389p4vsOhQPcLJeZQgO/7ajwma19KyA5Re2r9Ilj7p7XtKnrZoqIEejQI58IgeQgrZ3/QiYGWSmULz1OFcqSS1/5RphIl/nSvJHVR9urUpkPn2UW9Q3xCM/ArazRPrXWfEp8/wFw51+LhdJ1DNw86bF8WoDGVaRiYcbQhRfl+b65/iG32q2dtLo5ZD7Xa6frs2TAIE6+HmCg3CYPOybpQX1L+/zXDCJK8LpR/3oPmOpd6ddFdHvCXvrrKHcOMsZZEiggzgtBCzkv6TmBllNtkIvW1oSnoOivV3xIlxzE0TP39kQLOt6kohqE1Dn4VudcfkQZgao5c2y5xkaFIkBH/s5BKC2/+BeaVy4JlT6zxjtDnQn2dAZH9QEan94LF0qWu2peQrKUHMy0LtWEIKOxEw65ZBoy22/jnptRsQRomgW3l8JbCDQayeDQdR1IqTQw72bJD45UiovesPZfhufbjNz2/lfq8UbGzA+liJa6Jr6yXN1OS3shZt9hlwKAOOOPI4SQkYk7uK+jfeLJcx9gtsBrQmOwOsoxE/QeDqUBjjcy+xpHYtfwJRwf9wqCrXFvky/IO+p7uT9HqAUbZxYFKJDjJAoFOBPDFoiBYxUOa4xMj/o2wLlqBTCsbDOshJB1PnV/pWsN62/LSP577SQD3S0yao439T6AJ+Ai4CG/DISyWLt8vkn/dWAM6g7XjQY1JicH/apG6CWhyFFc8o3dVx5gxqA93sOFLJ2zCkuiNgiSyD1NQzfsC4hIuE0/vz9Tine33rcddA3gI+UygQWNbkTGQK0nBOLEsldA0ZxQhOPDFgiBH/MI7d7L1atg+smmGcpqabANO99VcTGmuErIBndQ3iDC7u43KK3myub70w4YcUc8QGYjHqhrfZsWsLUeLDkqJ1FahHXDVoUQv8NkPYHDG1XqNw2JjkS1v2FS4gZKFm6tuj+kogZZqB+VPbP11OEGVRa9b4wNyWKccaz/azNZETQ4qGYf0UPXyYxLxKgL5C0QYtNyBnJ6NrUKQZp0MDfDX3XV9M53a7fFIlY68WUIRQV7EE/F7G1ct7bLQnAv36dKirfEsrjGV8FXJnFUrg3OyE06RnKH8tnANLl1jdqB8WkXhpPCr5E76Os+tdWOwDV6DC+qlleP0qD+mJCcmNZdEmwzxdWXlttDOMKgoxLg1RGmAFtvXS4rHrKueN3n4zw7R5jChKVtQ+W61IIAmxudgjaCPGFYBquBJpSUjOl+i7Bp6Po11h/TMkCZSeSSSGCGVvIVS24Bkx0+Q3yJuzFLEuTS9ibfjt19biprXrC8w0Xh/sNdcdfNwwfkINiZqvzIo2bkIVNhCKeLGGBvHXFoQHSyyMFV44+yhlkblFxdTQii9x72R3OJC9yXPJijc7E5cxJJ37sgWUPVn7/oyGOv0moOaoIjnA3VkpO58lqC+xxnpjODsTID7vS1tdnz1bESOI9NXjSErG8JphNj7dl6q6/AGvsBSEE5+yshIZju746nbg43rv7c1UH0aiJDG063nixM0YqIRTleP6va63lZl9F7MU1/yLsckUuoGHneGQWeH7XzWXGlROUA0SxWn2K/2I+KzFBIvmJcm5U1p9Gl5XIMg1VIVXS1Cs+bVAA5tN4Ljd36Gg46WGADxkSZMI4bSVroMmwpnKkzqMmmQzqYuqIpIghymvXtkv/MDNSw/wubjJjrelTxoTl0XTbhDiAxlAKmyK/UubcibUJ2Q/79SjBDC3j7toay43X82y8awFf60YL3sZTt+Z0djgKsmd6RHDciG6Mbw/uz9wiv6ZFRGSzsvo2TwXlz0jnoJuohHxskB81pAr14fbx66rfrEKhMXd15/Wk98RKbIuGSqg0DZCOxRuEC79Kvkr90kslzRhuTWMKRjncPEqOqsFSUmZ+YPqAv3JC3DeEnB+1bN3ad/k3dYSSM6b5NoZt97dQ/GRzAuMblBHu2oVXe5fNAE4IVytJ8uBWvqdpK4rZHETyKePu1KeLApPOBXaZjhD1BCdLUaa9W1kNBj7pLplra519KLJS3f+j6JMaEUFy/Yczwa+603m49iJ0UjgSz0oBlJY52S+DyDdLEgZKQ57BPew5dJ6KJZVA1NXmqjNrSY4wF75e4DoZ5D3hjfgMtbIlIzVQi5q2FiLtoNeC3/iuS9aUy7OqfvFXy2Rf9yqzOVa9OHyiK/9yVEdYh3waEeK5x83v6UEh1ESye5qsJpiDIGB9mREak0QCf19kufn40xJem3iotYCBTsbQdJ8TWmMSQ5cu2qrrXsyXHzqgpv7abG1fqjjnhdrNSTWehLGDO05J8tmAqO2/h/Vr/BTcL2trvNsloBRL+Up6Z3DyJmVpGQD1ORf6xdkaE8OtZdM21MNIEXT6/ZPmg2cU+Q1coJUfjO3Nj1HfiQOMseCwn5OHMz3rPFooyfegxzqwygD7GIHqQCaVHNK2AvKC3wFRJcFT887lS1B2uPRwaXQN7YZme+r9deIF6wGrNul6igoST2C/VvXeRFBdchd9qwWBXM59RZ+a4XvyFlaSRFCjC1uBuisrCf2g7pktMiBrL18go2FJ82AQi/v3FVxs3bb+tiwTZwx8NZ9Flc/M7C00KjyTrFfNkHrrjdx0O7FjU3IWiSz01zzYuZBoOlM3Qj/kUfDxjc8YOv48kDuijqwsAipXhjIbJw+Wa0nX8j73OI9q9J82t6hrxtXNpweJyKbvd4L9i2K0RSWBxs86A65ZiQEr5w6tND7NNkv+p29atRQCPbsUC8mO18seSGMJbmbIJCuPpAd9yj0oQn25iBHBDUDDNYEzafoY6WiWHwqMaIu0Kh2dsxMrSL/0sP3PCeXt75qK1k+18pkBJMCNbKU36a+w5+AIRnAM3hanu80RO+j2tGkW9FHxRbElyx9wAOwHFeWZ9WO2Jh6VRxZwLPUf+rjOmHNEFT6l1Y8b7VwJRkzAwoAlzgv/jJ8N2MWMxjQlYNG+rLtb1J0pfpouMf9rDjg+DiQ9SDacWrH2s/IuL209izGNtKdf7dbYQxDffTeuF8v3+qfoBvfLCNadEwmZJrcPqYy0NE4jlwYSSfHDxVIn0E0AciXfiuOKCaV/vHxZ4ScUMZgFI8Xy5bsujzbDRHzfsvOkkT1UcYsffSq7USLQO4SiIyAP0T4gwkIgxLWCfN6//O70VtXzn+3kN1zugZozQRn7nuSIYwra2e0aEALLNrWp08MFTwRZKaV1aPXAlKk/VZAosSFgAVMzWo/ty+RwT5r5L+dEd4ghbM6hEE6E3YW923Y5g8b9oIN7uIlu7QEBjhOf+ZUnPhxKQVoOSYwar6bw81OUI6aAoauNvgAhNDEt9H04C4ur+7A6Rg+JQ6X+LuWDK8jTjGrHKihiDPCY/MgrtpRPnguQzCRT7E2Z5ZWrCik2cbf/EEYIbd4zacOMAL3IT3R1ku4ff52w41SUM7o13ckhbFAYIdXNlW8i/dGiZxkdFPd3tFJBj8ZXyyOCtKMx0ZlxcTyUnBFw9qA/D6mxWd/Webx/htcNyUAHBWMubYi4ydwqOwkAxMuaKCuNsikNwFFuOmTiVRSXLkTDA8I19KMzH39hxs2QljXZB5JA5vq88/E+3QZYY5WqtxUyDQ06BZfzGO0gljoiEMdIsoocirv4zhlIyhMUm/88mMDKLT7rjDCrop/PcGKFp9Znd1IphbCIvivXleJFkTO4fhChzX4TWlHRkEPHxNdgK9DGROoIogj402dgCb3Tbk4iT5ugZPoBwyMCxaMtO5srt9lxQg5mAb/SH/85KwQz9mNmbyVnB+c+Gg8+dqCV2UWwIPQisfA4bjNolfPRXYoIy5duk8FuZ8SKuweKcvVOm/v4gGEO6r7uz9fNuvmTUlH81W+jbgda5LfQ2pZMge75969tYoQotdAhLS3mfjbT1RJx/+xtIJPor4Cq/SVIwVEZmHk2HEH0KZEjAiTVHxVSEyWBrOIVpmNhAoTy4v6BJ6yZnX7Rh5DiiBGQriMFDVtHlHj9iYpH3CtSlW9sga+1u0nd44/ckxAfS7+mZSv67/upELsoDPQmaskMPeSt4FfN7GDTLosmuXMeyuwMZcMZdiqtpArImUf5KUBxNNqqawQgLKhh6ZQV6QIgaryYHM2tBSjH4hOFrhmzSR9hRqO1X1qHdsTKX5n6Emu4T1AkFg01gIuHzKsNJJl6SGSVTzwp3y5wE2wwpBR9woO7i5Zm/MPsz0bOT+QUFWc3MNZSsWqdJ0aFja0VPcJBEN1fUWwFxAwKxJWfyoh0nWvd6wylNWJt1DIlTg+zCBxWSX+Yn7JbzMvgvKdSe3mkb5D0XvDMIlRWFjKVTnD6gvgb6lebP64pHPmWi51WfT4Zh2lsRezsiPPyOpxz2KG2gQQNXgqabmPUOkWQ7PBzTV78l4SR8zeo/yWV5l6E/CbFMpIeaCHwa1PgQgvWs9n3f04/dpsdXIVzYySLpkxn/rfa91n1WEs181LtERIxT5YTRpo7QPAeglM9Zbu4KyK/WPda4GdAfyO+CjZSRGm304w48lKpM6wirfwxKV3sou/3P9/kFh6kqZezkUIaI3ndPQbIoOsDOsodX4tvyo/4ePEjVp6hthnsXKHzczq0AtN7ZMnZaoDejd0THl6hL5BTUfcJAkKL+QLTGrIBMTFpUNly/TrDpwDtFFwEC9pAEm/RLN0Jf2yXIYgaDw3nYvdPdv53ve7tSVOTsLLoD1s82FlQpGNd6MrH8R87zqrWauY/mCKcCJU9nOiXbNwK/GEIXjuK1BMko35ZVxsntK2DfLo3uzZ3UrOMHJsi448YrdkRtRfuccs5SAwWIuzURcDtVlH6BtTLB7azzLniZoEGOkyQguCwHv3P9Trnaz6P3afkG+eGnTQgZVvqemrrQ3JTJHvRpPbuwQZSFfG1kFbbHx88hbzkVnf0ifKyNLG4Hj8zcK86X6z36YCXNSgtMwyt45rNlxKdNCDHXRc4uc+OhYHJNJ0a9aRuAgQowptrLzqO2cR6yFxWXsbuS8Bcxq3IEFE7tzF233n16p7fVf2HVamWanMmV9OhA/RT7M+9psD2jAB03/cWxV1bjZ4go/b0KTC7OENZddxbJzmoZ/XNLSbWe5YuMl3b4L8l+KHp5J6TfwISsM3bKG41VOX9fY1/521iNqo9NBvp7CdTxHdfI0tjSA9yqRDSrwpe7DYjh+HtopKwN7wDcFAnWcuUn1D+s15f+xhl9JUpRCnNfxUlMo+yKfdVfO8cLw6371mgcGPfXHaNz7qPpt8VYQ+mtHMrbMfQrtuIt7rs21Zvw+fE4jEs9dicDgMxOoQHa0srlu50AXZsN0yMZ9w6iHJg+6EJI3/s+Y6sLhjYup88cO19/sTbQmIRPB/dPphJ4M5Vwrbg6KewPIxQNw2dpiYHONptjoJGkWa7AtvoxZ3VgNfRlAHfUWqAlxCiBPjalgFLv197Kg+7zYlzx4UYMQoR/6YokTONwN9Dgob1VcA+wiQORnMPP6xs0gbdyI5YcFkKNVYaGV92fZX3Hf5PtgJA0Gx6+mh0Udroe3tjw29nID4eX6FMoMy2tnlDlkqFOAIIeEdFGTxmdaWdDzyEYqPyHShnE6Cf/8+A+06+uiAbqICakQHb/LVer3ZfkYIBDJHBJarLpoZoxzDYAjBIQFd2hsc0q6JgJD2g+/nth+HA4fsF4SOIPTI3L043GfKr5UbWs2qCpy43qFeLMHR3F72zdzMLyvLifoa5H8edeF3VtFz25gkvsJKDQ/GEvfeLxNaOq0eKwW+ZYCjpe2G5u8KLNKI9WaGpXc/75UQiuDd/aQqTxnjN21AZt+3hK/4qgXBX40kqgGdoPmcNU1RdKO3y0p2XhXoJoW+raed/FwXYq//YNtAzGq9a7NRDsOnJTiUjqo3nEVEGLheo/lzmuFT2NOeG4W4reH1uJtQYEnKGCbd0F+jW6MEem3H6mU7n9ZzWewdamFBq9zXlZTBv+C7HkDvyBwk3ezAfVwIGn/PaEk9HKR1jNWMxm43RIJ71m16/UO+MNvSkEsiBVs/TVRpAu5o4Md7g6ea0ORbY3e91UdhQrLdJeSUVT5HCx51PO6ZUODuW8w6280Jdp31LNOkYdIkmji0WN+TqGnwAtEtZHQ99uf1Tr4jt7ISuvx19ayvbBQ30uby1ap2naPCLmYMaVFxrD9uP12IZqZl4MJgiIsSCuGW3iVO21k6vV02TCvxCZx34+YF5Q12ULnyi8IRlblHYQSBhEsXB4wId1A7iIrtrMk+7VLDnoU+breqgKObUsFqaZAkB53ME1VxNo1BLvK5YaDsjIRRboSk6brsKncWLcOB6NZtEtVuufHdTrOoA9iVYTlCJTk8mhpVOMXEjw9CduVitPs3FhQX6uN5eiLZec9PPd10kzg3GiMUJnjGSKTihJ4Z0G9s7lEZynxowJVlcjz5NciTGi7pcs2kWoRicGWlddNn6wNube3z0dpvstlwUWZAzWb3CyHRcubyLwIsVL5rCGi6mMHX6t+0rUfQ94Ww+RgB2SpPJDjn0G70JRPewiyCXB3M5aIkt/zQ9oW0Ek3NRwWAyyr6Ytz84//Qrh9gkqQ2Bzqz502kA7kKkv7YLfsSXNk122ZIWoca0Rtls5iSA/oJqTkrAYC/zGi/E/fk+ZfLcqq5nB8lbmJJkMm8mahWF4xrU8L/hB6ru9LF+I8evsyAjhrVQpzVMuU514a+GwYOD5CpitU+0YNETEo4DTj5yVJlsH/9230OPGLBHfdzNb5FeHmR0yYun6pyziCzaWQGTnJL4w5CeE98JpLIegc3l1sO+64aKqqJinqYMo7G2H3SJ+q6rLdkUM4dNQSq3/Us6brTdQ6P9/MJA7WaLzejwF4T0WfcwJryXqNZA2dGpNrzOD5dxjZiVBUeDoUVSJGVJ8zKGj4JTmaGfU8rPvYd3Tetd/imAWT5ChnXjD+XauhGozc9En/kzvOdj2W00RfS1Dx4Ug1zwrVslsck2prLP1vbAy6LUjvo/oi1A//J5ESRbiGccxs5D40tZX91Culh2QDcW908tNv3KuNfNHRPxjgTlcC2B0iiicIKIN5WUr6jDg8a3IVlO9JVBoZRGJHpx/9XlcW2b76OSLGkMbDoCMe8CBJknUNMRfTf4+tTraap7/yIxEkuDAf7KR2UK/N0rRZ2HXWQJa7mo3okohWAbCUZ+gm2ikPQepooit/DuceNgGD3dx2i7We18eFd6mE740IFtICYsgkrQpT6+S/GigDwr3md78K8sSnOHPCgXKZq0nvfvYXWA/dPDyqVoQJjmVq523H8f8Do2355b9LUuibxtV4I8KDADyM5ldYOCXwOVHfd/FNdETMpGLofDwgA7OFo3sP+SpJP5+MSRpQ6TNfNMsjotyU/wPc3cG4Oc96/0WTf8VvWpYvoUgg9v16dFIE1tCHPf5aCwU3Q8dlOBUS4WjiHPPJmD2EfxbZN2iYjGMbacD1ehnS2I0TU2DaoD/G/2a7vROupmAouaERIJHxT2ylceMTyz31X0cVot5NuZ9YO3xa3UIo0b2VX2E2LX2Pd0x9RAhmYUBBwwguAFDN3DhjDk7UhD6lgRJFv3Xrfxrq8gyFeegOon6f79IAhsCFn1tURBudXCPeGOTHO3fNE6s1IegvPiCzyCoNJRusidkHswb8WxSmLM1bsSPlbnS+ZgPVp1qhKJVEXotYR5GSCl/4/S3RP4RYk61oqTXEXEa3+VF2lK8T+1rpzD9GZ8Kx3u1xENpRKaTQrmu2CtfDlbbQs9UBeV0eQraxOUSgKkGTltov4jgyeMZ1+RtAoI32/c7VGYFzCKjtxDuhO1g5Q1s0R75z/s5Cy3hZseU046d0IFR5LJWRiMGtlXCCmwK7Cr8EeKBuI7VIC6wu2TLYdO36nv6AHMAfHNmq2Wj3xrl3sCelI+qrl2vSbidb4W0lcVERqBSELe2Wpx4gRvIAMHyBcPsPmDx/uH4NzXe9cGCkbCaeqcVwYCbB4lFoE11E/p+pKhN88hjbm6QlwZpHL5CmRxLhlMTHe5vn9CynUHGDxB5yiGIZy0GI9V6V+J8DRPF7M3EA0nr4YBC/rrbCehCTC50XYlHznt/HJIe8feiJwiXYdH52sNbXCAbP5OtHa6ttLR4g19XSPINzjvd7o1SO0ZbamjT8keJ2pzi6X8dPLUzA6hLAASDQXxTKiolZ9+6gXCODIzAcXP47PY0cAr4YRw3QElYmXextgCY0ZsYh4VJLz4kUijhNTrw3C+ksCi89gUz9JG7fGthkG7RdB+Vy6McHbfMANH6Gb+zTd8QGu6C5haknMiipW1UMbj69Paiwxv3Wc5xj0JgJTZkm6OOnIk9uT+ggGZPwNl9fMLqLMEU/nvGd3aKl6pVbWSyZZMqJmkM6RoMCzyRePWeXW0xh+Mrx++iGYiAhzdiRO+xmafgJcEbN0a9XBN6sz+eus9FsPCAQ8ZU4dO/M8JgZh1Yw7pH7P9tMdCzBT2bJlLAFVgdjgry5OpSSXZln0B60m6sNKi8+YHcD2iT47lKET9Z+hJyOv8ljo6nWhF+6TNTAOY8nmYWS6sgrq7clsLdJeCnkxPL49fsy8++wY0Bfr8naaCjBF/TcBDVKQ5sSQ14ol3NinOAO37QkkV1dxfgwPwO1byWuqZanS0b78Zvqxq3Ae5/q+pTy2DYcQS3DG9CXKJOUzRUzFb9RIRBKzLxE5otv9yTzePqlCFpUA/110sKfm/LwEc7547c2aPiK0U/Yvzhn0HJDlNATW2KFjLZH6EE/eV9z0KJiJtBb4JFUWKIIggBffV2+NxQ08mizxWURMZ4n4t9U22+Vrj9zVw825xEFFlMvHMDB8CgGBj5PP5sxtPSvRtDkbChwbzPDT6qKfTrQR+A6fS4HL01pyiDPFy72L7SeamIvEcJEb2uBmglQ3FVvSWpLJ9i7VnZsCvzFvgY0KocoKALSBDKdU7E+E8AieZphmjY4Y2YmEqNknPJsWapOZF74UEy/qwbZCw4LIE5fPQ3v9nJOGFUU8765V8GpFlf3egiYvDE6+ve6a66i01J4IiT1uxJGBfj6PKKGKfUcTE2orHIBuS1ii4acJlw8fo2Xqn7Hm8/jO6Djcf+vIZ2mxuZdLab1n09JMr/vy0Xxs7Rx0BjCkOOyapysWnH78UQzcDC9uLMZfgHSQTFbuSYTDNEHgdsUKEOKuq3uaK5IxKVrQKW8hHr7nphLNPfOd4XMXgVIC1fWxITpflfJ80i8kwzzHXzVqZXxB1oqVoXJvZQ0bgk8FsFAtTe4OKz8kt69B3aiLrOtPr7+l5hW5jW4Zof7mNDnroHy9lihF9brYB48aCp+CYanMAbvQ1oaAHNYoal5fS4POLli7yVXHL8ZRqye8V+jKRSGbDbYbqxzgpifCaQ0bvoXqC+RtXaciJYfvuOQdat8+exSUn5zLgEdcV1TFelszm9oxC9zLiFqO3qZF6wgJW7JApSm5r4jj8i4qcSa0O4gfwwrYhxweXg01QrBoOtO0lISjppKl+5gVke5LPGz69pdmDwqcnC3rYfCRnQnqRLHNvY/sb28RwX7VNWWNUTwaTrPaHx8FcmJ/EJyCo4yXlmUVTye6xddmqPXCQijUZIk8B9OURZfX0QLg8f7hnudK4qhPVeojGJLNjO4VRcX/NwN8qSruWQuA6uCtzrQt+i9vma5pc+7Axf0+eIjViUfYNKXnnGarcO1txz49BQXScD6IlqkStueszg/+zhIiVJp9V0r4P+WHYBTf9XhxlEFMBFZJ6aLrypvLWbo8Yc6cBc6cuBZmQYvDz5TAyRJtHyXF72MCgcPfFEwvGWbz2Xs557RpL70ZXKrXP2dA0G44KjTW9Z/Q8qjku53yvQpWEdR7WPY5IV2BW5e4U5SFLNosw8/I4uEC52q/tZLQ2oSnF2nIZ+I86aNPxwjxrXQk81MCdLkDHVvLIfsadEO7mEbT0sXIxTof6PkzQPC4AziIebJHMwyLkfARXcbxidNnvpfR8xqOQY0JUv4Iym2H9nI0/BgcIQKYuQH/8a3xxUArzJd/bFUMvH0ETHbd7rzhDwuDyhAzciUnLN4L7mzjljsiiSnm0nZdKwwDJeAVfs6Ce63csHwe+UO9yx+euTLtgGj8WlzS6NRac0pQ7RDqAIx2QWiQHyeF75cJYOhu7oRUnLV3vnWmOAp59mo495wN91yvgCUx/WbHygKktce6PtuExPGnCawKXLCJjsCKNRYvPqpkRtk8OwyD1pesVOo1x7Ai6aKWGMNGtEhlzDCz6oh3p1S/mSFe+Euy7q9b2bjmnkQQTVo+iy2dqrgb5XiLvnCKxQ/+RG7H9riRAjNZjoiTD8e9HALlTpjrRINi34vPOtw2p6RSBH6MQLgas5aVRzQ8GsQiEH2EKzRsp1YTKwlZJrWlZh/pxzh+y5oNukKtcCNfUYXYO26OUQ5zvLnJFkSsLhbEabEc8c9uvMPi5+QF1TuNRF9b83hrxTPfhAhwTe7XJm4BKlX+DWDp9RubCV+sMPLCC4YJxz+pztdAq8ggpW9Rq0dBKVaFJpaO62gHTjgpjGKvxVy46SJ3xWfXgaLrhhQ4NhIlAXctzfU/xb6dnikUGBF39vLOJ+IiGIDPou1mcIcxm0VOJX8/tWlyQQz4fNWD5aqm0zTkWY3uAe8dHMU1rRvp4pVOPVzpJrJITD156pSl5Y3EUROZ0tk+xGXBlubxVA+buu78+bn21/vXYJ95vnlDcfT27GYmWRfVIvqADCVmCp6NXJ5X6bTqNNIVi3dPjejax7P/l9JehswrIgy4qECBrLRsVdr2f6lY/LhUQrvekOLHf4PF4dSUIiXcmeO8y9JWcORgzYp7sBuugITMkrc6KTVOjEIgw3xZet0Mutt+K+16sgwu1CcKE8nfhufnxLeTcFm8Ff8WX2HkWb5rsY4t4LaOaMrkX/296oTG6BSbjyh5BIa9MQDhpNwYkIavaOT8m9mNydNtmsvtC7Zsj1fjUhplCZuu3pyRjww9msjPdz0TEZa4bWlfxr/0KpMgDoc/7dDNYAxB/9DKIYUIJgrAoPMVfpCSWmDIrUVrE8EI80CaR2i2/gQPq6A6oF4a3GKiU3uHGeq8N2KKvUKXjtNTbWzDA+MHwaQZKmRW6dVutDzEzjsJFNymXxDKFKQlXJLcjvCMBf33fitmsZSTaprYrJF8aevXBC7yilA1rcG8NNFbtFj6JeJhjtxqEoMR5zQeXQwijs7gdhYtbtzahUEZKbBBsdbS0SinticOyBAU6RuXp6GIKvUfmK7Kt8Sp0/Ux0UiMWOa/FaLMGiIs8wx6Gd89o0L5h/hOWDHY8k1CIpGcEGhaA4aF9mSPBZAI1CTBxfaChidLza5+oJH4v4xOuJdG/jyRUTRQNCRAauesoeNPVi1RcCq8WapWRglQJl8l+YqptK6jouQ5HtSg/PBz1XfXqyk75B0o1PKdngMovpTuoaP6ihJIDEL5Ko2TYIpuFo1Y/H91IyzfjoqoUrw3mnAyvPPmeYKKi2yqUlCWVofseHAKGNoR6J/uu1VmgX5rvDFXOdtsTLTEy4NW3NCUTRyX/gQ4hg2wwPHMHT1wfjRcxM2zHCyHanjXVvcKzDlfo6Mj5Be6/rf58a892zsF51fnRTEWGFh2LrU48Y1ifV6kkpLTzCc6+VzX0hFpuTnHhGWznYLU/1pmOUnuYsqsuzAQJcI3a/aT5TDKeoLZpVFblM70zZege+KFIhcAgqrTY6g7P7kpnQkzQXaJJAKfs9KxUmM5lVCBA7WiuWkOMxgAg0yeEWHyN1MKthPAx2y4S0UrUwUkNxPYd2outmqcirvqP2xlNPeHVtR+QWpvkJuqwIl9dpSCm6urt0YByEm2hBEu4yHFiSl+k6rYA/ZO5FLlnlJvLaD8GoJPdg9YBen90brj3+7Xtn52Ph9U61OCuUPdvVNqelOjRmFV9NuKB1sdB+lx6gP3FUfaLXpxRCrPqqx/ikRo47Oo7Xa2UTMqr+js7qdzVVk1AsVWk54To+jG7tZ/l090Ukbeomhg0sLmwfrlkL2u9Dl1mrLGZ0tiwSMJ9CTtg/uALIMGs2Ya3zUE+sWjI29+71mwjEg9rufXOh1f079GOuvWzXDaUoeexZj6MfeMJrbqsr7mJBnjBJIPfWrlnHwNDY2r8Pw7wVcZf4WTdT5YU0BQBZqAlGL4QF0N9TKpfTqsFyGCimw4DFX+/roivacakyvQvPc/JkiL2959lq/N+fTjS3ZHoMQmGhys8C4iDV9l3l4sQ7GjrzlOWQ73ElEZiRZBctbS8bthFg5TlFDFZa5eNzFEBVU1hr1uOG1gWQ3HS72ydE09qNGCjtenx4vXBlCsW6L+bSkUqFS5/t4ILZAj5rvP4CM99L9OcE2ur8MhAYvTSa3j3B9V98iH7+AQYGOwidtiTJkW1Tg/K8cub4uie7WPmA3pGgCxWvLYqNeXdZnV3Ojlrk8llgFPghOlDqtKZb/PG4OE1fUpLCzVRqGhfUVoFed1I5G8NDbrrBIVQ6dVDx1ERVJhlDc/Baz1NOgubF/fzw+8lUlnU1xDdx8MiQd8I7LceJITT7vq1W+GlL1bsnlXb9f/IWMqWZ8xUp1g1J9PqtjJxCJgxtflHbhWKJ3fHroXKLFiXXnBH3ehor/Xs1E3K2ctulY8qlfLbOQTnlpFPDwrS8xrm4Zw23vmQUjcXqBWVRKjLSUwZS5BRpPwup0IuWGdhl4SWNXKTef0KaXxqNMvJUSH56tvidG2ex6SLHtCjug7HbDhdpSWevKlfzxZe07+H19qgRIEoS+VupxVtiIVzeGf4JPnUJKfdSJGOq6+M+0JkNpXCrRxZdvWIhAySrka3Gu+XzPxJAAL/l9cJGPJrsWEgMMPpsQJHOAZDAPGqKrS0S+n1kUF8oZEcxMw2YphWbOdy9o7enMX5E+gmrTO9Mbbj+yYq48rKirD0zmTNjAGf9ZrgKfXJfCbYAt6jYv25LgQZPYb3gZumzSFlYlUsahERB2HwGcpVZeRN1FgdNI7MVMP8EVikjrSBKqTdogWBMCEyjRagaYZ+KD66hYE9d5T+gfRz6KkvYDudlgbLrLu66zpfsy1rtc4YwY1NHorE2rG39uZnd0AQ8SpuXDFHBA6q4X6pz28xGD5VW7hdxu0e0nnYmcyPReN5PgeStbYrEatc1vx/0lbZRDaphPhjJg6+n4WE9ng3uuTtXAmIsRTG2y87W11eu6Fy6zbE9vOALLHOPPIiQGNnoyRS9QbwokGmpn7IPdIfIWT8g2IZvuq2SgtWc20rIXhwrK2WGErXYUJnPk7sPv50EoIh1+ZzncPW+vV7MGs3bVBB2y/ozmK9Sz5ERaI14VS2rbyG3uAO7ciQcCtajXEKW8sfFXotZW3m978QhfFWL77WUUKzfP8vebk2LtiDwHkkZqAK1mOygXnN8yVTq8KEtQstgmLXBxvwiQvut8KlfR23A1iyhLJle8VuRk1nsT9F3uXfa9qdhYoekmInOmt04EpE+twOs5kbVR+5anEYTqZWiYxXwhJig631doGNuOBh0VEreOhlDrUBh2c/r1sbCq00AvghMsATYbXXAbsDgwVT7jcAaVPdvpoOY70emP/pB9No7MRtngnZ2bmWd/WkZf2H3kWi5oTLFX65CBeTDgVDxZ2fXpLMaQ6UuvbwgbXKy3owHKdIw3wDht0mje/Lrg7GuXtS5YWSe9ESDgJ3oWX6AmmykYSxuNPdQTUTiDx1++Wsx8JTIYwWYNpEvRKj43bIDMuI3pH8I6gjuSH+otQkN2USM2VPG9XNvdNWOWaM/B8aEp2GVCccmqpmaYyAoP8i5TRsRL798konJRkAoMaav8Ny+tXr15tmerLy1tEmjLNR+OIm3YaAWVO16CJ3QjqVlFQ+auwLMie8Reoqy9+F7HALwtLO+rDsYejpFQG4oNCLluD3ZpeMV0Qf0fSM2bPfO0ycWvV2ggVqcPjULVYqrD125DEkpj3MOab+uEIemO8a30caLRisIx2MTDAa9xbJz5euumW61gGJOMHErvmMBABfu0MSeSNYvbMdViShALAJFY6mRcYWlnEWWUkdosF/tq/puRyYb922Of9jbW7yCwIXbKT1JpFmOGkqPMwD0ZPHd+unZlMuPGK6VD3UMVg1mauPBwVi89loG64WaUZ1ks5ITI+yOriFUdfRTuwHktg23+PLQmhg/IV0FjkNJBiAq6Rs6FHjshXe91uqHnGR4f38aZAjS+4Ei62kC/Vz67P6J2l2Qr+1LK8L+eEFzLArcY/u3xQUKKbVFsIH6+cwZL/LOs/Lag+fL+8WBD56tjSbaroeDcZtNRg/8QbUZdvXBYewlFH61rsb3oszQ+T5pRU5ojVYicRo99irEQ1LbAuQcOua+PIYDkjE3IswlUtV/fR9ZyM+0Y2OSW+DLsRnv5D/hQtugeusRqm/NcOG5z0F31bdWETN0WV7Flj4I3k4R9RACw6yvKJKxOHV38SpIrZZEoiCKr1BfpRjv0r0pZIoIG1hQovd2W0+8SyI111yL+6ke8GvQiO5aBMuOj/3Yv7bG8baXeFd3FHLnA1NQCMf/OzIsKHRsTNDrC1E5shr2dKVgnl2UBvWC1DsfrPQLU5/FoM+1Tvo6tZdhvsKAMGiDc4UQ6jRzFphl6JxKr1zYaWGXovDyBfxPGPWNlJrEmj/gApR87e+10tyJCOQshtYoGtZr/KMRV+CXCErPKFUtCvX7RB/Dy+E7u4Sfw/a8YN6eppJgn5RC+QdS3KrK1kh4g67m6xDVSxjhoDTh3U6hvf4F97fGCxSp58jN7+KEy12M28cCP+GkHovvrdTIJ/EzVXfD+yYZL24yM4VJfICe/4P/2D9qfVvFNelwElLMj7gtnxvkp6h47P3+MFTFAM4vmKRkFTKKLGs5xzHQ6xxeLlcdBu8IKWPV8kFqYYJ6KiOG8zTDyfSVlDSMGbGBgVdv8MLOmUT3IzOFUD8obXJf7koTGjqafBgE+INzYevDcyGts84ZVuD8WrVy+oko+0ETfQGvteY2YzceqVAmM5oKTdcrnalaQK0600kYlEh9htew8/ipq1261skPqrQxojb8Ex3ZDeEEawjdBg+g3qpR9qg2eLgmRu2JehC0CQsTqpF7id6ZkZjDIoeQeWnnMu9ZPcrL3K6/eEerXpm9z2bKBrereq0aOMeoX+Md6YNAFI/dk6IlBdg7GKOUnl5qO7+CCPfZFi+Fuhwvm2veyqtgeag6G3qpJKOvgz0ORQD5xCDjc8kU5ks5EDRFkbJpijEYBfbcWqkv29FaoCOqIrd8Mp//p4oFe+MJYg7tBG2oDNK4dLMxOfHKkjNNjtKPP23SbaV3WXtOP0d8YPNhwKbAE3cowGWTKGiSTBek2Rhgd3BRTaom5Du1WMd1NIq3+MbIi6a+vM78m6QIMuEWuHdavWLsci9p10wFbKqYdB22x/lM3M3OxjY/fzI9cB7BPJxuib9IeabI7CfLEEsoWx0nx+PU8Ed85roQEcIqANLNjFgDcIFlxWaGhTve0KuHyoucMaNgmfbtaSAwqjzm8cTxqiCDCMd4faIBquJy5BJD26H9AGliDoCQMPLZKTD80t+SybxVeIotBHQ4W678BzrL9YeVByrB8g6pJRsWwlhALuDN9CrKRmkGqtU/3M9OlngVORRdn6wXqcQgT8hRqJtHcXHk/VL9nyorbnj2rlrKklUGAjnV007b4TzFeoC6xat6M60JmHatyne896zF/2vsCeL8xOqnc2fPkAcv/emJrhiyBJFTj/7aJVbOt9Htx8unqD9IhdRVkViOJSK4C9Eo1NqJ1+usoH6BfWJ1RDMs2w6uSAPfso3ChFaKcTv5WkmEfE4clfxfqjhrEyg3M+nTRj8h5G13wInECOS8+qekeoAeHOn2B6S7ii+NggiYoCXiKA4wFqmBmE1ndkED1t+H0XQK6dbPOn8eaZj2Odj8LFUlTpfJ3ebQwJnPu2s6eRw8bn1eWZQr2R+v3I8ZoSLEOdwOXMkIeWdE6zrT3/ELARIR9gZdsyHLHRswLCafFSBIHhoOlZRLUHTVrtpiW37vCbsbhSUxRAhhSuvzjPpyfAnvKeBqnSAjBRJwosZ4nXKwcaLZEPBLx6eWmvDJah1+u/teZ83UJVNnrBq1KkowNEBb+JWTbWiRbQPrb47fB3ZxgkruvQJw0lsTGUt4ul6B9Q4YCHyX4YY1wkxuuStYaArGN7APwnl/iz5qVyQbrTNjcBmvMj0hVmDIflkMABv3PmHWSEkR8ufxuhSnGbpWzuvvafxvLVUW9yMdBxz+7q6uyZ8brv16EH/jECNjeorMD7oc055DKhZFRARLnO8D5malaZ7TF1k5PKCp3/DFnCqN4++U+5LqGWKUTLqifi2ba4Iz7jbot/EM0mdAa03NESLhrKFq8zJ54RDjhKU7FrXl3OqsM3HTd+zgx/SD1xtreAg8fkhPcSVQfC6k1peP6WI7Wws/dl+sUurxnjdMVo2IlUKSi0wp2BQtKrNdKg8cgKSf6lgYfO1pBWCvx2/cTAK1brKsEKoqSSh2BGcmhWT9qsvpf0NWKm+8hNHqHsfb1luttQkadRHJbKqaL+9ox4t//3koTT+FgysSxPSkQ3fZv0yzV0nHfhcMqNpANpc/XFNSb7eKDXBBe6GrVxsN51QTxrEoxOEK5y09w97vvObVNKJE7PbskX02hzOLvqqkilPFllXtPuN0x9CXT9n48kd4e/yk1ikVPZcQ7cy9Fj3nB5nuIwa51YoHjz3wy/sa6guBBLzKGAddw3poBZABtiWam86DxHTZWZ6HoBAPrlyASMJFTFAhZIzlJ+mJL7PlqqOC5MSN18RzvfJJ/aDOXJJL5+jDJPyOnXQ5qrxciYWJacT58ZnbqJ/m+uoAoo4a9UBrpSCEar/xiDrNtd/pLhABlYo6Exp8a7vkR7jTSS7HWrD6ST+W7fjJ7OkReJdeA6X+94350rnOzzpvllC+Ys8eIIBfLGnmmcNUxE4ZiCYSq7sFkciR/tz5AHHu5RiZN31VO0EAIqyCa+j089UP3g96dZtGJp17tfpg//7oaR1Rm+r1U0j7FyPNl/z64Cavst3FsdqOycMR3dbAMedyDIi96jGB6DjNkCFvI4bEhnuk/MHSj6Jp213LgE3bTtiPJtxxDnqbOrrSexlarNg4jjk8o3U8YHsasnkTc8ac4bmGyD6l1GYHIwRgk86JnHyHW9aYcSVl0lXerwbQTGXG/81zBLyhF2UmVJOWs/lYDTSN93bhHNUKUOnLvcoVh0HIuWWE8prY4HJS97h07CwUwBMnaXKsRLGzeReD8s76PoFDbqPch4qjzO7CZOeEisfs3NSuQ91lEOGxMVmVGJefNRD1wwpQRw8tzmgN3MnjSyYebuUk7yXPEBC+1mc/rSCIVTK+orQcKN+Jfz2xGi7bKDN+DbTPP9zNvl4N7LvTXWd6gbInbmdfHyC8ZoVORISa+/LuysBX3QYLsknfJta0T3hddXRu0O4ikx7Jd1yBMT8Mpc/yG+xvPBFij++ZoQLlsAJ06IzoS3pHNbBkmSaMf94ejADI/9rsYBU3F7Kjv+FfI/yjFBLG+vEupusaJ5eywcCuMulMAt73d27on+jhLxdZG508xRJFeiKPxzxDSAsXQllSCS8gYjjKVy6IfofgVDuAurtL4hT/qlsxtTgmhVqgVptvwvaaKR+6nGrX1R+7hz9+mUySpf9m/mEgmgXrbGWCSOcKlKyCoi2fPaKQ+UXXhnPKhIg77tTcWpGkaf2MhbeJ4YwfDSPeeqW4w0IS7P/DvcJPovQVJa0tfG+M9IcikqCCNsWMmDvXea/WHhvC4AgKhmlgI6z+RIWcBFrIuExAu4OU06gRuYjFSWSwggU7UNiSHERh74fjt0mo9DnPEx03kGeL7KA0mbS6x6DkLoZlPFO6jGtuykvMNA5SJiqwruOmqjYFQ9vNLTTKq3pXf5Gu29FKpLtnzgINfD10jxp5ai7TdD3zV/5/phOsBK1Z4jabx7HMip9JmbglNPd+GzTxM7bjb5TJRyddpsZekRoyQPQjqF+KwTuPYrsiMXJQjnhMc0+Do0ariEwNC4g/rli5jd6CcgT2ZnFem6giKRS6aRwZx3utVgUrw3Qa5QWGf+O0Uo7hR5t16UuAD41poabjex8tPnR31z+aabKq8NcE7jqwAeqjc6WT/RpqquDq10bZhF3Axv2Nizm3bANBUmpLfxL8L2Q7ZsxYlxhalEHAEwlhh6VcjahvksJQLaOuY/YXlMG1Q8JKoZF88QOSNA3Ya9lL5X+0aTZ+CXM46qtYPmILSXeMO6qNg96KnIJxcAKiAVu2b/OqRi9PnSxxez2vOC0B73KGzW9WXIy6GH3sYE95gZ99bQdevt17KYw5Z3kXXcFkhb9oNkImbQf2PXQpJQ+IHI/VxZBQR/3rMlWiUhUxsBEfo/7R4jaCeLM5qAm4A3hQiDwwzLtXL2Oxj6Z69mN6o3ew8elGXu0QPyquCgTZhntUlGUA1PMqwywFdoyzgkVzPENYWG6UmKM29NngkEkADcvvRPkt9AJLllR8BHuabRk1AjbPANiWVVfEkhhlqMWKsiaZPohqZReI9nE1g1vzV68PGZnKb1Gx0xaZKAcmFlcFzWQtDIqQvTsCHuKnwGnt+MS6ceCIqrCTdblePdCe08J0VU2dHZKvI/j/l5U+1ZHXNrLZ6b+8NhgEd0Ke/WYShdxSiDmCSnV29N6SAOX6LBNGa/WCbNU/XA1Mz3+ZvDr06l3g5OaxUBSAnod4iquzFC0v2LTQATrWhvMOgJcF9RAMuiArvvCv3aPH8Cy92plXFU6d7Wa+5HZK6k+etBKGXQCWD4OEzUX09NTZBbQQmV+iOyK4YVCzB4eR+0f5lL/CbWmD0clvYQLEs7zkvPqRGuoX3/xX85AZyF2U9ySOEc9H8zweUM/KV4YCnfj36gWKWPA/l16GJkTl1zjzaCpW3CdQF7/BfN6pFDzITteD4l3lKnCYN2EpVwnC6+MMU9QVLirNemF8uUqwD3wtS8C9X2fsX00CFHd7sCQqD6/bylYUQ9vAqWTd6HZVSt2ESFYAHx6457MakS821WRfFWsSm9r+aw51JjE9pXSVQmhGv1q+5FU6oOP+E/MP9l9S5G6xz3Rt6MpDOnXO+udpmlLT2ylv7FCpeYn2W45MgYeGSDpk+RXz8iQ5e3PHVcrsQ2Eb1ujuMHsK6ZJ6XE0sQWgJwfgRT6EVbjGlg2BroQFmrWIQIVzhE+EqCIksvqfEczPfho4Z6Wg4pQYu7TBFjcVXzaU3pmGOFquiT0VVnEPfbbX506hRIhT16g3YJWPYXRRHxg+lmm/5qx79oXC9LIUA1lrNs7PCXH+ic0/MhGAXH5enJXp3sUP6qlZSestF5yS0CkK4JMwMmBCLkoi5dJpidHs0ujeUb3o8irVgdpOjtnRflb89vpzb313EU9ehix6E4357DOnOwXwcPj5dNOUlhAN4oQ7XI3ZDYdVSGsBDiZIXze20oFxdec5P33WhLkPYxQP6HSdp4MMpgvqgTte1W06c4RHjeWsXjdEX8kLvoUuFZ5PCKUnW1QWN7ETvgSdX8WugZSxVXUWKsWpTpmbZk8dA9hrVyKzSbzwaliHbQltUlm2zCPbG6Y9sLQRwv5dQXkqsm6PzC6wG9uz3CjnLWOmeC6+xEvLTsilPCAqRp3WeySW2vI7TMlrnhDFoMQ7zBES1TIUg4Bhzq2+CdzcrRj4EnPulWmtY4lpHP+Dw//cg8HPvXOAqvFF/1MGGrdYaFnBtiMMWttUdzEFCUXlahfuwv+DGItS5j1+sPAbtAyT1MUZnaheTfTKI0y+eToVr7WIgFkQKSJhbPjTL/YcBTeqTIxRBWT/NwnueLKyjgJsURm9kSwGZidb3g0Z3XIH6swpYtOAxX4TuPTXZKB755J1i5fOXml1EPsv40V+9+gsXqItZ4UVVSVtDNx0UzZzEU/43tv1iHegYGYNr3GJnMlcPnQUcOxSILouRXlLVk+1hgRfy2kK286ReP6QObWaRYQPgZQVuBokWmTh+oIaSqR+2VkFyeeV7wkTdIi9900sGcTJq3I58DQMdJHRFFb1TzGldPQXdiyiIvgbTGTpSWm4jpfVhZCZAxZ6T6T+Y0SdSNQaa0LCpDEW5Q5gUespK5NLTGbnFc30XGkD1yptMUTBNQbfx4Ymf5oYoGQeaxIDCdOHk4G8ixngaCSTY9GOUa/tu2VXSCGPU5+frRyBQmTPlsua1s8tKdWZaOBEfviRUrVbr/YB4CkP4ochJyMBEwOWfr1sFvfa/+zUCY5dsI5BV01hsRuXNFMxR4R7hHvGA2rSiUGiaIlGBW5c30nMe8o1QwuYL6726dJNoZXullBeyXmNZKaTdFmneSk3xB7AGh/hjWlzjeHqMTs16u7dgv2PMnzjClyoLkVi22vBjIh0Gun8//3pz9hbBiUYpsrjZqTlU1MTWzSCpXIoMgz19fip0D+ghjUkySSP0xVCWcoiZCl9VmExPOVRCM4KbLwrmIW/eyGC3ILxgemM8HftbHfRZ/iYg6ml23eSA6Gd0JexM6kQCbdKXIIJy7FxjPH35ND6SCI32zCMN8ObS5mLWnElPWaKbiUObG2+EPMtbd8e9nKS/x/pXa6MT0r1pCrbpkYpFldyVEhpOMXYQ1r5SPZHF8IEb7F8ZEWxjtkQ49bYU4FbFeAHZc+MbujC9GoiUzOBUTTJd0M5Zm7QIki4rEwCNqWFKBN43rcOJ8Z1cmHIMZ5NM0+fr+yoqwegtAtVINpoSbPmuifG37cM2/N9n60sidFifd5kOimBOoFAxvMxTdZhLY8kW/EjQbzTp6cgrLmSgClmOIwCXiQDHo8SDdjirApM1zNpJGLhNTZiqOXMCs5ZG5VY/v539liXM2DPBHt0H3A8BXU5sFSuBz9fTp1/loZFLPbEYqMiexnn1GmJ9b0idMx2O0VlpfjOSVLRE6Vjm7nNGU/d7c+Tjl/kpj8mRmubMpTlNKOsy+3JYDZ+t7y+RrKW8woJCPPaNRO76GjtgmRMe9ak3h813gQigvrXoH3VStji0gy3IM9EFiZdQ+I6e6ewDYlHtwhFdj1JTGfAx5FNJuHPUtCDvzgzPM8Zb+729FmZ7TAWSMZUkRR//VQi47aar2aC/siMOzS1AUWMDHhvi4FgiXd/EQcTNZpxerI8i5DvS6feOcjO7nzvziyCFO0ybaloiPxj9z6o+CLrd4ovuXY+ALTHt3Xg0aMZnKugha0NO1JH86PPjc4/kAZJN+QG9bNYgftzMXDLJrONkxYd9LMMFHNRBeFHFpe/S+Pj7NvII4KTnjJZbPzuOaZHl/ut7yaR90+ErPEi3tqqoT7xuPhjxttN7ADpZGB+0zJjufqUhK9R1gKuUf3GMNEbNpLvzvv3RDV4Y0Um8x4f/LgGTl2Tr3ayt+u966lqSB1uA3OAVgX6q4D2pZ/k13YUrpGZvNCtru51j0OW6zaJmM1b4706Suwi0+byaQwFUFMxpWUlHYpBr1VQZIwMLCIYLfh+jPV9P3bVrWS82plc9cfu+eFwCWrBaKxJbOluPAoa3mvXVnZ3l4F3XWtwPbfT4A4Dpx2odN1xURdxje7X7iOhbT2msNP1prUW2gEW1tAXHZflXndbTR4RdkaZj0q+i4ap3mUon2UzeHnm9lIBxfNyI3zDmkB6Ju1JRNWmzLZ0WU6R0EU29CQJc+qGpFS3aqfNHLHpx9BI7RWFdwmeHl+Ie4/iwOJy0Sh9u46w7hcAuNRjXzqyfoAStzcp1+uhoKqPKM1UFxsfgbUnzVPtnY12cz/+dL7sdbtcuYCnOJnHlwd3/WloCJbQXSF2hnfGl3aCdSYViHiXFpAkijjQ611uIg7PY9smcx5MaGIjD6YCLe8gPTvIxp2pbxxZFof4/cET3f7w+j/tcyLWYQrCtsIqeV9Rnj+PZN/GtSmcSIuoe4zdnOHECV4Dwpvay5iLYVRaDfeuOWLgQUfSTnK5CcmkAa3+c20KRk9mN1HQ7FbPrSqNkpz5kyrTXQKibRjcVHivq+0FgKWZMglVjoLf+MSpba9WI/gJLVCQ+RPfmTU0tty9yffK9RDBxl8HioS0J0A7rQHmXuywLRto91igt4eWcOaDr+E0o6yAkCV7Ci8jr2WHtFaUSAmdCs2YVpd4D99s5BAM75bKfP/aSl0uALi3p6HW6fbnojNH0OuUYB5J1ebbebxbHzTJnVYoPoJwVKvtuTPKVGfqbhOjP/02i6dnqnH752rKmmuCdhOW3jQu3kJ/NLOfG86R/f7jR3Ga+WZj8Y8hmmuCRsj5yGXVBCgfJXn58aP241UySq83OJkc54ehloKNZ9L7dgS30f32a8PfWAWbJg5/DDu9e5cOUpP++l1GN29npe1wVHkisV7bsp3ErJBNhtcMRWp+20ByBYQfHxQ3FToLdBmj5F8CZ/8jf808LLeRRYTOPO7PQoOosj+OMXxDf2CHCGcPpw4dx1HgKwZ+L15i9ZmAH79rNK6cl5M8veSLm7TyDKs/nk++3D3nubmVESzSTdRsolmkjJjJFDCghV13+JkP4Hom2qC87JpjGpJPmBCG1nZQ/nBmOcX4dFtGAo7QLZKFWGpOYwigXGlhLNqxC3GTiLKwqA4p3YB++jQrjNIpaWBD0hEo6XejFxqWGL4K3CJTkxkC5yjuU9YJp0si98HAsdORKV6YGhRUS8BU24qM47VsjevdNADHfe5gRwg5FSeLaC6Q6zjI4EmxMvxqCay5QiKAPwn/eKKvW+CdQEDctQm4sHicLprd6OlYpcH56FRaNLVT1wuTz+RIU8TcXcu6KPPehNIf50RgM3FpDlm+6wzjWNKxPsgEzx7b1yVn2RAFIvr3cGZbTK5boddWVnKOJ9QKHdvs+UsGWY91jWvGOiPpFSRio8NOQ2M1zyAU2sw5r/BLrD98S28Y3KBb6QNAxvpwLI3bKHfDdoDJNFkgkd16gW3U9Mq16dwfrOFZFuwsX/cZyIroNqHqoJ0FqCh6zbeO+aL2cV/6TK+HY5PcbtE2md4kdWbdD0CF+nmc6ZvhJJyRbmEV7rAIF2aPSaEdU2XphMyLS9SH/LAPBbjzas7CB2eGjAjZAB2wCn4Ms6E75IkRtIEkrG+IJGwVAsr/Irn0LgGiDvUcA2QuW6HAe+M8YE5Rt0stPXfucL0YF0647uu7s5+sqBs5P59mV5A6Gl+lje/Wo5TecROZMS/BPNj4m4auzw6y24MZXQOnjvRvd+vZ+TwmvXY5Ot4qmiE4AB2UCLqtApMFh1NRgjtuBoiGWCt02r9Ftn+0KKxtr/EOrsrMCQ/+m+6dfxLPFtc58F4Z5RW7nD+jVlq9viAjXsEdJoMN3UghYHu5MhFGbolYSIz47IL2Pl89QYl4/eWPoMGYPXWpbh5vri1C3mSBjorEA/XWhRslIYN+OgLCwRRgJi6Rxp3ESfPxB4+aENv81Hrs398evNbhnXrUrFjfpfW4kybtHwdLyWFr8eiolh8PmSLStmCRddIp/pKV+v8dqCTq9awVurZ7LeQL+NDp9at3PkNQVSRAVUPEsMMNom+SFO2EHJpGvzwa/TJRdRc9FO4meOG+ZKqP6ODJkgzDZghjKt0C1oGbbVB95fxdA4jkx5Fi58+QlciL3Vg5w4vBXT2g5aIXrFefvhq9P9Ykt8GUHpudR2MI4+m3o+bWM4i+KH61ldw3fRTs++g9ArztGfee78geQQGil7tKkv+re/h2X2Jpy6oMnG3D07+GRGx8GrhlxM0da0QWGpBqBOM3TZITlKNLQj52gJRy968a237JeUGrC4ZIlaftrcS8wAJa+TN8HNRqMeS29888OlqtIip0psOTXjl2MtQJfHnsNIbasv6OsQkhnJ1N6F5PG3ogaYeoer3Akg2JFjxGhMyFaTXADCrsYXfMFNncfLoYxpYA/oyhJDi4jnKsgkLgJiXwrW8N5KPZANLUQgrGnB3syg3XIj2JzKVNHZH7me8UKcS9X/aJ6ofTG3pHtF7zUm1xikSMPjeNOjnZyGPlJT6F/Psj5aLqMU56yOhCG1AA9h5o6CLQ4xZsXERCTlM+dMCsQllUxe2lJ2LfALV5LyY0c9tRzsOhHC+GBXKdYmH3vUu9HFbtIMIIz5pwo9wTgJSoRdzTRpK/gltF7fEg9azz+qcNtac8YNYnWPVkBHd0ugKckgdKjypUG5okSoJzKExP0r6NFx1l7fsx+idIt8Lb6Cq8WmWdUoeDdIesZ7PynMdWJN9hWG5svrfQ6/adEw1BKAwgXxNpLiqTvTn4UQOvaHBtzLNENN7ZuM69nwtfy+TcdxXqxUjNPRPDmLgGYoBZZq61+YYoBteFB/0B27byN/nbRtieOczXkIi+VDeIdrO6hG6ubMKVzJLr607bgKgt08dChrb+ZO/6R8sbg5fO6m/dpGj/v7AG9slMmmEPcze7enLeXWoGY+fEApeB90co3LEPvIMLEqRlzz9g0zk88W4tiKA6CdI9R/DvOndrf3w9cOc883pTZKezsxej2NVVVxqtOAJwO0HiBiv1uV2Xa6/95Ii81iXLuOWf5C0jFjI15sonjKvFfvmkNJdS7IGWJdM15qtDCIfr3ZPT91FqhrvUMHssPKMUc77L208aF8lOwpLTUC8bVdtpM84FDyLefixqs43ozk8/s28xWu3WzJivz3IQqgCULDgPFIAK8L5vcTe660Y+JfiKcgPngcusdMAinqg3DEB8h9HhgRfr6v5SPcgB7wTe/WhuqDx2YmR8DVGEtho+fKhy8b0cFhZ/q+rfm8oGrPQq5yAxtj0Jdk5s/NCMYyFGS9Mq7J1fOAoYlZXkaJJO7vAL+Riv+UtatBBKjaUEx2VUIlZ1b19xQuhvxLbC1QhNSxmyza/cAz7e6Z3YzvR63j5gLfPo3LY2t4+m52LRPFGOPQs7dWmEwwAqzYCSHv2jiSDo9SCjZ4j5O+P3agNvTEyX2iP4CoYNW0JRPGkxmTtC5p345veLES+yfI7AMAj1FDGjigVDennQfelxz/AWKrMh/LhBDT/ZkfSh9uS866y5CwIWh3J8iwJjBLRYGUhRkC6oC6zszU0dF/8aJesiixk2oLrvQ0W45Dwej3eQbxE22G8tctfo+q4aJGf4hpE6wif3MYyjMv12P2QGb43q8dSxeMl5RBf2togbhJ91A+mn+i1UZrIckeyMQUAZiM0AKi2uWHJtLGdoogWd3otlICLigrU+8T0DIL9Cm6umtepMTJxNfUUK+ogwPaKxPpHFzB17kIgdRnlHx4mpkxLhUGZdso3HO7AuvTKAs1skkAqRL2rrlJAQ+yVgZiIwq0h5dOHwsdk0J302Ny8Nw7CPLFKC4aOszXKtGhEUN94L6CgC89tydPvmhjjIJDe1tWvM/vcHRrNR/aKqDoC5YP6C+5J2XisYIV+8dvWyPb+BxxW8WXFZI/dgJzqdlASwZCaXD15MbmZSSqGLhpbbnlllnFsNx52WGhp1k57x90E3g1c9jOavFJKn4PjzZhu0NgYZ6qulov1cpCREuMAniq/47+5IU82fmNAacQTL2gEH5Wd09okiOvRBvKYZuEU9Wqo1+B1gKRuIzEMSszwDiUVpb5UJZVxV4Jb3uJeyDZZutEUozL81NCLfdI/bO8SOHoQPJLRH/4vtQFF/qn3+l+mpu6dek/iCvh9BDHjv1dNvRdzyCpszqQJEsuGiE4+Osm+eH7u5itbeHaWqJv5x1IktdITS2THJyN5qjyGEFge1MNsk6RBOfULyyo4AIDouwTeuvMob69PxFnyz4E1fHqNqul7Is8tinsqp9wIl9j4lB5ezGAHqyqEc9odL+PrVApqtzfIoYMB7FJrxtdpO+gaWf/8IClYU+PATZej7tLjE8rZZ72u+AhWF2SJJ5OoDIlndgRWZwK4WlNrieHHCDqMLTSrU7ZdwNbipSoWFy1uxC+rIoSxhpuOrI2f05UYsPoplpY/Gn67OrvmJwy4+xwDVZzx79eOO5bRfC9vPtOBZxCPQyIvRWvxje9T1x84yIWN3+F96u6s1wKyxyGZp9gKp5x/9pfEOop+GK2y85oXeyCKijJq5pDC9LcoZ2st3w+MXNVBipSwLrcMrq+zQSt8nso9tfqjvmOauJBkvjjmP+aqf+SDKU2s/8yEP+n4X8suaQS1aZtYBozRqch/HcigEkT3gyZqceMSOVGYifgHcZu1btLXIA74evzClWKGTQDJgzSuQK3jk6PGYHTqK6XG7kG4VodXNk5USlUyabPnd796FemH6UuR5jMIn2F3sGMvIxke1nsnGh8kZkYxtdBlrJKSN36QcGXmQB4mBuAX5va6CIFbrSAWvnxoX+MJQC5SR4PhnYgCDrmZMdfxvUsTluzYODNlYK4eO0A8qJbncs2I6s6M8lQ+Nnb9Veqt5zJFbT9DcMfYokZcqAjeVLf7zuADKcClIIsfn7yZccKMwJ3tAjC1fDeAd2OuNDn2L6x8OPfhDli2TAktY5/k22XzGdfHnvWnP8yqWL79BQ1yRPz50JSlAEQy9HrlXgW6M6w5pPP8AmJ9d7JnB3BcJmJpgHW7WPOZcyY+7fioesGMrsf3BbT+pH1Obu6dpZnvKE8QvcFUKYrGwLeYwP8dyZ+U495vmJN5j2ALah4JeQB81NXSgIMXcoDHanW+aurb9LS5EEUMxAsBISN/cOZ+S6kIyBCZMt89jIevTq0g/1AwzOY/i2gzczAZoD9lhRLFUVgDyfQPiM2vigA7KapP+7o4eTv8laHBsEVmh1QtM3KQdi4ruResau2AxLg/s0mb2cBVWrAKIu2BYcrnYgb0kfj+4ilIgMjpWd+FtZJVmMz225DsDC6JMJh/igDb4HYChECF/afGK/YCYdPLvOcUFMoax9C2ivxE4EBJvqKj2Qp7UWf+F1iTFTMcpDJVSB15s6sS0ntLWewCO5N00vIosX6BUl8JoJjGhxp2fORYMPMFHT8H4qczjPTYwgpmtElZDXyPy3+8jY893gHCbNR7xcDSfI2US0hjHPjG1XFnEOY8t8dTNDYGECIWwiybGx/fPW+2HYu34Op0VQPj5KpHrAPj3i2D9VcdFQmu/SsAWMqa6AFo+ZKNVVnNE7OkoBbZtT4ogFAmMsY9PQMc/VVctULMxPGlYFOsfZ6e+K9tvOspEx9Z94eE6+CNoHOOm5+Pj0zw3c833+pkGQqC4ipXoNFrVtT+WZwG47gS836WgzXTX7JzX1pCxaeZ/sbldBoc990YC/zigs+kjk16JQVv0GbSUaN1fb2iTtn1RXB/NxdevF9TU5Q+Kdldq9uUE2BTVNjcWJxxWu3dJKer1WbvAZD/IewzN0SeYA2NX9HV8ITV6451fA99ZRtxRxdBPPM9TNRW12fKTSIcv7MuKoaWTzg7/wvYo3NKvIvgQe6n9CmG2lsQQ50oJ+I7q33z50V8wqcfMb++bf5ky4FgKPFYVCKHFVxh3mY0EkF57cvsxorUbbTs4HHBwPTugjrjqy+DKArSm8CogMBPBrVL5PYuon19IGoIlQbI1gXW17fg3bly3mGt88xHrCdIJWFQloSoapQCvV91ziBICTXU4SQrLALnTb1IVa4EfB6GMvk07DwHEOQPOEzkuzAtaY+jJ2uRAQfePtufp3TZLLcgspYEXRdQwJ1r27qCO2YsTngXNm8kQ8HhAkV/9mWYvS/hx7wWmbMXj558BQJnPqfPUHf4mMQVxhZfykRZscZvMFT7fvNiXACY9Ap6OIz00/yoRbqMG1dwB5POTcWnvAdYBCMhU5VjyV06fj4JIM4GmR5LQsupjnXBz/O8UNL80w82Ezqs4dPILcQbLlBnFkG1O/f2CLi8OaU3/TaoZRoGghYTTKA8nGQcR1ejtXr8UaGN9U3QXU5m/JEZAWGbg5+OWFpAz6Jq6cinxcNle10zRDUW6VoNVG9T1nlONmylxy/aUir7ASUqcVMkPm0PGMGIHBJbogGBYtHzWSuakoFdZJuihSu2ssVe8CuvSYVv7ruiplWnk099K7Xodw4iIw63Pm9og7hWWyrP1XjrgUCyAn3AaVYf8ME046Q/vJQEbBFSX7zN+KvTh4R4xFtpJe2exy7RPGEG0bnztY+XGEGzCIhtXjPlOKMx/Tqk7/F9I9Sc7dwldxJ+9RRNb2QVwARWoTrOsYFaRIzNqRp0aLM7JBX7jfPEt6/Jcwg5KMR2jieC82QsKZXspJ37zJotobZXTjdWq6W9d7h/8bEe2jw68HtihABZ1SstEs8K0beTQ3De/ooCi05wU6D2V/grGoZ9xvXUMkegJTjeTHlKc61hhQn8XJLvIb0gld6w1A4xHrXlsc5IriT7qytNoXpL68yStS2DYSTD2/t0PKV648MSSVI9mVV/SBunsJ9+avTXIIqOCM6YNU90GKLueZJFTAAkZP+rWDZnbMy2fblFSy3TwRcHOKd95OnetyUqLqjbjRL315HjNbM925+vfPE9iMnD1L+1PTRBXXVaKkgI5jS58Fs01sFkdw3zpHsVuUA//JxeGaujzFlgTbwzTqvhya+ZJSPUNm1R5sh9Xgb6ESyAvyroci3+I48D5+wf7Nz7qvIUhs3rSDphU13cil8CwlK0m1IBpJtkcYv3ygZy5LowU4u/EI0la1yjU+owymCkXxWp8aZNxOCtp9T2XHGJT01TyG2jtEYQGjsCevlOe7RWPaozr6hUO6sfPAmVV6jvVItNHAmjNkiQPC7axBQT+kwsSWW4jfUJaaFW2Nfd1h1mQ1Z1AvF9CAKFT+jUwJTOjku8+jzCJxBY2fguYCp5sGA9UH71sW6Y/5a6nDUABtoqLxgFnJeiBQjBzOlX5b6H484f5VxPPiB/R4QaXYxKP2BS4jM1rKtoE3OEUR5lQyfbYlB5Ny/HdOhGiKXCG8u4CBZK+UUh5DI52zgXUaH+FW5GX5ssuEPjurkaZRXWI6BgJ6gzPz7v9/2T9+8IOwqgX388hWt8tKfJ6EgROLy7ulJIq6hkCmUK6yogUn4WVQUOV7TT2GXcJwnXolsqkVhULpRbv80Q1wfWCTdkG6feyUNqZKVIIqqOKqu9XWQ0pJH3v+05uAXdmErBm0h9kYCIYX7NgJBauBRnk65W/D7HCAtqvjxjFrhfHHXH2hpUIRTHsvGo1MrrY9yy3HlqEHGN4hrBeVlq+DAplEgDvFePkQsOLkXepxPbalUxU9elkTuwiXamwuq6XyeBfD70SouqOwQ2hEyz8QoMyzOVbgElyVUoclEl3t1WrCZ5xo9Eeo8wReq4GRzZuA2Mg/mruN7N9XmPvsM6Rl9EwxDmeLvaR7h043BTxAMGahqHM+u6Pu+OZ6bkRpPelkKKu9ugNvtVUGBXP3TinB+hgNu6QPpmrr7EgaFFdMe7jj5whwq0SsVdcmhjzniBtnukhv3tXkM/7eWpbbKacbwNUQYTuOz9CiZc48KfbVyBHVaN3qBNsEhsj7ruczIgA9CfJV01jSRD+/WCI3DzMlCnv+PO54QzkO9cgmAB2z+SF/FdvdXHH9tVHaqBF43VC5/t0V36CFVgOliKd/mqHI2A/46zKgYYC7wovtIov7YSRsRjqOmEP44eYJhiP05+X3lRCxx6EssPZLqYY/szMol7pnpze4F31uTI2h7pVmWXRKItasVdeWggNsnLwyl9xTMa5kHdUOHyoyzLeEmG7DSk/UK2NkVHlOWlOujhE2Qr6UM++NnJ4wErzabedFHyDMDne0n6cpgo6e9q+wk7ZI3hIW2nSACYrA2f6y26XA+fESltEijegsbpSMnDZ5spCwdV2YEFLnTUs8RmKXXGZw+CMD2gvimmwhPW61Dz/yrJp4DDWhhWoGsdUUz9IOBc0W1/MGA+l1QY9jHhCWWEw09gT4p3j6xgl1bkIqAC4lvcAZCsphUlJZbuK/6mJjEU4OJhs9voIcClw0bEo/BzGkhvXgGRDN0cm6zPYlAAQI+vylGjuPetnPXe55OMUptIFErAbBRfY36iz+orVGnObwzGjY/+9EuyEWCww7z8NsL6Msi5Ykq1Sdho1OgW6CQ12FLI45zM6u4by2OR5MtYSXibTWAlnXGFgSUPAp99WmW47bBni5XJuByODaXpdC3B+g07hwuhZF78HVAXli7VZ9hfHd8XNMZRZheoajjifn5Wrksu2UQCSp2jZPVCSzu8szBlZMU+xRiJoTj45B3t8vcDRIqiuuFt0XeWQc2JxSBVWapDF8CMhc/TeKzTWz2xXzvGGddmX2b1VM6E7KRADLf4cvhImAnv2Gcap8clcYg4Y6q4fHSPBMcyDK0WYib17x+WXLuDdp/dBrEMMxtjjexCIovcNfUZtKNyQRDxTg8slunjz6n+DrFkXDP2d/tulwn2RKezWoW8qCJl50E08eai3Rgoejm49PdugUxnGXAI3mgS4qtFMx/85sl2mYNwMgO4fk70jLMmFxLqng3A3Gd45XCEdEkvJn/ytUDkNVCnYU2de7XIrV1//31cG1YwPk7wv9kqnkCy02V1qFXhNJGs+wdPMvOIzG9kPBaxgHAc553CJrBFYXztNcFI3Dqv1+93YUKCMDs2BBhFFCWcb37WUn1BG23h/u6lJ0H9WJw/lK7xj/iLTzgXjwf9+CCJFyafVvhMc4Ep/SlP1n416JWW0hruzGJM5DJzqXdVLBTC0MLAVTVeLDptlyA4YuO5sqfFuUx9Y/D8SAWH1npzMdBrrwRhQGnb7ShussGaD2suci3zWpNlBykK1ZGFtUWchCKdlcCM8mYEqmTggBA/9JB5PbOD1mM8U3oxN3cfIUHyAZrUYb/skt4wJuy5f7bftCOA7M5Z06QEWsJ/paFtuOGWH4yz5ttvLKJb8PM/q15VaEzSke/M8NOodnpflIfi7UnOLQzcMatjAxo6OKFNMwuoZdOLn3nGCgzkwsUdERbb5peaS02a4NjgP+zVyeah0aO/j7uKDn12ERsHqubx8RayBD6QXCL2cJH/IvYBEoGrUIMxSaTYDZizfY2+C6j50JgW/MglIT51El9AGOUj1YS1JfmG6v85zn2UKNqUCLi1Of/BYsSII5Y3FPv1xVrMpSdYBRN1rW4HHxTeV1Wh8azpLLS0LCDYnOm2sYduAVtcdykVtBdYLf09GTbOMVzFi7JoPukn5etUCAwjdEwzMKPpJYi89RVrls/6uEn57C538joIYvLhdjIC13g07cBEXLZUL1IeT1r+I8MiWmAwlu9prSstvYOzbKmpUaV5uAS3Ysn7e04BtdBZDBEC1MQ0N71naFEXOYXkGCFtjLncP/2F/JfHl9MPgzcYfUVk52iUaWQV2tinBX8lBbF1m2cUfRZl8N/WFXYie4H5ic9D/xb/AJTkdY7zkpC7oZvtoHI3RxYJdPgWbsBEpNCEN3daG5HoCOb1yThZGJzWTvdc38ycBbDziaVO0t1TXroAbD3/jGcFT6zuYTLTImgt3DrU7opW3lbTiZaAGL/tN4plHKxE06yLuH7xBldoOSpRsNemsDSUK8giKphRvosH04ltRAun+tC8tVYeE8ezSis9U26AnWzNh/OmqGXFYlsqmESKaCYGKoQMYVu3KcxWBkxvtj1sOwCmWup9Ub+qD22aI+PSBmI1hP+8qBYPsqizWhGRcWNZNEpECq6lDehUW/AbNG3FwaWyRbsoE9D1vLFkEsXwzpbiyKKsfxgzSWdGaQeQy+5eCWBZJmWHa3YJQ+PT1mRERP2SyeVaUblMpFBP9PJB7h6+ZBnrv+wmd5rR6ynL6LKCo68E9OXnHhvqWOS5ozrBUUNh4sASWTtzYW7X+mRaKPVmY92YOkFvcCrWM+bZcgqg7PQvNDwViauicJZJXDCNcSxSx6BFU/S49JY/ZzU/R2pxfcfiKJybl/Q00YARBvntFci6DBbkXrcrV0Onm5QkZQGZ7IYRzcjacyb3+3D9hVpkO2gLBhoWg2rcbk+zlL99wZugOo6GObSIhiQKrCz2qcjhaWy1eee08npEwJqePIAur2F1ZGmot/1TVRkT/UN7+yonmlmlcKuWj5+uU4Dte4r6pV0ScNRnGjD9yWjW6xMHkVnGHVmbkLKVXdZ2bLfFXAT/Cid3tnyAakdvIgZhq0wjrZYyUXHXNj+6y755WRNETmx2rMQy3+fL1ffxPwSiyh70WBytU7K3UfScfjfMNQU4ob2ifJOH0yFAFSLhw8HZ+MNWmBo5OZbcicikxwVhfy1du0mZoYoteM6iDMGejIM/W6iKXyQ9aI+I1ffCRph2pOikatVKspqOZTUiVbYsT67k98jAsmajNkyBwJmY+osQgvBIvhCtT9+Yms5+EPh1vz5fScRzc/q6w+WOTd7SGv9K7pF/TcFoG9MBzxhLkk5v7OmzyY746CprIM3pyDadL5ON3jsb4H/OPYBNSZL/Yz3BY1T247M/JIFgivpsBSh/nGiey2MRYdQQPsPUYst8iNDfYf8g/gAltgVHlY7VT9xjlhQsqOvGGM0fpEvULzRBOS71k2fFou5oB0QfmBCnbU9U5QDWI4ycQqd2fPGekiwuSAH4h2qEBBeIdjhAxfXtJFFp1Vxuwqc6YwYB20CHthi1BXPJnEEbKkfgwLJskfP1OACEiqyuEz3bIwc4nLfYYF4smroHkieRI2x2uKaHEO9+Kwgqa5yLiNXeB3jXxb3z9Ygspq9rqevF4Dzp6sSSBantSRPEp2j+KQTcTvAF0enUa58hv7G5DWz6OCj+kZRzr+cpSQkx8fc2v8D0IsyfzOyO1QUjvpFB+KiJ2fKPqFHaR6zrc8lWGujvmnT2/BTTcQXA2687eCd1xQK4yXgkKI+ilgMNtZ1w4IZPrtCwKlIZx1PjGgDqT3eYY13Hq6OBX7/Mi5ThYelZMneIK/EXR+IDfz01cULJQGCi6pKJ/cbvH6C8zsXVXVKWKmD4VZQc5rNFaBkEbEeXSJGgq8tTfmN2arT7xt1CxgfJF85ICIlZVTzlqF4YHYtIFhP272Nb9k82d7zZDD8nx3bRS9I8I9lqX42Y8xx6uS7iPj78Dto8WZnj2Dp/IklTYjZSE6fxcwUBVH6s0UdEK4CaJvB36OmP0ES8E9Em2gM7EgNqCfJI+hbmNegWEIzdYnJxOK77q7Zz7iYsvAmxNgmPrBA/maX54fyAhEBwyPcq5KiB68Vq+Pedtoh0G0I65c+7xPF/Ywme/5O0iGzIsdY1MkKtYy+NyT93TfuTKqMYnWwENiuElRq3u3yffqCwY3NS/EXI1EhYJu9JWZDuiK7JZO5DEDNJIM37ruWpiZdeCvauxAYU3rM1IDJ8SYMUiSA22g3aoUiIVLfG1WBpokv/DGWSKE52vsyHweIIGGbiqIsgxka5lcy1fL8ZcTpd55rG9bxyBkS03DRlbsIfvGndNpuJazBBAmP7UkMx14Bf+ueHaW6INYSv+1N0yPfsAkRV4y7I9vsyAFPi4vcMjPS5ESQDmcfhdvFkk61t5yxGzE0MIwqN+aN9kVvfFVuHTPUgjQVTeC/U4NvKGlQ/oy0F3eC5lVTb+IxuyyU+HozgvXoipBUngsgQs9vlS2MFbsAcjQPscWf300ugK0ogwJMMqOZWxXbaai2pZ80fJZmL9/L2P4PIYEUhhXVr79YkewxPiIXzntKyghLYwqP+x168zSIFQ+qIbWEGP7IJpdOofbZ0pkm42X4Zus+4sMFaO/dYQctRiDSiHpSsF9oE/2PVBogpxZQ1vygDw+JnztacQ0sRcCc8E3lM3fJMwnCGwIsRpuRK/6D6h9N0JJEX6vA0BpNHulxdf6Kdl5AYK/IoW6l2gf4FrpoTaDsgPCPezfot+PxdJjxhx/VoBn/lnbfMqnwYp9EI7Vqs5AZXIBDikD317YpaXbRxqbOtGdPDlsFqIJo/Kt0jJwDIvIkMrzziffm+3Daa6mcOEh+dNXNn4R2HQvLHmQRNEEQ1i/FeaJxS6O25/CiByds28p1grwx6f0KFBz1S2YtercVjpaEnRf3H6bKau+YH7EsE/Qhv+wa2tfGtm/ZOxpD81/5KX7a0hUGx48b8qlkqXQi8jBMQeStZjO1XDwSW/9qnMepY64qR/BMOzme5k6ysLpN0xDXS9p0H2Bp3RND3/77NX2of4Kz1m7aZEt6UPoJsrTsCcRWxH5AKEFA1tfnfsKj42k9IvjhEOjl/y/AYut/+Nkt8aMwJ360hV6uVIrfsiBM6Qy1yjMWa8w3JI9r9vDZe96H4xszqJpkLNAVHDOIf/ynJlhWzwzxqpgSNYLpwCbpGnAJZEkwwT8pU+dEyEfU3gx/CkVFDIp7vWHyFE1uqfq6/mXSD78hZyiby5a9xlWboH9LvpVcqCjuEAMHRf59bkWuRStNEQUYTRL6FkNiLbKXixUYdyebJICvTF8ofUAjpcr7eRAeB+ALfuDWC+2Bxq/JihuIQrbMUL6wbkjqtPY6lu9QRoIEPV1oGc6z30vMyAxgmTQ8hTDc1wgQ7O0o3dX77uw83G8HONw1vGtSJLgPmzSwdtz13Yi6OToTvuGUwXQLkDW2PpF/iNSfFuwSelGoKJzTPStT7IVSE5OHEC6Ym7HxcZpritFrtzAGQawrfiaQsX+C7vSEltfssasSvx4ES7ITohRJkGfAiIXxacVUiI6CCIumj3uBYU2wB50eo7nz4t3WD6I5P2SybKB80Ijiz55OqzYgsI5ZNdNbkul6+/9r2KiI02e5Hn/JFVuVcJB4l5e3OGWe7NX/FTyJAIqGn2skAU1Wjuk/lQLe5sFyaNQ8xP2XOIU+UqOyPhOSEJCOnmu1T7q/svtR2IUCLkFvK4VyXx+zw63YWu9Hglm7Qg+UC9ub1ydZR7P2KIovBJ9jVKdYoHxxc348n4GFr6z7Mx9xbFkQXzei/rK38JBOtLyTQ5YnfglXLpzxIgMjBmQ/vQ4H0XnsvrJ0AewSvvHqCiP8INxwEO5QLSMtyp7AtcR5eZ9xDI+YePG2SGkdtTLnAM79lFkskNQddxcLeVEOz9GjTuVEgcjXX7Tl0VXANgBI6pt8NR05Jbv8Ga+UOCu4RsghEVTKqnHimrB80Psy31VoLYvnqT4mjjcmXavMD0o2DE8aHMKgj+ffSzM+9gpGdZXz/VCJlCnmZDMuGrifGH1HoXtXkLVsPQWCW26+uHEBfxdWg5g0kyDMO1f3O1d0Dud3Z7+xUSs77MK2bDR3/w+ta0HjpfEpwP7L+CTTQzsk3BdgikQZXL4+xhEsRDtXq+FvFhD1XAXptLfxImOJUV/x8bS6VttIZDCMICuElZNT95vk0Nls4J/LpDo+kIvfGR2qEpyOXf8PuJgG6whwZBv2Iwzyk1S3TY4T4UuzTXOFscbczLYBG99uxnbdQ1lRTEVst2TWU6+Nf8edlJ3PHMevXSpyTG7A8VuRCpGbS29Kp6dlvrQft849dM6nt6/5BSGDbwOuykmIOI2HF5+fWol9JrcxexG6aQ+TwtW1deaNfUNtdCHDWbWT1QjJY4aR1K1sYi3wIm4BSEwNQz1yE6fEtLXFvbVn9EV5lj5RhTJVGTB/4B7NZP+mQiozTu/N9VdgBni21Y8by51rfUaA5I3B/1W/XBeBqV79Jc3JV8fDbFkKxEpqq5UC0qL+VbJmSbtGtfRhVaH5bLuPo4lYFL04XuCXQOlzy4EWNZaLy7+NGBZin9LjtYtwSnQgtyi/Fk6ZrSDOGFR5z+f6CIFIYi0YVJLYIuqNJT3+JnqPsEDr2PdEfhpO+2ASn+r1llbwmr7bs7MtzSe//8mnp8Z+zr952LkRQfo5y9LpzME13dlRkkiCh7EJlOL7tS3nhqMtu4y4htT3/Hv7PmEf9kZV+ignkX2aoQP/c6X6PuGv5xwVHTJn1x62RiDu5lLYXBkTPW1KxmLS+mY3i3aG4zL9VTQBaX0Zoy11L4bpee28Em7G9sbqJ5ttPqN/hAsB9FWls8fZT0ivH2h8T4anXeSaBqCyvLMIK5AX2cnMs72RG79IyPvWzQ6EqtVElDasqA4tncTwb37rydtAHzPXNeCNCPC3SUkGMJ2NhQy+dFnCwjZGFd4YmiuLPvr8yNvHKlfK1KN6pAr9VC+ut9egnmfgTZAmlXC4RXye2URrHo1leUzMQMyA9PBkc5EfvCOgwuWs9bDjbqWoy6DZFBOlwSrvei+iZSJPhHF17hjLl2nYTKtQF8PD2vGuVDDy0JV9oY3FLvpuVNMicvmXJfNQmA3gw6GjVDMB/Ftedtngf4igTxOEL32D8B/IEpHusWL6eLOt95+aJ2aTj2xk/VFPLCozGgm6Itl68A1T0G1mgR5CaBUaq4h9cd3614YTXxu4Z3PN7nnmXaQfAL8lXvRc6D+yUBqi/sGlu9Idq6xtGii+PCzUd4Omhf4dMYZ0q7zRflLTh6nTytMI8VmhQhZdkyxl1Us8gpwS2uLyeookThwpWY2IzLwb6dUNzCaeRIvIDoHott0kyzrMQohMT5F53ngKrCI7tC5nSL6/lcio8aqn/Gyp5BXpXAb5wWEY+7XUDJ+4QlBxTTS5QkruR1rOlEep9qrHQvCdDA7DDkX4CNIFtbQKMUkSkNi5gxpkWEHWpwSYRsQ/FOJCOVbN36igBp7Ytjs2k+1Zm2RtMUi+3Fx7Uxwn9BXU7fO0aExoHg+IdwiYhhXP2rTGbR5YsR9b6AbmAaWPdF93WRwsrM1XmSR44EVsHvlJ8nkwBseKqbj22i/h+BsTkSR9BQX0Bjqn/wZVU+FEbCOoqvO/odxRVjzqpuX6kTXs9IP96t6gkj1GRD4/rv3Ur0csDyTRSiQnZSmgvra2F4W2D3XPurKxBBlBFIsnjMy2FWXVzK8F4Aa9Hk2/QgkB+4E+yz7tjO8ptQiVaN058trkyZe0I+itt0eXBCBjAWEe2oFhvz4/XYuP1/K2WmUITl/IWojT6eKy8IqE3CelAwl8Jp7t1KCV2z41hsctZif7lEQF0dxmIEf8st1iJkTElw3IVDfXG/OJtNJJsQVoqKiCubwC480PZx+GjzZAxKaxyNyO4Cg+DCBisVA06xeVXIiiy9dD3TenMCnP4qjjkoY2neggn4gpd9m8Ov4eCxbhk2a9bXp/0xcWx37EqEFxJbOBanj+kkhZsrDb/rxM/QK4WPQjhUmGjYphf8R/nn6ysLRTHov67SPezHjIqjAARrrY8+VbAhIhDeA+Ta4ijGXQ9c+g2HXcbVD33ydi5Y3xZ/S11tHTIQr0wDlInHfXgr02HafWSae9m5yH+OpkcTgST8YM804KJcgq9DDSesgmEgyDDL2pI28d0SQrRy2hLMpzPeooHVU6kltmx6szT98TQARcshO5F8uSvlpGpYTlXmbG5UAYVD+wFDXFfIXwjBm/bPr7+ZxHb/eZnZmk3DIoGaPeNb2yCFP1sMEYxCP1do+tNbD6j4L4GQ9RQeHjctOxFubut8MQVL7P710NZ+0QVtzMXiCgFWth+2bT5eepK0oorr3fneCXE1LCcZg8NEQUzNZ1L54qBbhMZtUp238EAAvkLpPldqyqPA9dqqG81B+0+Cxo0KWJqFCsRACpFWlUdC5wtaAq0ND0zrTxcln0nNEKsiLVgvQR2f4W5EBZ0KI9b7MCtADBHADQiXBnwUqdoclyvckt3eAAdfqI3bJH9qhTb1srXa4DLOnSGTEQ7ViAJkUdARpLGkbOoPhYVDdoB5OQev3v6u8UxCiPT1aed/bJekUjD5uQXcX2OS4RxTKur3+yLIswwrnB88JsipTQH0L94B9A+AHd1Bog61f78hEkHuA8eD9lLeDRQB0d5dj7vPceUBrI0sfV/odFitpxoO3nhk4U3qyeKNl6hzMAt2nqwggK9Fz+FxaMjkW1Y1YnTolKujB8N96Uirjri6t/GFIWb1/Ec5vPfzBYs8O0AvcHYO1PECs68OHXiZzA7MJrRNy2MW6H+Vtxvp7whNaky73j6+qaGCoeh95AtdizRfhqeBBWyd//NrSpXJbD4oYHOouDgikiAzYACPQwMs8hatdxE/5lZz7Tl3VcLm54b4VajwNA80kJQUvjtpEXxHai87RHEzTYuFRAUoj6R2nadVEpDoXix7yOq0c1g+/bhFuPotWSFMWDQ11sfUSu77UgbQn2SuC3aPIvlVwS/Q1UDMYVYiH2xS5YwUGxzdLAckgjNH7DJNEK50tIEJ+wagnqOy/SfnmcbfLQ+ZvS2ZdoUNeK3Ytl0Qy5h3ltBW9Q1ggFuA/1jOePOlCMDKtZhmN3IAgfZCF0qG0HU9MctgtpoxXi2Gh4cFMUUjkPjR6J63xv1oxUmxN4SS13HVMBYozse9x8w4bG9miUXC7LSWXGAx/ar1KYeiWTIPCkSsxNG1wSPohjLNayTeOf9rdhB1qPrg50S6ujFNoCAVyZ1vnFV1Z/D3EnuT/m9lqTlOH9m1ABRKDuQYRNeoYmcdiM2EWs8i4LVlRg8N1OTCOqo/Oje8LEOnuLRJPxV5oCx4bViJQo8eDSxnM+KnaKp213AiUlMedvfUP+roQ/bBIeM9tvFj7oTzcmcb6v+N3pOcf3K4nwWMrWyy3PZBQ9ioWt57Eamawr1p80+Klp5WOqG9EgjBiLununYkO6Gq7E1COn/jbbvbLoqXilqCvABFsWX6AnsZSpda79+1BP+py1bRoBAltifFyKBv7Hbb1OGhnmCMjlan7duLl2Mk+EaEK/dM7tMETCZYe1ebktQ+96YMsNgi/hJ+eVx8wevDtzp3WwUKBmFTbOjzuZln7KZ6vNqS1PSKU+R64GtP1UrOiRZhsjxhBH6886wTADJIKkjTZFI0fPWR4BH4KG6Bmdrsys9/GAcE1H0D7Kd5oodLTJNKgup90jygFar9GFIqNu+bVO9RB5sLR3ieBFpeqKndx7Mcb8lFKf98jn+hWpokG/r+4E55DHRrP4xuyQMhPQL6Frrd+WXtggKfpUCZc+zNYrlTt7BnBCM9ycwLzkbjXeOlEr4A+1wk641j0fPJN+j5i09vkaExlZRk9AiZTcCAin2vFG5l+Sib/sr0f1PymQhlHiOMByOUlk9U8AP5dDyaKwpdcDdNEO3T4d3EyA7lu3BWwfsQEthneArtLMaC3cS88PdtDaUxoFWc8uzgP9ZODagEEDzMlth9GrJKfxoGJ5n4fRmgB4m0KFco++yNN4iVAj8jfrZheE0CRGVAP5QzWUsPsSaNuScW5nIY+o7P56uGo4cwgJuTMAg4DBbyL8IpY5yz5hFlYHjdc50rCduZYrcOGol1zTWSiMceZEnq/2Ss+UASwiwejRdNrpPt0XsGplnmfPpCh3OPqmYEzFQ23HqFGqAPjPwiSVsIvsmIr0byYFPT+VVD9KeJJMxIEbVH13QPiF7ReZGIaJCX8pFznWqjVlzTUQ3MhNnoECsGHDx9PU0hWEisj/6HiUQ4JQ0l8hvzJYIu3krLJ+T7pP6AHK1hPlOr9tmnW2AVO28/sGK6+HTxxc1oZbSo5OUOqPp7U+0JwR3BwWYHTy4JoXPRd3KmCXm+Zi3pgXpPqt38MZ8GBKsmENAGsG4hCzG0BKnm2aTJwB/+Og+0LzX0SRLbKoggflJWuYnX7FqmSO7ti9nJGua8n79XKLNim+IobO2Hct0A9htKkUmIB1uN/Sc9y9cM1tSH22FBIWTGC/KYlnbDHmOlwnz3z/AjmFua3yFF5juLcw/k15FXvXe+ic2jpaGh5rpLLwasNtQ4lhLOvroVVWMGMWBKCc8MIGqcyGds7D3Y5CutCVkqwvrdqTVdCOST9vRgEAshGaEw1FnvmQoFHspsmCGdgtsGRcZB/9VFgnwsbe5kQQiFJMw9DGxp6dl9EBqTrOeotU1GoTnjSrJkwDTOqmvOL2UnL85eoxEhYJeDe1pKsjG0O43Ri3s+Usod9P4LhxXRIinV460rpCbAY/kp1NAtChKY9n7x+4qz0/atoaLFR9j/5TllYaxz9r1kjgWUsOkBTDW3CZ0O/ekmvKLc9/gRBxcJNduWrxz7WYQk+Us8pOTDfk4RMIWI6tGs1zL0nXhXFFY9Z3wdNiFLptegx/p/WYopWK38pXqAzljKzvex2NKJ1tybrl+JGLCYKn5ZuM7uAq0TaMQtxhfPJqqrA49wxL0v6mTd48g7JCXT3IVGGVV9+WHfxOixaJUy+jfPOKV9dCu3ogIEaGDPH4sHWckN+lEuhtej1zzyTnPb5UhwZAkxsRF+kJU+b550DmE9PtTXB9oPxBvWt3iTWvm25ZcWIXkTlavQUi+vqNlWvhTaOPE62CG//vopWdjIq14r+KCPw4TwMHZLh0aJhu+k8OPwq/vC4V2FYYWepc/PMnzRIQ5XQ8NqpciIpQugl9criXtos+NJQEbIaX+06dPJHjQH4688rvkPhixpTVYMrKQD1JAkENmCS2IzlgCiAXJkwPmbOg7/w0FpIWFYIxZtFmeJrefnviVHFFEcyMXCm8+GtuZHWt/Vy0TvVcvr2qIiK1VDIbVpYkblzxIMP2s5A1Ev7TMLaKdcb9aNAYRIpuYsR01LMvK7+AUjERO5paApWmxNR1y9liC8QxHiMxqrPYOHGvrp6Bh1rojoNDX22xockUnpo5je5sdDSocUFgCOCTE+hckg1AQsc7ZkB9sDk6sMT02m+JRDGotnkT72lsVKtrZ9ZgvQ3RLWgexSt+PcdUrc1H/0XjupYc4L15k5y0T3b0EaXk2x22AqO2m/LVQWGHztmTPzv1khm8Sua0rabn6dtnOGABpF/phlMaGCQ1sKD7tXmkxA/iV3B62QzD9zBTXyDfyQ/VL2OrVnULh+eYNQ5/gOyA9RjjgFVLS9bryf7qnrDk3azWcn3d7KvYSRglFzGFoHLo5M2eS5lr6/JGi/Rgsd4ud+2rBP4lu0UucAueGu+NLHDaEwKI3eKpEkEM6Sr7vIWRNb0nM8B7HLkfL/Eb7x+G5GCNJus3y7ANxPkpQCwLuJ8kUBwuTWHmWB1h6FK9y2peGfkgH5U1zFwRluO3+UsF/5nydEP4lGimay/bE+HhnZvgisep393KE9TqBVFSqcZc3awKwsHZSgWBmjoJ2fs6ODZel/RMoMG33k7H8o/uR6QynpWLC/F+YZ6x9Zl06XlXpFieC1+X0TXWfM4BIBnGYdj6Q+kXlchF+RxEFulkadLHpTd2OagvXzCFmoRTYXkL01b2JocFnzNfp38haywlEEgtF6/hiD+dcgvsjxRDhKx7LBxZGWDuws47x6Jxb+QGKamP0fXJSky0lkSwaYGfB5JbYNOOgRURMkjz1ywLUeaK95NOUeoIhvLsgb/UP0gFtRpTpFjU0rh8e7agNvhc0uCpOq9lW64Wiw0zrCR8ZjIZvb5ER5o3/VNJ0TNYHlAyC+EwuO2S7OoLODhRfKJZoMk3OWUPyW4ESY06UmwK7/5neFlX7HyszaeUEe216POJELcPyaXUqyjqFmunkVSP+5MTFvLwJpedoTfD8k4KCKvednhuuzYuYxTOheQqqTSpmvAlP/w3sGZocg+Y7ov44EnW6URq5FdjEDK4aCqJmhY0tsZ/XOs+8KO+EiIaspyQwoW/eWXPkp1cqu031Yd8CNN6LaCH06g6H62HlM72115BvS3kffArKYEFgG+yW/MOivm6gvtvftuXeMJxELjb/t+k1EtrejLd3PhtUV5cuLiRzC95qcs+/06xR2hiM7cDo89OI3g2NWzFNsgJbwPCW5fG9k5WJDu41V0mYGUyAqnA8nW/CPkZ6tpLGS2aBN5+372bmQ+oyDCNG8KHDIwbkrOirmfOkVLgLwsACxi3Hhv/fzZPgBALC1rV/LPHAIzMoyEDyOHvx+t3ipOL7Ay2yqGK0x32jbuTAy1b5AodJFz5eTXnUICKsbdiH+8cBB7xkwM+3x8GlO9Ihg5agKmT4X99Hhz/H8zvoxZMxsHloTpKFooLW9t4VwS+m0bpgwIR7AojtiDypBEEWjDMaXcp02i2qKXXZQuKQi1gvAgtg6vpXZZ4ylFt+9zBQPAROVw0gypU1NGgu8QWvbTBJxtEMhgrRIucqb+ufKL4Tua24rNNS2zhwx2omHFQVTgYU5m7TPm9y8r+kzDsj68ZUq+4qsi8jkCtHSmyoVmma7PUB3B6EPGvvx1MWJQqFFM7fbq8NexCwytZ3ODHQzBH8xyiE5c3C3q3J6Ujc1uqdfaAbJsgT9BWiV0voXUjCRgS5gCGg4uqaxl+IAdKmmfK4HCsFt46cksf6HfmjBEt+cHKRVex9U2R6/sxvNXpO8RnDUABR8il6UX1QUh4PASUtHAkrvVyjLlfJ0k3BYrko2Z8fxfktzDXTTwaRq0HU8QNAaqrwoZ8BM9J9L24r2id7tq7LM5M34IcFON9B4KLTv5R5iu5moC7mlMMr+Dvis5Sh7cbmFHAXXcBBhDgrwmrGyCRf7RZBd7m99DDRbCVMChFz1lOK4eBWPa1v9yid8LtqyJaHGI3GHxb+Ykd8rSAMRBuoKAIo0+KrUmpgjGpyGBAIo6D5wGcUPFt3ZMxqI1dIu2X0kSkIlOjjr9wHp4/luqISA9Nui6xBiYoYwNcAZ+qWxywE8UYdX78x5x2xlKp2g3+k7wencEiIRrJUGRl4tf2PWY5E2Bufte9B0xv7LjkZFREsAPZN//Ay7irTieeBiauCwfpb3nqeDO9MkM5RGmorwj7BDL+85r4tuC/hcyFLUVtDYSpIrb5fQh21msO1en+t2Db/195+xMXlz2x2ksN6mYWANdpJgdYIta+e4O5+2rBRt0qjdcah+/1qWV1AzCZ0TTzPZlroTEK4u4SyqorYw9Y9fgRx+SM9TeXSie536tsXX5QW5IY2e0MWTVf/VyrU4sTnPG4M6qt61wkM3EprPxgc8Ny/kupOtVwRdm1GbfiGQ4NdQA3WZFBXKgtCrGWK7dCSHNDuT/qpUVnNjUvaNcCI/9I1p8EWIsgm1cllhWbBPLmI7DoqozZEAAMk/ZqCJG7AWsenx2ZQNnbIribxP8NS6UFECg2U6rTB+pL3MlV0LNBUtRnmVfWRLcM88qmadrbGzIfzR6EAcBfjw51OOvn5huIqum9AKHHH+Q04ih45Rajq3WFjZNUhA3EY93Nw+JbonCO1ce8WQDd2uSGJHjTpnB8W7NNUaf5t7Ic+nE3Hk8XJixbeBbvLWr73T43+H9Jkh9dIx7YTDX5HU0VmPeQfzlGpBIW2TzjRyvjrpi7c0vitf7G/iaPB/5XYGXUsxqtoSY515rmo2ibLEAKgPB/BjNPl0Rev6xRpeeVtBlq/ikuCOcbmdHBhZv9WSarKd9FxD2RFdUeMVI4Jy6Gd62kHS+16JmTHTMieaqO1KpWY/KM7CS6SXNDnVGVSrjWMfgCl5IdMU7ygcqeuWOBRqlUgYH1DFxmQ7a03RrujIsiA/1jSGsPzP/yxtd+v5zgc/Vn0+pH5+fAVshzEnbqZaFq542ez8gSGjuQ7M49zzVEzMSEAjFjepGTybPnuSZtGa1XBZzSVxnE+7EZ4jQd9qJfA+VNC8MiPAs73mfEiYS3GEfpdJcuyFNSpzE1ecc7V1TY/vmlJPm34shsqK7RjGhXFDT1I39sI+LTYx6L+C0yztvoN0QxRX9UqhRnWSkCi2MA6MyhnD6p7pIk94sw4p141DZCi1ADxBG/ZmNEHgyPt/6a7NMWKJuQ01CxlQKcNLFC+kKIVsh1c2+kBu77SUpTn4/VU8gSVxbC2FfFq8SIZ4Ly3z6zUiICI0DIMPOQbyMXvYGvsM6HL8f+prZa8x8xZn3OlaxPQfDr0ECB9t40q9iKqJHJqevV6rowdVB1fg9IGV5xJPUP/Q1W2aBKNMhjoKtMTmfHdh0GbCe4k0pifz1BWyVzUsz7Gqc/gZVEnttNrSnQeVxXbZpEI7dKbAiZvdfsgKZf+95yEpEzAsIWVOxq/M+vUZN5JEMdxIdE7RndEpxZuYdrwcfWbZwouFcPIwbAEeCvjXKyfYSiCw8hDDhLHYIBIaXXfq/FJuQlxjz6t8eJ11StZK49Pi4+yCI6S0xEcDnsBXLb2A8OrxZ9vamdOUIZw9biyjUVMozNLt4WZg5Nh4i/xDy7weuX79GxNOG1JE2yPZgyGtC2lcNR5mqEMA0aII07Hwxu0N0jtOsLGEsDx4kvuxREy11ZzpSvIzvhu4Y4DtjP/No1+kVO9Noyx4YNo4X5tqV99gLmnCIbtdzDWhZsTV0GNxPagRcPrQnDqZ7HY6WQK7tXd1J6EZibtnhY7HIDCsvsI3eF4lh9Ao1hBmvgtDzmesvyMDmsj/UYiVwx5ijf7f/KUvzWfQtK0ucNIM04oKWjRrhXnOh4YfBoEcQbTD3L6zpn609a7C4QdEBrO3QRPm/O+STsE0gAXJJCdItotg4dT40uI3nqMV/b3BkQ1odAfqndpaf2EcSfjU0LVVX9TxoD1+y5j/6CIva0mzVLZ1awVHxcvcMYOPo9nLG+JQKo2VMRjE/IxZ59p6aksJ7uTKJfLNi2jx9olwq7MH78XnSxbc5RWKEqjhnz4cIlEdMlZFDU5PQ3j8uCXHodX5jZ4OxhWh0T+DSi+g2Abh3T3qFJl7LPtpviwTEk+K9x6UQcBsQT99WHMpvetpbPsPtxg952drfB6O/708hH2y5QqW+3+Er1z7QKzP9V+YBwnWxMeH5Fv/YZRFkvgFfMtjXsQot/nxXsikCm/rPr7A49pEgBkeaEO3kH3Wzz+rnnKvDpHdJR6KZG+tEjfpyLsHPu9AleRPewDSmPIRaKiQIxBo9TRg/djgjItV3SahHj8IdSRnwiRZXviLPvy4LgEyKNvRaB9fCQmihvvRUl8sLHZt2DalzILUMtRhDG129BQY9Fai5Xh9XG4Cohwtr52pI4RRoEtlIUBVfa3UF54oX5C4jTydv2WF61QcAmWuzdaaMPksZsKTiEHmWJwrn/cj20mrsvZfc380RH93D97Y5togOQXBp0AkdnjF4IE/tIf6Gpir0hXRKKqX7tZdcLnaFFzOz4NBG2oLTXm56YvbRxByYDoil24ZoS0ZC0tA82oRnDu8MxGUIed0gMZR8vG674Hfm0XhGVcZd1H+XXwy9A3fjLzuN/J7HsZNbf+de4IvFs8SS7Wg8I1qZrLPy2v64i8vAIA7aXyb1YseCjFCTSJSylAffY5QAAG1T/+20V7LGemTU/vRijkgLGr2xvgEhLe3zMqGw9+7e26BCS+cpu7q/64/Aa0r/fVYcM88z/5JnzQgv7jaziVboSYEnnV2VC8EfIM1iwJEOFWAoylxA2aG3FwMhPSUb5Ncqfan7wMNqXOjXsKESr4xXAx1HmeqX3EkumCVeXLQhRhF3xf4hT9moAvKRyUvFIVJQXlP757ashjIdGTvtgjXgwVq6Qkf54dlG+/GfFdHu0v0g1BRQ/97X6x++XiaxtT66S2197nKI7QNwBe45xVIZlcGoomcALRCJzaYVPP2CVbffe7qog9Pt4dleBHlbYSKoKh/75MQq90XPOCdvrcnYZ8Wrn1/tcYsN1kZ48boGvDmN1xIqp1019AY8aU7eeZhUhUiNRp7mmFtS1Egzk5Rsz7yUwMVzCdUaMbFid7grUVaEf9Z1qh6tvl1/Ojzy4xgb+qWId7haAajYE/Qn+y60Hww4cgAyOse/ibIghMgBOSXQltbr1aYCzLA6iDXadEW7nlz3eW6cf3MobaiM3FESkVyo/yjKeWI70PmxS6yXj/0Y2kPNyEdi3ny9LzdZ4PnMCnvWau3cE5+NKNivxkhi0p/O7ogHAzWs00PAc1GQOiIR9wgeBHAU7Vqwyeu+DqAn+deECLQ+2iH7hdksoSY6ix/ejHZ5BrVCiD1OJ3wYP63uopz20uggTkEqKOa4YQBqxmGbFjmuxBCWQtcqhiM5KpZraj2J4VxsIrkxAglVjeyuIP+bRUog1F+a0jW3UBWXEF3o3HPFq4SrBXXtYy3tVcg0hbKn1O4mXqrSBUdYZZNF3Fq5nRb/AiTLcDjGqInP01nF7L6ZjhXly5k3wjsxv8mb/+jqv5dLhYuJAtEZae0wCdwHp/zu8B4PnKi2OJfpUX75KnkHHfQt6yRx15Kp1sdma7BvmHvJlvYqH+S5WkpLU9ZHYQIMxUoZD1ipQdRYDkM9AxUdkzK/ajWMweI/6A5FwWex/r4RzRP8RGkrtA3Kpk5yLu+KYT/VhUqyxZFhLP8INnY1gT0OmqVUnW7eXOqwK1CC26toNj3weDxL44c5X5nSceYrYpURiMC3ARrBQmTBCJS+lqv1zT/Xl5y50aOMXE8j40e0RN2UHi01SdJjCpIhVS73RZ7vqwEU6M1yICR1dYG3CbKiQThSVyOzjPtTGaXIVIhw5BCqtDSmHzcszM07iSrp9lagiRdc34NTxe2UTaTcQ70madz35PGKhOlUqiPwQBtNWgMJKezrAn5MR9+TptXFKcWFsD2fvKURrsO/4NNrcdKSHZOb+chRregf6WjkBt/YQLH+RohHpUguY9lNe5D8AxVwgQQ9u5LWE53YN6fCcU37uXewdUBVgkMJVvfwJFfShrLXMdq0YeqIbds4blbrBl4O6fPIsq8bRkd0MzeJ7dgUwde94yWaV+oT3UpgeErrtWKmI4/bASDnFa3xKNDHt8uXUrQAIGu48iuILfZB4bqW+1HlmH/xFJs64iBmXeZEqRcrfC0gf/ZZJzY+jC96NGz7sRvUIsDN0oSGSp0oyzcHeT7njrQqVZrdnAp/rt9gsnFdualk+sqaujIuwRbkmwm5eUDL7Em1uf/COvJlhynxe7p7/USkNaDwRFBpYXXTESUwv4veJxZYifmf/f1E7JV7yz7OytNIDesH6lxlaZzZCNmze03D2KBlzztIQ6VpK1lzgt3tR/bkgiZX0Wrf+eFJ0tGIrg1c4NSDeIw1gAaOYMHZ416wg8MRasFJGwWSZ9QnNG6B+kjAENYAatOTIdXWRASWyP1l34uoHQZScbtPahls2kaiuaAOulIMFiCEIkOM2hL7sq2PzYm4VbZ61UTR53Y6DClwDVMq6mV4Io3hbef60KbiCHg+VgzFW4WheHO/7o3Wjmq7Aq9FeKWafKqRpbKdRZIZj27jrRjP+kUj03RAKU1u58BMDNIcwIULP/pFTeivp906gSOxTekNPjUDqTKuSVzfp45vmSgzDGG6WJZsn59ZGT+7bdMxkX+pqEVkgJFK4SFSay64wo4uy+W1Dgas3JUMKTmF8FcfOgJj/iLkGQ34j7YwlYDMluZxfd9ic/B1SzLrlElWx7NIDhutZauDXgnEgYaCgJ687sKDXgOQguYtrc74YqB9K0/nXoBleOKRWLT9MurTlSfVTFSgXS91qU44XVXJgo/Rv8XqW9s7rnHMd0daGE/KGnJn+a54Y9xZa+pjwt4A8V18DN8P+qy2C0b1vay7r+geOQGvG/DWJzoOa0R3D1LYsyJMmjNxYY8jwgkAhOZ6Ub/iHa61cxVJeNBS1K3quf2EwkyIgXy5Ty+9D7sI1U8QSa+iq7ZU8k/J0RSyyi9hObKm2pvh2Z7iKwlo1QUa5ZEUoFNac+m2Qdq7QUtRg6/oWSQ1WPzgxom776R6kpKbF4n37WYmjDiE5UhIJIC9G87ra9h5ImBTN18y5mp7L5DwgvUW1POkubVT5vuz6KGtOTYpCvwhTgAPVhipp+IFZ+3jI5xnxUYjJfafxIjbFGutMP1LLAfh3HcdG7616MfZEBR3DLCqYTVmPd7z0IWveN2+QljD7oM0kY1/+B1zGmHbO54wRGb4ohb5RkEplrSfKY/XRhudjNDCuTVoQNCPlKrBEMylmwqSzen8oCaTmcdiOm0Ll3VYS+UrKiVEwJZnfjF+VMKjEMLtzXUXFxtNMxKtezyYZOkZbKoC0OudrUxUfyLxoD3Oa9DJ9xBKAU7AqYgQoMvP5JPMO+0s26NI+WfloRIwPLE+Z4mFo4PdstRy3KG8E38DyaQQxyzpbdhpsNU10rzmJQLaPN6hWgR9ogB0mDZTgMBM4Nbt6HXIPhzgpeHpoDa5IfMyu+rA3UD0ttOKOKxY4DCJoFJMVejlRtOcxOVPWKhHXX3cB1Yle9vODM7YFIw+NktUysfBYp5yqRjeImmJCMLflilK354DAxd30zD0at9FeIUugPennEl/4CU27gTlsnBeopHay7x7SWP1VbjX7sgzRjl3oK6NhwEc6UGNZVUzNVGbVUKwQviUjumv2+T09jWC2AMG0J3tPaYBbBMgXQ8t5PYUCshIqnHY946QtEwrbhLVAtwA89WY/yk9Lh3kdSYpc+t1Mj2Axhw4/MrxrzXci9hSqjILoB8q0hlxutkimG8kL/O2rU5R0mzCwSUwMyvMGeoiWnrVFGtGnY8c2k8B9UC2xPSSKvJ5ZG6i1xm/R+vCE0bWoYcZipVFUpjzMZ/ozlkKXby6Sy0XYk4VhN1e/BPKnxQTe534GIQB0KxHxwk0+fk3GAh955dgB5nRSnwDcGRFJSrrItXqsNjdLCSIXWgxaAgZxCK0V9MG0TnQmJbF/Jt8LtBYwm6fDODXFEcuOYZvlFEZ8Xhcm8bTYHvjD5zMXruZ8UTx2AaoVXnpaGTUWS3cdxiAsmiAm5c77ObWKfa4a7WI4lQk+HQ5dCsVSAIC7q48WLNSlMUAIAD89/ureFn698FU9wyt+utOsd7e6Wmmh7FEjcXWIMSvExjB0jtAh/7v89Ag9YjexWYylmzfEsLr5/x4GbOj6biQcwAy5g2rv5u06xeLL1LY8XLLGrRtHZ6wuHIeinLd5vbJjdeWWb2br0693PdkF+nMwr8G8gOUZecnhhaAAqqEeco7PYBKXQGoq70beliJIadAYD26hVWkKhqLO8n3/7oAuebPWKgPCseDDOLDz2/yBLWzyW6wqZdscH951+yCJ9tbKPTGDPAEPwdFOD1CrrgYu3EDYPwcFemEvWDIqq3NFRR2KOIAKCF/gwJKAbUVdylND5hYJ/L41bbZO+qDI4TM3xIyqJhy95EwcNsgiStH/pK5OAYR5uIBOLGjhyLNMpXFiz3arD9cFH2GH667q5bl6Sh5QrbSOtqZnEyIyzlUsXpF9GExaagxoYU2KvMO2mpf+GwilvRyLRwp2IUwrAdDfDTbkgGw1gBrOHnucVjdkCMtg20X0Jc5lMP8F1D62q1r+GU3iCXAz74jaU3bGqCwBZ4T2tiUAYYIjsqoWlsRrYZJEPkS4BsxaxbiFwy+dUU2Fzum1YNcYr/v4THcLxwULxH7ZXxU0j5uE2M1C7apb53q14C4jhjklA5g++0EsJADH/0JArKr6Ho42V9g2hINlVQenz3y2YUJJjS4UsE1OGmx4wqSK42PMUs1XHkIMtvx62G/Ti9ic10fDnV5vpbY8DFqNajdI0Q3EnbMYKdjmpYF3mCubb7Z+s42jjc8lCARLw6vOwChcr9OBh8m2xlDB59kZInnrKbwBN7Y8IrgxUx5S/jDb/Ufzgfe4yx9kbWOKupcOI2ngptSbJzDFyjR0ucHBlvmV+PoYcdqWF3nV7KE23ACpexMtrOdy7SihsMyAVhXbnyQ5EDi6a0iOuHrZKmz6gqyTUVl7QA2hSIoPl1yqnk1iCkspGYKiv6CVVd8tlNx/9NpsgcoztmIqzmfEv6PuzOOzxrhW0xSe+PTXHIWKSngK0AvC+AR0D9R14Vab6boiXdZZs1glbi91/gZPg5ZWn78sxwwg9zDzRIS1k5Eyb+N5ggJQULuZir5aTQJM+B8a6PSy7cOGQwcqUednKD2KXHEq8OFQNzaDTPX475ajqSzRQpjLBXZpa7hK0ZanZxtQCLS0tlPwjS2UvUa1jCWTtHbONGW4pLvK3PRGePlpOjiCZiIG/0jxAtmPnCQ/E48oUGsawxOdZHxDs8CxMpsd/vxx2CNrWPMFA1ELccgzSV2/MUalLpzxwxtm/RqBNiIqF/2pzjlNrImpujAHS30Z9gwoQEUvhbSzstnocuXIoL5DrMi2Y27iurlL9665JCkhZg+wsJ9jVfrhs02wN7krOJPxNkrOuaBCni5VpxbaC4a5Wkhcml4rvPZNzH5iaXWfRWxi9A533uA2pGXWjYpevOntISJh8yv+xj0A3PzaPpEVjJbFDSUFXgOB3kp4Fh29QxMA8LekEhLT1mAOxEltozS2c+qaWpYeVhnNG0mlNd7zB56Wh4GJrxH9debDi/6HQC6B35GRuV/+bjwg8dr1cZkWwCPZQhYDr28i8wH3/HwfnDAgg/k1V8bpfA0bXFVnUQo7A61bj0djVaqtIaihRyG3YzFiiCFbqSo9iYJND+fEEJ0qxZls+mWNQLITdqH0f2DPu4xEZaLRRkOAeIQkohgHVUXB1KY4o26MyVy2TOynTIdaDYrRMy4ZuOqFAvKmuRPANQBxhSaP8AQRxoyQG26nWjbZOpfwBBoScsIBnU1+FMgNpAlgRGl7QuYGJ/m7VmXjIqT2M/fCtq3wnwtf/zuWl1tZwn8hnLDb83KPBlU8Gvg7jkFKy7nRE8GwVuuK6KCONH3lSPXO5vdFp4FA9WeDuD5eLc6eHPza8p+yTGybsOAl7jghsIfKqGNo8mIYcjMK97HROKjPLTok6TZjMLofOzvTYPX4akRgw+h2zWu8XJGmm6RGOhOYp+l+xaum+HcnCzgS3nWnU0CMdM+zAvB7sSA6PeKei+ClHZUJLNhwPQ3sx85mfisbQ9WW/k3aU5HXprDvWP6nAe2cUI3J8TNUHqpoXxDG2o507DNUNjEev9RmYo3wDLLGx1ZWwyNmlNmptVjibbWoCtmp2efGylaKBTYYBbbiRzVNtnjR82kpW+OWSativot48bU2EuKIV/0xARZKCr5fKzfD6N3yf9iNALO/Ipp1AWBvAnB2nU5pKSdmXVWTM0zDnxQz62Af8TrgvYnoku79WbQK41VPqzpStk4AHlww9T0KltIjzjV45gt+bZDL9zgX4VZuteSJ0tLXJQJuyTd0sCKOFow5En2wMb6zgYn3e3N12p8k12vKk86BwYoG+LgZ532T3UVdLpJAjF1NjH1UAUlbaGe9jh6pjZv2PlaPD+Q+8RCOL6fHwj9igSIDUhQTHuww9lNGM9Q+dEWnPcpqMaCdBkqFqiVxC7EWBWLaNLxOXVkA4nzsT5GIyugA/NEG9i83JsXjPuvDMrpAjk1vV1CsHI1ZVBxCm2d89w9lKJ+EnXsn1/5vOTqHlzDQ1J3BHC1x7FqeuD7ZWNrHZLppcQGD+GFaRJ1kwWkum74MqPTu8VOAYSED09KZ8k9+VzidrFQ0lp2V8O5B4XullrPB0pie1l+mHurWOZuT+keTln0bRdr89WWuEwjGbpyxt1GwOiHxu5V8AHQjYEL8MPuMxOTcliNcTEXWqx/KBIb8GH8T2xiNiriltIF3zv2gXVObM6G9yZ0dxCNkv28l02BdWTHcGykmuiveXdcOSZnaa2IbMvADDLsl2vayB6I8P13/XnFjnwHVD/lnEvgXxclHPdwJAMZGcaGeZ2PaCrwzBRlL/v9Yw+oF9a+RwbprADkS9qYv91//c1ABZRnlymjAO4rW40G/KjQo7Skl0Um+CreBTOlxWc6Vtc3DeCH9O4YWMDjj9lcHSIaSpTNrzQJ5nQMJUF/UobasKYE5GwW8G0QOS2a6fIYfnqxX1Q8QF5xsNtNxGw9rHqq+aOd4Jd2a9E9pvMxsrjeFnKQuAnwS+GFDzTunnVkWx+8shuNvoCtziWvb48qgetjCqH4P1Ia3dNC26rkE9t0l/3SEApLdMMqTpka6+gipXqyr1GJSVh8QsiiOd1Q2VF7PzA9aeHAD9OaDP7KJblTm+sWbQkxkk4W9qB0K8JiiD6MZq5r+bkBKMaLVr9YLt1Mqhj2VXTqnAfW1JEZtpREJeNGt3Ov5M4iBz/ItabUMyV3XoNxEjLMynsW8h+J29fT0yVe2POuNQBE8dlCESwPEqt7RXDQXz0yae85S3RJP7bJPf5/GJq+cFRVMfdZLoNfINzWSmDGFFr8I32qHRuAsfHLyIgu1c5kZaHVAMWk439ad8S6fLx5otB8NFvrnhKnKSh3yKUhylTG3yTR3i7kBBRpnzHxzQndh3pIQN532yLO0nqaahzsJ6pHjO76dCR24kuPSH3VYU5vNDmEbauBxi3j9Dv4UfEyT44PKtxqZZD5vsxJps1hQ5vP5h/F7JlG/o0s7bHJ4vYgVGhxVRFvdp86RU3vDcJUAzefKLBD6ErMdwqQhrYSQDA6bPL0uFlbQPKm8pCShFF2HhUeB8y/Pys/B7ONxCtrTIb51202LZJrFolIl3cQF0smKmZqvl+27cDevYXfZwdW1R+BhZwuTBDMgkrH9fESpiI2AjPhvxiLxUVhPfibDqMjmKTOx/mZMUT7Ni6kJgDQLnQR0n66lVnXm3oqKMg3fSfX3fNM0VL9NKtQssPweiTb5kb4Ha0Zj9FsDQr2cBR8ni/UN3R5H6Q8FFy21ZWRcikW2R4d9EREQnEBhBTsZZYMkOFcHOBUVuyYvmjXSiC44iFL/aXRNrdNTAXLVZKKVWBozWshKZNf94E85Asg7vEJlPWmVJAmNQO7IRE+Vdd+E4FUpzZQutrkZcfKRxv0fnDiDMQ2AYhZE/ziBtQ7trpYfWkErA5jncQNkDlGD5vEngDuAAE/Qz7r7usiW/O1d0J+98kZeknvohBvsbxR7zg1qD4BACF9f4ZlxWhLjPI1XI5wBlikg6vYZP7xU9e8rhNOj8OYv5g5onrpWukp1L6c6MlV1aQn5pcl1UzOKh3wjWNuI8l48r98uQHPQ08jX6NWopsiAiQXawYfQNdhmLMmLDdbYMLOqxjYL/aW5pObZA1HULNp4sbfVbTf+wBP5sB6OD/dsoVtBqnZXb4woTkW+gN3curesIyTeHu9DXZk16JDiIJpswbElCC1w2SixMOBtrln8cV2aLCz9UqtfdRxNNTs1GAY6J5acxecP7bIohM/B1uYQVjPjz1GMjOmPSnJmadZjU83uynT/KYpNrKlvCBZH/vQTngfRGYm2WCdPnNwe6/UwftEgPzAWdB0VID/A8lv9KzpFEZj1Aw05s9XkqVRHDYCDLF6KtkPnq3EUNqDXQ8d+Rb3qcilD4v5Wh/qYNIIrOCOyw+UMn7qdGNlKnuO9vwwk7K3e079RMj4rOAHev6X5MRp3PNzVumv6fJcL/NXhF71qXP+8Qp/pyxR0URb+FWQmm88eGaX1Lctmfi1Tv3ad5Cs9SV6oAtOUTxL9awd3tTJmUnHtSQvLEJ9+6isv17+kzZPg0rk0Z4sqCJ/vn03BoShbKHTaw8qgRuQFvF96bJXzLNhyRCBoGsxOmtQOaHhwSh4AbPkwVsUqYKx45jtcW/vMZ2W5cx4Z9YM+e+vUH1PWdM36osHEiTCjwM5MZ3H7IMqoJdh0YXmtzGWsHxnZWVR3vAcETjYfX+jyH4NRKAULIlmhu2V4yLNBX23vQU7kQYP0U6i6pNctjoXb+tlW7L4JkT0VhPvx0jzVHzksk1XIQw2RkEHg/TfSVE7TRSvzymWbt1rqCYOR+fFH9tFcI4GfM4r3GhJC5Ea/Tv5642rAg+xv5sqDhSyKmZrxdjwZrMszlH1esh3lvDOawX6jeUEXPALJfskoO+8yN3cINqLYpi1rkof9oJAxYykR3rVE0x748vkryruUS7Kuf0Qb7PwnHTyzgR7030dJTh7j2R9NEkl3v7KCDkuDKrVMuW4LZE+uxBLkWxD7T64TcMDjXvWjGZL2qOldAmuTWZaWZC4w9xZFaoEXOE3gUC0mUEQ1kMSoz6fhlWpJfZtx0PqNWAtIPnueddr3bQZbgfKuKMPKBRGSdnTM8WQCvaUvSf5EKYh+aS+CeTTXDKMZ2Ptcclf/IYap0/omhPyVXGIPNHkOIJv9Nr75oe4649qkSQmjR3upTPEPcjJE1FHr1oUwLO9RIYeDNIk2SXPAJzcjpc7ktVmkUc0V1Mc5+OEmOJZh1rZY771sVur3Y6g7FEx1GLjcyrwG2nNvNLsRHBgBYe8gIgPsRxPJTpaSRfLlrr+HTYf5EreTAxM+jmqXH28EJgsH18YHLSJFespK9NBfKzisIk6811gisscgwp9a1u+/CFuLs+R12vTB5gk4+zPS7TqPa3odaUwee9FZeoh7etHHi+Fe07uprzYLfput1JE8vY/Oy539PUmFmWJVJ0Pk77hwo96xIYaUWp4sSGvZg7oqi/ZKb43rc2nqKvOqMD2kSfPfMlSxYqEFEf+D4Zwktr/96b9oWtMyE++6tA7VUEif05FKXpUP99iVo1zoRMlbvBllpyqrKtn6l99CgJS/Su21KuIKDLvlb8C0TE4ZJlL5ZEUaVm2/Er88Lg3zYqqzSTiOiBs5D3v6033s7ExqbWDMjU2T8pHbG+LEWS8LCkLKcIXloVQNqO8MUmx2vCzkEYkdmZoCIV/5Br7um0K5FXlfmiLkOLqc/6c7+e90cLv193OwJHatpp4iYS5+i9EO8qBdx7JFdPCfh6fKdi4nC7RW5l8QuzrmpbopzmDxfD+MS4dHfgb3dsHD6dv8T+I6oCZ/sLh4Y1WEl0YBj6kgVBLVHXiMcq/kSFoNjA48ab6qS3Je9t+iVvUqK13Vy9qg7r463c1wLMroBxyZi7+F0TCYPBecFmaoCTBQAI3HtIme3l5IX3WG13CQG+inX4Obj4l64hE5j/5ipjLW7rnxw2nKoR5FlHf09bRBATJVOVAkHo1+K3rlPhpbKETun/raMWWlVDwYQzh8j/t7xQGBQdlilUX1+FtpT8k/vjR4VpGrQqZrVLHIgVEdt8SHhGGNxN4JyQHAJVRuNHgRfjEUZgPkWBnFz4+CDh+cR+QW0S9mI+x+Dbu+8sdtoBI6FpX9sfF6E5tLLmwjyB9WnbQFUR+iMB2Uplv01/N068+IDIKoY4UnE6yFvNR8EoypNbOYH4xPpHvmfLeXCRz8ikdS6oo/N19UQ2u0QGB/zT3lX/nJBkwp/k4WogHGmIjygO5ik2MSpwD6gxgxYMkuaI4PagRtUYizVpUJP32D1wDYSco0G7gPsqSGPpwvKCKy9GfIOc5OtaeERNv4+Zh78n/7IifE7yx/6Y6rZB2OH0x8S7ybt+XTJvVJyi1T752+GKb5Qp0UoAJkdT3c03irdQemsdCtGe49IbFbj8El7nU9xEXQNVGjEXBZimcucbKfALSgnuOYcU6Nvn2R+mpppt7QwXF03ScxijxpJ6pz3GxxOcQZLSb+ntxPNskOqP0wxi/iiCKmiU0wRCtXA35NQON4kkfLfWG5nPSt1m7BSx3f337RLvfg5YGaqJlKeuaALbhkApIEi7O4sdaGGdCMoNes+IsWXVe+cDnOf82KMsLQwDuGdaMHXThq+Q47z8K7mjtefH8K1skbKVBlXH4c3R+GpVjLCIH/MVr4cxqlRJgo65VRVqcdJssDy/5/fjb/eztEk3Ada6VgjHXMedww1GpefQshCadJN7JIzvKkFglAXJ4zEuntLKw0dP4R7Hc5phIuaSd17ADbNGoSFV8H2JUh089V1z6mjfp/PTstyD77nk7a06Fm+mNOqst/6NpM5Lq7s7Zn1iR61+8ZjN5xhViM0xAE4FB2U751S4gNYNCz/+FjoMSN++PikVL3kG+0g6hCZGfdxzRvg3wFpgSFqgYe39nTW7ceMRV5K76ILUN3y1pr71Vrdtxl4/ozIJgiQM0BU2ROYG5kLIUcBl82pdqCrfvle/1YKSeFifcwZBFA8URosfuOfHupkxtxTeW/gwP/b9WGsynZli4dfGb1mNX1euScK8T6nxkgB+twyXmdsNaHb6X5sATvxYECR/o5wYyEK2ajCiqln28aP1qpgq+Ie5n/5ooj9bHK2zLCmTSdUDMDgwMNI9gyiyVjFtY0VQo0qQcwNMsbR50OvYWwJgrJUPkDYTfuVAIGRR38cClkQX8hBOntstxa39PRhgehk3V8/IrFk1UZEqHz9LArwAXF/nmWcYJlAXyVd3IjW6wdjxeO/k5wOJH7hxtuiQdak56anl7KZRotNrFGBwLLY/+Jlfu+pdM59ZWDuLtQ7oyMDWeTGCE6IgwETRquSaWi+uByM4rFBCSYYyf4Oz8SMgxAYjmcvqk8Mi3xaHu5k2EjD0yqu0HQRaV/n/9UioEh/4HouZgHNY3cdv6yN3OxylbyxovJ6bAyp40GX9gRirCIkCGfm5ZjNzxUthO9sRdGA2G1Fyhni8s60q+4pW1AVuc4q1+a3OJTAI1eRyzOEOcteBTAQM/bPoT8c9mrRF/gS4VOLxnfliQnKDACxo5PJFUrJTqxaMVWUlGrgsflDOoBxprZ+jiXQI6o4lYT47M33rdTXGdtHhae2BsCOZnG/zTQEZmmlKC4PGWsbP6FXpJaN2Zhy5L9PeV8x3oZo6t+U7podkFQyPyAhIbEgRUsXnRBsAR72hUvfsCKlLOTzGaW7FrRCpq21ise2+KNxPAIJorlHE2gT1835Hgf8vinAkmOAQyLqFOzhK4gNlhln0nPfpS9V7rZqxcwlREkKhJuBcGyx/apDPRLX2hesNX5fUAdX393usdEmUHJvGgxeyKFxJMurLHtz6JbkoliBxUMM8b4WzlaHmo1mLxgVpAXyCo2T/Q5XdUIiAfEkSJoGHJzdKBh/lzmOU4O7FwFwI9sIFCIbbAwzZTFXJcMWq5K9lN/5qXQ7kjcVfD+nP4sjiSh82woczCRi+icjLZn55499fsn3TkG3pykrTlOuuG867Y4oQ4g5QqM4LwUOS/Xqg0vUIYzq4Xy1fSq3Lpt0U7ygCVyE9S4gQYCC79CD8R8kQatkvWCuRA5BJpXdEt16X7n0gn+HCUedEec1Q7iw8KxAby/PHFJu6rswFQ9pqV5RK/7F4e9P6HFUNVHQe8+4PmkGN4ZeVStFuYsnqPO0Nw1ZyPHzNqfgg5qKSNiB9t1mUosLN+gMmH+vj/xQgKJE5kyfWz5VPEoeVhHRF9bg6VioQNjyZt678tfFjyTDZJ63ufO1vEJZJws9ynmUSNc/rgtvbf0tQNxZq7S7PznKf//OKBrVG0wZFtdVht5bjVEAMJn38RmqLeg33YdZT0PQ3xGpROAeib5nSBZMaEjYiYbFIGY+EFKleJq9B/RQvuis2VU2L0fadr0zJ7KPtPd5/L8OkriEKRBUl9G7OQTB5qG8GnTmwRVg3uDLt1qp8E3QVgSyyo/qJARXWqIWibaC7G1UZgLlyPWScjBIRrT5k6Y11h0xJmYVUQubQL9RXdJtsWtNDsv4Xg7URd3aeaqe3DzmZA0hHjgCPJO5R6PmaBI52xeAkK61jSJWt+JG21d1pbX+Ue1PF52cRdBjy79gxjO05yDQ5PwVRm2Zls0H1Jd954wG+CV4Mq86jJzo0m5TMr0MpC3zwKAX4Bf07aD+KoIL6a85lcIjVZu0DV5MoRZj09v8yvwvAvswfOTiWbQt0XVHBkph7oafEvXp93/o3j6pdQkL00f4nnAS2sqOJwh6F1EG8ttBLyDaiSzPJJgM7UHXd5EDfFtMJGR0gVz98TbxN0ozHIOr1kL9LsDBd9R7YdgFANT6kQbo9sW0oUnjxFgHz9xMC9BBXFkJtr74m73IrnAd1uHyqQYpGmUSinCbZRcj3xCpZNRMyjp8WtnhtLmNs19VFN9dXE3tYrH5B4RU9/js0H/wmtAz3tsPWy+6RAXrwpncYlPXBSHQ9Ny/TlxjrRRStGYBW6KojfY23U8ftQOxLmULiLdlicDF4HKTDtAtkpPeSddWnO/363ZI49mU7uSgtKFCioAiiDITJlJHVtvGgWbt/Pnvalu8ENhQbM3WCDQKbAZOZgBUeKD4Ng6dSEAW2yUAUTDj/RFkoVZH3eMIhoAinHSrHDRXhFuM2vC2JhhxacRN4dEyWGO6o/pHjm6NiDxUGwzuYt/7effmAnlEDVheoGyQfj7H2z1XczMWWI66E3t8pYG3t85D4SvDq/peea3BiwW5llq0T7Hvjkr/zqcIENZEPfDHFpKokmMBZuY6R3m8e00fepBXiPyDM45YW5hl/FfJX5nPkGuInFGiC7s9BHtny4pEY6o5B7HWfXDnlB4JY8obE/Zt6ErbudburOI25v34u1T8Zx3it1hJwwP/EZLYKqu9BQ3QG+zC3hTRGYFKLv7nqbJKtHi0b021ngt5UjOJ4UpCkHvOd4bZTixrI27S8+BeUPHSsx1+a8WB22jPmcforly3Ccq7/mKUAlStBt4peNNUAP+SEo++ZjQ8h6c5Gaz/tX77X1ObG3wZWRp7WPXdPae9Y10Xzh4hXu94ywQcZ4sn+jpoquq7c6ESMb10RDZoHpfSvTUu6dkkARqC3DZKmeOwOmNuZtdO/0pzRxuFJkkpvTtNTk7r2Z22QQv/iRSjwg6ZLDj0tJWgnM4UxHeTDPNiko1kV5dRLKS/IbYI1C94l3gGyc5OlyGAS8ak4eEiUrqtv6LgFN4LphG2tIOJHvHiU56OyPx8q8c9C9I2h84Mua8iElwlvc1qmsfkFxh1szaej5DfqgGIrrLojEtR/bFjE88N0GP+U8Ail6oXVdMYg4ydoIVY/D74yn6N+m31+EA6fN3rRz+I/5ZGArR79COG0NK3GRxt8Ek2MARAzr9sm44uzXAVK0V9O8gGhrhZedPq4/5C0afhDe1KjWr4wMM5eQW838xt7IB8TMYpcceFGeFhXtCO/B/eBOGry7bax/244n++z4Qwd3x4TGYonWAaD26Cq3ZfVkN7fSRaKWRjdAw/55eoHZzfCFk5rXtlHdp5GnjO9JPBEGQAARnv5sShytEdNgohnbkklNeaGLPwhiflK1LfxPoXb/THj1q8AuEUTI5VBUFEkfkkEItOq0X3m4HCyuoocYP1MAlMp5rORWmE94rjnG5fvVp53jYRFkiqRkiz7EUBB0UbI2LpBC+0p1DVWJwdhMDsYl3qcGLY7/EomaLcTSS1IqnhzoqUZ3yVCnGHXFFMQv23LRpYryCmlEY/LSinHL+Viqoe8B6V51IfkUBvbGfNJWUgDJcTxnYs5E9CpNW79Ae2U+puWe3OOFSSMVLUzyuCO5s/54GFvyqs/+awE/YqQ2vdseZxiCegPBdfKREKH0c7HEMO18MrFchcb00n1OwH/38F0fcohpMgFDc/BIM6ENz3zP4AwIJWBpzmSkWm+pcFUL84dzknJ9N/dQwvJ8HzVKtyO2sROMCg62rkR6H0hxO5HLVMzGuBAScClKGY5T9+tvSDDP2p71TS0jAwge/f2mX7QsaVByutzMocdOBgtWK2PdR6GqS3A6b7LfzDLZ6iFjMAzSRE406VaXyQ5K6Ym7ZsdXnfQLkY7DhaiEeEKh8U0Xy4YJREHZ9HggnmAhtoqJ0gk8aLWrFxNahhaOmoxyDQLcJkh+WeZBPk2h8S1acyXMekVv3TCJaS8GZ2D4JOwbf5QGAyF4LKbucSi3oATE/4rvUHn1Ei9pW+vwYc8WT41JMRQM+IMub8fieyCveqkVYp9caBTMQ28KR4bNhFqRSU18VgXf7IksTvUfhekc7y6V8kSHOIUnYEMcSOa1LRjDLTaJjY23FakyTJl/Pw7Rk1BDxB4ietn/TUCYICAiD2cQkLyIRG6JmSrT3bBLd+H89j0i8+dP9F/QvwtzADM5GArwP2Kj/Jbg35qkn7Z16VrLsqhdrCSk53VX/9zYWwFzKjpdO1mWc36FusG8gZKrZLRp4rsbTqtciXcfbwcDCq0em0fUVPU7U+UrB653V7nMDOt/1609+/iLRc1VzFYnoGaJjhhvjWg8UxwrDLcE8iph5YVCgBsjMdqsD+KqzyhjcSjeWqZZFCYIjFlNAneo0psHiJY03XQX1HerXbxksXeMZ7WQ59r/rQlbQlpx32TNpxTFN9CQK4FacHu5lWAKU118nF05EKueLVNBjYRyeYNevtVUZzncss+xdOyQeAYegIO1EzJUofZqYAF8wi5rwPCXDCa97PGGxesYYkyjIcDFyHInP7fpGOVgWYEZ+gaE5PA7a6XeuhC78kyjJlGRJW9wogGkjRff0p89idFRm4aNN3OYMdD247ADpjk3e9N91dKJgIQBlfDaa1Ag2zMQez50BV0nDkuifAjiN9qZPHTPu6x9S982vWYqHOsmXNP/OVaBCd9AKJc/X3h6mtY3IOW0IAGuVSOlxlJCeYMXuJRNkxGtoA2lHHnRdcNPbbTt+XPrQfAODwvwWW+WMqaB3CXDME0UnKUQteM454x9K3/QuHDKW/5J5jmjsPKOvqhRcU6FkP6oCwtOWFOm4oRMmaPwvZIYUdHmGLjBUNqSa8+DPRFs1nqUJ84yNHx5i3NlL81iUYTaFnAifMq25cXWgiuRIjWlJLE2efR4C3FX091jF7T80ewjotqrfEIH+8P2Gh+pXjchZo5DuNZ4GUfMNVbWSae6mGOvfOJgeCi5z13+K+n/owMt4Hz5/+KW6v+tNO51hbNxj45OBZbHoolDRugrEZ+RGc93uJ1Cf+xZ9S5JCn1ArbeylytIXS3oZvee/P9TV2/KO61dX1fnL66Nr1PH8e7HneQU2jyDgaDTXizsncHEj/1xJKeq+6dZGFIWmWqHi6R7WH55RBKaa59i8ivkCcga1gvKfSw5w1GodL68ma3ukk/WlaOubdkrymyRv/KiSjmPtepP4fxcD6LBiakhBzBQvwp3w/S1ANqIwyVqhBt2IQqBeYQ0dvaziKiBRCPeJmXX4R598e+7k5Qn6+W8QBg/FIO3DjiYEBSt91NE9j0OOH9fIB1TTBifVgDB0zNvcQwsgwSIrzo7sDhDfbMRRJ6aYalf0FWhXGeTHFX7PyMNZGHydsLldIuxsFJ3XwmMtInTyEULLMKHgVFrujo12h+xMSIDKVv+twzlvRlpjhlE8s5Pm6owdDAVtoKlkEhDlEKG4XR+koLr+O3ly9akiQsxXPEMLb6ySVwZnBnYWm+6JGLuRc/IEO7uc+KLnNr6+6UQri+XaArrzk/hwcKWM6f2VXeqtxo6vTGZ2YOel6ynvadBZFzt5/6s6GgDT1fmtuOH6zq1t4rH2sm3WkobMQDzGZQ8Ice5SksCR8y7kTWErQXf7Of6mTNwSOTwbG1yglzuWDkGNC9UPkVjtMLQ8aOrI46NhZjtc6bWHzxt9Ymi+0RrW0+tmxc+VqLBwofb82k8vQnWZcZnTuahmF+MTucD1mwiYQDjcGJ+YVd991CmbO8aEEMWw/aehQYqssPjBtjejthO+LX+QRhaN5k4t6/e67Sd88COHWNAJWL8bk3MV8dyoOV1ef4KrKz0aYf5AFmb3aUIrEhEp7Qc5rOH5oKymjNar/KYw/H0V61zJvqO39a8Ib2RwFwfnY60Zz/WqX5uOCPSv8v4dy0otWgTFVbhtdjIGHqzKRWFwq1XdweHqg+fmGaOC29HxpCHg4D7iOLJj9fz5SJNNgQWzp8S5g9mZZQS30L11skSv+ac9p9Fj5uROT6TaTyHWIukt2FYGvludLK0MSgEkXhLDF0bRVCBAfVHbRwfM+2+gXkteOoevVK5K/MsoGQgOQFoWPrjCHPl52IpudGQGja6Jjrm1IkpbQ1w0BmsEgMUKpeYAP5tlYkK4Nq4DFUv7MnLLk4RWBXdIvMFzX1GA8M0JAM/ROxcBOJIHp620vvxGWboifyBkpATpiJDt/O8Hvw9y3ZhR91T4MuZuwfz7vwAw1MEgno8+kH1V0ONJ3tgiiUgn1W6M9ZEG9ztGndcOXbfoQ/PFVywUaLWWA2PgeCQpr9q80jSPIAW9hxs8U1cO/N2O9eQu+DqCPhIBFvWfXa2yz91zJwrnHr9ygAvJdxGwv/vG7VenXMqwkCF8NBHiq1OXRTX6RWoxGZD0F00xowGLe1fGVNmz5VeBOpA2FlNGJEAf8sfov7/4zZj/nhMh3dbfUGEOf4WhC+9Xq0eiflILL3A3fpVw19YyEdtmQhBAFY5pHNvkac74u7Z5fxWJDpXldnENeD87Zt6EnGJrz1COkei3LTTDPnCt8FbviOWvpTV2Af+IIk+Y1NxDhZ2fhMON3ka0dZWqI0cTo6HLAzVQqzje5hOx7ZqhvAVvSlyIF2/potFb+l0Bpon4v4gEGRBGOP6mvCwBxyEQws5SneA1xDs5j9h+GVo7UsDEXeiDfuw6B+ckpGJNxPLAupWf5T8rlxX0Y5zH4PZQjYlq0bE6V3W94oB0sWjK3koJhBQSHy/96eCt8gtH/4EJTuOSTS5KHywmcJRofJbEX8QBYc8RlpZ9blWMaVWJuRu1SNSQqYhgBlmWU1iJmYsKNd77nvav8jZuXHADcluLdFjz0ARoAaqpZXBLGE0uKWYE1MQJ0hfYKp4DCaZTmh5ZT/4MabCxv/XhRd6/fUzXRx6RULKg3Zop2rCLdOp8kM/D5uCN91N47+7MbGLgkBoUWzDjJqu3KyiSq35Vbig7Fa9T3zMfIWaqfrp0RiGm2rWS35cPZSEoViIfbg/PDel08r+pbotJvayOQHyVAp4qzXqmBhqjaV+VLRME6Pyhoo5vCoc8EdHBTkJH6Z4ghAv8G8+D6KxX45/uCtt7JWqzpvWfDEtjpvfWl6SCfPpFylT7Q5qf4aVePfyNhHrz7cn+99g8a6H4CIQGdjeJ954fF/GrL09na7Q4P4WH+epdIyEjg+HhZ1bUeE+7F9H5IEjPJwqQvnxtE6nexHwY89dTKHlZQc2egYNqLfQoFHzc6gmkbZXxUIJDDvXlbIV77iawlMepOcwo1BBJl5uQwibq4ivHiw7CT8sGqrAh3+5Aqj9H6iP8e6KhBuXzaS/vBn2u2kIjqruFUb28N1jr6lGMvMAuQOYN+fq8I2rGAcbGkmxaB6pHnDyHTeWvJRFGKf2U34bRCxuKBuhadUsjw/YTVTJbCSzGw16JDij0+gZhViTmZ8uSl6PNBVp1SkIblZLbG9H555TrBbSLKOPZ/bsnhtXJM8920KiRd35bCdzS87bd2L3ETgq5JfWXD1rI+WAp/eCZDUnJkDoF1xpgaMHV3YxhSdvexG0EpvMZrUQsojWlsG/HCyYzPrx6qm3jTqeA2/rhD2YDgreIhXJ8bqpB5l4pWsUZTeyI09fw6m/hc9A49l3B3R6RXKJ0NE4GjnlmEOhM3HK9/+2ICMiuUhldUjxb6uD0+6zse20hsXutlLt9niBswnEDUOqY66YX+uIU8OI1AIugqo9YuXrj3oIO2xXiYRs0jWaWlO1dvSPlLyCxdDEtKPysXONpVgWgznRTgkTRQWWPk/M0dVFTbRZnXIw8sst7GN9tOYwzvETzeTIJmRXGyd6DjzUZsK8qaQ8IKfxCkfRn+pfvmDs5Is5gcRU/Yuj/SI2gUlLS+qgyZV9eRxTbl1/UlKciB+iEHD8JD/4oVDhC+Ef1QWrbdYqJftnXB8PiZWF06M950lPbParxg1QuU6jH1M41Z9qR82z0fPQ4EWrxbvIs6mxxImA4dBwpy8SkG2x7W2WG9bqSLDHdU7e95BwQ/QCblxDqhTaZjbf2KjvuUkbeJ0pGOmfflItZjwAWna5yYrp7Wmy3qhw6so9EiqxGAti7c18Niet3Ddl/LbGlOeeP/h/oFoobJE690jUlUI4TqjFI2iXIvgmcSpGtkHOwlYQB6J9oQM5KFNOaT12UAeccPOgjjlIk+hVvfDlNfvaP/e1zK3knHyMiLfNckVQMzMYNsMQfOIeUERynB3m6M84iVgczcGGdHgVj0a6/dWIKCwnlVlGYperAquT022qCUvo9dKRSjzVBHe3sRxP9WcIhlk3txC1ZMw96RZEVOwSeMvBB03Dmu30y9p0dCSxY55p56eZVwgbRmFVhcCVDDcz3RThsb4rhZd1eyOinikMT1eNnlFHnTpvPDUGeeIpmuB0sd0WIfD8dNqpwiodFpOl39/QxybBxNPbZInkgIvdYT2yFEyytevYnbpm5u18JIeuX/YV0VY3Wu3Jkumyua37xcpiw/y0okWVYpRztWJDzgcvp++EQmb2wWPzICh8ra6Nui0FlLhg6Noh/cynLLCMXO7kmVUh0kGeGxpkrUaxkIx2s9AhnSo8EOkcOWRf9QIksAxlwa18TuCryfMarLaJtCcBE/+VoIfLGF1iOgopdNgiuzxctg3vw+TWLjBzk/dzDyACKcrwe3dg8FeQGOgCj8iScsSIDZ7NP1ZkwmR03qdGTIwId1AYrsFwD3F9i+750puER/Z1Iv4LDKKtwVhwYxQnl/nM/kCu4um6wv1/bSp69kzaPnoi8R/Yllhfdzo0+8pw4cWashcOtzxKuAfJA8FzH6xJPb1Ak1Lgl+vvoalBXUzm3WAbKZCsspj6vHsm2LPRdiEV4nqb/2Lm0lcwEZnq9/u+Y3S2rF5EJxDrMkWAW+QDKPlfuq+NScJW/NVSp0kVKtGTZ+jAOeYbJcu3ArebGFbwWTJTNhPW7SBlkxrgnAY075iEAZaRMGbOb62r1jQeeDhStrPgQhPlgE/9r43hX7kR/y5SG2NH9hOurbpoLBODG4+4gJHEe8AG+26kBF7ZPUqW6CQvZsZmlSg12DSxgxrBxz9rZGT+oAwxaJBUYRifyb1zRvyga7+BYw4Jf+z3AyzLiWh4j9cYK58/KSfcHqQy1jtbkzTCOIajYgSfr9QKFm6sfqCyjRY/fnA0XM+8NuzrOqjWWsjzw+u2+zNjwyKCFHNuYP9omlLI6zyZnno7pjwMRYaxVNwPeHqIMxkg1pDoqxjpYwNy0PE/yAgdU5NawpboBVDmylDJUP0zJPwuN2scY0UZ4JlD0y7rBrcOL48NjRJ+qw7HvbVTLEZvQM8xMTasL/R6drMjXpQpHS08YWz3Mm0Zz2Ifm3USX+ui3pyH75DpTe24sg2ELd9/saVl8mFHvLhguZwkRhB+KCcNxfcN9WTS597iWnVNcAceLDjNiX/6CFsQW09q2gZpXJc4ZJjAoClgoPFtHmZXAN0K95Tk0jKAjIbAzG0bU4+ffSe3DL/cuIO8hREiw/LZ7mT0zU7vvtMUjgQVgbZhbIw4MmbHR8nBmG4whrYoqe9Z7fTMnd6bk0Ayy55tQuoq3hwhF2u19d5zOtuz/bCQLuQsgCgi/o2YFMF/H89CSDUijDvMnKZ6CXDRoyFe2kZiIQHmzAGnsL7tgut0J5fku4ATacMH6n9Yk9sVkKg9wFAg+KeUQtfCBlxCUadyCDxH2WbZxTK+TxBZJfMgtHHkHvY94sycxx2uTa+uApf7/vT8AAgbr3sDSwR7UJicQwDMx7dZFLvWAHb+DuBrpHInMdKA0cqJ34Pkks3BhKWa+T6EKaRnH26PiHAGqqgJDJ8F+bwJJZJ1iwEa9ct/JzsEQx9u2/GSTC+a3Jqgls5jdNWHB2fXAlU6vbTh7Yg6u6N9wkIcPNT7fw3qDC+kfOsCgK/FcUoz2bhLDAtsaDscwApx4SLvIsPHQc/g/2+CVBPNaeVMFnJ6sz0yEPHhFxTUJ/lW4XAcYpUweDjyP9f0nmfSMpW6rlW9stCBQ7VPE213TK8y9ORBJeM2ZYMPJNxqIUUIjibAzUf/DFjBTUPQ5fRhYV1wSrSrAF9pmqLI1w3mWdKviOMTyKknEFYHgoAFFvyWXmkBuvNrHMIPUHC09s9D7nGr8nW3ZapNBxNp86FHt9aNNMSElFkKGNMjSHdBNELEPvL7fzXFajRB7NcfN+YucK4cqPHuUGSaaZARbC1BGOD5ZFTBBZYdrNRvAcwQCcdJaJJKqreK5XBnD2hKh6koR2LyTTKcs83Sj4Ku+qLT8VUaGDe1QZC43mkre38Fk08SAW0q1UCdaxkG+rm9LuwfugVPoL2S/U172lrJTuk6xRIlwgF16sQg8Cna+OfBiSl8ve1+aEJTWWbi4MEyaSEB9dmnVwMwuSEdVHCrg/A+yV+MQApTZ6P17fZe7aMDYQZwM/ypIALzgpR7Ri4ihYnxJ3QNg5eJ3cQn06HHdzYgMyDOVf15TtY1t9VN7RX7V2dYpeT85TMkrkEhKEpWs6rHuone8jvFgZ6L9JeIx6g9GP3Z/WmrM1Fi7fFou37UNd7HAvTEdeOlBd2cnMjtrsFDD7k72rHdKHHW7DSBjTXweQbmYRGK34VaIVibW+KwqkNgG93kNd8XQIHxcbA/y10Ji+xVBDaEJdLmQs078C0LMnNOCyEC1D63bvpoYcRBe2aLxuwtOtmLanzpNVsTzca4tJwAXwzLNXr1MjKEkLIQ9NoiTkk3DhQYyPSienQQJWA8iOJQbI35uSh8VPKjya/DdzVcxC/1B7slYU7Y1b+6k7gGUgUMT1wDdjiT0+RKDzsJEBBZDpsb7wWJWOpkF22GV2usIZSSZsKE+B9x5I8MYexpZW2b78OWxbXhVc4ksp3mxnezV1+Gw5WM3ihYwHucbpEDhB6m7dv4qZ1370IHzm3jpwv0MTJH2fC629QxKhhH0p+DpwM3iNVFKi1pdZgG0LdDgYTwmxSln0JU8amMFlC9y9e6dMjX/x0djUh14s9k8vNup1W3FV5fKh+egTWlYeFu894PlwS3tKq+BU5UQEUpte5S3YvLOmP2w/ZsbsMRUNq7E+5Qb/j8Rfp8Sk1aWFTnI8etX5tGv+4AKrv3oNFDLEmRTJe3BcdUyE75MaX0hw9ZqiVdJTMaTmECp+BJwBU4nU2TYVrhTScORLQts8E9KPmuV6IiYbbUdMAjtgookKsqs6WdPQHB39f3b0zxIJU7gEgoUiqoMjIJ7FBedjtHDgbLgvXv2F1zTHEcwyGU3fsgcrdQqaOYQtE5sSvCWwrHUOv2FVrB1LGzEnUnEdPpPuadd6n6LUwnawXVqGyCYi+Lt537yOGZxSpCautjNUpDQSnLEvidpDB40oCTLLA3e/i75JMeWhVF1zYaTCdEDrNZBHkIU32BZvrIYhEtOIYsnAo/ZS8xavfk2V9U2ZKfRKaFFsZZcZIfHn7KgiDGWscAA8ykrdUG+bGEyY3XqSjeI7KYSSMyVCx4HAoJqaERKBNDKts2/SQ/r6CG0CF2VEizaZKprcipxsodxjzIQt+6JRUerqtOy4B2KiIRZ9+6VhpZYsaDfkUSFbCRkRy/bJMd4CDQxIT/HirZgCs27MOS4ypWn3srGb1WmpckLU1oYDUK7xlmEeta5i/RdCjEYRtawWsIVXDzRBqPrGIUiUyR4Z+Ib2XqMyC97WZPA75L7PenkPaBpNcm3YEYShTpMfnsJlVJK/iZre8WbdzBJYPhCz/A4rhqhRUJcSuXXEL20zRVWh2zmpxkGyXoYiJhsXylXn2NsisRzCu+j35QLCtd6qKua3E/0k2ya9fryIZUhXCC1IhJ7ufP4iFdKJscCozw5R81pHKDX0bfPisU0UquKoY4XiaLiGdLUQN4PSlMimZlnsrQuxqEOndERCYjYefoYVspTM9orGfIugIv47rP+eQWKSqTodFp2vbjeWRjW3oOHPFDLqXudLDNEM1Gx7NPRNsZMsLWv3t8jFQkGj1uJgozCzARBIDZZWxu3ztELOkYJcKrNI/cS8KiXKFlXQpTXR4FD/PbOMUxzS7ooLTpeL72GwHl+13+cSYAmcv9+Y2xkiyHxsnf1qTLIaqh0232hfpBuYWRBKwCni/+X90eC84Mew0nFqfnz4QE3vwawzMjQsWHfUi32F9jYPkprZs7vfzEsTOmiKORLCqKdDEZx9S9Tw1R5WeHQ62QR5OzQWZwhM+6Zjo40IxYcto8bjVES8AmSxXnv05viCrE7ymqGM+Pr0ws3RBDVSYfG241IJiz4Mi4IkToKHvTKaKb8vpIh2cnla6fZuTJuGl60Olw/HHTY11m1Oefo8bdJ0+j2hGcSnCTDjszaSGk2satmaNM8goCRz4z1icrHgakp20i9k/xZ/+tA4Ap4mDtzPvYfHORrLgeoOXSG7wjL4u08ucgmQNmgk++jdiroUW3wIBZD+A3ydT0J+kYLsbXUJ5YV+Q9NlapbzQyINAafu+UWYE3/lkGzK2aZYsThrz5DfME5jpk+5he2akvY4PAQyCCvRCo7aT5Td5oW8V/5d3ckSCP3fX2WIps8J6doYD+Smwz1IGl9uz9q999bSmqYe+iCVEjf4EvjNJ9KNw/oI0yBLru4Che8ggbq94Iaj6XVCKXOn5TSt63clSl5tDwVxvJgxWfncK5in0GfHn8vXKUCpGJFmvtrf/TBJWN3iUCt48ZcP9DBlZEXGcN5DoHU4YH0HlRmUEcVS7as8uDzl/wgF6AktJeY0U5WI9T6Tv1NWFPVNd7ifERKel7nrylZOs5DJEbwgh6WvnZjVprHh+cPsDpFV50T/GPx6H2hEhK1/1MSVvPVYvj1Jekhfw8GsA9sXPBx8QRu6xRMwmWOzRgFTgeIzJ4/svEOoAwOxoZefTj60n3Ra8Og7COqha6G7zhStSgdGOLnJsOba6uohWN5+xfXC2hPTlSj1RMjYdVTP3u15q3YNfjeGH8InvK0AJpio5ayuzxS7IGcJ+a2zH2HejqjK0jtTEifygcV4gx2qDJqlelxSf+h80BpMTcnWyQiPIBNvK+YbXF9kwKpujkBJjAVXMTWtTJbeGPmjluR/sNW8LKEZ2k7fy4I67B+BthmbbPAqlYXyp+pEwfIqod73Td8lFnsdGNtvSQfGTSUg8SJDOLwQwNjAy96LhzlYWzXwmIyeTxdUr47bOcMRV2N76Ved/eeAug/cJkOHthL+Gj2gnqmCuImkprAjhrQ/fMiR0I09NE9SexvWNlF6uyp23ERESZhlH0f+dtINiiT1X7AdH12AfAlp+37m2jYTShFj+Ks5HwnD+9U96njxuj4RjWlBqgXXzz3zfvLt/ibvAznT8oxaEEzTGJmd1OwTk6ZfLTuF5+msLPuWeFS91/UMooQkFGODQxcFF/w0aXcDrW+8JiZ+wS9C5z4zzP+rdZeaUmSbg142Yjp3qdbdJsEROPNWlZvQAkWlHcn/ftUUDq59gpsRYzOhC0Nn6ttIwmwjCD2d9OoozSBfiRQtixPuk8Vpw23h9ua2F02DzrI2QcKt40UrYPtxSlMQ+Qv5zb3LezbW582hnkI0mtZwN8esMROpgo6StDMIljz8qPMU2FasB8VzfHCYJRPLGnwNnneesjCoYhqZC608ROt+xBfAFf4jloMgHkz9KBgkyGfPvUOtuGujzKKJQruLXgyWtc9mr0ZRuXCkMZXxQBz0UNPhsaS9tWGcKRoSGdfaWIquoW3FPuE7WSpgzPZUnoR8kGUSKNDleL04FhGP1gtZBwbvWUhlknYlOqg1M4IJJZNW0gH77CRKP6xJFYOVdwKElZ24HuZT8njLF9QIbjvEvabWxVqF7AUK1mEuCenXQ5ozXD8qku+eCywWPFTF7qCdUqufkP5pw+5NNaXu0trG7GJOksqNV34KvyOtgJWgArbR7MMTpzzwAq5uA0TSHqAKOaIIVQ33ptWuGdsQ/1RFDBX6T4ctP3PViGq+73yWZ5P+6zSS2NEjebc+6/m9jm8ndVP26shmeg6SXscm4IuiODLpa1fOG0jRX4DtoS0F23DR0/KzaW1b6oiMIkcNxiMrchcDfn3mU+ADQQh5M5//d+vTZ+g6XSgoE3uOoPXXVw6dv4uOj46I2jb2Bky7E0cv1RdSMpFg2mtVcB52Ym4YaQXPLZ0zzmMNTGM0NPNh40Cc3J2boSj9FFcLdcFDClMKXCelGKEMMEq8Vp4L2DkcaTkBoTddZfCGDBWvMiSv1iygXBLVnpuPnx9VhmWizlks5MJRkAodPuwvZhrX7yiih7yXY/I8iQKe+6h6jeJhj7AuY8VANKm6tYo7znlyKd1iTnxNnkKTaiPCyBtNNczVXVEmQObYMfFoSjZi0SGtYbdweuXKKungn0bzRDtXMYD+ZwrY6E+qT8wREYheVfPUmg5UfqjIugzAYx+9jaRjJVWCCUaHhYLaIeox3IVIKqKC9MSNDRMrRXpPt1LErDxQDwQKDNKpdBFPB3P6e+F1+Eo6cMO76vwyYxP9+SkiKDmNxvRtl2tIl18tpxqamEIOFznsuVTdWV4zt9+zQ3mJF+i5i4/pCEwDtfaX3DPuL+jXqN94hY4rFuV5GFoHytt+Qzy48GXon3AtePQGY2tfIwfbZpbXt/F3ShYlW1/xHCaAuE6t0M3wEIWHP6Clrx+EjPNxNQ4UI6Iy43od/b62GroSpAGK8Q1DEz+2DvFCDwVRdTIS2ZiNGd/gjlKWhQdI5PfIjuIgdvR8vZue98Ft83oFoQUTjeIdfGTiLn5pLTY3F+B50JNxnlNBfohc+ykNWiLN1q1zQ7r32wk3jLg4y21AnzVjTox4lbYVE5EBjoQKk4xAYTK6MDFXkR0+VlybZZHaaB6/CS2TZPwnUAr9W4JvS9Bm4o6DsjCLF18Jpv9Of2RTshoZ2jDFU0+3dJhqPg+kqgkHnlfXgxlh8J7XR9PSgsCdYpBNrD/boV+uLv3VrbPYLYViv8d2+B4jBXJjZYVPkw1+y6xB1QbXNwedNLIvMYdsjHpMNcaiJ86UHTQOEJMMY3E/f/plVJ+Ob2BSMN/1Ef2TMPECIn/6Z4HQ6Z7Q8I/v/bcvNbYyUQv426qEDV+KJWGxyEve6hhxwhVWmDVWgoFYsyF1SbvJuhfMFEeokRqt2Y/fzp5gWUbsmas3L02qs/gry8pVu/FdHQ3IY0AmV6YLL7cjPVyHZcpzxCRMnXbQQbpgxyHbocQupvzhwMFlsGQMmeJR7Lwa/TqXknTtdCqPYVny7kN9NTtThKC4rzjesxBnHJ/2qmEKulSRsivy8dVEx2HGZJcGJb48BUO7wBvnIBkxJG+2qXcivm26pt1PqJXLSxlaQlAq0IjWId7JqHn0IxuF8O2cri9WlXbE+1TX2mM1Dmyl6SQOvUF3WlXJKhDJYeEJGdVeUrdwhDBDJ3miTeJwJL8RwgW0MN2refyt5kTDHu5heJRTVK1nq/qlii+YndxWxQleEf0hb4YuErCCfMkxces/UNY3+hwIqBY0W0m6Qk2mEIKuI+szdv2loi6ob9LoWcT9utaDR8wBB9U6Kf+nsdJvmg6QjCHBiw1/7cjv46kh6IjbqkoAOfFnKRlZPazNcjdM4EobSkUaH9EmC+RoothAvaj4EvxPabTe9nZnaMFNPZKoQ9UD9p1t8HO9xIjuzA9GepGHKDlt1HdTAnr15eryj3UBEeL/q1RJV6ES2p8pCXrv95+rAfHQTJ9cmrpgxmZ5x5KXsgqJlO7LieTeMssOSzoUbJcdtEkwchlnyNFYJvVAH7C4Kg3IHgzNggXwnu5/QW5I+eITKfX+Mark+GK5fEFiMii6vkjdAdYxkp4j6lJE3TM8UXg/+grafDChyEqaRsXoGzFSnBt0/jOFnUDGXzMsO9KBl+6SJNLMvby0MJmzjUwuufkEYtTy9tGTOdj7qAWqRLI2SsWFNBzHBiWE2YlaLnQ1XUJth9MWwt30V64kVEC1Bi8v2w6jdIkjdagYdW4DVniHpN5JPApQqXtAPQb4pxg+wWIvS/5wbsWfkUfTfIw3DLAXdJBTy35V7gdAGKksbfBcfPtNftLzuuP7EqAG8pj4UGC7hDZ/3kaZVzRxQAjmgcVeUAGW5YzIRmEzgKuqbo2sisqySJtiuXEvT0f5kAiGNfevek3Tz4Num1g+unQHWx/2Ii0CNTaSnMCfPKZA4FGrDOau45QvK64smnD0GxJAnG5OqYmC737dW/32MrBzC7EqVTa6uqoia18BFrwq6Y+DsriTi3KlxIm+9B1KbNgfX12iV4chu6TGlBZPo9zt+/9Soi31HSE9ryFLEyjYV+pCZseggRniVi/NmmZ4CwIc4XCPHrfoGissMoLvLYCKsi3d0zSZ5EnC2MvObnqZDr23rjM7kcHSAehb54BroHTgpXLiFIq++0d/vvHblVqfvb6umLnztdLfNhaXhIkX7dkgxElQf4yxQdiXV2crX9V52ZBgALJb7mrXwhTMQ9nUAsPUtHcZDKvgiS1YoNsdcfdgYOv3eRV6jus72u/Ajfgt7U+2uJm+TfCHupT52hVrkUPLpZFFbDx6hs4Y5Ar4sKbudF2s7xnCw76NubEo2MBhuzi84hQkIc8mXh703251DVrK3s+62zq1+FG1/MWLPsXYSw2arykoFnl/1s4xBEzgxr1hD3zYkL9maMcwEaeXybj3YpK1GQ5oznR1M4aF36uoWzgVJqNOgTbOGttEtC60R2rAFBGlxrQw+VbQd5q3gSUhyG0HDg0An705pHYe5LJV/7G3yEBsZuYyZE1gWe6TDLGhoRGHzabqjL8iCSzPHfDOGW/FYrh0vDvY4ZRMnwz490htc/kt0HaaptkQRn5ZhhgGdw7fkOZTJk7qEjZtGGPo/jNzA02QxXK1UAzkTIPPlLQExX/roo12kYCI91S+m9xF8ygXbO3cbGDFTqg636FUlVG4Opuv5c2Y+TvceXobAtgjwiZMaYkYs0QXPpHsPjBeLqMHgmqM0Rx7M7PpO0fesMLOq7412FJ1j0PRqeNm4f7Tku415IU2KdzbUiTJXf3bl7lQDF/U28qfD5tsBP3nCCiE2O/PzMHSFcCLVfEfJygKRQLUh810nfCiZ+KbIKkpQgJ0vXryYjw/WmPNvKuNHHhS9lGQ2CBw8lOA4Cyf9+xCQBbnSBuRGBM5KBAP9mChrpsjGM/Zri3FhaKCzLPzIac6vTnudK8wPfmo2IKvc6QrurvPAaQkwBUtG0SN5BN3nB0SkH0DQ/Dco7T2MPoDlIa+g2XJa0mMB8Z1Pa1MJYAuRleCqgjY62Xk8J/J+Jetv4EqEdHyFHIzOq1Ws6Q5avf94kfHdCKMB9/ncQapa8ML5839a9UzwYkVXOZA+8kVOocxdRO9bb/Bn1qJhXP1eCh8qe44QGriTOEv17wtyteNaivA2FJFF0io6yBiMECGuyjP5fnfW9P936MrABWZGJX1r6DKAseTWFOMUatWWWlfBaR+Fw11FNVRlK+PWTvGgYbxVUUxSQbGKmGer6oso4oqFNVSOLBt1yO38klruKwxjciD7X99N9EukHBM1lk2CG80x+nJowkNe303rVoRHFAwEJcUNIooj7DmQqaMSTkymzd6kmHE2cTZZjDDsqPEoj1tvTgWfMXQ8vFYd6SBXCwEpSTL5BuXtKWEfxPZR/pl8DVwfB5dNJL8oBFAUPTYjdFSjBj34Ts/X/dOigTqKEP/VnTSx/UWT3hmFTGuOIypktiigs6x3g0da4Gm4SkGOW25hOe3s1yMKH0dxwlHR1Btri330Hnn9aMOq/QB1idhGG2jTdU/nuN/CKO2leNQch61lu+820Gchy81kzE4vJiTZ4kbSI5ZT9F3VGsZ7ooO1OyoiKn2zRzFc4zVbAjc0v6fPnacwutd7RnucvOsJUkbD786wwt4grgREOisMHgS0Pr+t2Kdr3LCMmQQStRulcoXRHolTmgcdZqO0px0h8ExtdVx67JUb21sNdrGSGzMsqwnG3GERKxq/UVv3nfd3iKKnAnL/Uo1lmQVrkpC46tG5a/Ofu5zsiVp8iTaHKMSziXKR0vLEet/wmKMyZKoOejg2n+8+9CiStd7r+yECBxCQHxE+7R2rMvZCMbcEeF32SsO8IOm0RiPHaJ0yhi66AKgGlnPW71UO8dN/dG6CzZQHsrQvUEo/v2ZBRUBFII+4zRf413m5Fw7gu5HkuS3g79TbVUJswz6SXvKEH70jrKNZwr/n0rNGXURusuOBxXgpjFnxzDo25+ghgyy638KCETiou8WtbBb2Hu2/RuWFh7qR9mSh9igHY0Vv+tJOTC9FOr9xd+6QG2ZIgxdj2hLtLGJAiYZQThoRYwJSpBE59kpaN/B0MuNY0Ak7kVuWznnKJ1EWZISojmjH7GQP5JWmJ6X+b3l3oxKXCj8pXmnq9RPe0ltWRge7wXWEbIbVfscn4dTW60osxWC62qVTjAfIx9Xft0nUkZbE0/ev5v0T1CjV4DQLEUBQSajzwhzykfBCUqj4m9MLZBIlACrK/l9KSeaGqaMrzGKtsD+VCqIQkTXj5V/auTgeCcecOT7+52Zfu5mCUAkzr90Jx6s6cNVZ0GGYhrn5sSEAbGMw5iRu+LWbU3IDlfVA+FcOApVeGfXXchiD6erHquZ1inmcuLm+lgtn+gf83LfFPJUaXoJX3E6w4YgD+LWzKJpnMO3PlBQWSJVsB1DC6NJsQlb1CP6ifA+mG2V+8/zMzRU16v8KsA5Ttdj5LV7EJsJho74ukUWF1dOrhz8jv5sYvW2M0MqCvdIgJTE66hGxwhjZTHqgHM5K5cg6Mr+0/2btKAtw7rhi17JcTf8dlNoIA2ZzQardAMYJbWfzitrn81paxEUxkuNpSBbMPeZ9J54rXYnUuIOwZ+2V3iafpFfvBqXFvG8jhBdVQmBdXjWNWfVFP4mgdwNvMZ9xwbkXdLeDDj1RrXkBaxr+YNvJ38wFAQyaT5COQc35t38ChNPVhpwMP2Q4OkMFqpIaIK/+CCy3qnUUhZTelSWpzg1jqf2BWShlhfqQPHmyzgTqH/rPzo8kzNQUMSrNW6+I/as/XvxbyGFq4Pgpeya5EMhQHjD3HjZBjcxJHwdTG3Xvh6YL9GIgBBKyvPA8t9o8dMMf/7XBFXZbUzyXHZ0O8YkJxjoqGVon7v+v5htZe3ydLq8CXQQhNsoIkztpQuJaGfHiGRitiUv1gVKdC7cqJUzmpDRNIoxtQ9VtO7ki+sUnzrQKsaaKqD58K38ZdSeA16BE57O4yOTcu1uESbg8b7Aq1IVx3DtUYEgzoVm+ZAmnG5gJmx7JQhny0dK92hW9WcOY5AjXascJ7h22b5m1MVvGDJPRpypfm7fpDDonbYmY6qWOu6Lopeua+AS9Wbd7GuIjvd4/9jCr/E+UDHHv+Ji9RGVibPZb39ST4aty0XkkkiFoBJY/f+eNLHVvESEch5k2H5imhjEx03x+1BjKy4Of94fig7SY0RlBhoebK46wlOeh4FmfNqkI+NOoNR1RzRyTkQwJq41eW3vsI3hC1peZqHLBZgOMLzoyjOztyWJ08ct1yHV9ljfArhRikmOW+CQPJG9pMmad1Usz2E55fLfN8EGsm02cr84zYiXV7zmbUpQldqUeIP0Lcmsji7kSCFh0M9sHbVt2j4/218JUqb+MbZ7LFSHfZg7B0D7gvu6RWOOH6mCHLD6BkmYxHB2NUe8Tcj52s91oV1wT9JLDpOlPGhcYQiIu7A28+c4PuTFEImDnCy6wI7+BsYyd4sR4U0ksff4N138kVjAWB2ha4FaReFlB6L3MvvzI1fsb+r29tDYhPKenskRwaQKc7AwkoANv0gbqwoGrg7kOmISdifpQWDX+94pyKGF8xvKZcyhSmKnfeMYPQNzBN7hCEl/Q5n1N54geDsrNhmudA068vvYNFNbs0/bibjoAyg/3gp4M/W21wbpIyPXQlCbStMCC7KczGxk4mwLZo/wo/BEEijeodD59WrfhEGR3CHCS7dBcsTxmrxQEZ60UkD1zFRrIsttDyo5midRDLRrPjmaKyZT2nTPX/6QpTcJD/02SRiTxrO8G/IIfp95RVuttrPehWeFpP5SYI02TfNOwEapraDNb2zPrL6Dbgy5SqFwdNBvC5ctlDehoA0NQVJAoP0zmuQinOApJsZmMujl0Ta3JyH6n/ckaLG8kziUJRw5Js1ec1DGtFm1hbm4l1LCz8PdLA2elmeJzzDDoX6C7LLkM7sHh7TWerLAne0KhiS1fNsdq29f1qtMgZMueZ76N9VPxoP2Cj/kQl+snHVB3s1beSu5zUA39P0xE6b/Goq/cCwU6fb7q11rFk3nbYboA/xUx1r9C0Ck4mjXD56sCltBmp04uzaFb/M/yw+m0Rp3qPhn+tUeLc9IxveeC+F/i14ccu83HBfYDHHKPpFFwvFE46sbHd3ijuqdZ69Q+XPY0nTuqCNtlnSJX/VDHpLtC1aEXyaaQXEXuuiakb+6/jYfGO/RAFr3CyJ8yTL3l30cCpOpPVsMirDJY3rU8s413nUuyJAFp/2SUG4kmkjQSKPuyPm4InF1hEp7qF9mPy66VdoB7i9p5iA/TiB/OJjDnPHnMW9d9iR/zzyYU4gde63hVIPKR35oxekKgimNg9UJ4DH5uMQNG8ckr4PFZnpc0nbmTZZ/7QiJknjCQssUOHnNXHWyEL8AiKQn/i3yIDKQwtfI49saRhu+AjEwi5cIZPs8tk/v35UOqqptUlL2hTuBBRnjKalUQibGaINrxYBUgBAfiv0ZKDOnUVvE75AVSv3ex2eA3tQwe0LLP4MhwJWmWvOxG60seg1ljqJegeUja50x644HIJdzMyJt15CpC+WAHVONtKzzk1CTRTALqLkYSOZTJcEsqdmZdRDGoUtFcFFIXBNkhor110ks0A0RqfBHSvm87/+fWyLvwflUBUlqUwD9+gOnjbF19qO2o7IER1hDS63HQxyQyX6a/t2d0fFm4S2Y1YFockLGh+Z943PjRE8FUqJ7ND4SLtvoj6UzJjxROENzXxPE0b2lR8aeWegfYAk6aLh6FZv+IBmF09Z1QOR46QBkkJybqW6eF6/RyDcW8qpOqJnPjt72A3JIJPpdoslr/JB9vj4HC8YUlxRDdNR+0pQVOVkZMsLc4MwWvULcIqVeUxBrrMWHeHqU9nQ0DKbtZuFfTW8CuCWgCx5cKCwM9zKEVMV5joxtZZbro8aIDM7TN91YDp/vuJrUa6FvA0+1fhNTOGWWPsWqWfBEAB7DuCKVJWaWujyKjxF2eMh1g037nE9znqmYmblcQWZn3DQsQd7ahlChCZtqtdw8wS6cMfyI8b9B2emdtsKP6oeUP7FsEiT8b+OjRojBSJ0hyJvOxnafh3c0TGdkxjrS/26TPkZocspzrYpGBQ7RGij6bFSWI2CU6aaub0DYLj+3VCBlz0RFSh0Pj3Y566GvU6XP+GoNt/yrC7jhYrek70/l7owqo2B+lRx76UiICqFTKCEg/wW79PpxFL4Cerd3fejmB07YW7LPuS8d8AiRY+TDluOroFEWCNMmL7Y7rMLQAH205xChwBC6R91gkrx8UAfcUlXU4VZxO+PbFCYErvj8RCEglaw95mpyWWnAGQ2NDEGMCWO0vEeoecKEE/tuGbShRAhRDTj7JvIa0i71mUAVSXpRcsLlFyvZEJpXCPbI6WGKIo/dAE0ZpPk01PQ44e1SjTLghJjQ7p3OqIJLYFV+zlranFB/2w35cqnFNrytyZToKS/Z7VMqmuNFmzH9q0gp5wd7Gv2muf23Vapi38ZgP4aUf+T2ebHSTBdosiAzbfg8TQm6rd456ieml0RHc/2lx1l+9//PPvY1ztp8ZN5+xpxkWYXGYrDtOksA6XMcHRwK3KyRuT3Md27MekR35GJOQbi7MFmXQOh+Yj+s96i/u1DJniGvDSPRi33wjltaNzPkfWVMHWklzh/LfbITZaFt6u782sKTcFaRgBw+DmVCadHWILzgoLaPOtSVsslKyzs0WIjhMsw/eARlVVtFCU8RkpvhXqWFQYDtMCwr1iMcHCDo92sDKnSmqdvPKWJwrS8ie26itGb5InepF7G52xERCyKM6GwolkGIZxiqZcTzQxIj7oT2kPqofJe6EYZRHttRMbetOws+N6kFzCVyhXAuZhMosT8jwEOZwHVBFxrluHlWNj+JXYG60jVj7JvDJBG3gWT/+hJNXqeqYdVT6cKGnVVARRDKGv2pKbEjixjEFICZxfMdFkZu5Z8K3AROzfSJS1EQeuQ9VfldoKRyFxKC4I9cExPTUF6iaZzQrV8q2kVX+i9MtWKS4q097qLN6coJFgz+mNIYyOjPUMXPTU+XWjcL8VLA8bZS+pPXCcoRUpisvWZjYn6e4RfLdxQCzrCvxtXIsbDkE+v2ruP/4+6ULM1pBIf/Gb2iJnVJfm/75Gh7wSqMS6cj52su8oP4eiQb/sBNw0DK18ImKS0tYNpcQItoiQtE+K7eVmkMxZhf0tB40Gvgx0cWjbPCISP0RPIj27HyM/aO5yuBpJZpCAoAX/lX88yc3IsGt0rQEEFfiqAIhjJoVj1RPjzNZUvHFZkVy/yxKCIHzOJAI8G12ksnRk2ivq1QCHnAF28kFhRqIVJJL8NGt1YUt8MXqoDxIYkAbkIhxhZ9FfnF7b0vHHnRflaApzr0Uc9SadzsyZDFow2OSQthggd0eaiIXimkR4DJE31kyPUqgMcYAYnEMvFYU3gtUxeh4hfN/fLWTXc5hPkkDpfbgm9DGNb0+L4JRzq/tzp59Si2X2jd+X2cuGG5ipN0w26B+CcZD/+7OjjucXO045Xx92DzZgC3Ey24suteg5Nopsp88BibIxDIOXg0ndYOt33mCEjUP3PQHLwZ8AryAI+3xUfLvxo3IF/iYKmTcGu5CMVyIBt+sATQ9brqejdVOYUuHx++dFLSZaK5GG+Wn0NasndYakUwWin39+bl6pa/r+th5Maxy5/dVqfdFJRO8Beb891M9qb1oEx9s55CM3MEAooIT7MDfZU1DRnkEljqUS7HBik2YNTyfuiAJBRGCOSD81h62PbvjNAIuwZwdioOJrSan0CcJf8O80tjko1Fvs+/hcRiqdfZiW14sPZy/Zbk4g6jypsoP6TyziLDw57YxoDpnLFEonLlyZx0nvsOMTu/4GVbDcBl0aSGsTWdUenjrQUSFAOZTSeYpEtoVBdZHcsF42y8C89zN8u+TwWIgRl5Qq/tbx75VUjUR+TfmRsJu39LuvCIDt3YLT3u8AXmmug86KdroReKyiuTew+8R2zskut4ZbCxQltyZs6ZUUzM2/Z95yiDHQDCye357EQ9RWcr8CamQmO2V7ww6+yzt1UCGoNbusesbuUP9tWYvktqLJQoh2wrxmoYxvjFT1L8Gky1I5KBOpIc4pv8zy1NyEyqehICrQy5ugrFvwLCx/1h6yyOVFmeRnboiqPk4WSrAiQ/rO4PWP6fa6/vU11GzinV7hqAO7uBIH/EcOSioUlDMSrPeaexxWeHQezZvfwWBwvDZv/m4blRNRCP/AQ9Cb+0o2h12qj5lLtxd+L1HV6oFLGVsHgHbtMEliyynONPTzd2QCXLtfcqMS7foB28BZedF/+f3M48A2EkGvRFNQGFO6KSo3wj8+hBegbZbnyzrNuTznDHDUOXY54qYGwKRfrnymqB74+8HSe//zd6HlQQVfgy6uDXooEX4XIyF0sxOPN914gnimAGb62vPcaHEi4AtjsiCMqYY2/aRqJCv8bCotc73s8/LWp9OBzrk6VpHYruYb7MBN0HPYax+Y8QiayuVXR2agJr07GEP5jm/0MhBgH9dx6yllKS6+u+Jh1bPrSETOdV1tAAhpCgpek8PcLqLjhyCeLabqBHBw2ODGCcXNQI7uN3izFMxIACN9m+r9/emh1KDe6JJPkGsrByiKIDwFAEpUxCIdIimcqaN2/U/8eZNRbcMUQvwle3zCXQjChnSKklFgbhVvjZVhZmHyDDlfz70mPgh9p0PYud9ZJAdw2NI02Xju5gTUTM9jggRfARcDDGUShinCPEfMAXkqkJ4QQw2gwvuiuQDzkdccAifJmPwuYt+j8ZMNWB/ufxXEybLalCVN9+STYJzyzgmAeDgWpJY6EagYaB3DW2Ggme05l5nFjCM2nMrY50tdkc4UKa11JNYzvznu6cVAIdYsuKoPaHw1cj3WRTWo/ATdM5+14MHpkT/8FpqkfUBgkx9PdZV6AbyI/uLP4nfZN3o9Zac2rN0/aGFbPvrzmWGL+XuYD/QFp5+DmFuSGU69CdUMFiXwu0wWkodnIcvJC7hEpzZ6LQQgXpJzB4LMZQxHZ1mwS4Q2lDom8pBLgRdJ3FddWNRhhf/OC17Kz3GbH2oVy655dq7Q5qiTewSag+VNzEFtvZtjfTONdiKu49Pe/SjtSl2hV858oUp+TeptH84tYQ3FUCrpgysQO928Ecarz11/WABro0318bxZluSAAJWLw9S7b70xCTVGmDRZ9yaioAgruyUS2hAhMDl3drF0LWhBN/qjzbKDfK3xx2WnmT9EFf0jjzcMyxO7qh4EnhCp1waHRmu17m+oIe44nHjMII5OJvB0m+og5tjERvctvTsn4uV2jYvWRTVAF6PtNyKuFD9Diq6a8YASYZCnQmGKL5powpJTArQwCYdYL1hx8i6YK2TVelc/rxdyIcAbOua2WNPNldy6WNoQZp5fKMVKioSNTGdNPa1dt4vDtwp8N/UWc96KIgmcyY2PJGjwUMb3Oe76whpDMbHw3YJfcOX6mHL9AR06HKsVFdfcwhvb6g91jkyBS2ZzEv37CAn7AvK34CvxshXVuGhAW6yUIrRMY+Blm7z5Idb6HRahDXcwY+/1T/x2c1AxtdG4wHmuNyw9+7Tx2tCF8w05wXQScwFKPci2NcALbRYzerhK61PhlmKkXH6PdhG8DSS6itaXZCby+njEADGe3p8t9QGSPDxs4ur2MIfVZDVhS5alZ4EajDgQ/0axGAhgW7H3r8rxKe5ddzEfX5PWx0YMqyBqKB7qyZgDvtuoUckVwFPSkf2KsSWzFh7gMoVurHMSateU7zRoNAxExInfaPOZ1vc5EZuTVrevlm692H2gLx6C7UPRzgmXmF+l7nycHQ7FnSv6iVuKLSWdGII1PHT6cT3kHisD86Fhrl5+KSlE/hxeEAE7FtqukSW2M4vSBVA2vQVZ9eZwHXMr+mXvH3Gf4eF5DHJWuf7KZna7xq5xZvn50qxczmbtvBFGp69FCUq6q+6xuDqnuD8SvHcNYMVhGBB2YLSiQsmDbIRMW/KIATIoFUP32MQRiEBI7kVKx0xlGDh2UCdkwQIGBTv51QiOkUM6LJEZj6zlLWislf9IUZcie77+75pdflqqtsK+U8CBz00Xd9MgxAhESxTnRpe+DCcr6CTgjFGJKaQcEFwJG3WCEy3KLzT5X/rBfF/X7phroDdwjAuzryhzFor3U3Qla5KU6K96Dn44h590UQcJKBxBiMpNlrRET/i+phr48nB03hCtGCir67pDi49iJ3eSYj7NQBHCdkut24FTX/pV+NM1bTJJoiB4//+JKC5IiGxgosSxs1sxpYgHFjvs8o9eJ+18PCUh1yBXsBumq9aMdQRiJ764kP7jlZQOleJUqtXWAOrCetiD6SABexkgCjkCJjzVSNEUXdIT6vrJc2INIDpBkrHqDt7t8we8FvpB9ASwph/ybwytsAnthdqtpSeFgG4SeHWuOnyd6WmVzagYCbQBOuoIeJSHOZwrT/st6W8pLuo9USrAtkwFomfBTKEIKL7iwdUfdRmrKvm/9SFj3eQTx5bGPDFO9Se484nNYcFcRJkidHYFz/3S41UKn/ngSsK8JzjcNl8h2o9uPl80G1LNNKYBrWFh2GW88t58JqmEiGHqeze9Gh+d/pWq3ngNPKsF9LVxayYMi9i1xp0Qe5lD+MY2mLmJdZMmMSa4vXWcFFY5n0AK1cZRkSjLS5hhp/Qpkv67kI/ZqHG0VMzv7jIv7Uxn1gzS5JI3VjhngW2UYMCgEgA35XfDt65zLv4ndwQaKuuNhy3V8R9HH28xD7C4axkh0UYOT0NBUB5nj3GYW2cNUw4YxLUcslCXPgkbOg473j9vNyk+C5f6D705V5oJ/N3PvGSz7AQQmxt1MxbMRC+eOaze+utDrW6NJDgB74xoyG11TtJuMrpu/f0p4xQbZILDDcu0xWt3NLnjPCO593juYr123PUkFVGx8pMFwyhaNzyiaKchqAPjuG8sDZdEt0uYK1iF5fjj1DmD/CXSeuj7/Nq32yCj2eQSzRwfDE04qt9slAHDjdraQOfDu7cfyqyQJY+4NxzRqr0kfmR7BeL4FYhbK3aHxBLL6JNCo6Gc5zohgskj2uLS/+AF3qQ14EckoUGnnwm3OhgJgF5Rm8+pAG4D+TgmmREgsGPmjuPuzTFQ7NVCUX/3+5visdp9pIXMk20PG7ba36N4+JZMgsfYcpEE1QFUdoeNrYsRFmW08Lv5JOm6FGH6cFEJCnLVfQ1RBnxUznMStaS6pAh340fhdjG1HsCFD0FU/cdCfKO4iymr/OdOmsy/4JY+n4/gTSlnQSrKM55ggQRkTqbQPx+e8qVLoRYvf3ujNHkxsfgp7kiUVCUrIvo4rAXcNODLUsFwH9hLIf7QekYbAlzFFcas+sJV60kk5bh+uNviLR1IdZa+TFi5zdmOy8RK/FULfSc7wlbKZkzeBTIsTnBwDuIbiIZVuovazpUK/Lb1SNi5HRei9qbe4Zhy4d7ZV/aghtTXxbD6LHLthHJ+mmRi1rIKvvAqrUGYdmpRqJuaUxbA90fhLiIn+qymz+8O/AaIQwChSEmN1e4bWda/4dbNAIZ72aN9i8HZw0XbLicJfUdBmbbuq3vwYM6kiJmU9Ou7nvd9gWtmMZBQsQG1kKVK8STf7KnfA7WD8W5YvmSg3jGsxviT8n8e5ayetDLB/DYfBdx/NO9UtlYEK0ABz+mJaVPcuZAc6p5dvjzREWEWgAlYFCEm10v+7daVbBNpiT2mI35X56ntqW1wCSZytqmxIp8MYky+F2MaIT7IaTiScLlhS5pRdpJ1pxuIAqwa7Wz/OcosaP1ctscUfMp16eIjTeIz0tTb+dYHLJLvmCVEk9fcGrevvaZHbj4F68e8XPzoN49mvz7sbM6ZB6vkr7WCOejs/3hSYPbAa6hNauPrt81BZG1RJMOpoLTUQFThKYD/3fVATGU9QStaBmKsqWjbGI42jBxEXtrqrGUm+zL7LqM3pf7P/y+u//prKZ3pbKoZ/pd0V7g4L8JucdJ4AkUOxDmcCtdG8HC8Wy5T+rkz0SQPhKXArzwzmUCwjFoN3+9Gfq2a74dJF2KM2xZf506vbGFUJPbcAXtqX6eTOrDNFcufsSwTmOwcTtTTLeQ5W56DLFJs5UJYoVvhkFxeE4cNmZk24/b0vkkgOAuz+9Z+X8ZPs3/B1IUd3+fEzvkbFMc8pzuyym3UxhwgsExCQ9zGr9HgDjECjenBiD+HeRoBjPeqK4JSH1eXIG/3vqtbz51Fa41JIhLrkbJWRIgWzXUN/PbUaJk1/0jnpYQSxSPW3W5YHNzH2Lo/Pnn3z+99en3bolfroOUdqcH5hlhwON1C2vJKvIVl5j5JwQF4Y82wtJ07xfjvnquHZhc9IDlKq7XytaYZRSiYe4Qla6YGBsD61f7EmGusZFkrcG04wHc9iqalvUimz5EMzMY1vhC2mOy2kGaFL9V0poxpJonax2iFsHajOQ4vcAVTqxcfMtQZKbC/y0cttGAwdMPtplIt4QSuwD/9ajFuUVApjt6DqU3Sc1l1ht2aMz05y3PtctUlcIRPy1+CO0rFgNXEDba0AseGG8xNcGv4wedo9kNZgmYJNDeK5CLlskXD/n5NhJ0Wdn8XBTKzEsZa0lSYU79S1YBBcYS7ySQRn7uIjndWKvgA0B9kWIDAKK5XdZAG4iay9wkQz4eqdI7UGIcPSHvGtOnBaohX1oFbRN8udeERMLp6BAtCrVl9nDQmDI+UL89uaWsERjQ+jFK1MTryeJKG94kFx2BIqbDtrN13t3Y24t2oGkALa56o7ESvjFRM0lOOtfbhl5XvuHCGeGxsiOFNr30dW8OuCyr8D1MlDGFK+beHrSGZ4mjGF35X222QO2Aa1KfcnC/svBbXOirf6bxkgjuOGzfZWZ3im3mBidlhw96Y4ucgi9Lh3W96coyFRysQPR2eeokYI7LJ9NmkepzMeX3WIhxe1C3/SrlYI2fpJo27k0SaD+04mh+e3mzSrW0/Fi4cvQgMRAR4VH+JWGuinLaUOJSYa4aLX1J/JVqmCv+pqXJ9brFk+i9N7CGpAinJpmbOF6xR+fxddh+VWNfjSpn+EQFU7kLJ1Ey5u3vDyawrvlYOajNlTOF3607WM5t0pHV1P8GPtNikJ9giPN/g+9iuTBZr0Ridjo5OfSs3KXs5nA23QPD0xd57V2PghBvp5cmc1xALddkPMWgjglo7vujj7oJPOrlGkVJl4JDDu5YrrG7VYSiohbypXDp5gsgeH5T11yoHefr+3+piXWUq5eJoadootd5Hc4n7zBHgZM874zsY0r0+Nxk+HJrvyhQmPrkZCOYdE8v+XxW1gMgT2WQnBP3hZydZbgrFtdnOq5rYzM8jrKcVKqiGHh2ohLKLWUxg9y0ySjm2BcxYxUeZoiOGQWKhfZS3yZophc6M+pvs+McwJGSl6d9X742Yz8EgqVXXi/OmOZGvQ08E6a9uiU+k1o3sG3MMbgso6CCSEw4Gg5wKmOGR1cdZmYgVngNBfgAVCK1FORG8Z+NO+tDrklfbNZuWJVTYCkknAzz4qiz7RUVD0v9W4edg70ZfcCM+DiAFohAYFHnU6VIpY8RD7cdQNdry7S/QvtkZrevDJrTFnhspZxRUBTWrf2bzkxsc4GVAZqN+i8apN9nHtmdNnpjB7O4g0AD2RmRU1TV/dRQkduBo8+43NsZTDPWdDnECC85qi05uRpBIICvo3XYpUgE/TMVzQcX7OUFil+mdoXS/iOvxHkonDkNoBcauQA4HUBTXDvNYKzwNNKPTNrrsRNEI4DMl40tSwkO1aA2Rf5nXryKImkSnJknDTjwEf9WCuXL/6/SA2frOtSCwVk6ydfq70oz6oxTeTNbu1YKQR4DbKSpYNWIUtYeLsYGgKWotnTLj8qAA4mlhCQkKb1h79KFQFRo2HhFLuosI9AGVF2Vm8lcay1ELAKUT/YOyxynUj9uuzI9skui1mUYUlzJgN6E1DHO48VsK5dgw0INrJRqwX8q0lTG2v/mAk/laRwI9zmPM1xed8KDizgM3IVjQWyWyzGe5iCJUD3K8X7VAMS7SL1dqryF1BboumBLiyU7m8KhOOKjKwfUtaQkgCTkpXY4tgX6UGynuFqqL9kpumqOCVOti9zV2wHMRChy3IFSxPs9GtfczdnhLiu/y3mP1QVgKBiCDQJXavzz28fkHrDqg8LNsUtVKJdoMatx+5IeKAijpHC2qSq7HkRTHaUoAdASrkj5rCDFN/+cnbS0vfJ5pNtuGIodnk7xN7idjkSspWsozfUcFi+ntNraLUqveB+W3JaMv5w63F8xDcupInkY0pePIp39nZYUIFkxfcidC8sRw9YAIqG0+KccTNOwR9lbiV9wG786QDmh+O2Dxg1IDDnFVaBv3SGmXDxupoH4v7z7PKxythxCl9HMYcy9SPQigxz4+qQxyAaRMv99hm5qBXALttDlW8F0vXgGYE3dG9Jzuy4+z492vGmTcSMjRq1UOipqaj8gVbQ841cygyrz9t+DmsKyC01NCXIQwRgwBPdd1GnTGLdUJYMEhYnMNrP/DdRjk9rDtlQPLohcHBogaDiHPU6H6etUC9g63bmgjXSsBHBiTY4abKmI4JFOiIIplxQgrA+HH6V8y6D4qqfKFORNau2hUNCFj1R3MULwg+YC66UH+GNxeXIpySDfaXhqVDpB/X26pHHLOhaVgEzo4DyfZOB1w5enfZsoGuaYDSaDjKd2IEzERTBzMS75wLUzzYoJq1Jj+TRFA0trTpC6scQF44HBe1nJwqaP3P0awc3lm9fa9bMHCYBDq3P3doeZXtBrJFfZgJAXgLIqFstZIO+2vH96w5M7BiajmKFLPiiB3zquNIB061FS6WwAoH6rYHa4aI0ChCbWPXArxkebmPNt85iybIBw1hCqgkI76Rl2PoxrmjPH2BGRzKySqyhr2q07XMiwy5ElwnKWp1NDpT654ZGZRBm39nNwU34x2M86xT6ejIP0SY2VTDjR0+zskLYg9r2TlfNSiAuagNdaDgL92LkYz6NH4QoMQKZNBE8Ybv1GMDKaMMsqIYl5EilznQiXE3VtK0jhj5RY84RiirA1p7JaeqWHCErGFQEhqBnl0bDeytVSjHiWkWCqZaDTBM/bd7vtaHIsA3VB8FUXSCixQCxyPvYJLCIb/3rCJa0vZQAR9mRxS6q2nEY6hnHGOCnBb9tdsW4+qV7DynQyD169KHTMdpaJ1d8gwKX39Wrjkm1CbgfwnvPsz+jMHStAIFxBLZzCZu6j2dnm06Y++q+miLj9blEPP3jYFuyr9eRg0+5CTCVog0I/TABIUR+ilVb440T3ewzKOIJowI1/WblM52+1yr2+Ba/zpBgySICE+oR1erZJ/SK2zN5pdPosC6+imN0PAAbaGRwzx7wW6qgBAFhf1WEHdVQeGWlTxIVjNJo0VKFJ+DQJ6B/2sZeEoxe8gghDnq34Z5VPGw0hB0NbQVNE+NSgFnk87/plN+q5ax6Jvsdq59w64ebw4ZvtYxGwok3bw/3pRNSH0vvnW8eORMm8nheDqhMkLv5zAvJfmy+jbgJ12JV4a5g0RZF4hU52Q1u+R4nrkDlmCVAwLEcCIKYh0mF4FIj1iPdKNzIkw6hEHpsa3PlBBkVUayv8NvEm9N18yp3wLR7+DawF581zt45lAAl1MAJWQvzGGcoPZeqmje3LMBigDt+oXqfNGfvWH3QE2zJd31QsAf1LR6WvvrDQEm8hzxI4AAIeO3Mvgzl8um4totLD6DfrtVp/u7xHV8TRlXkfs8WJFmxxoXA7bFIugVzxkejlGuI2/DXtBzappNA9JDS1fxSasEgKMFvI1li7p6unqiQgZHnhKaNoht6biGuYPkGkSgWtBU8BTpoV9EqF9dc6cTkjR1k596QDTGKX9fD/8gPJBJt7mteiS6l51pfnEa6mXoDUlfOuKaLfOloZoHKV6avq0/KCH/Ovk35t4tk9/bsD1hf5VeW6Z4m350zzRzEckH14t1DovKBl77BstD/FfvNKerPsAvSR3xbTLqPxHfFpGMNzXUJmHKYZgCQb3dObGYDumsAE+wDSgCGTTxFCoy6R8jC6Cwy8E/NVjnKf2UYfBLPZFilLne6rahaFkzFGsVz/qYPYjzQXZ61GOEmSroYx/24YRyrLfsOMwulrCgRlgdD/nSBy8VjW1nCZshiJun9VRfnrRWv8qKMS1xnvKHri2XnPWW2wHZAHCfVL6tjro7FShM3nDDhIsBM3KcgohH3fW4RicTbkRVY7XEkg1FQuoamoXQPwgl4lcplQ6624DS+jaFEahTX1d6vpFI6VKOFB4lIu1KEdi4zGSLOqbXJnsILIKakQxFCEruiqkDy5pymSQCJla37QBc9GLTKR3Agh4MBxyVlQa1hTZS7IXZzPn+DLsvu7owEP2rCtU47JHKftu43LGMOGtHpB2hv/udjZDzecE3L55jFqSoBR7St2wei+pxWBydo3Br/kqZ6+gy7cGATogCXBwosqmsSFqyl/axGAwmxCKRvmCyu5+o5ZWqSHxy4yClHfW5s5tcAZ1swaBVwEeT4Na+ohus7mrTdDYJTKZcEh7CHMWDoXLxa49k1nP20a4nYAvfopLQtpAfgm1bHYwRDwqcPPgz5/pDrX9oPippkJ9oQLfVehOUqpXAWvlACHqBKRQuI9rtCwgJ+NlgOseA8z1ry8MR/IbIOxy0HIhl6Xnv/9GSRrD9orcVGn5qkTQ61stvn731fZwXpBOWq6iDjPqhk9qWXBE5c86vidkWuOvRbj4tMUWks8dkXS9/zr7x9Phqje3ODqTlQmNaBrBHbWlPidPvlP47Kf6ybsqIx2GihMEiEUDeKZ7b1KUJ+vbrQPZNzsyFRumt2JbB2lrLO8cKaCcQMgCsvh+hINS/lvQH7BtBv/2tlXIMNr4TIMc4iR/HLZotzkFslkVs4Y3jnSQ/VCsWBQUPQ4Km7usdicCWH1QiHiZLSK5x5/Stagyvw3bZylLMOvU4h+io5X/5a/HkZ4x5dx2MzQAbASBLEwCdAXRsdJ3DEt0nsjUyOpWa/VkT0U7WRGqlu6xi2B7pyU1pfFYIiyozsVGvBcAUWzZRB86mT3v/XXyZmojBOg6LKwxxJyZ5fqSAxC2OVGXQ95nhCMnd9RmK5b1oXt6KYyR1KbFbJRA4IUCLHKnf+Pgoy/h1YvwiYSI0OHSQdiny/f5OJ4hbYhVTBHFeaMTQnyFsNvek5lzuM/j17fhLmvnW78IbAwgDIhzYNLpH9PKNSkahKDbeGnCv5kOwh9gGM/6v7Netw55U5wv2TADqD+A0kAzYNS0THpWBnkU/pK+OxJ2a9dM/YC8LvR+WZyBvq6rk0Cbjo0ddzS35JViy481JaYRRQKJvvK8XmiDbS9bcI73Vn18aOR5BhW5r78Ol1XfFPL87MOvhTzE/Wb+ttgjk4QEmZP8Av4Sa8hpaLWxwOcmliagL/u1aF3/Tru3qUjvxmxXe7ktkBZEhhaZT8LkhZv5uBAl3zxjvsRnJuxI2gnGyOU+iL6OyFkDo9QHRwzNRfVzEm2j3RnAyGVMs6e+PuGOhwRm/CtroFGYkijZ+tK2gnT+KGTmtkYVexL5CXMqbpa5R0JhhyjRcxCDW1FBJdEtgFqhgi1mU629sj18lN1jIgO2fqSJ14yArbOzpipiN22GMYLX9lJ+tVNz1a63wc+xkpPHqy78Ju29/L4AVq8dlG4b2jFgO46okyzLrk+t6BTWgjlON9qoZ+ESbGeFlg1wq+NRIalcpDUUUua1zgiCp1ZMIoq3G6/9TK3A4E9PkQKyoHcOQ5vpTR28s3xEHAAKLBKjRDEDP89tEsAiJ2VGkiOQlwQeyH2WU8cf7uCLtmqIb5MZ5t03BApBsZi0OJzznXJkM0tbAKqH7z55FnAoKl8oOsmg+A6lgRZX/qHd7kPqKeVFkISlvWKkihBeiNRWclqtYXlUamjfzoBGr+Pn2JY0+l+D5hl2OeuDQ3TG3YCd3KnRlIxKBhVlriz46Foqv73WXLzMFmxay4ghVBxMkfySZ4sPtC7z5trvyau6WF7mPIAtRZiTB7QbtOAIksDevQmqTBQSDRPTA/djRq3lS+Vso+TZHdzHpXwCTLBBoyU5V5cQWYf3P3LlW124GwScAQAUAddqZONg0cYCRcTsmnVXxRLcrEB1ERQkpBoimmyKxSkIxiuSh+ygorlwnmOt4zUyVi78B3PQLOroeygoCmQtziuTpUapV2O2Fi7PMB0DWzXNpzAFU/36JmSVSPbeT7ZGZMQ1SMgpFUFuCKzveMq5WDBdupxCQgZKa38aO4dsrwFvlWKRf1DsB1M/AIJULUobCa1lPLyYF8NlfZMpQeOUcxxbQ1r/bhmSnDaKE97ErV5LJJVkSPlc1kLUukhnIFxcoEIzxnx8TEF8lEN0fK89Qmql33jxToctgwCHWYmX/vvSBAuTqNab5Oz7mw5TsbfG5nk8C6gfFLTg4q1l7wAvnLBbmmT+qMxIR0cBLeMdXfVtAkGEvHbnw53qDiBlbwwevX8WnhDuFkyJ4orTWU+Ek8nN9HyFcpESdCre7aiZgMVaBHv0z4F9p4i3ALJZM9yYv5/wuibqggAsW4lI/pm+jn96vYgY+2bo/9Besh8a/ymYc4xhnaCBDzGzwvKlA1vSNMKlalmjxlvSW5e9nLF7Q1qSCFCmpo5hjHPPIqV1AOpMbul1cOMnag13LOO0eY7AF2UJ9+EFA/ZzhYSVK0Nv/C3siUqC0jSfO8dgEImplEWe3o+UnYP0JdCKBnku29ZeWFRHhLyDX3sT5HNGpIAzza1d6uWpwAz7Zn4Vgfwu2d1y+hRUTWQqjpi33/IXehaArDmuufLFsDeD3Gm4J/sXMIVniQiCuY9wKHENTq7hZyuOiSisHLtlFptZOzhqb+u7BlD2t+D5YtN0+7Iy6ET879KSmTy5dwCKlMPyKd1bGRE93/+83rlrX7Mh8ZKhjUKBWantw5IAO499jjQbO2TQJJ/Bi386r2Tmwz/wurnWulvdp6QLYeUht0SU9N+MdtIWDCfNGPpT5GbMtCru4EFkB1anJVXqr1ADH6grfHn1Wf3MWH7yZaddGox+G7WH+9efbIk9I3tCNl33xSKVbV5p6pUJUHHY/4vocCD0IiMfKvZE1rG02bgKW/dy7pwmvAN15oFWkN0LYnVtSE7m0e8Xw7B9Wm7WeXUDwR9Bu7CiPbs5tJFWPJOAobKxNu89liP7y+3/r7hBqxpGj25Pusnwx5NzQYIB+1aHOqgUYkJsIepi9I0+ceKT1Mp1wbxpis2KIuVsOZJuo9vMlvj/m/YjY86IKf3LcFgJbRyvH24l1thp26Q2iB1RZHKestVRUBpebkL/aEzwI5oqPUAhx3jNmiktPiCFE/2Z9YqnqDqRi3pCVRV3PvnDXh7NRv4dyx/9aAkAO+inEEDR1cohiN2MfhgjsTAcgbRnt179TavrW2fgdo/No1E1uY+XsTJMzfGnSTRtkc92ZJNfdemm1bCO7X3mWyWyr2Nw+hGjXb0uplCDCsr6oROBrMCgu9Bm9CPXN7HR4CAo+SHbPbapqAzp1n2sTzgStdM59cIAqB+xpMXuo+Sd166mWMlmdFnkVWl5fZlAseKgOBDk1XRH7x19JuAC7+YwpBs/50+RXixw88ob43yGTCsG4yMH6qxdhUmVRZAJL8rmFsD3ijNtMMdInzlQIfa89MjImblef3Z3k/CHavJ1ECIpnExJc47tnZJlWFHg8IfiRzVYe2iARp78s7BpgMPWbW60QoAXXJ6GhnVG3xqevig7Cxn5iDrVWtaDP8Rxg4EavF3anZqBRMGfJQvxjzPDOEK3mf3vweAqnIt2Znj80qLj3Ki/JkvRA3Vcly9NKu2Ns/p8+qr29RKdaNEF+8m1Cl20CfGsXjngE481wGZMLrGFZIXubNlMBgGbcwloskjL4aY3Fymb47iVUZeyYYlYfqqe59dq09CN5GXF6Snp+ltpKdb75ttE/DpzCJK0stsVNpM3EusEho8XBchF2AepcNPUx0NcAx1UCA2lMOxnhbfipYcDKBYPbh71II/oe47ZBhno4qtXa+bWJYW14DOeO7IPBt1SPVdSpeOMqH7SshWEktu94dlNRFIJkE15XviSo4Aq07pgNatxI21jKfVHzViFmshH8DymidC7FsDdEspm1x6WM4nrNKe/ZuEpbgvS/MYiKg2NwjIzZjhl4vf/i3tAAPUzK9myXcS6CUW2BcvIHp2uqSodDi+3nHQv8RGE+iqQvAJFMKVVsgIhr3He634WzADPXDSJoVrH5x7da0e1iCEkr+Mgy7AD0FlfkXd2DC2EW6B5MifZMOK1QNXx/oiFITnTnVsF1fn6WMig2NKVMykLCxwox3SLXA09V0qdJyjpfgHFPGn49n+v+VAjqHPBeZM+uQMe2fHW3jR77NOZKGGfjRpCzhMFEVfNbwwHZ53zTDtWvMTr1hyL3c0JgveW8u5aqFfSdskPtZL7F5mH323izYmnQNHfhMCV/zKuqz6EC5HLeW434dR6Fc0O10rRECIP9xsvkzqnoCB4bZ9rJelTv29EpesdSekZNlEG7yP6aTHWd4VgQiGzFk77+TnJJ0SJjJvH6wS/EE+2wSBgoVpnDZV0b3itOKd0P8Me5lSFw82sn9xmuB3gpAhnwhx6GporHUtsSuwh7sHAgZRmjI8+rEVOTlEb87lhIDIFUhYqfUVr7t5KNYvLkJErrwQpRrGY4zsseCM1h7qZ4GjLkIr0G6AkzTofZC0BDPqIZHA4n9m8Bl3BI0kM/KqSbjOhCAihdTfPML6eURTBxD4ZUHpv6JyUQWW0FmedzjASyrdHqPvWHafjimf69b10c/Ww+VeiIzf1fK0oJLh5aWH3VwVwN0T1QYj4cJm/GS+RDJDC0acVX2OYi6Su6bE3xwO4jm9mQ6LF6BNoarkJUMzWXlsbupAVCiX7SNX6ccrmoEQm4qBy0zitbV+2qgtDKMtZs+fbMm+STq/g5QdQ3IdKnPl6475k7bHPhaziCEZMVrePsuWy87aXiOEmsa649BWt7Wal+vgNndk8bo+/VIAD6jC02ZA3/hDB9HTCofUBdxhBuQ3ekaEqavj+DxhcXHNvO+jteAYKWHm3cSEWfFFhtZrcqsGgxRN/rAqS3lD04U11IhTlLK1VEbM8pbOr35NFPH6DdxosZnEs1GsDUTmiWMuId5b/LCWllE6YqU7D6hxGcMc1lFBhXXSnquptsp8VndvvFr8GZa/Xd/DatinFuVVvu9U3A19cMdlOT+AG16YF75aTmcJcV725Xjk5wBpxnjGbDX7QsawYgqEkyCBiw7DkxPjTbRx1O0ejtQ33+9uP13pO9Nisob6KyI5HBfy+2idh+Pxtr+Ysg9S6XoErl+pctZSJIIQIQ7Ng2r2i6fRgzVPyBTizS/PoP6Rk8QBpOcRDiTo1SoQnTF+ZFzlpNM3rALk7jKyV1mFGx/eKd0wcJQ6ixavP4EBFKs45g6ZnsbW/EZa7QWxdGn9L0iLJq+pkzSlhTqsob3tW7aE28dzVr7yOzkCpGB3WblgvTRoU26N7/zwdIh3/akCYqC19DAp+AV3HvsrVw3JyMxuj+PAgnihHJzxRyLZRSWnMQmgrjdL9ZTphMgVqRstoXhlCuqi6gyVQt2GbGRoV/iwBzO3YVQy6DM9EEPIjbC2uTTW+Ebg9YDzh2Whd88BVrIxTdaK/Q8n4Fx5j2tD+Qk5pYbprFXi83uXZavgu/M8LlObWftuTWN9Pgql5ZkbquQtI1INuvkd321TXFH3AUG0rurv+Fx2jaRB00RurWQmGpfCLtrlV2ADT851CDk6qIaNODHQxHUFvaS2qK8XE6FeSoo3tw0gLTCGO8OGPvAOpCsAI1vdSXCa/UomNDXQwLKGYkEW2LAI7hrgnJTDsaWJk8CSyYIzds1Xu/WsqI9CfQh2YsK3xYpGgydeo6MCtcr165DYSgMLUBRCsJvnY/FBnrji5CTiX7iN5tksOIy5UIJIyctxwVl/UeN8Iwk2hzkWAsFiLoJ1wlFn4ynbDisxFlRHc/WmcLUUh6OTpdRsURwi8E0pOcKZByUPGEJSFc19E9zGnYQyG3hIMzPJlkqACNftc2YogY11lW7mkkUElXjT/cAHtqoWle6/Pzx9cUx0lAHiCxlHziQWKi3fmCAvPKW6v/peKkNwzB8EFqUg7X9g9mxh62qfy3HOo7wupCYsO2WB+pqQcPHNAWCEJtXOV79g76NCddY/UwWjXW9hAVr0vFCpGjjpzFqtTjnoYSEkPZFkPHx55Mk6volWCacJbRB8TpSbG0Vb+aguIJDfNw+Yhnxiq+SU7B936AYzYNJSNpSPJpeDDileCiJ0UVa1D7bfcjX+l38ENBI0aC/1chkwXtnZbPbwEBypx7VFXOL+KC7uxmFsmhpMfhIThCswH2veZkpfclmtxPLQXA+UScDy+9SUR/vegQ41/8CVkE69FSZl/V+q52sPJXsIirDRmgUFyR8pctKlf7Rg8q70gSd5I7uwuNuN7IcjH0Qjl4o5TGRebhmejfqcseR8YfE+Ro5Gwfrb9yH0pJl4rqLRpUR88SOdi6nbY3B1tzRRqeFa8ne5Mony7dkHsOcQdjYYFZ/jDuBtybaoQW9+JcL00MrYnYKV8Ti/EUSDUOgckKLYXonXGo6dPu6Oca4qOtn4yo4KuDFRoe7lli1DAN7/RHh7kIMSgypoM8FLZoVE+Dni9ZEzjQLczNqTfA6TdlCWq6gesbL/iHxQ7ozhzOdpBUlJJxPZc2RIxiQ5iTFb8bmv229qNbAD+YVgePgNTzG0vVDbkvHZNzHLYeeH7YB0iXe77/5O7bbLPONTVvwUTmXAwu66lKbIfcDP1j1GyLrw8vSqTWm2+NZIt3f5Yy0CYyVs430ZeCs8HuHEbLZZzHaOP1fkDRzwSbNF5/F5IEXlPf4KLC+07u+p2jvkG6xl8gagibegTI1byl92QNADDZsQEsj8EZkaeDKJaYeDbJHbT6EewkZrOVYr/LwaR5dKx2LG6aRJzuew4Jco0seeWAUnsBjMe5yD92pfeMwVXGg+Bo+PvxYa9xG6KepfWBm0YwYGjijYBMG6Nu9TrzzbOA96NwTl54ay4TDS4yr/B0JOOZTztR0nL3xC6fLlXz/TPUmzK9zvbaefY2Q/99LvW1qsZoAbFNedAFARG7OOh8ed+pZOlVIETTW+RIez9Q5SntxSS5ceN2FO9UAkwSIKUkoE3vfoGGadjBWGnFqgnUB+EwhvleuC2XY+x8nNr1vUeODdvQNARblHfOfafJWzHJr8X6XANoaOlMWxvk7qd9Ke82eQdc++zaP45rl2BWR4o/ls14sK2jmIAXgmNv0cDWtZJfDs4Ut0Xyceqr8/rrkkOrNTU3wYctlEsJHA4QzDr8a509kx8oiERamJG6VOMnkK3lo1ALvGQzMo0cBovpmxSoHCvFYmSipVR8Vjr/8+n5sksajPPS6IIDroJLzHhdj6G13D+6+CZJbTsaLfDawVOfkpvZ519FpbwJvr+ZIjOJPgRIwsE0Z3Kz7fQvHc64Hnnj8M941fBSq7hfIyOe2X5qTsG6XynnSEiakaKmpwNnGrhR8la5re6G++sil5a5GEiZ8KVfYTHpXiNYOUGdWOiEejTkF/pLXVu5Cqx/UTqAPVUY6VhAVfw4HFusW0a20blqYCpbxrnt3ROo2WSDIG0iIJObqTxlFp1y4C+MKmU0ziRiFmfKjhlmUEoVjmDJ4bKOHYNRfKM4EWA0qDHlSccZ1r36Uhf0QamMmTsE4txIlzOHdQluju/wk0i+bQDR0g8ixYr55/IdF/BpapiTyr2LZzxxTvd316aO47XjNthXcu/Sc5l82dDGlIapPnQMxfh8tI67BGYvXcCg3MeGp2FJlEoTlFJ8ChqfCDShJNpxQfpYyUV/wksq9n/CMPbzDwXoLJDjGTS77eGQPhE52unSHn9WQtLgBdJhlgeHKDjVw2ee/DdT0QqrW3qc110paHLxuOtkU9veM2iuuMk3vbiP3N+W1ESMW85yioohEGf/TbaOxaIT9ESR8JroI8ZvGU1bGoXzvcMDpXhgDcGmFhtsmmhzb0Yk8gw1uw4PoXCop1SJNLRUARZVjMYICu4IUCS5Z9qYw4bxvXuNvduWfDs/Yptq0neVj7ouJ7KZhdtAnOtu4O2rl/exWw+I/hiKgWMccdGBXU606RKpRogHpDgHmeyn+B1uaFj8Q7n4BI4dIut3qStjqUC1m2D0uY1ux+THiSXFTNHRYmp/hiFmzmL4gyR4VAAqk7ZXqR+S/Qp/YIxCcr5oRsIbFXb9HmfVVfd+Iv3OYN+GcqnpTrpt/tqElmJeb4uEawRJXucDaUdbnHKiZP8EBhcslulfA9utP2Ev8b62cZRST0rswG8QU7G2ixscGOMW/86IaqfdvYRZLR6vjauaL95ePiJj1lLS0axyjR6FEhBUXPZFuzLnEkZj1w+Je0Q37DhcdP7O2mTFnJt1WjE/1lZ3r6D8U37fm+iGKqszPT78UKIuae8WDpEvSfFvFBUapofV9LFPaN6zRahgcwD5YP+mS8W7DqufY+AI7AA6dtENhmAXhze9Y4kM22iMoqJCiI5EB+L2vrOGdeLWiHQph8DrvNv/ocLLNMf2eMZsNsuTVll+zA2vHEdFcTecP+MTmo+y8spJpREmKjnL8+Q5Bd59QQaONVbs7X0x9KJbvwuZ0cMtFypUZxcJ92xJca4cFIGLYI9M1ZtqrFqABpyGvdNbf7Ox/SBwadJaEx2MirnarBtrwnTQI/A0GOxOjyUicbljMr2Rr+6QKCBmQinFR0dsLKf9bkvUzvb0BY/1Sxs+bX4noKc8goQ74nbKWxn+jGaeSxFGR1p8K9b0XRS5XNRwKgAX0SYMpCaDZ/3/afBSujSae3MkQjfK3MhFRjLDSgoxJJTWmYZSMurKcLScdXw3RksS4fuh0gvaoVumCamB1hkpu/K1sTp8x/nBp7aDbCWqfpwRrHpWMmJjGBlvKKfSG5pno9gM3FO4ktrIRnWo2Lonivhzu+4JafU7RGZmwGSffe3hF69tXA3Db5wYA9PloToV5fQBJeSSoJybNAO3SNd/OTDLZUDmmnfFYBbFwSALFpxag8f+XfLUSvZ9Vn4JhPDPmGbArarfqkaModjnk0mI4CkP8VCYdArlj9eJR6CtTxaQd9xgjFdL04f3x2dLbao8nfuzlbN9vjjpbRv4/m/O7qK2I7BYMNOH1Ah9l2p1tnvBX1gz4HFHM5nFuUsfq5yrM7VBgNLKOr6G16Sr7EgEa8+aZ82e5c96O2tv4tJTbbFngoCTTPkIMSBVpsT2T7G+CwSeZ9uq1tg2OzGXNeVeQWzTKLp8Gw/JuU5Jk++MrDxXcnfwjL3tjM5LKei+UIGMomlm8by0k9lnzdNybo7J/crVlNki4l9tcba/hvWupWBjg1pe5reiKI0Q3VqltEFRrS1scdSoqvcq1rDY/4ZJFHaVVHB26NU9MWgZCXYIdeQ0h8glvltcef6L9A8DH4DGoHHm9XtVos9Acp5K4ljJjYb1KAlyLkwK3pSnQVvpnGuI9c3J1efdzvzCcxQJqpy6T7byRCkIM2FlXpRyPtR1fg7mNrTb0i+7yY2Y5rrFhy1a+6J1tXazlzqNsSBXbzJ29SqiWVTodio3xRsGOLn++HR/g1OPcxmV7Y7e9XSn7/evoC7V0hdVkkKCRePzt3db2uKfQ2cic8LbA/lD42ncp3s2DAYQovzgI3WmrncTU8Ds1qzpxunPCrfMqlWvP6X9OLBNUyZR1d1XX3Q1DH0TJpXn6mmNugHWf7ZXDcc0rZpi3qnxLUbyxxv9bI7qQHYc3FGrS7NqS7n2n/XY7lkEI4BcBfPYvesoaG9SJ/gJg6hnvV+YMNDmwUdM9QC5avvfYN7OrS+BoB1TAPYRfnskgQmpYjUQLlaVaXkroUnefDHNOjifofc4pPyIq9GAYfScgg8AfC7eR26BNd5qJ/s8Wd/5BtDb8PSHQrKEibXAb0jiLYb3kxHf5x3xAftEf5yOctMwTvBVd6XUp8q+opKQ+W9q61VfT7kGUn5kP8BBlVohIH3VSysgU/Vf2Xn48SeypVaZa4vk+t9GREf/qATw1w9RMiLMPKvtNcB5DDjhXsxe0QFJvwaRcu8P+dVHJqSKcs7ooQ/Mng/Iga+mOSo4mQtEkqDf+gJE8nbRyU+RcIdx5RfrlKUlWYFttLQqvFDrTDcLyPxH3QYq27CaM8IppcTGNI8xcPB7AVQUBXknFcaE1bXrS6dUPS1hR+ygWzf1D9rB3D0RXQbki4/+xQhyh/oSedBydURfe7ukKaTzTyJrWzNbTexhGHfCT/WaCI66Hhk6evszGC68tlz97do+/QAMIi6VA092U8aoO3haz238n32uiGYZDmJWI+GyqoaFpvQChTSq0DDPDDcrFenskmqmouWVGRfli3sy1Hv572gpySDTXGjU7NUTA3Q/QuSdF8C2jeCXyZMLT34BHDd70jiMp62IDotxZlDESGkAFN+mUTw6v1qtSZxZp/uRGxxmtDFfPFNSLVK/VOw7f2e9v0yR7QY869fAIcTMX7VJ2HYYeuOriam4zJUsUAEYcV18EY2I1L672f57LtP6oCaG678Hp15U7/NbsFq26ICvYVQE7hC5+K+gmH4SCVjGNLdc8HUKqvnpSsiYJNx86ynlQAROg/hdzs+F5xx1DnlDhkfnooojR0e7W7lZEBitosbOEXQbRmkR805G2wHvsvG2Zi/gASLCc9Eoz06jaLBkkYsup9YbXCPZMiKv3LbVolQm/i2yhElTqRoFKl0+vKbocsSj2JBaBM1iE+OsxRWLlBv8XJcNYlcOS1q30UP2c6hDyqwGHugyI73zK3/Xb0vazxi176IPtw4dkbBlHsxFeQon8XUJx9v8EzC/FHGNMGw+/sbJFCHVfwkRVsxM98Y3E2QD8nxGgj7GUaMJzmEvxymgBmLc70QLtZpA3wnTaxV5KDisrKStp0YD/+OccbhdiSSly4p8m5MzJuzTf/HUV/dHuoB3pw/yLwL4nkd8QiPlDFb6uXTBSwc4cG7PRU4mfgfgcQEJ0a0eMnSGhWrWdHIbQLILWWRD74R6D1eTOF43ZJXclPAZzSmE0SfGojwgbeTLVs0LuK5GSYhEXLD9a46kgIVHNIci9yCA7nYgqr/LrBQ/kPODNdZXzaLL+EI3GOn9aoOE2oBa6GoBNRDkpqAiP4LpmGct1wAGh0Ruem0uDEBIA4zllDFdhqg6aks32inVoylKitvSG4ShvUlyLWgxbHp4CGg56fxDMLNWb39mmgBP3uZtSFDeHFG8gibtYugA6Fx/cuQVv1D5AUTuLDByk8OxU/vGNm1AaUm7GCzmgIWAUIR6SOnL3xcEBVjPIK1yuZ0hGMsiwMtyK0rNQx0OsMPTm0kXVbOkFWVIhyaNRKNceXUJTN4H8+DZpzQ+Vj5qQ8D+Mc4oURnh4Dp4FqrXy29sxFjxeBmRfbz4QB2+TWVCFuimOQmMlSzJd2HnRau9F2Mnec66zrvDYfYTsK2E9jQmn2LZ70li/It9SSGHBMyFPcHPY/LsUt1x0vccnscDHy043+sQ2ACh37UxkG79z2X53F5EUduvh7WCoj8Qe45Ob5mPG2PTKGA66HdRG51UZgbPT4WR8eyrDXQg2M/0gmeRs5K+oHGEKCx76u/HmfYZWVcXcU+a61u0rz5J7JEzO99CB3cy2kh4adsES5FK0QBN9DVdEP3sQQ8IVLM22DMUGclCjbMAnFuzJVsPfC2zq8Md/H5JN+obEEt7l2Ir06YTX3mpq35TWkmmIL+ZwObbLyDlm7N1wieAmcjYVa47/jPHKD4uiqS+wUakn4XE5D25ZT8xIFU+0zXbigAWHRAnlMQULAK8WOLk2A+vGcCCjn4df4I0FIHBtE0CxB2J1lFsylcGE85fzF6kKy5HWq96JP039vOwz8SpQc2DP2UMmKt8dRlcsmeSmjZqJyujZFLZUIdUxqNU7Tqx2IgK61EXkkhD0H8df1MjHLxWVmKFlrhxrd5IX+GtlooEJo8sf5nG/6eB6wTfH44zALWXaCmtlZMIXxxwLaSUbpCfbPqOViyB+8qCXJ1WOl8g+Okck8GbpTGPX+CRGdtbhrCVd6JKbQgRcHEuXis8N02apdsZbVupdHM1uK2QVNd6KfsHHDsjSPsFqeyW/GsFC0kwpWzRxLUmEKcJp2c6TAyMQkg44fLb3l9mYbwynHdRjUVoZ7FgRKf624/2FU19Fz2C9Ass133lVM1bHbVOVZi2kJCCDGKm3VyZ/o+MQYxvPxSF9CvK+Ip7hZHCMBD6YbpcPTlV+F0KZMIDYiiz/P4uBudV2wtIBZ40eNBKf89yQFsZ68vJg/Wed8v3BgLCFtK7/80zJuasrhwwxd1utPiQ9t/1s0W9tHWnPWCEcu2EOVOnbCO9jh2F6Ex+Y8C0KkZaG/pgSepg/AuEcUmSfaBkATr5fRVZujFeAsidE93xzPHK9pGO9/MRuRh+TAKTPgJLIVxYOd6+jtlTosucWuAPD9GxwZVrlYqoXmRQaz97XtuK64dF6J5TpMwHrtbAI2lbRMev5jSnVwBdpKxRTFqWFOKpJ56qk2u5DLB0n78dH/rymDp4caExLqxfcoSLkFd6pEFOjMITXWk7FNwNwtOix/9Fyf2mfr3E0LYbR2UN1cPogZZT92Jb7c3y4UbEfC6Nt2dsg9HZm5fK8hTwBC62cgdPBfQn+ouXYf5Suhb/TRgEoPEN8Kh0QO+35Wx7kC/VMtx1wqLlvTN3gHglywLM5TCFDXT/cjNx7qkESp+7srnRCGdTdr4PAq37aoTRYzS0QRMNbG48ZXoVbnqYetd4+QCYpLs4NGv87MwiMwdHqmgwwx+t+y5yZ1dMytzRpo5hMmOmguaJvqo/S55p0Ygnd6ePISvA4khHlRJydjcLl/DXb5Fj7Ncjm6Ao4xD1VN3ngpUFaAvvmXyyEaCh7JDvzYJWs3uQ4llHXYiEa5wI6Lq7FZZskI3Omo6cGE9z2Jm6OcffPzKxXeCPjIR69HaNR27RzvQfyDhziyaglkpmRXN/ziT3uz9Gq5UN4w368YoYAIvPYbL66tAopXT9xvDnoo7eg4vaZQhP2jHHr4gq6/MesUuGd+qouiNBVo5KFNb+E6XWgqwtV967ViGPKOjqUr4zrcQOf+9ighyX48wGmjzxRaX7pRSiVnJm6CwIu12+m0Dtr8PrpeCDJGiTJZc1Q7HAgvZalAApG6i77g/bNdSzzLC4URz0D5wzN71cQnyv7NO/JY79l0eiIYHRXLSOJUj/Wt7LQHBusINvm2Ksbai1Ht7DX2snqVE81FVyjdyGi0PBSAy3TkdFj9c9/Z2UprwB31Id2mbvq1CqZu/L8YXOKF8JlNiMMuaQK/PO2KBxGPejPfcu5CqFXNXjm8pUR8NsRsUjAutPcdaz1jxk0dcuIGoWun7dpzRyn7HvMXfwXM1ToGyqDMTkeflHy+pZzFz63t3hPqCdhCa1SA78T3wk2dBD7CWBxQI6ns6jsSJa82VrOloVAv7WfujPGG7p87UTnng8MG/xzJ0NUuISs4FZCTSZmF9G0cypd47+oLDQxC39582TfHFdYBmBLtQf4mzuVrmwVqIiqgweBgH1Rl6jLcdE+OZnXpp26piaOJF6FEpd8SJJQHO2SpwKaftuZ4UbhkVIpXIIvOCTwiWp3a5Vm8y3UNRzsBOOGSXAiEnt4JKcfMQLidLCT5zIJXnNnbeubgX2OPJ3DNppPJ/iaahdOoKOVftelzOPvGGTxpL32KAyQuLeO0E264sSSCi6c5KS8ooGeCPgf32IA+mVxao87MrHsjdnkOOfDcR2O8awCNMg/RDfSFUnPUZEfdMj8SAddyjSMT8UzXqZIMIHaD3tyQnf57BubHtVmKgHR+2GhUYijEJYxMATIioTHr5uUsEjivng5W09q+DTn3EmNMBUA4lL4bHc95zaigIl+IoYIp/kECqGwbOttB9sRAN2qR/aH4J7ODdm6lnQr4VUNAWL213hyf1SLSJ5Kqor2egd2SvbZVbCEnh+rYwFM5JuWgRKHCXOP3AsosKNNRGOLo3pz8osMNr6aHP/KGUBwRcnamD5EGk07WIkWSE36wLEI9FRkfHe+b7DWHh/IK6MYKJRSVShcqcMpvXZ+FP6ZoMZ5YVw0zY+wQtm8T4QZyFkiSNRuFNYJKv805+SpPWUOCR1xCzldFI7UCrpsMGC7vbCNLttZ2b/K+Zu0dO0mq5L1nUCZIODOcyqpRYsprmaVyfAPB9izHJXnQN1YCaNimPgcboCg957GgSgXoIV5/SBO7/KCIYAddTNI2PbH9FCc6pw+1U2i2MXuE0zU50uw/0Y/iI1eNuObgM3Ne6qPYxRZ9XJchsF8aBOC3aCYTPX9xtsFO5NuXNREwnVGc6lEQS85o6f4X4hkpDCL3ny6gfrU6+abZV4w0yoLfNZ8crROuPysR92bJ1E4XaIaX8Dk4CJ5bvRiAlQqpHuMVHGAewRtF2JBiUa4jFpFSjUjhLl3IJ1nBIFUOz+DakNV7JTaOnnQRSY+OpdTAJVgFmbQFKA3+D31r9UiELAIsgFlXcCYHGkA1a8LEIw9VTcgYS2qxv1HME4jMcoy3DtDKzNwWjdkcxTdxLXfp6cjkpp7UWyKS68IeKe0Peqsz8jxx1cDd0BNjnG4L3Ie6hMdI+OAErhbyvKZpHTNjd0x86ya8SNGdw7AgDqonho4firxANH6Yr0aTwuECGc2WFe1BDNuLmvwMdSl1A8x5ZOIJtXLDuW8xHZ3el3MnPcruL8opgkOccRnkUDypHtRE6WJqhyY0yiAnyBgtwY5eeqRAQAwcYN5lrxY5RTtv4GO1aNHYKSb4/QClfLqTkseLv5YNxyTunTVDCrpPe5jTnZTKmrpCCuy3D9b7BFkGD7ZZke0gJwV5xUr7XA8tivJP6xgr9flXpBzMaUQMEYTzAdYjoRnBeHOsnyfXVzYuqqyfKgTwRwCeRLMsBoic6JH20z35JVg8zf8B4ziZPeYQD4Za7oQbms6zfljpcBFyi/1SojajyrhkgMjTBd7SnRrzXAYwpEVf4LDXmgrq2WNGRC0WtMk2iUeIPgG8jbFyxRLe8G+g0WHlbiNsgQ5IBZyCWDrxZPqlQm4bMyzzOdI3nmlXGnaRTuklH1pnbAL+UUkczqLVpTVB24KjDwe2Y/d0oS/AQCWZJOyHvE+viMddnydPsGKtqYNwGxs3ToFcX4YKtzkCmDovarrx1hgservfVSoseH1rcKtt2pfXg4D4TrJqvx51LMTQS0CPInrrwMERn/6p9z0MTGtfNrC3aLhed7hVyrfEWnADCZ2AEE970Mb8eycZ5MtRt7mSxw62VsXtnyI4JIYeAw8gSdg+dKf/Hi0pWlYMqJUqrMwphr9zm27J23EHTidBJs7lHA9lwFA6gV6aWe9LlkIwzi+Fad6rHKbxpqAZdzHleqfnMEFFeHTMjdBQ2ygs0UaYVqLfM3HSAC9UhuudNstW6gf6usxVdUbMLxSVR9MczPs106fLLUScRm+GfDDcA33NSf0SQx8VgzJfu+A9GKrWFKyYCIz4ZkydpbzzBUI8ZDkdm0zGpPx+trrjnUqs+Qvo3wfBwla0wGYadLNihTEwNjRYRlbTpMENmcnCYrFdzQUO0JWS90pbx0v9nZt2mRdrWJ1C8tZ5olZGZqZON7wC6SDfCBQk0VTI54XHgiYQm1dSPpqr8LWlckT7xsgI4UavfcWWNDYN8RxeesEpdrx85/IsIDtf2NBDVaOHe4hztBF6e0gt4DG2Hy4+ehJLmP/S1jLV9UVku7yPcfemkzc9oJomMepC/I57lpoMyUqZJP6JooHveGuPQ3fltNta65cXm/36bBH6YhOpomA/6POLD8pvuka7vkUx5JBvGqDuEY84xe+hSerkrA/D1dcnabwJfIcRdIQ+Z7DRLD90Ai7DF4uzNtKyD/Lup4aK3eo1oKFl7+hAHynxjKwFiwWdPLzIY0pCaYKH2Xr08FmvbJ09ZBGU8Mp7V25n5tUAmkx/g8oE0YRYBrELDoFcX6GNyKb8uxx/4DvFHDsvB/8QfPzDNmUPEoWAfKiUpO+cFrtXmkIH75b3z4AlP9vJjMZ4Ap6lpd0lzBOSsNdQ8zZF/UTp8qtk+X2c8CpfdbZ6yZ7GlSgWqZ8/XqubQvDqgyLjx0ZWYCgpaustC+PVFhbMqbMIgWb7ywRZrI9LRbVoWdQuDE85c53Y6WCeomIk3zAVv6zN9Nq8vIsYNPxaL47k0fkH/XhIiD9h1jylfm7JeLm86LQJnEcred+6Yro8C4wHrMGKWJPFp5Odp++IbExwwwYRcyCnQw/7xlzHiAGcvJjRdqxVHvEdtKFdA8wmdCNApd4LHzJGuaX2st+61WTyIpVwVI7tJQwsmnSF9xdALqdzRD2A9LVXzFmsnYNKQYZpHr9ajk+GQ1LWD1ByJDmHw3ExbFsCGc3h1Mxkwjl7FdP89jrAfFZign8lVpuT87UQ2dVt813yy9wS5+cHZlErKpfgeqaroupAr+OXYCO3pSdPtxrUtsGY+9UQlQBAoufBaEVCrIJwUBhrK6Y4WUl6Xlb1iLHpyFn6nZJrItPBNKuWdBxhhtqjqyrrNX+RomKsWyGq/ruSUnoYnS5do211CvZQ/4Fsl02jkJx+yscI/QV1HzLeujRD5ShtPtaoTK08+1J2sMT/ngEtqzeSjI0/xfRTXkssCvrXca2iE9RF4V7L6707aOfih5LyCSwDHQ7PlFfDiu2QMvqD967j9XtT2OaboMKPos3rH2vrUOub8VrYNAlHfvXsFoJb3i81qNCMYzTtODG9IE4+wXh6/VtwL2btyEZ/GaaPDpgxSXfK39fxKYT6vF3MkIcTb90jyFD837DSNaoIHMeeoMT6I6fnva9dUjGf8bJH1m1G80vXuiQCPaI4IJYhlyc8Wdb/Aur7d5xraftChSO0U0HnKxn7syWeWFgF+quwe/3l8jcJLRQXw2CAjyvo/iWYhh2PvCy/X2GUUgXS6BQaTvJ+vlg7+E1zAHaE8rCJB5NZ6trsvUb7zeV8r4hy3y3S+nWVZvGOJ8jAjVp0M1W0Z40891iRn+b/UQGGWe+2wbVKaBz4vmzSxgHSy7QvxhSs1XJdQfeFXgm9fRkyqXAUF1/mbutijqc29+Jq1CQdp2UHG/H3yVvfbh3+u0to/j7dRk8RLqfQq3ZkqC06zwO1rbLWnV+jS5sxzP1SgBhBYHa/huw6srl4boPCtzo3k78n+TwDd+342rFPojxYozWhourzj2/HYqltMbMJ9BMBhiGlWNvtoM5QY27dNqnFv/JK+7iggH7W7fVtGj+pZZU5Tipd9xyXpXv66wgXT5YRUWIDfR2IEVX5VQ0h8r02Z/IMIcanYZe/IOVXys4swbgtpI1TeDZYUlT7WIMiBdQR4E7oLVQzyxF7wZ6OKF7Ua2JjVXbWB1UMtaiEw9nfMuGeGs9cKQsXxe1MTiYeeAguEdokfQciGIzhGQO+nEn4U2y42qpEeeJYrCkxQ5KG56/OQJVKE3XEgSeMzYnpewZhj9SMmAW2fr6WcAlHKaTWH+hQniIXwzAzud7nrmw5jJGyGxt5J6RnpMaUp79s+bTWnwpC0TJFvirlZ4kQEe1/d2hf6tD2sfptGWEazNq4czhOK9nbk1AQitBaoeUvH/T+NqkgLeWlZT4RJNpcz2tmoAp8n2CAJa4mX7tLx1gwCadiHIa/RsyQ+JkKLKF2Enc/8htMcDhxHxVeCrB13N+NtY7UZBZCMBu31/Ica4sRKGTYVBeSqyZgkZPZL4bO5rlkl3oB4zeWd/WDZ7aDM4tAUCw6w+BkXT+gb0qSVzZ88HzYx/yCWDQDxgJly1WfQ/otf3m39zGVDLrhA1PS14QH0Z8BonS+kw0qMUo1zXaM4N9qR8t1qaLgaoHJ7ckAYmusSKwv/JYESL7g0V+00aP/AU7llxV49XZdlPgJvRf3CFCba01TvYT2ZW/ipzUvqZRP8k8EvWUpL++7/4bTurv2rvGCDDgP806vf0nwzncviJpsl8nMx6rQQdVq0kK6iOkISTlLBOKFeP5BfHKSM9dEFqhDhpGIm8OOwL74M0ojOVjI8lt2zNdTOOQzKZp+ASXk0CxGyJHEbCp+CLOzjdk3i0T7MT4HlIrDiIrE8NCMsw+as8mDkMNgjem/IAAmfuBU3KCoCa6plsAuDgw0iXj9y/QUJW5QjJWUGD0XPtADO0dm6NY5jVK0NfSMUQ35+XdD2k/12nGTckNIHT0YZd/LRhawtKSg3AU62keo19Sth/SkyIdkMJouTdAO+iEBej0fHJ4rF9Zkb/pC7KG4S56fe13PCqfIdgt9wI1MsqbA+9uqTPoSQMuMcwzjoYlsOiaXaBLUdvQmp5vTxHcJUCFHGWLbpJn4kbUGGC6KyGNvuPrciKRscHv/dCoWuBBS8BDCRXLOQOObG1DMr/TEyN2jEVABbkAfez7/uPqqcL6OSF8xayh9f7UK3q8Wb5NELzEQs8TL4m1z7KyMkQ6sK55CZKpIQ95URRqlr3kB36Zuiy410Ay2R0+hFoce1+e+4Rmyt0LpONVGXQp6C1XWZAJk7onaX1aEMRTStJx61ASYBuzdwGTZ74TmTd1G84JHbrLz7j39WWC2SCqLH/eIeE4iOJmHHG0AjkvjfAqEndhYoe8fueDjD2S71lIzY9zFYvORXQNnAuC+PVNRt7LUphtPNBzOUHhSG7R4B1m0FOAp0e21gLn2JQziOln4uswGzWz5UwKF/8sVJbaS1/TcQ79QxCEhW9GwPSiS2R0OwloLjdGjWkYvTADfvKA/il3//FWM/FrqlHhSDLNNC9hv/9KGHXiVxapykDvg1QMHozncvvXg4fwOq+NXtwhOXimrz+jPJykHFk4kL4l1w9jceveo6ulmSpg16MQdH8WIFUmeKCX1n98TxH1VWfxfIQuTzunS+08zJtlX6kMbz5tfHrZdtV2flJHfeWia3OmJvYZ1ZejE0zUECk7WAMOdp5ty5UgsjkbNjt/Uzkp71t1SfxCSTsCRK9LTY0DGqCmVS8K4uBwymprZ0jFYKItWbYb4lHnqAn/0+jDh23RGRYnkxzy6k4GITgl51kSVCloy37BkdSUbASPqWUYOkmsxl/5Ot1BXenO1feBktTbE8oToDZHbvnn158yuVlSsf7Lh7it283UIYM+9HMNJ6mJgrqEz+ZsvYuwryQpaYHlluFRvf026JaYje2K3KkDGShIOFZYHdUsxbUg6WiAhrR1191djaa7wyLD0X4HPVqQqUesWtBgtJtXusMGtZjhRLIfyedwE94zGIGq4R2QqNeZ/Onq/RkA7ff0tP2X5up/VRgrgP7hxO8Sm59MguXfidVX5uz1Hzs/eRK/WtaD7bwzSr4aCSidHYR6/6eaMkBlwLQV+XXR2SrQUqkOlbIRahGBLryzagKYm6xurPB4HZr4yE+dVx3ECLS9NKvoL35mq1VWlkkku+qZaOXmFVzD7wtvn63zWZ/z5e9q02Ph29C1xhYvWw1gJwSyN9rsqubqxUenjBE5Q9FpdAl0sn3igABu+b4f4XRcWWGHF1IpWArR8R/JGyDB7gO3z20mYH0q2dhsFOeEQi20khgIsCxpDT4UdoQmDoTUIgUyVHld03VS8cR8RM/lbMVRwYEPk7LNYGyWpIynaraSHX8RNzhpg3AnOf5XrDQ+/klSW7HTALV+6QHy3EBCID5C6W5mM3Ni31Fjvhr14XHFpmd+XI7B16apydKtKf0kb6FL9+BC7znhIO42GUrwCdQvtK/joKSEeORqEHgCS9R/xL2KejFMypfQ+SGIjG49zJMmQvetegYYeRgIUFhtc0Ind5ftBtH+x/hLE/UnOMOdQPvHfPBx2DCx1y1WvE8AMKLKdNF5plSlWTtEFOimxSvzQ7isQfjl9h2/WfZ3ESy+Af9NTYxKd/fQW0b67kY26uc3cYBE8jSzwJbs5liR44KOmd8QdbN5O7MEO5TDoRsCGM5Zp2rSAcAO3cjF6uZXcdN/tL8VvFRCMttgkq4v8bJAFcQ7zYr+cIA6NA0+Hnf0aXpPuVOXgHXwWWrSOSLASzRzMGMBcQaO1J+CJx0Pdz+KtHWFP/3wYwrjaTjZI8niSK4BuIweoI4sRHuKj8BQuQVMtu+4xczCwI/RIEiZeRMY6gWfOpvtAncEohxQ8Ka2bfZSjQFwX55+9DN2UUCe8DWgJvMgnvofiHIwG6qynytNF6IhD4i63/rS3RwyWAlh1FeA0Jj3dvXJ9x4y2U6xBB9nrTp0eRUV5rfBEimYL15SRJzJv971FpwFrqCVkwcN1QXnUqiLhd8Xu863Zy4jZh1h4SfotmPCKx9GZKyf/92/TtTupQFnGDucEY52AQE0SvACUdQT/louwKpwtOONS13GopRDv6KrxfTChkvfdOYvalCUlAtZrngsBfT2r8kC4pnW9Ppte6TdcT0U/YsC1LK2ZAA9rG04Mp9Qv16KtQCaDSuowu7WELpf+2Ls0IRyjSUWa91mgY9p6bBiSka+2q5bXRCMVo+z/bRzpvr2ocCguJx8Cnqpe5ALvQ+nue7r2La/PxCiJsZwR7dJvv9P5Qb6YRBMJ2n5AvfB6a0cdAQ9+0ZNJpluSg58KG+Y/QKG3VmXVPnkeW6U8G1vx9FFrV9O08Ffx06nVS3//W9QXPNkLhcV6D9WmWwEWsOuWhQU3hbc7seYXpHYnPnKvQLkOSD68UOywMPaCUOLQKdIngGxR66BZJwE4Zuidhndy+XSaI/ox0zzfX5x+9o/j/NRXPbMla+xwc5t+o+EVuRIKVxBp3LMHW7CqrYzAV9M5U0cVxe3IpICGD2CHwNwC0f7U7jhWj7PkMTwanOVRgHQpKrGLL+SnQXqt4vlE4k2zrcY1e0WEUQD+sXCa5OmqbJ+KZQYw+oUceT6SilK0JJcDTys+4/q+pX161hcHjQP6kGqwblMTyWS9rGzmMavFairWzitKafGh0oUsFcwQCdSUy5UXJNj2Z7yT1V4744Z2Loll10AT87m807BpK6B9VlLHqNarSRm2+ctPn9kRPIbvyz31H5UABfcMdS80W+QCmvX56lMzvJ+OAzmJEUDOCqduBZtj4JNfcREw00eqR609c/kWQlOsi1wJBNMREF5SXkvZEw6b9AJKFmdFXL4CMuMEc49Xp7R0C9zqxm4+BfH9p+qJ53zamV3/QcHiCvVg4Vgx4qZvhJWl7El7apXpS8hz2T2FpJ9h80lAjoPvNq5pVPrFHjjEpwIeTGonBkZdFCVS1VZxwIxYkrQe3xIP7g7R8gx7Mn+DrqZYEYHEa6HyJ6rMPUKl/eO4+X+83O2ldhixaBu+eRfBKw1N28VkGRNOhOHie5e0yOXxemGJYUxB+smNw2CfxLvH0HUp6pWsWoqQBPqpL1fSjhDt58fpd8rKA8+on0lGCN5r3+/PZxbNc75Y2L8n1I6fgjz+NzIzofhmszuPaWVs82J+JQQ9pdb70xrplw9dJHfhUsjTSmOz3wmV03IyzcnD0SqOsip5zwK9LhnoLiWJO6Z4yVWuSKvNi1OV7NHH9TiwSvvZLnPbCw3iO0CH00qX7KHb9FgEgo/UDftEigZK3QgKrHEYmDZlbFlhEyfFR/7iQfWaANqPOYkdT1SSSdSqgoVd9YV8GMHqxHQHIkeNa4tG/SO1UlWc9snD9LrBMSks+/+87edM4tVlhHSU7aVcjglV2jXcSWHc44abxRkoAYMfvA0xGrkM4Qae1ckPyiJpkADN42sRacCLT86t/QTW/ylLgvUTXNNNWnl/teElY8l5Thq2Ht5NPzFGnbf8qLZlM25h/hoa4D0ZJ6PBlxHKe1oQ6AVy7P/cgHjj9ARZ/rhVJSpfE3JJlIcfQtNUBDtdLv/6pPP9OMvbUDFutGiwbhegp5JZYKSL5w7B3+LGi6JX0y1GGhJ+JZ/3BmXCwcYkZAXFy6PbgdCCeWWfaV99u0dv2vQTpBaZ3lSTfdlm0pjwJRrFyJ37t0+qYwI8siXuQmyrRnpkECizp6XA81bwZGIbpoz9Yf2Noypd0j/EMn6joen4oDOCQKxS+xhWJOoylxUYzBiEo8sU+O/XwNYDL+/ZdhPnp7vlNfD1fqV5bEfVwmxc+QgSnehdv7cPTbtpqNxhzLMM8XRCY+hPd2hYUMKO0pkvQ/Gf1MQdlHdHfCU+dS60+TxYkZ6Yqk7q0f+S9D6KohX6dgr/DE88zvVQu0BZvqk+1E7zGj2duLZADNQFIL2Wq5Yf5PaKSaNksuLNMvr4a2rHk8Y3J6lCEWJjPcbBLdIKsSU8CShnJQMLsVbY4JJ4DEuXhQUyQVVzr0lXvuxMheC2uiuLxbQ8eKYxKVaE9UG8uALrESXc3m9EN2T7rSqypWmj9Dj2Vh0i/FOBPpwufqNy3fWnHjpSCFdti2nZk+fG+6qvhO6x/FdJrbDQdUtzCnDQ7ctnKQ4v1XsHpcgy+07JTmzp7kjXzJ6WMsLv5D0/E8bzfOlONiwCKt34nKsvs+NJHyGZ+K2swils5VX+qf3W2+8YfQryRJnU/p195RpHnzIAozja46HOfp9Z+7Pc1iYC/TkZQkWVWLGW2qsOG2qQYlIyxbGbqw0zOQAqPPe+K5CbJl3ivkrcfuIdJrUidwzXZhg0YiCcm6v9KXz2XewYvMUNNWgMM00aQlvS+jL6h0Udug9k8e9nl1xauo5wx9Hf8I/21Wmyhu3Gu1ZTyw9eKRqPcm2g7/Qtms2ylc2L8ybITafLcKLc2yN48ZJZwtTcWVSJqRxToirAbVbVRDXfaLdbsUMHIKf8Le2JlPeFTrgaKf31UyIQALPWWC4JbT6fIO2tIoByEHuWavQnrSBkUGo+Bh7ls04/jUQKSK7kt3GpMpd5Oz0xLIQBrmyx9xy7fmYQLYwXFIAFyjsPQjuD5fBGtw/t0mtPk6286t3ET/JnPYYZKEbcADa0wPdyYzam27WFbBq92ikK1dbxQfYkzddkjjlpi6K4MIq1y9vaJaBhtw5o9p0HhL+1nV3ktlGLPjJSfiLcHK+YbTbnLbbDij2T04Ygt3GrNHjBzLZSMbctlX2Th/b7k9azdm2R+nXx/bO1UBvDHwI6I6cbXNpnMqVTXsUT9mzf1ZENjBVWiOVsPUwvWACx0nLZnm6eT1MN0QBAY5xr6ZsGgLoItvUELYnjRh/gx7byLxWxXFokWutWW1rt7xCLtmBMvo19h0QaktEZWWS41pBEFgcpfKcXVQm7rtCu6C2SW4gxp/6Cmnq6wZZyGsALFi4B6q6pQOJtIxfXlgOjpCrQsIDSTQCs7AqeBpKTrJXATG5pK3M06ittR8Hytkim6Kp7FIgqBg3V74Yoo0FpmEOOnY7sGjWI2mSNlBRRifVkLDiDtONVrItP9ljVTopJKRXgJfC0l46LbF7iw9+xHf9t3AeSW3Y1C+88rZoGmfwIxCkvYO8rwjZ7EckG3XwS2VevX69W8HKOWGOVexNnp3TDeR5kUDMuzgik6KsGEX8L5LEk0tqwC7Clf/GdmRHy8KJ8aGImLO2bobdtMInW3v20lVYlP20NDUi0J+FPTijqWik1z7orx5ux2mDLf8GTf3LEKzPUZAn5d2xtpbYzpiL8Fa35vtwOXHlCzNrcpYbpxYmwsOjMqcKKOyr1EjXIwJ6o+Ec6cK050BcKDjQTxNmPSV+IR3rFwHTRuXb5JD65HB2FKoPa+444QrIBMNK3eN/8/XjenupCkql6W4Hcev0pq8/LuxutrucgO+Uflw8gFo+CaTAd63Ip3RBzOP6LEjyE4hujWvB6s9zMysMgMfl537IshIsuHZ1I+dNrGPfd66fkTTg0Ow/uFSkjlfqWvPQQQ1H5zG95zeArpTZHZClaNLQMKjsLz60CsrAmFKicBzpNehGV53nd25hi3kXE02ZOJpe4V9Nxb5wmbsNeZE94jG3Ipj6UK4PmWlfMDjie5AR+KwgZbt17N4ulqZQEWuR6qffbuG2CUfjk9uF0lQ1sKFZasph6QQ6WnS7FMfWQcerJJsUTW2xKPZUbfOlTnXN/kkkfKd64DRTVE84y26vm+67YeBn9NsSLXoKrMhIzEBwe1A+hIoVWOfFLQERG+mH4SlkiXrKbOpBe5ixNnDL0Ncs7gXxi13+21h7++SDT7y/aMJMWtNNEpyjZrbVCjD846r3JoBqqH+NB2s8LeZGiN1vZiDQ7dqSYH7KjzSVFWhIX4HQMYYbtPAC9REKE9UpOQNre4sUpqTHhNGshlcOocXsMruVV2oyPRjgBokZyNMq2qUZNDXtoiPH2iOQWTp8YhRAkDmGvHJX0QJRJnN4WSGic8NvGgehCuOwupYPf4IZbxVzmD+mMhmH+pQn/nIyLHyCrDSHNZF/NigMmv93rkxk4iYl6FseMqIniTOf06EcdyhMwKnn3BsNJb/tzGksyZh2tIgbI/7+k/JKyRzeIb2jOn7OdYWF+2bv15D6woK1ghQNJena8vsGd1iXA9U6F1HnFr/hGJ+kNH666xt3JKfrq+cTzfZmGiY5sGrCvo5BmvbDcKxPUN9VYOp422p/71ftDh8zhYwMKDU6/bBrZUI0GdY57OymqKjBhqhFcv9EGOOTI91GG7k0z5WlQiT3VVTLr0n8fT5ryTb1Dvvw+pGIHpP0dIYcTHX0csDlINkcBuHmkqzbooHLZdttORdjbT/kmvum2ypSCfsAtt0NS8OYFyH7hKhF4Vl3PXNThDMEEYivcsOJ6Os08Uj5v0/00vTMnsU64K4oGOuK/nZPTXrtRLOp11wzxQqpbBgwML/t/5iANL+laxU4eB9h7oekpa8tUMeGuAPrKV4H5PgolPL2LnuWjO5+JArHNyxis6DKFNVVhhe36mNdA2gfbdXhiPj+XUJT3tzq2G/NwaOYJrMditE7zn9fQ6aQcijzq3FmikryhFDLusnPVRQulgpwEQRUnBxczphXaqpLNIaSStSuZAJjhCY0jv5KTcFs7EYmBlV5Ll7GJXH1zaB80J55tzPSa5ZhHH8ydFq0K+qNl8aN3uUpT2omC8aXye0hpxcneKX6gMPqgZM5bqt2HNrkgdnFst/dZH3A25377sCb26TrSKeZFJPUBFtug7hbaoc+RhxoeIQ/MSscp2BkPh80stafkI8kNl4vhB0Z08EuUYmAtrZePcRLlvMdbndR029GJ/dJvRDLNLBikfg2ih/6NfygSjAgJ4yu3rtGYGU3e5wIVWH9BE7upuE9tSduHC3Mo/+qffNOtrnaub6nRQtORZohojgxy2Ocw66MESvyuxd/OuYB/725Wo5NrIc7E3slOlFmuLQiVUQRuvcq9YklVVVOvomk2ZqkVxzbwiBvZNdps3kis7mgkSoX4AKjb8pxnod9ihqdih1BM2BPOEN4TBQXXFQJsQH26h2ZIa1Si0EaGr/Gnm3KZuhSieF3DSINYgNd5krTE19TqaoijxCDcg2xHbJ9pctMHvPg+LFq/MdSDZgJgDIl3bgZHwiOXDOgxpEZv+SFaa7JBldmc2AUEvqEPCIEQyR7JG5cEShu3kuu9JooO3nVI9g+SjaLUxKEbPbdE52OkzsrLgjVWbiKaC2zfqW+ypmn9OGCbg0MlE5rQIkiIRKBQbWjaOvI5ukG4bcHZsPQYjyz00/8zvvwzWX93kONIVbaDf/A5TQDoV34F3v+qtxho+hOu2dTwEalMUxDZo0b9w7DCLvBH9M4DC8PBpmHjIEWa5dlySxHXQebdqW3xhKOFavFfgT0Ak7rMryCnhB28ByWnEp62Bab2g6xY7AnW8bCw/7YE6vZMGtswkoGgQUaYRCPcYKp6gAaJEqaOokgmBgULDGVVsmpghbWDHHzdvfu/Ml6+svifJJxNDeZAld15m7utxl1Bv/I9UrqdXy4YygjRy5x+GPWQ83yxk/GYIwKYllC3FYsYGqkKdWMNhbzRZKblTQvNV0//al1yfHr/TqxPOyAk7h+gh4d/4fHzCdlfNWVfvjOlZVpqxkTGN/mrw4nABZrMQylqEAKdOWESwGopgXuMhgx7kEkeOFIqwPeae8X6ZHL5P+/A8K54OAwC8h4LOagWwRB7fqwQmDbtQhsCJ5/Wz/TrNXCODDb0bYK7P4CJ3i5tGr7Q++qCMdyVDjKmeGNXpp3RpGLpTI8SapNmPrkp3gogli5TJx3ShEefYFhOajSRzYU9glZFv/5f9yBYlATyXn5Eydrpif3DbPg0qqC6EF0sR0U07rOX2OgpsThsZFF/aNLvHo/gVCaEp5lBOvKYrwX2gISEzop3U+m2TZ/L1UDl5AclKYgd5jSOe2gFGL/NyXGrxK1gN0bbhCrbq1iBYaqPFuv5YK4CcM8rTFtb2DuahWTvMii/BGwTOozZmcvUKq7h31DmGDmyyvolB5Y+6uM8Uq7wsA4I9cCfvIVzrXv7yDgDuA8nT7mIKTqcTgJpWB+pLexihJD7HIsxn+Jnb3OU+e0ZP8Y5aFcicO4HmBSrVvsIAYaKUhaW9fQpjovOd/EtzyajPRJYhc8h4OhLPwPVKBrNzIEJY0NrVBfkBOaA8OZmDbs/cMJQxAr01SDF7gTpajL/Kmw8J+uc1554YYiH2VYIUWDpI1RnmSC6zMwRS+yV0PAkn7yc5ERT3Cr8mEa+UKxnggTbvDC+wPjGRmBIm4dWNOAnQkihax1NnxugJVV+rABKZuTZ3p5WyqiExb++EQmoJMthbA7+IJtVXAluhuGH0wSAeeODsEFTUJ23s7D632FRXIgw2+6kSZJCd2zvJF6aMPfZQnzGwsGqTm6PZVRtNRslGVHlRWOFjMCn+XBOcOBXOkHtiixhzYbyPgA66CozYz9SXahiHm+rOk3W2RfnNTwbz6UQI8Xj9IlGC5XvN3s1nRRNiC8ZhgMBCpYKoxdikTIYA3CgbAmXw9SWoea6fYxMkv4b/SuqH9jLyjIrMwAvQ4wudGRUGQitq8uI0XUqDuv3ic1I8SsdcRy7tPkqoGrRsIcHjhpUI8cqH149uXNnF2vo5+BSGiWeTvBPMvcui4AGZlDQT9tjU5q5ZwuAh7VtlybFxFLO72u/qkOSBquMvua8MkAkR/nC96u0d4JRmeIUynEI0FeviV2XNzLPKXyEoatavoMfGN2qBLsddG3KurCUkxPUygD5buL46RNDziEylTwnfuCuWJ1wFbOpMZlMMLnbUfbARfPiry+3HCPxy3CmBw/L7yRPB8VTLYPi0p0xak8voNyO6p9xzjpt/PIJQETrxwIDpZDee0JctLGETOSQi4AGff+eRrZ84DBCI3Cu3ODA9RL1L/7p02WXNth9JqCxkE2/ml9olZJyn3zahtpBC6QEGtWylh42AI/e0PUYcTe6UIuKebEjx+80JxfEd3eQzmaTDtu3gknft+fDwFFSph/F/pIXZ3ZLlpaJqmNYwC+PDybdhXBF0/btvN8fDbKkMkkSXQ46DXB9FELEGVw8FregT3fwTExMZiSsTl2XgSrvULQPgrNrpiVMcVl7bkXNXdEP/EGKP5LOhqpC09CtYu+DMbbFKHvEkIVRJTEGQg2U/rdiHio1scbwN58ZaI5OJKNWYIGAUCumZ9cSqlGh+nXOWnF810UHHZBeQkrx+/OQZiGCP/eDB5e4dmPmdaeGmIQuA2V/8PrTTeShqNmC169mgZU3SPk5DYb7vowLdufVeWz12bLcvXdEA8epdCUWxBNobpgbi0iTe3O7dAs4l5ZDge3IsS2Ge6uBg5JKGyYdC6I2gUIr5qQ+RGlJA6LhDIKWglazN47/XOsOyHWjdXE/8YFk7XbKXcbd6J44xMCqdc9zGAAOFNryE9gmvp0Nhrm9psWDeFCXMlXH6Y0fAeREJKRj81HTeThznnp6XHMuPvlQmR0lICFpb97+ll10kEz/but018NOQk/Q0wXC1GCHVcb2uZZdFVt+NbsM6LEsqy6MAvAKu2jN3keE06wJOWrp/hTbpBwzPX+Ppng6t8yF31wZS8SLNhLJida39WTR7fXPF3heq3I+xA+Aa/Vfh8zxELaHe+88z4s2Q+hKigScgi/3iaY7qHWnQF39UHdzi7orAv/LtbdXjEdUSGBJRCpUNLHkj35qeHjLq4JEChBn2MbL81vaLW1hv3fVx6NaoGm5oWOCFgGU68Iwo471E43nwTWFuSzgslBaMBpMfoTvo9Xv1CeZrbA7BS0bstWfPypyMcvNTx95vzOYLtefEs+0Nel1X1Ux5lVFCnneR+I4fduuHaKdLXuevcmFdhhNO2qmwRqo8DvLpfyXKwIiJHguYxpWXLgABN3LemKkEjsT2Yjwn0MdkrqnkyR1bYXCUA1p8GU8w7uqSxNS16pGL5M14uFWOfmc041fQjZ0oaAE/Pv2afKCJ4dO9ZX9/UUc6pCUHi7D+JuoCmTygDCW6Nd7Qw7Nhub2laQBa28c/EG5O5BWgocwREilcg/dY8+Bry+Requz3xe50rIrcsEY5AjsKLQMcV/c9wjtsTYusnpgD5hetucEbDxagktFN6ak+inQ0KfQi+8pOdLrobKNnsEY86c9mNgJBglSaJIUZBFHfnYG7cFlimPRbXVkblghiFkKS6MYnHfAZRbrOAd3nS1ZebZQkjrXsWbfuhj0CievVwjzkWxwZRTpeEesjGN3riVM6Zrykntk3U1YzDunDeL94coXBpiR81OcNOFdSFUJMBZAO+mqDDi9ZnsBlQPqaVxIpWmFd0ByUM6XH5soAxcyuDtKJvY+uSbss+1GtHRCkBM3u1sS3MuBu1nj/ZAfNZw3Z+i95gpHeD84M+vhYc1wNAXs5+i5PQFqfiSpBskRYQHbEyRe8vHP0rthgXjH7hrarngbM5Ld3Jw2H8VXL2RL9XT48eS47eYywrBdWbeLHNtYxnMlu5ocrHwYOIOvLgo08BZQjX2pYWB6sIoBN3B8zMzF7b/331Kh3vO4fCMYpClR/9jYTWOFbKGkxawKo0w9KyceY6dsuCFouQZJnyVNqWVmhUv288MMxwLidi1npXpfEBOVYV55u2iw+Wg9Fv2JBfW/5isKU1oWT+w68W0MkGLQwMpQMhpoQRLzdiDaUkLyxx2VuNv7tf4c4uZtX+G7UMMTCBM7+bLf6trcnqZrCdxqCwwVcjUle0mZsX1jr6WDL4mht2MuUt/BtRn0eeyiED0FwosZpWBs/M5aUh4dAGgfT9MPuAA2sBunyDflie5A+AiGWBGkIdCd65QpIHrggFQBn3y7sNq5hynRDaRNOW9MH4EaVXkreg5N8D6+FETwYvnDhQizBPhpXZnzQuk9gqvleTVGTiMbFDxkds1Rm68chbyXuodNeRFluvQA4KlwILWKcm5v6xbqO+CP46fxKD+Lr4iYEuLb2TIhyvdhyJ3MiK/Yd/tyGeR2+065KJX2htWvKcGB7nBArxWB094zBBlM6QqVvwusmfBRXWaNeUz2jKMFen/2WCXuPCQ3Z00GnXS475FlvPFsbMhfCYvOabxBDB8GKIkMV2Gp6h8fapRpayYgqSRDZzM70p5sbC6SY7DyLO/RJ+/9dwl8OYUtvqhkfPaU9ZVk0imYqQk8IFinfrZYDVvpPRILuz+Fd7/igJqUmCHACuMvsZo7UPqxmFqmXmvjEmEtAPpCs5nfWPgjz2s+f1ylIcfrGw+XOT4OwDEQKb/zgye3ediQhlGRQZe2FmPrcCrC7CDFraBqKXkv2CSrisfiXxWMdiSYysWolmsx7xw80CHrCJh2BGYNmOy1PyJopkYWqa+hSLnnEOtcpzAD2DvWjXMhGd3litNjGENXp/ch1E8V5N5OzTPiU+Ezx+78pEi87ZZdSfRlYiW+jbyKRN0URMrcmzgETxAYh3mjOjr10ZhZmdHUj3wPK0PKCu68cNW88PJw6kZExYKMjKX6I3+jfasw9Wl/1VaEQ+wPrMUmt0l6H3mJiuwLAD1X84w6ZX6kPQdtlaAaaPNj3iLJA4ezOPkyDW91vTEVArR2GopEZM9qn5Zo1HNUlvOlRVuaFsM+hVNS9cFPVyzbNBSPIpFe47v2vaKEVCgoOlcGBRJWYcsRrSrqJ0c6GANRlwITgFbBf3cAhh39gUSrCn94g3yaXBQ9jUN4TLphEBZS3DqLOTG3PFM3GB3ANbuzNZzBJO7pIyg8T42lSlnOJSWBr2P7QcZ5b5rmk6qDIesc0yD1F67/1cHuA8ZqRfXBhZ//Pfc+/KA6uDYVqW7YoXJ3qy/4EHJQ+MVUCcyX6X71hnTvDBIujqDEzTwn32B9XD412Wn00eYmTamE2zAAYyxpgR+MjEJK7AggyunIp409FCUfrMxC4gqQafZVe76xT6DJRcSbgeW10Nms6HUul790CkZG0zFiWZyUPjb56oibSnGhf5uePFIRNLSUcSnY04K6SvJBmrc7nHiSAhZiQT+tEzOJtOKNeo65kSUnimd5xigoTYMl52VxscMku9I0Tfa4nRvcCbKL3UQgkxO4pTpwRtVmf2esZeIU8ax0P6Y1lCFbyjk/yZlEMG1uMcFnxGQ2/C6Gafl5eeuPbVDBI4fztxSK3xHn4omH8qEwlf+8PnxQjJ2082o4HhNKPdAiRTUFEGkaYoh3DdqoaY7KQKnfHb16TB65KoRGbCT7Lf1JX5WJN0hD1YMpmORY/A9UNYNjJtGTJP4gq9IfpTnOea2w65lN8nfNeA+34YJoJVp4HmW4LpKCgKwtqt/Jh/PuBCZRxPruK7R+jMHXfIchu7XRF0xCzsSOXXgVseOCNy28syGFCqBiIfqurNMznctb2s0G04QIianrb35eWogfUGc8zIPZUK0VUypHHHiIh/eUaYPYfQZKyV71VC2+tZJW1OFwwo1e8lZnT7dhv/1INLAhqBCui0m96fXGSGIfWOM/bvDIgLbIpU66ImDy1hyPs/DQ4K1y35EXrOfas49l/fs4JXNpCrHOlr8Sz9Qfr/+dbY838IiglcoT9hrDSRWd5P/hIJDCclK7GI61LW8l7nxhUtDQ1ZPNqkf0ka54WIfIm1MzyNt8qKca93wGwPPsV7UoTmYYjWla04axTcynWa4r5pKv53P+524GUX1wR1zAp6TllxDQe9qz3/mLhW2J/oKCkbqB8stDPBsb4Mw5XB07M5XB4zec68B3tb+4p+mvy2zDtJXVmmGChf9/Y5Df1fOqTHUQj7ehGv6lgB5JaXJDV0X885KOJDuz34ZbCxQ1s1nQjOsfGlyc2iep1CV301LyEa8/ipxlpyjBF1QYRlHViOLZ8BPvsUHrvXBc2mkA6JoC0dolw7QtpXZEQ6y9foUzFp/LemqhUSudMOGa05XMLr2GJthA5c68j1hMJU12WYLK6ORYjWKbj0/n+01sgHYxGkCQ4F4+IzwyPK85tMSrXb2pp0qRbC96r1lRG+LJQ7LAf98jMw/1thUSo2QHr1/8an5fhqxcRLFpmxUF6xK4dX2TuU97TjBRHKJ1lG9twkWAQRb5njYcUQierP0fLjRfuePRHxE0rdlD5tvtq+RpYra/BA9APtvVTkT9PZmKA/kqP1GI32w0kJYjSeYngTM7hxoVocI67aR1etKos822XjTzaikJrav2X9cu/VpqfCccQAZd6mw0/M8/ytPwz789DSFeupcPOj1zCysxaRIkMNYtb0xyGAvq0/e1XqGN8ntxzcSeDZYBqlyTmeuEX4jfDKSsEe2xDMHO4cd9xJzLI0JYwhHJdSndoliZaXlY3mI+lSPO7WmmySjdTCNmuE2ATJZhNg/n6dn/VBjemTzPLcfNtDctGchZUOjvyQhm/fT0bsl0ub4O+54Gy7gIx6wdvrvpGkEPEeAZtAcClb8JR4WxrF5aKry89nqbF+bJLPukEjXDTJ/bpmgSvHLiSFvSVi4TN3zFiM7RyQjEN7ktu7kC1L2+G9w201nAAzYx29EzZtaK/LyO3oz04cZthFjBfI41et6cWwhvS4PpMlqqsO1rxUN/UB4pfnYH6vCFo8duaSIvBMb2rJFvSM9RFtr9TTIFsrNLyHjl8Oxzes84LclFhdXXGuptLTfDZ4aORziuPVwQbYkVK6lJ0j3Q7SpsO3ISSN1m1rVaCs5CoNROSVMQc3roI+u3x9stQ0vZyHA2nbyJDEX3/95Dr6OfDjCJse5y+XEpTOf3pEs70ihPX6V015yIAlbXSMYGK7um9IkAVJQFdYu+8l9dIhs1Usj2Lhj26zyxzqDriFMYAc+LW00ZsA8xcq2HOWvs0yuzYUJBR8jFpQZn+3C3XbULl4ONcGNHugCfvdbAsf0JkfbILUEQH9wl1z33w1dFZhLrw4LZ4wPh2EgAWoAbCOPk9QZBi3B6qoLNRaL3M19RfkL2QBG/KvD1QExvlPNne5y/AWrTcinx/fvYPLQEpd4mRDJ/HFGDjERDvSUCyyZFCo5NF4+ZJg8sLZjzbaKpVO01AIz66ar74ObxYr57Rbg3EYz6EOqjzkGhn8jj8FJvojC1jiZEQSSw79y5JIhsTpu09GkazhKpFFOQznh6J675YToI4afmKe/Hg6oDySDW+1e9cT+IKklSBM61Xzz/UNpAxndWUDmfI5peV60eUsLX4jw8pL+AnGy9Dv/9vapUeqY40z9jvSnkXCudnIzjIjTmILqoZUnuoWScpgbEkFulmSoTqOIYYUnUtYyFK3IavT8/msrU4pRrgVNsfEif7RrrrpSpjBS3dZhV24dY3IhTCji3GY+L28J2Jr9+7bvTGQl44lFLeCNwBn5RU2tITMWZqb9EHugwvFBsHBF0djUwhoJjBoRe/BLlGUKqsFloq8zAEq0XtRXsM57lDj1nCiJpi4oC8W8g1fsQralbBRoYZ5WR2WxAtGiBc0tcqdFW4n97v5P+uIooU37+hDUdzGl7jDhVPifUItfQ3pIkWVz+/mpWV25adl95FKweue7xTSGRIdhItyQERwD2lC+wJjVKC1K/yoWo/Erf841Q8GgUZHHpGYE8p9Fj89tN42eW27iST+3DM4LYSoI8wa9iZDmYJVk0p+7nP422uDAPm483iw6Gjesr3mJZSmDfH/WkQoxgapw0hf9nfLixM0UfCrv6q2/uk09B6yfHTbb7W0L2k7hv9fJIZEKzLUdToQlnNsh1xcHYnFkVZkxRjy1acUk4GJwE4jixyhf3eyZ1YoukDc6HwY4QYlQnmy79R9t1P97jgPMnVUsj50rTQgtH5miCXpBPLtS3pLjpR7LN2BCI+0HyY2ZBiuwLCUmfQVH3hqNl3HSxN97foz7A1xJZi4D2HhXWgkx1gJrPKp+eHaAs+gZyF7+dNGSwPlK9xUy2TNL89B9nM0vxAokRbco+olwFnUMP2MGV6OFpzhim3OAOdFbVkmfHPMg+nUPxR6vH5HokTuFuIfn0Eb153b+ufPtiQ8RUe/X9FQOK2x+5Yc79jQEBPDWTt7RR2rOlwdkjNznzgkEK2Asw2U069deIzqFep3gh6sYjM/5eOY1HnXRd4yW74vBYpJBwXOjyvNQeuSqN/oG/mFz1aEEWWs2ae6KqCgLb8rHwubU4CS+0rw1fGglyateFHvccp7u7zi/PY++dHZrwjJ4lG3JxOna7wAK/Ai+WM8hhaqlI42bWyYjb2Oxa8+sdSjeLF+wliAzU+l4VNV2wW6qndv0ifmVAwks6JTPzxmpuGSkO98FCzoxGx3OxSYXCsBnKeOzjcljo2CptRENfFS8HQjqG5ym1QqluI1qd3urvNsmN08Mog8Ou08UOUFzkSqepk/QHUp07J0kjJ5yq9fhHu7ic1wRn8Lo5YLysw55kL6DMfVBoz8a08fM+KQvIgbMKAK1ofPyNvVnqSlZVwZCgIg5oye3UaKRXDDLN3oNdbof2bpLV9tucWychZIxgMg5vGbLnT7nqxV3kjBnipkyX0ycukq1nLCZf0O8KSYC+3EG7nBQlAU9Epig/06b3WqmvwdlRTbsLER13mwuRD+PadGmPG7O+2hyl3vdZS9efkUCE1KQDUOobgzfJsS161SjwQtB+QqRJRVNXyDiYCh7DjSyEJRwIh5mCCPUWnfEbNmKx46B+ha3LLgxd8KymKWgbmYlNrJYxdxiQs1+BreyX6WMiLSRW1TtwnUBvjGk3JObrKrxvGh/2T3pHG14TvPJD/D2sQkha3ooYlXGT1OJWEoUau94A0guYWSjLBAIW+o3Ok02W+XwFt1n1xL1feoF9pLKbck3xb5Vj+3rM9jIZ7WxVI0w7Yzl00aQC0rwcvzPPS4E86eExf7jTNwgQwB3nv8MhtTovvU4uyq9GzSFQ7oCl8B9rOz5DsH5quHEtrkV/En5gGnJifnadxbmzOBMvqgFUHEJ/vhgrsHG1ccsi68kj4eNKhS8shSLNZhBkqoUAxr6vC//7IbNpVEL7BR9coAzlXT/6H/CxuC12EKOugBgUhQTakgRloCWfh9yw+NClz7rsAmhTJ9UdPHa/WiILhIvba2y7T0ZE4/mwdJbDOzX8NvL8pFUgN5ZV0XWilezJczeSSFoIpMqnaA0ydxfAj6rIFno4a4JLc4prCnXJbsK58/aDHs/T9Q2jqrwEjy5bNpgWiaXzpMB7hAD/dQddneo9YfoAsfcHAPF6tTvPRIRAhFj3913UEdXMk8NKBfx1o0Xz0UtzzCMkA1JETTiDqyF0agiA/nMpTM2v2KB+cTRPGPLg/y0v6QSgRW6V/InJMGfRggeDxAlhHI/KnJefQUtti0VRnJq5WsgmiEz/rTwO4EUCNJi04iYxfOAcDwP2KxsmK1L4PnwyChb9Dy2pZPUJpOaYrFR/8sFbgLb4L0NxP4qL6Gd2vnqnwC34y52lSgYe57YeoPrNlRnqQOweYtJo4XZu6Z1Gxi7+Xdir+vy/1VyiOLL+3RntbCdy2cOl7QXG+hqqI1tKF0DMYVxsg+2OvTnecH5d63lHlER8wMdvfQjYIFfBp+akq9wL+o4gQALsvIjEaK7a7FYxxjAO/cT6IY4mDkfJGINDP5DBDPA+w6WCHj9DikFs7byu0PfwhorkRvPIaBOtag0p1LJpfMt83NK8cm/2BUc1OPRX5tuzYMFCMCX/Av4vgskgV0vCE0atFkPF8gPk+Oq1DvGrVL+dnMiQH9Rfhas0mEJ0ujEHzWfccCt5mU3hpI+nFab745xHrjEfCmx2mgMk0/s03yuNX75TVlfzPmMV7go08ujEHlabrcpanU7HnXcKQfXk/a5r0U3OPYPTuf4F2+rFgx7E1/kM9IK8cmZMzXL+m1gr4AUkLkQuAh1OHJ6S+TsD8mbQpewLmedjeXPssmdQkHgp7jFSOjpYh90BcCV3uHUAUXqYd5pzKjk11mG/jlKY+Vbtpz9fX2vqNvERFQugtAATBGuVdqO6ItHZ+tW3dIYDEOElnnT/1TsCAp5tw8JYVE8EYZ0WWnwAhYgF320/g2xn4gmEfjY0/l5c+9uRrx3Kw68A7sGaKOY10gpbFtW5+5dCluFED5upkNzf1EKLtxZdI3v9DdN5/IzzneLSKN1KZFVra+mabOG9L2+h70WKteEtksAvqaifAWVcnRvStgsDA2ikp7/AtAtXLenZThRxJO9oFZGO1f1nbAQ0i5KF6KLzfKchWVMq1g96p9H+RKEIeG2lwRywskqWPDRFbB/FKtYT/bIzpKDRgbfnIpl3KjnK7KwHL9FnNhEx5TGvjwmbpX/x3lXcrYIUqzA4cvRbT1tFl3TzO6Z+vTgsj3RVLQU/4QwjjVJsHf8aIRMkP9jDDZCyt9i1iF43mNn3xo6DqKQvOA0T2pu+o20kP+8P3a1jxMbOoL5AO1HS1+qtULf4KkvX8mIF6gWMn017Y3UdqDAYuSVx2coWPgLLiILYD97BbWVAVAsTgRz8znMTUg/EmF5UANeus7QlXbCd6GiytJYmB5yxtpUkeKysrs6TrEH6Kc6I50/Pns6ydhTQe3ZkREHByWElVod4YZNdDdLC6iZBLJHp450rwAtEhsHlDAG0n8Z6TLlUYFa29+Lv9Jom3RGmh4i3v7LU5tWKWxbqttuI2cjuU3GdZiMBEvj3z733KBMyyoepPo1mGpIRjj1OeuNOqfFRb760mqJvGSlI37DG4/MISJGmJqfnD2m4nCuorH+mqMkyAth6iohSzNKORfezKT4gQjzWD5owmgiCXcRas0WzxJAHTNi4t21difSyikox7DW2FP9CCEVovw3p5hGg5U+AT2hjlmDI5Fn66Ks4R1VKAEn2jsujhvci1s+1dW8hL91xcL1xsUTZwyMIjCyauCXQl/rhREEyrJYhsjKb1HzNwVpiqEApT04tZmyUfj7clb/BNeK+nMYD1LmBMKnYKVNw4TrVfmswVS1XDzOgkHmHXzQxXztyQMgqYYXncGklXTjnn9xlZkXQjG+y3apc14HSpD1INvvIkQbwLlFqhHZDq/POE8U+gKgJ9JNa6DMheNxBEHuXgaP/HS8pZ6IeiJ98Rm0TzTmv3Hp6trv9fvaHkPYLjY/JHBPTuvLjMU90BroU/wz9JqvKpyau8at4l2rhvq0hPYgsiigmw/N4y6gA3BkQ/T5xGdokaftXpqj+sW5UaE4Gy2I8zA5zjHT3Rx6xVwcD6YLsqiDVEpn3rjeOIkbVPDXjkk2QkyKoN2TF6mhJjvNIZR4Kpwsz5hHrrQlDFDIVWYZtSc5udKWc5S/W5P//mAQ9DRpkYC3nNEw5BES9QsWGkV+Zc/MsHwv+otKgH4rE/v0Nhsryv3Nhtmgmrxbs7L1fN2K7Oojrcb0TDml1F9/TBjVNnhg+TZhGyGkpXN3ndin9E04/cbnJ/VflN9TQjsjIZZS1kuiMc4uT2R+7a67MG1j/OouooIK/jv6DqupG32ZBzBq1598UiKDgOOyAz/iPXLqclqzXoTUj/R1emXhYks/N0SYaV7yrBBhQQTWTHiPwVj/ob4b+8GSqVQqx5aA6wm9Fv9KAX+Xd19Hmdv86uF9I0BVIHR/qxDNQB2zR6zuyFICelrpzX5pxD7Siwde5YBF9kKNWLZ9TZg6N0idT1fWyhqZ5lwI//aOdzjek0K/D9Cfc6g7sJgTttK5TBSfACVcbIfGEWOTuxbWSuo5YPpjlRHTOts2RFgvbRbdD+DvJTA9dOykFNY8iUSQHUEa2dtk0EOO6duB2PqMcS44ZyCEhmI4qSMaMUywzDAvVrzQuxmmwDZcoUSdGqnEfBShXPAlN5hEYW0ti03GZ6tB+c7EnpvrY2NHiynjO/fRQoJmKKsglR5olGDcZ3zN8IFISfVKZ7TgeZHkwlOwmAt/NmnMvXgWzOi4LMlA7YDQf/Iewy0jAkDKzEAxgw7U1gmAV1hmPH4xbc89UhEKJttDqIbDHoxESZPT7TBbTYuzmKEe1RYQi0W7ui1QK4dzyPqTT6HpZ6eaPHLf3H2ktbqEfZoziv7gHnXrxG/JJW9fKqTwAlFBgv5KTksvTN+3SVXWY4Vavx0Cb5H+gq6Ax7DeSqgw7K58TEvDa9b15P2ya+Dj4iTRZHy0JQQ6Xr+EuMeFMsQS7XdD5EiWW/Z8eTsz+xChAYPv0BpHx1aqDfJn0arALW0AAv3KBAbTrvXwNEN24xweyiVlovF/vgKpl7Y7TSZYqE/UxX0EIiJ/CnNVF64vPRbxxMNyRqsRKI5Muuw1BOkAnreQUykq2JGpupvrq/DNd78vHxe7X/eACilB9oL9+O9m/Ej+3ECy33hi78eg4LJ8Sixe7lkNQ4BKNl7+XTOJ1WFi4VhMUNoFPfaygj7DjBw4NGRVMQe6O98E/Fb/D7+u5QXdPgzTRbrKyQ4ZStTlWv/oa0P7oa7DpkGe7ZfWLF/Dt/c0QRjbuTGv2Cd6TL7JjuGYvjMvd/wnqxhhCvWjqiu13XVEWOEN+OsWgmcTI+JcISKdoMENi2kwl2Dki53Tbw6uzSip/OZenBLVp9IrCV3I1H254O8iQKTR/ITnduahQnZgF8edmmQv3RpK48AV5Ja9ofw6WrTmzJfkE1m3R5lEmpFHqjJW/Ok1WGBwkZ+2REDJ+cX4CQhdhhX8OebD2wvrtV8gGcuwdJwXSAI4MyhWbDjQ7Q63uUb5dVjXtsSXMOs+TqzFVSJ7cYzb1UIFjxen8NKWTuKQe3x0rHEzM+4Qs014gbL5o5JCxx8TgHd9249SLSfbjTPVkkl5M2zFfzL5rdwkOQmIoGHshQ9GGDQDPF2CZBLBqudpYkVUU3cAm8Vi7VABIcGkSKrB2NY4UxqcY97+civ2Of3EOo+1JmnKJxDDRVmlBX0zjwW7VdYT6QoUo4ROLoL2v9fAAQjV+x2wKrTVgo0ZKSzzbhTKhkjINnNJ6et54HfrqoGCvYT2Qq+6nh3H72Y3znTipPlIpjr6Z30mV08PHYd6dAEXZxXVAgwGFL6I33WItSdAEcu48Uq24YFJBKsi8u7Xm46sIyf89yAk/v9poGCS/h992/CogGTWSY6GM5vfD9dOmzGHx0+tNbrke0wfwVANb0R/dKIZfUeC1Nel4TEe0XOTiESWnLCvv4Q13AqeNEfrOQ2OEmufju7ipTJDcqilBZYaxPrBLpjwYmhY7+MmWNxqr8QMe0DTeOS5w4wzGCGwzJ4cUsbymXNdf33cVVhz0cWsquZCCQNNUUvAmLXTJtvj0sGcfzeRhQZ6seFP6cmL6YRBJKl/1dbv+pubZhbGXrJlvREdpVBz3ZqHDH6BtjiWBCargBQIsK4O+8EQ10cJ2IPxr6qRGTKk3dEaNOxU8ciZbAmWkTvb39itdnAxHo137DYPw0zdvi7OcaTWgw2mOXWTKUtBPznWVEDFHN5By6KZIuousIuonQoag5Je0il3kBoewGnbIU46JeaZYdRwE9vVRI+gkMr2o8m/nyQm4PmIhJsqte5wYkiLmZQ42JMafxEsj5fFuvmI5Grnpo2uiBJHUzNKN8b+FbrR/vMAQMQg6lRyJXFy/7fs59BkJ9psO/sZLd3fdn2/UvnZr4qydlceuais63azIYxPgC0oW/aun2RTtkDBfVMXUl3KNAUH/lNdTzLqkQsaAAQfmxW2a83ZEF6MaPbk4s8PAtzNrQFpx6of9OVeT53BbTNaJmQ+jNWOn3ZHXZ5gW2DukmYgE7cnW8tS+4tpOvS9RNObaAJPTt40M8lIQpIby700eE2hA9RDflX3vkod96gos5vexTAu3qTssQ1ty8PjK3f2BBQThL/HOed71HI1x4dN/t9lCRhEGTz/rqICcZ7kjvlIltPOrNXH9ZU5COpY70YF80bUUr3ow0rEvyPHEiwZbdzV/XQIw55cOpMpLm7i5oRD+wrmkdrh/NHRCBQO4fNJEJSVzKFHMepH1shuxrPpLmivDUJcNlHk0HUhDfq4awjomAZrvTMoEMmpdhhQfJ/gaQ0uzyPLQheEiSeXr0WrupjPB2GLrEGS+7UDZw2JGYakWNUXE0VyKtti3P+6iW3tBFRF42YJRNzvf+4Ia0jlag5VmBbrW8qZKnaCGQTFKFz0k5dCra1TW3vHxrvB1Y7QxDrdx2Mvgc5ZRBlikLotMs+IW+CNHcsnKdFpOMSOXYLGRvsE1jSVBUnVYzNv6yfWHOS+25aR0HMEfOcUQGRGDenmsWZOz5rTpwBqRHZvf6kQwMSpuE28WzWXBfPR8k3ttczfXpvNOAQ5zq6b3NqFdRYYQjOg4f4FUsYvkUuC1sM7bIwUrpLSSHSGfNk1YtvDIjjSExq9/+Jfb8t3Y5kWa8uOmfWGTFLhCjoDPF9HEJfufekx4/FKS6eYpO1GZblf+VsPo5hJriRCQfBKz+PgLJyNJm31ynt28kKVFV+fA/MeWGU49yB1vLZqa59Ogh4rmtn4YZe+CxXOa/W434MKt1zjbHI/FnY/M1YQbE10zOZxstaeCgtzi7yIEaNdPDGKUgtGON7n64euHRXZkc7Y/6pNv9iTD/bYZq4Zug/SjUCbZpeScLuj8eeBVwGGHPmREglsNPOmyWFL/IHy8oDf7JKxmjkHpj7Dx3+8TTm4D5TwVFWFLh9qPbIYmcFPItBAwL1kPSr5KzcvaEK9CSu56C7n98SwNMzE0rX5GG3qqsg2PQXYZLq9gTbGohMiIlRkIGfZaDLN41Pvm0ugLw0yohk5iLc8f0C24/5QFN77PvPE3xbd64CBxM1cGdsQO2mpNRSgNLns4QmI1zC7V1SVmtbM3uZo7LlmoKTk8ZrflcOhy9HYyKpKFIaPCtzuUBUynE8BYfDib3a4wi2vjEtq+NKj+5JsTPHOj1zi1Rd+L9DDcyVWkhp6QkWs6BC4nN/zYGy0M0WkV+x0DWHcfcMA043Zg8cCAUsGR0GBJHy/nIYqZukqewvz3xsO02lCe1LjtPhfoL+nK0uHxu6Blugpg+0YZSEMeLOJ7cIYJ2Ze9mi/aa8ac0xxEkVBDiluK4xiipyu8ax6xZdiOU8QV9HecPJiUgANegjNtDXdg+M7gJt/b80hZbkThjdZypRLBzoGv/2dkuRuFUN1T+7DZRNggdybgPfflGL0TriPmF8HhYOiIAVLGBkTQPhAE5SI1F+b2zINKGLHZEYFVo2SUk6vEbrpj+3GL59WpetLg04dc60GbAfeoB1DRNnmCtqiXAQWo4A3jM8ClzZyRzjKP3DwfPx4vSgP1btzLJic7ytHTwcWUU8i5Wdz8y/0/Gu55JteLUB+9uOStzuomMudep92KuLhv/5GYlCsOO+5KRbjOkYeebpXvvwt8LPlrGDGntvWguiUX+523E2PN8Zf27hXLReb6CSnmkTu6dXg3dqs+eSXf8KWZEEJ+f1Yexi2cdRMrF3X7uiO4ZnpUoIgOdYJgwdCdDVMszWF0ftY4/dlggn0bJqEJXyF6VGm4N75R/NqOuu8dtcl3TobKvPiOnks88vYfg1womkH1xT/VMIVv2t4mDoZzMFZIi+61vXGmMvEtId228AV0+188EHE9yGmtXnSOVbCdL1hQ2ZDeMzmTT1NIidg3unYz06yWmgTAhEQc4E0MyG9QL2qM/B6r7SMOTuiZHMNF6Lndm5vY/do6C5WL97ZQkVVnnLG6qaS27o5svlNdBo0QLci6sflTjjOM4AxGgQqfezImL4AJ+fuwbCIzR1jNTm64tXEnWqRip39S2ORaR+LYAZKSQsSSc1RNW7chLSjfaLWBwMK8V7ZdwpvoCmoLMjTzu9H+frnaI/86+rUzy+UeX8ef+sXhtmbJrV8BqznltIuZIvZj74O9p8NAzbi7NzI4MxRS7hXjXfOJAruEPiriInDaBq52zBEXgAwgybT+s5vTvGtFivbfiMG7bSpS/ZVK+e0rmxitTxbZqepnnk7I0ln4u2qQDSZS7Mz3C6mO4ufV2qEYJS7sNNnMkdMPdaQfIGMQTLt3YiXv3FTWaLSEVWH2rZ1zyDIMq1SfX9saLecoQ+u3V06rchuhqdFfc2oWXKmnOR0ssiDut96na62lF7iTomEVtu0yzbUzf/AD++7ZCRS+HSrnt8tSiIiAum7S+JAHoBh/gTsFBzDjNjyAJBi/Wm5OYzYCGXRYocU4Zp7ho4K90XdKN+IENsc+od7z0QOo3X8K0A1+naNulwC+/Oy83cNewGMelpI2pu3utfpl18keugdyLTA/pPHfvhvG/Ay6ElGotFG+6O1AbFvb9mGPEOPotXz1R5lsJxxixpi2o9QAFrJFwDFYhEa24cZJcQNcNfjGAJeLX9bbtjJLO+MtbCQ6JttgaM4iZWuqj4se0s1Aq8Lf0Ux5hybuO1eXwi4eDWmxq4GPmK2Wl/VQba6oBozTr8MyFwWphC3j8gcXFyC8MBuoEcJH51nIYj2bbmkBGXHVq+oEqGFWcnbPs4qWOIV7qouWdlFNrRuutlaWeYAe9dTSEF8c/7ateg/vpR7jS1Iwdsj2sJHMAxx7auiXzGP0VES9c1S6z3EPNvaeoPEZUPiuWVaripiPuy4yE/hc7qrKewIhIn47/0gjzjzJwC/6zQv6tQEArTAMFCN4xEmTU2PTTdTfDOqbdpquiyKd4KJ4RfzH6sdOKNu6T/6e2GYN057lJb+EvWFq9sUNgE8eu8OyTaLWSLriI3xIv6naA8e6HpIXnNkn3H/1QifUgPK3X/JGoFkrh0ZNDTRoHpX8vnBK9yRT+LBP7lH34SuXVojEM2a82SaiDS3xHCISVgsH73szk3wqMlpfvUGgBFbUmIKfus5NhMkqryXjOndNAetjiFA8AB/ph9XuKxNkRXF/MF+2oqg0toJqprabu3lVEL9XNsavxp5UgF1mOmSbitJIz6658qGdeW2rbDcGNI1kwtwjgjBAhgnd+MPL+KIYZxb5g5XmgZYc2KMEqRIR5T4Cb31LC+6RVjt7qfzNnz9vuF8afY6yKZEZHfxGt2dl6tRiO08B27eLcPPbzKC+HiyTsoU6s3vl8r1aM0Zye4zbP28xzxhEnsPoR1wb5idy/Xmi23LQO1sjNM+42hstL/I8W1j9/jo/wHY3EJwfa3yc0THqPlvlLHaf8hfKIWJa7uU0oWBlLraGYxFUid4cFt5bVpSQm0CWtWsxe9TYEbyTZaRQBUcpSt4CBYl/ZROebhtESMjXA5rsa14ux0mmjXzEJvQF/ICv6CroW/YQ/O3o/p5N7528vSJOCDAvoEX4SCiudrSmm0JWN824whNt+2h+iUZ4UsRfsoR1FeKhEKhjO1FGROA9JqTPJTpttlPkoxP8KiYFudLVECWzKqmElHU3P0KycXnqBeN2rl7QJ6TUDTg3S6pwgoBaOp4aB4Q1s/3qc1iA2NO2o4EoIafckQnQ0ZHEfwois0100JVx6h91EV7M2LRGZsy0UWknuWRS8zgwI5OCjJJi6RvS44VkZVZUVTMqpxmnj3FqxBic9NCw8tTERZ46AoprZghFKqRGdYbqxGO4Ku7a5W2HO3uMx2MC7ghCO+vTiV7tzU/zfv8i4dq5SJD2zI8QaCzK20LXrVZj6MJmettAQXumQbNaHTRRtHHdIrCCKsX83A3EuFCe7/MZlAksYM/hDJIToR4ha2Jx854Ff9l5bw6pyPOPw0Vr2mLFcqeczJ93riOg5Kqc+M5uDu/HpJYXOm945/zMC+kQhsqcR48rEPcehPWpPWW0eYCxcq7WRF0oc4JLjvKenidj3RpEpT0pM1GiaAyMuqqTD32niPP/Eaz9jh5DqFwbV9DxmHNEvwOXjUDeNiCATJm6jZ0yBJ19aWMISuS0CuuXWUV2+SS2TLMk5q3DaiVihGQywSzXdEXWTQNqRdPJCavo91PpgQBli8vXUCCQcE34dngNJ1bmT3znId3cna29Iqpz9+JUFdp9GKkqvK1NWQ//wtqSU7apdTgl+Gj1LmvwfVkFDzMDov+6/hYhRljTrxb2cdKd9fEMUYYfF5CRrBi7s4m1QLn0G5JaI01Ov3LsltojtFrHBBVFpMyU5dU2Nr1lUjlszdZyUR0231fqyC/yIaUTbcpdOTwcKaQfDOF9RjvIG3RGCNNu6j6PgMNC1WnixYTVdlbzKthyzaPk3WE473GdBeMNFuBbT7gE4Z053v4ZOBUZZrQwD1RqmgHJzyvbngUIIiQOr9FWPULSYY3dN8v/cXVhKvNogz/UBGxWguio3v4bmkvDkrJdOKE4i57KbP+pEu26Z5fDcChD4VhStUU2KydmCcOnk9bbFgQ7oLtL/nnsWghAcJnDGL/HCpPIRwdmBHacU31t+GW3aoz5q6NW9FRcFTsy7V/+jgzWHkFBZDNdukbK4g6j/QB3v/5dtgXXCeXfkc8rMzjk237W8S3kMZQAdpj4d1JKxEbw4jyFT+G15Z/eknuH0aR7jOvSaM5SD48W6cWgoixFT3g7sXaMIAqlZkTc1LfnD45qWsDxWAtxfyZ5RZpvDGq5geXnJNT6oJq/qk9f3LM9Yu5k95S0lTOBICytKeBR8BdcLi5oka8oJUvF5OKWn8nYzj53kFFShIwI0+9H3IdnM2Iyr/rD089bPlEYRuUwEu7404tO8E07a/PT50F/Pc/JTdFACh7HqcAE1OILxh3t5bcsGPMVBQtObCCJo3CyMLYwHVuIfHlF/FeaNzugzSLJdyC6uBy9dDDuJCplU2go4Y1L2GM6wLQeTqP8hlR8qonhN0NgECvIoiJhPjO+7hm/DkETrqjHdvsbDUFW4DsmrqPpTFO01jp1RCtcj38EkRPMpWwuATL0gJADwCH0iJvLdUzKsQx0qYtOmE6nYYxE6O5SoNzdS4An7VfqKM9PTYe4dTpDoKHyCggRZU3EChRo+Qj3bsampvfsimfALxTbRu2DMbIeFkd+ij5kn/o2hf5gxg3HKKAkIvR4xVTuzZYTuc8ncQAdJmRTDdVMoejn8LuiiKScKBYzdA68EeFtYLgQ4DHnCdmkEFQGpWBkj1SBDUT65PE3AiRuRiS9j66jwANBVqQDkN0YaPRLMArYPG9P3myDGDPa16wY3aUrUng3K4DxKaoKNsoQRJcF74cajzjd5FGNizpatP6kOBuGsxXyF59x7TDz6mbckdsf+HI2g9Rn1QJvTEq+AOQv/G9hUjHqpFegY0dU4zb97PdwH1AokSKaIPSaWCjsLhHvCh3LmPKgBjH8dGhC05rIiwH6OJYqvtrFAdRM5NEdtTAw3t0ntt7buw9v1QuARM0QnlGFlRR36zCdP0nDQj90EBnu2+kRZPzppiQL1hV8UOmmX5iu5cZC/bCiepcX2IFwinl3uJ/tXasvp9IiQ8Uci9wmvHXOWhE4t47L8tQM4wwYxjOlwVNGrN9FbKp16hPj/vVEZGQsaf+gHkZ5zfz0mw5oTQAxNPbpswo4mABSF7lPAK/Rrj6fO2dYGGgZrp2iKIrCWy2feNe9+2dioJ35VahUMgs+2LOW0l7KjTXIOoYg1bThRDf+/XrMVBD7AMiVbbsN/c5HnKxrbaZdVXEulKMcslWMYGO4SVUbX+kCHf1a5Q/pxFesnThya/bT9CoK3EMlQ8CtYD/vEyAcAfe/HnZdVj93bj8VY56pMA4y2zogwyKqVQY7GGEu5xkUFph1i7+H+oeJrI8dZNZwNpJWnDqwUrUUIoWWpJVdXJ9o8YWOTTmOUqsM1KetyGkmFfyPrxvTk4pltDtK7+v4Pu2PscoHzV8rZJyBZkmip6Dgp4F/eh/dQF1uuFKeY3yA6F9HovgZyBBcs8Ta9sm9f2tIojTdfyyzxtAjBczVXNbkjAi2k8cdWogpU0j1PY4hjmL7J0PzsY8YhtAQOUrBYhgjMFQqVHFtDaE7RcaoWuZ5bxkH/6KietRwjMQa/BLye5a1i6NSDbkazeVO4qtKmGzHetYwwf5kvQxYUXchAD3agd543BMB71UiDVBbvOeoA+c0YGDrTn/wyXHeSgnnDyNCS0lrsJg0c1KqURybmS+8N7eSZ/s/hbaLR6demUxZ+gmVCkDHUMXfbIj6kQQnRNprsiRTZpRzhXgHmHOf3RXqy3PRhoLBTjLX04K062HPMKov9a48AWJs6htahJWDtwl5GVBObccAdTfhuPoHOdASNfd1hzyInDkUAP6ObHrkNi45nQ1Xxt8/h32ftzVH0tRpp1M2lgG/2Plj2ofCBmB1DaXofPrx9D55V12qMKEFWadPEqV3225tqe/OvnWcx0T02tumgkWvtQqRs5g1deyOsureR3u1O3lnVyu92H1jS8Jow34IMeVBFP7XGNW3EQ1BMNaaVtPRLVVSbiJ8bxG/sCQ4Pvr3RJS3XIFqaMybUnrSvGiSGl18r53TEuQdyiG9M3SbqugYi+ZyQQmyoVq8iST1e/oOsA25p3z3nV1RRcsidhIP70avnqs3FXEOZj1bcWASCRufVEmp+Dh4mlblkopCCyMafY9LA/3I8zTvjXxvV8Ye0ToGjc28G2OyVvAoo+PYPwQc9ItzKdjTAB0TErD1dtIZiILQPZ0FPBDahqbv0cTVvHprjrFlRCmnGoR+4nHiopH0tMZirUY/aZZpBpH2PSzIMAmG6gcziCmmuV+4AHSmmHCW6wuawTJH5dV0JZcO+ZDxR0C6PRXbT1oAmYIK8xwTVWBGE1gkCtFXEIBRjFbUFVNzRNsAQ1FrRImhHJY1mXXYR5mUga3bznsSbDhb4/jFFBllHNDzPpjnggirq7DErnf8jAAElkiOB13HURfM4Fawe+JLzI0NfA+/yUH22QZ5rYcRtBLZxHQYIBu+KGvJiRhnNWvvX+q5T/szWqFzeu0HNZ2tjfp16lyzG1BzLSF7OPF/DEltr8kYbbj8nv+1CCxO9W4+WNrB+Tuv4S98UDWg80aiLQQ37LGBo4jVUIV6+CQ8YYPkq9tB1DgnPX+IAOkZeIMsegq8+OnjF9+FGMn8FvtWk1YgzeYtJml1LQ9o88S2XWLm0AZZwP3FNzq3wxt0mvAZEHrIH9yXDOIHemegMJk8ggd4B/s6wGEM7C/iGFex82pE+6YHQtBO5cwb8x06jnQAPrCXAFVsiAFxLenLuHof8dLUY1xPtCyAm8HElijm0XsPmSrdyY5N7uVs+jATH1SL+Slp3X7nNfu5yWOGSu6/jMqYtKuv6dpXiv8th/FF+nanrHUnGTYZtSJ1nGn92wW4SinjoXZMtSwhrx8EuYt0D/3aHOu/J4MjfKMsnK1yB3dZh7hDQSWinhc1YHZEWXAfHx9A8i1tc/dWm5IFlXhMbdFtB1Fekhq6uUGNEv1voGe9n7ENAVQQLDOuzUuV4DEItIgewYMDHHbeXPeZNndZMAD6we57fBuHqly5+c9lrpvUXh/1q4eeZjEv9Tr7PnY8vFN7QSxwOGU9py0RiGqKWDNTSdeFMKt15xo7PIoFibbj+OaAsEJx4gh0zJKS0LVuehiRncg/u5ERW3l6SrqlQ7AQewncsrGtnl6umAEEfslhlX+WeFyWn3hqvmSactvxu/jtv6+YzUmCjV0NzMrLKpeeAyGe8TOxExnr/RqpNdAK+x5/Vb8DSaG7iTaXLDi4O3WrEUlDFYMBHoxlihQzETA/liXU1N9GrzmRYx06ws+vkwKP5sq4iPM3VaoCpv7rNilym2SFkgGuw9VmaLXZyT/+7b+yC8HVdmkWO0QuJRQGCi60q8/mNSRjZmJsJLsR7UxYT/qNnIbhxDwEM/dEJeWbd0ZOr4iTduqsm+4e87MAJduOW9Ah4MCx7N90CkhxJHOGHJDQWII6CqW8k6m4PutKmTsH6enXEbrRhEYVoIj34D5ousc6YUA+4t4eba2wGeUq7VY4UqVgRluIvLFWvqpVoP7S1A/+eL3un/Crw3NFZvShxNJNIacS3OFWWwzkkreLzh3/wuQoqhYQIX9EfV8vA6wq5jwnsn0ZLrtgZn4l/49jLDXfutKY/eltM3TT4jeWfB2+dZbrWh0NvoYRTmYSYLp/0JEcSBTM0MUqSodvV9Z5mOKQFJLBu4Chq2hNPGk7uoYYfA10CyJjREd4Al4AxEBvjn384nurYf0jqEMf6mE+vQLIl4GCKIY0VtsLx/lApKg863OeQf0bFmCj5ALuJopQ8sb5w0AFhmlHZtuxkU6NaMLVPLBH52StKzq6IvCdeIu51e+eyellhpstF3rlQL6U8t/jRho06cjyJpK5PHtCsPk5ts0rIOdafGgqYcpBksRdrsOAIeoUFVNEGzrRF+SlWlaMX7mpoFT8tcHpq1kp2/zXcluUW5O+zU7SeS1dfGZVoc3AJ1H4mUUW35bWCH51dcaQTLEgcfv1SNIAFEkUAF2bCx+1QKe0p015AzED/muc4k40dr5CwuO4Ssptm3rrqtHY3NR6kONCL0wF4rCEZDcFCIMJdbOuxkxXikXkh5D3C4t/enLTvuSh+ZeGafC3opee3hCKl1R0n1HryO9e+5zbJir3SpNZvD0CsDU3Mk8gCRNoOdsk8TUlkKHERRUrLWqA/so2QmAYohlBd4WtbMfLG48q+Av1JZ22Jd5ZdteSJc2/0FHz3FHDdm/Ocq3NjESQ4eUdEdVfLgKOp+dECw1IwlqW8DZBMZj7vxq27kUIdNh3nj+NhieIxA9Ja1LPEawXRmFoJ1dfhYSTMtVjP4Ku/M+tadGI6QjlvpFArbKnIMprZ9J0QBtp/LE34KTdN7/ItbXUhLj5QjloIbBgxoa6G9+sdcTaVFgTmEZB2qoDaQ0w1gOTEQb8HV6wENWc89Nd/2lQlfScz6+XoWcK6Vmao415bajZBHqXiNLRz4iSImJm0k9xoUlfB9Jo9XTIXi3vlEn5m2c3gCPt4tp8Sb2VemMFP4PEjBaeBzyZm9kplv/ZZcKkn0z8t5nkERO3BArk1vnEGivahss6mYQuwtJWB9AfWbokB3aquzosWTGMGKx+z/rilG6bVDqFIi2KmJucv5rG90904R8byCGOB9B+wIPc+KVhVuhuPo6oH2tFGIcgYsWxuiKzMwhO10YU/sEHEh9DS3Q9kZtDhBzXr5Mw9Bar3d9Mcu/+RQCzxw9mflixVcejHCXsegodovncw9rFYr2A9sCgmz3Zp6bgdTo5wg4NAwjtttVZBhwYGWAH47OGL/WMrQNizDheToM9t1g1ULcL3OATcF6fziysTQEbnbylRCRp/6L1n/9nCq5nAjsNG6XCU6znIF9IIarOGMeo6/C2r1RgPKBwl171aPWDbVF49+XyTqzzKhw4AO1laa7EUDoCnUMX9Tmjhco8c9dGlzomHzMbY1vhbjWoEhgUFm6vaSp15HMO520ExIYMStJzp0UFAqmotzga3LKrgvr5/e/aK5Py+RDNTD7uWrLKKGEXLnaZ2JywOt7mQ22zaZlCFslC5ZuvVdaYLUz26tfDMxg6lFR4LMhG+3SOeliGd2TTuCmkBQy3b0GtU80C8wwHNPl8mRALBdg3xy9N86AFe28zkVXr/8+EH8ej3cr/NZFE0+i05qoSYUMaWXgSMsdgX4YxiWOsXgPhSKgvOYbbdiHF5w7Xtr9ewwuZ4cPjjO+k6p29ap91zNHOlZ5B0YUZyewTO6EVDFqCPway2zB+D0jtKMTex6Pxff1Oyb3NCmVhQIJ8NaycOhEUO/PLhWg/IOoAp8P/ggqIqynMYEIoaQlkngQVPgKfCPzFpDaA69VkE5H+ryVGwsosDTsuuIr7YFT5DP23sJ1P9S9UMKzrl+h/qO+MDu8N8z4BzV7n1TJHhETrp/c3d4vMGRJL3pLryWGchNJBSgC4LB+qkXbLzjkzz8y4A8Vw+QOFYHSY9PeFA9RMUZigzWEs9gnbbjHjf+dcEC+GBUSai1gLe4SFbBEKqvdqi+3yibZfcc7Vr3DqOLCVen+6RLK31iFoPhYEOGRoIrxTAhKCPlHU5RsoAQ+1ROdjXR+gf/Y36V9aGQQiU9AXMbEk/MeJBjP2QeXG8Qo3XC9g75OwYonJivDqj2u143Fuqm+QsKJnWS+TpIpZmATkGKkgDiD0cUxNj/tE1tG0OD//9poPBhpCRkVwH4oDx9N2n8UKW4/gZTI4ogJO+jxyR5UbhkkrY+yPqZ3A4x7bJuEPXn5BqxcP3L4v26YDShj9gpuWJ5KAj9MGxOvr/ACfYWuq6AqiFIwyfQdviH9zw1DHXiUK/uiKMWO4uiYrXVw0dZFd3Now4xfE3R9K1/I/JqANrdecKXm6dw23ghziIV8tjSQNf81hiPXIfTK49YirEkEo7/9vPicY9OenepeYgzz8ESIXoexPw7Z/+nU02UKu9NjvSQnVGTHutBc/oD5NkFxwePH+hKHKgKC9yY4AjtaVWvh33wRnBnGKfBIEwem05OTClddJVpBsoXLhnSGvp5wxvbIpOf3twr56cz6tSoHaX2uOoR3VPdn8f2gpfd28vAxthaAn3MBAFoNItjTmx7HE5qMoIEGCVSuxYeFg/PNDo/58J0pTrRQlb4Ch8miHg5xUsjmTRMyGIxRvCeJAeZKJcdWlw22GpWqkQfyyy6mu3kdoLjfFq13ncGLGhWl/xc+PQWIflKtmlNktXP4aM7aL4fkYVPUjTqGp/tad9rjXLLEVXpUSCeRckrN8AR31S4EJiFimvlrgHznQyT8P3lgKQB9Nu1hOOXzD4QhReCri8h5t3vN3/9zebwdF57WwwWXUBwsb0MRXpg10uiFtzyCadjCsxvtpqI+mxxtHUtz8jRAdP0CsHpGDrBsiN0NTRfZZ29fgscXHygdzooJdxIjb8+0U5fAgiCiHs5j3/FVYtQ+emfAY8CnmpUIbaDzsrzK1q6cKa6C98C+2rZJIPy5iocF95/SwOylItvn+NJHjQUCEFGqVt7+26CwVe9o/N/Z2ChogW7A3pu7wZiJfZ5f24byJe3PG8CDj4pw/0Uqe7l+pMb9F6jaoiRnh3oJhx6WY7noXy+T0QKJuirB5n9pk/WZJwr0awTOygmiwtk1YStrXH1xyDs6YGn/5pPCtQ6vlPRt0aFhdVwZGnmDBSdC4s9db/G/P8YuvMjyy041cVzNE+wEKDcNRnGQZl39WOan9gluywMSi0VGhzQJLTT4w9wI6M5t0LWc/5pdWXl9Emp/rV43tEV/W30ngxxaNculu0UYnBJYMMPkZyKrjpXKLBcCOS3qTbYXLBKuvQM9vzqA/ks6MyOwqMe/w2HS0y+qicvppK/GWzaBuNbpNeGSj+0+4pagcMM8I+jAy6//hBLPaAZx+OujMlJ86jfNy3H6ZDZfIAlkoYDPWgT+/derFi+qZhZlo5LSXZ0QyMiRw0Q4Oyhquc+ovxf8xhTvjx+k9W66vrP27Io9z5UXwCIs1rjfRdvMP/ftEaY1hVA3FwVOtidV/tWmo8VKVStsVelxJg7xNl3yY1PoLyRdoZPEQi7t+rPV61MYQTKGBkdSYsz1oAJufMmL5CYz3nYq001zaisIRnTqjxklnlCZdnJfj1w2YNPFgnoFrR0X2qFjNV2In2PWEvZNVu+6gVdIJ3fzkVhCKY04PskIVvY3mfvOiPc6jZKHbntg8kb6U+R+f9uwOt6XPqqAONtD0Er9zWGul0MowBStidfmuVto3hB2qdzvfXI3iNQRwrs1BD770jW33EOKicgR8FvOlODMb1U81Ag6PTgBoGtIb0fhLcTdM+uuaQiHo/Gh6pgwxOODGj+rUhhFN/jB6R2Ogc6dgMv5D4VAOeAmlgKO2bfRmffDLOLs49Cito/TN+v8zKMHkIeiFpp1t2bLN1n5/3DxaG86Xa51mYppERGhV/KVQ/pnKrOeT4WSPYoeTETlCubXORyTO/2khifPLDxeYIRsPUyGeZAM1INyhNAf7S4Tvi58xBU5eHDfaBSjFjTKAGigutpIkxoekXK72ntiCgN5L4gVDZ4AOO3kSudp8MFuF7TtcC31g6GQE9r2WE7NqDrvqyO2WDyw4+bTOtBRupuEXnttl6m9lkrH1lkSs6oNUURfgjHVengfvLUmAVB+iFqYG2bMmtBQjE0UCByymSAYUpP6hMJvIDjZ1R6sTnZKGL+OqmeZPTy1GU0CFcI3FlJhfv1ScpEATHSI9Qs3UxX9iobBIJeZWBn02PuGkiahWe+/7H6+LD7lv8J30eB1PbXbhWk+fhkLOv+GE06fe8C+N25t0FZyqG4wdNztt2aesbOucVvytSpbYWqcxBg03UHQaExEe/ArGJm1lDkHL9jIwg7MZoljU3vk8hUd+LgKkzI2xJpRK1hv3m44lgKgXo8IQn/eFkrVNp69MaLAT8Ug6Kiojyl4lvk5Xj5jp45+SSqCwEK8fZFnlHLTt8VqXBgFzTZlCHXf9nj30/0lRzp4Cd8BnG0lrKaPxZ53kgkAhPf50BXb0OhTz6rPOiDM8IfA/19Qh9iuRBakzhwrhwhVBQfwcrpU+ZS84WOFw+y29fIEutY9WtTJjv4O0y5MvzPN6eZcaT1bNkWB+KCri7vLWrk+56T1PDObCBrylztSW1P1McIGRUmV1oCGTRX0Y856XnZjuZwd1YoVfwvUifJyIDdShu3LxqrD/jH+AjZDKqQfVDUbpnp+cKXGL1h9fEZqOE+lmrVVIalGB4qnZXLt/Sz0PIEycNtAW2NvEbEOcwKigxi86yYxfJkCvGxNDZNuiOSqiXENEY0wlMjTi6t9k97PdxUte4mSuDVzaSfe+xt+w54Ru5MaiRsLsfwH+5XxI00m9+VZF85/BWPqBFsQdMPIai1zTImgSigvOxiOkunEcGqHWPjFvpasAmlEfC8Hk9C7HsJlifItF2QtkCt3vaIlycKk6ycShWQcZ4S7QceQXgyr7wPUjNEpLnO9ME58bWA9OOQcTtD1Hb4+vS5jJpn69jPYsAs2F3HUyZdTYaCsel5NF9SMkyZ1aWHcR3g73YaSEcLVFD03e53d0NNxUz3Ku2m/7cTsvNRsAPppXgzCvf4qp0T2HWytH3oMTVY/eV7u+FcJGvxSpR6vxbESlTwyVhGnyPIJbyGVahV5dMRj+b6LvO5fOct9DVYNLHr9ZqAfZN5mahxVLE/bycinTTKLBvxG7IvxYaH7mJGsu7L0ghF1vz6nWrDjust69HRoCGp7O9t6epxe5VWh7K7CcLA5M6dyfXZQncHAdqyEaTDKRVjlYaouSv0Z1SguDHL4P9/0cwJj2decT/4KuTSt3jl84NMbeVjJAC7SZflEdchv5OBUV0p8KbHwunXG7tBGhUTjwkq/bF1f8b9VPedsTibFaDZU6xqzUD9URjTMX4Pd5Lc+gCPkNLncRWfTsZVa4R37TPdumCdp1xUAHOxQoxc7cQpD28vc/4m1AZIMEj28cET9QDhTwFMfi7tpb1wZRt3WWgyB9TTdZvu8/LQB2qFriRFC0WYozeB9a4VvS5pkfqmF/BxtAScNhqn0cYWWZM33EP71YqDkjJknmApA/6x16/wgQuE0GmPjKPGR/3Nrsg072dRYsZm4C0fZRRLj9xBIeCJcUwjU0wOQXilerVRJ2OwoB3VQUHTK6u26ZxhHBmrInp/DnbyyHMcVjQjcGYAhpN/YStgrMmdkx6VEiOOb5Dg28ht2SojZmVi/SCBzKq4J4pUwc0swNQH5Wdg+2pIWZmqnLknOGE2pb0bLHIKYSdHJ8GA+cygQ50VwL4pqTDrHb+Q7PtykVpxxqzbVscDW5wqFMlWxmoRQOhulRHEBRNtnkK30k2/C1r2IWCj5FIlUHX3z7guTTEMLbdDdJJbPVqiTOdrOyr/eKmFcZlXuRXWEs89OtEraU27KULFZapOKtWDHsusJMYplXZqFKBjioeLAueenIdJoJX8iFtmpkmE0hdV/UMKKbrPZ7fI6SPFAoUsWUaU6FvQPUXwTTewCNJAp+sU8paIdxCgYZrnfGIX+PWZyxCBUPC1ai12GPwc64tFRgPLWm3mL4naf5LK6id0Nt1NWrFRzLS4xVSzbe0X624AQyCF1lunta8PtFXr0HXhrILgveno7SViXAgeJTpF8DuPJl3G2tykoC9McmMUfjn0YusuRpSgtBDsUSXyzRsifP16oeWIUnfeVwNVtGKuXcyuUayL+f5QVIouva9dekCT2lJj0vtBW/XAAS+BfWNecsdOjYRcn9i8re1ex8l5zp4e8yjNF5VWrpYAt67MhtWI6/kEqS51UN8ajjANYXICfpzNQBGy4TOLaSf+LlfW50sd3fu9FAirn7y5FeNFNwzFrp4hYwXkdNw0VlatMun4AQ7jR+zxkOSGMSoblOr6VFd/CnkZt7eRE5pgUedd9yVa6i8TROdWyf33Kkvc+u4T+1p5qSxqE6H9i7m5jd+lw/mfl24G36nKCBFOb5cmbgbBpL8316GRkTwoUO7sjWhoJDdrDDm6z/RVImQJKbQNBkW8M+E5gLg8hVR02VCF1JfjOxP7bMFv4aOXklbwEfwcxjnLbM31Y4qAc5muEvNUdCAUbk7MXrYeViebYXivhDkzGFgyT0yqa5KBsg4pfq+o26tQIVR7mUcx3WkxK1F+c7CWhPOgoBxubAxFhh/xPXygfAzQdSLKSe14zWVnKORyIvHe2iNNdlZG+UMEp/ao9llTDKNNSc+Ouo8uD7rSjE4kyMftwB1dbS51oaq8z6mkkCAI01i/xTrk2dFete1jOeMdVDRc3wxc+JW8PEqhwlSFKFZnJejJFXT63v97ply9K61ur8mQjfjuAX0tzEuz7IGkKU42WKDznDRPzaVsrNVURe8MUbd6ekmX2+HxBKD/Q3Pdbw7LhxfJUYl6RclOC3FESXkCzTdQ91kxv2MY6nmZ66QL7QnPr0VFPDVYIwfNhn8UzP0WDItr4tZSI8GoYXyUrTU12A+oFtqA4dUFw/Tn8rkveEQVzKpNnorf5kF8H5F3z1VMxsl1PNFzS9B0uua4CvmGXhhS7839sWIjaJKI1WWAivmb2KDFJZJtRUCe8EY/IPIlpk2s0nsr4MQOZxJMEWn/XhPoY4fkSa36mU3h9EyAK5aBwKiRfg03DlYV3Twhw4x9jgNIcM1ZL7mNAu/JprX9v62smzmRQjoqKZWVGZoGpaSn6YeM2gdYbgCz4+nq+9R7B6PyqniZhgn+xNSgDnz52X6NZouc4rwKI/h/z329tCZfZYjyieDwsczZxF0vZ6p50ylDimv/HEzS1r7FmFwh0S0B+r16uWsZOjt+nVT4Y5aRe3YHeeL73tod5EPLUKkgpMtJfPAuCi0oLUhofH1gbQDMRowXr+VGxudSU+cm2BE5H3bFxY4eXaiceH/X9EGLAkvdiCDpySQAvIdcC8iX6z6WLd9biFdmk8+dAgrF2cVS5hnTnme4YGGO/iXtByEHX1wFB5zUWAaob4n68694ON1GBBUCi9TKu60iUlGeg/RYbhXIyOOtmNGOsYpi8FamSHUEI4wBpS7ojwZitJINNTmnMywQfyZ0G0Jb+P3j3RcUrE5XPjQPIbZvrKRSr6CAWLGheKnCCbQ8O0+FlYKW1ORzCfIQlEx50dj+XJBiA89BB29XW/369WM2eIRoJh1gqHloNrAhrpwbvn+mznv+JpiGmTBC3y0gGb9bR7KJmnSpvSNAUJtJ/CLo4z/Z6PvMFlCnbzvYRBURHtQvB62NForr0cuh4HyEomvgkTGqlP+xVcl3wd5H/Ckzo/7uAIwOu0fZrKQs5WBl22N6jQrMBfoQhMIM8QshE8DwHDGXIRMEkD8UfrYY6RPiQTdyEFHuiEyyV35ybgGKBALRIP9AoAIl1Z91nczPWYG9WfyIiUAZKrlVD5C8IomOoWvE0H+M6OzB2ylRYRk3vMjERYh9sujnO3yI9/Zkz2lYup/dbQyZ6HD8rnMq0je4eHLwbOusFDSvIjqXKwXLNNImdgDbMHu28Q9m2RNuV4J725DjZb/gTvg/4Lii8bry3qW09Rt6T0sp8crOJ9Q7a4MAKgGXMkXrsaYJUCURAl9YqPq/uELxPDnkYnuAfDU7UOmSdheJZsvxGXi9pnJpd0/DKHirGzqIREz/95IQjQhD+LH6/JB4creDZ/i8wyqeZg9gADIVUFmQs5q+jD4BUJAGi1Ks37u9C58nfYQKvTBuXZ0ycfjEUis2Jk8V0KkgKir0u7sYv/XhqPcJSzFD+mVyKSrgryNbUlC+XyWGXjUR0d2u2w3uEmw7ZIZJGc50YPZU8kFGNoKLfNDSW/D7cwxUd+dYBlAVtyxbonyB4261vI/csP3kTeotRZzVDq7fmEJG0IFMK0Tct77k7AjCfGHFb/8/LCi+VoDDzg6Qv/HQg5hJ5+pakOEznkFiFhmtEg99tiA1mQuacMnLZGjS6CjHX4E6hjlnsUjsfAGXXTAP1Z4seNmJi4I9BxLMg6DQsdT1P2APdT7nFoghTFQ9yUTrOqBJcHZVYS+sj9YxEKb4K4IeZn3YmlBxLo9DeO3+Tb5Om8dNELQAwOxYFyi6zq301fTLDj7LHnpXQcDrSBACiVUnbpgSZ2qHIdOWxuq+ne91FEKTkdpW6m20Fg5nMx9wQJE2USknu24nL9pLtKbiPjKNyX1vO33ouTDayXc3rHe5NA/y/I1R+AQQlnfZIpvj4Y64Ed6t1esy0V4wo97x2ND5KNvXyviCZ7itwC2UCXaBw/ZbQcYacBfA2m4Hlj0Ky8lhXVpNd+gEZMu8GXkd9dRSZuyKeGZBBR2h/QHqAuJSLPrp/Plyo5oHsidKZwypK/ApsfoV6mJiwba113ziWwWqpVPpy6Qg5hJWuooM4eUHFql+2WSOA0tOZYHz0cVVXZXf8OxH+lENKMfafwpOg2uIS58r+GFOduAPxTWGsKELpZLtqqXs61pjN+LrHNM8oHziZdnbV4NoPxB2qoHaB/LKyVCA8V/a6XFIktEvSRjTFxp11PPTDuxdalsjcAVbAzdJwRSHIjugxXRX+Zk0fOA/Bo8FU7HAcb/mW/TuxexWm1vQ5hBFWCP2zJUcd5Wmma/Mt4mXPo8/W/mNxmNFMM1r15Ws0PjRU8XC8HTAf7Hm6HH01HxOH0BPMtoXRkOyMRGf1dpKYrhXNJQoZ+9RO1evi1I3xpbr4VBi415VyJs7+sxPMvp1h5W6yMWVNyX6wvkQJE8SJfGb85eRt753E2zZs7+YjkdXaGJ5o/WaWAXcf8EXMADPpVsgaL1CcWpjc6CK1EVWjRlECvAwarbyzlZ2UVrpHVDbXZWYs3RjLE6fucFt7wp43KrcP93a8ypMuhPhxQKDP3C7ciipG69evbt6iaRzMpTGUwmdPDW1S23/xZF7H61iqKAFWxduG62weyHI8CfrDnv94uCwpWh5bHfiaelxpvfP94N85KFN1xjX69qf5pCKm7QjHQ7AoCqR9dX8D9za2NTrEnH+FOi1yhOhc1pZ9wdSpaBNAAPv2hbQrpEdcXEsUcCjYb+mpWd3GWO1Eut9jf93XB09xDluzwWNFK7cJQB/Xewu22XuqJeBoRtPh9DP9pG4mvhRvMkoq2kaH8WUoE5f3BUfri+Y840DPKQ5XJmi/OY3gy+0iFBhP7s2SiQNy+uVpKRY65ANebG8fSHcU7LDF/GZfDr5I1oZILkWw1t2joKlFog2ZaD57k0g0NbJ0OFHvXKfaYN0OKxVp5RYXLF/AwBRSfYYEnyBHAE2mQXT3MlbUWIcnZ+2SWpnKRxZXSpT8p8mdMcBgpQyeG7D4HzHSVfOxXuTXaB19I4O0V4D8yVbvkbu0p8v5F1dpAGdhKKDn1RQAEubUt5vDIeUNBjzg+H/yb9Fdibi6l2ZqeB+vBuC4GonOTIc6t4b/id94Y9fsr9yAfOF0RVqTl7kofKYJe45tgPqnA2IsWVTzJYlfhKvSS6bEC0CxFOJ6TKD/FLWcEQ/lX2UWdE53q0lWF41HkipW9s1j/9WU+/cujeNWBrSukKX2DKs2DQvKQ0PB4AiDtWi03VWWopVYb9wRJPGU+LbrSVIAtXOVx+Y1LaKRMJSsJTbn0y+cOI8PbPnCW3kEX0SgwgNfAxRgQQXM1+1LQ51ICiG9tSFVydhnMEPJU0mL7A64hOXKT+il00bY5TMwgnE6Z8Fb6jRF9CNRs6G6DP7/P5QCpnWzy+8nVV8wLmL9/zY6waSUmsKdkANhyisi1IH1tQWwe+BphLAq+Wp85RB5Kr0cIEUi4sQMkTBE4FCYAGhxtLjdLDvwZh1T5g5QVDxYArJwxpKIAea9jG9WQf9ZpIT8khD3rc0oa9rgzQ3RrYfVdnDFQeqJL/a+kCIA90VqmXQNxC+utoBU54P8d2ohpuKTAp8jd1lXEtJk/6gRsix9R9aTrhH9KlXHZXEzUGxlFx3H0AxSDECTKyjQ/BpnlQSwHFiNspR6A/Ql3a+f9tM8liMKcb9hymOymtu0dueY7wpm+6lr45BogSsuPRkeRRVsf9TT+PqF8aBzJA19tbswPZLLr0/1AMZuGQUjUMKxHdBGEFi8Driaf3EwuJOJRQVsy466H2oQkFvQ0Hof5VJUwELbiWYxUIa0GA39EzyWscg58P3Uvf5SLeWBPDQLIhCbpZQd+nvYEq4T+/NgHSeazLmRzKBSkQPCqX9Z9mA79c8E2zPeMGlVkijAIPwNTMrA8uYbtT8XksTe3fJ34LHeEo0vtvBXqX2d9UqNusv4IRJKqkHqTTW4AO0j8Ps/5f+vmk90U2HHU7YZT6ke8G2DJ2ZVRrZ4Qiuf32NdPUpk+a/Jm4l5NoPY1tmq5qCE2LrflCDfS51FlDX/tFn0F6gwIJHJdmX6ukChWHRnD2ugXY/IFjCbU+Orgmgwkaaew31NuPnUxomvhkaC0sppo/sVVl2knTFrbDMhi4mz8vPcHVcIU0I2/gMLtjRlb5Cc4x8nRF5aJgyGgMkfjpI91BqIGe7Ux7qHBBdjPyCBsgcpFPjgZusSdXsddrsjCKGrt/KGGJn8VcL97SZMiTlCLyQmZINpokp4M15+IaWOQaenLXKl0dXZNpcgbor2qw0X6QFAOAZ2H38oKBuCIgVNt/hw07B+OPvIpGmNUKGIskIxzyIhYARBfWK59pEy18HznCP846VjQhZcyA97zxDUAgOy43bF6OQTwklTBW+uZrQPf4yyPMU188ekyahvoc81Et/pDjsN3xbcbWzMUXyWjvs/rhKLv/DD3agZwUhSXmolgh5vQrMMIYjz6QmcIZvrfSVL0ZhVQdC0Gu6eu1XYRi3mHKV6gJ6b0TmgpKuO+JuEvA1GxAlFo3v4hYbde/sxsyJfBFRTiQcRkRXfNVBmuRvXwxwb7GXD/L4+Ysfsb4zHrQlGJD2bgNarIwqEK7m29jBqfm7M6juhKK1PJMWwbc7tq5gaQ+834fpIbEt21nMrdMXKehivVBeX2dLRNYKu9CL0WdKw0DhvV4HHL3GrfgCvOzTEZRC8AhweNX3vggioW+JNoAQ9dY+Ob2S1q0Gf1TWCLyNoP3x1hRtVXIRskK/JyJ2fJiy3M9qB7oP0eEv7AtwpmPP17f/JsHfPvUul/XXgEW15fzSOxNlsC9/Ra4Uc3Nopbytb9UNmOwJgUYGqcSIUhMZXSos4MYmsnb0h9dNhqtCd9BQXSm5BkbfV7Pu1a4fYyyVHnrschKIEjUGIeczG9/RiLtswgjqW0SAo53QEplu5yU9/HviSPT2F3GZvz+jewgAh8XqsKtEWccHItb2P7C659EVj85CuZrRjD+xsvM2KNFcPemQSMjTmFmas6f7RCBK0OJ1GbKnFUiZjG2ZcNvDMFXlH+2hZ3hvrOOqXJN9bd8NlNdKPh8YgDZbCVYaivhnqhcwn0QOkqzaeOcQNMvbmz+q40n5V4nBGc8q9LhLj5MPXrx66tUeL0Km7HvoDT4gP5ZixCGz1urNmm7V8S74pSrTsjFTbH47fH2pUc4SQ1/oQx6pMm1l2CghAib6UKEH9C8YE1q6KmZsGdsQygQFZviet83yoBFs76cCLuiPeRxJuqbhuKMe3tnsqpuQFxcCRepLCgN9RliLFynwU6b3aIcWH/SFn+JvUU4NsScR/bmGYfy/OJJhMCyxzY5iHvRjt2x3/fQUxC3qA2vpxu05fxeOJnuJy0aRIDXOdXcVOFByDgQp9eAjKaCgMF3Va1vsqjil43ohmnNORbqHy6tCrrquc61uLYKUp1jg+OTSi7XPLKK9AHPOl0lK4isp544W4h1gYnwLBLVtFWvvvCToYkjPIgm7V2MfF8145imgiYcZWrfv2jmGLueYPsaBwge7O3I0D3Z5bS1xDXtOlAgWrfyPCHGfuBjT7d2qEshw0+PzrlJ3wvV5owc5LX7TLNJI3vPf5uFI3U9hi/S3HbYxIq4W3AnVm/312X+UuYqPQH1P5x5ybBeU0EayqUHNmjjp4zwLQqsKGkpbMwnrmnfBF8UVubZFbUzjSRHR9yCdfos443mEbKMPNkfUxpBAGVi1X0dey2lDVSur95uIkGGlattA/DQ5pxECiFStr8Y+xsnhro/G+fmxopZSCtDqatYJ+dQRCW6JkAIQtdmkAgaSsJx4GMswPTYwyF7vWafYyw8QZfguPIiQ0ry9CNrtcB/Mno9054NprLWRkk5IMKduDL1JhC7c3jF3VMkyIyoZDdI3zg+H1U4oX4Sd385Ig+mdvoQ2mQOBTtZiB4d/RIFtnA19oxCIHVU5iXOKriaFt1mt0EmvmRPRX6U9YeTO80oSUAOgZsECFsXCboUkSGu3hvl2eqtswz7tIusTKWUlHwkECQ4+krpET/3iYa7uLgmuZOZK9fjp5lRZaDYPS8ieyhI88dPTJ4G/rr07mS9AzihVzGXOziRe4KDqoNOW2DXcHv7JQqeB8NQNp8Gqur5zPobhoO1ZbkhrMfGtZBl39qVhOxyCIriUcCIXfAWMMIDb22LT+Ksd9MOXz+nN4b1+dSIcuojQgm18l+wHxtRufjO6yaAm+oO+yu/Cb2up7Bk2FIFQkDAD9MmUAdkiJP9SSvI3SiwCtRl2hkTR8UrtbVT7ipmtaNZhZInKBrmkN9qYp5jcAGgwIfK8XbvYmwryVxvh4kycLwT4MxjXSPPCwKlIze9YHPYDkPE++JaRbxheEtMGzOU1EUSYHxzrjVFjrA40lPsp2yzdo2wChyeRMM19w3Y4RDzZBguZ839vd/rQAKLxwUaU4y9mJSuhcDusCa5A4sDn9Z1K4bBK+EV6ETmsD2NdtkJanAtSgBKZIkdwXR0rFJV1R3KS8CFjZUHv3044TvIsFNQ2AyNYxRg+nvQyxCT1RTkcLvFvzZnB+DQBlFSVuodUR6TJOk50a9M1koopBO8qg5QuL4fPH4UOpuTdlAZExh/nOq+XAp90xjy+8R02dnPANzuPehWRdWjL1C3AE09+B7x0WhdxPyBP8Gl9S01rDQFq2YxkZW+qKObDp7Je4m5aGQNKmAwM8R8aIw1VLZKDymhNE4/31tL+fWEJfayi7Ajs/yvLVsa7j/n2IFkgGATMPPnLTNrUqej7net8qDZmLWSf20Bxf4SlCjTvUcKUQ3xTBJghZmnF2kbo9Ygd+er4cYMZS1r72xhjyAVe2d+9zbcrkTT+Be0Df7J+CkJ0Fp7Dn5AkD7E0/xJntal//JlJxea1NUhaW4UY7QU5+oN7NUwuAd9vZrg/RvqzRUJM2fny1fRcAM7q+yC65Huc4VVArhSWwXk947AwvYDs1Tknz2AoiDlw/pR6n80MW5tO0qAAqMYca6tErVD9XwgFRGcyeeJZL97xKuHGoif6LAzaZPD3bhrBg+l4cq9gHzZnvxUi0U8tuuNJDIqfwAFHtAA2z1qeYVSBL7mlW/i11erLyiAnWDilZuxqCh1Dowmtnro+E2eKcGc321tDe42xA+y+8bsYdUg27oF+9pHMoqJltn6PB8kEj3z8p1E2bTK5baZDbKzKC09hcUqFMtATgiHRivb2ETsjaZVhzE8AZxEkGuxLYMCNA5so77TZ00tU2B/5cyCrZXyxH4+Jxs0N1ueYbldIeGIzQOcJi2UqrcuSOmNUanz9v98hOemLA9MzehENpc+dotlE49+FIZGpv5aZZIk6YzFeQ1+GPlLzUOzZpe8XVdauOFtlLdAuA/wgzouxx161dFU+Zpddz8v0okrfnFp+3oWXRVqYbsyXGZqWhUYCDRuJIIFVkFprCwUR1dw1WkeQIMf50eeEIwK6+O6FkYUpJA/688WWKeXYU2P9iJszCXxjR4jQWFKbzVL+Az3gDTjHPKkoxIW6h9cVImVS/yMUwH2WR/VSjYkJ48SweyMNi8C1p7xOuMKbfIemI08z1v/UMkq2Dzw7AVncf27rNrs5/Q/rlFPtw1ncZ4pFCk8DxuQmYXMvNbu/YCyXOX9/rqpTnrQMImCstlp2FQpUws4bo6rmlD9ullX4HAy6lvBGzMVvqHb+dZPtWDSKLK7IaQeyn23+jA/PBbGGKi9GIGMVpfDIrInuPHGkm6nti8DRUhStUHJQi8OXiZsqdn+iicRNHPKWZEwVfX4y0cd23OmfsYvkSkYf0E8wDxLJI00s/hxAGaSMuuCMqTocm07bdGajgGzxxVtB5eKrd+90Ryta7Tb8VZ8V+LgX7bzbZH8wMT8mUZu1GuHYJDhapGj3NN33GT2QILROoLHobB2ORO6ANwrJue0De/Ew+VHYrtJwhua8E6UZIqQKgIohbAlgiOe4ER3yzEtHGjT79bYtLNHhfSJqO/dyS06zmI2yh302+ualxvFfJmOARJer+45N92sew6L5rK/hKg2ohFTKaAzytbrBOLAZRli2lVlPsNQL3avPYLbrGlVPjga7aK9rKJ/FtzilLY1Pmn3CmJ4b9oqmuSclb7aW6nfWqRCdi4Lrx+R+3U4A8+okf2lq/G9fZwtAN0GMD9JSyJKJ6g7a+xT1G/jhWG5w/Z2AgqByS3tURkrVmI33swQ4vfz88xFrrPqB2djCn/NY6V6snp7YhXk6um7Z7uF6nnQogi7gQdIAbpXdpqnVw82OME6QwcwhKulbI5ZkekFwK59H5c88/uwMO+7w3G7ij1exQkHQK3qPqZQHYIHrVWBJd3BKLnH75qtc62IOtnYAorF/zy0za2alU3XWL3R+h03Pri+gRFTiCklKfoz0+TnInAAbdCBIp3Ztk2XccU+5oncakjg5DIY2pkEMagzovCJrwo4O2wLziSprXNGKyU0BHdnID8YT+WPxvj0mqBORAkS1alIjWFel1czwtcFhdwG2q+FtAyOzvlJPE9YeXrikpSp06qBCkkL12aslEtwxl4Kaowxtg40QiVS7UnjPFmf6wiuFsdOJS4S4TR1jNYkXMUIq1nQPOVaNQjVtv14s5CzmAcIJ1OAGH5FTfuFUIYuwzXxuS/glGkPGjgQNqaghanGz4smftUuk64VlqgDfqdtPzRg/MhpWCi6GEkMNuGwdU+40koM6ce/4hQzGot5LGdNLQlVlGPVkhXKLm51Dilh1X86ev/dzIA3QiqF1DLCURv1AdW4MPObGlhmGgGrR+1oXvlVjElv2K88xya/3Hy3UdzVMQawOiFXlYmjmCecrdiVpjiZjvR9rudm6CrepdZ5qFq3WmwfLj9Bfth7JbqJo4wuNO+qoJLeFgtILmhZq4M4NKJ3LB+15WmLibBfJTIONd0L/cl46nn6vHDcGcTgRRDCsJsQkfMZcK2DsMgaK40JmZFlR7gK6VcpOnIfMhr9om3Q2NG3EAWymQnYv5gK2gUClLQsIhfvDY4zjotVlYRyZ2Dw9RiRyqM7L+t+98+4O18PeCD6xB0QkkGKKV2lq8Ox5Nb1StNnZRaOahHm7slO0GFa36hblBbHF83XlLC6NOZzZFvoOOEO0k1um2+p93CHJuw82vQqoJtB3xQsfPpU860juk6k+Mq2iVsIysGzOi61v2w276+z1Xm0DPUCXbyAIq6/DOwMIaSc7HmRKSqlXhmsi0K7zRfufS69nN8Qf5vfmt/5IoEHv1BQbe878QZUX92yzd/IGhJbsLJRjRuzgul7XO5KaICKBrPJJF0C0X5RdzIWzbuMMtmgYZIvpSmkCyXcB4B/B5D+FkssJsvNgiDb68Igxfu1OHEq92UPfqccao2UNUzgkTJtGnUYd+tZF3KaMNRT1CHzqsGRkWUd2HzBz/615xq+XmUt2f41pQ9WEjxz8UMCCnCoRzVUX8bJfB9HSiAIOBdTxHuM303J6X9tW15HIc8CmpmeHBfyq+AgbCWAPlu7G6EvyvwyhON2oE3vR4xwfcLYgWXEut7SUnN7AC2cCbqHvBETsXr4XMC/DOGB3qGTV+y2Ba+XC24lwlXbj1Er/dCm6WKmgNtn3/hVOFrN6y0NhzSY+A72HPKG9sP5Gf5F+gTj0UFvLFFyoJWN8isvLeNVEccZf/xbUqlPvz3uN7kjIBkdqzwG4dd3R3QCxUL1cMrJzoyW++ZESbzmkEWk/4Bma2VCOTlUqNpaMx1xNQCsvDLQ0OG9ku1gE7pbom3n7tGSR7KHLkDOGbetI05bpdOqetAFswWpaMDgWKuJyIgY1/OHmIlSCXywPqWuoZwjlnQxeOVRPSUr91YQOo6kye6Bs0IxKQc+oeJpTiXA7xLrW5xoB912sGMj3wxiPbb9kEcp8L5Cz4vTtSgBUEjXGIE/aa/SiHwdiu//cTNBiOQuSgPI7YjGmbU3EJBoCniLkUojKFlh6HLqZpKNmzM4apEAa8Z7u3uOT6UnT2l5S4bnyfGVTFDSjLLmDJeaJ2tLy5o5qte6WHbXhIdC51iJGV3KwleI5sS9qkFbD6m3Hf/uiJ5cekcM7XfniovwbjOGkEzRXRUeJz9IwRuxvrnHNTuN5RHFOD/SS4oZVNgGe+d/B66TpEs5wRbnJCz0KGpxeV3YZtxTijFTqiAlE2ZyaFnL4SvvXRklbiFJ1lHkO1kdjmlAgw9+Iq/3d8UdmScHp4ijm3JuQId0A4+gZZWMr3ASpwGAYsVg+4izot+/P2aZGr4hv5WqYYZCagcM+2Rx+wOfkeNc95gIrmEl4XXvI7R621YUe/w5pyJuMDj3J2jOqjImKdAm45b0HFLDzB2qDn10QRY+FxdYycUis7MHfT6fZDRRHFIfLJ3AwqYowcehxAST+gqD98s+lVO4CU46BYkfOGgmr3fHLn1moturnXlmRDKKD2uTkqUeyKf9SQlSn2698vPAs+JbSCqTHmurMdOtgbCHZtLxtQVNsfHC76G8Cl1Miv0rR9NjdKR5Sfu8LL8wzGuotwWKrwvuPcO06fBs2b9dIXHS46n+7nsPjEqrGYP0uqU6SQXiPLNfmJtP6f0e0DhH/vROG3TPR57BVPF800KGuUOencSV/Cvq6iUl5REs9R6xGe1pYdfrFNWqWM/Rn5yWWNRhfVxSuBCYSpwQNxcwkS1nb29BUx3Lz/5vm631/sTWqRfd2Q55PFo3UCy/m4KHznEuNm7EAlLiR5fV8hTzevmCYjvsD5TlfLSwEztHBYyTbXRQc+1hx6SvxXQso1OQ+4ltIbMDm5ugPFnvAoO7ekl4+IhuVEQ9zWXneHECevUYBcQnd4bNWfTdk5j0uCILU/2uiepsjcgZZQ6DRUpWJ5PkzuNYLccm2dNX8FXnQzW8iLkt9fxnL+oZBOdygW9n4xokZ+XUm3NUxb7yci4S9uM8TFOsEfqE86rUrEsnIT8WUiLKZMCFQ6v7JYrFM+poQKuVhrUZ0vjehaWZHkaOQ4lq2OeSFDgjrJvXKV6Cl9CgKpYx36sk2+xD0abHA9fxMPtPh518xtDIpjnP/IjNIe8kX2ttNZjxlEmYw9pzKU/UiMRoiDoa1TuaefA2vP8xAnXiKfDd9Eppxq0FztMC3GmcxcPhT21Tvajr1GYQRZDHipYGBy8WuIhgBa4MCD87dQxNMycPOrd1rr7OcP4jWXnVkba7L9zdJT8PMvmkY+gzGV7iTc9O73uZGZZelHt1ef33Ih0NCKC91FDRKBrWyR+lun3ZUeKPLftbRzVLJ/TUxvS6xIMHXGX/X1aZp2ivDXeUQzqIP8Hta3QzhIu8G4gMdEgzI/mUj+a4EGsMYo3v7Fl4gMBZJf6TgY6OT8F5Gr9cVw1hpFOb9jUcqKkRmNG5YloGubRte0KQ7iWzQgxPtvzTHoyCzHjY9bmUorIRCHrnJ0by+QCpJAx0fVd00WHsDIwTwDq3kjedQr/mQDxscrKucgu4OALybhTEEoz0VJYBvzlIimt2lEAFJ0UBwfJL32SQs78jr5pwVKgjESE/LJqispIUH1V/mXjsw2wuSouaE+jw6uFIlZnIMYFA3BP5e1jZYAH3rheoy1zxfmzeeeSjiiMs5YbnrxcB7kjJtXHfpDJAn/rd/qZPMAWwILGAdxmekvOi+dTjwNxksuIVE40sKnJRPXIl0yQQqJiasOVMHZ8k715S9Ecmmwp3abcYfCsu0bXtq4IZiJoLuUy6+fPdacvxRskRjnTxCq+xkj63FYRgbeVRkNW8RrgzmXoJdcNF8MiUsWssTtp4PCtbhdBUD+ddLA6DweEbGxsRI71jtKL8f7MG0sxe+h1g1WD595qTsDv+msgY46xO84hBBFOuVrQVLrRiLWMH4JgClC+sxkKPgYdYtWxfKjGP/XftsK1psJSlkggDbhtb3j8r5sg77VP1tnWoPNDZszpyYiK1Eu42294DmfmQ/NButaB2cNDrUMjoQkTZ4MHXeAcY5GW9HKavgP0sWvI/0T68HKdNTIM0Lz1CfQasHYWQJBo4lw4XT9v+DuWv/QVQicpY+xd8KuSLPwEHOB1LTPpqHGmgCJZR3eOqlvbP3kwCYOBPM+2dOLse9qZyVi5DH+qKAU4N+erLvazd0/iJ70xfSnZnV9czVqcR0HpXfLMhsGgCOBI7WaGxDfTyg/sWGxIMYJWKA6acYw1GiWEuwozujRjeUtph94qCFclLjO7PMU8ZgOKlloRffIj7g/seJLztQmu6sua6+ghtIGlnyn+c4S2kfkTnt/RYBrEUTTnnci0LyE6/C8bnxauV4zXWrmgpRP2dNMXXHKQ81Pdm3d5cHMlMoXGV6h5VEcfdn6PmkbKQ9jIBXRvqfUbJVGV+ZZZ/R6CsA+GKF2AhlIW84YAND/tsU64huGSKbnX8yNtO6TpccTBimudw8vcYNRc0+yFbFxevN9cSkZkwLWdlrlvgasm/VdyFPtWTA8dl/ItTTsjWOImFHNZLWHbRu2Saq29s1mtZFePF8SJpyud2BWR69OeXZ6WzxowQvH/HKWZROXJzIw9Hf9+OibMpYopwcjx9fU92/3ZTW0TB2lY/LBQQrGP+worE7XCpP57ZdYGZ/5cbTqtcYwqhPK9zjc1t/4IUu3WFGQL4hFUVxiGvKygTl/T//p5vFoiMEna0ICrK2v8dCzFbRmHKGOiPKqbxlX+8WYUs5XNroNsP8RX5vHMrv5/82qQ9ULC7sakIz077jp+lCUuj1OBR8sKHkL+5Vjbkh8oLwArUi5NBgAIPpx9D23qEeTJC8ZGorOueuSsa25Wqhcm/c1gZuQLdEDUVwmyB2r3qSVetuhlL2GHrr5MACVTBCfXSF/Ri5tBjbnzN7T/FdNR1dWYj8I+iDKVQuw5/45SNvRybAHKaT3gBbCkkJcfSub715W7qHNb+9RzO6+MnTFbrPYa9P9+wCGDQuMGNK9kQAvOcalpa2LE6F4KuGo+XZZ8CHRRg291MGXM7ER9Eg+dDjb/Eb2rLNJcdv/oGx6ev8uVMV+nGvDw9rK8jaKjhB08PiQyAhxpg2Nv6VrB4B8NpoJh6z2fJUn6EFZDtsj9Rq2Ov6lk63lDOughJtIu/O51/GQP7ocqmaiBXWXBNrotnSM9mEyVGV0EOBRIXFJV8DP4jDz7LuWJeUNRsHECEAm8+jNy8w+jUUU1yFY2VtpW86lYr+9JjMVq68BK81ARljfyNAJe8ePB2CfN3RpuoO4+x6J9C0lwCuqIIb9CZiC3MFZ+T5lMLvUOy/daymJnNXgpO9H1mcPHjC1Iln1G+ck7svLvd6UNPRYtz5qNLoLTsd3C4XguBDZESo5Lb3JDdydFcg6XRzmw6f9Npe46fh3UymB7I4PiJkZ5jDsUNDT/+pkrVrciqL5oiYy5xUwc4VP/RVpxEiLRa9cOkGml7sFJ2EFX45BYHsqwW0P/9GRHEIoFDKKL1vvtr2ClLkXxtoRYwZ+3EJtwhjkJZkN5cfdUhtBXB4U3eJ7HU1Yf7/Ymc+SDAeAXUt9DF7AaZr/BeQQ/4b2cfJwHUGfxpSsLu01lXQr75HdMBtlTNF3tEbJY7gceGug9pc+z82OGpO8s0gw3mCrSsRfJmvyJWMuTSH2UDUMPT7ioNtuC3+/DbWD8K2vdwpshQMb6bAXmHSBaLLfIzHRWnM60gqybUIxTHMX8rDQOYzlSdzVi4unA6Anxld6LGPdpjd+xuCavv7x7D2RqK6xWFPwVQrBA4bER4DW10GQJM/OK3o1EpKzYA543t3J8nvGO4jj/Gs7CpIca+RPcG6lOWGi6j6FSt+3jdzQFcj+BLWHtrK715nJw4/BQg+T4ugs2/3Y+s8kUqZNRuznKQCirw0ONKrjDeRF6W2a09pOF6YZ8ruVrH/0GyV/b59EPJIAth5ILagPCy6CVy8Ric5XX18VbmkdXV5s586qZSBPdg5/Zkc3RsNuIBO11ZpTubCH9eni8YzrzoPMrz7iKjc+kE2KLnpMLjygh69tJGIp06vKf7uaYwTH3gg6LK4+QoOrsdUI4IFStWLRIGhs3o04aqe/i43IqPzS1FORKni2f+uhYyLjjZd2JP2pjtA8M51W1/4d4EtWIPe2/tgvAdN+f4fcm1r8yQ9fNNCBmdCpSiLmDv2ieYwh9at111Yx6QuP94I54IgYGUJ/YluuH9iL+UQdebWJtOVvdKuxjQ83FbVyPdBuQ8cTDDeAlTuSKltIvUouqfpoWHE/ZAvvUQRs8cRz7+q7lYRI3c6PBQ8lEOesFg+E66epdAk8N2lTrId+qlWaZ1ekuNznm3YpWQZ/OkNLjEkyKJ2W3MypYv4wutckUUI0nuMdAqEXuEDRZKa+TmTs/Kckk8A3XE9tf3yJ9Hfdih0muwt7OP/GOq+2y4yr6xkZyFr0ZqbG/RJmks31sOkMxWBSg5r6JfaphmTG1AFsVL2LQd3ha0NUOXZJXD/9sTc1SwIcYT/HoZPIzInxsZAvEK7+AjYN6Mk6VH2kD3OX9k1SPFluNB7FAofI2MdwlXkUkjK7BMHVTAV+fAZC+uk47fTCTiNK8oRO09fnMG0SggqJ3vDUXbNMHZoZNBLYZgOIWwvXUhVohZEA2sQAf3CtSghsmKFgFRNTaGvWHM3Fo/gHToNxJ088tXA/yU8Q9I1MDFPAxk2FqUqFh97Dq6iMJY9tI8K++Ljir7aPjPbczk+z6kbRnO6uSt+IHeBXNinVLnjyiOkHGZ4I6fKJT36ilERQMVFS0m+Q0M8yDSS+jDmkBVKHhduml6XtdLkF/CD7PCCU/AsTxh7Z45xTzQBIobXNZ6M6PqRxcEJRmP5FH9jYDaD2zoKCWRL4NPBQj4lldRdoWRhKT2V9tZIkrYlbWYRYf1INGeI8lYG0Ab0xSYQpmqTlUMg3R16PvuZiOMOrmen3OvWI9vqckXZhSD9KgezlDUpLiyNt2RvLhSp4D1GVcmWVxQuWbmIGfsnLY1vEU/FOcFWh/QwlLxE2AS0B+8pwmGEqAFqGuqt1rHCMasZMMAsxgc/KXYNff9TVFCVGiLkU3pXZXcjzpJ/8M0gkX1vCl6pn4mYBebXih+tMw9B/gQObkRPzDMyBwREOuUMypEumryanWPFephfG4AFk15fw4LcP6UMsYEBBw/wtYizQ+Y5DTzqf/SFQot03V1Jm3hpTuLZy/CyjsN4KCBOFurDpkMEPpkD8PLs+scAlBH4k20fbVLBPAwPYI7loRN1Oa1diXbKkZFAXpq2rzlRi7OqqrZN2IsyOnausKekle2DlrWWoyGpjGZX1kWnjsFbxArbI6KZgkkeFAtnZwwWzODxfBzQqT3rxNpH1xJ4Kuvl2hiXf2TYxiPwyJCiUi2u0STIk39EGCY4lCRuXUSs7DoY/61F399Y0BgOyrwt8PQEH0fBrkYjEpQv9OjF//XlD4LxZLj27vkaxtsYShMJduS4HLASu83pJG4I5r4zZB89fPA83xlXafILF17i6bxk4K/2ZWIE/DwcVCnHu8f1Y6wiw6b+t1v+XuKqWmAqn5P+l7ZZC5Bz7v56FLyEgTo0Wg4HgrNYEqYGmIjQqVgMwV0+bfE9V2CALlo9WWCchrBhBtpiMQeRaWwyv9eS4beLtSAqWywMp2z7lTUkwX0DBWx+plca7Y1v1xhZBFE9btfj2O7Mi7zbafPG7sg0OvH9qnN1dXVVdQ+KgxhLKFhkbE5gdhBXu+WU6892k7N88iL8WP5Aa6gokjR0M67iR4keFhyMsb4264gTefIXpMebJGUoJGedN7IfT7veGMnfdmwOzUEFITPcucUaG4RLE2h6EuiBcnPoPG03+3LAtw+euxy4h2eNiqMMrTMRsHW8XrxSKxTr2pumI0D5QgHvmvy9EsTViTVGZQ43NY/mjeebD4fbdd5fvxafK6njjrjEfG1g93HV5CrG4DnxC8AXgFKRsErys77GVr6Ip9zT1lzvGOQOEJjQQrwbmdZV6xDfEy9+iFH061Ao5DrveJFRR4Ja2aRIsUfcHTqPk4sP/x8aWxKjnaOtxwSHIbJTrCCVPwHNYVQopU22z1d6zcmhIPsK28orrzWzxejnCxdeABlFYknRxpRw2nVUOqY7ydZKRia1q7OabdjXmIacwGDkit3Lhs4fFINw8sw2iR9WWt6O2Q+S/kuDj1hWGVxADtPr9kTOUAQVIv9VjFp9PDxSzzVXGlCzzAtJZPrMmF3lN2lJv2GYH/ADEhFgirpGZlsphTnPg/jAmcGU5tc/fa6IqBcHyvJZ8mKLqI1wAAGUj2+mx2Q+uEZBO6lEXLDpmbBM9Wy7HYmKWQzqFgV0o4ZAFwYAkWad+SLPS4bCSoGGfL6fdPstGp4/cZc5WakKq+V5aiLE0BzQcTxGoX9v6vx/JTSJH09YJNbIuCe3atp4i1bi8rLZas3s5aqnAFkGfqPNXJQdTDmWixxXNqKf1QwqDbAy6buYukiNSmmANyhxTyLKerVzJDWEkr5uZtibO7dF78kIbEdIaTFMmCG3vpHtLFXw5d+zGqfoQ0aQHAu+tCjetYCbKZrQZ3RLUEM8ZOMqaKcsQI0ojEHxfT9NtMhHjKhldUQ6QAZtMJoTCAE3cSvmKK3NRWH5pY0zQaiREJ4dedmgPzyj4NmPpSzi6q7v29rh1lkTdgi7PWrf0pJTDLPkUv6u80HDzgZ/Pd469EkVQIyt+ygWQWFrC1MM1WTrrkP880JGNBbAoJOMI+IKZg9RqAznCuTjD2EJMPIIT9Y6Ma2eh+3k3EHrlxUOEvy+zLp5LPONo0ELtEyGKgdRvYwLGl/scLAXhsJdj8RnAsqrw41g+z23KnTa2qJfjtXrPyZgxSCWJ4xGi+gfnj2kjfIeJczxibg30+58AuwT98ogZGaBvpfpW8dr1SCUdLibmvw9Rg5lvbZeT5UeKutxHqtnDcWnCzJPUI8gaS8xWZhzyFWAx9b0eEW0vtaxlrhvRsUnHE37htW4VXO/37ah0tg65G8c3cZfATnHB40tehv5P2u9MyxcwMuR6tiE92KS8lZ7PLNNa56bI+WHBZXACtB/orHiKxLqQUVVhVAvn9AkEqYnNogmt0E16z5Ek2RTn1UUKoNg8S3f/mdpXpo0ny1OqIywZ2BpqjExSCviZe7Gw/6Oq84Z34bYKt7vTQbxfB/8oCH+4ACMXWpK41XmtWR2TqlBM2Kw00q/ctazDiPdnWpk5tHclv0fQUAyg/LbesLfsAbovLAGFaGQ9OeBWgjly9phNBGFORHm0noV5m0+6Odu/RY07FOSlKhNNVsGx+LrXEX5l1TDgcWqos2QvpakRbxUZPeU3Ln5x6zY/baXEx2265g8t1Bt+4xVT8JY/4naL5CrQj6DA840/MHcToucTsDz4FEzCqBJEhukqwGLPxaJ+Px5SYkDQ1i2mbamE0460wbKolaKymWEVRg8EEP5HrTNmttKwnqn0uCFoKuCo5IOt03LpZSbGPgFVR2I/tXEu7rpkK7h5QCGHBb5hLYBpmT/Vf6OnuGQRrg+OAMmo/rtqlYnOgewC7XDxUJEKkSZUUoZOHsiIFttyqj9XuhC1dqmua2HON2hCwbgD6O2shlfqbV1m5OmoROBZ+b/HR0eeVh/iMkUa9vVvYDSZfrSrLOhYA2vVA5n4WStuuqfJHtZ7O9W0WSCCu4bffGP4IwX88I8ozyYLW7rYveh8d805IyPlHsf/+F6XvhvA8BUog38lRgTtS6XuWDMqlluDoRxXOQ02nAR2ULGADlfyKunXrYPZ7NQtDQXeqfh8myxMm2RHGlPSrmo8JRGcwJNL9qfKD2HixWwh5aHBn+8+6UuxdioFCJ69rW+W0458bHoQnUNGGz6AQx5S4Fli4uVIELv43FNdrs6HW2FWUEtokIoTJnPbzXsQv8Dv+ukvHt6P7hgRt1AmprjQazZcTik2AG+U96c2pG/2/BwpcirN1YJ3KiMiMvEbU+CawjZILl2UrMYSeQtz2NCUyet3t5Csoy7SRzyOy8nlqLqLZu/DxIg1PVM55j1iUN7MlD8vcGQh7BJNw8QG2+RA5QKqgU8jkGbETvG2261tEju4dUX4WVslXHyiGtfadBO/17XanLNkDwrN5GncfxZG8XgjO/HoWyijCmPbY94qnVQ/GqNZhk9vPmaaw6jJl6syymhbvFHH4+YZDgrdSBAeTVO+CHwU/XvS9LFRYvvBf+UiLImmCorR5nz53ryrAEVbakJzjAQ7JJU6Lq1l+Kw+9XU11yBfwuvCX9JB09WmG2gc5BCjFCPddp4KSK9aBSl1PBvCzzWS+p+7eJYT31+wing9Ss17hnPjv/+a1Raimj4lwVOVd6Igmf5MLu4RCmVkllJ8N002BQ4KHVto/QUyCQTFX6fvpQUgGHG6KRDvoWzukP3d3L6yUtZOSUrKuwxgdXMmkzc8uQw3Wz3MOA3iIslkairmGFYN5c7NOjQp9f68UmPtnnhT2CaG1GvEhFtFpPEt+jafCnBHEL2NPSbbrr/drgqS2LidYj/55GfQouarpYcpotjU8Cz7YuWz3Ql6y02fxSZjXAE3OG6DBiL0slyQxMda+LdHCC+Fo+z8Km5hP2qrU8nSO6M8OLEKuc5hwmi0FsFCy8mXohBuBnpu70pQIdNM9V7ikfA/y0IVkHz4XBp1pBTcHKYeOGmWj3nxTtRTiEQpgAMVajUo4HB7A5B+FN5fVbNXKZw2b6BkvfJ210Pt4OjrVrlQBoIxkmYHM9K9kkPCaDwg7niM9Ytzje5j7ImUJvflttv6IJEgRBI8Dzenpk7PZdIpAViYZuvvqAv1G4Q6baxe5ibAPpX1JXZH+reu4UpIwVJd73L+vxLo4n3X9WqMYh+j2BXrmKnKGsmRuHslhNBCb8kfi2mREspCd5EFRAIm3oipPjGdJK2wsjE8EbbPQuTZ/bnOKl2Qb4RtCOfaJHFT7fBYk7TaJ2Q2xeV5D5kVCaHFj18Z26Nw+jNkymmUs8tSDu/J9DB16k+F0BWIB9Mh1P5C3igCY8Vl0zV7ZzkTzVndbLwugGZJeAFEARzBQclOom2x3be+YzUaM2E7LeI+IcliJiAvtpdP2pNbLhKNUxzu2At6C4hLrl5R19hlqcHSpMLrjlNz4VHYe1v2YI67j8HjRCjYVXPvXG5vqOC3FKh+hEtGwMNPuIsuTii8kuv2Ppka1ksLxgbUXODUFhN8c9PxcLPCX1EzH3uXkpTEKGOG40WVb7vXHEd9XjcbJPEnE9J7DNgGxeZG9CXVEnGa3xnXgVp8pqNg4+A4C/eKUH7rH5+IfdW0+2VWf9We/2mkEQ93RxsuDfh1qVfe2ciZPuaSpcv6tTPG2I8HsXrgP/iqQHHqQeVM+sRqWObDKQmvfdmecMVqUaIP2r8ZzYx2ZXxpLKZa67jmB9r9Uxy4cjGclRSbu90JyC1BfM8cSTv9pMKr6LppbBMOLxqZ5yaHbh/ABnOS3MvfnJ61desnLQ59LFBKbURrgEPIzsuVtorl/ckQFRFJYO3oY100NYlyhHwPHVOwLIkqEYccnUJO20IsYf2H1xB7V8TQQnyy7xJ6yBniP/2Xrq3jypFkzH68FlI/Fn2im/pCh5NNr8K+4M43qRub95EkduUWd7WBF79lytK+mYiUptwmawIH6NHMkqjR9G6dh+jfOme5QwRJvhbr7hBWQ/dujc4DVoie3C8+G0xmmqmlDuwyVgKm4M/uTMkrBHt57Piol7fUXtrFqKeeycfPs8bRWWghQ4xPmL85z+TJ+hfQb7sD1yf5Qnv6Rtt56Ut/wAc672c9bOsSPGrcvS3PhX/zN4FuyYjlPGqfjnz18GrVNQN2EYwQBr6Ec5VXtTlIxi5IGOnm8hGhhA+upU9be6NBovhBmXF4TVWX0uXlSq5Gn6gu3BDZbk20KfaQgJgfB4gWPXOiyfpCv4SnI3flKMrGFnsWyX1rxNFtBuNhOJb1/cpGJZ5xFB6WDlfivAyOZX1vSi9/zM5xwWzDPw/IUrDktUSSKM/C1rrgLSL9wA+suMvzd1QqFMixZ9Ju0EGkh2RC1XzGBclB+RmC5BxQtGcBYT2KrHHOtrUpaZT1uhmkoXzUprlyC5r8Y8P3NiBso+TzZ8SKEavJukQ03aZ0EAaKdh7dAnm15wMxifV7boKwsFj7Fvq8WWEJPFV6gydREMjFkKHCRzICvhSGnakTqtG2IzM8Y7fKbPoimLokrNbY5f0cjNQjxWY8ReJ+0VN6iSiyjpv8StgZ1EgiI7kqbcXvMdKoV6iZLZkSmkzEPE+gvap4tzw19vmuZAIfK1Rnis7B9IiAWCBKjzIbQM6QCWylzmoNi9PYrgQWUfedNTQY9QbmM8kXTFnDrC9MCC+vvgs7BP/4fhVVZA6SZupJcCbxP7jY81SjXkzV4heZj7YWMA1MptjEc/rIF9gui7pOEWPpwPniPqbrSxc2Ob0fcQDKz1zb+dJYFsnwiOD2LteNd7aBH2C7+Wk1qsDAv124RkxNkDBAp+a/08NvavhneVUtjZ7we4lEEag26CiOzN+wTYTrXKYiYK1Z5OWFdTXoP+n+uOWImJvHEYyY2PawuMwXkQwtyjwb2QerI9YmnvywDz+bU51ZfHjs8kWGsEX1iPWSrr38+pDestmnHbYTqarFv+LVL6s2rP3y5z0fA5SZNxsXZQLNua39WXCYelPLF2KVJ0UQ50O09fx/PKilWORagsCnexPA+0WXfZwzrk1I++/V1XVwCsfEzhXOSM8lRKtGe1BMbbyIuMejjxXqJ9OaSZiKZP4erXk0yns0W3p0qxthV0zCSmdIkhpNQF/SdSuLt63zBO3ZSHNHYd2TNqhaqcFKiHKlxEakBZrygiDKDhmKcthE8nISNWMOar5q0VveMf1Gn8FRM89oUAJnOqHxAS5at+nbeldHI3/RFftzscygXyBpFq1Clb6yosBDiHaoPF54cEy1Kwp6d3CWFp2KkyMDVaq7ieknjsZsBrUenmr4eOCmAA647F4LrZR21s3f395tPEPy5ZZLeicX5MNdCZ8SVacaDTHIUTYHtvRboAgUJoToKZBkO5fqrY7tK+eqJXTwF2mKeM4Fp+R/JI+6YqFXuClpCiDjFtALg0llUYeOClyXU8x9C+s5hrSNp252vLaM9s6wvaVgmNBeQT6q/WWiwlOFshBmrpnFf+uRG8nYP6Y6UITJcAbMakPZaIItWCmhIgJTHjXkBYCKBB6IRfD1RoOTHAtngO9ZfUiIB+wefYPK8SzhV2ywOkpeZ9mmQYtT2ecOv2iAWyhfnVVDNyzjXYF7fBwsudbk6hQdTOAPC2CmrnMUJX8PIlrugDS26+pRF0T06BJgY2NiYrT7Kqzu8F6CGrT8/32QdOPwspBW+3E/x0yiBQBGnlK+cRHto4X9HqKRZ+DM5F+OB2MiiZfadK//pfjMrWG13SPYLUUbbKLjmDlXJNuk1F+OZg33wKx1HAeFMl5isKDACeDJ3wnxxXlt1SiCJYSnz1EgfCa2aD4b/Iluouhz5K2uRQ6RhDE/K3iPTkRcr+HoMTvta7Wx0saaR8RuMzfV0ajTY7lLEZxjk5ZcIgxgQUEvSzJIkkyYdhnDouQTykFiOozPH1al7BJslwiu75cYCNIuo6w6lJLHZ8vS/PV8gzEsviYlHmdBn6fd8qTtOzLzgM+Z/HDujwJQoq/rqG7sQZpHEDDZOznzIKuYoLLizB1WY8Tk+SDyR5loko63r7gpPEZgenW/Tu4/puRuB5zG3B9VFZxbX1CczvedzSYZbCs2keRKi4fUMW0+bnm/3uddxRI1zEq+Z13Xa3VxdWr+A6ZuX/SozUg1lKhy6oA/rqdlOPkdPvwoBhrbe7TV3LE8nSfRBHYryCSE8pwE/nUwDnNkr6GoZIZnZSdpXI/FOGst29ivrsVUqLLcZ68KPJl5KbbAgxmGhvOMqcGvwbHhuQ4LPiCmXN1x4fmLKxqZx5syxyincuTJVrLRQvd5fF7onyMGXh43IClxLi8otGn0nnKiE9OefRMLK5IwdFCMBPxFafiS3NoS+Zc2v1It3LN5DAt6VM8D+KuvWVL1V8ucTD3xyx5qn3PA8/oQZ35MRH5qEPdTy7vUali1G/Q0sC/N6rRR0ETz9303IdAsZhBTebZTCqpaiobEUjx/pDt0fpo/ZBFA/WIKHkdfOp+F4zK8uw38DSV4vXWmAjmq2kKzcPV5uyRCWbsBDw3cOIzMXjUXfNwpDk+SEIxBTybUDChYBpO0Bz+46wxHc0Zqp59FFHVXwkCpiWlbO4hPgpmk186/Cg36nNuGLbikVv463lue7/INbiHnmfdADWFKhxyoc/RE9PBAfmr8vz47dX91j76D67BVK/BPejQlPfclZMJhp3yyqwZEkUeyp5ixdpUNgNqS0Wj034DT4Jx81dJavESX54b5D7A0gzvrolukk0knSf6uUJKyNJBJlB7LIsJy7bBlCZJSI2TDP5UutK52Xv8u6TXpjQ4q2gUVRgB10kR+4jjlXS3kphRMt+PE1KSykdpgEhfhU4HSt/zL6EbeuvscCvph8tJGkg1Y0LTBxrGgRJ/OYDnN2/5dJ6GTbUfuzI8MV8KG7QgSYe1zDLNfvnRha5+vm6f7ERaJGaY/nlmcQ0bmxQmF4XyFFP6va5ltbPGe7p1+mbBOpOnArsIRrcPULP6KguiTdfo53WczdrZKbtvlRxzhcApAQm8OSBtEOrqZkDjeARyavqt9UaSwZ0C9uiaQhakuhqlRzoCkpyziIE7WEkMvjHswP7IjXP7IA0tEVF7VU2wcwNYspm6mqIDsplsME9lXTcPojtR+4lhyqcH++TX8LgvNOgvgARxXtqjHMhr6N7koUL0IsK4vAn12KihVKCzyhY2YANnZkAd94hmHur+W4rwuh4si9Pl10rUfJb2oXotQ3dJhDbRZ5jBih3I60Vtgse9b3YyAuNsk+x03+u0lYeGbqH0d2sSWPSY4uA5xeEYwplgesxIlloJynHH7r+2Vpj3jDnDU8zZVgYvLDUzZw9UKNzvlRk/Bm6gzrZW8GvVsfyEYgVqKOmzT7H+/5EMbIANnTBMoUg+//KGTy9VSne9biqUmqAiWjZQzsf6ZdXMNSGXmJScPBmh+8Ew2jB0LMgTTmBwKzERmV2E1jlQyBCvT8I9gVinJycLd0fofBMaMlNXmIusLI7MogSH226BJdaHRcn4Ovh3Y1ng/wuzDYfuh7Ph0pwLvD2dS0bCbTQxb0rhY2cd/GtUfUZbERvWxOrvTxmin85yNAnnp+Ud+NLjKI1tyd+ObQ9m1Sn65EzeIHOBVmpSW7orjv7gFKtS7Odh+f37B5iieYSMq7gd3+H7Vnwzf2SuTRbXgzF7zI8A7Yjq86GGDI/6qJ1KtMXKI5weveykH8vkPpUSzNV96lH+emrGBE8IB2WlqaZe/T2lqQ6W33n5UbQDO8kgaNyQh2G18rhK1lI+skSA4vmmjW86xt/whLhGIyRutUZTihM/1p5JtWVre23uIETxj2DPwLyvHfp5ihs1QWUteDy7h1sR0SAZCSa4jPLmxpmwUjVvGq2uSHiF8OFN/PyMUD/IL22iPvGWys+jNYNX0RjSzkNZ1q0w5LSFT5TQCIUeuwL6/QeKNKPhGeri7FflG+M4yzFIztjOXU9P5ZgqhgvvHBoDMnc+Ln+zNpZPpqYaUrgN4bzD+cp0ijelxgrdiyadaSZhtB4hXJsA14FsU472nMqnYbZ9xSrJGlMqkJ+YDxGger/RlbBY7pv8+vBtxP52T5rxk5e2uwL+HTXvgGeBnJYyP4VmM/t3b3ljNy9Hz9yDO0BHY40L4UyZw/nihYrMx84Y33ev4xKdNQN5T7nwYv6nPjJjXQyxgOK2IbEtWwe1lcEHeAmzsYpGLSe/jaa9nXLQZ4/rLCwiZRNT0/+NSWM+SBkID7UuoFnNLeMmcV39BTMblppq7Znqjp3UuJ85CHmqH67F6va0OAYXiOD82cGe9UW3y5bJrPVlf31gR4PMJ+J3WBSULyUi0SxMPKYtfkqwvPhdlqK8w+O/sK6+VttYa/G7eo/kT0JxzdoOMSuCYJG40YAnTHxTbLrX4MRkYjlYCKWVzn4r5mZQqDLxTbPm7G+qBbbnERbU0aVT0NzTVfks//v9grN/gfjDqk/PcuGn8xLNNNYBZ4q9N0E5vOSq+W43kog1bnJtEXpvnfEMfzTEb9jhWdcT9BFryEVKRB1p7bf+5g6HPVgp1tRXTSCnxH3JXAgsqo3SSY8ESy1fh27xleWyhh2R5wrJcBt+5YO6EHZi+wyZIlYpJUuscV+Q+h1hZ8tHd9iq9k70ngTGbmQ2jU4LMwbxBSYLXo18mHdr6I/xXyO77UAZ5/M2XjZf0I942ssdZwNsBBVeXtkKiquH0LnpICiergavKPxyRc7skSt6YqecVQpNQVQmiBfflXA1EHs4jj88GJm/AYrdfiXwM/7OHWJbJh3f6uV2yVGiwgYAlAYEw83DcqaxOXvjjFRpeK2s5MhL9i+F3Nss9N2ySaa3sdujcLPSST4vsSnB0VAP6mi7ZPwaBqGfrfh1J9MwnGPeNC7UTGPBz3YkG890J5OoVhbAclHvHB38Vrk0Eavs7xoSqnlrslO3rk8hc95Gv4+JiiXmwY8rIXvRLmYyhMkLjKrBBjmu+iFpuX2GwnOvWeYzXxIOMHP0FdNnIR5aJjSfO9Czi0nqaC2XduV1fhrz6Cf/rtSIsEJtfDfw37pXpijvJ8sPc3IO0jCV805vbCH8xBml806wUZUxmlKmq9cD7Z/jIZnuPHsbU2BS399CvmYp9ldTfagH7F/ZWVZwzsdjgEi/Dp8lP8dq+G+lHsPkRkETZd1xP24VmcHyqgtXvLosdHozvwjOWz9IA2z5+WoL23oe4+EnCTfE7yD1MU39fvQ1CpOSsYRaHX4wqm7EeQlHaiNk4VF3dO9mVToFlWFGJB3/UUjFDFf6AazsnU62kiK2xPRjPajOhwVvFPZJF9S/maDUUjVht6n3X0On0b1FcoVlnbbXOlYlNVodR7PgVQOW4RQc33/tI3DfX1GXb7LUtk8vClIsqZOQVkGtyVWQfGVCH4Um1R77SHXqgnuAIcOSk+G6qSCsO2Cuzp5r6f3+brnQnwYtx4U86uXe1PAdGyhF+CiWTfjGI3LceCyutmKlyCwVm2fQRvQvIq64NXXjxOyTka5VeqmOFSPHZUzoyYKPNYrwQylNtiSAP558dcquY+8JQ4IB8mbJAO+osWq48Qtj5vCgcocHcJKiLqcBa0HxW9J+mptnOxA6goLKyy5iP5TsSrUAtbngX+Ed77cZVRlY7sgcdNrTTyMCKjkDqrstfZKrOzDVAsMgmhxhsMERxie/X8hvZEQUNHUZf4vpWOoYI751YZX88olLB9cp1OtGr8dpmk1m9UhEufpruubVMcP9MxmVhpekcvwyYPm9Ve0/FG2o+TTGp/whzqe1PapPBQ4PnC8krZdURKnPocPGrjA9xBLv4fwRyEAjmk2OFTzy1Kz/eNzCMVS3POUZ69O45N6c2x1+9p5kiSVraH66/ZHfumDFT1uKWxK4oopDbRRrvyUtgnsIt7tmo/vud8qn4kxvr+kq271Kbz3S2u4iNxuew0zEC/zLmF90YjL0dtweIq3c14JN1X+pBiWJAabHrLOTAKG7WU+eHLUtG6bHqCR+2KQ6+kDgQF4cwMAnkLKtiVK0tEv9QJymanhmR7zbGQIUduqk8dd1yxx7xCKKalq3uARMrm1n8PFOS92nDB6wblRL27zCUhtynODGD3ZBejS89svhBx0cR8GhBQ+BwFqiwXkuS0eQ0VL6AI/4aVzRQMnMfEs5HVf92z0TnqM0/EiO7+wsC/OHLan7OXpA0eH1Su54doBXnZIOrBA32EZ/YX48/JaYGX00njv5GJcqZkGbMGedsvS8sYG3UCosLt/EWhLMuPkCJNva59JzHGR/eCt9+fUV7xaoBOXEd6PK7U02p2LJS5NXuT7hnKrI99Wm56/etlDjQY4Y+hweIONLzIxjKfZkBUo0BR1UfwyLGL6Zp5FQJQ3/RFgPoZPlmKwJn/kHmqX/D1SDHqDbpSJM0p0oI50BNL37g8A9F0ZQ0W4eBQ0Q3z+tISlt28wDJRck8tFrWR6m1JiFAOkZhhlDMpYGq4O/ZJQyv4mPWC4usYXxHxFevafvGFfw7iOz+wYwPNPm1WmlELqD6S/N/BcXw5i//iCwRubDT7p7SVpu5AyRuof3qygyhyWmcqoSIKEOmhscV9Pol5ZAORDNfy87qOQTXDLHvisoTldFIsPnz95GBPgj0YpJeqmJuoMpJD7QVGQx0Bw48Gt0miw2BsMkKtJwOtN2XvoWekxmrfFYRfgsj1p2vZmckfHekzDzr0aTzbA71GT0XN9AaTv41XtspRyqohc1Ow0TCiki4drZHqCt411NfWZ0MAvj9wbfe9CFHE6kqUnZG+6UGFtiDIbCfV39U/v0HcQ0nG4aSskNejs/mpoJUY1/S1GmKmqJoKG69nwvmSJNNum9ksw2pagtaDHd06EvzX2OrEFsfW4wHQ4xP3XwYfZCB6UrqvNKcZVsbHgqdCw0drPOg0yzu/6ek4hKBXkaXcHlgYL7UYR4LAmb3wT8z9uMLaJlmtsJYh1EufzscsBe4s30kMz3Wm6l8Dq7NEO4AF3YVolsHpSUYIV3mDyA1V1dwgPNStrxGrWEFvgzxoPNAQXdaydnPjclcQgRI8kzWHd5iUwvI2Pkq0lIZhlcNs0oeT4/cEV88oKMdHxejFitBSKrEW7LkA+f36U6Zlt/bTzq+P6kVb91rmHoqh34h2KVHHECmrn7NwiRgL37ZV3nu67srE50/GnPdqOsmanvrlpkPedg+4RFQT0L5ycNYij7Mpu+itFioicceLwxQAJq3T+ousCYS03cAwgwXEHdZvM91S8+lZYV3/mtee8IGE0ZEiX9zuI+KwGs+Uurb9/4L/Qw4KGC8KZqQQ20u+9eLXk/IZOT7eErancJJiCwEWSDidztQ4E4FLY26HECYvr3z4mmK1MWKwdotBk6umzumYzPlX71pb4CzIhzvqrECUurWnTw2xlnvG4mfJHG2fl09nJpZjctButuVzWsqpwWw0GidhP2qQJfcQvfXvZiX63Gfq1I460dHPg519d9tNxxWS5ckSap0Ae8ZCH1yUfaaQUTVBAZ374e5OOqvU/OY2LhsfG1nZcI+KC1mw/33Quvfnwde5KdoZyy6rFxI9aF3S3wdmREKUoUHUMKPKoFKUiwFbHqnN+OqYkfiauTfeBnoBzENy5Zpz1nqsFELF/YAOQ7d0YGrxHrRSS5FiS9LthxnnmYoovegLjXRiHvdGobtglDQKi03jneIAWpBASWFczFMYCSTSq7ripZniY1JWbXNRzhKHbgtcQcyIxOWh+HLQeTR11CEAzBOA/CGKzY6Bzx0uTAwostzh7zs4y5tjNq7aPfVHg5mp5z1kTyL6mzKG4KynvPX5lFhSHUUjfVDvJDXQMFMEIlpLGbSFt22hec+qUEQYHjbh3G2CHR+4Xb9nyGUUk7MMAZaHZemKOSb190c+SumAEmMP72LiiUBcojMWqP42zO8oHWFOQVurwKba9RQf4zN1uiZeg/zejw0Tz/XW40UOHAx5Pr/TxgaIYnWV6L35hvj/E7OrofkqcgdI7ocT9/e2gVFFnPZZBFo5Gm1ydXdlAk5dOOtg/8U6ddtIOc+J2saSJ5CAXVS/O2YSMpokRVaF4E5zMvTfBFe5NN9BgpP9FVgVLn3tqM0Vxra2ssF6ieiG0xvu7BAgS6W54SKJl5oGMvVVS2FevFicnoj42J5+u0RIOSzWxjLmqvOz/TopbTsXnyOAdlcSEgCbZTiqdM81JqCYSX9l5m6PLwKS7qiLDpkLgvQSKxicpE/AYmkSBg+N+zATMYJzgdNj8qMdjE6HIieWZ9JMfqx839kkMZ0tDaSL8is1EPB9e1YhUcY866WKKSbidGPBwJb9Nop9BaP7L/y4X2u6013iCzuuYsyeQNmRAG9gvg7KYXA4eE6kgccW7ppKRhHJmmIxf85tFUthuqf3JOcJBBB/Hw1J2WMfMdXlWNKKwaIW/yy1ETZX2/Kj7rARLIeNv2k+nSYInpI3OFdToAWjF4WonqG8/jKpeVnBcq6kpNkkq9HUsHNfnxMT6bmq9LAFfkIAi2kdNYC2jm8jrvgsnAKzxlcdUHLlXu3Fwefx7obrB3ID+GcSwTpthpIkLS8IvGpY53aTHgFca9i2D99tJJb6eh3qwAK0TW7GSJrfccZwHnIepWpmKyA1zf1EIjQErvKopHxpYbz8C14rlpCTwVmRgzm5FrB09xXP3oyHZxzA8gGg3DR94McI+/UITC1C/Ghf/eKzp+47Jq2G6Gxzw+b7Jm3oR2ospNFnTAWBWEipgR7NSKugceKXdjkBoLg4Z09OeGJJVkDUiVrNhPhJteP/aSFUZ7u/sh2HIymCZF41TE2FwxtJQd+iiwlWKCF1YKWe9WlKFvxlWktShYpMZxLq8pFZGgwOLsx5dtuA8oAwlqfgi6BIAoEnvrWcT+94mvgjBL+nV0sHVu5WUjL9+EOOYewiDYwDy/eTIVRkeGYWzEnaZ5AIgAODqGFGNQFW18tXpEK7TCyTSgBvKEkapbMhWYfH8JSkeGtyTDj58kowYA4YP9MDoNcvfI64KFN4F0Mj0jzhCwFAHpiSDh4x8MrOHs/2X00JvL1eT52nI+7/fLCfI0YhwsDhArvlJPj2wl27ikFKiV7GLZ7iuWdBTMlom/OJMENggPtaelAhDCnXxBoByUmaED8NN47FuYX66Dhx9HyKufBi9B9TgpTV6fpWqKcMSMBxjUrimDD3wZ1c5RSbEI0to1ne64aiztquWPWw9kBblhRUwDRY96EexupRu3/JatWqV/4YNSSFuLUIfYv3sLWFnuNY2iKcKk4k1GqjaXK7J/zFX0aRRPbxdHcdEb7mX+2O/13UTdORgbzLBZhk2fA/aZOSyO5+ypQ1VIFyrd+JTuWVnuGbVQbulMTzhbIrJmNV99dkYrDR7ZHUGgH+/uJ5yR1BqSKtCEO/LLQMDxx1E2fDjlSqg4ZjBQgPOE70SPWWzBjptaUPKLHPKZwUdra11VhEUrZ9hywaNGDofCye5/vu34bHLpdg8KCSiFO8MkvWOp7pi+7DumKiuvg9H8zTZ+7Y3QqngmsgLmy9hcUTAp/7rvvpFhtN4enBuEI0idTcAbEMMUCZI8eRYVO0AXzP+kei7JJB2PBjAG/ztDtvw+Qp/UYHJpisfbWbPUUCI2oRyjlQXHjALvLDl13a6yM5xMS2oO4pexMKq+O/tpnZQ+CfPZp0xT2MYusKv6ORHimsoJNsnrCb5XhuN+yzYNfxIDpzDNU+9trRtpc20GCc+0beTn6UbKRB3wcFjNG2VKrULsQTcM2yPgL89DO+bldAxmHULyPzSNlp42UFwA/mTiSENpY7JPUU8O64T1CHqGPbTE2feCpinA8O84+g1J01gy34aYq9k2vJVdRxl70JqgwGD4SYLXwiXenBUe88LccSwRjmQlz1ZOUuvpwt9cCbRU5NrwqDwNWXES4m5MGlix5IHJID7S/3ZhFT7I+QhZRW1ePQweQue0DSko/qs93+rSUYaeWm9gGlwXIykdDCYD3BbIwppRQyA4V2wnvuvpuwutwoXjEF3worv5O417u0dg0Y7WPqv28jR+310I7XDNYjZOBHDpNDRGpW8Od0M0RJpYA50uCDr3R9e9M37XAFoG4Wqm/boHUeDh4HGdkeZl0nRKD5AW0XeEE6uKJDfp2rOCMGrHa6NqNVFYkNIMqpwUE2NlhpPEHA4I3/rcNotejp3SintXG8ZLBc7/DaKxWm338RF67WrIHCkSaMMM9pEdAWaej+Okz4xM5uJAY1FwGch9dsG/r7Vzay0bcx4QMXsWqoURV00lt/PA2TjtOQYx+M8eTxCZkTt4N1bnojpAR4quvr6betY+YoZYgHAOdE3fKS8x8Bi1sTDUsjatmlE8tx7iJWJoy56kD4qWZQXRL0EswpItpuDpBKBDdrzXEhJthXULef6AqsVzxCGLOT0M9Irdle43wP9uSwiITuQXFP7i8fhY7CPvRZKPQZUP+n+jg6ZieTBQRpFnGeuFB97HbaA2Z8IEB6BXTmCxjeWuOKeTs3qROIp3NLqopJ+mZ/aANSNWR5hM/8UEjKMQBCJToVgy+Mmlj2Vgkoopi/Atiea1XtlrkjSoRnttWhkc+c8ptH4+4jg7uRLuxbcY/jBfY3hYV/oMRc8pB1T2IOSwJWnSRQ4I8wB+EW0S1AitvtEiKcwmZeObsu1Uf4prZ7wZDc07osg0T79/pDx0bIw8kE/Cgf4tDM++S0iGVLKC2Zms5KUXf+vVzEcBM7FsO2URq8NPy9PC1vckW7l0W5Ilya1PCeXflLNGeZrZabHnXF8U/Qz/u6frrQxp+q9N0uxvNoe7YNlFDktHLKkFzf0qJnVL07GNbc+cYd89mYh4pqjmQlhqz3egwebx+9s2/tS43Te5gKVWQlBe6lg+yuE2cTejOhSFxxheQjL8jdOUbl4/xyfQHSLyxOYDkeYFy91Estf/yj8kDJCkVyiFGP9kEKUHiYnE8YKfBExLTzl+VspJCzvogFkL2tjnT2bEdFclAjRxU878bFVCKotYlJepTlVP0Zd8pTavuv2fMxPIPyaofKruXJcNyLVS+6+eNII0KbkWivVWntffbiHI8ZknpTTR4rB08597Q6mOd1OvBfj4qil1eiCuKZm309xzd6vvfBnonjrQxjPNzbNwcCktv9OZJghuTx8fU+CDbQ9s4YeF21EnpPiMleuEgKRSHlJyKtB3vFrRVvsDaoK+I6yq6BcLnCWQJ+dCCJFwLiG567fGL0ar206L9bF7CGUTOcY4iy0edSBDXq9hV/ijiY56P0tZ8in5LTIzpNU9HZwsHdnjRhon8fhxluap+Y66XX/fl/4pgDrFtFYN/RUUFekoLBNuCQH9EWVnpuzVwXB3c/MRWXn3Q6cVClZJO4HXQG733aL9S7wlxbMjfc5iTs7Q9OfB6EWidRVMSzX6NFIVDbKcH+8ffTHddBR/lb0aGctnn5oZfGywkGLhfqK+Cm6bUNq//HgB/c/VJku4b+q4sgsvXDRqsmpwHCqDsnmHbW5eIkLSRXR3oSZbeNbKetJlECZUDaJCO4b6XAoFJ+NUNnvA9hC2udmyGPmA4Xi8ChBfoQYr9gt9EpWVYwtKxegxQzFd2r9QZrMPOGBzmMBT5lJUoiAb+0vuzkRV/27tiXOJtfwvJi4JXvZxNrUc1ABO81AGigYMTettqF46EsifZYWkecXxlYV0BP3LZXkladAbVAqZ54A7GVRhOx0C9FmjJdfG3FHoh9kyP2rhjQUGAQeRc/GlacXJmgHl1RTJ9GuYX3+b/AwcKpNrYC+tYOxCFQ5jKijyLVY8rBEqAT30Vo0tHnWS4U3vrkmWFFTEd0LojD9bcTtAeZDq/pHGwWO2ugs66eVgjbn3mjzUy6p3UqMB53KLZQlfTHSxF4WRpDiBvxZJnbPlSYolfUJFTojzKdZmKrng0a40E7Tq6V5UhQrA2DAXxC2vpNOBO3mfQtDt+EKXiz8gVT3TYpXOh8yX2LApDxwoa+XVF3bt+eB+Teerkh/QOR5jJzGuZ8sN3dcGoB5bMFqJwCmij+C7ntceTITN1Ua9OVDeOcmq6l+/q1EFWpGZba/KDrx481ggD2aWHpifmHKutd9387bKvWv8ihJy5OyzKQAzt+nRxv+nCZV1ojOAc2CO1DFvm6es0nVsACBSvIk857iHpoN9L1/7m+5a+Ch/3f6khW/vEjG3a7jVoTH57OE2jhE9mYlTAde//A+PGkhaiEoTj3ayjZuUbUjVTAT2NhP/Fq3ixj1NvGsJBqyfVkSI7Hc3hwcvwQnplUb85cvROss+3rI2qneEblQ8qc0b/fo6PPusuCeRMW1YZLVcdiCdH18KWcM4V2yNndUzX3VX+VrR15xZgolzM8CCxNgxM6zuEDBrVB6u4MD3cyXHUNoTw5U35GV0SVez8Y18LTZtHU4ibC8DE4SIfrLF+QWPogBtq8kJg4LrdxOLGtl0pEudbEVP80hqQRNH+VmFLZ5e/5yV+6XIJtEWLq+rCn3W/tBQC4aYAxQjS7/Jmx7MyW79Wvf7euVF41aFUZeDJXedNcAt+9bpDIRH4QnImCOowXuS7LlZUkOKTXASV21ncAuCTdjPUyhU246c5SeY6+z8ygqk3CkFjLUNEmacac4U2h8WojVubNdIDfNr2kpwRU8x3GCh2IIdAYcmc+lfp5lNIBPPtR6jHA9wPy7rCUCAdNdi/dMN3DhTGy6iOfI0rSxzqETFalJyaAbm+6cCJOD873wQjLRywzKSFzuaQ8JG+bDljSghXmdn9eCY3Wvii8MNE1Cw1Lf1cxXISmJaNHQJcQKJ/bMRnlP8W3TXOey1wRVvmOF5GlWGEG4Xca5F2umOgDxzCKXmNI7kTtCfBdj1SlARL4xF5eaJWTbudG2VTF+yVEiC41IvSflDeDxzDHBapaQJP9OYoXGitNayBffhS02EDxOCIbeuFoWgQQXCkVkin0amLgSx23w8YcVEVxSV/4dZvyhxXwR91alDMPTyUuyGsODCEESKY0USk1yYqeyNSjhLUieDatFpzAjFmiiKyfmns5ySPnBhVvBIyrYaMkQq7qGt8FGjkRICBJL1YABiZzpL2UZZShSGziKOmrOSy89DaqW1nsuZM61dLi1GORwmhSFVToqTkOnQEsEjXEWVIb949EZHWRsUVCEJhhkPTkYPaDtWlDWnj/nANXvA/JIV0Wc3QpKN88bvNWeHN52rlolDcGZ0tESAvBb4f7ccrIiQRI3dkvByIlxvaDC62CHmpi/6nX3q8ycATevgVNT4qUEQu65ra160Xz/h0hjXS1rWyj9oNzMzvngRPoHD1tCSj0YHfaUXZ7m3MeLBcCdqDZmojg3FkW0Oa/LpU6aZQpglL0BMTSL+qIWg3L3JPf83pfmLTQobvGaBQF+cN0t3xQ2WaHKBCFvBN/yiEokNFkMwuCBOQUCL+BTN/b/2xn3e4FDkeNADYvQt0TVbftVHdq4cQr11+Q3PnN7QtVQwVmBTsapHaW79kZb+yifsRwI6R5SVf2aTdJusTYTq7pzpO9prK79QDmNOCBnm0U2TJuIFA6ZRuJpSOVIazUev7AThw4t8kxpZm1VbBPF878odoziHzNh7elMmMX+U1jRE3wvHmuZBPJafooKWPSKQQAIcsNaeXFi+diZnZBZbFwJVwZZZGWDpAYzl15ZAKQW0MpS3jNcCJ4DISdZh6xcHHceumdk6l+wRz7XYf4XRIhlmvikAnXLQ0UlahUB6Ul3oyPrnBOSA/YH3G0nEIrQK98XL/VJZGnC2G7v0J6bNGVKDD4EnAtOvI/DCfudGCGSr1hjWgJLWnytLp0sRk6KCZ7tmADla9Sfn70UiSODzB9Rsh/hqWdPYwUVxp24M383juXiUHYL0cp/h+V/lEG/S8r9xWNB/eVR+9zhZFJixfGKfRbjEaRaYLEqAPnRTGjcFvnyI22XqaIrilZG+ru2cGxcK7irZj/0a0ivbH+ZFomRXXdvjX58tz0Uj0q9wSMsNhcf+StB1AAyyNBkTffDTA/+YgytbRVjPAiXJfiZkzghrBiANAGgYXiSR053Cquxb1NENRzPz7l9cdWNHjHnzp6n4WGmFm+5nQHUt2MlZn45NCpaqSZUtOlbwHtCYWtdp3mVZCWVUXSZEKOkU9chjVwYULqzrglIVAEUw41edLMB6c/nlzevPlSQMZdG58eDAwtvOgVHZUhCkOMAsGOCO7PfkdFdvfS3mKv2tA17ShdXiTcmihQ5JX1HnBVXUctmb3Yh2fdjDfWOZ2nTut9+4stB1fhDn1q6Pti424jZcsEw8KwqrL56sye7WGkaMdPCon3gsEQIY+eZBBM8UWvkZRwdYPLMxaqqHEJ/MDjfz90j3dheThrwOC4Ar362qWFArlGarQgklYO54Jmeq+OJhsHKauWYiPbS7EMq5oAw7lAkCjyN2k1+H3q1Rvr5DOmNaDkt/aqOIOaGghqbkAVPuFSyq/x77IjIyQ3PnNbRKwedKAz/NtiBiUgXlyOwWsoDvDpH/XjwaRilCX3YpZaYUP3qIHHU9nyhiATP3edbNrTScfVb1GXpJlioJM/nlbFc0IZJ6MR7eWY6UiMcv0lVDAr8nwD6QLMQJi9prV2I12lo/3AoieAgPzxYk3pD5+TG1kNueOa6HBoZcUFJxfwnlmC/mIOF1HO/oa4vKaFGarBzK6JLkb8xc6v7YR1sXWzPZIZRayBLy9tGuie+M6L9z7bAc0q2M7g80UNwsiPpjlhxMxYXRJRTvqy4p305ETm1rAQyTdx1R1uSAcnJyWnGVx6T+kJxtfpqAcXNboDYLR743tzKrdd1dVNxX2niBrTxF/k+VIhdWDPKFHTOmilnYROYelodvwQ5AoXRDeVgYzYnk2vGYMGeNyihtcP6ttYmUb1UOWGH8B1zGZ23mFnAnviLtaA8Tc3csWtz8H5wHTZdXZCS1dRNaSq3ExovMgBjuocLfANxWDbLRoq3vdQr17an2QjdMYf9u3Miwmznl5IHewWInQpPGSi9iI4f3jZhbw/o7ZvGhUnqgrnHpODS33VxX3P2YNxCnNh6HMl5SDEIaxveesbl5vkW3+yAD+V34oC3CoRooxv1VfevLowP2XiN0oPa2Vmi8pwikVfY4/wbASdBdH2WdG+wQZUBrwr3kcFw82FfoKeBr2AwhpOphJozobD0ol+f67JT29J2paSXNXM3SisA4b7gGablawl0zl/5BjRNUlAVHa0MLxfywm4uJD2SjtKQsBo7Yv7FNA3nYKYTnMvna92xJ0v0b9XBQOLJBQotEgcgPG3KLmcVoEbjOR3s3801z+YOcZopS9emZFrjAvGhhU11ia4/YllLw2pieBLNI7eWfvPGXCuaJzQ2y4yXRpieLY1CdWhmfXQ6nvN3uaBSjAYFHS/LHAwI4SO5/C+KhgRYIIqVfTpIGhrpkKmbX2DOwFt5w1exsMzpwU3NmRcP/JVK1flIeAAyJBAuymwZaNJUrPnPhbw3IwgjjvhKptGXiJ7J1BXDtuJIEolHGLvH5A+5ZOd2MjKyiUgkLEDZfpWhISSFzZxj+MarGpg9kEMK0QVa9j3JVgzP2ruyFyeEtAwaMVph8yXrzjFFGrJiQ/Tdt7+RwebxN4UnMfGB8A1+80Ljzay48NeYeRFFshtyQJ81ua/sW2rQ3zlFVxbCGmflVZc0M8LVRprkASsbsk5PM/gx1kCQqjos1Bvt2j0QKYBZNoXzu0cSZmZ1HomcP39Hb5fIQU6xwy1sSDLwMn9B162UzzdsLWDJRmwEuI+RYM324Mq+QjNz6USDxGfl9bNcE112CTaRXztpP0TxH8EE7j8rx4YbWtzeA9OfKw6orcBUunLy3tDXMJYBwgHy7LXTbwZ9sX0UQa6sywslE6n/VRRCnRpcZQPsk1ecqGLzFUuP+iDnFDG7doz9CCgunonGpyFhBsP9ao5GredBp4TJdEWP7sB7fI6NC5uakz4wdoxXH1qYZqW4TWR22Z7GyS4zR6vtb5ikoTRAi1ea6wy/yt8Sq5bc0MJhm4XKFYdOwT3+/+cnXK6otyqmaX+kwE3AaO7KH9lpK5DnOargoRI9hJyTVuVitATTn73wpRBFLIo9oqbxeoE2POitnWLSOvaLZ2iOSHRko4e/tfB537LovBCDyOSsk0lfu7Nn1ssZa+zxYbvK6jyul6liiv9xuYfTUWgEjuWOzqiUMgtKjmT2M6kAVeUks0EFk2/j7aFWYVYGZ5FPiynPBcaQJ87U4jBJrogTWGWZ0s9UOeC03/HLQ9rFiszU8Sv+iUWxFBJMZDKyCsLz4oi2cCVlIfIjZ53Z6uhkQmfs26ubFtSnAWGNS05A7dvllBioB0nyiY35HiCadhA+E/qxd+TnQ+A7Vh/6Yqbu0CrB1RLZ2lN75jHZqeoORw1TMT6O3kx/mMGLdHzNOZxBIaSAynJiq6R48M40P+Z5+1O6VteplhVvZjmcbWjzJG0ni1HKC9bswIJK4ocp8OnEuqpHyfzX7+FRG1W4upvr0SE+vQvpvhPvwdWMFKdFf5iCp1RtBWy4aqFnnTjpjPxrfWmJqp3pm6QPvB5Lj/7tOg0LKZJ4yJ5wm5lKoeQIq4fvfBhz26GweRk0E7O/CxV+I15S+9L16D+lwkfJ8EwG4xyMgr5aIlHT8LkoPB2LCX6Zk0cEyd1Pu96rnHeDXUpVamEI6MlzmjWAzoh1hjFTFrvY4um9e7r60PfLGuuKbM0zHUXikaFWdV4IqkeeKGnsiX1rnkFs2FdwMM0noC5ApaPt0zuCfj8CfrEKbY6FBeqAmi2+DsrDp6ae3K5sGtTNR7dQeSGqSk6YeWqHaZQU3L1YtXsjD6BUhNocWiuQWGLolfYD8C4y0wEos1VMgeFaviQW2gTkVd2yXXBsLqz51/qKW3tnbzcG4G8LyX14D0o2TcnbB+IozhcS/LuyMtoaOBl62bAU8J+IP4asSh6fplrQs7V8vx2YwJE7rU8rIaW2410EbfZJbYGOKnEcS8ZSWOze38QbbQaVT7Hhsoz3DAeYsnEPSAxnXCPis/bnQmbrtXarHkk4STp1ugJwcUmDMsQEYn6nieW0batpSQVbTo5APsbXk5LRa6/7yuVzpLPQI6zy5lw6rWe6JDZv+1O6bgjxJrb7OXe0/oOl8TSmR7jEs3tvo+ZLnay/+aOadTuOUInNjGysYyfeHHjmT7aawrG6awzRphM8P6PcnYg3OvAprPr/FqBt5J8LTd10D3Q2ydO59CXGkqgMp4u3xU/FGIxR3MbATZRUgcG36PN1OEIya9rEeBUbg6LA0R/28ng4AP9+17qNCiPXZ6hnOYYGDXpfwWZ817Fj8ptaoo+TNHozBavM0f6GddvOrkIwa+E+UbYGDgvHwwQ+ta7Sq3NLWvYcthChip9GyF1jRybrJw68WnQ/FNe3rE1Ar61lgDG35j6MNB0uZGb20j4kCErZxWBnci1XreWlwA+OP+2IfJmZoIws3OOsqOPJYmM50Ur/i4Ds2fp6W/x9UnWwD8HOR6pJvLireQpaKefqOKP8620yIyiN8mMGH2wJ/aTqXRBTLom0WwCncNyGeXZKeAP0NuwEprl+l2StBNw5mdioY3JpJWJ5RP9hU5X+QDj/w4rmqX+AQvyNAr6hrQi+Jxk8PjoRXXi5FppVo/GR8Y1MRlO0X+QIiBbh+I7w4DwwxreBs67mdJf2TrLbduXgn5tQ8W7qSpI+A9G1L5RJASBR5r4jo9+bcKoRvsZ6F0L+fzB0KGzCUS90G/eNNNAI+OtcABLw4IlgEkcKYt175VwXQhO4IWimsXqRGByTATaxK4FlrhR9vy679ZbTZCefaoNVapOkeHq2NX+BVNE98isCkSyZMuMjTEqacr0JFeS1rgS+Z7YCgfzbADRl7FpX2yc5xsM7nMfwV6XQvBijyOcvz8BeJSrR4uSbkWZbcSJYxcOKUyB6eZfvdybm6dmv37kjXEVRv/jJeNxAitc1TC7l1VzO/eRHcStafpVotNvsOyuTy+dvpoKDTCzaASTkSrMU08M5opvAn1NyLRqQIRuGHrUEIFyVrdWrqr/RY1wye/P5pUTPGhbncPJji+7b/G/ewD5MXXD6rd5RBJrYmFWPl0HQQYZQ52OonPy1oDStbcHIRCTvL2UAguzy2WS95yoUrHKNy83jORytYZ9JRj9axEkH/IPX3Ie8eNDVPifQToFavspGwHbGXzGXIcy9y8YkL7cJE3/lQqeEFctEadz1qudloMTQo57wz7z3HXE415uFRV8zRVr58LWVv5qKW5412yoKSt44ERG7eoIY2OUlZXTj6DMsinQFtSrAZXqC67NIAfnKXRaokAoW76pwGKRLll0e0JTOL3/f3HBdCgHwb1SYTb/lM1wRhQpwNStuYloYSxyGYGCgAsz/xs1je5Kfx1t6VV9JgW8JgtfY4nkKbNvxSgt4Gzi0cVm1yoKKM8luXWv9CqC32c9Cb8GK8KAlIp+gbExPopZtvOHvlQCaDdisAd7v1kLu3UcwXKYztJ7Wq3gc3yFgPByHOICoCk/puGwRB8CJmLD0vDxPNg4rYysWBpnm7vxp0j7fAkLzxv2l3DyuAbkCLdFNd3ghayG3VXjqTTiZypSQlW5Z+dzK2WaOjRNmjtoR9XViKd2M1k0gLk0c/Zuksu/TOZWWJi44MDVyc/jey7vOGcKFoSGlK8tDXu/BMpWiUpt/pll0OQKiyfrkrHsY1RO5/qoMlooXNG2reI0xwxxlQXLLtQVd3hjayGH14h+5hBsGdjjFysfsxVxtnDAKiy+lJzfYMGJzg9H/Biw4Ka4jUP5dFkW1bNq59xN0PnTs7ZusJtrjz6cdeSt5G62UYMdK06dDTIym/dCKpm6P5yGoQb8tUThwqSR1SEdJrR7Eu/geSExCFrzyRQLpBu34gER5LvYjOi9zWoWUhHx55yEjOiw0plB32Dgz3zospzaLGY0EiLA9DBVqQNo+60u6moW45LoojPH9Qk+J//NwL79qNzJAcfAgEDDBKLIhmnk8Ki0/BX55zh9bcBy4cWU2X0MzAazAY5zIHyJ9M2jImETumih3dxsrTGIB9KWMxNXELL2AhyeHXuI62lxJWYzvr/aBTB2EC2/uz8LfImi4AVyPCVwVAH9zlTTdYJGCrrkn5fOed+k6jA3BGIa/aSzOv7yb7jVD4pquoE/AaqpsHWZhv9nu3JtzlgKBH3LdN6ksBf2KlUHr3eXK+LrHcWfgZ5UUz+p454kkXAhSvLv/bcsrvG3S2UtScd2vrIQAYwH0LxcERUwMPLcyldbb1lIhrMdRPCoJdvbmn5TiaLzIIj4JvtF7dqP6Z/ZRw3zLnAhuDwin82tgZhOdKhTQHAB5f6INYCj1URSSEz6ehysQQFZW3LW7PzWdCVzSj1AdO+1VXhDH0/D0G9rNHqJ+J9NMG4P7kGqFuGdTtsXXmIubgXTwCnwCz7hzLEWQ+9MQhjJ5EvXizzvKJm9YbajLjEO3I1lUkAxEuf5WQkJEEdkh7DiWRMQ29auLS3SK5+ZDuizRLSyzz8JaYUMZX62ThMkOSXHbb+tykF+IFXkPTygBdz7pj5QZouquDZMu06eA0+hi3xKLjltekKq4SttdqMVIWqNMxeHMM+/iVijLvZ9JuFkuePVh0dWmrAlsjyKF+7Eg7I3qfKZ1kQd6AIPDGAI3L6C2x0yBg3DPvkEtDWrQk+hvPWW6Nshaj4rWqy/K3H+y/74VHySt7GKN5vmqoW5ri89Tw58XkKle6X6hesiPaK9DxQFYlCTUQ2smsF41PzaJ5MInJbtw+YOaI1uRFcWJrmxfDzkLNlY6PyPbMHJ6ibfvnTshiKSEQGd2MVE0UjnS/33/Lnq31cGh3WyVxo1YxyBeieSJ4pAZb/hHrWwbvknzkGYVwCxhjbMMJhjPUjPr0NA1f4t7ZywL9oUkX+8HRrsBM8NOjFBOx5yx/wtNnOlwshIOPVwOJOrEdm9ZfxV4rdHYkHu1QTrAQ6NzhBaDr63kjjocHzXFJ1K2ihf94eN+gh7jDaCC6s5YyYzxna/5kFltDL7IDi/u+jpEyOVDGxH1dAuVk8bgCfCcFdPvUlCxLHIHT3ekfKLfz/Q6/4TgUB/5KKeEQf058E5JTr4esFcWYT1dAU4lqxljwY7NU9jgHaN5zayDE4XLXC/0Yr2gr3aHxX4bS6yEp9YQW7N7cchEzit3gu1KdUmfrz586zOgpcNuPVlwQAL8EwujVK1JMTycKUH+4bEEpf+cN2p5ka3O2ttLY9jdrHrxJImMVgLFufBIHokLysgNdOEwuVbl0wYnsv1a40mseifNSGMdIgeGoB6vUvHDCsc8QGdxMoTGdmlhLkgBS/aYYvtP+T9qahjPJiLY/ibNzddJL3f2ct6ncBP0XTy4zO/Ms5fQtU1DoQUKxV0VBlS/oms9IDa6UJcEq0PcE+tH7PmhMfXEqrurnw2AnsAZohu4pD8Tbu335oz2DNn0kkQi+uGTPQnciS4MGHJBXywh7/lOCG3qrNrWcoNAWZt6iOfx2VZdZgyto6erCtGYxySqkustEHp8G3opC8ZLrjy9FDwAlzlKavWa61jJsOtTmRES0wzI7z2TS6pJqEUM1UCVHHXpkRb59b9OtrK9OuGY8ogiRc7eYUOVvAU5CAIMl0eNgLG2ny+w6sToFV6z6RftlbgKTBxoXv2zbhy9sv2GNIF4bltdFx06bZZtnH3a94g2CZX9Pdge+HuhLdwZyu3fPrDw1UNdHfQmy8EcXOzla1xVlr6m765fmd/rWVq1483XHqNQCMOConUaaUPUA0xKB+I4t4LlxhOIHjgTYyl8U7RkKy3UDwh24Uk8B/ngeOvjDZRUdiinH/PVuRJ+LjFM8zmgymdDwaLx5ZU6MPRFsayO3h6vNuHVdF7+cvFfEuDsFa6k9hgQAcysmd+XFfp5SUbW82eMMpwFQ3uK4QpinSorRWDu2q/0C6ia5656VMfptsr7s5DOlh84e8gUpDJI4GzbY6R3Ma7/bmTOmrQ4sJCgLfKE3L60WtmsO7R4Wu8tCIGwRSKkqd5DtRHgk1zuSCaL/XJLFrqJaADL4ECZquBIDa4RF2+h8SRR1tOK9Iy8MXJwa7TYnmdLOBcnlytbEiFfw9ZkbdIs3h/aaksFsg79i7/oZxvJrOZBRSBh/Q5dbPSmLidu6pEpJAcvRtDiqX84ncHlLLMCx6M1yf6kq5PIQT2Mrbs4hlL4ka3HWZdBS/aHQyclh680WRlCRuihZ1sKS6aOkGD3G6v5yEFWtvXqHn28O78hOwXdo6+1LRr4FCYHhVIsoAyBCZQk2RuhBStg7U5MfM+NImtWSzEsjWCUmb9iaf2FT3vqpuJbhixuKeNYK8KNWSpYNc8GARzCZZ70+aK/AYqT2U8xaM/d3BX/T+43h3Lb2HB3jm7Wp7AmSGFLgIJ9k1FAqDTiJMy26mVIwWCStnQgqlncRHUvt0Q9r3QQHNPD9DVoF81i6jmIgdXtsM9IrZ1DhrttQwiVrOO/wBNekGveZdyvNwcB9GM7iBBIcOsw3CiBVrNlghnopOgoufxbVeBxht2J6CdB0wkL5gxZcuH7AUKs5uGC7J5Br0iNlm1hGCxoZy4FOCCdOwx4j/HxXwtUAv0rbKtGUU1+ysXXMM0lWxmDpLwaFrgliECjwToDNawJZbS73V3yHZvaH7EsZXRwbxqTDO9iS42enf8CLOOWS4mJyyjnTU88jwlIwb8n0IuIhw/8kx6m51mtA/6KgAjBuICGyGAF3oc1Azu1QK73951jNhkn7j6cP3vthcHqRoW0a2Tr2he3xU1K4CNM5Y2iIKYP4odEHIk0zxqFCMUIKI0ifQzWliXTZ8neI0IKfznGLn7URcJ8SC+cd4E4grcAvX0spe1oSVsf5vPfAbQlsmUI1cqb8Kcyliluq8ATCk5wkXIoOQgWtOaE8ocT9QIShVmIt8xrTExYDO2qUvoz4Up87nnOIPf3OxyBdaPKYeJ6G+vE9IFAxOB4ES1pj/14scfhPB23w2hGHYOoUP7vttT+/H6V2mVb8Mz84DUM1eXlhk/MOEav40Gb/5UQzFHpX4bXy8SgsdLdLk+9GSaYGy2R+xTqEkDCFGN7r/0tR2OCLiZ9glYcFdEOiIgFSRktXn+SP67BZKe25kRYVdqL0lcW2ovQITPmYhlISvil6S8ip/1kG09XYfEI3CpwczrB/eB2Ws2jsS465XPl/JguNn1G4FJhz5GW0moQDKoqeppWi9lM8ofZULgtbyUtYFEl50egPeghvYuvs/yRWrOeIkapSm0DOZeqA7v1x6JGwoP/vWTxGzl1W6K2BGESid4hhuluT5R4fmuWlXBp61agnILuZtyktaZTOH8238nr30lZZsDhwMqezjQXpL+zwUaKkdIFH75roJkdtAwpvCg08+YTQdgegBk/B6Ow/N9EnCipv9clf9YuH2A+38CJANwZHDYW0Jv5KLgEUZPlnES0rc2uObiQ3L4OEPhErkjPXwkzcumNGEHaBuCWDjvEIIT5Ne3tiX+tq9JX4Mq/9Ehk4v8C34fpVMsNtYir5y6eIp+stoXZXPEEfM1wRENP9fcnropysEki529Ml31kguWlaMJTMMyjJfAHE1H51145DFpRf7DV4F/ZVCJxK8oQmbIg8QBQv3Gp9qw+0UEAbSwbvcz+TQvfCaGoUyvpQwxaQ47ta6D4l27pXO488ysGUBG46f8XVW6qzAejsM6RzxYUESjZrytEPSqjZnaLx7B0Izc5dXBk8FDHxj9qMDzNQvoJqv7gKydsdmP0Y/kNIuulrHzuCswQ9CAstq+KOVxRADPnqYJdm8HTpMktT0/bnDoZU6kzXfW8DB/4L1fJkBvygAfuIyn+DPVslg2jrHenC8/pUjHDPWKaU65ZK7ZtVdXMdUkyF5Hp9NPKYWC5hRCs55juvV8djhMSzrGkqgmw2HEcvdKSwn/q9YTVSXWvp/RyvUqGr0lI4h2Ap28PG05wcE3rV5v5BuePljL5fPIP384zLP0bsITPmM0Nc3uwk6CNnC7bM+g5z1LNF/pYu/nLgKiOtLVLKaXdXafEUeub/DBozRRHFgzQd9MrWbnqt+2FWE1EzEehcZ0CTN7Sk40y4tZv6Glog4ZfnwRb4w0v+C4pTUDOOtnselbahgbtj0pzWUECwKpxsNRL8haN4VbgyNWVWDfVqOCXOmtzeajL9t+ly09PRg5VBWBO11jhFmDZdMOi0IW+BapyYL1HOXJZhcCdjwPLPJOArOTufNHhLYGfhfGPeRv1Hx8jmw8YXPwecMDXvPLnoqhFP8INMdRH5N2LvTT+1wPXCKWZv2dGqG0Gm4oW+dSJEy+eMztbRjjmS2xeoVjgKDGUaxCxMZlNEgA2c6iUrKxihrUp56g/GWR1tJfF0ixDIkwxS3v3kn6HAs4/It3to1yI9mRbmqW+lW/95+qNPggR3uO6gi19TK9vtG/7lgAMVB1FWuaT4yX5HSau04qfRdBoJMziEDd3+xxPfE3idanTBGDUXKd5s5bO0tG0vv/Nteo0tr+9PYrkqz5Vx5DSBzg45aE5UapfsxU0IgdvAD5sGzmsQ1VSo48S/WXpt80b7cllUAyx8yuyGsw9IyWpOmknGA/ndybNDciI+5aFAfBywyJUVbW/+sduBS7EvC0ZuPFyEdXysXrmwC/JUdifkQO0tNk5Sc4a1gePP0zhJgvROospZgypG/21Piv84ecgYH5Qx0N8CywHGFBekz4apt8MCI4GSGI41GiXGLhcRiJP7eBOh5yBp0UOqtKQEzs2guEzV3PBDRA8pKjF/YH4xSpy/XSMAz0F5rQ+sHoFO2vywtMuU57/mSpAuyOsKZ4daVzX96sqvaKZkr/QKBwSS00PosHa7IUrVAZ7Es45uLvhGfU2OgwByz/xlIUhAT8sdOYFxGsbDeZXnYxri8isz6VrpeI7HBlpLYJRJM1ID16trklmyRQsTc/7Qh6ViANbv6r2Q8WHranwnkESrYFrjhZ/oa/wLnAFOLYofKesQX99f9NOD3kUiRLJ+liysgCfKmtcnvqPT38VFL6D0qEgN1cXeJ8M8KImnSFt+fxDpO2V0B20V00Ruj0H+h0H5L38T68ZtyPcRFaRqOfZDiPihKgbzPdoZBh3TTJ0CeuSzdz50uqcMqZ/6k9/bKgFhH+m8nVbqnc1i48gmB0oSGNh4p0P3/3WJEgFEExcF5My6BWR4oU0OM9MQOa2da1YGqL7rzffoOJWQMUIIsjdR5Qclm+CXEO9tf/Ai4gAXIlP+csG7sqDUbWkVQsBH5qSms/Y2TIncpVdzLzKSX5iUkunQHCZKh84i0CaQbmi+le3DDNekt99dRBkDloFfr033kmFT6HZ13meLNbDJoiaAkyCDAThB6QCUhn+9htsytd3DjXI9SCVwFe35iAuaCMkgeCyNKtfBE4rEupLVDzMmL33eG4BFY2E5kxvenIePES+dUZGodxlZWf0cB9v45pnWFdjxoN3D1WQrnu7stZiKe3R1ppPtrZMsRYAkYCg1ufGGyTs4GBElAIpmEq/J4mPg/pyUhkvb8gF/TLwDVnxqmBahJ9JlPhal8IYUctr2jFWg6/ItOCjfJt08jJ1GLu0v81xXE7KDQUUzmbEpYFHKsPk/J5Nu5+Bxk6ne8yKJp75VM2hbPVtFZ3SeDhvJbR7Sfp3FwIVyDZGpDs9JVzkfVaQPl6esf7a7fjCnV6hraZnBYf7IruiBi2dpB7FJfQMt7/sYafJvOCJCHqOw70Vo6e+rP5fNqvInSjEZKfrdQn4OzjZT0CguFtJlhegwyeu/hZrFYIfz8rpVE5SY3g5DGn1cDxrJ/JthTX+g936+sf/VbAMPCr+Nc4assBwddQJKqRTd2lpaIZ+ds0eI/1dl2LeDY/BOrr8sobJIl7+3/tfmECn1u7ZV/drHQYzV11YgRNVTRAnS5aglx9OviTaXleDQ55g1xAHiQr9q7qLMjO1uJ2VPYCwLNvdajUb9y3ASvZ+/co8L1aWrIpQgOWxC/Fq/8+nLJFA3CrcuDFwiwgGC7aU2tLboQwOLePHrZoc+kP6t+ep0kc7vfZPGxSHA0vaBjQTZ8XpIbjmyQ5piUusVfs9+C36HBY/7edwg2Ako+QwivTQc8Bf7l6kwhn3kDuE6hhs4cC4FXLwt+oqOzMsEFpjAGIrjOrKENQ76Ihj/ZqUeostWvai+eYDXF1aROUOegZMOBi3cBpuuUuL8E7MvKw/tZsEroiCfjOZpCh6zsxXOP13brSvdUHfm6m6Ku5kipO2dIp0yyoOu4o1V5ReUoSXhNeAam0wcYF2zxc5qnBskZWvcrDDFwF3BTmEBa3xYaxo3xeovw+nXDigTKONto7c/DZ9Ku0+8KsBZuqeXGL6Y1PkHEkllWPDsHBuIrO2S9CnQnxKZ58pduVwJmfZM/G3ckhiCAIl+y/lGPRdMAxlKTKeyGK+CyITBpt2WuD1MbjjLnPh084IdD//ED0oKpQ8EjpLFbrbwA3yFX/aw+1bQr/0SFVg5EWJvzEf2pV43YXgky8w0Kf9Ao3Bb7Q0vNv3D2pYuh/R26W+M9+lqKmi3idwmZw2IYy5IRAhP+Ga7MX+wHDxLY+8/ehrPVm/b7IwDlQhWCYVSSpjs1FfePOI0C8Rx7xHSU8DKD1kckzna6J/mNgUNnoX170vuozImH/r5qi9f3zF3ZocPTNKNjDXwzMi65t3gfcM3Nw2TPg61nopcU9UjCipYiXtINJVwLR5yzNmc5fKs93Y9jg5EafAM+aS93ffxCKy/KAE/XxsbuSCaEkNaO3GAy6HH2cggBb1178nuKBxRUd9kydzcQBljgsQQ8YSwvE/pzpwxk73UBTGfSPYYlJzgY5iUP3V5bJcOS46aTQtHAsNWXhS8FZI15j5BwC8ygDEbhpgHT2PT5b8duQCxFkQ1R1cUPSSN+JsU4Glte0PrQWvjgB9T2lQiJmH1ksdNcVR8ivPgdASMLSmW3+BdNstvtqEni6MnmIMsag0MZ1khXpmpTk/hqeQ7t9kf5ucX4/yFscTDYm1PoiKGJfm2z4gV9C+DaP5QobXKMyPox4QtfnSa6odOVi2WFKtR2SWx9pO/G4gT+7F9I9iOk7bjHZ/Qs1r4+6oRGk7eZFNsoFyXi+UWYZZHULUmoiOMAJ58Jj+xQu90/L7Rpu9/BrjwQgdKeVK8ebd6zM7BDWliKNYBq2o0kvNO5lxJXRjkU0GFFAxBG04TzY4T4F5dh0wYf8doKAPQwvrKsvufjaQm8PY7fZcnYyaISoNqzwcuNp7Ds3cHF+cBU3uc1AvLX08UPgsEyTX5EjrDh3XaHcCoZZVZDogrc3vKYbaiHfjBoN0Ps7apUBE9Ov0mdKfi+vPS1LJMsvPTlUCC8Y2VLHQmgStJ+JUz7R7FG/gn5prjZ1llHIwzY1qow+vS3SieIsmDsuDT6NO2ijrbNRsHpFW9XQLlG5K7DpwOLD1vkES3Au8wcCVhi6ZHPzt9JWgKofi9lEBwmbQ67mh3vkPNvUtHzEzAXap3zlxyT5EAgLnn+M9/rVR3SddUCRwg/3Bfq4DGQHh5iITUmBs7Vi2m90otU7qQ62z8AFpO2ZzZ+89Wn7Mn3DKZ7dUOfGA/FNWcwi1qA4t49CPfdDhsD5+L4sOLJpi9X7whZodg4B/7uqJKnBYoYRvB7LODsIUbApN8QQGwQhBB5WJVMTo2eHyY3xAfCCiEzYs6pcYmp2AniFoC/AK9VYM+yqkV8aqTytnOrM3aPfN3YSXEwX4EJ9yKiv+jKA8neiiBzdFBTBI3iPdgbS+LhSrmXtXlhjjqk4cd3eVkXaVloaqoHwz2I1XygdQp1R6iBqG2TrvC68+NO6/KB0GtTUM9no79t0U2IYZiUHBajUHrDtwIy7to6e5EbBQJowCWXwPyj1uuNVRxQcRZX4SncMQQ069GODeP7lJ3JDBx067Pksk/7fC5SN22kfFPw0/mBCwUvKQqWBBbxqpj8+6vERDuBKSZfAdeKANqF8FY0teM4ibzqWZL/Qee3dnQTZncTQsABdUbnWfckUSUxBHXbSbcd0iEiIlIVB6dkyxAtE9ff/3aBPAGlXdFAUNJevp0s7nDKrl9kKR1vGG8fxqM0JsJEU7Gv8r3WV7LDJZIk+ytBk0Qq6pMW2AU8uniFXpJsjQ1owLqqtudqnvc5556oSUrHpGznvvyfYuYr0qSXjpJNBkhXVuEQ+aTctJ2sO9pt3+L7FOb1KjhfGcI/sWyOxnJgDtj1VAeukrkR4gmFG0bzWMpOl4iM+pGSFtdp4/SCjyMLfKzESGyOzYAgGrHB9Ikswga+spAd7fSu1qkfcQu1iSgKVEO1WIjhsJFleRmdw56UtFQKWbaf5ycCuFQFz7iNQdHnPOD00sGYwK3uB6BSk+gmIWVpsXkIgngK5m+kh9K6mFRmkRAZ1GVaC3rNV1DObG+IE/VM1ZUagDIz+vxqpj9EQsB2sEDVvYF6gvqQIDQONoYQQF7D9hMOTNq+BrAiSeuYEp/hkqiigJijWPNTIevA8VAFSAeJd/oZgyWolpUk46Df+FH2S3/a8gdcbI2v0t9NyUlvw0qZ2e3AkWILCnlbqA6TdrdtzSG0m/OMQ25OICvfZoC4ohuLLHEfSHDGZ1Kn2mY83jAm3OTenl50SqHywmllhjdWnVR5wmybS31udlBEPx0eEm8k1VRcBo3PjMs8nurfGQ+mSZ2ZpNhPJ+LwKVUq9bDvtRozOJWOUu6kmjccBsuTdZH8Zfvppo7TSBPgs5kYLE1O79XB1luKa0r8bFtJHjqIs4+MtlhmVG6oW7O8Wl1yNsrUfN2GdlfYGpcz9fmF+3rCyymrG0aE51kj55Lq1/OzAIhPvW4fpyViltkjJOIgwbgFyaJL5ql763JQuf9Oxl59+qBmmc8xPHbUNNLw8T4ohAGwxnbVpKxi2crQ0uut/YDFqNhYlUpJUQUt4yM7+d3UdTrr9rpaTLSfnEKwRUa2qggbrCeSSm0cXJyabUfQjfzYHPqOyTCNVItmr/T/BJLGc0ul2z372tlcsrV5pJ2gFOnPe3BvDJ06PQKbeWz6c+Oykp7ERyGSoe8xa1J0tZFMo+nIxdVb7AfOAtYsq5EwFXbWU0BHDmoAjlrdxM/dlsJYF3+22Y7PDMxuce+JwYZYNtcafZW5yDvcuhBpgihwJwreuTB3E5FcA1vm3eNfOe/o3fneXyK4eR5/oVGyE+TAovOmKsOLBqCTzxaSy0rUoyLNo4o35MGkHGE9rK4ZlkruaIuwScL82deNbZFLK9vp9CAoDr/MU4aH3GY7rSwW1ZP3AGm0aYNFj+t0XXn+z/CpYbCoEzqIsFW2TZbQa+LFsd/c43tUjGnx3IllB97mT69nVy1yEaPFidk/n70UMBZ/eElJEOBXAmhZbkSbJTTZPOk7J+uuM1gfVoZHwxc2n1SNBKFqfUK0K68DnNqgkWcyyMASFBHg0j3JxGvMox/WxkGg9sIKc3WdT1R56rYSXIJ4dGgxK2e6M52kGmwdbQGQzsMPeCSdGMYk7WPRwB/+hn1Ev6+rmo1ZuVCgtl+UwIqaAL+nfNP1yUPx11Ex54hDwUIdQGKVtWHZUL3fbjuYIcciqthhpufDg7NLOLz7hTYVQJtX4wy+s5sdQbnx/evDGxYQNjZ9jFB74xM0hAgqRYeqArkF7JQIjdbWnqleb56s2snLzyf6yZMWzg1lg1KXhQVfvnGwQ0+kH1T/o4oZiH4MrK2jd95y7jwTTVMA7aIzBDkKXftMkQp2/weYlvqBaLoInboXQJsOzSb9CqI8BELawfsraAGA4dg6/Or67B/TI+a5MsFRNqXUXa0RyGquxnVqjczvyElUnKyDCQLPcAgzQK/8MvsN56D1Gv3z1lSBm+1o3yKyn8tiZxPxvrHWEs/cGMMYzrDDFKsQmztBoARyDYPr7ynztOMKjYBFU5eeeCnb4PTVre//P325M1Ccprwm8jsrYbqKOfVwhM5HGtprrlKcWZAJfa1JgBsJ91Lr0/0Ii3bpHlVYFmN461t2nDJjZ10fe0IojPoaLECNsWq8HE05nYIFasmNoqyhbG+GFQsjOhrAT1S8+LXmu7v+FOo7j/vRMZieoxTBN1aiqyGfOHFtiJufy+xF3+rLa4La/gfIErvPPBghq+AOohl+IcelKo2grqqI2/TRIDtCgG4CvFatI9+czilmfX3xyp9iMb5FUfK2w8Bt22pqXTwJFR/kUtyEM/wKp6wK3yLdn3paq6Inh3/Jgk/TP8H0E3GwOdqIqXQcnQrRitegYPPFsTXZnKB8Nw+H6cx9l1QoJD2+JrnyjD6t3ZZtSjmIfnMarDWszFYm5PQh52V6RQxOZmcGMUzUDyuwUNanW6KXQ7oEzkjvWnhRzrICMBJz8Yo7ll1YU9IkNy6vCmI6vOsKmjEnIei/oHj7PUz1bXnm7oUgUgsEPsiHFPIox7mWmg4/38xsFiDzL99PpSTEHY/2OY46d+42LhN0VNUO8UcrL7bOFhp+lIigr0vubuJ6opmUtxdZ7b4T/hFt5by7uyTPWq7jMjsgNTrYEvhfFUn+8foE0y8X/RSSnnaw00RQYUVhv+djyiXVSFKnp2/WLZw/hFe2/FAsy7p2UVfXLD/MDKJpSs4/vinxaASCzF49vmZHYMz6AvkzcLZdeK1KVVQ5X8kPe3AU783PT2ELDZ2QFNCPu7aCLK/fHE7hs9rOxFkvF7uSM5/ZQIu+1fVNhlYrCkd8PEPKlu+EhdpgqCIy2xn3yJv+tL83UGjQlxrIacCtJYMTTNSYWHmZ7osRECa75b7xpV5YxP8NV1qKin+FuB+IP0zJ0XIrjVzkX1G+WZYEbn9joaucazE/XnJTkuv5AIMslluuQndtWcLWhaGzjfIKUhWFfJuHtlZmNoo+vLvdrxe2eAgLxI9UtRI/X1BISUk9S26SyMGENsH8RHX4xNz76m+hzStm3glITyP59LpqNisL8d+mzNGcqfrhepHvrAqcdD70GpCcBQvGgo02GlSgma3ahzjyw8BpwOCW7oB/HqLLVJfRJIbarL8/tVkGsaumkQIPOO/0ONoO3tz8R0CWVT2AWdNFhTr1rugKPM/ubJAlHJAHceXUGSQKyue3KNlUjLe+PqMy1K3v/CoLZF8DHJlRZrD6N7iUGgQozn5E41U2j/3IiO0tdYNZxMVUWvwGMR4raAlMEIQk1aO378qXRtzVxpXM4pcOePVzBHuNn85HsbrJn7UBQ/xkPYfxXKsS/c502Cnhp2BHCnT1meULttoBM0AqmYG7tdcABZ/lusB0BZmKPpdJon7pdkSvG5DFrOnEb6K5d6ej0K2U4XvVFN6Fb5K2289JDNBz8FhkYIWus2WqoXDcXXi7sBVeRnHtgGCM/FN0zICqIYJtcLF7nl5jEPxOOHE1e9Qfnx+Wsfbiw+h7TW/wko2pxQXmdG8Q5OJBm3T5OaJfKcDT4KOeJaLhmGtuUR+2baKwXQpZxldYDL/Qk8dPfl8vtE/cMnxlCFi5OFdbdFLgiX1ujFkFREGqZ23ZbR9GrrHKSodKrJTkkwI0jckQP36HIABhoL9D7SDi59QLIc6OuZxES1DHVK+OIpo8R10+FWLewOqMH1mwmRVNheQLgL7vX3MlzJA9S17p8DptTz+HNCdTBsBWowufQn/dOkZ05UQHniqX8mumfafCX9QqYLKTiM64DlUcIWNjG7qcWwCglIlAmSXV0OPu2rHcpDkCKxgZJ82fMAfHlxDA7qxLV7lI9ylQrkxFYF2Yd1Leh1gYRAbMcyvNs+D+qNsSoLRZSE+IwVgYSaOOgPDfPOP6UKqjLCKcxcUWuPMlLgF/shU2fRbKSiNxGTIKMtbiq4L/B3K2u6JXawdAoeNN4XsWKJh1q0s8YmcAYq0CUXpe7nl1pF/4ANpo1zDr65WhMLuD2McjWfcLqzMDozmZPJ7YhS20Op+0P4wvHUB6jISnuF7QFGkKvQkvYWmqrrjxP4dFdnTDnk+0KfEQrDUvq9MQYcpYFdeuoNBCzndkzrJ7ST6OvIx+Yizt6bIVolp0A4mKF45guhmvcJaO5dG48Rrmq/t2HCHW2HylYdIwWWDPQDdHR961mdpTE9rSY2vEe9lg/Saj/1b8qKKga8QPchFqgMBuerslKA7P2TEtf+gPUZkXChO3Cx3voS7CSQYa+I1tL3xyy42l0ke8umI3dP30jOYBT6FrrgEU3XjpzJEOntiEmBcr00MQDeNQ+oYUS2AhmOswxNDyPP/yyy5cmpOu3TkiBMlFFTkdaQL4UokswCSWiG5IlxO7p4CBV4K4wSg0bpRG9X+Clbd32YNg6Knqed8T2kAGpk6m3V3Hj0MwmIvlbDG8ubxF7OQmFtNRDcOolRrkLKSufVtZJBM+yAzwmZpW8ouie+orPl89btANJovj0Etm90gYxwNDtKBdk9t+jRSd2pgO/xIZ7sd9/78RES0gArE3DLUMVCbCEUT+RxxWifVqBWUi4VSSjy+dzjHeQpLErmUHO5NsFSfGDqMk2Q1iWErXTXJduh1vwDtiQrWA//dLPfMNxiPWnbt4sG/u19XhzB/PvlHDTeWZ2mB1Uap18VmUYdhVu9Yepq9IeatWhvFHFpauEd8h6xgwJaC8VKzcJ/WXpxbONh2dq/48pWp/yuOZRoRiKQvOqr698PsSn5ZR1yRaA5VJBCzcfPza73h1SQafhLTyQB2E0EmxvmPrF1EHpTYfWiwF0jXrudC0S4vNLNGKU+uvKZewexVnccpCyp6gNLGI/8tgFB++xpfNpU7QsBhZNUeFND7aAxYSC3tjoLoh8NIpbtkCGsm7HLUZJk3XXoivuFMCYaXhPXVmZvkwxwGnyFnIu7R4REKoc9YH+gaefIajrW2pZVJJ6tEf7LACFVz4Hg4YJEKkc9wAB00acauGe6NJBUCPQcJCNOXtnj+E7WHBPZI6sndppT4Lh1SmF9mLLpYYJS/J/iMFlXSzrMY8U2rkBoijF+jg3/Ssq1T1EWECvizaETFjus6gzcWLZP1wX+72eOcEmY6wh+lPm4dVbmOrfCoYUbDAL8XcNyaQtIMUjvEbW5+hM/nAXwoIcHohK23/huCSLIV+qldoYFstYCqJ2Wo5Jf5InAS/oOoA09nOpOwTMK9uIjxSIr0160SCW5xOFn3iAQadrqVZSXJxI/RhdFwRQuQYgOihGZmXJmzWx5uJeYnVKGPJwpuYPCrXUZUBWKVvc+DmKuitNnXI+WbXUe7mSRLkJHo1P0MBgkbdDiJ3h33zFqztUGLQstgk+siNx5gC79H6CoYgPb2zHAuG5nbJc/y+FVtfpMaND32N4o26B18JIqfhvLCpXqLtCgTXODrI8wFApeLKpS+r5n3pVpuoGDxjDj3DfXs0tuwUeRbkb0jMAtcXQHwjUWvrWmtgOtIpXiabfn3MZOI9GUg9/fZnocJOtsxX7zB5SE/r6BiTcEHB3ZOXsALE0qFAKtwOJ/VvcfND6bKUOKeeDHXmcc1Z3GjJVLOSvB4PrH4g5+8WPX817LcgCpKWoU4xAkhP05c6hDeC6wN+zrNjkVtPqfWAQpAtNP/hTa1wmM4FKSTT7IQ5d72lN0RegyXDR3cYfBV9vLErfBvFRMOk7uVyBi2q9za0k3XsaC6tWJpaR51qf0SheZTwPhPOeeE0yJKkc9kOOoBJuVbVIaVB1u8kM2h9qiqepmof1MTW7IAMk1GUXbYb45JTL8xlYMfCGze3pdNDNIet9tV3F6cK07mplYqE9OCb49pigut21BZqOyxYN2gmMkFfg2o96KXK0mThOiDsXiY3av4E1Z99hyif5jMlP4IQ3+Jn09v4IbTkSjHSlGPHm13KzcJhWfsyiPtVp220P6CBI0hGtgJHvwJR4idsnr/MNeken3mHqP2T+s2c0vmlqWhNu+gmAYyLcwWOoRD/Kgkk826IZoV6lKHViNR8YrDkyvs8ik3BESObs9m4+JovRO7itgiSaewIkI+xMN8BO5YiaQDPF95wXuDUlyxxgYoxaISHd1yRAX/qpIKVjuCu8krG2FdZ8ICymRmBm3yETcHuhqNMndaA+KlG6z9W1oUsnlH0yjDl1nldgNH5KpX1u53XY3ZwcX4trwiU9oOAV7UjMMj8/QcQlqKyjXYA2d/LDE3aKJTvgHJdpE6wsMdoTemf3Ci3tKMsCQ99Hf/1ZYv0oJ4WDUSmXrV3oYzHUypS7OXgyHdEUPKTugVkRHFrggUldrVHyvg8hp3kKM0kolTdX1l0un/PZc2U9GpLImIUlHWLQqfxftUNkGU/MoawpOWOiHiJ7rVdHR89EybUdwLiV1lAKMqd1roHRTLBeYFtpt0H+mfLcOgeJZndyg2GxEGOeDRBolX/fsEOYbAjkTLmDiqIeaOMeF9fNEOQi1qbzITO1vPy7WOdYVig2dXwHZG5DOPbg9Y8Htbvr8aqifalKEQTr0/0QuRjPFm8w9qgJXpNHjMnHWNKuvNPW7qdT7FTsL//XXO1j/ZDhVx90Wsl4fb5b9xphrNvwj3oCVuGxmG5P97wW3oX/5WAmUyGwNM+krswPEZTp7QBvMRQekKyTfjXExieHbG+Q/V0S/jTNdgRepLzOn9htJ5e46akzpUH/s8bRkTkozkDCKPGA8p+9dboXU+b8tBzdW7TNtUxHkUDa98eQx1he8YpIYCRpcb1/aHQkEmwMxwfC8qPy5CznNn2j1OlXCIfLLMBNcDRu66GRlZmfUcRA94QST2NoQ2gjRtKbDjvd57iE31XAlnQ+FqB/7rzYagA3o6e5SVwMEBKkd1V0SEv6JmfeU9RyTJgOadZ0cNvJhDtv9zg2z32Wo6Z69QrY8SqBgFO8NtZXoYsTHV7tgaySg3fHNzxKgP1RsrgtZKZKsUVm4zRcry82aFkkiHSCZzi9mSpzdvX4q9H6Gtf4Wv5KPiUgcA21I1AdFbxnSePz0NtiGLx6LpEiBgP7dTgJRr9W1ivm97rGGwx9DzSQOMDthGevSBtS+6qaPHHQ8p0RZUkrDcEX48L0lpcA/xtt89mBV8rXzSuKRyry89aC2wsl7iTHuNqXQQv+VUzQhIQMNan9qGq2QUzUqamnomEl/E6XipDLA9s6OQOeaLZu8rAk5e8q+sadg0XSPSPFx6JeLd5BpvoOQbicitwVtNLYGRp6pHmNeKdEgb3P073OBJZa+f/eEoFOV+N7bBRBDM3L9oEuDnYpcso7f+2zl2HWne3vQfBZ5bTAEM/b4GY9SgD+0Dw3G2FzBoI/mlRw3c0dpgrwrJYGXZ1VeZGtJSp7lVtV6STWOxIBe9jTpLwST+eZoXJNzkDHr+rhR2BPUBWA8NVaKgYqpZAVZVFapi+JHfxbURYww9esdhptRYQB290cx+lYTjJnjbUFNOwVgqLM911ijIaU6T2QIZC8HJ+nQznTJUewb5FC4QSDXHmyr7fcWbN4GbaH0y80E1VRFkfNtI3z7A2ua6ijSVUSD2BbfbNvnZPcE8Kr1Yju+gPv5hPBHLLStErct8j9eH4mx8+yuloZeYZyvXbMGjVUPQQFMEDY6C87SaXZyqhZ2iisdIsOelPUv0FSamZeJ/mYA9yxYchhX7K+cUlAonKsqkFXrluzSkDvtEyyioTKAaGPOd1e+gIIjHCC7mZjt6hcENF2MNT3fNNjoLHQwZUvhZBArxrmN1cbaUEkMrj1xrql1KrXGLtpq6xyEVHRt2Zr9q/qkV9LRPAvA9OQhqTVWhE667AAjFeX3okYbJEnS0EIaussfkvx44i0GDejq0fmszPPImMCqqpBAGnM8bdEvfxizg1Y2pfAe19IcFKmfSSVRIp09Q3GjBprEneyl1IC7kAKk07p1y7ZlPQ0ckcColZJMSyTfh5b+J+PvFvk0sQSUgFECl2t1RZ4jshqUFZ/8AGEEqAarEARU9hoPgl4zabNDnWaIlQnFJiPTOHDHSrJwUP97aWGbHDX/n7MYaXGSw3JQK8PPGMS0JFNysY+PKkKN8OvvCpFOeehFEdBY1kEqSUVl0k5GAnT5SRe+Xmjb8SgcsBcaI5frbLX0sAygCLGjOYT9mUK7GUtDnm+OjQQtz7dS5BYMVr2tYTaAxK4uUdxi9GeSzn2lNDlZvm5JvB5LtZJorCoZBdPIQFKTDM+dOxjk3NrgHtb+/X63Yoyja27Zc62aXV4V5uYTSftjoHhS4lwZpiOAXrbiUpB9Xkff8aMxe7vKCWe61pKIN3XS0BWvkJMKAVf+CaoGDIJSeQSURkQf31W9198py4GOgh0kS9Jh+L0mQ4VU7BDWa801CtteKlO8jNb2CU6e4LGvPgjwPpc8yfuqmZQTUYp6Hd1JJZQRDBy2A9dp2cdPdXuoo71OQcNR7Agm/lRWFMQDNRWqoD7HAde8563cUiWscThK3XXQ8YB9KFJch7tCmcCoVNKNxa0RK3gFOvRrzr3NsUXnJ1dikrM1vOkssHhOxJNCXOAlCC1vZNgQ+cakp48dUk/f06kTIyhJlDgUMe9oksdOsvB9W5s/awgGIMpgWdARoxOkN83bTj0/nQHueNIj/h6OOVOCE3Jsy8qHhBq8w1ttvgkoLHKOhMEPmkCAbx/BDQQZvjneLgdB1jX1Olrsw21RMaL2cqkFYGtJHQzaGRi5sxIIFMVoo/x2zvU8PDclQ7HNgtUchNsjs4t7hq4Ouzvg1oPoPJnUOeBGcrP6mkWTrpV2ErotPZjGtI4hsdAocKAXGZ5Rgga29sOYWfMmKnG0eIJLACu12bQQ0JqQFaQ4bs/DjVD2JyLK7gtyvijlNvYqf/mzooo1LA3QkM3FkEVUxiwZGatgZRlrzn+zFeNwVxu3KNeLIypcJMPpE8d+Kt3el1NqI1//DKmwTy3XMFcYnVfZa5gQu/3+OS5KZZ18nnCnQKYoZGq8+9CNwA9ovEI/lIzyYfp7S9gQSN6QRK2InKohSF1++RIw6S6e/K46v8VKgfQ4W1p3lSrEn7tDaFy1cRBY7leTTCtFRwFyvpEsaCzwBXwYwizlEHaNzY/hcN/AE0r4uhmmnY0SweBylUJNitJaEwG8YtEZQ4QvQEL+gXqzxu8EwIZmpRPrJM24lEiq8ZUK3uEHeXo7yVwg1K3YrvJRJiO1hnoBANGOOl1H2fYXZgYXVbRn5I3uriAtzbnhNlqLoKgWk/BqwPpF6jFgYOVURJN4vcr5A9h/VRx/Ef1HAEDJstmWiMl1Xh7gmnozygkIqHS5nzy/EF4jzEEmiPzFOljm68BByaT3xoJLSuGhzRLjRz3m5twjmk5k1xucix99fIMW0oBTknL1EmQOTX74tTO4Un7+pUeZLC4OKSdd+RkT1kmsxjU6jZSFjwEtm3g3tCILXj2/x8+jwTUpgCKwBh6+glCrj9TXNaE87V6f6Vu4Uaf/Po6fifEKK9etz5eW8v6PuKel7ffXJhMyV7mAI2MQvntp9ZPO29S1Dln5m071fzAxEVEjCI1MLz4eATQ2wmo3/k5WCaBjEmkqu4HLGRpMrN3cgY5eVqxf6PGcITbU1wVC7SIolkwZdqD0kvw1bzOypwJ8F1z9HH3J4fR5PklNuqoJqKlWJn5CNnYxEohhEygwyPOQO20PNk8vauyYoe0RCD3vSVIKBRhYVQktVbmI8tjEkV7NDTJ9Sne0h9sfY1YNlEquBOgnokQ2QY9piZETz6AhTr8zspX98Tl7R2zdp4ah4Er33bFSpOhGuXTg+s2JFzm1CUJPJEFzYCNBFClvxzf9Ly+nW1SCog5ZE604E/ry/1yHn0Vi1zLSKHO9QISfEKEfa+Y2TwyvOpptI9lRAArBJVq1n9yGmv07R+faQvsjSP9AdCkIQyVreUlaHxWqywsWKEv6tGhvpAAGq+OwjfmqyyKDtqVH8XIaTqQg3iGHEi+Jcw/SEa/k+R2WV+dRouMlovzNeXIofQpJvvtO7TU/NYJTOrSMbooK4Y4P//ZvTXWn6Yj7hjokIO3/eMtL3DkS6iTHvw1JmnETsCcY6kb+ufIc132XsHin80WA8sQJvmzQOi5OgQLgTOaWMaKsTFKOAXb6pdQdxiWNPLCQGl+hkUb05sGkBEVcVwNcU/SRtSUSJqzzuBCCR4Da/G0oTia+BaF31vuspRpt6GGh3rFxB1RMC82saDzaWMJhMVONo8r+LefUMnVIe7wzcr4LAW8kexek6jokAZ8igl5TEwOSGZP/Ijmo1g/QiRqpkRUwE5TX6sRu5+yYo6Dwp+VMpPOceV2bjbENwMk5g7xGdMt69V6+JSnerwBW3LNHY/TRJPeR/XDJjfIhQq5WS6DJpsc4e0P34kx2mu37/sa+16qJ/4y7j0CDM1nuPkAyhXXc1pWc1TL1xdgCzbc74DGr+vyZqCYidUSZTuyXyo9s8n0FNHUIdwa2+7d0rw/JQ2DhK7QETY/PzzqKgLm5HpSk4HB2VczAhdovB2jboO6WDzJjuqema8AU32IzOvw90FO5nX8ZVwSZjtYGfdYHHoyuPdFKITXiQKzAaBvsg2BYePZcyhNFO+6ZVjSdP2qHmdh7Cj+X/pFJnAhVNKK+uv25AXKVqDuKt2gWRFT8jNI3JhkgGzHSODomakg1GlTQ5+Vu0AQjeN/6zt6vFez+D/bR1nlu4gMTtlbCBogRhFMnIdNeoFAqGuukSGXdtQz4QRGn+o9riKwW/Zl0UtX3kCkugqVd0iUEv995FzRSSUmOEv7c4WrLMKhsKsIVtwAOHoXJZ5SNVxYPHWiQ+KzW608XSZcskkvuK3YIAyuDqGJaqID9+cFkv8ONK/PxcC4BSZYP2nLKOx0mcD3r5KpOlvSKIMRns+LbM4oPPpcO+yxytDmJgZEuWSjas1HOwO6kXUdsJVrhY+CSwQHW/z9VU7m73we5VpFW3xpzPoYz4R893czP516GJI9oGyl9qkaVMwahbwVaasnea3/xKd9SWLA116YXu8poAAfEcq/QRX/iVPBpVIyfzwNcFe9AfN1eZtlC1UYGyRUb5x9sGN7IC4RJ30KLOtbPKthD4tnt6QBNc6Rt1lc+I61ua+096dm6hU9QAaC9AmSJNPdwmd5JcVxaMm89KuHGJm3xVGpBCAPHIe58az2zL85sE7MkFaKuk40D3HzNTsKyE6lLB13ytEMmOCyPhnC6ByzvjdEXrbMd7W12N96GhRHmomTrGIbtX7nwy9f6KJoGgRJ/oHO0tpCEz7pQlFaST+sp/bCQOMAvZqnAgckVtl1DQRGYoo93HwBw4GPWxGKeBh7rHJ0I3RpWCySM2wsobuwawT3R0VgF5dEzrllmSCfjQTtC6Bi5zZrMaLR7TwgLGap9tpX/NUjycaMZZ5QfXSGLGA/gb8QwIO44NIWtJAxbZ3jOsBnLXZMpeXlpN5zR5jGZDCMRgBDLilQU21iARxMi5FGHGLP7ONkgUYcO8bJLb51s7pt9nuDp0dM8mDpBCmB83dtr7BHL/t/nXrs4BcPWdC5asjlUg5ev/CNPfstpV50crGfsLu35ZAbuqMOuLJ1ZVulIQShmqnznK27cRJuCBfCM2UYFUNem/9xIVlm3lE5j9Pht3y1cBC7yE6lBLw4bUM36rhHTKxRW1wic4ROavY0jCpGoERm+RBs6n8Wlus8YIbJVhOYx/DZzYvRj40kd6/DjZ6VQAJRbNwFwZt931lvAiIDK3NBNsL17+NVreBi09Y2XvVp48UYfurWr6nGM55ScvvFLY9Ac1ZscHIpyjGoEw7I2ey3PYFh1pC0dv51lkvnYj02bfnolxPMzYGC11UCB4D20vvrOIANehnggbJG1+5SQe+npCA5d5FiGggnud1KzVEcDJfeLOd7nTrnXwenHBoy1Z3mHkBNXbygh8SFOEU7jPt2IEVXeRV6uw3qf31iWZa3tJjgSOZu3RX8yT245AfVQV8CqSBjqUVfMOvQCD0Q3+QDzYO6KKEwLFmUbuj0xZHe8FNEAYtUZi+2plFI4MRL0IYUoqkHAfM2U49ogA96Y+6+yi2Oe5v1QMdqh/DwDBlNr0Igs03U/OJ88REL4I8GG/iqSKYIQUyCCyy1NcrpjvtqI/+wtzXJCN/XMtiO1jlvxlEMT4PeGxABDWk8/GK0JTvtEa18lbWSuw0bI5XMzOjHHZ9XJsP3+LAD/OF42Ca7PnTd9hvC1M2hxWXarkIwREQ8X6oQFxcJi+usJ8vhiV/ftr8X83AJpWlDouiftWhbT+hv6k+Vta8Zspiqq2PhFE6pidI6c7uDasHSEoLMhG3rUyl/CHutF1SAoiHW15CsHBM7i6e8EtwAb5at4TP4gLeVJTE7nXuXAMQ+W8Ci17nrKoMBIxSeNoYy1I4HfC7+VRbVbokj7HDPrGpm/0UHdPlo4Xfhuful6Gw5HdGf41D1bNfQ2+Uu/EwNHkEN5pTiYclQJoE9PM5pLLovh5ku+AXqcjwMSSkAs8GlxbyvQDM66EHoxuIYO+bub7TC8ywEXFlwsqJdylwJ93ampqi9MuiJ7C4u5WMXhhrXlwXrPyt7PoQVe9cf24gW9aKcpQxeawKFWXQ7b/2tbwd4hO3A555r+ygbXpgbV0M6s0L1C79j/exL9204iKW7T/BiOyX2QnQrJuiUYiTMT95pFvSy0dJpZHIzI8Ep5dd5orQr/DhyXW/7CZBM34Wm7t5IWrPYXsuyv6LtKwYjeaasxx2NHls3kEF3fvAsn/mzNDZ41OOkllGRptXacRYCrzUFAEEhWbUjVHbmLaAe7xlaSidrqCUPkre6yqOF/PhwEi1iNA17cWMu+HT0OZs7R9XV1bcIF8EeZKK5wEO2gu+KrANgmRanyfu4zHykGHAjHfppGXpMmtEZQmlvzwX755Ea1if9FuT6N1cqodG0R/vWLTm0idv6YuBcwAW22QOIIRhR5SKztPI4Y/vfX+LxuRhVSLVzwDUba30OqrLPzVkaDv/S0ivxBHfnicYsxd26rkFQVnK8WlFyU+lcypMgOq9savXw4KSUcig1A3yxh6QZCwdB5u6Vv6f7ogUXvg33IVhZH/QOng6eKz5dg5t4l0linwQ4mOP08V4mF8R9l43L3dUl+oihaF/SwJgZ6X0Re8rmXsrEs/IDukU6a+sLTw+77Nxg3K6HfvWh0Ki9UGgowinUfzD9fe8EzequILTmr9MWrXdIXqZgwZoQX0/K4z92NpADDaWKxgU3RH2gHpkKzN3/9J5XiYBQlFuBRWntaoyA3lxf3AuQ0bIzwQ+CCZFF4013B1EGacrF+eSu2wxKdYrqmTy7m8osKZjt8FOqIR/1LnL4j568R39ZBV38VAJ/4a79Wu24r1+PbysfhVQFZtpYTBbrZI7Qh6vmiEIKkm8yyCLJ3HcOOHGv7zkrBtcuMmwRIjmwqx2Ge/QmnwaVU+0bENdpMYh0aV00auLAxMyP/V1WocKTg1wq4JA3NovSpsbuLL2GpNTI54eu81QC06zzMRDOGXtAf4YqmHSlxJ2h49/54TI1Kxoy/zfdwnO0R90vs0cxKUuJZj02qXbA38cRkwmua4e1QQhUxjDi5eBhoOxSruY2nhpIcgfOht+wCYgAAPL9eF0QA9rF4KHutc0HUcqL6cNyv8XH6Eyra940w2agDKuOe7NScy7fxQZiKi2d5RhHeXNv3dIfWnEgRw+wAkCCuCmI9ChOln/1yaWFutgDaBCj0nbudG2woK19NH1Po7PX2bq209NbaAFMBjmEAuppCRRlT8CQIb6Weto/C3I/O+Eh8z9GFiWQvRbICtSUvkXL19hJk3fxB6I3JQeMjxEcGwlteJbJ4cq7EWaj2Mn7JPsFKcZxberj1urKKVj0/Idz9HvPcm5ttXbACk5hnburQTxe7f0nySSmBI+wCu/EB+v5ufcM4u1R7gv9ljhxIXOUMYg2HrrmwRTsysjxtbUO6KKkzopfZUQ8FWynsmJoU8NBp+fCTqiwey4DyQTiEq5oMitL3SxRwKDv/wxxePRm/exmXxPpJT7k9ts4t5KkF6+7RhPIybiJIikdcfC9+DUXMwt21G4kWycxKfcvsfl0CWOG4zYSCffy0x3l4RtlrKvUVNqyghK+K0uO1PnFL4rTyxiGfiqadJ81OuCalim3xLFAwS/n1Mmtz0m5dTEVcuVEHdCYoPDWaJw4k8z6zRubguf3Rfe7vkVz9NvtXvfowoaTXma/Egwlweo/n70siitFL5IKpgOvaWx52XOvnu7X0jGr73mVURtfkQ7QRI9555j909FjzxVDL38WQ7kJ98y5hijM3t2a+Q5MlcFc8Jae9gy8LWN0GBTmv+Flu6Cp77u4J1CjwYPLfIkfPpEvsm8S7+fodM8i+4Ya5eY3mL2EFeFkCQInWJmf4xzSGxTCHAmfXZ0Gham+hZ/yc9cOeuw9UHnf0IdgLgnizA+juoaRWcv9iWjWcSAm6ak8Igsjipg0h3s9JznqtsrTmpWpErVFqao/TKWF8C+eR6pHmHO/3BlrdPM+/rtK2fZIBWWPgqQt3TTqtMbRIsdZUKq8MdtjGPyRkbu3niueXMd0jm2cZOQLVEhxbh4+/ANl1AJVAZ56S3VEl8jPcF5AeBiv+JZWaN3zvtj+MYG3vnRu9kXDHDAs4m8XoiM2Ju27IhFzIMRymeoLdo/PmEyMQ3qVikP+ZPiWtCOAFpiAa/ThexcmHSP2v0Tf7uLwpP5pkSWraS+e76GaT5ecCOdPNP+QVuRd3zznCCVTtxHgnuAQV+MFZfHM71GWD+Zuc7FqABx6MpOs3FPWobaGDiw8a8XhaGexh+Qj6TrFbs9hagGHKZhJN1+uv+YC72wLxLTu4OHZ8a1oWdbfh7nc8z6f8LXdlpiqs76cT1gaQle/3OVwpkF6tCD0UGd+WVDa5p5RjKf+TTAUnzE2FafOQT0bwWjpqDdCGC2dN7LLUkWNrwWDXzaUFRaTr2R3vrdzEHuKyg+wQelQS8J8HcnE7qLofKsS0tjSsbwTgHAV9lv4oU4GUUey+2CI+3Z+nW8QTd+Ws5SEAqIsbvDi1wupczrfIENM/p5XLQTqK7W/xZx2lNvHhKe6dTRwOelBKnNkQ4XHnBgdj1fJTigZnn8IIfP7JrSypDR5evEUGh6Vwl37Dms9/Q+RJDLOkK5G7fO1+IVdT8RkoBZIBHXShSgIigJXe83VAGCFZIng6jQxbWAJ/SsNJ1HdYtlFhRlcnjQcM5D4JroagsNqxwL/K6ihaKGM9l4BDsStfm72PmjmWitMyjHHvwo+uJpCuBIqXnXXaWpE1YeZ8A+R0hAAAw/xHIh5/dM5RMYLplwf0Z4RkhyQpTD109kVurlJTNYseTv6jfHE+q/5LjcB8/UQjSYhE4411RsKm0iOZ0aRrr+/BwI0fyGJkhbVTvTZ6I+lGmZ988iifFQGO9DEXQZh+kmHG1Hih6pvzC2dsAGSiSgqFs+nF+Jz7fFyGgrmcsSKiQrIpK1xzWH8jydFC5FViukdVY5z3niUT1eCnFY+UypDEYzFyyhr09J3GoHkxj6MwIA15nTlFV1QFyiFHdjjSF9tHJkLrYWTEWWVYHs4jSLr/rQ6pTuyY9/4fBpUd3KJ46JvXsJ2wbkhbNVeAhtmEQL7mfO22Q96+RZzZ4TLc9kXW9j/bVMWL5UgmxRHgZAV5HfSRKDPxEyRLECgdxP4bgfCgad1ODdHE1uk2/30rjfgTy9s4Qv8kCoAkYzfd8Y5mUPp/5wPnlD+/zPd6CXWVVpxWl97e9jntvEEOFUDPrFczWTYtW5B7d9T2lEr7aQXejWnqj32G58ldOrE8SpmZPS3iVk0QCkdkG2m7LKQSb2attEhFww+Y+deoGrug1JR2BHl/cRUoFCpKADxWzIa6qnb++Jnakrhi/xjnakUSId8soYoVCZWHK4f8ZXkvYRbwKn1InVkhl+Gxx+Cf5lBVI21u4ZH0PqRPsUVsGSbQl2dNrLvCC/tiSSjaJsLdueO97VlYlN8euI2R/CqnsF71Ubxpp4DeP+yfFoU97f8TA3wTlm+l2yfdUeD28pbSCB2eGavIDVwLxNWltTmbTnf94IhYWJlV+7Xac2lKmmcjjNOWLgiDKB9i560RdaSs+WAPz5fNw/h248zLU2wXvLnzlpbLU5QU7kBylUQkpRcLSir/8X+BOOvBRj/t9aT5VVBiSKcoVHKIqFa4rYhcXgkLbKJdl5CKbmZXKdub0kii4deHc0BS/xUZLOQxJxf3KPRGc3sVDq0VSTzdPwqqV4Q7r2+l3+jo7Jv92q4zutqmOtqqVE3A4+OrfRwGAX5SOQGOKxW3b6JRBu0VpTUQmQ6PckmfNGyVgxyZxxfew7w1PyR2sSiGhnPOs2GMlJbK2kPS6e86+MQabmsgfIj7OwiVsZiDhGyirlCuBnFl9odc5dh1OoYBIFZTc4QdNsgBy0SKYMI2GozbBk4OG8lfxTB0xZeigu5PdaytNUQPgn9oxF2gINFv/BLa7xFrSilh/9DAM1UKTUa8mJIhAa4lfSLYJl6zGOqnktURoS97yf0RQfPZ76wgyNCVzgj9TgN/uoNWQEOWSJUpjOrCJ3MvNubBHyMaL6eyYvkE9xTb6sbqLJNALt5Rf7ACTCwFz8kN5tz64g6hIZIlllxsvdkdUcKRBZo9NMfOTo04RqVuMtbqGvafW0SS+53LXrTHiBwxt+0Pp+629yoWvel7q91VyvZU7bPROuv6C0vAObyaIsLgMKfm8hZplJxdCMAGC7ka+2Kr1lhWCjn2dtI81qvSsqOgkhTMFmtLL+E9uTaOSXHbSUyVbIikfSofY8B2IUCxBjE11T1CzH2OZT4d6UGc5HvXH1nZGAjoyhovXH+yXnJc4UPCAgtemf0u6/4zTXaUdfipVcAOfT0dUu3Nbl0/HvhP+vswqhXeSNlDC8CXMnVYUpFyRzVloJ6qyl0wmp3kg865Rxvt7N65kBDJLul/J7PWyN4F1ffYFP81qyD7Rm/tuX30fgiuQc3SzFXkVuuy/MW463DcAD8ClbJz6a8e/0LfgvATYRwnDMIolLNdHaSNls7YLh+4G0noQEoOM+V6YcGQKPi1/Bw3L8zYrKXIoOY3eNvQwmbeaReRCBYx2I5wjkPRJJMHHZ8M3u3j5d73157wSiy7Q2qgp6cDRYYZn+c1OaOHXRYbwNc7NMU9qj0v9WX+pKqjsI1XrPIbTurc4H7Fp1ospd07Q/MavmYr0+zVf4tEeqKujpuzxslA71DzFdfTr7+j8L19eNYpTTZlJ1EDjX7JIcq4Ebhv8lIqcqmOCqg2mCPjSsgFnL+QgiO+YjJEZUs+eo1vSDMISb/QaMtjPmMrB5s2sVd5joivXUl5K8HHV+I/4RHWYpaPYYPHTfM5LrcccFftl3IpFG3XJb2iMTszONtmhkc7RKGBQDT/1bcvY3ocm1+ohIZS9lQOy2L5qbSuKEa+mCt6+iL0anOCXqowMlgfdpB8C/A4oQ2isiL/+S24ppmMcaRFqjekf8c1ViT77ZtCQSeV0+VahK1Uh4CmFlm9i4TPFlVYwNa++LbRKJIuz86oDEtN0XJrdUIshSuTV3MluzhcUJOvKGvWeZy8vSTmlLeSM+23oBrpMub8A1WUoE/ajmxHaAuYsbLQOIwSvuwSJGAc2v0Rgo7mw+d8nBnyYLDnRkVoWZfS/LkEb8viGgZ/GCoFZTAuMbkTllVMy68qsmCSvfmiJnpzCkgo428GFOJunncY47ilpOHGKnq5r2xjHjuh2YILBgJEhd3+VeV+e9C2aAIRPwjM4M28hQ9Wvc1TcCeY7SnCDh0LiKpNqEdSYAMTi/GVoXtYH2BbaGINxRsrspDe7r6TY03NcN5g/whhOHzr7lPl6MyyKrUilJG8KW7qkmsBf2ZIGeUYBRPDatjWyZ2OL2p6A5oUNtS6iANhytx6GW6bwdCAvQs92LvnPYe5KV7H/6JQSXx08SMI5M9hfbft7OweGAMfCccQMt7rTW/L20j4ZGpsLIAJNPxRa4Fgmct2dYaMDiQEZ3iN819/Gc5zhdqXYMqoieHhGdlWD3SxXGAapoCP6BhagMLgrQUiPz3zU74WMPaFSa6a/QhB33zbgX+huCJlaQNn1spEr9l4REnBmTjPSWmi/NfRDloopyPmZFSbMkYT1pB2SsKA8GGrIPCQm3mHqe78tNkX0QWJp/PO7NOaxowvinqi31h0lnoyaK5A51uC775ZDv4Dr2XHuKxstV9RP93hgPL6tYLpMQgjzIRQ3hxO1eX2/A+vc70273HIzgXFkDmz3DOcUZDTSDa4XodrQ9GmBzLHTgfXly4Ok6Yc4CHyGTlul1cc14c+0iPXEckJw3MQ2TetXGRbSkIymWZeIIyj1QBZy1kwi2vBHSmn1Ej+OjGKx2VHsmIGQfXV38/Cl/aw8vhXml/qOKJeGrJsU3lVhntzruQnJqQPJg6Qf5WcQvu3uxrNTHE3lwEt1hL7CctrAfczAAs/JJHXLZC+y2GREh5z1dT+HB9Nk8B408R2zLjljK1jIKoS9FFei0g7k+mnvu8JV7Bvdp7V13nYGjmvoIR9ciLlbnRu5q08fax6tq6YMZutZgSM7PYUFvShkDeJR8SmsEte90gMIqGG9FPwLBLTYjKhPRLwG79mlAHiccE9w+fXP8PwsS/fHAWyxFeo+1/Df3Z6U/7OXjCf51iLsl4UaEummXlkzLMMT7tK4c/q6u8TfQ5gVf75SKZSA8NJTQGjZQJmdLGOX8a5Yl6++aKHLaac84psLG4RzppBetitryAlpxIGgNZ0CRQLEDKmPk7BD1wEpRptEpgB1vt7D7U3upSFtly7l6cYnnfbYBnVl3BrhX3Ik3jOFR1EtjVY8XpkjbkX9hdh4xHkUWkVJSvZIfuqufQBAIjTrbcRyGrQcN4XwBq+0iV3F5a22B6kPELfnK8YMSeDDaI6wPPsPhg1vxX903tKKFTmBSZdfNZN1/8yvUV4rbqioWLP51PbbFpqWWcvm01Im3fiZKb+9UwlI3xw+9NQuOd0jxGA2tML8tv4/4sxwdOFMHB5stT7TIno/l7JVfDaXPlUlu2ce1y06kOqcQStDwOBzp2nXQ2i1neV9luRJob384IZzn6Q56QMMuAtX02Y5dtboJePYlMEBZatnRtxpgpb6cik6Q60bMEAedNAxlh0iqcnaHwp0yM2sal8in466CNxpej2e6mQleGcoy2Nn43MI5Mm86UygN2/YnzOQV774HzZ/w9ZLMWwLpt8juw5br6AEoVm8HqT1j/fQBeUZK6LtwFBuNtlR1txFKlOVvGEXXc1SA6ml4V8wHCa/WaXxppIMnMuDhtSbLh3iZSbesgaiNXBBcWkHatP/QHAO8dpJVD0TpRR6HxBkC/08NFo85k0c2pW9cQtLR6Y6CD/DrLzMUOHj1z9pI2HnavvgfhoUYqWVoMVW8um4nMXTBBWn20yRK/DVJIUxphPR/9B9bVz2uai5LnWDHK2vOU6dyUtPj8IF6+7zVc2GHnYbsFAHmQ83CNVsGBv1jsov6ImY90A8Zc2ms6ahsqsJXOD9wsHBhj5NYkDoKIBktKBXM9cpzQvihTlZ9AJQyZHJ9Q4AaY7dI8yeN3of6ECWKoqBf0ooGEovd20Fm8eyd7GExpvrstgmwdAUTFsxEcTD4O/YP1IRXleP+ulHQHkloKFt1ovNED6WopQHi/UMFfp7BBzhAUmIwnhxU1BE3nW7hrHIt8DyZeZIeM/+wVvU+L4b0WbTeH8AR83b5Y7PKSyPyHhqCkWhlV82EqaFiwd0ZOvfizOlOiGZXXgQVyxA1TL8LOO60ySj7KzL1v6gXgV2C3YAKMxiinaIUGXM6LlE2FtOD0LnvKpCVIBhYsG43CmKW5LzTD2f7W+NkSYdHHdFbpl5+9pkoQGMBclyHuQ25QgSswS97Rnxyn1t0KaEY/bCF8OQ0K1KufU2JqP//g5d1UjG4AzxEgnrV7UaH+/rnI7TD59Bh9ANr9N0j3R5kw7AtbBdRMbhfhhGwYJmISGJWXwNGWf2MRQlmBB3dzWx95g6DD3hgvHYjg/5N2wJ9j8IJiEKQLobwRy+nmO+52X5EzsmXnZ2+Pgyk+as+VGA+9uK2ysHUt7KOuIDOyh2UfmgD/NENh+5VGBvAjNqYPFndi81SlKukD0N70vWJv/ZMue689phPorPTzy2KCWsuqNcNRML1Ov66ynyir6Of7zeKKsNL6lPPCpS1J9WaSXDtkG8uy3hF6dtwfBGhDVExE1VQntt9ub+KxlyhyW+k63eSKSWEhRZtCvcoQ47g52nSTyoBPyte9VH7Sv/f6jBYNiBi9Z1y7yLVZfb9CLAi0HVktoA+aFIN8CHOT1/AqDacNfUiHXxJReb3ydVASSPGBxfMWg7IAvIOXbZhsuDn7EULn4IFpWCxkvG1AW+z4CdrQXVM7OYb2OkDe9HI96lV52zTi4E+CA75wlcIarrFWIoqJJLnGCSYnskSIH0eHYMNQn5w44aH3EbcsOy4+9PPozE2PSErx/0iveVnPA7sCYwv0E7YDZEnrH9bDRee1oOA387tIPAQUHNxdWD2U94C9Klb7I8ap5eo+bSqjN8qjchQUIFW5ii38pVwgp8G1OXWe5eOInLYpCbNKpdHc8l/OqqHEhijYqbi7uWPh9Vll8OMzaFAFlsjgSK79lVVB2wWx8qggrnNSiBJtkGm0yUfcYqYSxiVq2pyInE5LBt1KrJB1AMN+5hQPTpau9URiyBA+p32rO5qENDQY7ME2ADJeAgpscr8xy49MF8GUiGKLvE+KZGTmvE728hqYukn+OpXo4BVD96j+fV1kqJhl9GXAjqCnwBjz7wTdH9pWWU7QV6IiSeK8r1NMzPYNFZwQ928eA2e/ML2/L5hbWcpg3hi0v5A/cDA6PXXOrHVN/x9tO5twcNq5cGkLohSABF/EV+ovE6SmRzW7PHfEdX2hC6a16f+YLvGzHIfdayd30RKhXnKvj8UomDCBqmzq1U7YVQ4HbVRy1DMVfqTsJyhA55Yg6kQWZSBvtZRsDKY7oQlxDl3kzaRBJdw7ppdPQw39TMhOwF/jP9vsbQgSuk7Ijb3QyiWcdvyhL1nIZCFx2iNpk52mi21wxwYDx/xpWxcLnYI47Ld6jZodw1WNszr0oR7SGdfddi/S2patfnOughWFKMag9ieBszrFWBn/uJSyN1CxFZ7dRrvBYzK0fkLQe5ES9QSHgcI9xggDM/fFmEvHzhkNtbNft/eIX7PoaDyKfP+tI0SNGYq2jDQXqG8wHB/0YHP6eh6ar02EGXlLefd/+yPgY1C26CIqxnRY4eZIyXrGcoLllcS4EHLo8nZs6mLbuVQxEe91f3o2+fQ9XkPyFxa1VUkbpWmlK7zZrntiaUioQxFOz8qQKsWN/wwuV9egt2qiw4bmkmLUuYMZaAfcNzl3K3fm0CpVufm2ja7xUUYEWcbrIBly5fPku+FyBKCi8FTEFkI9sFhiOkiEJr+Ut4dZIQ/HeLiArMOd6FMkLoDG5/rqFA2AolvNJHASppJkxtD06n+zRo/mWK5BrZ9bQc4DKRiBKfCdpFfmrUb9Gv0OO9QVeKQxo0ctFOhvReveMBAQKCC51A6uAKHkXnQxBol9Zm0vRukeBb5hF8qyQo1UcUNJMScib0Y9RC0OY6a8FaYPMI6GGf5BAUxCtPI8KB9JiKvlCiheu2uYJOZ3BALqR6gjMTa4dnbZpUNjP5zQ9Thm1aZMpLQhhMiqYtEJGoBkLKGdYgzT0/jI5Zu5pdVWkgw+7Eef5njd+eWES73AtVfY1J9L6o99uVKTtvAMzs5umlP73sZemOl5v9hbKALWpVZewwdxgHioZMuSI/FIXSO55Pvct3TqfMsg09e94dn7wkMxaQAILpMZCvAY1aEu1RlFa5klgq5588rqpc4QZlKzwt42Tl0zpgjazSpw4QyHfYVdCeDc0n6E5+kK6GWgjLLi4w6at1wbmyjhyoP/YfoYZI+Djvx2inrwrQG+uktPyXGpliGJiPUFWqeg0fJ5dWg0DuGbb0kxa3NRelgm7wQPCh3mce6kB2kRzPhLl6ULcDC15tUW+jQfnyL2SmBoQ8wj0I4/79YDnEc1si/XgfNmcCqE1whB+V0Zf8oIqRhHldXBumdfsVaweX5zaGF7h7ycRjV+cV/llQZ/flv/mQ5qXxNjEVc9Vf40vIQAxdtn25LzJo5m9VvBzCe6CfK1rXsKfKAYxRgB4xocc6olX1hIsHBV1IG4QR6rIDwzGGlOelYUGDP8TjmMvs1+Kaq3wq1nHPs7+6fPxj0aM0b41Mq/XacqFQoZNb0QITZMUtSRp3YLKVTvndPG+A+g8+iqFdPdYk9TwZn6UryglIuGquUtLC6IfsnyYD7dvgSzxA+AFq/FQc/UjGdONJWGult1WeBUXyS+1uUiu+/cj95LI6uiDSak092PxFB3ekXeAMRolmHNKMUY4ybwGAGIe3k4AVK1035B2r/2S5wpD5KciWyovq8hNn6SHALoK9Rmophs/rqJB/Uf+mFkfKS0W8t0xeVo+BTANre5z2D9KcoUku5RIitX896zo9Gzdj1DqETxiJcUaAv4BQ8H4VQzSWj8NqHq1Ebdx6luC2lDUppkqzfIr1N58LdtiX3AYe1gFwRT/0OcYaInjRPtuET8JqLqPS3D2Q4a6TDsK5lJb8uaUm4BEP+Sz9xnAlUBxdp2zj4Z3hUVvjToQx0vt1DGXF2E5Z6aUZmKaI0KisZFI1UsJEbdDEGsG5hhGd4Pc4HBbXqVR5RVG47q8dn1pYpO6RmGx6EoG++lV/6z4CksHnbOogsV1Uq/jmQbXhBF7kOJvh6ARcTrnPmzua9F8ElnvQI6nOf2hN/uV/p1aS0jt1R/+bgG13hqKkR2bam8C9NqvOUjVbWKSALSsQLacqJCCOA7HCXAtlu1zYK4ifiOjWkwUdEkoWGpazxTrF2qHPNnWeXvuGKlJGMwh88/1IHwp8yg/AwjOFKeUKyC8JjCdkKdu4/1AaDSGRxdryOF+YAWcVE4GGBToyIsQGrvYPIW0vevMjhlrHkGU2Qs/uzmEg6s8eNvts6Dh7qNGiKeiJiuYGJwRTFTqOQMJx+Y/hzlCfZ0VHCC2BR81Qp8befKKojkisJj57Vvf/MVPhItNgXd+ebAKejiK9nvfmjCF7GIdXWUk0nZMtg1Ul6C1njOwwhHV+mTTHWfXpLNcRdJNu1w5HMUpF5XLCs6MkA6xIR0hnLaaaVS0U1dwS5OQ5LJ6eLxDQ9rC8bvPT+/BWkHYmL0iVg8iQzSdYe0TuXcS+xckmalyLrvxx8R2xz5YCOQtYMCMoSJkWZ709kifB2hj2bNaDtyxumGTX3XrUUMR/Eag95r/4sq47nzDPUa+IMHknvABAaQHflmGx2xHzStqp0gLC6T5bj38xSDvFCHvQ/kChHZeGo0h72P27Dmu5Mbg518sEs0+3fhak3vuJwkym/vKyEK2eAfFKMtcRtpeWGchhFtFMV0hAnj4uieALOrKdAcr2VLjTPy2l6e03y5FLRgTeFirWS7qL1YNlsWmua0ZrFEynsy71dW/zbXlmPkf96Vpr29XUEqIaqmGn9LXAbm97XLRUsP8E1/pC1i2lrKOZkgYS/bX6Nx2VgLSEgpvqTiEUDbdvU3CPjVwVbv+1p0bOelg7MuBdC6C6Wv+rx5mpIEfBjjepT3lKPnuJsbTPBQESkfbtLP/zTGdMnmIFRuEODh/AgdlXJe2wNITZCxnsSGmw8TpgtGNWdEIJYNiv61GTog1HzDwO24FjBN9vTH0sC9m+bxOH/Z3G0aY6gfsrTSZvLWBt6z4sIg0NpYPXqnS2OmEjPMShS8tTxEaUFRr55Nhp41nnvI9oToOjOgLuNnIZu6Cdoh/sClDP7xQ9JvO31Rhn2AFpIEYVPnuVSb395DUvuLGTYOE3tsH1j4yElUV8e4cB+E/0EYhXT0V7DhGKNjtnpgXJyIrzxOP1GOYbBVeM0t1ba+KZEM7UCRMPXQSMT5IJ+f6flpXRXcDEbnDqAeNGXoEEAKsFnV9vffKp6Gjlj4iSk5tx0CflFpoe2n2uYIf7Xd+B8jG3Ow2abAL4v19iyTqo8zSukow9nqSwimV7irGVPR2ou+Q4Iuex1DOkrmF1uhRDihMXnkMLLiNM8nwyjRBUmiKBpGSoOAhxsVGplWKtd+J5vhXyYr9SlomJWF0t5t0WkPkgywWYDKYA5uZ3FS+YktDGwpdFtzd7JauEBxu3pOPjRWharbk8PtAePVHeRpe9Wy/0nLZOlhKphIHcY2A2jXjaPPR+/+WTMjKCfgi5PM2c+HQRI06Q0bTRVCkRJbrxI4mRO64rOm6n2CWgLTXFRwXp8M8R/gniCDRfA8Os/9o0GvYLIhTdOsv7e+bcFSDpKL99i9bH97T5OGds+JzLJ4GckjHHkyFJjFPJKXwoNEo5UALeQVSUcwT6HjvbG9ACpCIYJ94Tigi9rcz3Ggy3OnQHOkaGjXZhnpaR09FU3H8dAuvceyMRNehPfLN5dBp69HoyCZ8R24qpKhY2D8gpRjaeJ+OmxM07xi52d9c3qXxrDvjTr/WAUo6p2yxmftEMnfVsXgQ3d7FFQ23ky9Mv1ViF0Oa0/3lGVQ0FL4cn9euorOVtiBfOBJ2Bj8rmuUTcSQGlJPcuIQ1bDPWSyoz79hSnGQcgf0pv8QzPUOH6zM08JmX0bp2r704LJdQbWAen59jNdPw/JV30oCpIN1D5qlrm2fPi/guVp8J9HGDTM33hWJV5cOC9JaxcMgMEqyEaEEuQ3fw3sITMYNnpZF7XYENgK8jehlS8D1aP48ct5xV/HuJT1fH9zRi9MLjhdCzVnrbNhjINDVtVf7tD5nQBN0bo7BA3YkaLw0M9sIgKzGgY9/kRe1T7LFBnInqibb1X2lCZvgIGugJFx4cjRSkGnlnOxwXiRKQLZp9L+PjwabLuBiHpjB5H/fCxn/canmNXdM5y8TYJDk39l3YPsv262pvmDmE3mClcdqRLchRhuiHBq3vWEd7w8SpVO0+QJsR8A3LuxsWbMNX43SKnTxmMcZV7uXmqFOe+HJqw9rGnKMbDHUSr8SM6YrNSGWoXCq7ecwbpHLs59lJvpmAbE1m9lPdpAhVZD108q+qIy9cSfN+UFPHJCWyfu/8lKJ2HyY6TS67BRovhohZOQkS3PqB5mVUiK6s42mngFjGKbUCJICq6TBHsANVzgdx/JGE6WNijIHdSmKNjER+kADY5qtZIbVqovjiyv09ELf6I2cSKz0kveuwfhOwp9iTc1OHopcfMoz253p0pI7c7pBrJoiJ8gpleAyO9YjC7fGCiwlhPiv/M0T/22jYzRHfJtPpFUlmzfdLnw3uLiIF+jYtWcTKGS7vme5f2La3E82Pp9w2r4kCiyrzN2uFpDLNy1BgCTUlDP4tN8VzyQe819FPsdFwoeUX5O5yp9CBOLaqCG13VObTUhe64Gd5+FJWXu80VmuNT1Scd97GO/ySrUW43exBfzaEQT4rfm49lReJiVAiM69oAf6AU8yIAwA4qlsXMrhYHfxv1B6JeNrTgEfwDi9IcVql66yvODqZEFL4hMAnrttCZqbeo4+C/RfaR7y500d5BSwIhJLfH9iTfmNJa5HHRDMb0Gix3Ba6+bpHioRNRPdZ9gMq28G1HMyCGROep6wvRqXtufSDdQUb83xNeEZgUQgLZO/3jdcimsA7uqKnDHkckzYo0gIzXJ808YwrCX9psK+3VITPiV6OG3UjfijNNTakT4Qul5ChgMToJERKPO2aRXWTOOzsJ26hfF/0YU6oo/nTBOn65VvuGMycGLhLenxzj6k8+qJsSmPhJ+LzzVyDjoSLia8ilS6K8MzpD2IVxdg+kuMY8SM/DDA86aMQegwE4tUuTg7QgIX7iiA1sogkPmj+K2TngZS7+o+uPYbOVmVx7qlo1TsgIGQkapQgMblAM8RJFMg923g65KirGDrIU9uuuh1zyz4ZV87+5iVxjh2yvyFJ64lcvAA0SK4SrYsz6hCG0O9UNjsXrGUeAQyD8SxOXaoPPcHqoq1Trk5VwZ7SSbM3BIuN7UaUA4CzRwkANFxfYEg/wjFlAv1F4OwqMoA9JRyrnYS7Tu9YAuvVASnPaLvd2RtK0Tnab9BjISkwuPVl9tyaMBEUbo3n4s5DEKFqGvAidQ4ntk6syiTc8XabLjEqJ8WnNpSj8kH/nsxPmh26H2BK+QiSoDETwBO/IdMc01/lD/njDF6kL9h20GYsejHXm6SCj5Ul3HA7dGSzgLXSbjpttBL6hVXhXqdD2vyn9W6akQl7wrbwnkkk/UG6ppY34H0yL+28vVi8EjnAkHheFHFzGKe0s12rgPAfEesLkamkymrv0ygvFgSpVNg5oxCD4adJPm6XeCWzPrD3klcEzVMazOjeZHigqc4OhVC6jBXCygKimWiX9izj2Qx93JbfuDeOWmXEQYDVzfXvmcnljZsBPKw5vEsgvnaC+whre/C+kyBxj2uHNjdL3iVOZ7jTQvtzbELAQHQ3gOak7q8GdGXMDglQyComlFYC67a1ALXaUkCv3B22WRLuKB52OLmy3teRxfsoXtIxtCZx0MA8JvwzYulLKxNIBmfN7iSsnphHt4SkFPWFoRciaUIjneyv05lTaGNlmb8Z//sbEt9td1CFjKi9QrqINW+Mp4Ij+COxEFPRcN1KW57ftK4jx1S7qOgDITFecCJhRRL2ecbTWqfqnOFc6nv13lbCb3EsHPvY6hKhspB+I/ax5ZOQaHCWcMdU9KQcuBltf1WFQOys9mCamsNIAAkGz5WDFdzZPcpQrKp6yERbNQpbS4fptlDwhsZLrHyDq9Cbt4gPw+6prHLpT3/8O1rT7QroqC7MU0rFefmiuTN5Pkj7CVEo0bBENQAGzLp3GhopdQ7RB0L1ONWrSHfV1CDhIuMBLNm8pJZZau1T6o0+nd00w5JkOhPWaE6wNLCs6pEohVOVvVBAPHFu4uHm5Xf6c7wdBG0f6YhEqD4fioQSj5cVYaZCnw0TRr2N6R8Zbb95Rufxe+fVuB28Calvt+zNBCTdB5bai70cOBoHj/ttseLB4RIaWM5qlJd65zYbjlpA1zWfvUURKet3NtMXPJJlqkOdncN9KPl1GsHb68cZ8dowEfyZ38Dz9iHG550j1z+YhD+nyduV/IzVIOCnQixceLtBKiQTcKfX6CiFjffPaRx/BB0iPaK5pWhmPSax3BnvzwGUjhuLrRl/4Q4P/CyUE1YHe8udviwpXvWrVTSFcy5aiCdp8l1Hnk8oTNLPuh124D9tXAbXwOVbaP/fNuoLwjU/acXRMeYihrf6lb9G3RkQV8c6MrMi8VzNzPwPnQTGp77YehsJK3KlcoVPbAafdnNJu40D9N/D2MGMSGzzhP6dve1N9/+/VaO8ouLzw85CXk7ZIrqmWQVkyoLpZmjxPMiEuWQta3x0di2czjgZjWTNgy5ib97QdfraVDzq7eiWOyh6ZjKTUx655HqFuMai8AExBi/yNQAWejwRAgawNcfmtUfX2LKxpbaBP5ria9dD4lCZmtIi7OgodUw4At5OBTm/XNfDlrvhjAUoQNfGTbjjnEQYNEAlega3q6BvcnkjXa2rKVwVBYVB1ROJLQRMPyDMRAa2DGh2l45P+QPIPpD/rqLHKa455hS1dUAetKD7GyuwcM30F5yOLH8llY8i4SWJaR1hXgB9sYv2x1HIKCaxzgyYnloyQpAuadaw7XjtC6YHhKvbo4AECDAtJtkiRLtiXItvDvDneU798gtdzpQkqU6/N0iMDQsS8aeHeyk7I2gVK5ckPLXsdIdf0m3E4kA6OZPpNPRKwbmH+TDL92QSJz4Kv6jeACuvtdMdMCTAsWhV8ErPeK/esZeKXNOqZRtu5c57sneHT7gmZGW2LR7YSq9o4pMsWhx0/VrureekBowhHvWtD94KX7VDvLGrPVmqvVcfgvnjbg3cy3vCZvDXtJ0mSCCAK7CoojoUKk14NDKdpMOrVXNS+zUgXcbWGIKksJ13/OTsyHNPv4Av3jzAVso2C8KT2cso+2QNkGXKpYf8+WQqJzJz2gEMzazrN9TvaJYf/BbTewGz2gvLAbs2JH327UuyHkNmfV78G+RGVyMJ8q5fK08TsqOr0Xzz8zFRE3YeAvI5BwVco50SmavQcCt+axIZlXdhe0Fgv7udLFmR8N3TRRW2wgRpxkFB3EzzxXRODd/L2fJ26pKXOuobS74xAwqyEfe3js7d1F0G8E/0gGTxDMSL4vSzJZfox/IZlNlu4491Lxl/0HhBCRAtW/51xVv39cWj1rxN1q1UoJeo1izIAi7wKnxMcqAmQTVSU0yX0mp85ZWyoY3J7+7j4mYVSJgZIjmrSopiHCDFRwk2kEyDMXtm3a8M5jaZGnfOorT3U3YpP0L0eOQp5ZBQCvG7dwCAxm0Nev7Rvngl7dP2mrA5g9kA8hgV0ys0+2iBdZcRLUdRzw75X0xeGJ1JJaU4bt+4MM/8yarOe1NDN7TrYHMCEXACfq/qjv03PNVlrnc+rdTawYjTDKZ9OgyJwdcR/5AQCuYpLYHj2WK6AkmnjOU5fTVECLdjZKiHxgOJfswXO2VHaEogH6pRrmucDQH3x84RahMO/kn6NGjTB0la3vtpROfokm3V3uCGhbXQm5jOZIk7DXYQ9PJm+ciMz0+j6Tw2XM/xPYyjbvjGV2EhpSjuc+KYfLJCNrMwvrdXAschewnUM+XxHpFsPZUryWeFVSVdKzkms7LIaMBZv254Y8Uirb1SUQOA2ghumHc5EUJQFETJK6AayLKypduTE7l2cNEhpjDrm+s92BSql3Y7EBz7ilfDvekhJZb4FAV4SDlyciRKSxLLsb+C/kkRWXr2mOIeADSRAkuHoIT3JiSWqEUY6M8pOPGSlj+6+XreOcSX0MZUG9P1IViBnKrChFHnXgJNBHHvqAIFxqngZnKNbn4ZP88FYt034EGkyzrbXfWhl7kjE6/lXuQGJ1TSzt/7Xdg8/bSM1ouRPnu294khdtSF8eOBxvoQKSZV2R1BHmtE884SAxseKf0uQGF7GOzcGjN8vfzZOdBbS+BHlFrFXATaVEBRcfoI2R8YJQ5snVpEAjoY/oM1e8nvAeL/v3eFmTLPG/DhDpk9MK8usKQxhPTaS9x7ZcUO56jUSCkh3qeoxsAukwCOZtHHp2BeMBwLd5stogO/u+cAc3TtbfCsvnrjrXkRyeEpkAwyLkEsZH2k+EacEN15u7K30Frl1JNyA240NuPLU2lkK58YhZ6KjepuRGX5LUt0q8y38e91viPTlHMcFkoqWE+H+scitw5pL4wtYCng/j4PzLcF/pmDSSPsi0+Ufs3KSPUi/dDaQjnQB+C9DOLQJKn2dnUQuAI0CyrTMLM3oBHv3eiMonqtoV0kMoSNaR2cvyy/oAMGl6lSfDQMKEN5t4ZetMcPB7qjQrXVbA8j4OIdwmUOWvVfvfTC3fhFUJfff2tAqJpJCvHGMw0fN5b7TjDdg/CFUrAaeYkaQgTEJrDgHYMWgeJo8W/s/JQisR6Rfm11gJeultvJCaiFv+5vGvZvA2ZDB6i6pBC+7BxrtI5iR9EJTp9v77Z4XdEG+kKusW6VoFOg5gxenUcLnWa+lGLbQcOoPsTNhl7Da1dhLHUDxpdB6WkUz6xlKmQ621AWTZL7/CtSextXXUnuxiB52XJxHX6eD51NaoxgbsPdtsMcFy5J72LVrXMyQuDGhj7SjxauY5Cdh9+zNp3cw8+E1S2ZNzyq1ePA/auch+HC0LTA4y5dGLR5QhMWQYhuNoKjd9rWA59TUanxmwg8oFA+c0sL00RIK5Yb/Sbbjei3tF3PtHpzPT9Z3rdO7EX/YxlV04Gi8dea9Uiye4/kzEmbpwMBcXb8j/F1g4iLqHW+Uitu3JMqJiM5IzlSEXaER8mEDOKPj3udbTaLueWPU3bz0H+X0zF8JvotamIACL7pc1PvhAD6jm8LyLXQSLdP55ADqCiR1daRl7xW7pzHBDj1dYroL8Z0X56qkXct9wd2DCkzgjuKwhz61u9LHJPo3vrnaOrGDimjo5wBRvMtOxIiwLyIcACak3W5SWwzKzIDg9wdqolqQur+hTfs0U2vacEI+LGnsarCLI0dz645jSsPJFDWQzcKeCTBC1njyH4UHkrY6AMyGisWsi0RrBU5YYOyPiiHWWa6uWN4r8/YvI9Z/o1Av10BjGdM5Sqcrz5rmsKRoZ7qoJIYL66vQOJx2QN5C5+8AJyGlmNOfZH4yFxkPa0eiGYDdfnlm2mBlJhk9KYb5NDdy18iepL1o2ggsPDqAyHCzttxaEXV/K3zuVU+HeYnum69rKmL9JKknEZsUu7M0zhTyBdEUBXiLqCmAWsPfkduOlkL+3fSkJCdKMQ0RLHd1K0yT9SAksVtaJvz07Rc3597/5JWAMWuiJw0ygXMvkwD11kAmDtylZ2iS+8isSE5Bt9JMNrmIQWbgJpsQtDEO04U0LafFai8Ex8Nuf32tLsV71tyQ1tBp++YJ9rxnoiDrYrGUoCI7kvET44eRoOYbcLreadY9OqHSMuu7ClvUtN4G5Spt/xVMX+A7sUAL+YJdeZNg4cq5ax5JfDXmUo22tvxm9jCzI6f7QGM/u7X3i8qrSnJ/2D3ipqQq3WK5q4Palr3exWGKzM1jruJnPna9Q5O2BltlVlRV5zXKatsaBfGWEnYhBa5ENG8PPIC8uzAbS+ZPho6ngGp5EL8jIawcV3ccCxWAj4mbsjY6/tylLqJcdiPxad+sH4tv6lzWa9kE3SC71tUGf5AHNBex2tNtUdmMZlwW0Cd29qLnaVNHq6rcVOm6ggOuE4k2eXYeIy3VAeznQIwLJFzJnLt+uvEOvz4mIM6CoBMsVJM47lBzTuoV8TWUKtCFO8PHkWRfHTLr4ZcU9mGvgTDq59y/Z4Stb8UU93u7kRIjl8GQFeYGyauo0pDtlr2Rsc+8kGFgw9AAhPnpRfwami277EA0yLhozqNtykLzJ32k2g+64WwRX2xTI7St0kvgeCUX9XWI9k1S2kdyKfYKmCv0Cbsbk3dtd761G2V6XpxjT+F9KNonBQPIz+f+aU5dh9sblVi4oKkO1ZOeJLrIo5ejjkMMELptszKHy53fC5UZH2Kj9vxEbQCh2nn26npYYfokdhLIhJkr/XXCkvFl+q0R2azLmA4vBGY/i3J3gj+mm+HwDEuAuzmNMZMugoCvIDNe8NmY5s9o0VOX0RNC1DC+5ODGX593yWlUDRS3kWWMECMr/2m8F76YvhhFG0Zv9aHfH93NwfOgMoZ9U0cDrShqUE+O7i9eR3pEXHo+vCqSQToE0kgudFXYuAYXBinZ6gXDBkFsdQEhamsHNQfxu8WStVwtndZvR+DcwlL/A7FvjQa73OBSFmki1KgoRiD7PqmWTzS8xxYE8WdIxA6CjI7dbSNvZQXgyZpwm+T1UI1yFK+fN37Nf0I1/dfhQFd+dcA4KbZ02PkFeKFfmNxHkOeXghPI1zvWOXi8vgg9Rfvw7oo8S2mdn6LwljhDmLU0mZ5CK11n16gpIMsDkNxGhLhUZILViJ7UuO0o7Rn/LronydfoxAPyUmSsFPt/8qGtzRZ4dhpb43Cc9rd16+CuXm2dgJeoKC1SwNVFUpZ0b4muG4QZH8EZcqYiWXpWLm881X10TN9palQzY1T+xyPIaFgTLOoNq+e3xwgi2uye2lrdeQxmXMobf6YAc4OXQQ4Cqr3P+X3TEE8s38Qz0QhptJt80WUxHfII0fKQs3q/806Wj2VOZfdZVq3K1Oa7XfZiXquMdO3CV9YMVyZtp9q1RJWzW7R2tIe+9Z5h1pi9/b8fUTGhyhsdmbx21CygEVq+/o8I5WSoMsoaWgxKaboyEmJF7H0psD9YK5crDZv+xDp7UM+G8EgQRNXAvsy/L5jVH44OFK4cTpZXfeOdlRl/WkXbVJzIyiwC0lg1W5kPK2jjdnbiTatR6LQbAUOWpFJRFZWRsR95Fo4gM9k02QxmLlS6HxUZWahyO8Fdgaeruc7kxvAyZ3qYYU9S4m9B18HckOSxu+T68YcPUyCDMTQY7w3oHKrupo98bdRvJhUAyn1WqD7h8H1bLRvBPnbWBHqqL7G5mkU+7KSf7lkN4hORfj5UNZWO/9SF0kdNmZ5JNXX3+aonYRSMZ3v6159XCP1yJXSz6IPNpcSgXWIlkNNa82uSZGaoabjHeqsSGxPbls165yms90yw5Wp98xvUciV4InWf5+WXL+j0OMrKkAiXYu80Eq0Lf4MYNu+JPMXuQ6M377QOdJTnBpQ9LvGpcy9PwUoUUezrHfANovGYsWNOmSICtDwINS/2xQeSArNDFR4XHj5dTOKnUjvEdLVWUb/Xvpt3Z1Qg0rfq5hMUFp+QZJFWm6mzoHj3COYo+5pYSBn2EScmCl5eZ+wPB6mLZ2JPE6MqlSO4Ge7CZl68VSc4NPWgUaHPaJt+1pb9rc48OUNFeZOcxFS0qtCS/c03/Z9HfDfBlvOgV1Iw+k0JBK5anpPBDETUi0+rb3m9urC3U5TzawitMwxiZ4UD5SaSTaJQxcZEV6Bxv02sYsqxnLEUVnCOinNoKiqfQ1NibZhPvmv1bDEJibCpyguETbNXhP2+f4tnAvOu4HLf8hFaVjY6vjCHVh6C4uHY8BG4+kCEZbCZ6fEz1ramNzeKQ+t9XXniukraKvYg67OOhiD6zOxvsw4rZ5Q/oCMBQKFQtWYUK17AnwVIpVHejMATE2dctMJt4vJUvkv4Q3bYkAOUthgVUEpmGZl5x7brUyt/HEFTD00MiVBIJ14Cy6wCDpucyZL1o+OVaSgVrtIX90WWdvbkYW2tYwcLzc1VoJqLh6x01OnqM0saaUuRG75ihlzGy/UI1QDUPd5TSKsNTaApZJm5Zz9Oz4rGHJtPaRm8RFhrlDUkujB4oz/LxMzfUkdq6AIRBN3lXvcn9d0fyVgkLxsPRi/T1BDBISkxOroee/bDp2xLei2C8aYANKGn5J5+yCI50PmqGcwNCxr9D3cI3/qSOnfHUqyP6r7+9sD2MJ+W0/y6Pbo25ldUkoBjwUlM5NiQrl+5MZUqs3Ep7BOI1C/y00/PBt7blM9WNFg+kc1cQvKucshmbGDeruMyZ48MV2Uk1nk0yjFfPv+v21t5GJcMCTuBwUXndlWQEpJZt+47/eyK5cahv8cS9bNCakeHddkCzk5ItP5i6+qP66AW/Xmv/8cvIIqdUG2j2qWsj6KGHpwKBCirvh6O0d/2LuxtcPuPcD1NqWk6Ny7DnDZsLDsd+4JwHVEw/4Tyci1CaKouzH4BGNxKkVOVKkcrFC94l5K+Gxnz8l1iDnUGJc+wfvVpdK4H8Fx7nZnsAVDSOnHGj4oHqKpAtvjd1UbZ/rtODgW1+mICaN9X/00k1FD1irSMQtCfpYIaObphbYOUY/JkJhKhhq9P21E7Dy8sJRmukjBvkRiatZfj2qSsItAG7037i6LPE/hqXXGqyYqKswlJJnSNVfWGxQIMJ0HjCD4B6LLNExBMBsa0R0E20KXqT21bSwKy5HsS+rioVwR3RqYBbMcRVy2g5YDzFevR0Ei9M4aApM44+GRrRiF4+w8rmnF1o0bBxZr8/qVuUWcG55ARLovQ6aXI35j0sFMBdTH8pVd6ZRUZKBxj1IFyRPy1PSGLyoNVayeZqgr6bbYjGbQjirFhqcp83q3qDP+G3ruNEUnp3mhu5X9t3dYnx865AxcpQZYS6AbFzIErG41/e9Ex+vk3QJUg5XQm8RF1L3dfZNQRx8KhDjgrLF7E1DvxmhnJcK3GDT+Tpw6vhx2VLAy/NWwnlqNRG0jNh8mjKURHpY408bf2XPFz8z6wzADx7bTyaVB4n+HY7M91bFUn5s3FtKow64r6esvn/ZTUrwivAChJWAYBdWyo/NItctCUpSlDtXjlhhRwiVZULMu1OiQfrx2CuqCC+q4jipC3Pdvok5oTdGMwUwp6XWO94hqp6PiLzTiiNY4OEm3t2fPNfCfATwQ8fagXOAE9Fq5yDvUrHHDdcPkKe5OGJ9ftx0qKd+i7KUT0gBYreWBZ3duoSlWZhpdylGi5potxocObV/dy/xNnUBDWl2Qe323fbWmSKIt+j1xBrwBD9Pyoqa5w16MMUsqnvdH+4QvER8/ZrQXCf+86wsfc5t+78iYgxjwjnFzhPLzQj91NxLn0GDRfR1fQ0grTZJYa5YWof4Uoz738vVVRMDEuzG9p2y/v/I28vhxzHWV4gCZ5cQU6cf7MoaMYJMFiupAHJpJ5HK69Nr95+4OqWR64KtfIFcHjOB3B099u0o6e6lmYpTowWXF7d6FgmFj8rUFgh+639wwB8hcBumjT1NVSjX2u2yrxIt/nFiJgDhhoMhWJhOH10tLg9Yaht92AWryC7vYMZzRy4h0rcyIO1ZbRD+dLoWxZLKdWmZJL9CoQUX6JjvyKcq71h7tdbeoZdA61/Y8Up2AndEBcLe+DJJX+JS3AZ55asKzeuvtAokGblFiZja1ibKYBoNex3DDlDjnTv9C+0lrbdLHIv5zrUGW5dATClF2ywlLtQ2eqccehtwNYU2kqOy3rXsl0dEkUH32NmTTnK3yQlv/gXS2Wh6g+5xeWCnQ3m9YIwL0kbYjJrevp4rFa0AYHRTxn9vf9/A2s69yPKFQDuzjLN51m3ELts2F4fFh+ga4ct6nOICi032tMm4yzOENaMHpOgoKMkb29iEUXD7aLyfCocGnjDPuP8sF6cxKZdP5zRGG11VjYbt2UEZxezb/VOnEcFbU/+TvYqErm0AriWFg7IOks2pVg2co8F1/HnBXwiOPY4wIDRwHhaBY/SSjAKs/aynb4PW9cagssdH5p1t957a5yuNLRAr9Aiwtnece78n8fz1WpB0kgtN/8bYFOh7rQjSA4s0gQWNnYAJ3gHykOMn/QX+6i10mSgeR1szxTsQzMuW8DKv+uSEfxLZrRrUoyLougTW8JJrZlE+dWKEr0UwSplw9dPzg5ECfBljttgqqUHY/laMO9YM9o0TVPLmMv7yFDt5LwyYoAi67KcksWPO7bQd55YsVGeZbi25Sq8uWGkdg4SBegsFNTbHIl/WU8YAiowgSKCIfDpejKER47h/sDxhcStyAZZMuzn5P8YwQd7eVL3pbuoUVGzh94BVauv/cpEGXE8rVEoQ2uSg0ogF3L2sfibaneE6wzd2NlEJEcCiOo3mUN3brLG7/m4zkGoG9ZX0WJb0HKolePnFqQHhVV5P8/Zo6b1/DRkoeP/X3rOH8wGfrfUNWYWA7Dgu4d45o7e0mbzYiJ3YuMzXwmdW8rO4744SyCSVf8ocjdIjgni+973QLszvFYHFLpcJ6IFJ326uR6ynPeLtMxTc3nU7jLomfYE/7Ba6A3A5aMvJHwau2IOsUHMRgjx6m+DYzmISPCBtY9ljrUqXSy9DKE57Mxamzr/rtNP2xVyAb/4p4Kz7QXeeJa+2CdXdzA2Iv1CiaWl+rbt9lJQ9TKyOciUMHTsrc5bzI5KyeFJ/nVgtPrXp2DemQvIcQAPMEElzLUTjxSI3QCiXyjy90HaTe9ty+VhMJAE7Odh4lUiXbK5T8DYfcNrjtSbj657c4RidfudwqT2UbuH/ZpjkZHdbK9zE6dpIDlb/zgxFWDSO+udtRiBD6/h9Cpaf/0wWeFq2+u7P0NV6IH6Z3AD/SrBGMcwk6MvwgHkNP5wJkp/ZzZKtq7X/XweWXKhbQOWInB/+Bw+CRn8m0yAUCU8vy9+oxaWrrSFVHtKJOqSZz45dAND1dSHM+qMUMU75VqtORVyZa1hvrnxRb6/Be7rVCPTL2e/GSP1eQHKxrhthl/vKKcDg+I4BgoOCBCA084x8SO7wg1YE3VEKkHMyEVSoE3bsnf9U0na4Mm26xXb4frqW5tc1kjOCeJUXdDAMP5I7uqKmjd480clYtzmuYvW+N9HXbopN+2PJPusSkK1jygYZdZmqXPvaxg2PJ71zpBdzb79ICG4+lpu9nhf1rc5lNlfo3oCGzgv+6hU7Z5EYjDUtl62I3d5M++127QVmWwbfT+66rRrV3qdgn2a+DaXoIBctCbv8Ss60XzdCNw0f2byDV5UD/jfkvtIkTFy0jt7bcFKtmuzzY9CrTcLgTLzksSOjyKcJZlQefpmtxgaAVCzia+2kwXyFaPN9cS6VHdhtZTb4MZBhu9mOOf1DeEWc4tQx8RLKXo06Iy5SlqfVynw/nhnPqJjfNxIGz5sldQDwFk+tX5UYzQXGF48I0r4DU4aGWPiyGZxEsf/NC2uBKPZmtD9EXkEUxmmdAneDAbOQkGyoDx0sNkPFIMsURildQJH27wCr91G+RyjPKgBi0f5N6AWUojajLVOkoxC69lRUjEktBTw9GBOQOJHavSVwpo/LPzUDy4XE+PsmIOqlzTatfuGTnX7ACp66SFFVq0W/nJMXN6ZrnuC811ezr8ubC1xPmHtAW3fw5Oxw4k55EV/yQPV86mf1ZbsPnvuLoYBpdd051cV9aX55drgfhiw0kqOD/dg9XdmPrKbkjS5wwluPaBC81JQhrsqALb/lTa+FNAxE3mZELR6/Xzd8qVsM7T0K+zw4h94vIzrP8sFeJY2dtVNVjVRLbv3Qf864ByZtiw+p+/BUwut7ZDd4ZlwqDhz2pUwtCtLzZ6j6GpmXsjF81ToM3FXO60n0HD8xuTFYtmHiNKZUlD0CgDHnSwhjo+KXsXrFuUyFXw1kYAf3lw0n5f/ptXSj3cx032NVKTuUzL8Fpitvm0dWkqYIXI4Ztfq5MOSxcDpuupEFg7HC+WF2iMPPI0xpjyPkUlK/5NoUJplmZsfmMv3Z10O8dT0duYroGVk4ec1n9no4xDKQrmbLqmy9yLAkVusmhbb7y98B1vnv2gXRJwYbZmtIAPcfDiaptLok0rskTpdQpzeO46hccpcbehhPU7AHE78O7s17A7OR/FVSqBWALBVvT4xTh1ehP9/SUd78WaSPPHcST+Fcgy81+hbdMUsLSuxItWCuBY3Gkhd2EC2kStDoEuQP6RzgOJjhzC2VKzc9SUBxt0zhU9NBywc8huMU5bpIU5lgWkq34Cl40CLhQHPCB09a1LLR4CZLiAzJ5JxoIVUD7jM/JGnsYbuJtC8xQPJYBGXbU9XaKmpj9JjuxMp6hf8FDZpMaLBc37dUx0ANE8N0UaGYVsWkgqnlbRPOmpfdX6s6xkauic8MBJPVxN/nQW76ORI4GfZkAwkkwYQDkn0fhaPT8YeJUWxgn8l+763DIH4wOcbyoqfgspNSYusO2qz6NDywvJW0Op5EzQHB0xAx98Mo11WAWUA7AeIsbYQjkGOR6+N+HShHa0XpMRmB4sCdmIuaqO6pcpHHfl9fc3HSrUfthqT9Z8enLCThspMekdvnOepw+0N0AFJoEAWLkfuxY3L8PzafvHLn1chXe2iDCPirfI07LYLkTRbUUTzjFMjdwP0waxOOYEAvprpSXAhiJMCY9ewPm+deC82kRSozeB1r0JmZSdntEbpNZpQ4l6lsW1lCBUbX9kICxTtTdhM3xrDtfDuFXCEAftHuuwa8X4hcmxzAcGoHDJVT2YqGq8qAs8dHuRGIONKNhZ3KitoZmhazV7S/nO0J2PEcqHAwV8x+AuOncKE6JjRhB8YN3q60PXAVfBFjKRxhc7HIaWfePFF73pKFccxs3f8kjhISIxsRxsvvmUek2L81wxl0O1XFcaNBkUh4hfIQ0eWVT41LMxP/P11bkBswc+f5JO2oeCcHOm0rluuMafKlMdPLRgfPJpg5A9EqSVaQJlqrzGEKjpOaXNzwDUpYYqPeEbgJpLzF5Lcl7CaZ21cc3sPqF6SWyYooJpRaHR6iN0nkiIa0m/uZuriyfS/VlHd35v33fWkyIOUYM3otHCVYQB6jiWBquLeCWjMlK2LByb+xl5ErIYShzrWEMmagbAOP2QJR3zbb5ANTKX3+eyxQz3N4uK06G2E3Um8pM1/I0ZHFd+ymfqNW0HXsQp2X7B0aokRn9cpj1WQ7VvQHQifFbEh40B2PmTgF8uDnP0RKmq8hAFUrxCNE7Db06pwnehKIDdMZ5Y/vDS0bbh/8SbTzC0kITLrXh0O/XDs4bWsxAVzfMhEV+laOiJy6IsnR21nB6L0T4lDdg1Xhzi5l2e97q9wCSLVNS79zlDgTdX5tgml9da9KSjQx+Et/MLc25Leex8C/mfsvHWRIIGfEPEAqZNwuM6qxy5Dx8lId0FXvskL8d05hQ8flUhyb3J3DuFFYGPOob+/FV2ugobvJ8/2V0KgpvpTOM8eia8F7Y7UAQALrknWWNaTfHIBQChqVTUDTnYDLcU21rqoy2/+olWg+1+QqqGvYMoE8IQmTSk34a3s4/lWkAizTNwmRYOktmFIomMl30IHmsJjllPAAHouHsooluAoDSE7zTy3bOr/YALnVYZ/JAy2HoZqzZ+1vWqJ5FVzuhI8GQ0qoWh9GgfkWK1N24+P3F3r4WlUtUUNFl2qt38gmOrCd1rJD/vyAY49LM5biIJ+hE11bee2UGih2I1dwYMO614ncFjBM+XUf+s3kgUMH1L4CK05l79Sp1dUatkPskCx0AtEMBW08sRr9eiRmH8IyCDZdoxC1c0Cq8+V221hghuV9XecoP01aCYaGTlBB7phSnpcEuAYYfAcgQFroTraN1YJRwEQL5xwg9Le6rsUuPbHUFTxtXceIyjaEoTzQ/gRAqvLqJpA4W22mLrSJcDxXLgXCge1m74b0e2aZNsY5AZ++ccXRG3C9pdwxSBp1PWzvyDHkoETAOm6jq52UpWyMCbqtrk6MbSpmB8C/uL3PMuG2FzIuVoGxzcXnb2+oRljp1QMvljYsV5KIXCzOQuM2dWaYCgCesnxd5W8324MLSeqU49EDrchXiQr2rOK0blpdeJp79JQ0EOAa6meehDOvIpV/Y2+8h39Me/VMP1Gl9/8ImEBQnltGCTzpbQqUx6uSt53XeJyOvahOwh3xaZtX1pTVMaNNt3vl/638UEzKJB/Ks8imGlu0cuM3lP5/Dj3u+rFMgxViBj2PNbRXxZrH7lWhnvyH+TgRVAiKSCE9sQQ3YsM5vFxkshmR+SNpn5hXjsOcbWZMriXTYZ/P1ty3rb79Uiaup/ZZ2xyWZFfSLvr9Llpl3szuh5WdujUN/WAnFpL4jEg1ruwHjYQoE7VFXC7/7nPTp/BQfAENFvaBlfKHHpTTNtPUE6BfOSfxQKAU1WAeVABQ3mSY8IOJObEdpaHF28pgQhJaUalWh6uF+1r1k4oDJ+f3bUBxmbeb3ku2SVDL/28LYDkJ+uLRCRG7CDaB+5rZSGncM8ye2+GPr5H4N75sxRVyQvkRURqEbJnMkoGnlyK5nilz5WD+Rm/m9G3KEpOjHIVf1iNVi0zN62zLjfPNGeKeht9HsydrqaYLFmtM9Gr0TTfs/1WI3i26uLf1nazN+4D3LZmq4RE1EQPjjXBa9/FbIGJsKQ2azyJcDdOF2MJZY9XIIh8PE852TnSbDrZYeVSc+vAySCelnc7Ah8ZDY2HyXVCdTk9YF4bnH8YD3zn0yjp0/iIqUy0/nbiCRXymbkwckqxvRGsdi8PNG1H9NKlGsC8ssWQ0kHwDoamEGiFAoAr/mYH/njNRjzB3Oir5XRD7sR1A0bxp4OVWgCoXEUIAVXm0mq30MjqLvShWNXxMtCQO/jCxkxFYzgMoMR2e4flSuAj4BDUhTM2asGSuIhSTAKOOsUwGLImNOoSn/MUvcwerjxZJHL6HdYR0NuA4ByXYbXfC162pLcxaz2vK1qNILXugvyvCrhoeIPRMVyh+yFF+aXksyXRO82oRJ2K8eKRf0u8C3QHbD0pEef6LTTC4bkTPUW/gDMvok3hXA1TGz3ri8M2iJVXxj9Ocb6FEs3X27S5DVKdy7EDuQL7StV28aPjhOYdA1Kfch8guw5gdVmu2IcLkq6ESSkQDTd+orKJtshasrLpq2hxcHcMx35SaF9CRmfsFaZz2zxKyRntjoj/cI2onG9vA9baL/EU6B1P2R6hlD7eb7O8R+ASzIctUjGtTwYG+5hGURnXthiB0Tf6cFFM1WKWDfNAb/Uct6OOXI6SlOeiDkxeNW0F6ZfISJBNRCv1rLGl8GkKSQ/MWE80LalvT0JLcqGAB82hUU8l+apgwEaRT4JIEDV4avPKg9hGEvXRlE17cGvMyL7z/Xt4R0gfzhRh4I7UuQj2r9/7sLpLbpDK2dsJRmSGxjwE/u4t//1+xUAklcpkROiNvLbSR8fmf+/HkA/m7Kz80iyXK8Q4K3cv8+GbHU4Kx0rjFx7llRHx6CxzcI5zHdnTCLGeeaiTC181AlLRQ0RFT3bNMeV1+ijuloP2mY5UdHT+0K2YW3J0SV0YXSzgqptdvCg4FHWYHeTxssLv3mQ55AIo9HLNX+gKC4HQ1FH3yNCjtFfAxhbZ/l/zzNndZDdYIbHk79VKRnlmkD/AJyFwUN1ZoeeyhFrssF+yXf/NcJSz8flmjvFW7daC5o2drXFoaSDPtxZGRh5ienK4uGNSUtWxXVSUgHfiBQF2g6nb5Ry7Sk84J/UrDZIDjAp3IsXxrXey+5uh3C4EDiytzYQKII6EHGu1bvgpTNoN4xHEfIUjwDQgFZthBneQD2bIkaxUyr+tFPkTd0g3q0zjmMR4qVSrLUIuAzofK7gOOIWoByWJo8EEgk2WmJKEN47CSPublnMpUoobApt3nocI0YAOmqlaEaOBGx2+Vi78lNzonlxM7q6dNvHamRCWFlrKHerh9lHdpogX1QIYF5QZ8t4QR6udZQhwesnRS7VuM8tyeSaSoWYEFCJbPZxb7kErhLG6ki19Q0s8ss9XGELfNyVnnBQwqmX8MQZJBfD0X/kBr5CZfKr3mm1YVEdyXEklvlPAHuuiHVFbQCsqBd3c3zfWNwvnuMVNofYPNAQMSaCnNR+m41ObzYzOMrJItrT99icEwCYXVlPs7WLvvm8Y/e0VBqwAnAZPkL982xNVVKjZ1RU3LTFDUMwBlk9Su1HmGH5FVsa/Kq6QSec1lWmIk+zWrFG9CfXFlL/H0+7ZGMB2CaFrfW1BfCflcjZocYQHlo7682i8qY32P21EYrnd03j58nPo+xB/qgr7cz1YRN3GiDz1B0dFWTCXUYc8JuIAqb/wwU0dla7lnhlnpdxzATGhXTd3nLxCqR0SwUyW3MnCsVBdg29EFz7hRQzOVHT3e5G/+2dz0QOithjAMabv1/PObOsKhULqWHCrl5gCIZFNQVkX1cYb6AWQ9f0E5A/0xQr8qJlZ/iuCoGNQXbdVHQyHYtCLz6Tp6y8Au3J4bMhRZGY4ha42leLGvwHEciQaPOJDiRsAtjrf1FjbxKkBG9w3Iz7nBNu9nsh8KI9Qt1etq6gr+qMmiWAcr9jvxh2hCo9dJp1L4T+OP3/4SFdnl5xVbefr/ZEMJEH+b+ysWVsQHIAGmIdwCVFSs20+vsNrvdsutJPKu2UU+mxmOFCPaXlmLh/ubyAAmRar4SXDasykkmZn0iFG/ZyFp20nG5vOEsU7Otef/u2s8bYfFRkrXDliUCRdeGhwr375n1Uaggdkig6KWfMFJxTWbHdscOB2zK417ucfDBmV6jNNAlPCgyv1WXMnQ9Q8MlPbwpCFq8g5mK7e0yiRw63oJQOniKCDczb8rSuSI2eJ1fMcNN+2TRbexsuZtyYziph4H/Iew6W+ZEBuqz8eCd8AYKa3uhSAyGd4sQpbacNutxDNB8W0WBLRi/x4bpy8Y6REdcUOYaT9meycIrVzeXDwb4sc77skGdId2z1Q40wdYT3kAmOkJZpRjNPIoPpKf1QVzyS1HYGfiRe8/HZ2NfP/o+qN74SjEfDVghiFMgumgLre4kQ82ALagBrwrJMy3jtQzqCb2P1YT5K+QUXRFx/JsCAvTFAzLArklugVIwc1AiA/NK7K40BZKQjDyqlCXfIAy5b7ZFKBcuq8BtyVrjZiV7/ItHlendY3SUPBs4P1LfkxFxeJqzh7wQ8ByXlIvHgo3loJyMJpL20J19GIoh1dxBj6mXg37C7s8yglhQm9j99DyNh4Z/AeDB3oqZTHI0VcAgK2KHMbyRA+06PbzdVZnUk7wq3/SCJUH0EsJmvrXY/gJoJIt9FUdzObLpE6bkP107RJAhRdlDChOxSXrfBbM+QCpHu2gcB+/z+u8S7MkiyRrKhrvVv1LeUXeW3cLX53Pm6WnZomNe26LNrME3yv/5byZkh7onaga4pIj8Sk+Q75l8yDvxlMCHTIHaJ3PMrrogOWi3+OTolxqBTex5BT4llClfZDJX6taneC701DSoFFeBQv/iz1kSdBHq/1AckOM7aK+tr29EIY2AvXzyqXAm6zG48iq3CfW7yIGdPgXkIyAivqZYNzaFBUJu4A9UOC3NgWGPs6r++0+At5IK6q5mcuu6tQHB8Oo84WmhaiYJIOUqrtNF7UkoAHkT8oZMnDkq1yuRXz7fSIZ7FXoenyh6+DrknTURyuXLoPP426CxhbLnToKGPtf22Ka5g3GeHnrQnS042zenCeEM9Ho21ogZnBgtb30r2FEd8WwkSBQCNStdyr7S/ohurRCRSRGb78VrRvAE88b+kBctJo3ot/sCS/2aT+mXHLp/EJ78w3wo6enBTfpp0r4NXc9GalNz+QBkGRpcHN0h3HcxBLCX6asGAX86CXz5nBvyKpapV91nD0vbklCKAngroausFYWjHcSVNPWC6ZXnXJF7KRceClRCG+Uk34BFgLQ/s6PedIJoESqNg00BgTenBv6biOfjKW8C+5box4H0Cb8+AldOALaFSEQGsr2MBfvnq6wYe3QyJpmOl101porWM0WKqBLGYnanogER3fhCKOWespA+7Uen4qKLEB8WCjyOdM+fsYNA/XCK6TLMPcRmbKLY6px+yJHDFkQVoTKc0wBM3U0MWdzRf+g/fhkMfHAIdfNU3Pdji0r6OmWAuLyrh+b2nn8YzDe40br1s9N5e5W0UMF8+cmnI3sMO6MCfKklxcKqIaiNiFFyGDyFcCAIh4QUO8Ty5XgVvHB4Vipp/6qmTLUhkhceS1sh6gfGPGJxDedJoh9AsM/a8ukEiMpjm0sDNJXELcx+hE7ZBjbV2gZfumS6NpE+Dv1C6IQBLMlc/BpW+qlT111JpAyyIib0dbkq1yNX6MS91XV+G9gUi8xQ00+/kbWSygfEEe0r34LN/pFTTErZSFp+SvK/1dDmKsZd/t+OghPr+P3LW1LXXXBddxgVBzb0kCWAhYhxeZLwFMwN74G5qUTDXEhAC0S2Up80x/8SFKKzW7hCvctlpxT+PcP2r50Zzyu932i6fgJPbdXA3nRTBkp07N9b0qXChS1hYb6OhdKebA9ts99zj9GqZyBSe9GSPkCTfcMkizXxClFNIqR7H+5xQ5S4Dl4/scRsxYyzapE74tNLdEatmQIF+pHx2eky1D2JWUjjl1P/GPZBRigutK4jFaJHwmb4OEQy+XF19wpIm5F1bvGhe02nKDWDDkjePPDO3pF2fSu7SiH4WtkwFJkhzn8uYf20r2SfiuEY6JJWvia8BTvjfHs9k6kUzU1aUdtmahXeLGY6oXxzaag1npOgUz2zKgZGZwZw9+QWRUVYmTtQ0MGk+j+A+mRyTn/1TYjAjfJayPanhxQCFCCOG8dzAWYpamH4EFj8AJoDy0XI4ydkjdRp/hWbkRAUJCw+/8QTL/WztTG6KMKlcoFxg6gWRu3Sqq7ar0I63obXBrV+b6ufuoe8kJ7cbRBVQ03nPsKgKgx0HPCwZJzDzV8zJRCFuRAk0gufoTehtP4Z9SIT1g5iYw5m80P4d7GUuO2trBsTcccD+NsCIdIaq/N+3UPLsstkYacZQfIg3Lc6RRGHSWpwvbkw3hJ4XRz0dz28RZN6pIP/0ux+kUcY7r/jCF7DzSZjXJ0skNZi3MxcjDXWMS9P1NpDX203mXotVUq0VBc2p+F8bmEnppUIOE49qpTBIjrD063deSIJKY8x/biouJqaK00RD0CHBCXVskBUYAl2GEZJnCKnM9WrFtoIenWeXRY3OxGPrRhLjdsECctrg+26UsRNmFNVVORqPg7Pafj1E2j+/GPjn7agaquUa/ERcYGYmSSOVSvbXFSWDOTX25noldfEPx6TaMsySmT9TLhUJqa9YcXmAqGsB+jOmhZkzVE/wkqwmR+34XD2qUaKqbXnlIkKSoq9o7GihBjU8CJdp//1giD8hYxyGQjyRR/Uf3ntCSPWTBL0vkKRt1v25R20wKU5wkUfu6YJk6wFVj+z3gdt6snH3ss05h0Fr0wHvG1ImsFRkp99Gl3xzAL753zyDxTk9AoXuxHZbRf8QV8u96eclbxrTO4x53oW9njDFOOLIWJtVTH83erhiDkqaYHoi0KFoEXd5J8ipp8pM/tYYnIYJBun5+q4NLfROvP8FycNzQj7k1sblrF0Y9YEIV9Y8prRRPBwpwNFvnrNA94Dm1DCLCb2UL7aFPr8Hb5kgquVDj4UawBcOpsD/FlU3zw3um7UAwNEUVbddE6HOZQtQ5OmFlTx6RJzl4t6N4s4UWtY5KsgSGjSVHvfkQHmGqpGTUeE8xCZ/kh8lyhv0PqLM57BMMV2dhPYTwRNZSexs5u/GUuFQsNKXb0RZfOx/sTYvUORUDtQsLKRoPk0oG5OMLKubeQfCsd5dQHWla2ZkMK36o79pBavh0o8TPbpmtUarlmhTSNO5lTzqbB/ktp9VQGDhTwtsLmK7XcUxJwr5GMZHbxd+rx+GPvbbMQIfdgMi0pSJuqB/Dme0Ev31Jcbp5dvyocjLyt5tOiZ3VufLrl/t+22v5DM0LVjZ/KJfQb2/YGGT8QMiHqc1O4qbiPn57oF3svbQktNUCoDQrOeLLHut8BNdP8vUjGrAFaT6ICT+vJZ9nqKvNW5J9QKF0zCc7B5NHUMu6SIt7VGdf4LZNeY9pz1BY8bBHvHIeFv1QOp7brlAnp/KtSiGQCfyR+OXcA1uW4oWdghQLxSoDvzafFOK0pbWR0IZn2+nU5JIUFUXPhDohbRYNbfiVOEnvHhktzZl/JJsKJLLfnr/I2lxeEoRxGr1PLvfErGFrQMRdbcNFiD+GRhytcOHtBVObsqFrW2jjw3V2un8zghvBZIhkJkLjT5bwsC9fWPgNSGcogth15iBSuKgyBHOSpLwUBLbj5J7DcLi+rvpXEGR1ZjZbATY/ITJoHy43VZqC8orHF34CkVAFQaDCl3Heh8JWcVXqgkxLQYoWWco3y/y7hfsk1Bn5hCti9EW9U0nsKL1LHZ/HF+emVbxf+aTfYsPWuv+kgvbnnSQswCzZ6Rh8lvaLj1fIm5ZmZhtRp1Mwmkny1e2hI2XgvDhRURyiTIt2bQHO+Y283D3TZ9Xzt7IGDHPWvyP/LzFY0BrfDqsPLmaQe+hqBnv5n0B12UTm2cNRGaw9i5F9yywnd3L3vAHadfWzkHKMBg5kiCg/5YDB5m3Mg3q7Vzwzb2hQL4At63s6OO6Cp9ugzfpl/hKGzmyYRqQDq8PmzifzwpbSoX19PhsPXQeJi8BvSl8y8O0mNJnhw17a0HkFnqRkYIOCCYj6L2pKPHcTY4zud0EiaFJYIb1iOigCx0Z3R0SD/cQ80/0NV7xOh1nGSMpmqaxNviSr0Y7KRjatGTzJdVc/h7mPQ0VPrLSSzUprqNSM4adj6FApELaSC0ACA/a7cjMKKFzP20vHbWobdyYbqRLoO/NKBHxv7RXvo93vaOekndkEYVdTd3qX0EoprGIfe7H8AWDCXZYYwwuFzNeUbhqBJexoKSEoBWdK58gtXPM6Iy+Qezze8HnH8OMU28yPfSDFsxMYHvdYqxy7hRjLtdjs53GyNm3ut5QpK/87OYoXWV4HB9IyOgoF5hg2XNIqA+b5sg2Ajmz+kyHuH8MIB/l/KM2N9JRygWDku7XPbHNTkugFID7+1RWAaRyxXbCx1SrdlpYQPbDVh0qzKx+OiONpLz/jYoBVNSn/4VqpE1w6C1SCxHadt4m6lL32bh3c35uDzRoUrmMaG4N52EEEbGK9hZUod1nBTaRhgDAUQuh/9nissbhkrDgRJMvutX8isCb3T88Sts5ow2moneRSnGk4TLgxpOglDcBYZWtjsT7z5H5IA1MJWKAWZdls19lgMCyzaRULG3uHtmSAE5H8ZgZj9KmSrEquO8gc5QtbrBJ71UYH4YzvX2UIVsW+6Y/CB/F2gf4c4UqfU45Kzke1WR/cDN8LgPejgMJH6jsp0Y2vNzEV5/g8lUXAAbA48VaGCLUAm8ClqUO+SWqsOd9vNRwi4H6zrGCxGYnCraVz74stgZWUFZcStQnZziToGmf++dIpab9rBxdyAeJUg0Cz0FNEg2t/1CERGUEerTvm6h9I6LRT9m/QvBn2IEYuUe5vb+ZC2DnymcxyjPxYYgFtbR2u+wY17115HoOhQK5oU/+wWiyLKOFFqyWUdXKWfFh5+19ijYHF4jPwkVPucy8wgGd7IVYRI5i1eVoleBgeVPjjvyc5+OfK5MoMhmFzUBd2u1fCGdfLf/0JgPUGTM9bxhpWOF8UTB3dLOpJdM3KkLLd25qjqk808/n5OW0yweVAMEycfMLbUQUGm4GJAE+d42ul2btNV2KooZ20eyAMveiILsv1ly8TFTDcWL5vBNn0ZulL+T5wapDoFkhMbYSysoZrlytjN7F/2R3TYYqJamQcpTQnlRORbP+nWmPLeqbSOrMcASIgjKJPT5javZtCMsw8hfS35TwXCQ5iGu0TMCraTVkehONDeT+ujC0jWU20IXiplt5jfAkU0EvlaTuQyVhRg13YVsnzWT7P7rz3TLg9eibF0QSIwYzcC+9Rcrh9zU07lCkVEgQI6iJxQy8InZC6s59Nfk+fraMQGAv1oRNWJgZ2hhm3yRK6NQkmCUh7Jzy1aJpNoHUY+NoLd7NHoqehd23rNE/E8ipdzgcNecEo9s5vHAAPXrpUvLvpS0HzOGZATVUjI6AFlTC7C0iP5DX0NJ0dOEv3oxsaLCoM7WZTkHwyDEf/x2qUCtP1dHJm2Zc5Wj+XcoeMgnriRZW3mnKsVU0iPXpCgrXUk/cXkdmIJuE9d/wlk/Um631+slmYdsaXv0/YStZw9nya5/F9kvtItgJX85uzMBlPyqo4arKiseGP7Qt5a0blYoJvr3Uyl4ePW5LasgFJYGKsMqjFox6xKDvuFw6Ed0GL0BfRmEV2nx5Sj5In5nE/Zx/P47EREMeBNAMwsDGRnoeDsZMW4FLvdxRa42lmAjW2uxr55euT/c+QIbONb6e97DXsA28GCfi1RGJNnoG7B6M6UvtdcW1V+7wnBvrOiR6qIAqNAmcqSK2q3t9nUG8SGx1LjwjIMofbSBCEiKvWX34+uMrc3oFwTMOzbQh7UUNZBy3pcWcOikg33LpWthYXrJXot1nb74OqhVFL2jZ1ctwobATzHX8NATGGk8gli/CnO44dlN2WBmXBL3k86Z7mjydfYb0c608yMrUfF+TyPE+lyJ4zrX1wGyGbMgD2gc17UgjQP7Bwz9Is09iRwicTC/mIsMItVsS7PkJ/g3NNqn40A6ZZfIixW8CJ14qzQdbfYmjXbrW7NNAQa+JWzjdbrvKSIinpLmrN1Uie46d3B8bob9qaEyehmSzs+NVpJqJTxXM3jyN1VfoEnz/9B8rlYG8YYg4uGlhtyL3u7WlqcFTAhdwkPA3rU+F8Xnpls6cpyzZx8qQpQiTdEeN1bHn3j5ks9po6TIs/oJFI5FTntHLi6cewA6VWugJpZmTPQ0LwWPLoeiqPazhcc11X4JvzYX3TaazUsZGXC4iWMC6J/s4i/TXYxwjfMLK7xD2p/lBH6qozqZMeAZztXb433CcXcAWhLxbAEyam4teR2Xdb4cHCo/9fuRfSk/uofVnLslDAKHYGgPBywgBADOSSoOKr816UTwJQZeB6dkDtChPXskepl6vtSNPao4yph0JJOjAS4jaP4iSGOsOTe5BAKcb7Tr9bcd6osAguUHrlGt5C/diMgF4CwWhB9Ty/Tgs5C2gG0snt3VCQhQJe2bem8tu7v9ciIPxPtNG2S+bWpMkbDU/kkRcVQLOntiU2YDWZ6whF+uF7kY8m0R4dgS9znIgDt6zx+pUfOZ/eY+4vRc2SHHdNm7J2Yni6lHDoAPrxpSyXJsN1YqrZBXAQhhORFct1TbKGnIrTL+PuUezkMUdZRZ5OPgwoPUOm+iTN7yXDphZkObyNscc0zNM7rBs5t2kgp+pbF70cISYpvwGk2BbirytuN5+1kbvqvPMEpDIVKjjqxZ4g21lLhAhRznTS1VesmcaQjvpD5JgKtHLCFkktCxWJp865QaGd6Pb1qCw5Z07xcnNZzWArv+/csBBSfMQpLQljJeissMa3XnwEdNE1WJGJnmTogat+ueLSZW4mjq9K9Oe/xShcehhzeUNV9wxPs5hbmZ+zWcX9QKB+T2j3wzeW4WeeJvdXFytsBwZcP36sMn3SV6H57Qtvq0N9eMHmwTDIk5dSsJcBH/PAPs0FhYTUp9rCYPdgfXTtgsiWKxXjUgLBi0LppUAnyPw3a05x4od+SXE3PhyNtMHfVI/bpGVgoMMofK7lgvrbCSqyLh5S4qWZpeD1+HPP3D/4bsXwKq7YtPmggUoWkkaIcNIoZiUytWMPI+2WwE0LNKY+VCfovolF4ic5GSf1JJ+/QOHtmuqDqBHttOtR+Za+GmN3wdqbc78ENUX+gQwKsRWmOcx+DHQWXwxLdoAosDfwpUZ0lGSH1iF2ItpsCXIOH4G7WhfjiECRr0fdP4euF8fsYhiyxSSufdtarUSdbIP2/XQ3Ti3aFTvUl6ZdeLrdZblUXnC5nGvQ3jdxzETMeaA1908jh5iOy9060X0U0Sp+uQI7oDlCN9Tcjo/dnrQNAw0P60ytONc1cnJs0tqNo7ZIvJsT/8MaNaJ86pE1q+TDlfNdDv/zq1U2vuBh9bl8PJmsnlMKcVq9rvR0A7l9+x8UhqU17EKq0LjDJeAJ5RqQYH7+uy9ZppMbxlLYieiEqet7JB/NgMVJpPSSKawYjMm4n7DX36IblYLRXtiM7pFZ5+PTsBTTcLXqcQEyQvqaE3dmDq57pUq3WPOMQTISGXhD1i2w2g32Wcj3ciyvF3/8jAQ1BIJ4hvmlBTt4suoDpmFKruLYJAU/JfQXugyiy9IbfHhhODMulg3jCFANz2u/ZJoxhne97A/pVnHniOm+ns9BZCV550yp/sKpdYnNaQsEDPdNytXWQ9dMNvAiYSRmav+NGeUOHjl9b/GqVu2XjJnYJeCXb2Zp8A6i6E6lViZoDF9NsOX3nPTrcen9JIbxJ/IMrM4xqwwJdo3G8oEsFJVTC8x2akAvpN4Q8Ia8I9RhrwmUOkdEYO7qQfzvlBe2hku2rildL1V/wKmK2CHqq6McA6xQpIqjpM7cxxFDiGGWNDaIHZnPhhnhnUmQtr2/IokfFIF0bLQbyJsz9aHtFU5VUgGtGX3gE1ETdZ/PWLkXfpd27SvHV27IRMr4TJkXW5CJYA8be9w5v0UPXETr2c7l+99Ca64a3YFpn4LW6wsZ/Sf8jBkCeHFtFeD06mAjb216P1X3S2H5fzXlRK0BZeWKLa1FbqZTkLSjvGVvdb7wdAI5QdikyO5/+gmKWNcW0KOmEQbgQjdFdH2JpQ+h+swFQpUNTJnJfwuMSbRIxZ6uWclLqi4uH65HsFL9W0T8XprWgOcesoB90vNxaZE3VyiN/Fr5jYqUHLaXgdofBGFWbyNYBJUz8pl1qEjZXsQwl2LhDIXrFf9UsnDa6YvN/dQP21OlLKcg4s8GKsgf2elkjH7r/FP0YgVl2aiFivPZQANBGzKa2iFGCFknrg6ncf+2jwOSQK/SRFGRhCU+oNICVDyfE2myRYbWb8U7RC6RY0gEsXH1fGQbCs0tQa46kxsXHcfbUZ7p0h0OTN6Bcty1QvcqaRwXNo8jnlDyt3lrG2LM7zDa26qgJgCXKHi78QN7Tq94r99NU57xIOrgMor2O9BnJVevuLN9ZFmpXM8MJb/PBzbxeeHTXXCzQoCBi9RgWgivlo8gXoRE4Bq+X0GeZg9KRAgaZglPbNFb9fhF6JuPefUPw51e8S+u1XEXhOzOMFayT5MOfYrctc4WG3XE8djyEjue00HxumXA70Kri0tc9cBmNg6RipW4L3Ic3SSraYfc64yvRxCF1Df+xLIrvV3GplAvBTwu+sNGYWgvrSNb/zf0fEJsw9wXp/jLbTTXVQBXpDPYKMhq22AI1/LoWKbXOuQPJa5kqtTUq1KRqHBTlHmvZiVYqLVo/7IJmeMPh6UfhOBbV2RE3ZcZB88BQUZZekGFjJyddK+tcSXUJJqfsH1sQ9Pocr1sp8vUDvuGFOh13ckFt5TUUIfqT+EBwwd2cfYxMxfCPWENd4oJ8j90fskJ8hmExh/CXTicXY30Uyt8RdHY8WRQfm9rWH8hyv94S0xicEemAxg97xOIhPy4fMWFJFZzfuNy8rCxGgsh49kp42L06QmgT+tyTF4Q/JxNpPPdGF5yf49RZiADTvhqk4sHyC9gI9Lr+tscUGYMR1enaoc/33oZtcEDcwLVIu0kOtYrd540OuL8Ww+HSbv0l5ZFVbuSaFHs6nqPOFsqFvBq57CUS12uG5q708KFKIVHbnIT8IH8mw2BhHGrNn3LxdJHfW97r/Z7/3ZDantH14VTjE9yiQveBVbuZ00pABI7o2foOI57GJnWZVnru2N/xzAuGhsIEu3/qhuThcDHEm8fVxPiBybSo5PWGTOU5ByWRURM/j3js/rSRlnQxsA5kgU9kZkI7WIYIK+ahcJeuwJlfYSUnuK+wE7UTwP+reu3FMb2VAnFRR7zWy3DWDTabiNIrCxI77b8NvgSiz2sKPFRFWlWwVSZ4K4GFBao7ZiJki2qhsD2tg7/8gGESA2HT9rPBcelK7SEbXN2NbMC3wO+jJF7f1NXA0CykT1gyDVmuDIBUaPpHanJQxUCFtrjBuC0ydMo8yj3q2LBWj4I8CaQHrVw3JEHIN2LKdu/+IEBnuDS7uyej0uJuiA1RxfHF8PBSVrOcGiGnliQX6jtPfkbyPC9zrZjg2QoUUjYmTvTCFJjX31/n57UDb2uOxSNNOx5it5Nz8hRs+zYpMVk7f+RHwBftvndyWp4rfKbjpow1Vf9BSUsufuO+51DwMPnFVkCZy/VeEewotjFIugncLa6dT4cvxps8jC4E4wNHQ9GTx8wigxNuMQvVpxIYRTYDCQ2Lj8FTQUVXon/IJvLNTQ1IK9P3RCnUUC4vmSiZyFYhZWymtjEdWKylAgV4gEzQ4Q0HmcA48BXDhkIfENZoNQjP9an1mnpBoBAPazT3WuiXvF6qVWZezC73yFo+iS8vUw/lubTgZwtwByY0MF8g7VRZ4NDL3Ud0OfLFkqoF5LlJHIq1+tcVFVTRQwoHEzt3nSYqizpDzhXPdj+drT3wGLLRShzS9C7vjrTOgKQBeTOR7JCPJe+NzIOaPSF8h3h48bsoQxg17p4cFp0xQXB7jNGmhKP8RHR4u+BD8/sc0dVwHA3FQNwxlehGfQbJZeyiWEffdDszgJqnz0dXz2gdbaT+ANciQcC7dj3WfJ9F2pg0uTnqOhdt3t9QCO7eu+BSRm834yjO4MrlJ8k2kWaPJCntI4DvLkPWPFyZ7YWzjyQ5zk1knC0qV5CW93+4xcaox/O94/C56R3qskzAcfHbzIhJFd7QwOA93QmH6lBc1cAxOXqUY2wVN2oGJuwGMkyNKK+wgnpxbtqfmO5yQ43PlZXpd+uxJGadNW95PHnHhro72Py3EX1Xz7q1nVzvXxeWZ2a8W+y8aycKm2E6v5vF69U1Tf8okd5Sp4y6G6Z1/GDP3JeR2UNlsD562V+PBDbxPHFtNZTrzXyLFU4Nx7wljBqNkT7+Rcz79n3DpCXtvxM2jcCCnBK3ygDzRMbxeGGKzJjkXzK139T2yjVWpi/fFSADuy+Gqfp9Eat48l+8uqtWB0VPcgMvK+jEbUkJCI4Sx/PDgWGxEM6H5WNOmTTgYy2jsToKcQl3M9kLRaV3r5jAmsLn8oTxKrsrXGxoqbTwu4/bYfxED3e/q7gvYF1eO3Oq6/3ffkUuX8wwUmqS8NOxGWFgwftVSLU1ED/1/VYwyySAtCL9HR279MO8OjUrFH4exhsdHH4UsJm37lC0Jd/aQ/jGC2do2xSniXEHHmgyeupd5jV7UAQyq6xuqymYEse+sSWU3op06XRKe1B3msM7czuev7VRt/+jq+lxF8b/wCuv30Ru7KoU4vd1LceJ1BPj3+OuEdiokEoFe49W0YsE+6D+CUt+iFpvyPG2c/rHLTjvZfWNUQp9h8lXcny29w6y3ZjJPZFGdbKich10sa+/qOZ8tlDVr/TAmIDD3TAgRFt+EK9HM5hf8v5Sh4d9QyUGSgex3pTMAEvQabHnuGHqkDhhHHT1XSoV3lMAPzWLMqNA/wZvPzGSFz0yXj4sZ7NLyKvg6pAhVCHa8oDp0xPk/JJ56MCRCkic3bwJLClDTpbnTWXeWjGxZJb3FsPXFG7fJ3BAfAkzCk4G+0Gozqm4VadISyC+WlUY6NRnsRslsDoSYQ5tZCg7ape4+LY0TLMgCqt+ilS9Frk82qeQoP4c1gIEdzmFFOD5R7WDaO6Qkgummv5aqk7jKIJzwCHzpa8bBpT9LBXsNVDDXUMm2AekGu/dH68nQPjIKpo9ea3vFwMWiSpNc4UeK6tKGaxM3E8Rsi8puAd6el/RxpdZPm4geUVNY07s6lSbYAiWl4geCFZVHOX7aTCHFYJ/bdmVFiR0MqSwoFqu5V87MXUoe0i60NHrsXmZcnKY5riG2VfJ8WYNief8F1ArelRZ7Uq/iH5Acggn3OAXvnbAP0cTtUKfa7zpuV85mJEJRsexNB4G1CNiLqO87xAN6lqrtSK3k80CkpFQNq4hlMCb09gMDt5tAzTqF/akmcoyZY2bcXC4Fl5eyboHOH9+WVFhS6In6UxLdKh82FQKiuNLJZx2jvDogZLpuKYDVMbj/aOkQ/S5+qFF4IhNxeR7GYP8qdf9EV6inDFNTwMTkurtzLdR9zHOjJepPWVU6MqhtthtOo+yeK5tOm121l96Naw85N00Gr7h+II1ETib7J0byvl4/1ibd5I6Mnh2Y5yGDrk8gq4vPnT0PPOBBKE+tTVtGewKhFHo+ibye3kfpxctW9gcrnODCF6kqvus80aRucskr3nsT0Z7knhd1EPkhcr0Rw+FLs2L++kYrRQwBQxBg1L1Rs5vWDS0UnrfzoCBP+rkHc/HgUB1HzxUTNKRXHG2FQ0fl+fxDrlKvvVIqQDhoSSY2fuwFadGQMOu2DQZfzo/67XwhI+b9FA5Dxa9rc1FMaOrVvrwd2Jg6RpyE52Y0cBXGG9d6o+rMaHOsuMpfC6RBy8cvHZhvZxBHAcl5jRs1NPjNfBEzJ1swldjcVS5yb156d39D0QOhRKzvrkG7lLLOR6aXekJwcKSp5693aWgUYSz1Qp8rAQbyKZAzW47NAQwUhBu6d0a01fbEQUAtGTPzixK3OOiQaCtJTBQ2Ht0J6bi9QGTPENuI8QTF37CGiI9QTRkbhdr4s5KROfjzFZpwlDaTImAmthd3cCpMft6XITHi4SGVchEs+6i8RZU7x7ugxEGeXZeSxperfz7j/Ic1pwv5zZTKf5y03UBfUvr/RNK0XgS+CoJzyKRQl3FEjpf+N2J85vNg3S0GMNHqIpQhi0NrJIr29wexAgBRnjHDWCHL1UKrKJhDHsEOn43ybXUZVR9WTHNMQyTLXiuu9byBhuh5BCnDqEYe5o27IWVvoIPzI4dolUH1G0K1d5v6K4278tEUJS6yRB49Q0aCvXbLIYwWxxG9DXXRoZVDBH6qkrg/ZFAYPWWNkQX3Lwmd0IVJFR4UawpJgpNa1WTxxgLgVJT2HA1b2B+bpwIehUQzNn5kNy7RhxFt29dU0PMjPRCRstLzKcY7e67CnHkLv5YM8gBoHxMtxrr1XPbGNQVSeNWCWGtjUSYkTdQNFrbD8CoY7YDTz4jCUQqyK5V+7KdpMinoHh1/gZYPXVnmxAoVKZLAsFeOqbijz8hujoH/i2oVXNbTtrmyRxk12NaoqHiMaSAXPoA4CoQw+XbjA21FcbNiv5ZtPHhnqVYZk/V6CRFimsMx+sAop2LCq05OnxkdxG72x2XRcGvLrBuErWOyCLpGeM3lvhT+9Qjx8+463iXHOz9yirKKeIp+wWyK8oOipwKbFUnr/CYLFI0zkqbYkpstV0Q3HdM8Uk1tu+FB4uLP8KDJ4Y44Xyh1l8X8MPeAl6ZcSYf8hq/0YxsPwwGX9Yf2LpKuZJSL6uzYNtgMJpa1oId/SIphClahE6fauANkDJdQehcMY+6M8K/1NpCh2i6XjjrRiV2hrHpp4kjTvYdT8XlQdB5pbWwcuVWh5lU3HqLugzuTl1WRG/WcFaqpdu27Zh5kah8DsiTVGmCqNP5dKWJSTPVbWl2PEPJnyIhKdZnLdY+JLdDia5XX1oBMxuM3G1xBImwme+/jTqAYutVpjUcR4yK2ANPcmkPG3qidZaE8iqBLQUDqUlApAEcPIvdg+dTYI2rQHBzXSBKQKdPibD37i9uKp3BZm7kV63nSrgkZAZFzzLqXHLoSmxvHY65NkmmpKnW/tfBhBJZZWH6ir3+edNwwhttXwY/vpBcpKXDOZYa86+T9+yiZ1nXpxsrGs4d5ZAAv8mUgZT3BPyowCKdtQ0m6Xxlc89cuWFrCwovaw0ZkHM+SyjZ41SaFpp4Ge+MTZxIaHsxDvTQJ/enD2ilk5gZnnM7nZaWHQ5fvgeVcgfuFD6PX/nZrt9AdmG1U0XoVRCIJzfk1SwKtPeCCCvqxvS2sjATsfshQg3zf6X9q3r0Ggeth7sZiDng4Ag1cuabnDTAo40F0eQe1+52TedKzV9RjtLKD+3BOdsQ+XoIW0kdQj6auwFRlGzJ3DwqOZG+XJm55K3iG9S/ukTgm5anOaF7lR9hO2HXhblsD3x+FV/w0IKQ4/oOWz+Zs/wazG+jKo8nRBhgXVDQtrl2opVvrd0Jm4KlfUHdHSXhSflREmrc221DZuJt/Dk/L8J/K86eaiIG2Ky8W00cqjb5LzsG9ZIFte3HfD3elf47WZqs61gj9wXde+z0PSB+5V98tLWPgcZ9KPm+pNYYiwYO0FMvDNvimH+wo74/4sb1kLQcNVSm5E9t2POLF2d3PyAJQPaECqVOYof7YPAyHuXLnWxVcN9rs3wQHhEUV6aLaARCjQQf+rVF/114smOUPbe496QvhVfkXlxIvBbqRjzye8QW+meM7Ez0HUbyHiR2BlB/aGyXVOyAiPI43u/aRBhQo34kmSqlXtgnuNn/EI/M9fFaeri7sTRIRHXZZ8dJbX0ZAKr3/LGbcfHJYRD2nDZ/zlQDh7eh3DzFQcJKNKnqRC/koKna6REcwYp/FAa+jrKlxUZpeDZoP0F+EXSexPJe+69HNqrQpEOF7l2ux+LL7URo+Yaa9qyQQXcZwrzA7OJF5KqZKEztasACweR6cY9IDfGygrw85tyNR8OR3406Ewy956O5mpQZrXBDTouFwoSdEczJI48cEtWJzt6gOTRxU7Lwg1lgNLTCIdQ7dnlRW6kNih8XcS40bEXDraNsra+1nAHRAtlm2toyb5/CbxawsPqlfjiuMwr12T8wihUQEek/K3nvmFVG5D7OEtMeyh5Gi9AwxmR/+koZiXeHyiQHNFvVy6R+xrkQ+m0zhAyk65921NrM6ipK//heg5pDbMqQfhWSs3atOR0GUbre3ZCMntr3yeKB3Wy44PrynuUtnDIQOfcV8WhrA5IbZ/G2BZ2djG6EyZDXrwgqBr34mMOsVVjmweShBVywVXrEaaqQ9Vj3Smu4r0ghLG6JQlsgVykqtWWb20MTd46Rg857tyxE7YEy+6L3g6mTIaA/6oP5oGvUkChwILKAuxEjMEtjtpeYPrZEJqo6b9XYzlpegZrRv0kt1FHDHlKbJZvxCyTfwka7RZSvqhK2Flk6zrcfJ3FhiubV2qpnvVLEvA6UTgNrzQlY3GC32KCRoTCyqg6N377bCFN1S0SeyA/zu+ZhGCQ5qR2uhFXuHPEledGA23rNCG6NKB+0HnfQlq0wAS8HZU3n7Gs8JeX20sVaWKHlnh4MiFONxL2nm5lvo1lojQ2atvamS37/D9znkSuVERXWJTaixE4CNWu0dae0O1GgSpwEuilnVc2iEYI5IUmyN5sUjMkdFuTRxVzH3zzz2mulB+1N/dcUsSHSBfuKzOiEt340t8eDM87iPKf3Zono9xJtuFnkxnfIQzJ/cvI0mJG9AuUBW+t8JSSS+LSgrA99lLY03ETmH2ICYgJQj8KXFIUs4nvr6eyV6i2pMfaNhtrAruF0dR/XS44sB1Pv7OfhwiHogns250gL3Td0kXrVcG9h6RFwus84I8yPvyConwU07b8eet7gQTnCDULefOYCazLwU+UA2BW2Muav+iZ0nRxalN3360xgS/1p+4YzHswAfm1p4Z57mO2MdSutHPGmolma6zSP1fsEajxHg8l0YEJFY49QZZYdBg37X1mQyqCCJlkNhhMRYbiIDNtA6f0jzb7mi0cryGya2Quq2Y+Ytn3oWmlzvATd1GQFh3usx0H88qIcovJC2Lq0tUXXPGAWBNeubBq1jS4e5FUTFF3kTwA1bYHRrzsuk9rDALkPggb8MBuN9LfX8iIXbOZClihsJ2gSEpn9sUuI97ntyAw61gKe162hHdmL89zPwlViM2M8l+JFbvzwBw6ODukeD8gHoVTcLc0RvRvjH+v9OlVNK07GTqQ0l+OJYyxF3IgbQNaznmCal+thLxtitNZDEiDXIKb/NHmn36yTnA92EEizTCxE8JvFvspp9Xo2rgMAC+UGFaTBatiNlqjSAr7b3cAqaddttDsfCq3fPtg86t4AOWe/RnhGLhdrmugR2nJVdCHCiv6YI0c74tNwZSAqpOovGyl/ZsArXvGja8bsPpt8SYi9O1PCZKqXJ5CRO/PABhweHLLicLdroSnP1Dd94Wt0UJp8YkAnzQgX8ZCvel4KOObMLvmS1/SkFlRisjMGLBKAV2GwFvVbtvKWk4lvUP1KFI3CIUIbiFand07g4i0lTe1gb6vKqaiAFfH9jw+wyeqqn6hsng1sc3XWbJFdYh6J01mYOrvF+W/jpQXmooxar6Z+ZDy6lmYSTzP6FId95/gfZD5FylF+bUr3ln4LcKriYYPZIS97d6zyZcB5Pw1GS2dRHoDllRGtGKRZATMGnUAxBFDnNhZnLgaHfK0bohmgBLnP64RKVYwwyafUbkzPlKtULKkRI8i1rByjw2wocdkaIVELz1GfJ18K5w6uTYr8WClOEYLzMhE+TE9Ja80OHxhD13WY77zpyKrLNQ1MBsRrJ8gSCWLUagmCVbNiq2v1Jy44IQEhduHqSq2ZOGmdlpBh8ufhhEu6AdYkTMVcSX599DWG48D2Nc1Fq8avJNxuBLVYjaqGfLAV8jYQDmEo331EAS5m8ChqatEbYktOLM1XSy0MtiON47sl5pBPLGlGQKiwulh1jLvJ1jLCcWId6Egn5Q3+JSHVL48GrvMCxBWIjjVK4dfVz+VSH111vxQTsKTU4ZvmeSRAsES6Fi0ypsqg+QwGqT7kWTmgagQZStnRC12Z90UosVrpcXsfGhQHyyrqKGByaNzAHbJigQ2iPVrHQ9ThLnF4+sWQb2LFyHfCHXGuO5ztVD6HdvU4koisGNoTBpT5BeHu7Err2BWf0pOgP66/yL1KgGkAh7aeL0kyWQgvD3Q9QO5QKqIk6TsJCMlgg5I9gYDOKDYr1PPXUCX4fs0kZx8dlikoPit5ui8e23iRXmTcnpHmHm2SwPR3ec+1/weY9Cyqw3HJ4sQlfmumfbMcX4kgNNf+eGmpRh+hOxT6sGv5EMJjgsj4ywiF2BVfQjoLuhcGyPlEThKCvwQwU0WEOU/hbkvl8p1AZqZhVJpS7+emIckZJMYGrA3EXnVgum5iFKStQ6I7F1HWg0f/tno3Kjh3PG+jbJO6xBRbNTSjAD11KjWrQbkDs3ROnyeW78Wv4q1o/IOd4lzUBFuOkrdlLh6T2E4qSWZIt4l7+6cDLpt0RjyfYFNaj/d6hOZNAoPAhVxA8FgTkPe7ZCIM8jExKbaU6NBzqB2tOVKOpjzMRll2aM5Wz23x6Bs/dT8pSTma1rmAGISC2pKRLm/J983Kch9LmS0BShXSfJZouw0PZYP3T4cjaiTJRZTWZA0Dd9r4eVJBZ/dGOTXIaLKOZfta+4HAyEhauXRlbDtRrgn7eJ6cYoiKPUDLaavfNchXgsM2EoQakxtmFoDvRI351GYhdw7rqXA99/7Wh2aaAXgCGYE3WoM0Lqtz6hHGaCpXjg9xh42RU+SDt10d7kO9PgRV7tJwy+Ty7Nvlb4XGxdNY2aINiblfZnNgRJM6bjCTndOuGUY3DLui6moYjYWkta1lLF0SJMVktSo0iR3JlyTG/jCnXQfyFxjvRtZGalXS5HD9XYuSr6CE0kQQ+zscBqSobvY0DxG3FYYNyzPtQq5HEPKFT2OG1PCj/ntWtLtwB8mJzFAovLfgA3nKs/si1GEUoRuREE8RKwASe4O6JYvMmfN82Rj+GEB7J+Gniof1sPWEKYID4vKhKOlGBstjKh/GQMmQxsejjRJEP9xVLQU9kEYBkSUwDf6Cm+Czq8nhB1o/1iYX55wxN+yKGRuMlEr88h+JcCqTvzFxwnz0NoRazGlnp0o5W0ZZTI4QXlPhm09eAFpqlow7A5yViIX25Gftv/mqiUsg7IeAcHR4ut6gyOLPRqH6fqnFukcPj6gTTkuM6ogJgSoWybU7XPfSUTFujlrDhlPsgDSTI3+RyLKS8ZRLB6rhlasXQwNNTjANMeCQ5wuB6fAzD3Fp8IIqQ6Me9oqdImsFH70V5e466CCZtJxNDscBoTBp5uZkDLdZNLYUfNv/iV0cbzS0z+9Aytxb1Ipjljs4JSbbG1gCx6BzdjR4ahH0CL1cIFs13nxp365firfnwtFWGnMz3HuzxMXuvSK8ILvtyOlHplre0ocJbOla5f894S7zkVnYvSMOIRGoFsD4yXLNkrQPYuzz7GQ+9dIF1zNzEgBtlp8WlmV3wajjOwMtE1+xeZZd7lXGU54JL4Hru3/MQKUCmuYa0UIq4a4U6MjDjfYkH8FVKukDWf1e4R2jn0K8fX02mQXLOC1YMnWUbOfVhc9XG4ocwifqzgqhXH8/RnUWSbBrlXmduRxIkZeNsiFBvcZSksdpVQV520Lktx5hXMyA7SZc88NfPGloTeOUFSQdjNQiqa8XDaRj1/EBLFpu0NyZFAVVTwI95v8lHUAuy8OrrtatpFtrugaNfLMa9XUVibEcREGz6XJIlTxnXDmi0ExUOqePLjLqaHGxCSpWyzWcZPTPMJaY/89VoRo31Lby/GBLvZ9t+gWP9ynpS6ByL4PXbdu0mofTbeCtDjnj0aa0EwyrxewqYHdKuGQuj/8ODsJj7FZOoOZMoXNYs2onqxFRyOP0SxRV2VqtqO1MNQs6x/gATTFzXkQk1pqVJWoY9ncZUOIr7cmJiZkbRS/GgSKaRYyIvdMviuL1au2W0PXuwwUQMHjfqNp/p9xikSUnguUoDztvn0+l8UQpcmSQ2XTAlb5ePRGidLMIMeDyIkQBu7GQqbHewP/mBDKsyf/s8dJ9by1e+EmSTsEtlmWIH/3aNTsefUY7LYFg2jJ/WxaHkzRTIu45tjmp5qa5mjzERFesOFn0VU1V5bC+Hno/rAif9oTPdDeAXmKLX7ld+P4eAWKk8BmCl6SNTbB85EiqlZKBT/P88AOPrIbBhF3A6dNQFyy0G/NqbaLCPRveN09I3Dc4OHkrdNUpVaOelj5jNBO3jJHd/T6TmeYqk0C47nL1w939qzoKK/hUThm1n49g5+56ViwSdvEPfLf+6+DjQkDpVQCC6zhotILYFPiB/sqSJJyef2m/CYUzSwrHQi8zTNK2bcVdEoHmTD/bCop0z4uX9yxvifJx1jA5jElMrMCrG1SeKN5DzLvxfQleVm30MHpSjF4Id0Qi+6N5IZCN60b3/I0WzbZrMMcdQwuwFGiSTpPi3IH4Q5mce4CGeB/NEk4dfe0iP34ES3Ozj0sLl8kjBCJy68BUtRDmDANActord6E8QvjotndMewDjNNvME+X2rpHpFzP7FeK2gujv0dJvhNSULFTyz/SQu5v+NWrsPdtk6ZZGmc8pXFFoHHH9PMnFnx3KeL+0mA4GMEjqXgigIDUOilYPe87Fdi38+3xZ8Vw9OlV28RnymHWgaACAmqFogAzxp7VDGa8tjULSQmDlCKS3/nfE/s3TUYKaDCtwlVSFH+Mk+bwJk+l2tgiPdTl8Q8Hj3p98a36qrXy/CGIdXj85dq0586obWWb/58MxktHdbTxSgRgwqS8t2stwpC5UWM1hOQvaw8+3S8UOkp2i4xnqCjYla3SX4F7mmGQkVVYyo+A1pz3XT5gLrlfx/7wGpdYwL3gS3pXvuc5XtCtASPyezuBoyr6RfHIvqDnjnW3OwJN/p879HX1ofhYMfzzoKYuVHEbt53aF+EByZmSEH0YFdsyX2JGBpEjdRWndRVQw0DPd3jo1325IAJ/mqnTdc+IneEskFC1+h/+v8ucygi1J9+ndPKPG+Gw/RzI1KGhTIYF+QoQacUmOOlvJKpKr9I+cD2yPuPQK8KwmvGOcJpoR227F6QyQKNF1MxTagXoq0jZx8oN9ykk9GscIzvqOHpnvWQxdzPLavLoGOW30VHCRXSP4kidhgzHty4PFfKu2/3HbIWJkidZazxywnZVkeCRjBKBO6TkWFU4443uXni0MkD5UH42GzED9h5BYrt98sBrY58LVcDlYKjB4kWfpd+1kZkclVMiYfQSmM85nhFKTuFcYtkVciou+1+rX/eY1fHndhxrhqr6Tj/kw7WFx7QvxN1mqvaeg22D/ilN7jOi/7cevqnH7geRdxi/b/vctxVoXMDFPKEILSOXApKjy/v7Zr7LMrxOtZPtVcqBP9edi7D8WABfU7Spm6Ma/J30BbMgnZbamRyStphLHR8jNYScGMHQInnMwdgP+6+h9o362mQR9ZnBvKnE5KYFOgOdOc+Zx4viuoHLCMNGcwjpF7hp76aCz28BMXnEFH4Ysw5dkRR3lMWPnpNwbXv4yJT9REO3ndLVRtPGjuNVnfiDCFwta2GWdKyxGu4HxPJGz4SDIaY3EbYwj+K2JvU0syMNVcDTim5CbLsIr3YkcLka7k48AStVuUmIybLw5AbcX2PXlZ+A7hvXX5ccf81qDmzyyWL4/Dd3m8OalDQbNiNKA6c5A6FT/3tNk3CDCK2zxQ4joG5qUXbXt8TEkgLKC6tbESJAJrf8tTDAN/xS4rOn6AYPWpo/xEghGmkB33B7wwwIrYe7gqTpeIP1b38wirIc9I2EF6r3FZ+27OCQKC4LTTVzSPWdUKylxc1geXovBUuHPnb8ISCisIdhE9fCfN952EW6gnDNJIJwGqykmc2PsXG/dOCSVefXiCCGEPSb3dytQcaBaHsv7OeWnVQESlbO4vGHHWR0IFkq5GU1l9XHbNvq1ZTisaENvZ84qSU0mdF3OrPddisOrNPjsT7jM4OOyvcHRN0O19PjNKAVydyZ42vY17U7nVexX9yYSTO4KF3lRQCv1eu0xnBUnujXiUhmYSkPi9yqD5uM8v040xYiCT9uSUaZZfeFt42D2VtoT+0TEZLFdQ4IvflSQf6HTFGlAzoPI3hS6P50BuB4BvW7ltpZhIOnyiKVSp83SY8ukt4RsKg4BhmTlzgIsXIE3cH1SsG+UWuYOYDEqWpmxPcj8dTYMfu7vmeInlDJXWGoAZXCFdeQgwEjJgfaysbjOgG3iN1xaOTrhmDX5g6U+nl3pSL1MBo/A8kKqWfb7WInKj9CQNH8i3pAgrihol+klCwKhSDFam7rVH0TZ/ojoaMLPPNIC6BkQReqgL/qfte1z/nHzdLLikzd3wEiA8g1W0SJJH8JJ0zM4Zf/WmDR3muqDpt2GPr9CHBOlyx/FN5ncgmNvdeM96g0UeEb1pUnUPJqF9TtaPUthOdXNMWhjxUKhZLUHMXZKez+58IJbFv3AY2lUW9tsnXMiMsSdZ9zaGdgbw6OsWOeSdU3HYnpBvmZJWaTf2qgRLaVgK96Xsper9C8D+T8XCVLHNpdVhQYG68jzGkj2WX1P07iWU9VGH4qtyB2WnnY7PIE0vLSWVHI78ZOhnXgeqV1qNnTVB/EpitVRDwkcEnsaltAJTpMaFlEtosCivL6Xs0t7OU+K43bxrtbOUTAdBo1/8a88u4SmvYeG0xbMqiLfExMPS31+DW7EYqBUs9hZ2lQW8j/tL+EpiCmnXLu9OmiLwP4r247PQhNYBo1F4EC9BVkcPBPHK7Fc421hda1lA809M3GjD7MSSqnf1wF2Uk4z+6S3+kkTHz7pJ5Bsu4QO08NcYuOhfyalMkLc7R9f4HQXwS8ra6ECEoW6JkKdkuM5TzZAPRBlzlzUqzycOnD+KeHRQwM9ZZfcwpVAPI51BrqBCuUlhAQoH+M7iC42oeUqphmmS5pTfZBlhW/8P2EumnRgyBN7Wlo8bcANMw5/S/NL7xxwhPVm9UiVkDzsyWx/DEcdtru1wMnqmK5vD0TMZWLMsU45h5FkzpKF/cnrbviaz+DZneYFpuQRpuhTpGyX6zWGSnH9kE/ZP0cDluz+YUcGUurfspYyFhGh5+RuF3JtCQw6CnXgaaTK7mBsTxsUqlEsQVYoy0J7o5wvDSXNONydBX2w55qTZ9e49NL0QEfK3hfDsUu8XMgE61m9nf/3f8u+o6RBXFwfzLQySXgGI459YGRoKgU3zHVf89bm89Qgy6J/5geTP1rH0CbictGnH77B6X2937fX+YdZ2/6UHWpZlM+h7noUT2OUfRtST8hFCpzUrlAjCAoLh0I43W3XLexOG42fvjM3njoVhp5FhG0xTTmmzzXrtto8ZY/i38RmcWuehyC0qFT0l+VAygaOeTWFED/qFcGfiLAXFKjhLntb3UuOAXMEdhgstnC0Y0W5E4ulYG6hmdQ/9cLhxpH0Nhb30UpWm16IbRU6IJ4gdDWDeOq92OWfQMX/WGW1jpO7SSNdmfiO9wxWbEfGQIKlCBflFfSipyfG8ueewGDNJ2ayAhUdlseUdOyPSemF7pU/9a9dG+11vA997/cdswKabWM6+R+IgsglrQmhA+1k8VPU1CuXusgDWTeV4K8u6e9zKMKUEBMQRByePzU4WdMI5cfUacwnJQqr0eIY5AKInWIEGIGvouifSAVYCae/oK+sxEh5VPwmTLZcl1VKYKn9NzK1EW5xiSt06yj69qmnX1OqEIAjCrr5/Oy4wf5Gh9ETbdFf64RQEPC2ita+uVbeHCScPlaFrUZ3DVQgE8H0cpSdy7CFhhFPEOWA5pDlihqEC0dRSmn+M+nSFJYxayVMj8VqauUAq4sG6CfAJwqZww0JRJ/GAylEe1Yl4U9rH1Euoun+ebacdvxuMOEwmXWdcLiTlHYEo+OOW+EdzHfgLZMn3u+yOKr5xtUKmRGNPiP+DEDCgd2kG80EmKAK93NWkqlbitJSsmj7Ragr0jnI0GnLrmLCEZhl/OcphGLp5bAqy3uglIUlvDybR4JVJaxVOJciRAenRMWU38oufwgT+N//irpzArLv5pEJx3EioLuQJfveUh84wsyqfiYmMz89a/yBqpre5JekcLn1rP8ZwOZMtxibM1H4O9TRAKhMW1qkTvLiIzX9i9oQd1cuKqR7OCVxXTwHpq/ZclWFsIQnNHdZsubj9AegU+QFsSLgnevGYIAE1NV8G1r09zQclWpRIx8Rfs2bBsglGUlMj3pEaL5tapPH1XKx9VOKJfOc51fuG3j7FCD/rn6ZfnGa31+56V8O3phjamray/DcgqRawJT8L02A3a9xC/yqVayJ1NJOZoCMHcbZ5rrEp46ABrBsok2UW6KuOJtNalu+V8wafIDq7195+oU6dsdv1u6CTSAyW0010LW6Togha6aYQP+YzNPvu1TQeAINQkcwNTk9rx4l5rzvec7lJ1qoZSyDG+KGui+X3hXn8iNxJUXkML7+DF3myUo3U1CDQ57QIghM1oYMSkSV/TfnZ17fJg9sCW7tOVjXXhzgUK8BZsn2UYO5mgDlQHeijUDfafH9eUUePPlMsolO3oeVT8xGff0SAs2STbErsc15Z1kkIdRItT0vhjQUuMTdQooxQt5epFyhDf1y+LIh0nCNU24atXDV43Dao0whNp9f+cVgnP1cF+fssb6mP8qztKrKj9y9dwt7SnbW/BBJeDdSjnRjNopuyBemRtu7Ig0K694nMxYeL/Dv8oY0/Tyed9NIm1zbmsab6aTnE184QSZuBYphBpw6O45YLZ8F5JxWnsd/xPk40HqIT7vE45TqzDJyvw8LRwCp49nwTgOOWeZA5Sv1jPAspKsmccaB9huyJORgohxAzs3RtziUzpPyTftL/5tkpY4iVDm1VhzxTa+OZFjE+bxIdVZ5M230p0c5FM5iM2ZsH3A2xonD9UfncP2ogfqIwD2kY0sGYOFUC6EigEg2L3fYTR5nfNes39FZYLkbUzf2L8GaFs8vh/lxSTW0wNPkK+nyA00+7fL1O3iuVPVV9f4rmndhkv14MDPQP/3Y7Wx6KSFalK+30Re8bPDpuhb012mkl6RwK9kce6qZL0JntnWsrV6E9LdxoThBJrZlwSG2/oNnOijAGVK81+hmJdqiJhui9mvlPUxUiFs8y+A/cHNVpUAI4bMHW0VZR5PjEZBNGPyoz3raqDZEXtXlNia2rJ6tSRyxZpJW8pBvMpIDewEYwkx7OH92L2MdwDCuqOAJI5CdjYc7D+VhzggourIE6gq/kBSrtyxoV1PfKkbcvTiVT5AXPZJ95H6Ya5eQ7iIFqvnP6JQqYe7zXzxAaMGIs63IHrJLaABOLp4DrHbgz/kDFkDh4QOPoBoVxncrEOXggjxuOm2lw9NmcSNkXHbGxDVGLZsUqL2u24xOXG1t5plPxYOO4p+su90sJIeZbh7/vUCmaUS2VLI9K8l47AcawGqwxjai2bY7pDKhzoKgF01WBWJB99W1zF7XjgCrD1ntGhGXM+B+4KqvfzH2G66AZ+mUyA7adMFKBuywxPeyZv31IgmWI1gLsA9gn/dyxLRrOpX5q6fh+20tkSotkxoeqDwqsLsxNhfYEZyS5Ftiu8UIdfriCz4cxL2QmKQMVyZNO+avd5Yd79bUyKQXOwGuAsocHD5g/eck/ZLNp0yKANidCFp0ggzojOtcMZVMi5X6QpD8X64HHfTYgHmyhxbqz9rHO/JjQj/C98oTKJi9CbJMlPgze14xmMJ6x7LIYXXLJkVQFCgrpUv+oKRXfPS5KCf7O5efw40MPIgQuvWKIKHk8hcxXptUyalJEBu93JSuRb94/UEEARwwbAZbDH9pxHTxVuO0w1tVMQ0lTH/rzHi9VQPQPpnIZItwcN6846+2qEdGoD1Pbsf2xplknIFwy3M9id2DZSvQc6i/cgswHf5EVZwQP9NklwrPYGvGGlM0F4egxaFXnnNZsy3tP+cVEzZMB6loeppy/oK592fzUPF0Be0DqeKdfkbFNo1MQ2ELGq6pir5GEevBE4Zow6tUYzmf1RdXt22qTcpmaLplglhF3PB3X/ecUV7bKBk/yo1bqMjMS2nD3Uzv0uWPykzZQJ9WDgl98OQoYYpD3GFxoIQE7FHRmNH5FrfO0z0il7j8wPiieUrcy8xrzplglSej5GVrtDnk2XL9aBOlgQd7W+zJff61drT2O+OzJ+R+5cvoQtVl7OXmsu+N4WbBdnvnKbJBfv31h2YA2gqvEBgbM0yzbf0b3TUijOtIZi4KjnvfIw5LThDEZT8rFjxVKlmY7vWqwLRmJwbQdbDhQcYe/uecbRnwz54826j+iPPpzuZQBu+oCuUI8H8eQczq6o2XwsnYabjuq+BBbGmWiBq6J0poDDC0cUWkRtnvJumCg0/tcfyU5qdtix72pdbI5Zim/hAJXq391OPDz8TcyCdu3ABU9aRVtEH5j0ChshFLWkoGeJ/EYzj7+DjpqX91jfj9w+5rus+gG4DvSaMZBd+LbBIt0hXzuu+mbSPhwfMbhzf5S2sC9kIgs1IdgeLvX0YI9v3ivw+EbTh3r83fK+MZZ8bSry8oKCSQ+iR/9kCNeqY6kyxWCsC0HB/JQMyen7sxvuuBbd02Q5rdYTauTdENp57RKWswbDEV9apVV9SIM7gx6CAPb/O2Eqx5MQp3aOcQVL6DuHJsATh3DMOcf+RCbo69lvDLl0nBnJeubPmeyFBH1aquYpyCBef0cWpmuXTP1mWwPgm/GKTyLsvW2EA4jAwKEWTy5jdCvEVrr5WeljWUgiesM5G1SM+8QihdIpHj5gBXmkm9XgxhEdJACl7SEfe2qWkI6g1UN9dXGKG1bM346HM7hs4xsyQjtf6ozFPyy6ySSlwCS9LJvJPXex0NMILqx3z+uOQd0Mes0nNuUKUB24oP3tFCaTs843bymxYTcl8HKfVdAqVWez3+LQzzEBM1UdZ2oeIRfrwnQJslJOcmdbIGaUpzzI7n/+eXsmc446xdmf0n3rPcS8vByEapOP3TLXp4XO/OuG7KEQzrVpjY7kGbZi9YcpBlE1/3rSRxcrexaTXFFbvZ+UcYOYWQRjh+t7EomUz3VrQmuORrVIjavDH08XbSTjUxNWerfvxc6bqTEM09ejYkfn4YwI7+gHJ+3Bh6tRFVe3VOixQyUpHMInimBSXf4vqcd8rOKHiA5AJ5JHPQMe4e1UQLu5NkssZx2cawpmTG2wSTveINaxMoqAz0SByWQuM8NFr1a+UChfFI7v/u8I7c9vAnkFAdYqjrtSnYGQdA1KuDwmVlMU7NwXlOzwZwR5h+fAiziolXKYu/j85PiMtT+rs/xi4iPd7mgR1yD4u596gc2ucJrg/+EdniUDwqBlf/3E0jQCrKw/v2FjlHNlQlF3aOEfh4RfNB8ISgm5+Os1W1z6Njig3o1u32hd2QsKUM4ffueVR8VvpJDIu6KGXTLtYJsoUC3vaNL9j4G4GIzKIJnKGJWUpV5g8dOoaSOfKCO0D36aJXfU3mFVXFUk6C44+fWdgtNlnEOyNFsBNjhtUPWafExBuuzCpbABjYXKmEhyfyLGUX07V2jslbW3CQqpN/v95WJQ9zB6iNKLieyAB58WGt5B7qur8It0IyzjTHK1NuOSwgRj+k5FJCn9sSvOmmo5DrH9MwXGyDa/mt0fzAKOR5gNNEfk++01K8u9e5f+GZqN5WSYmEuAPPVQx4tX+MDxtAFoL/p2rJKysa5rtvtVSd/P/xiSautB61d4nQtP4uoSvDLcQqK3ZiQ7sn7uWS4dU4PdMIX4fajc9uyVD6usy2XLRnNeP5kn/j8SzqRBIZ7zNx8RDBj/Ir2kkAW5xDxEJeb/pUEetPkkQ3wfhVNduqX4UPisfyNolrC3QU80Y9ksesVySq8IIiMUv6A1cLmuPFGIIKY2eh5To0bDXv96DgtjhC9oLDGNFV+dcio/y2HipU4gPUKnmr497JTHEhhFLuabIFrUGKInpPLaLu6HvJmi8IW5bxoWUXCJsEQIyKBiBCXk98nvXR2WrABMbceNEDedQDfFXncI1LKQ9wQBvYpZCxoo9/5QZWl9gxZZPOCO3LeSrYDka1aUuiRaTxSIKFlW8d5NdxiYPNzhBILqpuOOhiygvBxNZza7tccxpD2Rx/42Sn3Jv7lIEwwEfoYTvWdBmQwpBSCb/Q0lcQEBK+4vzg60g6w1UdmlwVdQTNywObrkUHMELFTEiWpRHFxRsbC5p+sxKv9+DNq3yGHTGMIL9UNlGmVt8Xi3xuMntBgcOH6pKWENj8Ya4V1BMAAn3maOipI4FOV0rNl5PPKAK0H9fI1qCCBXvtTZRvEwAVuTZwgYaCxwIPGZweHq3Uzsg/N3K3A6OhLglKdqpD8kvhTMk53Mosa0utzX4L8R9xe8DDfkmKhK+rx2gFQlOL5Ja78PxDqjwxQMtal5U0s5xFk5M4sTvxJ1TE6/YNQttK/HmkwcnlQJ5Vh8eNP2WIcT1iCWjugFRrQe630TSGEiy0zQp1Tz+UsoFbszv+vPBKAEN+eWu2/SX7/UCkR37z5ZUxFaEQX4iMxWuZ4hIbM9UCjAb0gsmmEbsmzqaha/llJ2bQe3fqjOgriIzxerRXkC9BFoEkIPm2YKnbISC27YeGdH4WGx/Cgvz3s0MrnfLNEgAz1vXvaSQK48TfNFEfKgwJbpGo+epaRQVd8aEYZLP7DcuWojI6eTLeI2K+KL1Aw+0TrRY9qR9rdOwRvzrYM4eY4GjUpnQcj8AwvmUqGGtKTg/hmz4kRHg6t/2i+O/JnqhCKy4MoydKEMq5haJcTtEQc0BUXX9eWcA8GPpwz2U/bExvi135JxaKvGWv4agfgx+uJ5J+XHm6+9Ipg2NE3tj7ae0hRwFCRHV/IXMTMJMrQod3CbqWGZTcSBsYyk2vUgeRZvNcpTEyP3trQS3JqGVqbkMg6cR2nAcUDFiSvaNwtrxNtQRwwL63zI/Z4Gid9hlKyUJzIDPzOoxBcPMwLULfi8BQUaVzNOJyWzMMg58qqCqwXjkMZWG9/FDbvD7AT50dzuUFf0zPvJDr20TgAOGzMrUn8neZdR4hNVbVKzRI24pPKT8xrBMWhRIHx/H3a1ivR6FE35gn5gSyYCUrNu0ybdU1D/aiY7yln1TG0eccoNUQhM6NffHtAAWb1TrieoR93f19vvrelc3sJY/c4PfFWCws1NMinCyGKtNHzIVTmWTQelI9dOJrsiqo3rw71qiyyR46ORYRNOqcoO1nW/Kj+R6O6rhgy/Ch5BUOCZCPK4a9N8aRCpYvooGnoata882RItWfocijbZOj2rMBZ7fiw9Pk8QoEH1WY+uzac6vWCtj0H7v5dQhFSk0iovDiteUarMvT9cdbcOxs6h81YTWrdH8kUlo1qOwO7kgnYV+xAZ5fuhyECrPAsWKfrgioKeHsxLuxzf2K0FoQF7KkENQe+ZLrocDRj6rF+JA43CNVrtVVeHG/nudMm3MsMktUAT8iwh0yTFMw1kJTwPrHXHlLvUY06hD3/H5J3sbYMw1D5yfEipDu0J/RZv/G7E/5P0r+qRx22HQHv/CSPmMHJSd+1YMvy7/OSynL7E37w6XOOGKVpMomTw5ZICJWfDCuKdB2g29whBG+hJ8aD3Lg7QrLJhLHfKsi7fvRqAaTQvzxwSbRJ4B8NdQ2x43mZnv8RTpOUKdk/u8hvDzO2hCXqjNCCyWlA8xU9B32a1GcS/w8HIV88+JKMlwAG7hELijrGWOa9Tho65bRQ1UdKEtFb4VViwwcO3cppH2r/UDA5LfhkgLWWHiZV+JxYSn1/6Az6QZAZzY8sMUUYgepFuxG/MpSMS/94CY1mDF7ewmQo9nubsQm2lWBweg5be9PEBxwJVJyoTGlCVBo+klK/plIjivc632DNOFcOs4Fd2lC76qd7al4TrK9o8w3ROdGTvkEQnfMkWvKNoVEqvFfyc25L1cLforeQZiGlpvBEDVpCIaA1/tcBBmggcurOsfS1xbT5e3OCCez2oG0JPRrPO/A3mAgUCXQKaVhb/qmhj6iBzAvMbesT949xXcz5zz0ngdP52oMJuSFfSfv6ZfnVwlskBnuKWjAzvCe3aSOG4otgka4Zx3RM/Mbax+u2SZ1zaMCRjM0QW7mlV+k7o4Iajd1/K/IOYRLGDoJpSlGkzaSZe3Y1RyZt4hl5DsaZUapNm9x8xToF1cyGwT5MEh9Y5khfftDVQKY0ral3e+OPd0I6nyArT5x8Isagey2efWT2Uu08bDj5kZ8PfHcACtTbwIN8OAQWURUhcBWIRNKNt7EnjdR9SmYubojL1N/QH3nrAS/Wgy8w1DYh0tRcdXhyM615a2NGYA/rwS0JVOMyJZ3O9mh15v5HhEk1Ajh4oTkxvXZr6X1p4FzmkHdxN0wW3T9YQg6xcR1LeJZtOV20tLT3aPOI/TeCSQu4zKIKqBfEBhKW3Ifnds4uKjNeO99vItebX/eWK1waTsHzClUjHksMDeAzPoCyYFG/0coTcdYRwMUT28x6LTzHhs8U7bOH2L4fBNEwPUH5KU3LukeYnYNcstTjy/ETqMBxii0M/MHfPCFP8ALFo2yQAOlNWrZMFJ0gJ6lF+i7GozCsAeVAftRoWR39IZX/49WKikiKVlMTDfMAV4XSLMfiEtHIF4o1mu5Wx+B9MN3h9SqwJAtNwnGmElZjf8CoQ9TSrDZTZoBbaUlDGQWZIxN01wjQJ2Xg8EPFzYjPR7zadiOKbw4KuRCG2zazikY7Ty/5/38+r1mLmtmIyAIhDFbM/9IOqzej/GDXjpRxXI1E6l8AT+UpFjSzSStTPXRhm2m6hvlWWMK8BQIMOW2ssgtgHOrRpvc8fgvDQcXLG7xRg4hLo05GhaD1WmeOlSGJLC6wF0I+WFlhnScAmsnU3PKY9vA7Ap+MVDGA3WyQdbeudW2dyCzmGHcLYub3td/DrZt9gT6uX/QHwGZpt0nNETz50QoU6T3b8/asuY6m2k62+7qsszffDepwCbz4V4IO1k0PS53Idl328nPueQnjA3HI5gSKZwJL/vtmSLTf4JgcnfTLbFYNRcVl19dlGjvvKR1zynQ7Mo/TvjzJXZ1vfEYphruxeSAuPfKoMt7ouqf38/mJeaAbWGU/tXnZ0Td7amqjKD/IZV5jXvt6tQ3VADFhawop9rw5mx2c57RKsY8aw5DveSOIR0LzqR7PgXeeREhUHPvQnYrnZSjLzSb8hlSfZ8pdNUPgq9QI87exLhW9lve1tI1UIxYs+7y5sYV9qOe/kXvZAs4v9UpLvj6UEcozo9GVZt/mnYm8CiIqhaIEjFGM4Qp537y/gzgTdTeeEc4s+LGyh8+VhMUZjlTx5Ie9npwgNXgH8YDG7SngxbcW/nXSet4Z7a4+HmxIICZI4ZnyNL3QL0Ne4KHosCgkV4Hy0vhCPHngrbcV8c75iCdvf95gNqbEFgavqQXOb3XHQHvdbqitcgGwdcPfmHRQmklRUjxpINrCE97us6UBwa+o/AIhk21CHlUYSCyRJufC2K6GPwbz6MRe4sGfuYyj3q3EGVZ+danfG5Us7JEQK93B/fRl6MvTUuoeio+1RfaS2nRHIbzJWqBKDkq+xw0pYBDxEB461iQClrHq8tciudWDpUwc/2a0zFLNlU/OIr2PXKuzHcar+04jUDLMEoz1UQ4jsxzZVp+4IrILUHQTdi2q9ZfkeSEelhmFpMd1cJUyGXweEyHaUYQnWK0AEFy0b1ARqLZZfPT4Uw+woBMxV4CH9Q+PhNZAkDcU1bXTJAvEpZydSvuPitkyUsytaGfdJ7Q2xdkfdOEGwDu3o0pV5qRgHBCJR1G5oX+k78Soir3l6eugmOproTLvhx0L71pZVYgMlQOkJlmmYi9jHvLtfmHbc61ikmRS9zW0+jB2LksgNsHVhk56QZxn8Q/eJJOAOTLiQdfAdJ+tneDrfJWenmd7Y8u4mz0AJeKg0WIoYq+TiahuF3V59EEBUBRb5+EYaKl7JJKYt64wtK8AhNpBnJJyiL/anKypU7ro+BnszhJ1s2c1h+QDXguHErfc+AKUJ7uhXKSn0AcYD6Vu+rD6vA8qyGvFWnqaa7c3noFEO3rKY+WLxPaoMnCoTPmxkboaSdLkmKxGLLwieWf3BtWgHWsHQJDiKeutLN2TBN0tKhHOXHMBHP8JQ8Wwh5JhGp6P3MuRxavgjDwW7wiJ1VyXnJ8hYMvQAS6dbOeIa+13X1ZLfwJ00MJxA6B2B1/W7PBgGAMznM0CXualnKqmjBtE7R/JPQq+veapSztXQSpRz7TxzvpZGu7sECTW3ULMLxVUsWOTufm6jxbagArhNQSyE8p8ZHCBJiWEXTisD5kbsZaF7UwwpjxrKAkeR2j4/fik7/qLnyPbj05nvR2cFfkkt4B3dYu97E9nh9y2kxCXwSr2jwstfRZNE/whZnxQbu8KWjtylISSBsRyLpjgZ8C9+FQIvYSmBWe7C9JtBLYneYUem59TLfyOU1ppyFeCczjdBdPoUj9ERVoIrB6NKlat0+NYQ0eJ26ZL9mn1HH91OZ4/ULCGt0jfjD8TU/Pu1Godn8tciXBoAFJQX3RwNWGKQyi5564EZiFYbi4Iwp9xizjeyKXh5yf0nb0LjBJ9jP1q2XBR+0XPQcO8O1ZXFXib/9xCaJ3b4rd8ZYjVYTIxU+N86wOat5TJ6eIs13r5yoc0agVlidlgirakK9yWxlV4j0jhTjwzjtqvi+fpy5DSg/iMDR/7lwlithuF3OxpODrMIrboX9ys0099cMApLXwxBjg3M/wKYfbf043GFoLV1IVxvJMZETj+yGPoS+vtW0Hn76h32RCoaN11vVk/vWw3ipBkVP4FI9QPKCFUhKWJGwVkLJO3Jvo+msFHcj1b62waQB+dxsQz1Zw2guq9P74VQqZE/vSMooTkWDSP6j/MOWJKE9tD2fzSwDdwiZksfZFBulapvZj7wbvPu60WPYHWUpDzA8+vZC7Yc2iQVVCwQlh6w03slrFuzIdoPOVOlEsrsl5veaEAD14/oRgshlrFE6sZvGglq6f55Q720F5jS4PrEUG6RrVFDhS21gUXwNFoQHGQl2cunMCbZYnCBE+jVMYa5oXLMdrLAcGQyiPAfBywob3Y8f4Vy+9ZXzrfTr2LaYIDY7xn8VZ63HxfbwbcrZfoL8qyDAvDhrUGxqAFBfLlRkGDC6H0hvNqH2ojqsLuc+0YyIsr4dvYDa4iyK1Kq9XNhcUTP8J6bNt4KyxF1+A/TS3wiFjYlVU9MSubdxD7SUu6s0lKxyTi1gUP73iT/YsSP3HcSXPWULxguyGRc8RDGYIeg5uswvBnZUa7s+tdlrTiwHSv0LRLqG0bqKMEfLRSZBGUQxjX1Qc1jxnXmyZQLn6USN52bk/5dUF05gfbTuED2bonAxB1zNTnmg2APblbv46kQ/jbggenu01JDoGhPLnR7Bf7tIK0Hffms/isFL+dsA4c9WEbOVsKv1rcwztuWAv0jowK4DHtRqFtXlPAe8F+8EwL7X8wvMHwEnho/UPdVUsFhZKVFEksTERbZLFQB57dgDhAnfhbt1X9Z95WI0KyFQFUuPLlCjOa9X1JwKTNgJ2wbSLe8yEeNpDHNSo9SOigFNWfDfNI0m9SwDbBFx0AJLETSJK3TgGrQPFdEOpWGPkr0pLt/aeU7PwIio/4Ag//2fyeQ5qyVsJN3DpS3EHDble83S4OiPlHAewBgx0VWV3ouoK6aXhHd4gFphlVQfqWXEpLqt4dzpLhvhcyD5qSAYnOwYuK55bjFq/3HNOZE+JMDbJGu/bhQOjEtLjMAc/nH/akN7y3IOj/wj0ipKy3Eam3I2EEGzl5k99nWfY55F8sfLVwkiLCaB8vTT8iLEUtqCZxq5Xw1qUZw2zl/88eILqbqAS5vwvU2HQp+3lGx4jmO5dHxl0uenijbMGElIyzvIRXO0A4VdwjB4xXJRQcTiDw9nCdVt2jGLblYaDrBjsaInm8voNLYGd0QRn/3AgYtzUg9X6KZ0ELETrHUE+aABCs6HshRXkKfk6MOZAdAZw+7zDdugO4UqgBdVA5mPLwcKGlbNc00IUdiDPlte5z8PY2ezzs2/f1kkJM8QZBra/ufvgK0Hv+3CwmNdSQVdKA3KBvQiGBpN0sw6dlfGPLRzc1EY4YitYXexwvJXRcawlEeqeIPdn2Zq9Zp3N8pW4nvEArE6KRzDgfNmu2RkZxT7Vz/jF77b7MN2AyHI6VcyJ71wdkZ8ELQfRRUBPuP0hm994ghF+XQGccKo870+3/TaGIO4mWbp6nO76bJYmTaYNBcIH7rv7iG63ejgdadKhydv3ABms4OjH27DHZomHkyDNHtUP/BHI6iEVrpme75GQxGoPH/lJtzFehcJf0G+fHYxHAHExcKlN8ncOu29mVeoxE/vRUbqexW5ZOaQCwgK3HtyO1+vjvPvj2BmM6u8n8C2Bn81kZncVWDqC5kZuc4gU+a88tlSDdWM0ACblZxsS0WW495WfqN4Seklyd2EKF45go2xn3rOUtcEiX9KWnVmJd1AJL9lnLtIPdteLR4wQ1h1n9FXuU/K7Om7HHCVY+RIU0EOW6w9FwFrnZ42AWcjumBea2pTfltoG+TImLdmYCZ39TcCH0UhR6oi9KlXrgW/8O7ISqOWhmclTj8Z/fZ3+aYUFK9R4swC+HblJ7K42fvzZaBO7uNNXXIqZ2iL8qeoYE7Uh1XAHxQiy+u+JjdXaj9Q96UignIA7ZpQhExWySrPRCYTgA27JEzPfyHgagS7cLUJA2k+65EpZvXqDc0UJR//u6voar73k94xlIyTjCAVKEjkjKndDWdpGzYdkBzY9ZeQqeIsbiHBH+WbLLqNEG33CMiUteKdxlaEPvt6RVzEWiM43n0ZND/SGWCIZJKVkrwUzUdfWclD7zMQ8V7HxsLDnYtCwFtufP5L7NE63HUV6Ysf5M7UchJWlYrqQ5iRpz3Zce8ym2ywnIwtHn3o/9nI6JG1idE/B3ghF7AlQ2/HkMqk2IBvjx0BnvRvOYkCmGQS3TCAYLQGNhSpxPqDBnd/OaNoDiy3Sn8V5bNLqwF3XqpyndJdprWSPk8jp5RN+mXJ8zk174pk1ppuPRvNnd0CoHiPvR9QZ8ojRf7e8jY9ZqdZtOmVqT3ImhFDb63W8sRPaOG9KRmaKC8+uBgpoYREaUkO5eRmDLG8KeElhbGnq9Sf7vYXWKZZMZ3km6M+IpVGvdFGCZlpwLB98L3DCYcXvj0ppjFHzIlPF7mLD5JseevdsSaBP44aYB6ma5AOr8SBRX3wsd7pTJx+QO5yOP+Tud3me5lj2Sv5R+NXZs0P4BxBK+Oh1H5/+ktqhTyXJr20vXlUugbswX3582cc83YM+k540C9vz6koh133svLrlZVHZ7UmfUSX0CE54Qiwrqdg7az5iVFDithHzGEcB0UJAYDTz+0gtbBVuyAaR59FUoQm9T0U6nC++rmhxkQkceE1IceCgKKWYuwDiSwt6XpLcZkfI8O2NiduiV6yMgNMB7t6907GWoEDdcH+Apb1h6k1ibkLN6OzaRAKOg85TL2uINRZKkREo3A9skLfTvX8p18IwmMbXOGJyPYfEv/oIMvQeRLog3vJIxkAsDh7Mgy3OCPYsWu7ophiDv8uqW4C4TFVZHemzUbSWVfZat41JjOweU2Eo6fwIX0pwCI3tq3uCRTtC/mkM0ENTl5L5cKkb0zUHjLjZtIGDmOzWRNYY9WFf7ZWCfO7t9VGk5GgJcOHhLYpxLXRctSKn8MNv52RAkIE4BtW5GoXgZaRlazws5ouoSiF1PxhU6mxhnLkxzAlu/JX4XYnupSJr2OYKg2OkSuhnZDJS9gA/EYHqQQm8dPDWMJNJ7PevqrAbmviuSXntRndE/xeqG30XKZBJuOOFZnCs0udn3TX7r0dcVWVC0dSuzLQ/MgpTPeF5QSUPWL7HLKnDtct/Q3kCOEv2Iy9s4Txzjv4EicdCjSHZfwuK6y7fZuXwf9KMemRu9gGfprXpTxCvxKtStbxtUds6WInnCciRLXktBEvob4oex/wEJ97GeTM0DST8Fg0cI7JQSdzhywog6/O/OKvHknH+wLsv+9ztsy1T8sXulbFiwUlDa+YDWIXhUCUHSAKTmZgJ0PdTJoX/v+g4SaRQVqIM73xMWxYKdPO++CEpoX9IptdVSAV28HlFsg3VhmizC9xrQeyMeKAT7EYkS1C0n5LoKalG2I27na7xqxJd3FOcbtdz6JjXk30KAuBEO+XFqGmL2OF1YtelKTjyGapDyeta4xWaQw9S4St0V9ASPovhR8alxL2NHwPO+BqUZ9j3CUwaKC738IyaVmvq6AWfe7gDmGrUP+y6wpOfGvVgDCmiGIiGB+ugbJCuewB5aEgakhR3nMJTNuXHiax6zPP5Yfcc6DQKCsWP64T0NwOKmictCm9l8BJNhNGfq/rLeeuCjO9FrJ+ykPJ4+9QadCzNuvhAZceQbSqjwXNElAV7XFkXq6xLf8V2EBwaX7Ezt03QU9dGyF1/f0BabAqrdUutc4BB2eFRrf4DBz4FlLCjpn4Ef3Bur+ajN9po+cqusD81n2Usu46IndjqHX0ytEPrnrEeWOlgGGiIA24MXlsUA+hrfnMLPrZSgMWSJJmLq1y7LxBaQ5iDgcuz4zBBezO3XYfuNyDc7R8ac/5AVC7QSZ9VL+mqfcD8zN4nO8AwygPBr3lnE7usXoL3Vk7REEhhiwA2J0VoSJEvGzrmEuF3doOucxds7oPaoNzLqZPCmk6gkejAX7Rnxd7QBLTKaBWsRFjEjsyjlOcrznxQ+Hf9gV1xWPzL+ZFoXzOUgGchy1GlfceASg4HrMAr7XDnHgA5fqvSD0kTCmQFrUYk14+nWIFTX4isnXR4D7avcns5wDHSBc8knV3j+Ubmi8+4+gUXU56xbLHQSHdcFZ3h6a9264QNkKKdi0uG+q6oMruEz+vw0JrADYmVwbm50fZUr8Nb2L03mVavAfDI+wwniVdkLPqvYFcELKKYC/v7cZ6bTFL2EyAIkxjtxj+Baly8OM1afuOJKJp2iRncUY7JDdKZbsP5QJUictMuOnsHet9PJhPn82os2OyClQwqgKukbv4nnyE156hwme15i2Pi/UIoDGw3iKpjqe/6oukoZJZEzAoUH18DSCi+xLj1k/1CYBKJbELXP4pTUhKpljH84DNwXj1GTBfGIFo6W09oYFyowP8VddYNeQ86ncQP61EMmqnrUW3U2HvUWjlEVuViFPSP6RE99QbcYlHdusC48/4ro1ElbJNoO7uQSedza+jKrY9ia9w7lKb1ydpCbcxrUfV0RF68xDfL4YjUUwshHU9BLbs78xjnIcDjxmbJdd4Mc8NAtpsUStw1emjVNxyhEuKFa69AFIejgh4gd0S0hFQ9z0dBJq6E8U6J11j6OByd92Vm5qkREER0kwo2OfpXj1QI/GovSEAFeqqC65jiwNwKbVoMz1/dP9TnU1SHchanLYVCZR4rkYsm+XxpQmgY/DlrsciN81+q/vHz75LVvCQlXpFAWEpQZi+1rB42WMjOm0CqQW+AQu7k/SeUjt5HRkbs8NFuJScyVtmHll4vgv8qGNIAgr13hUu66ZMEfb9Z19y16xeiCLVpVOe10c8eQVqtkeis/9Ea9ooVFrqwdp5ghiBm9fSmyIPEBuvszZNDDcfHkFBca/Eu3/FUulgaDkpwT4Ke6+THLhah3bMMmgBTdfDdAeiOQ4bUpN7nURDIjn7YlYo0KKIWoh7QmRo2KAFjNgP5rD3OWgbF8eg7mMBC8wiKV4hCQtRsp751cXxaudK1/OI1UW5LIQ+z5kg6/2S/ZqTqqd44gXMLBWH5V7MVdfc7WNugwGDBuESqTcqmOHzhjosaovvv+JIo+6iGUJQGYTiMY+XB7dDf+bmcGaxzylfrqQwn9NloE5wSoq0M86f4Z9pu5kZIxGDL/wrVXPOwznKiy+ZGOx+nz5l+ORAsnVVkZv+t2WaNkU+mUxaCde1Akko+wlkzh3Z0eJ7pXJiC/6Y5Suqi+TghHS/4JMJWiZNDT6+7NdukJ3IEiwhbsGwNiktC+bwl5SW1iNIRauvGrrwjBkwWSWGlBkVbqrDtSkBXrRI0r5k6LPNLLoNU0x1U4tZLPTTj/YukJvvwmX3bZFzGNATIpXnaqR90LMpiOJ3Vnwzh6cslmTevmNQDfnZ/FHALqMdub2YPwdzk7QTHc9t67x0qht2FxUDPMh5Y1IytPai0eCYKzrxNmsw+CCRrH1N5K1NZL6K1tFSWp7yntUeNyWNcBi5cySM41E8ycIRM3bzHxYOEBR/g3fcJP6pGdA8dexhvLhV7NZzTmbwFWIZkyApxRdS/sY4PRaAnY2LSlXk7+TA7FMcz7/9Jbh5puWbgrVeqF75nWS3t/xImvBJ3YuxDYaE3PVwXoVUJz12UmeuBz2hPT5sQ500wzw2sMTWUWNmv6nXL4aLq8am/SyIKzd0l/3kDuvZl59CfLwpd/7+H91tPQfe+hDadN2f67C1LZ5Abk4dpQ2ciS0J/Z32zw6t34mzGsFMQRHhZzzPgy280sDNDeRAm4czpTz2C0enAVz9WzvOKErycqzQ2Lx3YzYY0eWt3g82CFV8dNiMzsQkWd8zqsWkKwqJoiI/A6bgKC1uIUBjFigf7mEQor8GP/2ctspGKidqcO/GjWCNM/Alxd62PJ8rJtIUetHEvEHpVc46554KRg67ss92t6Tk4UKL4FW8+jtLqAPKGnjH6D+98XbnuBl1Sz8XzooShcun/ZijiOl7y20cHzucFXtgj6pm40yiRTd8YCQwABZvq1QVGERrjQntC2qV9STjkrw+YNi8qor+Ghu2/S+6SIEVu5ZRhhri76OTj21eGdT8HGHTka24siiN8Ew8yZiXRGi3dA3L/YD9wuhWZs1uUbWSO0ry0AAU4E6PhdzoM9lSUxJZGtvCKeoemlq6eK8q7K6fsr6zaFP7Lzg0GoOuLaLo9dRSkglxaclrfNd63zQkTEk9lV8QSE1XtHTcYNhCBO1Mzl/8cEF775ydmq1Sx7jZiIgyX4ik3dofscnyYm5/Zfoly1MTCK3roL6wG4TnFFIjBIUluKF4E+wCsWUemNZHFUUspwat2EsswQzElI043hUkBUN32hXd9SHsejhk0zQavG/f3fBtBxfuZpcbjDL5/uVSUHF/t5bqJfEP1CuYXSn8sqW6tVoMljzxSyi8daKI+SouGr2ebya5pU9T+ypLWNe/7+eqJFAUxNLEiQTwbglXC0qnHKLY1ZcOk7qOR34khiLI0Y0bFbEr7LhTljRlIgvmUkygbnfhyy8KO8jsfMu4chLE6v9OJsE4kataFu/kFa2V3pzcCpZAVM4TjhVoaWYDtetv+RybOrW6hH/Z+mIj4QALizjY5RtccsxKxuuK8LK0++n/BkY1CUQNQUk8s2pSqo9ca9zV/9/XdfSjXBKtL9IyxUpczwE333JG/WAwXJrTlZnSUENxN0UCFYHjSMiSFyG0cYH257tVthW7TDa6ubGhEEgPG5LQPkG0aGdmcmTXGbXwrL18qren278VzBqaz9c3ujehwQM48dApF0YuU5Fq8dKQFPufaAf1IgAT+bLiof978L9kkbRP+P5P7dFNUZKNDseq4joB4oHQ8YVCevxDqdsaTWEw48l84n5qQZ5QGjR3JbOmb/Q8wuiqL5Xthw6b7aKEET2Jmz8xdg8q42zIOQrHQj8Ymc2q/2+UeJgU3NKbMOkMhzfd2+4y7su+RZ6666LklnG9wj6UKyPMRj7qfF6CaI8jhv8asC7JyIz/qbTKyxL5gcvBCVOJxuWSpl187URIT0v83m8j6Svsvrt67mx5zwUcx/yJvgplxubwq+P6nRgMDYUV1mSS846TaSJTEQlF0Ozo8NXKno4tQjJrGEaHYi+k/Zk63KEO3LOqI6wjmlTsa3Ko9C4zKpNv971G0V3EMeQPClWzed/lYsdiHYFGgFxW9ILaw2d9DI0QWK81R6kb05H+Yyta5hbXGbf+kwbLwdtBtxZx8NKMF8m32KCG+72qgLwUySN/MK8HS+AQtepNxhT+o/kwPEFNBt8groOgMUgKDPbozuia5RAcj1WwgFIz2hy3m5v162EZMSQ3iO4irrZqWtNbpTb+ZydUoPNCHxbMaQo6Mp47NKedvyDoOXWszpV2kF8ko6m7GLNDHjddho30/PMsW/tGigTBTbrfdqZ2vOYt7K2uedt8M77F925tcZ78N3FKvN7PDZ32E1Shg9jwhrYbWVX7STYSTt6EES+jaaMxcvCtol1foaV9WR0rojcl1K1XbFpAM80UiXCr2IeFfDM7xMVkxpvfwso1vmCofg5PQrl4CuCK/6C5n6jzGCtZYq+NYJj6QuZXPAc9zldAs+yr0Y9vj+HgmNhVX9pZ/Qdbprw3BtiwIcXyd+UwYvE3fjwzuqU6jeOf81KmrLDOEvu6Dv+gKA/AkG44K4U7EJzXYNZ/NlAe+pf6EbNoe9ofJmbNcZ7vE/9gSclrf/m7IiVRpGUITLWd2Cs4QO2tOA9lstczRef0MahxGfV7XBaFq0IXYhon/uqClufTMtjkIKwGBMtd1oQYx1gHa6fgO31NNA7TONzQC05TNENM7gRkB7vWvCETrmhGbdN4ug6vJLRIJVMyUKDilCW6Ivbzv756TsENdRxO1HVuF/1mBxxaDbVfJDg+6eqBQF9IpAI3WT1pEOi7TSN1RpYA3nM3x/9Jkedn2w+y7ELRwB3X59s0lRFJOFoylfH2eQ46/vkPVKwgGRRxmdtYxXcbikwrLC70FvOXj3CG9aMvcUOpf5tbGH1cxo+ZA4USjicB8Wf9/Bag/kgmfJDroU9Mf0e3VgwcNR8WTSJrCTyjNsXlw58VTvTCho0zf+BJ4AzcZwLEPF822xoI4bSPxMF4gUpQyBImYqvRVavZaD22nyULHPSKvQlFn8clzKOkQPFyfLexmM3zBSKumGfikNBAK17WgXFLcwaJbbHsTNtNSCgPTAIYA+mf4jW4Zp9k0U+SmEc75nHxFPwKUuNlv9yiADtr7MKpfFrrGqla1A8wmgdFdmBu7L+yfQfVyn6LGmUlYyIbFvR7DZqpAWlH49tm/pfdC9NUjDrMcp9l+tYpyGqbR8Sr6UghfMaKTLlBoO56MykNsD2m2W1paDFVuGJuAz5GeU0VnUcmfipyKAFPJQCmclfNCPto3kizZkcMR2Fu1bTCKe4hPXPOW21a31+IczKeVqq45d0dp2vfsi6XD7QlZs6LGIW6W6cffnhQUX6pEHLEnju2tOPJm/fI2kJknmB7xZXgrS15gT7IjkqpQIwYLlIEHeQNRl/n5fe90yeG4CS/vRFsl0CPb/Xy1JpGGZH1l7JsnG/XCjTOuFjAV5ONPR0Mr3puM04r9gDgbmKr9hDOwqzEzIqcttrgkaCdzihiau4kc7VyXUTgxEf64++FuP4RhFc3LSXAc9VsChzi+XiWzU0XVhK1MFNRhL/lYRUz6iJ6jNm2zJ2piY9sTE7O7NB5DYmDAhaIYL7YA8nLze9ebzftEwQgVTMZcOpL5eGe+NG2oN3lcdFrQ7XU80xTt/zo5zmc3NH4/LN/7FEwsS7HtMcwvqJc8bMpcm5jkRTSndIjRVaDeFDOr2k1Qi7G05GWlxHgkFKNNN3KqYulNgw3aWuS3NWjaaVtCVMh0vj513GN/7mFqT7i6Kk5a2gUPuFQ84v5WagXY3zTs6EGllC8ULfV1+Lqg9zemd7iPRLoEi7Cx1mZ9zplyHZb0tO3lUB6yzAN8BoK+MI35beVlZ3G5ltDkFtjGmXVOR6BVIBgSNX7HsNtW2TtGZd9RKUulHpQe/nwmEbK8BMT0p1kPYLfeNkn9vXmyt8X05i+mI+Zy+tvuTzzMnwrS3TklGy1Asboi8LOtALQzla/nytlNpnZSdasW0ydmS/+5rpwP5r63Y1By0AXNpveQHaoIQtf0uwXPRPEMGC04z++08P4tZCmEQ6ROH9YK8kTHJIGb5pSP1O0IPmqkOZDVTxOdUMBlS9JkSYwUCMsH0S6rJHNhzqsnmnXAg8V1RB2abUGxPq0Ng0Nf56SNjlECMl86vJZ//reJ1iUaHRsRvxrRf3zyRxecDyqjZCnHi6K1P5RcdxLH9x85N8d0SHha+Irqiq6OJFl3x3cJmEcUfsPpvKZdeFCmU4sIXJz/uwSbclINRe08c2GPKVo2T4YJTGEYl108FV15PU5Tgfg0PgDKNB4RAIlan7F5Kuc0B14Yidq6PShKpmRVBZ5DK7PLKBCwusDNxVriubbcK3e9gLwE1le42pUxt6II9WeqWyEdqRSIbRWBa+UUE+BZhiYC0asIY1Mt4rQnROh8/fzRowcw6bAkMXbBKVgfvxz+pgfiazWam4BIlJYPWzSplErW/oG172Zi0NcMnEm9qXbTRU/9Ho9B+hqQxJpIzeey7X7F1EWGPyHmYaAvLHwQdcz4+Xx95uINW1/4P6aMXX9hmTW+aD5Poeyub5KLwWvLcQD9jCvHZTUGW8am0huHI01wDSWjuz/gXQ+qC/kCXMtjX6B/DceR2SylKXkoAkBDc2k83OH1dpUrPkEQgIMQIsvFeBUlSUTaJgnIyLrBbg5vHjkBfp/L4zZFKxJof5G02ui+/Q/SYRwj18tE4MPhtDgBto5bcokUYMW958vz86yrvkpSKsQ8i4xfZxcujtPNx1oUkoflOd9AOzqIxorja2WmDqgywKAOcIF/ttdpSeyPK6RwQDRC30CtwWAtGDSEUs+ro9GTS3HY9FIiWs2Wt1YQSvT8LDD/HyhS8CXU5k6Y6KRC80f1tSWCsqQOZRASuNJN/CZ3fnbVqJ2qpYhpgadaFmPoZ8Wn0PxnwX/2YPRFOyjOHywNBV/ZOObNk/VrnvwgBHYM8MyNWl5sgHAs01ciWenGJDU4rRe/PSae0sDlG9UgsIZ2zu/t8NOZ0er+tT9xVFEifIEfn69K51Ll0cGisijWlI5HEyAEiQE+8iEWPdWXU6A2Y2hzv4JM7Z5GD5zLU1YTXE/oCH/0H/6GxQOpHr09dIPv7Jd8J0NgvhNjUgBgxVQpga9Znyg3jARk1RVwfWlQpyFyLSHxV2jQSrO2C1Zlq7jKQ/iqUrOxUUiC9tOncn8Xw0rJfDnWZeZDNvxvmpb7O08X5pl3ZH4UMaSWWEbyqCd3pdocmBk46LLvYLCP6SXZXlIhES+YhWVDrMB6VjMt2IyOifXef3Be5DF0aK9y0Rv0m3LWDGlxCc4BW/s0W9EfnGU9mxK4EXx4di/Yl2mODktoeSa4FBykkk0XZwLsBND+SouSJ0EGGuswxu+FweAWXpnhw1WwZrcwr4XJPD0JRD5F7RmrmK7Ld5nfU+hwfoHZTH9nmvrqA8Gsvfj1nrc0l4Bp0iyfGeQhmHveUNshBAAJ7LRChszQKbfMPf7wO8+woJSjobu59oEW5hWK2n7mSyMreQSy5ybzL6O0QrZk8mz39rFU+seOdU8ZN1GX4xh8cw5qk0b5GBe4eQNDQaSbu5RaXhvZ1+BJqZJgDQapUsMdfElmN+UXifVsiO2P1SE6RPJTwCqE4jLZlSYx+xFjskk78JDQ6abxRXDnzWmZ0gWKiv6186QpBVXEhQ9KxLZ+A8dDOIHuLVCTLka90+G4jHBRWGlK3YIwNEWobc4o/bcMKmjRAjU1bgcZ3DM1ACvB3x6G7O4MVMsuB0YEJ02NBqvDuNhEREgekmloTTPnTHhJ7vIyQ7AM55n2O25fqvhz5FQyitjS/TpCQMY5kXodGiC1cUwxvdnXyw2TaNiq+kmeyyRMQowGJQrr3VcHvdUPbFZf9d1oQDDl6h3vSv6xeIOvhlFrSRpuw0dBUbNPmO9T7HGDx+dSlp2uqELyEz48LiE1pE8vEHHvYN2RJVBnzkT3MRMTchoV5oJGZpfMuVtSIhLxwLrIJBSOtswmjMOTbe5eg2nEZWX8S3dsqRJgWPLLXLFlCMEUix8oXoCg/F2BB5zdPFeCm9809LZxmoVpz56G07qq8sI5uWxeMqclTiverTPzI999rf6M9H1I2c0P61PHn93bVV9za6VlFV9VeInTsbDsTu5xuhZaP3XDVcc8DBHeLjBTlfTDLfCtf/YE9Hw4xGdc78r+EeD06gKDQGV4SUKjL4dL092f8MbXNoPB5Kr9I59WeYo324ZOpQeeqd+vAcb3OZA5RApIvtEyadGNQAVG3AFW+WnqiCMTpL3MHTX+2H2LSW2aVLz+TDcPuMqBvM5l8bGbZL2nJvwXZUF2++jJe1zU6HvgI2Lor62opBTA5gKNPQnSWQlmkMM9irDoBBIF6evT/sHrANpRPal+4w+3jgz2iTmJ43JgYTUfFZ05MRIbVIoH/NHSFVwWDDRIJ2d/a2j6iAIXXGc4fx/IGFSiZuj+xbAF9onfVCARmACYpRAG7j6wCGtDfReocLunY6copmH5Q45yn3xIeyMGSaPyBYF7RzuJFTatUMuxzG5Txqdwz0Q42bpFdYrL+7k36yktdretSRO0dx1nVU2yJIg7nN/VMfNcfH2tFhhZkSk2xwgBLP4o88XBq+ucIIi1KP8ALX/toTXYkXacoDAJbbeuI5aTjGJumoWlRx85tiXaHgRbaPybBmGyt9EUQiqXDX7E3EOe+HuxeypqOtwZV7/QYCGRCfP9dxJ1hbVlkKCt0j+QkJPGm9lmzpXQ8xfP0gEj2CifMBZGR9be/P52l87L79MVvIEqYo4Fm5YBiO3PVWS0vLsBqH92ZEd7oyAsfsUy89HnWgAB6yp5/DP/mZC9X5G1mEohy/Ibv/mCMpgi1cISuWf0aPlz6EX12l6uyVgwJ5P5bQnKyGOib0gKNjeksJWrO6o0ntZJkbhAOkZnCjtzS5END8R8I+XTzDslEKh2TM3PQE0dBkc+77aqJK+3VV6Maic8RHAYfl7Iwl1lfE+nllI9iICMnFYLVRac7TWwJS1BH0slFznh/Q31x88NLlR1nOFcrMeqsXgeT61hkABI0RbBxMWknceieuG9MTUzJMJ1yTU8tyu+jAvs3su9Q2ravT6LWbNxLyW8H+aecpF+l4BC0JlEJWIMgu8OLth5xNk2Rttf1rCfEOaVLh5SjGvWtzwFP18ILNC4U+CcLxkTItqtNEC2boFooFT1N8X2QvR7pDG5jJ8CVSOVoSp+2MaRFPiPshAreEgGnjak9Oauo7cfJtKbFQXC134EQkyomsiM5PdsHYxuYrGIo/XloU9ei1AT2Y3ndq1xVwEc67tv952+NjWNjgMkkXixgPEUcKL4YSuqT1onQYKPaktrKgpNilzoX7Zm9RpBs1Weg/2961Ayg1qryXmtrDh0FfNE+AxoNAREcV8fNrxD/b4+lMRrq8C1YFxqP91yzztbHz6LCS/+CIWtnBIyiBXlHdKCoxeKPKpvOm8riJyFf+dYf4JxTyL4wu2z3gFgYaLT9i/iczdBztdUwHGcf3rxs86Z9M0bdwyK8ra7JhYyPZzcjrnVnpeIF+doVRoNOvOV1ThOVQtCVXaHSlKMRXCqwZ7UXC+XD2J+C2dCeCPf2tD3MG/9SH2FXj3j7VmrKvSIWMeOqGbq3EZEe+l/y6fW28/qDJbI64NYmElAufnS7GQhgXZ6O8Z3MP1OOyYo5F/zlxzZCKhoR21xYhQqgs900dkHwPeN9U3wCVd9jcFyizjevfxCvcPFmf7YoqXQ5LGgJUZCQAvoFKebTzTd8Xv9/I3ygxKlMLYY6YXLn67ircKz2x1z5yyEAWHSyhLkFMCs0k1yq5VNKB57VDf05dSgvdYrWUGKAj/JkL6SXOGcTs6rgSTh7O6frzyZLbRHZUp2gA7T4LRmCIZjSrjoIz8GnDya9N4WdCSCforr7FW7mJyTnRvjsv+x27JnX13zW8fj07MHxnIpKsXcQcKx4inzojRdt/SBRPui+q6eRpYuOFTqqXDAtESO9QF8ZbiWnE10tLvDZApdRGt3ZhCwFBf3WmnnjASfJcNYqk1n6IcsNe81ieAkjFeSb8Mi36dtJCPJ47QOE/J14zNJ9iehsiAyDbrU0vidDk4/BDce/OxFS7zFFENPZ11p93rsytjfOu5ln/z4Prnfxr1LYX5F0RowQjMGcrknApBA7aNzuJvWeqtrS/HHHaOP6VKZJQZ7hnwgBg43WJ0wPZjLCht0wBsynws9Sy7SxPIbeRG+BkbwOyI8DRY+ZtKVqMm4T0qGu7M4HNJx7AKp9DksuyCfxgqyUmg/KZStALrE78FeEG2H8OWCVxEYotNUpqUkRCIkd4eacrd9FSYuqlbKltQ5GGkvCdC0nec93xOmrbf0G/7kh70i5DxVfZqz0Rjq8VjUJHCIy9/mZOrO4MojJ74fSQ5Vo5ReBbUZ7nLlel4l4ohHJH2xuoL2Z/P+ZPrakUA4YrzcLQlKpctQfmWQ+YMWQDjFugbE3OzLrtQO9wEozfwuVCjjb+PHZyiwUnZvtTYqAnFYulYv48x+llVWBYSXXACZuLKhbixZ0wYO+eaZ97ghIhOUfj0rlDNLLErzZNwBYSIQNTOITURe7GnlbDXLFMognOMS+s6stbDsAt7YfGiHCRzVLxL4snMzcLuH78/skLo6gVUycv1UBN/FVp7feMS8EHJTL3RgMThNKVkp65xkYjoyIJ6opVD0Bt7L8HbYuo3EszCv5FAuyk8/zyAvmEDOx8jxyCOoVfi5nF13M5W7Nv/qXybSzKlt6EAztLKT0lHWVEsEGgw/l6lmjQ1jPcvxNTMtt2m2X9EF0B0nmc7KXhLWACy4ut4S0eGTRpGm8KT9F1pjBZ9FSltCji3VtdAmZxIVjWZdV1DI9+KB7lNviDvHjgxDrAj+zX6yQO3gaHsMfER+zSYoEd0kEZfQclPYi9CMP19Oo92gec5LISPXIExArYDy/WExT83pHxrh8Ck0LDgB6ezPA4yB3k3qeGHZt/3Ry74EIQkMG6jiN4ZqSklXNIQgG2sCcxqaKQNElJjptrp8HwhtdjukKjv6rlfAeZHfhebz8INQ3odk0oOasX1Q8pn7/hswMNgdwZA8wKm9z4ko6fSunt+wTsDwtAuFFqm0s+fDd37Kw5zJyNRNIT0JApOeJ7DG9GNg5OuHls3iL35puK4OfxZSdTOnoMiKlvprQsjnKXXek4tZ6AVqG4v8S7Pp74a6NI8by/neTiBF2zBqpz0dNAbzzCZuTbOumc6fL1HRFZOb4otEUjgHNCGLLERLgxPYoVl7fLnQPfDyVrB3ay9poo4IR9iIByhwcSKkeJMvrm907oWml+3n8C8NpJFMbxPghzN2PIT4PGEkZm8vZtQCZSZTikAv9WpnF9NEiuM7D9yJ4DJqaS25O+aJy5EUXGsHhlehbmCBk1oUjToty/FyRQV9znJcZ2fu6qXoKi2JkM2Y849ptiOxFXpZPc6giujPSztz8MlfZ/RhSjyUH2hFiWr8BuGOKKz76pyUSAFKDrh93uaLBm8YrtcW7v464yXzXwWVXtnTNzfQLY3GLjC0wju1mWza44BjOetpUzEHz6RVtlazcoHG8zeXTVc+zWJuRfk0TgJ1JZrkN4P091EkRE+AJ7BAxRsZfetVgN2ju4TKtB+IM1QG1L0m+q81HNQvJpesZ2nU1XcjmqaA0soQ23o+pIMA9fVyuuQXis7oOS7KcD5HQ/ed9Qo7A0+Ichr/7Oc6RH7O4gynKFbpQQIbEshy6jt2eXiyYBPBk/A78oL5jw8+91FZnlJpsAuC77XK8FO06VQBJrGq4+S+QY67RrHAATM3D3YgecPGSGcxtks0Arj7tPt0Dtk/tmrP6BphWXm/SXT15e2E0AOWDVa9TL/ZdhONkzjZNuWqxiONmI418gn4jiH631CfEMXrmM3ddDX+mqT8aORiTl0+WuQEEjli0Z/a8rpWi+SdtGAMPyNaKJj89BNs+S4vahDm6AjKbN68VQJAyCpA5lzcNW7EHTEGW7SVz5t8dy2v0uEURuK+xn2eqTXnLUbvfmNhPJ87E2V9LspqlojwCKXlZg/BsdFeYuASO72uQhFIGC0J3eSQUlRY7YijCC3uOap80TghepjCTQmReKG3QvtKUneRGcs0Wu2qft7BUxe1oJoMLBHG0+gj41nUwn+r+ln9B2hLSm7tOnDzoO1B2fejI1wprCFkYOgpb3dvvlIYxt2J2B0rVPbe6Xh4kfcSVd5EjjBgpERjobNsMtJcj1K0Ix3R4ksTDdyMJe1Fhc7WhOGb7DNI+7vAtdsWPMYF1LAPJaFcyeeZ7xgLeeMf+Iyv0294bi/Yx4b2vJqh6j+2ygCl16yNqETc5wENG9qZyEbINO45OGfG4DCNuz6VS/ah1O61+JVZSceSqrE48yHTPyS9zc1N0+PCNMQeD32HWgt0u4f3RU+utudtNHFHmYD8QkLX27xahaWpxuvTBr8FZP5KwmBxq5NCMXMlI4OLdD41SYh5hpYb1OZ5ftjtkzgy6RBe1fFJIS5t1za7fHGKf/U0cQDgohHSYQG7SlhyAiuGwPCEN2wPgr6Dyhjh0Pu5+hLAW+6kTEi93r8fm7lyNmLRPMmfg1tx6blltmcQYJLMgxKprFhajbzCQHjsNU/jWmCql7j6Y6uWy9THH6VTo5DyNt32+Qw2WlIzHq0G7ykz+elyioqoDXrGJqtnsG7dQV36+brRuE7AzaRn+9uWcB6JB4tO4qPb6g4UJOBY/D2f9EcrkQecje3pIsQwwEoemY7Zi4iIlS47tZAEsQqNtogu+VjUUaaK0+vSo8grqepG5KXQc0e9IyZV2TPFwol3+lvmPHFj7q2K5jkUc7suc6tYJ3olWEHRKtiUhCSTbq1A/mxYqD1VBqg9KVFAPk1m8S+0EVIB9vClxgH9ni6qFHRrb3idNxno/w2I9V7yngu2YCr5Vae36Cx0t1DXOgpNTN4q4oLxTw/1oN+G5hBq12jnLTA9tIZrEuNIB8heDxocFfCEdvv1JSVuNdq4gTIuPLDUSuPSu6goGBclL82Yb95zFxa0y51YJvllnFjKrFLq+4lqMLIXYDK2romDHKQcRbftrzYQHq55071GiWxRYPQeOBPruU+m8TlwVSDltiAE2S0OBDolulwQbyCA/6WCbOseJkehbgpRgsqfh13OG6CSBxubUQcy2jCDYnrYxOxy4UCtEPGdcJDRDHSMc2slvi2pwPzPei7YOntkk0uqcV8EsjreH6mjMv7ale/6KiIuJTamPX0EyIoEnh37t2Wmrx3fDPJqB8jK9yc96u7cNgO0R9Z9x1z47KNMS538iqL9oF1Pk88q6sR6tHrCoETeqt1fjLGHpc+u9/C2d4iv5IfJDsEXxAi7GIV2kIm4Y5AXeny7Wx5wbl0b5IMhgovQjymDP7u0FolFIjuZux39NSsOwZdqY3m2jjvO/i38kDxtNi4GmrIPAkrswd+SHV7x2/ntsa3Wm2P3xZwGYDdMPSZZhYvigwQB0vTiJYXY9paa6eW4EZeKk6ynCkiPJxOZfNlt7ytSx+89RSfscyHEL1tJ4NydXjMggkDHR83zgeiWrPzdJ6JSaEiix/0iReRpd/99Kdi1ik0midpIPbACwRz4LagpGo/8aTU8EQAdj+XmnpeF8j/+YULSO+Aa6cDIocNGClw57Jn0Ys7YhwkeK3vl0XM6UaX0dqOl7IVFywKuHDfZeKTzkmEFiXHrpTIGu2Ik2YUXdS3c2Efo+Pg9FzMSvwlIC5ZEgt/dkbug2kRpbWKG6eqL6vyP+3nO57Xmv1HCuKoXU2EAakBRQ7OJFT6Vz5kvQ7LCAAmKwQU0DjWPz0J6IN0i9wHz88y4MhpbQnfoNs6KsbZKYPAV6NgsVB7HW5RfgRK5ze2/DaAud+3obqoozCTdImntTFIc9KMVQuEusn8do5AnboODPVXKO3READ9YuLoBJ0QduHsKZHfe7n1xrYc2P2lLot79w3dJh4Z9NSaFtrV7Tq1rASbHFrpVeqfeGuKogrcuxKtmn36Xetxc8FDggNOnkKOJmzbiCDEUyXQVw8+Kz+HGk6XcJHElzjpFOmxNxEa6CFRVNJ2kxkzwbncT0yya+mlLXJc2+2RXvNoRrnM6YRUaCFpCrEc+/Y9hnuwwAuh+PVLir2+7vwY80jfDas0XCtOrsHx2z4/WMaAx1KlRxOeQKaZDVhzQYg/4/KhAv2rqhVo+NOPHxHqJ/vbvw2z5tp3il8/VH3dFI++2HnQ/zUyT6uRugjlgOtNiVHC+dKzheofi5LolR7JFFTx36v0CipaPDoSVSNcruKJ1hASpmXy7MYr6afTD3fECnKMQ/ZPtSUVZyD9DQECPu5c+HWWDjrvqhSt2nogW23oQoYA2SNByZAozHM/TE6K+ZgEgv9+4o/LaFCZriR4SyH3EIAm8ADfPbURL/pHCiYt/yZ9+y+TkC/T0VLYQFBSaLOs3SH8Hywzs/6vxg80Ujz2eEnTVj3yabMEQ9X+sqUhAsMrZiz8ZF3G5fQpeYHrQxp23u7Rl0LDNoR1OCR47TZGT8CJ/hN1M7oUD6z954a3vd2kB5yPQPNNovesMfXoRUDdPYhzAgHCb+fGX28Qrj2t7nHfEK07+9ke61JlRi9EdySnVx5JAdwgYhLWTWcEstFxH1pNWcTW3iVdvvE9WsmGYHckNy+2TV6/IW3aH7h+P+WlmcM72HSuS5USiAKgXgA4zL7SvS2w4q8ful/9JJr+HRMcEIwUvwqxxIVTyGTf/oOTPQlFAEawZ2Jc7R3j5DLTYJgzdD24miipIDFi25XYjF4nnlRknzqU7Bv4UuuVVsttAVBqMPsgiyv7CdIyTMV7J1A6iAP16YCCrB4WKsy7Q4NIHDPSFSn8iIKOma2FDKy58D6XJo0HumT7v1s5AdgsFPkdn/Ul8sI5DXBdA53hHtpaORqbBSsNBOSN+OaSLgJLxqgk9gNNwQL1319Yuou5VWmig1SzPUmhXh0pjGgcEHBJm5w5zui3gvUEcNVjCxiG7PcHbot/wXjU4klcXSYVa6hMY2jWjk6Mwe4C8NfMzia0L52KOB/Eulou6jgF4L8qYnOL9FHunZoLvBK8cJXEWjxchjkX3pDXCcPJ1rYFqWAc+7tCaBE5bYHqDCu646ULof/RWFPP+vTtJeq6yn0KFVk3iCJV48i7nTCPOH1a4Lwnht/cIVpnoZHH9a4Qq2jp8Y3AEWr+ncU8l+pRvA/wPSzXsat3gQCbtZGZq0OgZZCwWW5OLcokvtrWKPV96qZx3k8uHxHap8C1vcv3Pn+KuatIN2vsey5GqCepbbWQcO0mi5dKUEK3b/36sakayephFuYwvcYC7O1kfudB9zFuiukXENUwlE9FlEPQ+5fnaTlLVkTdAwK9D3V+mMdRjeS0UdC2+wetDMXxXgHWcCOaRS87UQRk/q2Rkhc6G+6xBHktHOxFCJYt/qfRVoZ8dQeLfXAS9FDkm5ItRqNCg3HrVERjmBG5lyyIo2oiOv9RIBJIojnfusiPMnWhPC4qmgPiRDTQjx2iIDnLZh74qlD0ukqlVWDYDvKmiQ/kaAAGDweoe9Nh8PkwOJ23kbEfJJAusCy/kXkejhYfMGZysTdFnE5T8eNE4e6Q4/lDDwF/KxfhmVsX0IDPqim8cqgMZl/daReCbID6a+J+9cSpkujPWFXYyXC8XgRDP9b/2mw23SWx4qPl9U61JQPn4viAExjXLVtvYO4NGg7ytAFZYTZOam93VOxW8jKzxOKjzKWFCVqfktD14tLWjg6LrnCfA1Fa9vDa6eToj6HgXGJFYC7xHMeHJotfC/E0Z30R9kZObaLk0jGjBHyHe/S4MLrFdZFSDnM173xHBMiIhwtrdjGKEuB4iwHYQ9lXe0dOILZdho7nab+3zLw8lSP521kCOss4yugmPQjRURC1MrTfhbhas8/82J7A4R/dcYybFfmn0m2uIvJwmdo+Sge8t4O+kJsj20hAlw40O6I4tVCcMiK1cg8550tUttm9tM3EjV73OhLPoKK9Wb9Gpa6OZitbaG+1lvgq8w1wFLpl7JpBsAvKvmFlnNnj8zJYymCfiE84oRpCyBj+zEgg9pU42YFLI2THMPssTRC6m7SyqjKJzpR6UDUIAvD1Mw/wD70K4sPs3bP1cD/XBbW4cl42ojt/11OGFWGs1h0lYvEYomhDIyxSTCKaj86YPBPMaxcqBOj+o82p0hqErb+LQqNP1JZmHoHDWZtYU5Jmia8XK0zAPbhxzH/BK8O4IUFwMGBkP4q/NBL8KBwCq4EDK1oAVYMuGg3KhjJQbUZHu6YPrmNnId2HmYWrXhfAZAzk0U9pX/yOk+kEGE9lN7yTZIkYB4wwgjCyVkFftgaUWkTUCVcOCVx/HlR4EG1h+QA26kB+B8OtGMx1oqdFoqgiw3tSleNa5BPzL2q5Lj2Biq1mEoaqzlTrXo+eldhXgmwFZWk8sDbjok0kRbJ04LlS4ByPlQWuTR9fXT73cAEKSSPetXJvRWnHpmT2ihiNaQe+dfWiCeeV7lhNEtqf2KhMZGHQVrmmZvnjq0/MVQN6XYdjEACbD/zxH02V22RpZVdO2/pT5iMPL/MfXTX0tVwvwrNgr6NlzY5epVQ3zogJ0XLevlPpuQ/9SRHRhqWc8/oGImD916baepqm1lGRxRJy3YP2Mc870HH16KejiInv9IoWTr0U2eW0ftNf3dGXCPU0oAPCZJ0LEdgJts+99W5jiz9pqbkp7cH205nUYl0mlQRTzePdxXlFAm3v8yLXKabXB1tzXvtwTWtyBafgd3QG7qHfUdhl3fqjwvpkmDGIyvMP0jQL4JXa9DAKS0DP5twHlZc8qOpEJ5U9MkWYSn1+FGtMz67BYlB6QXmWa214UC7GsZDJ/L1gPvj7ZlLnybOj4b+mS7mUYGL07XQna3BcNwiOQa/NKD7qjf/AoF/JUrFmvTqEARJfWCY9FIEKBSSoYJ6yVfGAGdtxfw+hhk60lhiLvM3x73MCirtl7WSjDT5zI6FA0y1ukFQWrBcT7Uy2aZ2yURTiBAo4bJtlZxPxcszxO8EPYetQTheqfkPwTT/mMG6NoQmSuL2j096XtPbWSqh61x4MnmY59CPQBkfRIf+xGoqpJ5uq6Rs7HMGVZfMhJbvMTicD8BUKk0cY9UEyTfGAnMAfxKfqdsb7ShFm9Mp9Yao5+QwhMS3XzMLoJXwSnLUjXqfAVJZ+DQnxgUH8TNj9Fc9nbKeZvIeK6cjHs6C3/zxP5ckIcM9ov7DX1KgaTMMYAGzBgryeDNUbcmocMM303/rk0B3CAUHFbNiBPqb3gj/qfbKJEs1s/Vrj781ACn1bSxR5iiaAi0HM34yIxdGVgxj8ArLS/TA4uVfir5DPymdooNb7dtZh8tUbt2qaZZPFN/6qSe/YPo+sURa6yWlw5T5ke6qmLOddvmU6bLTOCXa5Z8NiaIS4YajjzB4avQsrGW4u/EvSNHMa0TgRg2WCP8uqlW3tFqKfG5tUbuazWLNgguWG2nFcZob+6jMOn/H+2JaH6XTXJwI+JiChrIj3hKPmgpQTwKf41BdVHvGmTPhYxaQYlc0gd+BFC5Da+jGPSVfEHQ0764f3suF4kzFoHl9pR5j7HAJ8Snm6epr/FykyUhn2Sss4YU6BLeV1PCr8OwEF0rvSN7nngxH7PQD4NDQQ2RJMPsDsFDISpnzcH2QxwZ22pjP2rwYpSL/C9Qa5P1YjXNGDLl+bBfwZ/kXnTfLXk9xrqhtw0tRrieyguYRT7Ly0lOkZ4wqdFHoWND0q+wV/3hTVENTG6iqC9SFTMLK8+evtlFAH7/KZ3BFV8rURiEQLVdCu/4lWupb6fXK8LB8JQMKY+Lew/ODHnXptDAts/9tb15nJopI60sslKBMm4Ch3pW7774MWK1DmgvdQY/UNha78YkRW7LFY0eT855b0gGiUpc6G9TlXsFUV8Ieon+EYL2mpn9u0C3YeoYgY6IQkvVw40lck60Mar3HrrXFhUkKP5PYa0CWbrMca5kdy0eYP/W5YDy51MEmhgMBi93x7PXT4aLvEaQCzcKoZ5cVGdAcPdWvbiq9dLSySUpA90mN9JO8gzv7EeZh45gsCuRnrOJnNViVhoWmRfdcF0Pf/Sm4/h2SvHbW8kQ4cW9EuynOEX3sN377qBJMx2wTkWCgZaAxPv58KAUYl/9U7K27GJnFv/GqQ8ssXMdvU8HsCje4FhG/vm9uuepNOQZFpa4rbml1304iCu59aeroAA2VYQ0ceyJfsYIosrJBqudj2gkvzeH1GIWfmlrxAEMSYIea+r+Kg2JEr5hEJrqmtVG/EDBIXj92qiJzg+RYNJ2bP0Xf3lZHyh+UUyVonHpHMBwgB5XVDn6d9GtxEclUrGl0m2Xe7o9Wj1RoCBHKaGcb1HZJALJjXdQgbOpr2+8XER1PnTnebhHTcG44w84eWs+UVmg2tMRabNljDqg3g1gj1vvh4I1cuOPBAjXCekBDJXFwNr+3+jBPdTt2g4ULl7AtSnxj6o2kQ338fwWT8JP9inAJm9vlge93u/rZ591MQxomOQiNYZ8lCivWEc1JArRDpkfvVsxM9bC/6q72az37DnGIrnezJirLigH08N+ZhrKliDBG1HLqMOmtBS0J9dAakUo4U8cAilkFaelMnmigWlqmuPN1O5QcB5UGvoJ/zyaLZ6uKL+iLSUj9GI7fnJlMgqsEG/9M3K5X6d7NACaTHqqpWv7mNiqsAPitCOeE/nuYwf80eBozipIBy52oihq0QVuE0F1YfPruVZaTU2MHnCGbfgAnsqi9iL4HZ5i6Vmel136TFPtETHWFzDZqTmlXKErl0Zk4/9GAgivjwsh9mEb0GcGTym6oqJW1rVXgJYrwyFhj6eirLiowNxiGvSecNn7sgCy5D31sPPCkUjfKQJ0IGWCqQu1qJa31MpCNJ/RgIKMWMYamMuoo1XklfvG9DPlYtbckeILlFoFXJdKAT+gk2MX+f1RDFgzX893jP9mwNKGn6rOjXoJ8Fzb6ntaNQqr70JLDiSxUKrCU38Su0xpGgcGIVXgJlKdjGIebc/wAiR4OJXGYjWFN7sTZcdXM6u6O3O79qY66HjhseKg3meXGZqJR5vVhvrT2EnylFjxUYOaHTEpdsh4oVNmUJHhIMJGMmfFA6pfTYpOtH+haoNxpjpzX2LtfCON9cy3AhbpQP2v2m92NYqjZGpwP/Ieow0EzWQfUVaTr7wFT5LWXXN9imSdnbbtGMeTLvtUp9PBkrg0N5eWAZJSiT4j+JaUYWRkhFOXaQ6HbCPVm6ReKwNiW4dpv+sP3w4FC1h++gEFohz2fAcKGhmQ6ls1EksQfeSpZ5BBgNRxdHJnC3PUatx3TY7vWEWcHdUwtjVs+lR6Gkbb/kiYpkXw58HMvDfISGuAKP4UWp/GWyVvH7xCcoVjvZwm0dSVyjuGSWru2Oysp1r7Mic+qxfE4/QZyVokIPKJoYCKdyBbbMiFHgw/G2PA9GvfeOfSgMEzkSoTPiPESuKE2rgM8UwcMttkPRXNafN95y8SYUcb8cXOQ2e2H1gnt/7mVjITzenaw3hpL2fVJ899LiVVghZeiF1Wy/drpW3cDV4zg+EHo2Zidsuh29Vya6tW+57zcijptVM1I9BVH/smWY7kyysZX1pIfijm+6IpFoZ809omqU0qj0/y+i5LfSqtCQVr2yc5H1L2DXTA5Sg4MxRJCwfKVOClO9lI+w+BnMJQSAk6BdxJK77kDJdJmcVmWhN07ENWdCTaB4CT4nF5mYltJCiwxBAQ0ov3+uKe0jjuM5yyuSBkSwHcWYOum4tXAnG6qmuALFxccLmZE5go92mrVYFyeMm0M6r5LTRR+AIpXobLk8sIjwK7r9o3JPsDaLzIv41l6qjg3ToTmiNTHXZ1qgoZqHcGRQKCkt9JXXCISrM3YniwibPkIhMkWoadgVIQrcD0M7rxB6bsSKcVDBX3edLJXQseKLs344KG3VgMXIfPD9C8uqAIqP+hUSjRLpOEny2HUYTTLRenCMp8beStvMLsBehTNbGU+2B52+RQVc/zwN0398xsTr1uae0fQF6vsVAlJgnNy9/5s8fnj1C3g3Fann8YrdoOF/LCJe5Sn/uEEP3lI6egbv57ZFlpi2v+QxRPFEEjRf9w8SMqeZaWeS3wtIqzZvpq+7w/iYSKeqywG9XZBE1kpnrUrchOheFKnQCTAZnYU/IyjKRM5x5GS3u6KRd88l+SAXxKAfg+rt5duTv8MBTG3ROPyZYZ6bNfyh62GnS55Thl/XPXwC06Rw96/IDzwC9/x1ThPYqniXHFQLu2eIyfm8Byu4PZQ5krNRP8uBHVIIu/ibGQB/T36IPM3gekLUOs2VBcTCNWRCZdUrlCGfigj3d2RWjUD5Nk38izeI1hV/KaIupmXYA3rjb4ToUQhfhDTMsF+5J59K5BRayyGkYLFfPtet90fsXSdTKRtl56cSfHKZIf1vPU4hk1cdxkltgWk1X4U0iH0/rNsoxJWWvz/4Qffnsj6tk2COeymq5wTODAwrC5pgVPWHIO+dNfxii9d8ZQyWvYjiHgWGWfye9tD/OP4a/cJoZPfxdJQlWEuDmZVJz1XEmKnxs1VSvmINvHjEgklrvEct7GpLa1CAF7FFxRRf5ACMtNBOdQglQm3kyDknHDQQ5DIFyBbrTRW7zM27J1IhbkLQj+Fp+qXijNVRWZLVprE4kSKJE4eRxp3YE1QAPbNcc+mS1GNtn3NryKtmilIv98phWZCrxWXEc3f2NFouWA+0rLxWCvDqarJPvHJ+Kt7RZZE8Oo3MutbSh6K52CKjD9UzrdNHBV05b2Wg6LZ9rKEK62lA89SWB/r9z2GoXG/79JMdNoGYQT8tdD77BuT3W1zpPlG/SClHkX+igHYyW3RFmwzkbuPqmmL5Q1JiPxj6uKsfKWz0bjnJ1lhQLAhJHqbtlkNhe+e1TSNan8SnlT/clBzwQW+Tl+Wsl3Ovz2vrsXSX/Kn8th2axXfbkrZZ43A6BvOKqi1mPLc3WCkScJfEET01aFe3rmM/1nRNQDebI8KIdqKq2I9rvJtRznErWRI9BlA8gXnI8JaQdViN8gN7s+GQYvsy3P5sKBmu6PTE3r2MqkriuRtXgYQSnjIMZpv7+uLp7O1FZcNOcOsNIJefJ/cH71HxTu9UtHgeukqT8nOU88sgQQ5bsKnVE/O5qqr0+H4/HImKz+G0aATXI4rzEUvuXE08ITFUaKf0qH4lKe1AnYU0GnroaB0wi5e5lGqp68uS7OODffXtNTCMY+uVwfiXvXF8EtpYkAcypsYTlq+zQmP9Qq3MPSUm74KDv46vwsyZs2+EhyhddM/9SXnYdnnQrvt1sDCO+arkUspnzGK3jzoe7XE4BF9jU91Y9EeutyznwhEPKgYgGRnWkuf030HiH9FO95V5VmppGoiHjWSgqrdd40mhhr5C59W6px4Ue9fE/wePLzSVvi8jSdjioL1tf1FXOwfAJXMyEAkzNVZIUytu9kzm2oUqtGfwOAcdELmP/q9hwKb/2moSBn79bDcnE1BXVduwldchFuEQdQjLrhxCXZnfXPE2Aue/uzmusTwOCVGT3s9Jp7wy2M8PNPUspQowYdHdSwroWoyYfD6wFVpzQBxsLyS+kazP1ii5q7Vv7UMjb32ur61lXmSc8Hg5aKRDNv+ILlO5YN+dFUhfVuqWcs1hGcEyxXWsVmXCRQdpremKvRvJQu6SJDCswBAENJhhYoB9VlaeIjoqafbbKnNeAakJxkBvpZHpxCUcZR0Y3C68oJToieYNkDrHAs3ML3XYPd4owf5+zcAK5AtmP26D7YiopqpS9lUSg44ROqcNtOm5PnoQA0ay87gRQBvLMl1lTdk2iQo1IS6v3HvGK8vU8VbXveGfuQ1ripXXTtxngBebeyc1ZCPgFNrS1Cws+6zELE3yPsakcLUwDJbKibP8dbh9Q+voI+rNlVHGYT1wr+cgEKFrTVexDwuWDx4x/969g8aAP8DbhCSHjka2/72SYPVM4b35/2AkP1oyfCbdqyVeCFheCY+XyImY6aZ5JTymaibmFwMQAS9amGF0zfpy3OFsqJ1reome/wrUP1eS4XTcDx4j/+OxTdDBTOYrcYe8coLNmTRbbumopicwM06rv+2I2volGP3c2FKYRrhxQwmjK1TP6728L/MAFwLsI8gS+AHz3jAKkNzxioMRXTDcyJtNN5gixJPnLpnK0f8IfYNm6OL1YyiCSCL1O4Io444IqeuFxMggLZdBS2lrIM1/BS461cLa8EciX0/RfTPi0sqiJ8nfrhBp2dA8s35gWPxYTu6iH4KzbeHuKyZEzay64X21FqWFveTLIc9oSW20l1SLYBTWg78MUxS/vCwZfigA3iDbzDCg9esBHTw4eTeFqbhmnusUnec++44z/g0G/HndSuBS4HwcmUW6wkmimLUqAHoMMkpNS7bzaZwc6ISkDNHlNEMuxT0Qi2pUfwTEkYJ7tW11EeIAE8XljKDyAMYFcHltSYBLOaW4P0sYM8gWglKVL2gHIDddADxiMSE1vipyKPuTmSZ+M0N0LP9XicHxrAyrVFyBDcCiuXdIXbhtO0ifrWHWdhDX+66S79GTcT1VxT4MJ0Xr651Tn1Kqmk2+WsMm6WAQj6lacDTIYRbEFJin5HHJD/CPNxzpQugOcgskGpqQ6+eJUhppGbdk3Y4jA17jL4GsXmMAozhNX987YVPEX1hYzWpKECHZMtaRRUt7fAz8ClroGRllASFLjR3GH6crkgFRUIr/6ubo0rxsNZeMcDK4eMrMgwDh2XIKjz8L9cOyKvwxiu2P9RadOrO4TbEL8uRr5wkkVqiBoeZxpJLuL9R7AyAiSPTkW4YEwbhrdR634NZz8hEEK2ZWCoIfpClVHbdlegLMiEawvT5tMxfT0LP8mR0V2MIPqv/X1M9waGz9W02vegZnDHvd7S1RSuJjvSpEjpeafL3sfomJfAPKch4YUgv0oF1yyxot8M+8p9wVj1pTfbzDeBMmZe1AwXcwKN6gbVD69pqsoc4sa7N2hyVem74cmdjAKCs0WMG9UcsAf87+8+WZZ7zPCvUPo3Zgpelk3pI5j/43OQdbuWbalZwRYBa6kJATai/RhYZKhT2iwcBgVVR1tB0OybSI2nnDKUvFdqocvxLnf7W8ezE52QR6jby5Na2eGVELAiwhsvAazOhqmbn3sihJs/YWoAxYg3jHO1QjHl3thxfVzUluNu0+fY95relzKtdwXMU9gcBEVzklFa2m+j+3CBmyr/fcJbFTFEDaobAKW7Y2/SV77ldjEM2klhYiCGUwzOAGUwCd+RmKbeeeWeBeddEMh4lqPRUTWatRVTWw6cWYG3pay6no1M+BAhk4E9SqNw8YcHJpeb+Fu16CF4YVAiR7XEattxeK/v8CQ6dCrEh88EseSV8xv8bEftMIsSU5vfJc1JSOdNEqGBUZvBYNaodH7BIZMPIR1usiRD5Uqn8x+dr4o806Fw9od9fuHrpNWjcw8oB2MFXJBLkKyuffLXjxtKnA5bomMUgQXt+1VwOMVP8aIzoq+4gi6v4sLjrjAhQ8EsgwoR03zn2UtI1oQ0bebF2l16QyCTctppZNpEN/bfFZ1/hM6uvIvycw6uELNzvKc6nBH6GcB7LdPiSK8962XtTMoEj1jwxIEoSocFRCxUNw8gdvzPT5IploeHR11Pkyz8tK87olLsHGNGugto9xAYhMQxg5u9I4EgCU9U1Bpk9yiODDxm9Jo/aHPX4EGqO9oOp0VdncBQX1N1AV3OZzhA3CNdv9DyorRH7e/S3615eCYKnNcUBwXenppi5Xt2+mTn7xxBucZC0XiK1PEdC4MA5xNiC+5srNRa9WTWz7AnkH7nzneXOG8qaOsf45XY6EgWD6Hf23EhuIIEHyYYaVYMD9qNUNyRWGWFQAbSBbxgWtErGoiPuxOF0JeRFK9rCFXYSat5M4q+RuQLkAuVaTWu30+q7I2k6U/pZHeCGO/Zwu2DiRpIale6ygeUsjWjy6Ed3B2kjSQfjNQ3vsI0XfnXp6L8QdJ7vluL6wElmpwu3GkeDNk9WVHEm2298MBIPjrESVDY14L1Qggtk/lcmHReZn2B5w4FCm3hX8MWueBl0xIj3AC2L4+cvV/+CJbGEiov50a/7KF9DHGz2C1dLJ234eim0OYSmlYHaJIZ/+jpMXSNSbDN0G4A5auPCCD1/PEbwWpnUv2osfk0G4Xlj8l8kbrq4QhmeFz+RdrgEFg9/Ev/sH5HD3UCqJTVVIoUXUbuNdbs5nJbD3zxFXiRwi6WFzWaC+iGUN4maHRcF0QYdXtMXyyM/5SMkI4n/o3gfsTxNrSrCEGY0WoajMeGKZRjiREChOTdybDPDMdKH8ILNu3xc5sgED3XGxYl+0qNLqZ3GlSyAzaM7EGwhSlXRSu5OMxMW/SPkQoANbcjN9AiCJhm1xfk/iDhDFHQil6olldWAa1TunXxwRmieYUKbw42Cp98Q4O3+uifKyUOVKcVUJuFXrwLqfuOjdq+wWOOeJ0DuKvH7Uzzx4HMY7mtSMY6h4aXQKt2aNKpOb9f+HNpqc4RCwTPwuFRhATJ3YY8S7y+H+cxSk0RuUNZ73aWWiZcSEdZ2lgCscqhoFMkEKaw370QyQj6c4Jqnheo2dtRJeGJMrXPfDXTSXdmAVYv7YIfUlfLvq9Bhk3pO/S1GawkQbn0Ux9L8aezyJbzgxgp0NUWjTJcfXReeMSU+XtxgrgNz4fE6HPJg/owumMUCVyrN2xO8SJ4SQn6kdP9U5e1ryAjc3YEjvoAna0nEmPHDMIAnxcPVk+MNpyQlfdhbrkirPOfhxEAyqID81t9Tb0rewFbvf7UYXR5DlphQ6qF7a2hK1rFm6oz0eS5B+Iq5bvH3JCRQBiRQ2zaSdTNOpmtuQKHFNctxOIqIpCMdeI4nAcT+olgTF8TJ38B8thSAoSnh27rjATFOOxEwF4mT6w3Tn6srDj/Y/xYTDHcJ4kkreaNK7qHANOE9+iHsaQDTn00B5k2SEN1xG9x2MyYmazMkGpCCHS1pY15GlqO3GYIpYzT0eIohkKeNwJpM81bbkaRZdhaWYmcvWztKb6Lxis7QucMWEzv33r2dDbDiof5JRFm3sQy3zGdEHujxswUJwXsCAGfCj78w7wS+8OhRiVguMuw+VF/bEpVziCl1MSMIShX8rmHxujY9NyTU4nkBHOGXunBFA0YkHYxtEnpqATs4lm5a0j6FTWoRGiTDpNgm5dS8mw9YQYj2Try1V5QCwfPbI6EGRoLv9PZ0yw0OzqBE0dFTaIOCcOsWYDlW3147l7YUb9pU0DH6tT42X4Mz3rwgEKL1sVc9R6F/hVwvXqlGxKQ2AsjQN75ypcXn47CjRito9x7vjQH/mqTkTM0wSTkI6N0jWszd2izrT3UOw5Tvxa6x3jbyoNaifW57FONY8svc7YKrdZMO+Lm7Tv8Bsrm5lyQHb5lhgco5eAPC6CLYc5IEhILYBzmbeU5RbvT5HwZEpP2pdPPzy0u53BCMutlI0+58B1C/KUSc3++652hV4ZQUEWVfCweFmBnMpiQBBtaOxweRtV4HFv+TUbzXhYJq+FYYVdOsqh/xIftWGKPTioZbgo1nIbg0sde8XfD9ikec/hyEh0+jWCDxMNTqMYkLD7mpF/rS+YV/CWzwZher5lcZ8N6LQ8/E2rQapJ/DUmFQJU5XiTv6SrM6DsnR8sNikjRpaKvitRasvYGIz0G6sszjCCR8VaOu9/XhALy8r9eWSVAtp5OkBsRPnLJDIFN7yJEwJdCTkoeFomtk21BWAU402NGlLoS4XSc/2zI1Wpq5n0rSCdEQwWKcKbjilOCRUVyaHBpzRKE08bYsTCtsFk+aorbhW/tEGs7sd53g8LAlbDJ4MdJCpXWsVD4FjXhmO7JAp0hg1q/oCsqtB0P7O1DPgSDk+4khvFYwukbDrbb/nLwp5ttladcxg3ydVD9fqFOF5/vH5pP66tSS08irTFRXsvnJVy/7JXn8vQ/lEazn3V90LA1Jqd92SWbaraA3q7aFNQYu/UR9X6ElbxDqCDL11Juaq+na0rpeH0AfZzxYeqzxQiqa3tBDGcRZ89RzN3eJ41ScPZf4fKl9BX8Z7x48BDc+cZWI5wA+5kPj+Y6CUmTtwdsrlkninz98hX1SqiBI0UO5OzP1qVCRPqJT49qmHFo6JkHdK5mIT5SFzoK5cFcZHxiwOZDWyif0RNOCHWDDYmAlma/mhze7U3n2H2yJwAB5Cz47ZUuVWpEbz2x/jv3xi6eFn/zgXhBlUSkFDxdbtYV4tj5bc0OyORxUe3lTT5f5On5g8WC59bIatiuWaC1tDFMeAVzt4GTMMSNMav8J9G0452NjCj5GoYg+fYvxFsdHF2nzVpivWXEPux2C4jp+MGuqAGl5t+w06yUs2xyuW9jTURCjpr5qIK9aR7PbbccIw/yQfTjbu2F9VdhP6+EonKER7mN92bcx1+PkFdZag7g5OWBvCjLZMHgf96opRqWStvaRiEdflivbtk77ifhO2x9GYMGDX6dksljANeVjOf/YaC7V+zqWlzwAvqMwGgJshZySE65RKXrarQ073BWJAwcCc56YHOkStSgdKkQw30TQzufCcVBFlCams0xxulSH0HaTKK1z03IM+YrPfWBGeATFxWM6L5aAEtUyk4EZs74w6zpdidpClmZMllIYtOLbRNF88o69d2ghBoJrtMA6xxdrEgQCO2Dtc6rbHlRhnlsGw+Hxw9T9YO1eDZFJAGPTJzbmmMvFSiRDOqYd/VmJW4iiC2HEjhsKb3k0XAgWTUT3nAJOxZAL1mH6y990WUwIPWOfqniQIZi0XzssRW7xlpmP/ljBRWEf9BWhkIkN04jhYVWIMrWfEHDsJBJSK6H/D1VVu86rT6WYpKAUTgbxrgPgLsKPhU0dOsuJGe88QX+Dw0yn7mVKCQKrC7jiO0hkvxN69MFm81E6TZsaO9kmB1XnAaDkkvLm8rY5knXsqNaZL3r4POJzm91o90SuE4ECdy9wdn2mQh/VjnazysV+2U+FN9MZBq4dY8vtZkdBKnV/W2xuZ+hkqYtqsClxK0qsEwd7t/BOhCd15crsiI7KrD8CqGycnHSPFcfjOokllR7URmWTaCB//h+5xmWMXqIqcUxKxFDvJJXsfKiQH2oLDDwTdTeP5rcOA4Nw1laFy30a9BaWX6Gx9xyld6ImhazaiIHVulbsMOyb1cGMyCyyl0QBagHC2nCG5ua7C60mbEfdUIyiT4LVC5ph2J/bjEKuruWPooj3hx8u8iaskF6Fh12YIH5OP5pTLdr8PjIN7/67Pncczu7Uh1Cqc5tUyi2PLTksHbTwEKLM5Vz1t+Boblel8C+P9gDSOVDaf0y9IdussHe7fAnMUhJkb/yu06M767yUdOdvmpifxXcMYM0Ff84Fyfoftt+mYIs4xRWw4dyKLaXlqPdTHU0Yvr+gWwhuluJLuDeu8aL8KM+86IFbDB1fpfslFmj/CPMt2Vu71pAx/gFtnDRcUOVLHuSJ7QmFWTQM7380TBKZQi8sGPhARvXjq2qjUiw/C94QKj1B/XBWJu/vR7fDwYTRoDj5g5p2tADpOGZBXi+lM2Uk+bSDh1h3niOr6QSmx6y9i57bbgX+/YUCgc0/qxJNFCYPMoW27Vbees1bCpvRqaVx+BXB0SN6sdYXEGMHfbLYiWxm6Y5A9fPMTRjLF1m8tUm86qyas34i3FqX56YeRhRacUnTsR0yGrFUp84hhAPzPeMoXFmniS+Tr8y+D/FwFrNBnXkrB5UxtqiCZyjZcHnT43Np9g3T7vVvuXSbNU+PaxO75K5Mj0SJ7bFLxySDOx9E42BdOnCkhED8bQqN2AZWXfJgmiHc6YZVpzdBsoah9pOQ3uRY6Tl/wyml7l85swFKE4jr3ZxP/HB4LUgge3B2OydRuY8sWDt0XIW1afUGmXTr1rCbe5f2NN8iv1W1gV2BaJLJ5dQJlEnNN1zbWI867eromA6jDBQ5TlIV6hkJPTgx+OqRPMtkyVkSgS1M8uuxH2liDG90+cru6XrxyFnD75lYpVCzjfW/TBeabt0xff570gekkeG8+f4Id3TJSBwJYbGlX/Rsim3hW/8kRxVXVm61ZxiLIhLwJ9ZAs2QGBuHlCLZRaBGwWAD/6/VnKrokeORo6BMwpc0KFVBBPpvBi02eqUMCfoQ+c8bmb/uqXAk6srz3OkDqv8Yr14RUt7JRnlSDVv2VlecgKeyQ8Gst4UqYpaYQhtcjpfpWS/coqMu7WEXmtTKB5WZ/IpnhIDbOpHpDdaIMALu1nUE9MCOtVUStYy+6vESdmehQ8tM59BbZeUPgcem2LDdcRf/6p6CvNHPD4K8cQQB0ZAUseUhmvRR5Epul2bP6VdBviu26BN2uJjVhK7CAKuA5manDuK3OqWiUyLcBmoQTRtG2iTOzkcmFIQsuNUkr+eNXBxnm/YEp+O33r5liMk+3pW66twOiC54/hdXzB4boxbcqpd1MJ85RtMmKFF2qXaTHo3QLf7K9wjKq0L8I8t8enonhGnYGDpTPYhKZoYlg/R4E5rTSsUV7MtzsOc7AF2KzRcjEsTR6Xw7DdX+EPyNdUgwLrzuwLiZhRl/Y7lf4Hu7XstplecBoicqRIm2zbmjxunr83nLbbkRH+06NgtvLy81HiC9ut1vN3YJbfLNUpoYs8eLQFjX/V5XcyP7Nmq5b6xdrhQA+h6F0mklx1e0Nfju8dEuaxOgX/e/P4ubz1Jtva1FIx4yVWWL0LbA1qQSDIvw+kNdd4WXKBIJ4hpud5KQNP3exUiqhVS80nnfcQEDSQn97C+f5j44+o9HTtLWfa5ePgEfyG9n/HEG1ZfHeKcMX8ZAB77Ir27wzTLhhIA08f7tDMMi3CtJCLm8nLSv1MnQum7XA4Q+Qt1lrrME6sl94AEPXDp2gvGxYRRqHdaizsLReE3+CNEc1xC2P+4QqF1/zCUUm6LLzA9MPgbXr9NL9qK1etG1Ilxflbk5bbah9BA2YxC/kuqewD55/RPBC1rItw2xeJ9r82tz7LU0Edgcys3OITDG5L1Op4iT6i97FGRr3TqKkk0VQd2EW5UyYT4UIVO7aouJSDM6ZaFj3dndEXXF7Tm16zldzI+Jqok9fT/54XuxlbXsFCCJNKAR2qwbhjoTKfF2I5ZYNp/coEWQQtbysgALH7CzeZ1SQur2EZI/5+EVHTL0roSt/p7NhXGhUlESJQvg8nJMYVofCIEGb4Nr0PcQkauILrhZhUryR4jdwJzwyrTmujPcYjPZrCcPjN1s0lhbZBIrIYkeqTBEvrqpTYWJSPKm2FZI0nfFGIybf2zi7w1lJqT6/Uy2uJx1fSREyTGTG/O24jhTpiXdrWVANoBTN2CPMt4CNwEc/v70aHCJeIf9g+oWoCwFpQDB0o6xqNsZoeZ/LiCjXiCJl/M+ke9fYSkHTBgmMk4isL7bBMM+92WKyeim1denylD+Jr4tKNb8XTMkfrMRcyXOn1+sAxq6hlUmwfyo+gnEo6gJG5A9zy7QWFrMVfQqNw5tVJUU11NR+Ln0mKapxAC+OVFjV7rCHqOHFut3ArSasescjz1Fqi2uzjrBrwJMeWs7y5Dv/33jyo4omkUu0hH8hL3aZlDf5EdqbVS6LspIFLQ82DdJd3dRKrx54rqs0/zcUK0LNpDhWvvgP5TBsAXpRH5k2L/kx/lF/ehVErX+yS6kezO2mRBN0Q9WEAm7ktwmWTNsiHVR3LDFU4KBKN5qpJONMp8uhNo6LrNI9GnX7m3mnPsQfI8Gi27CU1w6gJVgkFhU67rfnAZb3zMsyHQ2rhnKk4yObRpPj4Twb/PYPi0X7pgPqpu0BN6kqIMmwplRIyY0fGy+FejBWe3MTVLmzyH7ocpu12guP53AfFSx4TiO53qJVuChPAyd5mpBezhfLj2SE5uWf/tY3GHes7vZPI6MBo6thsm/KPkYumPI+6rfMZhmpCBsYPJXFuVz9PvjCk/e8Ypz+2AbgELKpl+GJ+rWATi96XJri23UyZGfD8O1AUbAuqQNEv7naHFYVe+jaBIIbauZ2OWwcGwPANusY4r6pbWM6TSK+GKEDjqRc+xlQREVpxXAuJNaxfqAyzlSjZs80QhXL2y/5qRGTTqJDeGXpl/eaVlF+mEaYldeCpBat/lGY7Phf9dddpHmn2gONesKiTK8Nz7rxOYu0gSMqyiguNmw04n+qL+AYs0LcikjZ/acBMYlUIbxPOtPUmyG9kWKfrwb/7u3JJrUdypScxOmo3x7k8srpxEMxVfa0N31hX723dE1GNe753h+eY4iZE+JCuUaR7xoSWL9YIDlC+tWC8KhDEdOGbed7bW7PbLXlNXXfattz7vf+bEm+d7zKtvWCAx//9TMBqV8DlLZCBYSqJ0rihTz5jgJqWhJylnGMiF6QtT7qj4UdGOjiGAEj1cboz9ZhZu+MOhvB7N3RQsu0N6IzoFEmjXtsqWJjec3rxfuIyyG1wQwTEY7CCpl+mpnAK8vHq5MqTQwvJbtx16fTQgNXlNn+++jFwqtXowdY27livsa2KzzncbXtMzpELLesBYV5HV+RUd0Deor0SfVXkfUXXxKGHILrUqFKgQD/KkQ/JDGMtuswYbnNzEs+x8d594DWQh5PRxqbFjPrOeKD7ptmjVOvjptDELY+Xt7rUevMMhqzsLjGNzzG8Gjs/HyU7o0SBaY69pcEwrDGekZUVhIFgc2ESxTJ6h9MuXul8N37S9HdILmPq4d3XJUUsYFU8WeOU7rsL2gYFGP/vt992dxjZ1NhFOWwyWII7L8qfFLJIgYSwbAL9ETFf9DfixHsF8VWhX/r6vFEY/aLal8ukaT5H6DPCk7E2u9gO01cvYOnbXvS100sHrGEqdHC8JVBPLDrCP/8rR3N+jAX1+jeE5jEWNfiafcoYp6MyiMHjF+uKpjNs2pBpz4Q27664PAdOLPpVZxA1OX2z+a/TE1NKB35nWg2OoUDViyvxPrvN2CYFeAE1A7/mhOjwLK52KQYABaQJFaIJfO5YURTEw8XuPDlRP7zro/yNzU4ahwljikrtGp+V3qQxVZ+hkmMnvbr+o6niNtyLRdlJpxEaP70vQLvUY8JGUyYPHNC2JNi8P1Ff2SCukOfUzMnsp2u7J5mz6rcoD7/E6rPV2414iPIuHwLdZFvLa5TXS+BehqzUJ9T5/P2Hv+DG0np4WCRrOp23bY1yTK+ZWMava4x9lWDWR43gxMivp019xI9WqABkvqyjX7HquFbygsGGQcVlHCPY2Hncu3iyD7/kYFRR96dYYD6X7zrxlliT3IHjccAUBY38yWJMxPuC0BoTwdl2ZUkl27hhAvc9owbVrtqTi/DN1lc+avxJFR/bTzQJg6n2jrjsncDp6KtdlXlGflMitejN6/3xmG9nTzo+bB6R9YioezeWmFjd1pv5rj4hCxYbOTDsd6DuIWdIG/acyWIWNPqyfZzM2aV6k7LpXjuZzsw1qL424f6nNDBCNvxY4A4+q/DDwV37sJdaBy6WuE6jVTc1suyZgsG/z1vxu+d6FYMD7S3EVCeA4ELqIiPS5BL6QL3laie+bNM1Tw+XVxrmfy2ylJtjLJhH+eAU8RA7OSgX2BbPahRBeF8vAUXInJGO8uEY+U8y/wARLX7O2uFoyZFF+hfHbFffvjdXJVGTFYf6Yj9lYgJLBAlXNgEYmNj+svw484kyywP7FJJcIodgm9c/ILj9bbH66uBHSsO46/jNFRwgLysHB9H+WGKTC53G+wV2XFO4LQ3xPnoWNoQWQPaNXSYPM9dr+AlfFhenKa+H1eI9j29Eort+KnKZPdXnx1GNJFNDxBg+OdP6uI+dcnWiQN9FKakSVV7YfM7+7WkFfkpRzaSmVDvrVgGUVJbMkHIrWP5ZsccSR3ySq06foRyvgkr6Ken/vgKeXgeibVmh+Bi6GDOaE7adnaA0/Yrj64bdbtuqgHCGb8VnfpKxxshdvq9kjm0ghLKeoDVuxOGmWlOBfWzIeEKQvuy+SRCSQB4cK+kfOcaGvmsOKezSPxlKNWOOIZuDvhbSBjb5k3sznzqn2cEkCaYjt6yhFuPVFrFGnxlO8vn02w5/ULQOEeowsW+rSF8TwKawiVCS3ivTOU6J8NwNbebBIYTzIfQf1Ojgx/lJTslPnChkclxoDX9SD55+AzoosBrvYvvP6DpbqLfhgJqXdx+VmNiUqQrQGNkLpMdtwqsyfwyMKkH3azP47MWk9I4hPMTH90iy7FdfPbOQVOmisPsX0l8JA+mHJQhoFtMzhN44wXA27monV5KDRNIAJymjVrHt86pUU2BMDCoeB/AkJzaRPs6AU+wMetOgHG+CVHycCH/qpbXjN1ta1dVc0ra6v5UODwQsQ+RvCuBLOyEmozlV8fuTAjLKyQsUWY7tQkYeSywjHZn0Yfnp43rIBWw1Om//TG7kbHYxXcG+aTjIqz9U1OOvoSWGjaGGWAraAaRhyUxDAlhxH+m4i0YWXUiq+GezXn8M9Oacv93dQfknslW4BdeawBsdRxHLn2t9ONY5RPQ/B754SZvHfnd36o16KIVp+ZAB2fe6Kcu86qvpBOkcHtT1fAlxF+vbKtMsDfRBZ/VYZChXh08CciarjsK5Wo7+b8+P4rjgxsiidh4x/hn6eRDRDr9zPOB+uxIES9x/8tJyJhhY54jV+aw/dcGSwuz8DrKFS0QnI+JgGUmy9XOCh4RXXc+H0E0ydOIKfnE6bw2wm9S0+C3CJmiC8clyUkRnJ8Y9HxnzeVO80A8QBPP6WnNxHgjBlxllbiA52Q2/8yXemCIXOBl53Os9f7sfIRdi9XTPsXeBoPVJZMZ/vNufR9+KQ7Sep8hCFWDMSz+GCIou62FcOsA+VjmgaqcgNVm6+Tvn6q0d8bLg0RomIYd03RTy9jr+ZGkbsuMLhWzA1VREKwvYDWrOVnkHkBZg6tH2+KXsvq5PTUEFFCwJsgSHRe6q1Prc8a7ZAp3bm6FfcKyLT9xkmXIiZCjKCbKa3C0KOPWBQhPzuq1KTNRwOHQn7TCxaxEEBMNE8lQh/DBAgNN1s03ux7t/gzRVuPWZgzw2NvueoLCjJ1miPnGj4IxCU1UTlC+DqcCkkkjWIqoU9Q3gxG5Es6h/B7GjePjFZsQINbzlHYLeSggJ0lz83b79CKCl4cvay0SqzvwCxCh1rriIsGAH4U56pYISNpN7okW1jGsOIYH67DGD4YmbvMwBFNc5+n+1Bt1hYD08duhK9hPe/1UbLJlqodPR2J5bDVMHFYd7PM+9XU9Fx2OJ+KSn3uXyhfq1UZ+bgEwjGWvbFPRxp/Yj3qTEBIfhmhfIkXlH2IZRRH9EJAji+SSAG4tmFGibrJNW0CpzOEKY8gnze4CyMKnCAr9TfCWB0ZT/9DsOACABTfGaR9Mln+SsFCNpHn8fWjk1cbxh449MVEop3uYOPv+rVI0l1llB9xCqMNV/5I2SNrhuafgyUQbukCAAmM/cE2qtV0VBWarwaUKARZztCm5cqmYPK7lP0v4hISzJj+FxTVCcwNimJK9Y2FUN7wb8Q4QRu60zMZtzvd4MU2GvvHdzhqPJcbD+HgSXh7BT3bDJlIZH54nwR3sCAb0RTVFJnCsV+0LFbPI8Z9WzdeQOKtg0bvqqSyo74V+1oGRVpePhkf8xRZNq7ZNbDWKrSPLGhyTKXJj+BCvjBnW86dybjhk/bGwIOj00uPak7iw/E/FZmZTw+UUxAlmYSBUymAtNq+Mequd4tngxxdyPgWVQGCmR4UAyTAyNDM/432ULrOt+cd6K5aVwyg5ESYRQsm5nBtlcXVjqeksEyeXVpOUEFn8+yEtMpTd4b/GDhXNNAE0cfdTNGzNFolyqjLrVqe6xVavJTze0XkHAfadPVXyMN+yEdycHAQMizwV8cJ+6osg+X6w2sVTdsGiBRxR5K7rPVXoWrke7SV4w373xEdOnRgy5VLOb2jKdkFohlkrTnbag9YWKDMU+qHzXydCPMd+yb6lvJ2P7C0ZEoadjYHWe98bVx+mugqDP1E3f1mAWDGre8Gs6tcjNYCHRREwhJlMgucotKsM/wEIcIbeFTKAgXJDlXlUM0cToWBwGGq594oz9u1GnqoIKKL0XsSkyXhRr49//Nsd3W0S+TpygWbApXyThsFYmL5zoqmBSFhngPEvHD3otnhn/T5L8mZEchodHGRQQTEyXJOff+Sg6p1G3uPgJUFEhs8G6f0WkQHmxH+LRMOs2xAMzMMB1lpRDt/nUv/bJcJYtIjPflILRUS8L+AzBw8AgjcWQUBdaYqtkklCyfewDGztId34CMoLl7GfyqrJEvcDqVQ1Hi5x6r3B/APN2hAXb9032qk7VKMl6f+Zf58Bk69J3n2wPE7P62VkvHD7ye7SpJ8zUeQvWJV4TbyEl8RCn2uMjl12vLLfGj1KLCZ9LJszVNE5fhu+W72zmVJHqBgiuG9Y4saj9RDMPA6Zz4aVLznwkmBYYGqviYxzHVzbd2zCH/XF+q+DukgfkUa1xAfp00Oxzj/NoLfBwb7U+DKWWBAqMf0OYDxuIvhykQZbGf7aFHD3SHPIms0lUH4KYmCYL38bdfaC+20AIGHREF3ROz+it/67w/YGLiU0olrB9k5eGOZqQnn4ckHwSayDiBOqVrELv3G3cQOYS/kW4ycIB4OCSRkYU5terGCjsZvlHPpWFNi0LCiN0hkrfFk6bASb437nmmjG7QSK9NjFc217VTsjfJqcZ3aEL/BPfRBlQVDjnVUiQL51ftyVgcRDHnfUDs/owWLIBf9z6Xc70qp0sPvdhMB4XhYV+OHJZ4MppXYjCxW3zNNdH6MrJuHmLgm4VKQrc/5Y+PfLL3J97YHsqbwkraoI+cIzRcSyxtp/mCcARsXTPkX99DVFUjPh3jPI7O/NkFSJTEOD4zPp34dN1vr/KOENlLYwbHkqPsT+lOuZCisaocISmMrQs1/KGynW6r5ucS3VPL/PYI1AB7O2qrmx1ZOq3jzFLPJFSgYNPx2O2V9ki3ZeRbyvYXmm2pWayFt5lDbxMCErkcwWINWbB65UV3F2G5wAxuqY7jtU7/Fi7fCVuCWgzptD7BT0rFLF7YG4Cpx6U6QI0WrAT10+htphMR9a+RfEmKcRqRkkEkZMfESq9TI4Pd9a1+XzRgzko4Tb/d5YoewZLttIMkP0Ee1UmufuJjfQx0CD3CB/jyXztF02ElHam/0kr+Rs+pkEr+M9pKJE/Ld1l3iCdu57q52Izp5NcfMpHAj+p3gG3UvdfTPOU/fE1+Q3auvVyeuUN6GvjGKDxxoBmy906u1qfYi/wMHWtz37saD0Q7z/cc27b20fkB7UDGfSD11O2FA0DhuO/l7wKfQk/GCXs+QTJPiGSTetm/JcltoUKmdkHqvJko4zuXLy7mAmfDBPI7uvaVHxyJjpOs+lZgM6ukWOAoBTT5WaKQ+9Wbvxe7WrQeakevBWW/SD9FDfHYh2fuHUtbXYTuwwnUoZnUSXAXo5xi6Yoq3Q8grq8elKeC1TtqRKIibx23s/Z0lkw1dwOk8Cg162xoiLZ+g60y3suYeL9YUMs+Yvd/Rqxm0eb2KviPN+3Sww8DgFtIJ0OP0HZFAcAL5dmRctI8eQQrEb137sjAARjmDqYHPp5pH6udISz3NmfWApfntGodT1ctmdXY9jCNRekTYVPq8MoJNar/X2CuN9qUTPWkbr0t/KJjeOXt87tL3VH6vQPGRD/nI/+ykCz63Itp3yECMJaXEFI6uozqDEy/Ji9hOR96gck3IglhAFJSqDoF3re1iuT71MBeeeaYN59XtxdZ06Yiv6luP4Khi7+grsYP9CMRnsiO2ev32WPFXT3cknrA7RfQW6G+o1qkuX0w5ty4Ar39v4ncXGjArSbc4RpCfzrQ+vUBouFJ+FPFKQd/BVDvvvwkdWiREqimsKJuLey3bgRph/4Couzi2eClx7toDIaRdiNGX/lWRP579LAS4E6g2bo1/Qoa/hILq6BaNYM8EBJSf9R8hILFI2Fx1ugFwdATtTrGbh2N0OWgibtQZKe1HaSe3ANVSGreV0oGrRpjH9Z1TM0Hzge7efAauCh58HdbQXUITZhgYfrPxcjS0I2AZuJt67C+b1pCvh5TmkkMiaxsmcZGlIKXx6caNXQPHjLnMPV/VdqESAw8Bp4nRjsAwynyb4+xG1kllqc3LYyy29R7H2nFElyk//KoD2zRHzNTtaxYk3K4f6mKnUy5bp2HSxETSscNBXoVT/fuuy/9UsxjzpY5WUgYCHDkzvWkkDsEK2xNK+zlkfeLGKPAWt5FGO3HakeyMH/7yFcWDBM++yMEXAlk9YpEyXO8+dMPN72Ai3sc9lUTtUqS6Qcrt1g9B9rSwvdp9GZI9x0fcw6YfKS8oSA7dPDBPJ/ejIY2t3ugsSRAyuqgxq/gfNvmp27KSP31DPKqMdF2KCiNd02Nmky9bo4j7t7syy83so5nI+8IRER5tS85PovA9b+RxAVyHhToW2NZZrq5+KQPmhdTQf/5Qzq7bhNfSfb+gswu6bHQoZM+fY8gYlcmumTRe2RH6JEXDS7CPOy8zjHyjQHpzj1UAighbmZTjYUGm4Ml2c2AFLcsqPGoEW40fvYBrdEvjLpIp7UHUboTuqdeOZW7w5UMuUKHQEOSG9EgdZSXswQSu4F+aAtBC+t43i+48cSl+O3oc7wu7Kwi7ALfAQFS+FIF+0MKpPLvJ3o40Q4lXQd78X2lUc9n+zpVFG5rJYdxM7pySSM3hyugoyJ0mzde8SwU8Ms6p1lRVP40APleIbG2vvl4yS7guHJj0OMVCFEoNTWwK8yhP10dykNjxst3VqKhFuBavCulVriAcwWwPqLG1pJot/cm5jG+PEJ+lm+0QiTH4Mh05AVEvv0bUWREaiKi+IjEw/Wsivckgzyi77UATKLexxZ+EvH24/4z0ej0wEoEfuZmsIBUUSHqfAYiXveE0PL6EApVUNQOvXMa1n2mBFbpCDRtZd89QP4/OpJyJTVzcAHO2PU6iBRdXuogDu1kg7pskeo3Diso1OGv9oNLcLURj7bAOu8saLqG84vDkEARntaM7GaeExjevL3HHHVyF7o2wQ/meuVOA+T5YrAgdexvoZ5vHWjASYwD3aBJC9uJ/FkWYUulknXqz+powAKlJxs+FoquH9Ua0roxoMyU3ElwgWkrriBbOcX+wHFtZITOmeu44vuaQvOXf+oTU22etfTBuRebHNxVNFrRUuvifgwYv1soLwJQbNxbYBtIWZ59cBdDh5ichUmmMmnvJv2e4izg2GUmDKDr99nnJ4nmHeB+m3nXkyqzxkVY6z/W0rYVBKdIN9NX+yG+p4m3/ApubCjIT0sEKmfCbOOM0P1ACtfZSWxg6F4Z/YmwFUuKBVMJ851DAaUFN0CBS4BrR69cMhWN1ePfslpI9ANtZ6cJTkGszQkrmUumiGwkm/ErVGWRoqcn3khyTTTrOPQ8sCIZSo2tcbak0ODuT2mDb4Z4Qb0O6hWlkvm4AarVSajyo5QXvAgrAqTrYDj340lDOKfv5G22d33VseWfa9RSnyjC2xRcTU0HxJKxe5NuNknvuUDOm5q4VKVopFkKjqKf39KOXBXdzifisE7D8YYqby9vmnXy0wqJC9gEfVuGIGPmAuh4oVeRKK1OwKmauozRlK/kIY+OWzKyfx6x8usFBa1HqtemJA+gNQrH35G7i2z/h4SQsgRzPwnPShEoamsX7EAbJpPZwlNC2fsyDRCaN110iHKdd2vZSOtBgvZtvAZoTwMIh/zK5vjp6/TYejnM4NQZziSHCJT/U2WaY4dbRBMen+zkjPMHj492rAs1b7sxCKQEJ+aGfYGGNb4GLNztCW56w8Oauo3GM+bZmU8+i0oq4WW8dyG3lEw3IY/S39fiZDp8GMt/7SFPuzev35an2ZpJe0kl2FNvN3e5uDvOoz08mvd4DcvTb16sYyS0Hi+43wqZia4g0VveSP4hbaHVD0txKDqLRrd9P16UCLTutD9tansF7g2UcKrNjzF6PcSoPtY1CWUTjeO3L6Ymy0U50lQnVn+e8LSFqueGiStBMjw2aNyIBIqCruZucEZXuqMcZ9qYJ9x+q9HZhCmKmDbbX7RORJAckeQ/4PIMziCdtE58NBCMhGDg6okVY9ucNISM1ak8KKgXK5oRtiOzUljsVuYexRvmNtB3CTDizfRLAb+UsfeY0gn1o7mkTFldWI3qrslBjiWL1oJpeBkGPB/W7VX8nVuNQlN/wKNZITrRypubFFytBv35LOAEAPRSoQLS+zPQpfbxFqfHD6b08pr3TeSp2d4mXz2NCC+fvozLIG4w0E0iEh6cak485WLwy7/8Z/9d0xdTIGSlKFBk3s3mjaT61Sz0xXYq9W4RwL0N7vqSd6+enQRUykEnIpnrayJuoW4Lh+4ln9a7Zr1wqwlSOv/8xOUqPBv51Xp4n0ug6xzVNLijwUoBu/od74+K6/40UWkB0lSmde4K37utMyYFBT5x6UOX/tym7U7y9caXf3UkqmUB9OXUkTo7rEB4XdvR2j9/3p2zLRJ53G903tUhG+JW3lntLdZUX8/a+PPffKAS4nYAx79B6xuzMq1Omuv/+h68OVW4G4WOS5qLzuqhsa/BQ5L8lolNLnP5q2wm0tcHECMk/69eg04OR6dWrhUI2y9CAMK3B6TBaPSlBz5V7axjDWvlFWjkBYLOEM5ZakuRwxan/HH5XFSFHEHeBFDIYt2f2GGZ4CPtZDGuzUUvdOlliF53R+inngfE7fCBzEkTzQIoNnaN//3w3+84JSanJQMrE0aC5pQKidI5dT0OPpY9WaoFms1MHHvCNjawgQ4nIedtsDSQncdDgdbjyl43mdfpkHlF9R6iue4MYRL/LUk/xliZeVNJ6D8gesCexeAkVrzg1mVZbarBrZiWxdWlmwQgo++Xet4Bfl549NMC4m6BqdxNHm34EfnJhET11fGGPQKeqVBorQvziTcS2MLlidvCM6J18jtkUITIXX1Nixb02Yo47/GiaBa7Tv35JhOngHbEal6mYD+xCaU2Y+mAeYse7yr5rOuvW6HWPUPpAQCG9P48CM6eVWV/O/eb7pgMkCXpU2t4jgatHwvI1F6A2R6FUPodhcTqIEhyS7/RqiR1mRlkeaFmGWp5mnqqGdNvMgYGOYuXFBVICrgmm+9jlnHIVxiBMj3IOXcjrPgv9GcdynFt6IKXDYs0zb8tpp/oGm4i12tPkq/WVM68pwf1jUWSl/2S3FuvlXf7HTfJc/QfFGCyMZtndnTDTt8LPg0wBqDNiUJh5YdH8G9Odk7mJZmlOVjYXPZmDh5s/giXQ961buSLiS+/JcMwRGJVuEaLAdVJH3zHzT56gf5qIjpxqy8DRiOiXWHnegGcf8K3UHZ9xg51YEtXO05LwP170jMuQFE88r0LkF95T0JF16ifgTsb9ypE2nKk+KMxfjotqKUyMUMXZDrllGC2JeyThlkUni9JI7TzBuol0zEYJQR93wHIa3+wnOzKM0VxE+xotkSdbaTVr8lNBSfsG1zlKwaQMok/M/kPawEMaSs0aq9Kz5eEPWKRTdW8aiutjTr+h7dh1+cp87y2VC5CdELcHjR22TRwbs/TpaQjjvz/EdO3vtk3Jsu8RmsF+9WqA6W5zBZYrFS2QKEPWyT7xmljLdjLSM2uIK7i6TtOsOZ/QXLNNNF8f99u2azHw4SM4xl/g3KQAkeblGSs8FSfY9xfx4a1hmtl/rD+vfOVtbTp//K5DxdY10vGBXTC8zeZJlql5Mck8dfmJgrMOgC1pK6Or1s/+umVITfesVU//hVtSn1fmRnYkBEk6LXm+Qq2GNMeLGSRpZbXx+30cZNEAi621OHZynLyYMSuR4vjDnBP/oaIBEXe/la7wGPuq9vrsvGjn0XU4r+rjdPSAjjg7UBFGaVilw/H00LI5X4+OKaBe5/XmG/lnm+v2AbM/nabROCuhb2Lj1leDDOGp0pnn95AHwL/nzx4UYjxpem5i6L7gVUPuu7BHqatNq/B211SONAtdyX2KVhL4IHAjxCEBln6QRw1ihUQIewmcTS7lUdtB/uEkH4DKJg9pTovthWSijQ6a5Lv6Y7BOigkMWZOCZmU/fH2b3T/p0wRk6H5PVb5xcAJPv0IF5+BHWH7/TF9U0+mnVpPrihZMgSU3yMw9ziwJw3GBmfUtMIjWggCTNo9h27Ntloj9+Eq/PATa3OxpHmM4a1J/UhO32CnT6T/qQvIuaf6Zd53CjsQ5Hixy50XboNIodHpa06fIJaTFmLW60q0tyb0EyK17nHqu8UQhEz2Q0jjujzQg770pHPUVmLXnlDXPPk7dnQdEzpb/BLzCwQvUqEelyodvlRMW3hubLOOaFQPpueeuj2Se6HCVWr0n+ZUD38hPoxGk+b224DLktVpi6Va/KEMZEoqRrircJmrjgRjd0s9iKSU/xZa2zBK3ZphGwjd1wItX1j3K9+USeP6ZZv1k0IPjN8sOwF0BkqIgD0MFldtOVMibHCBiw9aoPaMZL/qKLyiQp6OunADxvEtNdZyDI9xM7gaqDuLcsyhfXPnhl+bLyBFRi/T0r9fvVFG91v8qb89jNZOE7/aUHB4KfdZLxSCDYjAqxvVU9ybuH3gCT6dklPbwANPtqdDFqambgnRQI3/pGtFwLB3V8Ks4jIC6X//BatpA5fU4I8FoHZb55GggQt8Ew9IyIJY7vvV9XUpZeqUQUNeTqVbeWR4rS262y3lPPzTzlpvJx5J+We+v4/GkpzHw/nhr6kBR/Oc7j/CV3253kPOp2KOCAZhw7qWa2m92CNxcKO54WVedIfTMf0963m5IrlWcruzTG4DfRGSjKxz/FQh3CaOCiTGrgrmtLBQKcUuIptTQG+n94ag5Ny8NkKwpHuJPXKGK6OBERbx3WdtSU5BZONH66kksmWFxOOqQHfe2UpkaepUBxCwMwkmaPNmZqWClWAP/5TzO9m/33y42LkxEC1CSIgWBR7KB9jUPauYoOOmpqOhSXH7tHRgXIvXq+T9hCwn95p+EbLL82lnyYCOFeanopsxT/5Si+0MaxT4zAQpIFuLdbqpuiCjZKZ2KKn3jb39aGoQLEo5kvzl16dYiZW1Etg+aIxBtp3yBSLrJ8vRpDN81d4LHk5PW7GpVtCpwuBf3zof+x9EzqjwkUcAmWQ6bsOpmeRCiLYu8rQAIF62FBc+a6g537c+VDh1L0/oQvXYAtOIuOJBjAkog1voCZbDpK7vt2CX5hQW/QNDwoJqy5BqhQyyifw2OBPWgSGKOljQT9p2iAn0FpyOwiD6UXNsZTTlandMn4VHX5sy2b3lq+ttT3NF4ZZqxoO2YqJcMoo0rJBrZWFcUmT5Dgf+I1m4tQ49VTLLWSvKDRnDEXBAII5GCb6GQPmj1eWWVeWfMX+r3urBgT/hdtzN8saTULwMx9xP9B0YGYNda23upJrpke2Iqv8tquPilQx2WAOZn6/xznRj+f4SZ3vvg/G43jWbxa1dqIDy0tSV8vco++f6JY5WJFPdk/et1dkunfvgoGq5X9N5DyRRK/vDUverYRqE8YW/1G9fA8oSa+FmlMe71GtZVNI1dPLDqnP3YernvUdw6OLJ7NVtIx5WuScKXr3Ybc/1wGImtj3VedaftuotfKbE5B0zvyurxRVYi3jzOQLRrIFio/8Dz+TinvicGUKruNVfGYzn3w0486TltqEalGiMJ1yUOWj+C205b6Zgcz5R4JhbVA6hB8EJCc+kw8uJ9vwAvD4J9NXrPe4U94OCQ6Y+FnD3BOO8W0/4tgnuxmmLKF1beueOysaEZexTT/tIH1uWmnfm2woW3THIfvM2F7PctrBIu6Xe+Cy4JICXmvthD5ldwTy2bREniF0Um5oh/r0bKt9xQfz/jLMtLdmewJ7KHmmaCiFqK003X2ONHN0nkkEy5C4WjKKvzBUO/Tz6zAGnfpdwHgGq9M0uw9PcxcjMVllkkT4vaaohYgpolGbrHnnpyfurVcoyo0GOKOeg6Nwk2RDoj+2B0wNBOIciBEaYCtRLM86ocS0BN3LoWikbBZOX1sgtI2gAD2gJCPwZR4kepZKyazmw2Odz7sM4bY/xVl2WbHCut+nKAPjwUGgQJm8sjI2k9wM79vNG3RCANAoizB2k1WcZGCDo/pQI2wWVaazt+SXztM9dfZN3y2CiSImAkFR+5OEIMaOI19B78HHGmKIqyxxjkUesiQHM8nXTGWaxQxzphs3eYhyaRRad/9AFYK2Lo/3IhusK6OWG0Ymc53hZh4TGWfCL9MtzBfjEVIoMZkQ2Bx+hWMrI4Ol+LFGt3rj4wM8Jl2RKmSyT2lcmYgY3B715dh7aMCW00daek/LRbbGsec6tlMk5sic81XOs357GeOdFNmyO4tFbLIaD+A5MuB2BTQitEpeT0R/LScTcYMdhj2nMSmC8r63uM5VTHnLj0X3SshfDdJXYz7pXCJ9+h6UhiizIEg0dD8RIOuHBpe4DBdQgKi6BqkyHcEiB+sFg65kHopoqqp8NZbl+/CPZcd5EeDW2CCKOUbLKojbqFzuF7UjmdbU/xDqo2U1IXrf6QZyBDzDb0aEncVm/ivdKAIT0KcFPqjjQSJGj2lblXt1c6SXZ0kTnsJ0sKVAXLjF5cXa2Tt0a/4QYqVjIizlpton6C6zj0M2PuRgKCKIFSfw66cFwyYz9r13N+JwgrRWKNpbqMtO7DUX2G/9l/nCOj6UTGGL8XgJ5QwotkNqgyGt3F/HUMaaFqC9yEJjtW1C8q6jUY5HDF8pc+qOjCHQfhRYdLiziZgadF9z21Dfn3TM1kdOuDCwkisZGrQX6DqJAWjVD/lBrG0GSUHCdy/b1lrKl3Blkd8yrwMD+Kgzs+f7/5eTwOp6mBUEjd93PjU51d/ppoavqXV7llejz8R9G0mEKIVXYym4cL3Ho4flvFQT6agzXkMJc18DnVHpJLmeEpjbj1LBI8xVvVTLhbPcbTCVSsmqVv6xDD8l4N+fAqPX1iDElO86g5yrPdNf401yee1F7MvtpgnxcGm2gHrnP1JjBIekFfQMP9CWZrV7NuUvpByu1KiWrcYWvoUtNECXhbfwaCGfeOuGmm4bw4DYUf5y5aVVDFAozMBa1xp6EPgDtxwX8oxKnyFGBgo4Ky1MKkQQzXbrD49OIt2GK3L0+r/3bmomF+r2ldGBlO5UGbC+TLdfBJil98SS3v1da4MixLrNJwp6iSRut1gYezZjPiHm0Tn8h1qi3fZH4TDhReTYZjDWjtoMAoNhcgbjFgEb7ON2QlL39FFvzxpZqR/moeA8ZFZj4Xiyf5+DNh/PRpiV7zUw9P4QV/zI0nkJMI0eXgr2hYM1uhdpm8CknHPIOEOsFqkbtUUqRVZNqn1Dcohbg01Z9g7CiOKptmnzoRz6d7IXOrkn2ukH2QKA9yA3PYH3M/dBoJM2LK43nYQsqbDnj8A+fVFXpWlPqpaMBFNKd78SvHofU0/hcsAiHfAjnvOzZusPenyCigCQWYCwQOUEmLlwEdVaxLNPuULKMYkqO2FgK36ODlgyAXhSyu+7CBNbhHKjTUsD2WoGxeDEBnZ4Q2CMi3XrGgh9AAGdQiO+TU7Y/sA6ZWVSeYBKPxeE/b8MQv1kAQ7JZASOi1i308rucAjpvA6mizNXUmF7emN7HMZ64QxCTZV6uQROzsrHPHyGXkee035MihOZJFOJA0MAtA5pyhWaD4fdUaAv+Ft8ENP0Zc9yGFmik1a6tDehym0SDXKb6OwiKYkSrBYbq0nqbzlQiQST6ZB0pMJYGlB3spTiVDqk+yZ5UUizCma9lCrKb1utQtm1eXJafwDhtLAFUU/TbaBqG0suPzZ4iNqvjgfCvZfsUuZIXmDDsfldExiAzSe5rRvTRrIdxTmacpZt3y4FkVFa4UsUdXw+sX+6CFUq72LnKxOQiBVIrVijTRB3HydwYJovncomcZza/FB25LscnZZs/fHQX9zbB8/m3DOdAPX3PyibjwSqiqdk5DJJYerWstcdqiD9Kpvhxj+Zu46fOWH9vZlo732ZRy7DnyTbFCbAqDokrXXUvf99+PJTT1c1+EhP2HUgtdUJ9WMHUPm6Zcrvx4KxtImBTH+I1QVXDT6xt8IH2DySx8X2mhM0uEat5rDoYphl187pdymxbQwPW0nqZO9PMmckJ05sgDoX729YnmslIsw2VKZQuIMh2SRu8YUIa0yVXmn21H3kZbJnYtXNq7u662CrKG+y3BnWHPDEArr2AsGcuNOR6cg8Ow2zOAgg38E8ycva65mF5KHvGw4zPLHY12mn/XgxooB9xtjxWKltfRSt+v4rxQsFiOvMKmnlD0WCKpE7QcXV0314zoMWAc8XQ92QI0CsJ7PJ4eRuhEdBMwmONiq4pIxt0tWTCK2h0E0ugXlW+//H3rxK41IS95yIZuB6QY6zcTY2D4K5JM89ITvcRGTixhwu37L1vxUQA6JmitqEUCbzxVlVkkYPrwJPVGFss2YicQ1W9TYYJ8mCfsSqIce4qxn7fATS+AeGlZKI3l2pix+2DH4LDtt0asEsbopLTC9xnUGBY1zzHbCRcNO5i9rHSojiRw98g8oXO9i9CITZ0PUPqR2kE1Ph+T0RqlFgLd/V+cn41fDO9FM41/qfjaA9c3SEol0U4ErcLnUDcWvrSU15MqI8gkDkXRSNAAvkGJQCW2dthwSIpqWGjMXH9q+ky+bDRRYW8MAVpTG5bl27kNUXNfCyTDb7VYFJf+rnXRolUXnExB633k455cASfeYR/K5/9ofvRagxGrXatlNICylqgyn+m8isjtt0H1Ds3A6QpmYL28ukmCa2XhIo86rZLvTwPAeg+qTYnt91WWKiUTA3iFi3GNxvikl3Id+GfhzW0Mq3LkAml9ikGhs8OBLLxDMdPKjQ24+wx8sUtzuRQJMJpMBueqeZdTL/zGuMNYAJpbYTOLJ3cln7EiSgYAYG9WEeYbCjl2lDN7w5W/23dkY+Q5PiWGr96iA7aA9kL8L/5R9W41pRG+7BjhKJL/DhkbJUXFYkL8RcOt17LvuGMfdjFfHccwDlu0CLHX0GruOP+qh3Pw9FDe0A1SD9TgkFoZ2fezrMIXJLmUp9l3jd8XUolmU8/2pg717Brx/DwVTd/LG4C1Pj0xYx8IqOzHyRkcqghV454SyocT+Zd0ZwB9K3YKVFYSt9RCuwvjEKnSCNJP/nJEeBjT409UszHS16XMvtjAu7B+dOLY5tna1k1oIt96GAK2XU/GWM3bu+MmhWUyhCtqz9P6A1qmUM7NcnOm+S5/tufG1cowRQF9z2NB3RsplNToyeg0qVFXVAYjfSq01H4vpXu6gbekWTPuVDfBKoDHmkPPwnBiYDOAQSXopUvDsW0euGimgO/5AOo4H1TbjaRXMZ3vQ/PJiurRgGCgvxIcr6q3jyGSxzzdoD6//qXhxigD1flp6T8pctk6b+z28o/xCIi6Cm3hpMhri2EbvjUBj3I143JATyNp2LcYhmCUbjzYuEeH2JLfPYpud7WzLoW2PCt3YAfaGKhEqTPUZ7ErN62iJbZUNzT3dqLDJNDIo/nl2PkNYKG95suVs8U1PjPIVbEp7XHUnqaFzSjbW/DFazFk7axXHDMukiv7qfYi6zJxL3a+4V18QOtGhUFBEM5ARfXUaWnEyEkry31HfdBSt9M2/lyQPXE+aILXwqC//Gu1K71ClL3U8sCoyuyquQIgH15YPRikOBRfJROKfNPXWhph7VP3TN845Jk86VqkhPCa8thgwPCOqdFnR02aT39hpmdhrR5TK3BHYpQivH7PARMnOfmjIlvLtCMoI7wisiuTw5mYcXBoIulGazU1h32hMnzsdGbFQK7v9u5r8bGqsojcI9jiz7Fy5024EXanSF0yHCMbD97ywOdur7HUKB/QuJpRgmMBwIERi7zMnOLIYPpmAo1GgyHCtG+m7bUgUEh5FllWI5OPmhjrCUsqCn3NVV+s9A8D+yK9ckRuMERF/iWZH/z38R0mmaelIuQ1qCM/GAzi1hmB8gCk55EF4rujKKMigrHcr9+CEOUBil9gP4gIjHgg7tYcKQCQbysHqvBtP3l7pyNDrEfjq3FaHVZyQXsIEzqwO5twPDO2wGONX/ZzwlMofWfee4ZBtRjNnbn4mBEJCEhji5crVmjsqBYT2n0QgMhK7XOiV11v3RCyrdDrwatc5lDwgSBOojf27DJo3XW4IZXKClFqOzAOjEs5zgZQ8WpENSb6vRaRzan3WO80c4CGpOs5OTKYpdOpU7JTDc4cf8NbG8Ho7jitGBn1BjuQAOVYlTa6oGI0d3ABCTkrMzNIQp/rNsWGbagQeU0XXvO/iM6mRw5NUummjP7oZAfZDf3Wv3xRgZTiswRNoTxsyyLPIIXQLugw9PgOTQhgbzoFDgcoEsbvw5UyNz11SG256g7YR6e0FiOlV5dBcCGOCEuJO5ptRhAKIjyA/B4YU0beWDpA20qNgbDGPSMKN2+biRnZXlPlLie/okZnSVAflWNctu9wxp9vncC1XPWXqIsRIDbsvJDO0BXnlwKK2sSzql42ryeVwOEDABzjCLhY5pWIwKcHSDzEz+sZ8eeO3rZeZCHdi7e8l3VRtu+nBS7XuH5rYAccaLffpigw0X4U2847b3fk/dcpw3KdLASHr/l0Ckgf12YJudLIvlafTkMkGf27QM8NIrQa2JjozpRr20da+NtCZlv/7rC05ucSi8xAHn42ub0lfUUs0imrEKPXsR3uhJL7NxrB2Kln+PtOqTsMXCXQAzvwK6+kdpQn1TZ0vZOyj0E1TIbsUSuu8lw8//OSIFnBWOLaW77b6forAYzqLJnqNRFrbNTdPJEaosf4CsPcXBvUIJN3tywoDVufxeGTwOfX1ME4bXaZPXJ+Zrve3Vh8c4/XWNzeoMaOl55N0L2yAFSxQXNOFrakxq7y7tT43Ph+YGeIOdl/rNODkiZOLweTNJ7wmq7r64oJiB21JX4Dr/a7Ssc4N4029CbioNNIqhc+XA/iq8tGA+SlKu8lcbXCvEPbQpbf0RPrsVDgn7otTLl6dE/bx5r/NBe/oSGv/TIIZlju286Gps1PTuLV+5aT+xZ293fP8bIuIlxdhbT5TQZC7eq+nyumW14aepqUG0j0xLmC+sFuldwjBRJdKLibOnI1o3nk748jpSQoHkrlqFappQzqAENCRoBzguR6ruAia9TCx5puahN22Kvz2DC+TVWtReCgdNkBqu/JU14Pzo1srvh0tG21UJbEFFKQyvx7OaCKeaEtv4cv6eOqTzOkVXqvQoKnMMCgtluq/wjxr3kmsJvWDGrmPr933KQ4R12xpr/h5UUhsrRyatuPfFmQTTp1p734nBpm2M3DqHuXYBR+elLeUcFTlopUhbySmLYRF8eInr3ahaO1EBIlnTKoFd/xJejVMWY9YI3f5X8jDKJTP4whYD3xgAlk8et0rzMBzrZtlVBrygSrimCi8+pzCgWtnMsvgNaP6iBW7FzTuq+5l9WqKPBQeA8z4/y3ovVHHunCVwodc9zRgKyhKCDYBQRF1Esrs4aEAKvrFeVly4F7DFYm/KQCaQ8nktAxJHlWiZ1ns3gZ+zhrm1461dCZOz4eBDpMtRFrH8KDS5Idev1GihO/IwPE8KK1xe5YxtMEDonAMT632/hLTcD/gwpRKZg1p4F6GiysU6IJJxXIWgFW4egaAAa+eicpex1AbpYx/bEA/SRFQFedLUUmjjHpHN7x6qWEqZgOLgOs6LrUrBpSUESGNRtVh97AMmn7BD4pORNE9J9F8Dq925yqsad1mTdNGl7Y0xg4LAeiC6Lcbraco6rJuhsIiSGROz9N5VAAIcSTALHegBNRRHc9Fovqabr77HF7r/P6SuQSOFTS45Zu/FTkpy9ROhRMqAEhbjB6F73byw7frWMWrlGzyOALtcYbHlfeiSz3No+XssFWqWB0Qts8fQpiMI+phi7TRwSQtkeEXRXrp0cVF3snvAdYACmIxgR5WpBM+lVzuGnVJ1OLIIe4maMcishpFBDLXm5HWsDjPm0XDy54uQrOAvQG6FKKiMnvZM16bvf7lJSaTDeHiD72IFQrPIeQr8WHzvEgthEkwsVS+NzfxM+wRytfj3lYgdR8H3QUqX1XhBVDpT2jEg4CZz1yF4MfHwkWEX+NTQAAkFLi4LQtPHUV8s2LmakFqQQsU+XmP0Fuhg3pX6oUj0rtyKtfXX595dev2uJTfaaseDRG8EAPyRS1KeOsHcrRvbuk+e3SjE7fpcPGAQi2Xm4Js4hdFV65qFOJVIYI9e4A4miwPEQhp/v/PgF/S0RAyOcQ6ZQcZckBMV1Oy4ST1kYjkO5Mw6vFL/39iZOjhetxakj37fl/GzqFuwVfXPzI9YehaDgw16ytNfERgNwfVkUalvT/OQiTetj7GjOsTboxJau7iqnWPAEmwJEElxiYq47sTbTHxnAbvzazh3Im2EC2RU0RY4cIFO85poZ16HxB76HjFxoeSR9+f3P08VaA/ulcwHy7BikrbjRAKDFnkCdp/c6Brf67e1AF0maX+FyrMGPJGZnEamKuO44WQkXGnyJhoQKV9mJ8LeM3EppHwM2NeHDO9VB8eYoA/ynOyTlHZ+TgodVoTnL5IAEPLg6ynylvbp1FEQMbk1qhSewbj5yvmJdvvHVxs8eO137+XyNuQKUx+H0EehTg4V+26YutWfZcS0CD53/Ry77TsIU+DDNswf98ATnXxe6cOk9nbx2CU3iyLuNx8ihNl2yjxOOzpAHpGjAfmNG13YC4hZRABX2ILEDMstMnFGUWCvjsISEV/q0Ci4ZcOdW8hDa8gDsBMUleVPGbMI93PoCEuZs0A6hu3xukRLy/wZtP76cw7Ezh8d3slZPpzDQG28ckqr2C10Tdng7p9gj2HzXn5PHEOKOMHvq1qfalos+CdOhkWZK3qZImhsEDmBuvlJb9nLswbfGpFxj2ZZHfsHG0kkxegeJ3IXB6Y+7FECdH9K2Y1M7HiLu8ez9hllhtX4ZKWUp/529kn2r/tbETs2q/F6HwPzka2K9eurA/JkYeyS8Uo/4c2IsxXUpvfPdr5n0dPu5oRuprCWjiX+HeAtXNgZHWSIB3mGViHE2n3Mj+uILDBLFJf/qQ1WNjrPLrycdtDloayoCNyMtEcR8+tMxaJjPqkuNKuypwpNkkiKPEcxkYH+O6YmUuQmhPVV9Bjb2EA3q8cIazCX+nXxmFT7XRKQLzgVdiJDTOq0/PrBRS4EqGApa6d7Z8TFcLw8TETxyG2EyeCfHPHsPU2R1LlqhEnem5oVmhkqJOCxNGc6c0QkepbuFtg4HlzyCY5ey4Pm2bO8lBOgQmxcoq+1gloNWXiFqLmy6XuJ4MCbfxZEd38z0Bqq7TlirqMDTZA/DaBhLu2OA+qDLvmNVakr9TkE3Iqpgaj/u06bUEgaKpoVqdM4FFuvtuN38aH80dLqG2Rs6Xtp8Uz7eBjMqSGMOHG8RvSCpdAtceb2ojNBmEN9p9MzWHYUubS1QMj2jZ+Rz4MR4BN7XelskfQs79lLqs3QG0j5WqHDxhh2olZdFTpnTdNaE2M//d8WYymlpmcdq1EvPhyE/8QelAi2cR0umoTy2Kpi73WtjItNbi+xAyDqgUrzsetfy3VlGahNhp5fmmePhjvf72+rVd9tYcMVrsI7qg7sDom9/CwTJXjLtDTCYhhKKOpmrRSwfKSJ4UKAOCqFJ4eMF+RljHpeYfdiVWhb1yR2wQTpViqRzQwMA5UJk8wN5YcLsTUX6yK/tH8R1y+sbjzcbDrUrH3cgDDyU21rpmqlgqRd3QR00cXFqGSxu9+Rf8UT7Z9ALiqVww24qcpZuiTCATHtpRYfDSmyyxaDXVWKXyTiFRG4zLJdi3rzhMGT3rDXlPkNb5bhSxK2xqCJm5mjPxSpAnUZGNYlfjuxJm/MAbeRuYstJ+b5s1jGAvjXt5HykE4cRBK6SgFtGnYnyOBDSBB8ayr0ys4m9c3oXDwGXbCbkXgIpfj2AtZ7Vt0XjZ+oe3etkLqa8vlf5a0MlEZIlTR/mJ5Ji96UUkYrSw5+v321e7eHEqXTRsqSziJGYeyU/WLw4swe78vGUQZShg8fOB82llTcpP82PTng+0JXivpQQ0iS4SZiUjV8B2XXWSz5iNN9Us33SbvbnSdasZL7GekreJyMyqRAcQ4aaBRZpLgasjhRFeMbOKCDCqiIJ+LHYFoS2i82fMIRSDX4XbRSKIeAM8tQ0K3eASEHPK+pvKoO2VMe5J2SKfGLjQFWGlKEsgxzEuUIa5C0k5tMxt872Gu1kqHBWQ2nTRLR4naYAd6AUX3vndioX9cxFjvBIUvUESV7KX5IUQGNvsxbBVYPAUPO+Sh7eluP9fYkh6fG5x3jPphTIzF390L5aBbGTbNER/UiKzOotq+lKm6E60IcFCmYoudULhZ5dHkH0q/jRqoyYlsGAdH5Fbwyj/hTGPX3d52ZqinxHobclr/EEFQM978n2WuQ7A474PRt2CWv4muOQSPsYjYKkCF070KKg+OzWy9JuAw2YK2n4Dy1EASu+RP98q7SBNNHKmwYu/rvlqgi+SV4xIpdpBC7uegUfBJgxMoIhi9BjwVJU1KlttoVrUwRCnZ4594ytUp81T4IIPBzxbUmYLpUSJU9mD0SjRsNT+zQpP+dmXi5gkMDDExI1ZLSDmBFuzzIw+B4w9teQCydBlerKsxpCUGkYIFQwoCfYP4SowsBd27xh3WD8vp2SJ2/Dtw74gD6LAqbOxhgJU8wBeH5PdEaJkq+7WsL2Dn6x+Wxqe6uI8HRxrEN0jV1Sn72KGFnSIGlTL2oNWi2ZVlL76MmphOYcbI0cJPQB7pfpdFGsCPN9hP6qlzP35qKmJuNDVeXj1lOkoIaJttZDSGqnYr6/YjTogfJ0FNxP+jdScngCbgEDhMy9j0wTuH/Q2vXlPhzj8ME7W1oNXwlG3qF6SpxZGCM4So3kimR9KppJnE4n+jVWngfkb2UAr9H9M3xAaZzc+1DkQKFOsiczC/ZrF80xZ/j8cZj1biiTx/JRNQFNTm+vIqoAODK7X3WnYdWLCzMLRt1ON/rSdw0lnuZX6/Hx19TOl1YEBvjp5KApIJwS8vGJFiMC/iWiI/URGY4+1vpQ1fxQQVbG6Jlv2WMEyJGsS9DY+2VwP8v72aboymhJTjv47oX2qvtrh1BIOih+QMBl3PURfsgSfpuaTsMXMVYUYinAl1kt3pWhgceEUIzZYejsRSgeSu/MkQUUdKqPQy8+HT2MKGPq/dpRJ6wGCSN/YF1pqOGeiPt0xiZa+7z9hcdqZNhwhO6ObgexMgIKlyxqIUEuFrp+593QuOwiULbkN1UNEPe91YQvlQVpB+EjyL5j1ASWAbIOanr1Q4swxw6MxR/TGQcPDsMFwlvPUWbxyqbfC995qavT0TabImAJnSpD6g+ab6Rw42vojArCQ/OIUVjibLiVudARNEOx2YMHYXH6GJcXGEEeTccOolcaY+cCQTElh61cEOgLhE6RJa9KC/s+wl8hX8fYObxM5kWqLVWecAnyOFQdJIGtLd/dTuxDdq3Nn4PbDvnj4I4G5mw2h+veRuJFffDsNyfm+5tAEnJD+A5O3Y42OOJwBaEka2lWywyMjb4gtM0aBCJ1kDi7W6pIfcQPOgTEAmlPX8S0A4TfZNgeH2xbzftfcYIDMUzE6HKqomu8wtbMkyw6kO0o/9WBlx/lfO0DIrE1zq8Au68/y2JvMR2LNsEFTdNcdKuPO3tc/4/neGzQaTHbVh/ickaHOBZqVoyurp/U2utkDpBKqsqSAwTAgtrBOoAPIoGJxwscqsbqQC9Cmmw/E6L1hPZn7OyDW6KAztF450UoWmk7mYWTz1SVEGqwFDmUAE7I4klgig1HOsJ86238eWL/FDuKyJVfDqnEPXVRzAchtTDRrH5KNQbrax7owOe5Ak8uNb86ghE1TeXFfE4751hf3x/skhf78fC/3ezNES0qmF7cxOe2JDOLMgnq83fTRebIQUs6He1xD19l7tVqe1CAFjizQ2krAuUrjLEM+w2DdNWTNkYzpCdML6yBl4rsUHQcZChdG+HeXH6OxX/WvlCJhzdPMYD/6cFZRSsBwam1r4OLYIfzwZxfZSZhGmVk1L2JXG5f6jyE0uRjagLcgPhKSQFtMv3Jt1B6RmT//ZfUhYnoX5jCGwDoezsZpdenfSTlTieQ0a5OTgJwT/5yMDhnqnhUQPHFoOQwNM9kyzFms714PI0IjWmN85YBaXuedthVEHYIKfQNRzCOIqBcTgVFRxLOYZl7XF320c3O598HYTjO5zT3ZGXHJWLpGQ+/w8SM9O+yMpL+3lpR74vFfzUbS6ub2C95q+BeYJdIXmcsGKdFXeFJKb0ah5OmID325UnucxfHLA3156wSa/wqoob4ykSBm0tlL1gZzS8/Xhq5s0jKvxbz0xyPzFWnn1hYerdJfK17lhCeLYx9di4OmCdaD9IV6qVn6/Ts1JBkvwxlbTiBnKJi7ZxsSGHWu/9GkNyeXa+y9qIT3w+RwV9Y9zDIdt8HpahiS/VUdjog/W+dPivi4Z1MGuYQU8R/WkN/n4FuVxvCQ+vVz3Eqy4ES54//84AOTSuT5emWQqsPL80X7K0jDgF/KSdGougD/PAm+C3FTONTqhuLzIXIQE4YC60dDRkdDjBIfp/aAefbccTYD/29LB9gooczPOzua0Q4F3G14ngcKxg2b6JFWNIABSaR4QCIpDqZjTtqhuckKeoUrjMk9QcQDaDzEVzSid36pFsw3GzV6C5biu0Mo+qdoZaTMCNnho1/OsNAYSbU1QiZzmzvWqOD5If7SZlznZ/9AY+XXEQTeqz43cxIw+9AqRaA3zztCcayHc5Zb44kdg/c8FAhmrad8Fjoiz7idweud0+M40NRcrYRgrsxJRYt3MiFdP1SEkTUdQA8H7cKGL/nl176YQb5650IMT+UYHLtnuTkgiIYOtG6Dht7nwfnzqn6lNuIXjTJyOptF1JV8MKuodqfJ3PnY1yowi9xz1gtBcvNduruOgoXVS0nEUEPNsuwNS1WS1Amue28UghkuJv758z3BRK2yOMNYs0avqLhR1Qt2T2kPatCStaJHoc/E4m56zSz8d/TMuG4Cqv8bx7zB8+ga+Euip22zXKfiplmVjGOSn6UaItSkvVtWfr1J+/iNfZZprszQ8cY/gBBPSPqmrQ/jjzXzptOr+UhwgWVDglrs2RqIZDycyw5BpfKjdghhyk4hL2ED6OrYeHsGhSKEZVQQz48KIvpDAVbDNXfrvGBa93SPTMNMbvHfCludFR47GVvaRJkDiBAnO5JKRaWrx7212Jn8sOlTq7ua4Cn7hrijaBU633Kjk91ERISz4ampJjoN4HQn8WMCbZmNJy5xzniiJ/QOMoSZC3BqknBdP26V8HugH13xqsllshs9jX3Fl0Xc7rAboHHYVEgid4HZW/B1oroWJCaeqqdFpn63J5PFJLLsIRBf6f/yRWJckQNwCXY3sOXLKjnvkK76xYT9Z/LkleBt+l+yp6Vx57lyUFkbawGNs5x+rbRnsetchJ1uTq8F7/TNW2cK6nkDeYqgTMdTwdf2UUYxGCtI4pqdzoY7C62P1jMH62TTbaZGkJvqcqX60YCXEHXSFTvapLzFtwrrLwVK7GBs90vKECrAL+L2bZSZgWccvu+j7l9vhbICX7eh/HcIWvmYcM1jq+SRAKmoyBYtPSRCK2C9GANlUHhUNmZYgNu1gFe74zt9/j96ioFhroNYo9CeIfPgBA9s5YAkPb8iZKg4aB7D53RTueScj03mdqqGUnfs0I7IhDaAFccxZSR0vk/J02ByRp8Y3JmLhMfJ58vtn6VM2FQurk6c+WTpwwSo+1AInbZ0NfeI3gzA+x+9/DCq6R4iVFEGzfGhxMe6votei66kLUHMq611koJGX5LZ8Ghu0Xrs9OaKReBXsU4dyMJUWoAxA6oZqOifLBnaiabA2ruZK4Ybs6Lc6+wDkgcQKwTM5fx0d43/KVFL+eM4XtOoLNFGxPK8EAnBu+q3dXy65IsXX9J3C6ScY1hSTDvAfoP7NWZ27B5BSO3uE8jhi6g6pPXeuJNqal8IzWEJzkEwLNd4RFMF0LWCfuH0JU8BeLH7mBPKeLNo3ENOYq7Po06l/nG5BlyIn1Gn4JjwK2bPbs/yACYLp0Pk0aviw/Kd5e/85DOXO5opbPBGlj6unpWKAynaHyPQT4ifrb8GfWwx6s9OFbqx5FKuS4meUhXR3lDXjVQYWb4i02d/1DE1rDzlc5gAU+n3hy6dUddi28NFITLIlJe3HeV/Irg4uiSsAAc/nM4tPMeN3nffAriuZxkWKIPrFWQUyqNiY5hvyAIGK8NEljqyi50VNbLHh/R/iD5QiQdieBM1QxyjUGAtJzhqtiT4SBFXpfPixFcnYzfUIwR9W9cogsPMaJ2gNVwquB9zMCAtdS4C/7fjdiDy0vAJT1tP8rcl54FAm1pQlEiY3GrXcf+gKdmgKp27eCO19NJMW6UD9vwvexseIogO+QtTwbsMbD3h0tORL43AYHPJMHXBcK3wg+o+Vi1xOQyPQCcmDZ79juUCi/2Lh+FntsJ7b+No/Vph8cUC1SYE3fQK0Hkah0TMH3Agd53aPnMcl2L6gTre9LfvBIRP3z7QqQ3Q2/gNxOGj1Lao6Z5ukcdu5GOzGL2T/Qnvyxh0DL6tTzU4PqVu3eXm60u5ZX8k5kbVaGrRmPPl5WgVdB4XMWgmgPQqfdpIircYXG5uoaVUGhhZXWK1aldTW585i0Vw3uN8NWsAIdLLegANTg2HT+prrJDDD6wKH56XtnOwH2tWR2PQONR+u07ooATJfvjKYXUYoO1J93CGY1xEgsk7HCK3NqJ1BDu1puIjjzheixtf3U19G1MOhaVqdIb+THbI6x58Sdxr8NGY6wImWF34sSCML66a9ajHcAUWmmih/K2QyioXJhnRtZgKQuxmovoNHrRpwQQ47PugMMdd5p4g/g4ZbwG4Hg4m9B8WAjEzBOEU5TVycK3b3q3taQLEb48wUbo0J/e/AKavY4VhnStCEA1jJQ5l7XiVfDOT8CI3Rnk2lRGW4Kr8R7P+fg4seEGPZgiCOoVR3nAeP6xkHB7/JPT4b2Uv1/VIouit7Qizs4B3wTCmXli2r8HiXXGmptSwTfnANZMMUSWlTBvsvEzPHkA53ZpmauVyMAuo68atnxqa+wkReqo4U1SUTATuKbZsSS+amJifCQI7ox616dQhj11axnR05zu11GWjMx/uNWb/A410I5iQA9HMzRH54SJ9YTkIz7N5qEZ7pgkAM3hiAzQoG7qN9GVEqmCWzhH+3absTHa6r4A7/IPhxn4BxGXkXu5K9Km0HrZWhcP2oGP+bBdY5h5PrR9g/PwmOdOVoFaOuF1s+nqoO8QsuywxBfmolvtSXianhNqLwABYLixQQfr1mrFq9gnIMx1WJHUmDt4fhRZFmyfJRkt2XyrnsIVJgCK5SdNkJ9bBgbgEW1S9cKaanGhpBZymYVYOMwOrVmA6TenvmNr1cu4ect2aOf851bafUA6NZMX5knzDt7RDw8UlIP6qeQnYRDsh54dTksFFYMSjBty0ZFGYObW4ZBDSkH4YJ/F4Eewol8mWiTNDwaOL5OIOSmm3ODpC0wv5iOX5zc7mp76h/9a1VhFO5wuiH1SJ8UGnETqL0M6GUUqe1CdOwUUZpuZbwmdSu9cyoJ521Aat9ND1Zoe3PEk48sPGudeKAaB9fHyQ+4GiQEVLGI5MB8ApynSM5cRtO93NfyKUdOPMfGdqqzWYO7x++AYyHLkfgrt//fNZOSyG1EFRnTDQN5XSqfxIrZWPs3xwDrfoQ7eFHKMhaZT4Py4N/Ll+YUoq3IVDJVVHoMz2mEihDFr/ZLqnYbYHDzsWbQPB8ZSLYz1x2U0y2fjw6GOD5FtAU/Rsj6/44fwm8JAoPh/zOpEfqKmmKYPikx9AMNvYoKx/Fs24L8KSFPyWI552Z9RziPLCmNnTuXCIjQOgzkSceVGBuYqUUEhFwYN2xHOLQXDUuTaEIMC9UbXlVIbADofbkGxWsk+mp4ENjWqe195BjHSaeiEhbe7KRex5eDnOymzi0hLLxd6Th1ANb35D/uc31fUzw2MIkHtuEqk6/RZlfLRWloQGsEyPGgsUVvUHIiQgeWE5Dk+c0Oips2ycF7q5BLkwroz9Ipu7ZpbT2EJg0Jrme03LuZLdCNGo9MBKsHE+G7XpH4TkI3jvp6xBScbDmbrYqouZsTnJMzTFFSC4fMiowippGyVXqNdGOcV7g4YDsw4OBkb+mALz0rvz9d+COaeQc/qN3sqKN9AnEwLojUqw1kX9kb8MUUVJyzdw+j1swASWhTo8qgbMNxjVN86SCwgFMxD1qAOd/ZhOLocOCC+Tx+Otp2HUIISmyFrkNNB30kF3UB2bYXr2CGrRROdNE3aoFZq2/ZEEtREloJUq2qAlqIGhjkfjvq2TdaKMFD5nUsVy27XmSVRGzdPlGGDpraaV6v3i/HgNUAKbVUv/4VKfWL0mWSAz7dEwe4wADcgkzaRM2YiNzRfr718dIfj3Gh2zTSZANRmGVhLn5Qy4Vv1/tsK22Kvdhj6cjxX6uXbvFSEtkqFzwIzy7hQG/zwjZa+TrhaZQk5Rw7HhUOfHVJ8gNTpaq8DrHp27LVQjg0ZsMjFmp0vnXFXYiAMxZaSmROtBjGNaadE3i8LjIDgmB4LgEKlLuOfeNDHXS4sjM/1emIanbqUbE5nXAx7ld+Kmg31YeGdl2AOIMMVUHI9E3hewXd3ngqPmlUiWR+3vZ0g7Xv/bLtOaWssb+URX2P0OTUFVIsnji3CBSxQZ020aDhISN74xXz1AQAA9Y3S2Mz5WgkXHUZUvpP8UifaMNHgahnfIDJ/fHYEHmpsRYNx6EXOD2A56mW7yp+2EqkpOACZ+yioffUUKWM1p/hTgelVCjGUKp+WzE3JN8vvc5OtES3bxV260Fo879W+6JkJ3DnYilXtOBppBBbSv8pwfWUaTBk82gKBzZAfVTC/e23o61fZVm+e7L7bQUpiiYsqecJDDjCHKqQSIW+cP+FdCBHUKymzr49BmXwi3p6wrnYsDdjDZiUNgukTSGMKiHouQGfikjS8/XqeKn/IimVcnmHa0UtXXt+YhvoMdztZY+moU8H0qd0/gI/WUQtwtEYyvJ9sLuC/zLwdvn/ZPQryTK8542RMjDuaCKF8vJh/0ANBxWymEWSBIBClrAU2vahlaumigZg68wYDfJFXYVRifQJ2IBvYxKZSS92Q2GGO1NfMcjPm07U2rWCYjQxaYEb6tuD09fku8mY2o+BRmKdyTN3trRhvD176FdDlUQgZy6G7idZXRYpPqS69HbiqWMWvrjNPlLKqONAfQkvveFFN3StUk51yzitQ6MR0/o8myMcvTCfo8luMpOgJfrOmrq4tF5Az6YZf5MpmILLyBs0ToAMIx39ozuaZVB4hMq37lZF8N9/dI9TbmsRJApKl5oYvVMPZoZoh7uLTCFqE3QO/Huzg6NDAkLWTbkhL5mYv0O5DnP751pSkRlqjy+4lmqOmbvR8NHuVXzXNtSnk3BVUrt/FjucBYCSHNF3wPYK+5FfSiAsjQ4AH+gjLhpihqLFisO5VyKqSNyuR8TjCVslWppkIsVG6nCCTZyxeie0RwoV3rE6w6djF4P7Wsn1/vT5h9DVAJX7j1JFsLBAm5nAl9wROq2ipfv1C4Cr0l6QCtUonpFW8i57VSha5qVCkPTXB/suiK+YwP3sBGan88T8rQyjJsPyqBawiHc+rvc/5r9CLefy7Zx5RwB3MLXnDd5mG7dvlylo9wL/1IkQLjlcu+jmN24BSeWfsvlJ0ja3+vCsHB/PQP8HIcN4rdRSIc8zSUwkH+Wxz9LjUbHiVs9nAbrewnRdve6tJMSlxSxFKfZ8JxaZL/t8wE1schPoP9fz0oADf0cfdyDk9KFETd9/Es2s2cFsJ9yzgAO2Dx3H29cd/s1KEiTsjGru1c3McwRsraA0DH7Srmp8h7RtcP0e9XtQVS+SYJMSuLrvjwAs3V3M6MqLCL25JN0JkN9D1py4WNUY89q6Opfbouw7Qf1MaskXCzEizR9+RzOk4P9EOUOXwWDfpWdMZ2YIy6lPaO6uk+G4XzVTA9EXfvuC6JxxCaN78woBYv5Rw+rr2Yj6DDF0EQEVysFOdJosMO8eMUQEbzuo5FjADTZjdWEs0Zz86Zo7grXY37V6GappUurfruJh3ep7PWeeQZHTwg0t/47Rv63UfqLF/QyhLCB6X0BztgHzifMR6s55nHzqFNvknY34kvBV9042UsoMqxFtkgvkb2iB2Q2CLSYscihVlb6MlDtoojspRxj6cPGzyNRwftP8MhoePVZI5Fq2MiILLV+4C1PH1j7b1MvqyzP2+zV64QKFePTJxQcXy9S8aEi3hTSD9RtzRaOe+Hdrc5pLi5pvG9dLCuLjjGJ/aTAaDsKU+fHZMKQsLUsBn/YVMeeMCx66609HJerUvt4QN7AVZYhqksk0jajSHSrzZbG3/ul/Ust1Ttgc9tyt7jxTngRUm/TvMcq93U/au+VN293aDZRYgb72K0D61xbtdfLsQeQIWMh9b9gbHkng+aO+K7Zom4Lbi20FhJfApkwtLQBDKVDhbja0KAhqJs1XccWXag5VcsQSFEHR+UETeX8ffGwASJr6iGDRzUcgXaT6sO2mHXmDLiXcgcGYInxpsEaj7+JfV1x2CDE/0sEBXwZn3ENrdUIj/6FACyNFq60D00DVrCjH/ga3+14DnvpAKWhRrytuh0FW87vdZwApBERCxWk08pkHK7PC1rmqKExrmJcaC3Gc04ftZXGcKzwmiDWHdpiAlttKA8CDjwfVkwsHgwNPyDKlFmBVfJe/SMYsL4J6iqOdOZ9Rx6XEleupvisFhfO+bzdKhAolxhj0t7865RToMN82OMm6Dd1GK+zkRrS8WrqZHzXRjrVa9WuQL/MOvFs064L/h4YSWF13hNmzM9S6bSKIIdQL4Gtauk8S8ZNthGL9NEtRF/GDDrcHhU++eaz3Qeuw/wjxLdfXN4EPoc83WC7/q3dvXEdJYmSgCrV3RcYvB3zzdmllqD982AO6t1cxwO4YLwJsZCPDMnea83ygLR6xRQH0vjKA+J3z49huDebdJUIdzvpVwJKfJFi/O3j/DwyRQegDX/39s412H/JScgIqnCqGBYg/kok6hHcbmLn7ySC781PHVSETTYZpoIpn+8RXL3Ii4Nbg4RttUPWCTcJipvEjsHxNWGFXZsMOubtnZyzqtUYh5v/6KDdjyn6yHc/40nju0XEUNa/3HP5ykVsKjAhVYVmHBj6tsVujLpiJ2H9kd3ptF+MtLD7Gc4rCjFCQ6YP5uiL/LWB6yfhLIcNSMqj2Bl6PgXJ55rBU6Lu37j8QIjWuyIt9tLfdjgPizkysX6/p0lO93PsSNVeJ/MC9z+w0/1uYs6Auc0MAZOWEHJAMcAKA25N7zjoWsv/N9ZKIrWSopCqCYTEuXKckr4OvWT+Dg0AWsQG6BRuayvHd0EujzrHrWBVFHDlNPuBsriPM3L5yd/pnN61d6Y40weHR/Pe/5hQiuykkuPRl/tBQ8UKGDgNi44cJhcRz5PJ8ykGLR/pNwfYkL4PXTMCkg/FlXY2MaQAObKCgWGKbqX6jIx7LLtohEdzq7qEzJdMtodWKY67dWoqVhyKvKpmRa2oh2QCxy4F4kRAfBC/oBspPZgIHZzvGLQV8hOfA3I//Cdb5ntEUdwQQ6ibXhr+goALa7OSpF8tzgx3vJ0e9dZvn09H1SLTX4S9hqS8m12WejuaAH+Con1Nc7FmoGKG4ZdZ2ZGGv6RwlEEP+5uYs4aaiNh/sRbQlWkoA3EWHDwNpPumkqdUIwinC+pbhxx015u+n50j+pNRhTmrI7M8PGCMEAUhfUayI6D7grOOq3iF/9OLLY2kDspjDpm3gu/iDW5h6u2/FtR8fbqk0fKe5zZkAizWWWUbtF0eZbwPhjnzgGvSvHKVHZrf9D2gQ/gnIIYT3SzgO+mnJjVatco2exHi8eqtIk8/j/upl7jhk/kMCL7HAyxDFOdT8TAxsVDeSLQQpNQ7Utl3JQ4PSkeiq6RxTlDAi/FjuM8zlVQoJeTXOWgCP4JfPKZT1uOZSbOWBF0liQSILdXyPEC6lLB84TjkUBRBcOIEbC4RBuDIzkFskKDsge8u+JwuseyFyB75SK4OOd6KUyFqc2G+6ZyPm1+JsWHGTlOMId8tVEJs8hA2u0bwKw13qizZBPvbBZ0BoNjWR9d6dj7KhWR5YhOW6Zvymz4fM3OuzJHEMiTIm3IbSho7ZWMacnnBxzamfjbzfQZVfN8hjZPRJdoyE09A92g6eeBSk2n/QroXs+khg/S/Ets9ZskhUzHL/XgL/dutgvH6HnYpxYXj13u6/XkKbhaC0F2secq2GcX9CBHlIdP4luao52jQVtydiGUYDxmwLSIgZLwJlpvynoajLEMlV38Z/FQkASWtYnD/6m3kGKgJA4592hMDZbvsTKdOCAi0unPzjfhGYFjVuKnBcSRTloA3hOroMOD/xtk+TBIXg+YpuF5hPqWGPcDKxDZY7Uh32E9v3dCwU81Ky6i9fCxxwhyuwpCIkZboOgxowfORXEK7pdP7dkvIl6roWGZTlcy59Dsz5MhONGEErWZd3GrjT8tPaSnXRmdT8eUnztukwIkIchaV4/J7uAckC2XxwiOTuxrhPC9tnv5WNdrA/xeawCsm1Nv0saGf1+DLwKJ0M69x68eVlsDlTE3eHmeTbEho7VeC5gja9hn+Zt+L9yKGFMy7+qC5Z7quc0JwEZXzp+rKjdciswP4H5GrObvK5jgs69xbFBzG9e/8BmL/a153EjYIPsQi+GYucy7UAE6tBKSodVEf1+yCZazu5KAp35piNYaK2WPmKJkE2+lr3Jrl60F+xiaJVuz3k2V+XOOoYODkWTQfAUKGo2imzU9inkP+oxMxf3QwVeDhx9Xhg/T7mx/xJYd8DdO8/WKLMi6ETWLhZVksCvNMLEXbI/tmL/SLY8IAukSidOE0cnDS/3natPEup0VxkW6YD4nrlIbR5fDvQbv/rPQIF9hlJu0SP90GnF3jctctPT0lA73gFkQsRi8/93GrvP0NHyV9D/c6a9fZTIybx0uxX4nL1ZvSUZ+Ep+KExgDV3WVuwf3d8XpTcDpNSpdRW9mCWD+ouz9jfcPDqd77XGcNL+kSeoGkOms6IbIw5E7MPg2Qoey0kc5QV9KEUMP6NEQG1i0rlKOBaaXNtKJBjWCLSP4/IompoDIsw7LCmRwtUdz3U67TW5dxvrfLRN8zt+Wntnn2ahNGqhVBAclKWGlgXhUknQyWllEeLQVXLgdlxRH3QdVPzx3ffrXZkn6cUQy9MCFA9vMC4xaWLUGTS356/hDROIVVJhpCp4SoStVxW3Dqy+CoLQqezbIB3WYC+zyQWAqn0rg0YNCB69S32mV5rhuCEjwLI3t7oK5PWkO/9D2cIiUD3WXWRmbBRf64eRMlkPre27IwQKtiicZpp1fyw4301aQoSA5toEouWs2ryfYPTmobSmbDW/aWT/gHvfzEzOHPzpvyt4BUTsRFEd+sRXt0NXfmOHkLyt0Cm94NoKQ0cf/5ccWpJ9VvlwpXpb5yuEp2ggEVPuFWKqTROGBKPK/PvW8zz8S55uP7I6B5KtnC2wodSVjO3iNouHfqzw7Dg4K/LnVI2QTcn/hv4ecvgqxukCN1rZ92zPwMlB5iT2TArISPIKC9kJSI50HLFUT9XjuvcKVkFhzljtdF5TUP77Vddc6jdyWPlaRHde2Kh33zMao2HjQ4eKg0F+UF2u+UtPzsyACI/aACcA9kUOt/+H4uRdpVALrnbhib5l5VM85dUlL2sOM2BoMSQvX+7QopTMt3ngmaElfpMXtiDkNPzhSmCgNc2bFOD6//KH5oqwI49z30HMdEJBeTN8BX/HydGp5ODV68fN6DYXqpL8qyYHrA4Hfr78W0+cLFRns/kRnu5jXqMiVuHXaKiktw3sW3XqCgejmCZRqIoHx4RCL6ACxCxi3wBm9cL2QGYtW8A4c2V4EtXKyMXS33R0/wjQShwKHLxNR0mA/u9ss5wGp0L5h5RYK/sjEj73dXIpAOEnZE1HAq9qwrXQjt15iZ1XO5tTh4D/YXCuSaIPCGc0UEFFNQU5jD3oINAVQfMKkXHxSjA6tiOhkOP8HBZF3dDV/ujNafAZXPQAG1sIAz9fSXBbeYv0X/RmeC/uNhBfVRaHYZ0coaEzjFqyOvY5l2DMpwhtinAoX5w8xiv0Fo1t5jmUK/DkquacsYRLCPj+eBiMavu3bf8S1Y/biiwhIBvbR04tqv1lzYNnZGj5sU2gV7b504Gqp1d2xzBu8t3pdy8NqM3QUOmSAH5WuUyQ2rUj3/RU8tX0QHJHxqWheKGRk6hCx/k0vqqD2/PEN8m2yEHe9rZwJA0LVIhcp4jDFIjVFjSvcfdWJw0na3U6+84LHg0DTX65StbjCJFlyfNoM/Ke4KQ/XaSMPOvf/Il/A5vvTRwP1trb2/O/cRS8jy0KN4kBypMrYjt1nLGGiyxZGHXqRJ2sg1nWC+A2avu47Z621gfPtzY9hgqyJR96nJF35tdERyhPOIWNjohTNtLoYvPcEiBkTxf9U5CfQXcygqyUdbqPNwsWNOxHiSeAkpAip3KR76mGDKVy4R0oW4rivl8/wHB7595qxn+3kjxute7pdeZ5KmngSJPB5jnJKZsW8mKiDsV2Ky69G3DrEC5P1dKXInqesOCWpYbu8229MVbQ79ZeUZqultP2UqU+gKAAfeC3/N9iDGBnC2sP1h/o0lqOjcybgVuGvyeiE1d5fy70FfqqVbm9Bpg5l4oWwPRSTLBSIhiKhoxZ0PYCsp2xJrhzkadbdqgr5Mm8rFdUbWvFzgFPiS6pVGyKi/7uKWZ6eHseOSuE9X6M7w3PK7Yvo/DUsWgDD9BR4xsu0Gl14VWk23Ys/nylCui25QMBfRrlTkDi9TX4B0SPLcFa7GsPJfj14P6dBUn1nOtMgIpopjeKTiDEAstkKw7+hVWkJsf0xNTD98YzzINrVxyn76U7JYjTg4MgCMafo0Sn+7IWxBrSk/H4ManCGL40eDXnc9MvjYIwx1S7nE/JlFHOIHtUg0u56giaSovuf0f4oLilB4HWvR+2w4OlNFdFXEbU+g5SVjTgpTYxDawXvcoBQtBSPQIJJYRNXochBSbRos+qXuu5Qo9+Yetl2AS4215Dw8j6d+YzmgBn3xEUtrcgcMd3KH2GJtH7CDoh2oxC2zzfNDOHtcYs2WwcwIX2T9M4NcOHw+U8bCk62YNUZhBPEuApK5IxXCEFPy/6oY9uvd/tnvmOWmKOjbrU1AlQPkWQ6+FR1hqEj9vCN8ApQxefOiXgMKoo1FZjTku+vmPYYQJ82CcwjvzHn2nR6Z1M1IvG8En1DO9ZegXZzZ8OY7jqQQz+zUYvGVLhx8Soc7BA1xBSa4AA7jklZ97i5X5Tu0lTUvxR/pztJ7VmyhXEBQzhvOXACO99xfyBcUyH3gQx50zmWs5Bp189XxtLd2JbkntJYyX6mocEOFe3qX6tuWm9aQ9+Cgc1VXKao/anPxPa0dtYWeDKP6Cy81nr0QazKJHx01k7aSRRtMHz0gMCs+KV0gRNdiYytPufgEm9VWeX8F9wSr1VWAil5idqec9ouVe0eYCBxf1RCnhUpjvv6Vc9p3AXcNfL5ty8/6AS7eAKakDxZXCtzSfP8WQ0A+ErKAtkz15Uh6LEs5bUYRcBXFJheb/HAnRuhaVGE+L1Fp9VC9ClsPcWVPGqJAzFsnKxpB0/5kfwjhoNT9a6K1psKTG9Xy4J/OOS9a6UgJsg3fWf35zEhYbbGpeYoqqDwQQelWGhxRkDFOOPRMdE97dGR9POtea2CmhBu2iPQ2HiraiBcyKw5kbkmlzFvEO8uQeDhBkaBJ7cOzVm3fQmExojqeE0TFYYBJaZrnsukPl8yaWejFIia6kc/hhcJJt57zbepjNjBek0t2W8E9DsmEk3OuZPd2ILBI11voEWiu9E8LNYT6JvaDHoAr+p8ZjZbdmgZNMg7rJMrRKEDPk5C3mXX15MBXcCJbnFPA+YyENl2V/ollgwov6ykpkk0U45p9hS5Nud70zxU9Lbh1zOCa8BVn4aDQNHmuEv+wVSlvRniOU1e+bqYb54F1+x2m7AmABaWDkT/xLiRpvORxgyUu1DiykkgaQr12nW4plkH3nUA96IJ3scu/LpVCZ0dNoPNXYyGSukGxgg1kJDyCYGh+uELDv6nIeBhFIzrfSlJsoMy33tjrn4Z3m9PuIsP4mYHhshLQcuNUSv8LKNPC+cASgEXc0/0N4COU8s1FMFdy4XH7T4je2O/dnO6h+8jUn5f1ARLUxx0X5wxpi2WRFqc4I36TuqE3dPDKoi0HsBf+O38uafncodMSQa0G90WLAMPO9hMxTVcs44j1TXDCk9BSFpU+mrFjRwVID29DWO9qz4PhKV4Ux3Ywy6E/NJ/JpIk03/bq1yssFyuqbYdA8ibIsilza5RxcW5ffRUdA5bXCjEzcQH/6ENg9p5CC38UB5KN+4PWNt4BBUacpAj9HVAvqji8+E+3WU+129IEaRTBsaCq+hHBuuADSatXNXFZIlKh4RB1D0SIQJ1Jf+tqYLtDjMELtPp7e1pPBchqkm/OAboD9ug1nWOpWZg2onMq+wLP4bgAzY2HOKsArvJr8VyXkRKPliIf+11f0jaL5fkHv7hYe/t9pOV0WngVQcm62PeQeyqq6x6PATHppbI08z/+WcnTFBXmzt9TR8R/mB6pVK8WO6+PUsuCOJ/PrCfayjs9n78s69/dgZQqAfZ34NMs80y5IGZJ1bEfYxaoAD25g3GSVsq3RFvdRp3rl4It+vxXYav0/6RijaY4+xc+nVtsdNeQjf0qPymfTEtkVtbaEwzRKd6KNDHMDdrDxfYsB/djkg74zgAawc52b51rZYFyV8lpJOiGvG7YPHlWPbG+w4oQBF3LICfmQl5AayJRnF81ftTTVn3F/8MqNMqmnV/EDPk0ht5oHa2Dwg4XhbRlS4s5oSX2mn4Wk6zhDHaLBcFNINgMjDdHJ8g+28hL1gtwZJIVgaYXr3lhGLsUJFeOFw7e4fepiCWO/5ZJXBHRsR7BhVR47s7nIrU0ReaUu0nx2/z6/68fOEtPqY4YQWkxmkX+4+F9Ur+l1N9HC5nUgEgZVwWnKXRVFct18FWZ932CEMJVe+d3oLeIkr3AZIymfe+C/HVd+GVoE0P9xLsM93bfuj1vesmzG1fuTDRQL95+LeYhoy4MTIz3WHFG2LuczA5dDavnOXp0lf8mRiRnZocqJK/oUoZSaVd1h/1gub9fDhmUBP2bWUSQyB5DwiOlN00m0ybUjAOGXZEll16Qs57gexizhRwcP6UOoMohnL5f3/1t1fy9/0zN1GQ4L5hhcxxO8NFnYiGymvV4Ss/KjuolQwBy83xLLSh6x00qx5pQfx33lijeqXoFHSIMhqnO7P8+ePcH06EV8MgKJC35H1osaM1WaFUTTva28FnrkSRre8isI/08WbQq5l7E9h/b8o3mxw6kfoimym+WqjDHJPhP4NoyQJr5A1Xf89qqT7AZGNj0MTbZCBuBOLJe+8VI9LDcU9YrJeLCx/ElisQZdzRp1/3z8RvpI0FJZsPynMzTexx0OYvcAtM2Non9YzE9GvgDft7gsY61KuUK6ITrPDDdH3rIJLGxypa1+2+YKuP49Vm5KKzlLHQ0MHEy7qXHmBMAG1SVdlH/JbcfyxW3IZW4G2fBp7MiAGXAVtL9k8ELiem+11zlDtXQ65wD0rRyD1azePx2CVnlxX9sFyUwvTa+QCZS6dXBe0fQkNr+zA/EaeN8tXEZoyIaaCkwFNvQDhFDsawcciKwi37EcuTeXUXu0b/2zGeOHbjlL+1lwKg3PGyCfdP0z6PIxQ8UTQMTxzMhGxcZhd5FBAEXDK/EgFEV9V69q3hXyXGjRgly44PpN7sJWDB1Cly/l8teQeJlPNlbR5x5Xfj3OiqADMLjuYgGEiXsHDVVJSMB5Kk/eJ4HR9kb2tcQHwyK4rdbulaH7D8T6097XxkLsQ7QvorJoMITeg2qTSi3Umct6aYblFCjoO3imdNjhViAY7BbfuGCcnfb5xTmv42mdyo3DUwTIRvwq/4bu6MKJSQylU398RjtbC60EO4MPDG/5SgICjw1aJS3tbRToBfjs2eRDdGyCcl6v+ygRSqowxELpMt5LTTKD4t1ILAeJl7KZi7KWctPk3esiABGYgJFn5GRQUpBpyJzsjXkFOBGSkCIr1Iml8P8nyYZ3dExmAJ+TeVV5fjPLcOvD/0dA7CoDWIorAEjcUspuKfx9CBBwHWMauM2fkWAbN7puiZz96iowoZTLcLdvfZUP8Lf6cF+cYKk3LK7ymbuuQTxhq3ZSEdxIxKoW2v9Jd9ZPOqOjXvGDt2ZNMnO44H6liRuHO7U1FAQIGyFa+SsFxgi5vmp9OzWh4kM8Wm6g5ct0zPDrOiDX/7B/3INGQlkWzdwQ3QbUrQYGbibxEhBkuLtHb0UIzU6jo/afJ0o3k2cjDn3IAtOnQh7ni3QbAfqzEIruAHnmlk6NWQ7Bkk056YSpU8Zqv5ODkB0/XHAPc+Bnw84K+xLvFyfWsJrg4u7dn1u+iVMe25cBPhRd4uXNEbKXmjBDSAnx499CFkBeWVYJq1VW7LVBXdfIcLyyCea+jAlD5v3xPHhT8CUcm9n67MqDlMKajNKdWtBymQKSnKfIPl17VptYPN1aMwmX/KEkV4XXNaUKWrWOtbw0bMPaG3zahqCk80MjiYiTFvJWpGqmj2q2S0oq0hGNUn4Q+X6KLGfeYVeqPsNqfaxFvGlKH0JKiogRn1VgPHaT1OZaLd1tJ79qrM9amiKhB++2Zj/Wy9tcxGDWevD3kYfx2m6dgc68aSHDet+9CKVK+ZZzrFaUVJSNWT8uXENw6yVJLLYlOG2rFIGsJ7tJsG60GiHBFqQPiSXYkBEneZ3EmCt4woD4ZLkgoVD9z2u4v2+W295ar8vV4jmo8Vnhzb/vlzdbckaMON8N1ZMZDY0TQdW/v88PH0MvglyFxSQzIFqDUlxL+p58YoA/niyMsVQexVrYvque7WaIKrRud+s6Ju4bxziDYFcy30QnrNb4SsZPvfZeXaqsqYBoIv9ybrgG7SrTdFr9SW4eFYGKWaVPTc6rvgL5Sp4cpJ79sUrp5y1pNQ5qGCidD57KiijBbDo86vCefSaz2TzM25nL/Sa7LzpfwE3cH29jnRlgMy+eF3R2rGYLlycZQgdEmOhViZmgDIBkyfHvO0j5WYPrkLSjNrjmEE3jFKqLlngWnVTs/M+Q7Tjjj8xpKjKYQjU4g1zT+Cef7MK+En9TRCyjfMXw8SAxRYZ7Uxt7R2QATm6uXoOf/sU70Pk6lBlHtVIo6OV0n7VWGjhnXxcvy4PzNgAJZIbN8yCqkTZTmaj696HCDANrfmjJc5KM4barjUYrDDv7gJilEndqRbiY58AETdybt4h1P/DrnettWgOiH/ktvjXid6g3xas5yZZUpoXh8zQ2JS++AYnlu+VlQgmw06frK78CgwcgrUcBTHPo2PCDxOQ2FL4hSulRR86Y0fURRqWRRNPJunvR/nylZmPJIjoXJDJ/sQF/0Sb3E0LAMZn4NccZYPH1EXNFx3fxlCvgQU0xKl51YvqVI11ac39574a6MJYgXTNIa+xN+JPuAdlvAkLxmpTgofmJuV7uaCFOp5fXMWV9VKL2AONIJmyLABkwH49Z8oF4Y2CU+IVpJQCYzJbujjNFn8mc30DoeZn2wp5xcm4XTPuCo9BYTffJZ+QLbRnSp1mcfIqAY09N6hcYA+CRmXNBslCZRUYIjAU2kcTIttyuMwD/TgZ2j++aTKFx7lgdMZORYXZfcmWctGDEe+/7koWab5Xf4RNXTVdIby6d/WzHs+wexgjNCUBNuU18SR/1u/VER3oFk/kUJTCWGMAVo5oo04lwjDWlc/bQ3BFrgoSf/2/0oEbyQW145XWAUtY2z3vQQFWEp+j/InB8FCcvK8PJbsY5wsr+YL4DSFJrHRByuku4tao0qDeZ2S8PuFR5xEcNW0H1dD7fajwwS5MR/GRYDtjDJTkWVqoZITXz/5zVWtibOt3/bqSI0RrswSCtw4JpZMWB+BU+LvGA+bykNpr8gf3LqlFLPnkloPRmB88k4A+lA552r2peg8h5vlAw9GCi+1UXHOMugroVxCOYjQtVjCoGSB55NW5yo+UyQHmuMV/k8VyRQqZTe7+0UB+SKXnbKwbGcIEDOZmgo5FKhuLKrIhiz8OTemf4G566vIim2SK7noqU6XL48uVjw7DJHG20VtVqvkAeWEaWWD75Hw0cRlpM8gevvAU9S0T+2UqoLj/zCsVKNaQgQo3yv3bSNEe29/WrJ8+tTgM0npQhT/uzJOi3ZNNGFx+KMbvPMQkrfKdNXOgsdgLEf6kCNrJrtaaakctON2RV+1KFHQ7baV+smhbHPGBDqdbrLVjR2NlLCn29nume7zJr6LY4KWkpEt1bF50FPDrSD2r536B6EOi9blOhCUk92rPqXhXhLLYMwBDhGuyQyhFgwcX/vd6mdG/oxwuSlse4cxcXk1glg/ZmvZ4425j8DttPNAEXnBVNOpz5axOGTGy/9fOezs0nn2Lkh0IrumXOh91FCqdAUDman1e6UWxdFOuevR1GrWczi6p0GOinhEHG64NMsj025zTB/OnHmd6cqyGJSv3pxigVDuD5u1OVQN6HdW0ghFp2g4VZV+eQJ+p4uPiiCiGdxwvE9HT20LH774cogJ50ZK+hXweetfcKazYsuKj03piPdenilO0AsTUt0q/6iCZMOvGGDiep9mJt4RmbpbvGLaQ7wO8c58sVvjc3iddNVsE44xT8oy80gRKsuK+PC+gn/xOFpMAw7hWBNQnzS6Vuf1dmQ3ohC6KetzDVWoZePK1QCUpRP4mYqq6fIhK2gdKNJf6NkwyPpO2uB77NLfd50Dj1E/DqaNszyXIp8eA4LdXacfKv0/HdqUayWom0YbK7F211e270r3KC/EU/cv2jUXqngVlpfjPEVIOmuy7nhDxciyPpSoNHVWAArtmnDTOh06OvbpYUM8E6gpfuJbPFg4td1jNLWq5VRLyrT7U7RwCyROu4RJtUR2pOLXXDGfjKm0HHjK9YYnKvCSfLZfHtmGz7kV11Mq0itPNFzgM8wdGMiILZz3caRncNO0/D8E+28pfqUyPRlY4YJvCPlmXc7gBH8LIl8cJFvXY3nYlBCDS1a6ZR9JffvboedKCxMERCzy8cXHLnj2Q9a0yi9tghWj11oE2GoHjw+1M7BcARiiVNbDkzt2TXYXzrEIzHjwIkMDXNUOmJTTiX9inFuhAv8eEf4j9DhNhVFrrE3ZVyfHIsm8ON1gBE4Ae4Ei7VuJfhsAr4+jaogUOKUtnD3Jl+GfGBX4uCpUjf9UIag7285DoeitQTRc7orn51CxWNtW0arfEUYZVxI65Em7m8XFEuj+/nH42RCangIwfvVTOtDYoaCcInKlEMyaqh5ipa2apG+/sz7mvEUQlYMSOB9WEsianLLFzjn/aRe4QrAOfoFeO3qSZ/q5JNCDqsTq1T8pX6unNu39n/Ni9GFQzV79J9XP1PRHxOVoeIs6boAGWZrWfQiKREN+uOOwxr3Q19/GY1ouIYSHFBrP+O+Xmp2hLXNx0E/UZUYFUBDxTJPsDehRNVWe0HXCHy3v5tHNGElgLgxeTje0gd6v0fdoCVZdfcxqu14/qlumhrMRJqeUIItMOshpLp9JtvuvHAgmZr5Rbc5CoUQN5RaQn0nRQ4OoLZQUvp6IcOwnU5nf7duitkT7j+BmN11qSg/h7LB7kFFkldV/XOs6S71M34FzqUnrsoRExXXWwvbTENJAEg5ySc+b/vLcdSectkysknk3e2ws3bvqorfj3bICfg9mVrS5Qmfk3dOtV/VFQO+/cAvvriLAWtKInw2V9kJsbUoXWU49CEZiwdOB+scz5drkNI7gbF9/Tv7xInAhcEDwCR1vHNn7eMH7sWcm02NT52pMfwwzhQF1b1nIQwhGFPvvelf8rmV9+dT8/BiyoPB1RoLPZ5lMpxHwWS8HZ8ge5aZe5vmrCdOTd6h5tprCkLlUFyb8mPUAMPX1XZGme/i5u7iMGoZhDdPFibpdlrVORFhk0E826M5wVk207850jgrY6FGs9+A/TqKKZktWYI2la2jqh21pFYrgYyVNpWvb3HuudzUkBeK5KFgzXMXKpkypPlMPgCO7XLCkAVPfbfOEicNzH+kMH0CJthhTDBxV1pcGSfbwzipRKiUZsUolRWruORt/xeMwKL/+ZuMbLoiJme/7o1iI5x30Hj0uHcJzrBC52Zwh1RATWhYj/MOKrKGYfGM22AwEnsImjcZ59Ipw6iM+/yjmhQdhDeuMEfP1YVDjX1JOaTXont88wv0k9HK9Iqjei9Shdk5raMKhewpeL6mMWsadc7hTw0yTOV9KvDPNfZgOp2OZyT2JB0SJFmlGuXt69Z52nWQ8izY5a1QNsXjl1hacvB0mpO3FpfpTQImggzoiQ7Ec+Z8VtiOzYdtoUp335S3jpto21FyvLots702gzmEAOpRjtwHF3Q0r7nzHp260Sb2ltoPaGS1THoqaPSdFtJVFMnP5o0XpqIH2BfFxbF5WWVrsNbgiloxtDKc4ivfJVoMYgqlsBuPwRwDGCry7GoijiGUkdtmKMcLm4vrjgHcXjKeFzHkZrTzi6Cx3nn1WxO5mFqqTcSnMHeYdgvjK5ljaPnTL7Kciu8eo+XMHQiUv4zM3wiJOOXkK6B0/XSXn0m3oFfUCredFo/4a1P1cjanwDpsHGdYVi47+sjHE4NmtgYHk1I8i+7pnxX3ZaMO3gaLAdxYFjw2RJYuc65/uY70GKb2yN2mpgjc0I2O1BsGiraEE7YTEoNTwM9KNF8uVqMJY/JtNfJe3fVMJ2kFWYIQLj9KGpI4pJZj/101dBiwmXc2+r39hoeFJ127+Rd/z8eymVpKy4YLxwTD2v3w6Whqnm8o501/mFSaL0SXZ0PqRCJFy4i0YX+b0uWME+510BA79iL91wT1efnAhA9JFDVYr+ZKj3THwal3b8dZmALNF+mbWUv5ZdfvC2KGbr5J9j3AIJETXJ/cZFeS7LjpgZXQDTdWKlbU48FnR9MIfRbZuUgiO040weEvowAZB7Rzu27vhj23sJ7GtRv+yssnM9tln5N31tUW8bTyW9rpDchAfN2gEb6hZ4Bd9L3m9bdCxKbSpOx4ztTrXARIk+LDr/1s+/abaM88K+v5+DdW2h+5YZtlUP15zBw9M4oCt8P150IUGIhT99ID5KBUvtP/xgqSY5CgKPgNomDkK7c/GteSFhkah3KV3excuGb98L4c1Oo9FWeMte3uredwmhZyiLN8DMdTCtAhSWFAg1GjVvrTdb0BO/5BTa8Iib1QLNQ9InTfAX2ozRSC9OnNOgHaPFAD+1I7MsQJqKzEWZ1ak/IzlMViVlZH96MrOvcfB8WpQNmIpkQq2nabulp5h5Wkbu6dedmfbUAAR2JOQ7SJA3hdMXtp7mm4JaVnerFkBiUe9kdPVrkV05rrXTStqluKyRGkQhlMe/bOwwH4VbK2UsNWVZkUXVLW21TAUY/+ZHtjJo/T2rk6z3zlDRzp7JoA9WVU9PVV3Bdi10kY9bWvbD6sWgydeMP0HuiYAh3fn/f3F7W/2VvGx1n/2TUkKC87Ugmfk+lMwbppuCVIQD5RVErRiv8TfsIMF/eRLQC+ArUPhERVAjBSQ2uJKVxniK5ZjCVA0sYy44hAzDHFyXin0HHy4JNGLofTImRf2WGUgQgKv1BGHY/6ExoLqHcqiaX6lEvgF0RCwWy+zpdZYocjROycSSG+IA2G9gN0XFDoSiMXc96Xyir16Nh7JxvyOmK7QeQPqj3lfmC+yY+GSIZkshEn3EzHkm9KNuaHLyKv5bBpldhu7Lbncy+lmd5LDh/gKzqV58kiP5VhmVY/lomhhmj7xh6ZWCHTJp8wVOq4suRIfNhlQMlk18na5aZKdY8NvPshrgk2ZuiiPqwTLotpMCw39cGC0qGio9mWZFfPBn1lHv4AJel2uV5MGoatXvctcdCf154P5XDjqKWw/Ek8Uau+snOh7jnBQGnbpuRAYKDWtxaF6+LPP1Rk0oyIfEDPn+/PuQ8iV2pjQBw3Eq1mD/loT9BflxZBNtwJW3giuueS1LYGIyaGa/t9H2gxLvos0HJeUfj6n6A90LAj4tgy+UkHBsC66sl/QSU1kjiWcj3BEBtxGaC/VbRH5a7fKwKEOuIn40wx+K5AGLK47F3xCwZtBPyd8GwPiBW4yo5cuatioT0bvF4CSpsRp5zA2+zIBE9kmJ+pXaXf4jdgxQLJhDfNzed6e/91mxQS3vGenljYDCnu3erpqfNJXHsPw50cS969wLR6IzcdbjKQ6v+AjU/NGMUkoyNlNbu+nhlGNFApsCOaH0AgohjC5iM80vel5LaykJiwakrwiu1+4T9AYX5yV+lV0lyGdZj/pGX0rpTO5yKFobowf0qsbRyNBjbUTGgC5ivQhcbB3H2Ryvcq4bFqVq7LvXS4rAJZ/HtkuJztPPvKg1BRN9lcnU8gRQ5o/kT3DkIdW1WpY//72IfaGke5aTdzEIX/LpRYszjreMpvLK822fiH3oOLGx9R7HiPNXCml0xkIvzAluf5puFLzouSjnw6oHo7Yuv1zpLYdkTCRc6kS09ui3i+rRAvyvbXfzcV+VxH6UpMS1jfIqtnacjk3tJ17RXLsdRMBhhVvH1j085NYc9Zd95m4IlTkihSltftcsXhgAJ2cBwQ1g4s0q0Gr/wq92bgKediqwjYPf35rkpfw/fDI6x5rGM7rk1wP/wb+nNzFTfE2nVyqSVFEaFpKMHWR+LyFO7yaEu9ZXQDAIzKbFDgdv1CnnP48Jg/+q5VNdWyJLy3najg3D26Fif8qgeLpUIC0UbnzG+ZOt2QQQ2qYwqPHT2Lj2kVmMIfgKhYkAsK/4oto9aQt/VrXfrsZd0ZLtfHh8BWwDWwHcK+NjFZvTEx5Y7TuajrG2aRF/CsIbNgY2D5SPcL6WltDedw7sZNKa7a0P2XE4ZzvChb48mDFsL+wvKkwjPTiCuWziFLKTlvZZMSXHtkLkjzXY8zpmp4UvOdzR5QY/8Wh3+KskvSLX8319qRVRVkyVoN64pdq+MexMVYT84cjJPUMoVszIedju9U3NHA0WlECP0tvMYIhpkkpAGf+Kg3jnl/rPgMSKmNnksKyFF8oXNBTqGsfeN86XahCbqcuEQrCD78Ez+VFzbBxIJrp8rzFn3Dvs16wgTp2tF+z5WFMoG5mtC1gwbCLjPAZBOELeT7FilmbslnNJinFkENYc2z6GBmN9BGS60Ci/n52B8eUm5x9chAZrqGjDW/fT/Crm8N/Nh1FDOOh4DqWgYgkzi92objIAsvoWEKOpkSzYeoFGGnZHTd+wHlXFwZhnCt2w+KYYgYzjFd3nMJ46dBsCDLHL3Ie6RpB/cIK92ku8ZcQikycb3wLpPYh0z4E5p6ly9WxN0bR7Mqok14dZDPcjeK2toYG1UCaIwImY/dIU2s4DlFSZ9takRiNvvdw65hNLLEcx5rPNYFIgzqNp8wVEE3auAX+D82g6g6z1yFyodAxruOtT6XV+T9b+NNPvL9EHicvwxISBmCkDhQK26adypJhHiIc6IiG8YFHYq2niAs5k+zjfo3h5qlRf8s31XeHiewHzKv/+1grV7tkgZ6Q3QkFZfp/B9jw8Khv9n5c/nLJADH5RIEpQkT/6R/G2SymOftKAl34R0KdQcxljOcvEJ3qlCrmf/vA/lA+3ghkIA08hQXfdb2XYa3W7D8i+ezv1P0akBNnW89E55wKvfudbzSPheEyhgQKYjvpCh6oKJXIyLgOUDx2vspLnT+/hWoYpqjczrVZ9MMyr2DKRJOKNlotYTi4pV/IEjr745z81ekyZArHUTEH2YXQnLtvVyxRGPpAlr4yCmM3JpJ8wyTPs+I3+sGDnXxnjlVi6OdY1+F1fbKDV/ckeIt+lb2p+kU6e0PWWkxzRkYyQit5svYiY5N+CqfhPcb1MJHnamoa3+VFkyPt2JDrDJ/RdRKiYCmK3MgGJxhbbSJyKBL0ew4cgE5Zkic4Z32UttOgvT3UiTOXqw0JjFqARoXc4KuPbg9PEloKQs/qG90txEdC0eeW9nfsWZbY7bo6kf7RnXT7M3Mmlf68jU2qYVlZEIho7Y+jynLZuOiHXV7nLb+I8ZNy4lXwj72wUqmi9ZNcnK6Qypi50/Zz5PGWhEalPRQcTwJ8wv0bxgCA8PLLaOs8odOiy52jhc7WD04L9yP13G8hr1BSlDKn8cUdp94/u+5ukNTUCaD5dDy6KIsgO+46+MuLf+7714BgJKO/f+p9DT6bPuc+jen6AUMzLoB5xjMWrQUOAjbQfhqEUWQQ85w+eUpfh76ow7E10qfb+ibv6TeyBAppRN07hYJS3hQIU9fMUuhATh0NzzmR6vGOVkj9KAdVIQ6UzII5Xh434+6Yi8zpzCEk06JgiXN7/+12SOkgJXzrpSEn9AERXqL5jtvSnghB+dwJm7UjLFzDM8D/J85FO3/WPQzop54I3d4IWKQ1HKcIw0R+DQkIkInbcCoKP5v5Dd35Q0bKvSwkZG3QHFEjer2SUVhnd12ELyHEUOFGN3jsPhcirhtIJ0mIUAAGLOtlWe4EMIY4UVpvvAoZKGjkLpe0Hoslwl5hjWtgt8L33fpPky3oCzk3ooREIs3MqFPGSN1+MoSxzQCAUuzWoWRZ6kxYDUHIbOhKYCXPRXTdh4B9Qw8gJGMdMGZBga3YKGfY2X8A41NdSVpQq+jWjYfg+U8RDh21OsEUmk878/MPa8EoalJumbFy5I3BtyoniW4+5rXObsNpfHIg2dIZnNtkQ+j1MPJW/8onHHFC8BXMrx686zlvMHWYvv9EaUnghTwL3i0oYUKeAF0GXIW+SvgFv7XYM/vk3mXNHdUaC6wIByy0gPhVjdYKxir080h52Eu9NLEdXJb6TFvhvxLFVyQh2zz42qFMeiAruqKMf+C0QA4/4xBVFZjHbqVsjurYbGytgynhiaNqlLILU9odmRC+WQUWtJulmcCg4VtGts0FUIxPhA+WXjoXapEljULSenhdNu6xdud8ixIKgOXfz0ZsT2xkVeqNsrSGpDc/W7Yjmbz+HQiXUeCnEfRDDomUnspJx+WTHDlTyLxr9qi5CyIM+5VMIiX5alOok9JEHFnbBFWMx4GeA6/25eNcoO0yFy4BEbsdISo/P0DwQ7s9m0uJhJ8L1M1IUeimRTdKE2uOmptbRJKLokTifUz7f/jZeDPgMJOtpu+AbuGeNA3Db55eYZyKCZJXOEFXBULgIr1xuxnWFoTLeSVzEUKGWPyZRzvOSiSevfyz+w46f4h4VtBskXUNqrJ8jFFnCJIzjJggYs1610jEeUI7MsQ3HsmH0UEcTBcMf4bsC7+gdTMd1sZw2eGE8Yl+Yl1yR5sHYQ4vxYpGRcaNCP2/ONUIHQoyXMrmbGB8u3wZBCbgLELvhaMUs6O2lHlQvIbHR2J6JL5WR1Xmpa/QQbfbK+lBNw1uDGn/Q25q8twyKvrO+ueAz24+ByTkXmePSVgAiXsVd+wW0bm/JXMfns6Bj5wICWtr2KcDuMofzn8CrqkkTdulS8HBV4SDFRvUl8XzPbEpc2CbpVG1h3l7mjIdXvMjsBBRlNrTr0ww8yuSIzNS1XNbXjg3mAI2CmHW7pCpquIyx2aZOoMheSX9T5HvUpYF13yJhD5AbRV37ng+bQyD9pfBMLN2HhAMUwUKTaWkelxvh8EWksEGFS1aU9nYK7cAIYJRmvjjtQf9Rmc0Idk7LO1+TYZRabtnTu9XTZQsSOHKZVYduNCZsDyjAJxyRFyVUd1xqIk5qCVi2vQcnWyRfH5MM3uNdSojo9PzV+5YsIhwm2tx0agAphCDK6A4zPrMYCVSQLH0qNR2FB+GWCiONt2ssscDjIn8i1oVSEyCx6hOr9stv0JLEP3jf8SA6EUCKRMQBLUGMtYPtX3aAE+t2GDGfRI4sDXooxR2zZe5MRW/RLzZ0Kgo+MT9V3ITikS8Bk6GXS+/dYTsKrWHoOmodjzw+ajQ/6o7tAEgfQWvOm/N46wws6Ads6CJzhJ5O46lvW2POF1uMp2hBZBibD9DoSmxbFW7EX4Sek13PrBAeEEOtge4DQxVdRWLr8o2tZj5GvcvVV/aXyhRhiU1n0wndZhLSK6tdbjysmtL2LtLmLdW08tOGRj8QNdEmxDGAs4PgruZyMTXlvnB7LfGYRMogzer2irLh6/D6HZ6UIRIVL9XiVJcZOb0jybBDRO4LKUKibhYJUroc8SNYtjMDm38gRxje8/da/aW1vm7TauqhI4rqrg4ykF6jDcHOTwMl+vzTUE8eK8MP3QYfgN5r/Qp8tkLISH6Xp57WEA5SsWuINbCt7Bxvu5zRY8c4ZAI1OpOQUskX8DASretF+wk29LC0FkXKSe6YQ58dgOeZVqfMYS4EjXkkKS0bS1a6NJL0phAQkblDTcVX3tsNR4eKUKP0Shqfh0F6DMeK2/GRKtcuKAeYOMR2B8E16hPiSM6xrFAO0gdZtd5KRImuRYOBSoYpVqrxeeWKJtzuxzQs/fARLd08a15qMGyrs7NP/Qg3M0imOeu1UvxgZfPxLghIEPwZ5w2leGOWN3N8xb6r7lH+24W6LTCu1yItHQ67wz7tWxwquu5/vx7l3Ko9Q9WNP11d50yZJEpuyB+Q1XG9im0iE1W7/LWJ+rj+HjAad8S7SPcu4WamRydAdcwOy5F1e9d2FVsOshOH8yRxW0+5acAxj3icMlrmfcCdD0gAD/aLB+xLvIjXMhgModsKswWFvOPW1M+c9KIPr8K/3VhwQIlkquXAUOw+Qt1NrkZmc6664+aaff5/yqqRrmudFNvTnZwH9mi3kWADvQGZxgHRSMAskMTCEfTSplmj4nPjdX2msAW3XlwiNf0oOSQMNwuUpQPUu4a5hk+nLzMYasLg8pkwqSSnAbM8kT/bU8uK4cmE5xfah8cOJtvZb71Nx86vy8rGzSxgDl4+PqYKQm/LBHzl6halmijVjdwh60JGIduAuNKmSXyhpsDT5+vZzz2yeZbejCpL2sr4PUjYv8kX/hbiwuAYXPiFizfRbS2r3+63R1I2wFb8C+lWRZjXGTgMrgH+TIrKtg7xlHf6aZdhxq6XOEVUOCYHyrmV+Ru0S8Y8Wyz3kUeaKUnTkPk5hPp91UDGAhvMUO8D7G3WBF2C4iAfJ+5TYX+UL9Z2mOKJzGtbVmq2voZIqQYkO9RFI/UqsUDJQd+5n1oiYxzKf+q+LMIsTA5VBj6WPLOeops7GWyXuerjEb3lsy0oVnbMXl1Ltilas4HCb+PSycj/jtalYk8Ft+orERPvugPAYXjYIJ81BLJKepeGZz2qvoYQa0sAH4gTfGGbvdiRHRtfUP39zcSRAaQIxOz9FBd1xUZbqdxHAAjWQqIVPqtzeuHVvDJ0F/eDe3gVZavnxZY1ptKfHVS681NcXj689pu6fTlf/M0Nn3oDoN+I73o0H+fVv6G/z7jCkknXYPwypdaqFixvdSlA4HKQh5aT935dpl413EpvJTVDT+FLPTrrzrQCovKJM3dUrwif3ADNsFy6gvG5xmoZZ/LBrL3YnaMPe7MBeRM7oLSvJ2GlJPhf7w14pExe2np6obQIOo8MWRdgbtrNeVe++oEljk1LL11Z601GWjdOA7JrT3Q7DPJM4SsgjnWxkAhrKt21x/9xxl9PL6G9L/0X7BsYocj+3X1IJbCuC7sffNMxqkz+xcKMyCtng06lrMBGw9cXlHHNKRsIua+vMwnkpi5z6usgqgzhXhngWHudt02nWPBIN+XL6pCJ/cH4xnmiE5A4nBkwrUJr631kIucomzEm9/K+9A3uEGF6gwT0L+LFdUcQDH0FMIxVXCYsM/1vLqNFHWS6xVhoVvkME6dHaKitoSaObN4LrxHjrJcmuut7afAuoz5kp8xHnVvgoKVubO5zDif8niPWv1Mh3o26BlcZlxu5qJtY87WBbgoqMougCYqFOf2se0LLR104qVviKNMkm6SwpCZmaXMaqhGlhOeceS1XntfdjeRfPCJuLYcK0Xe/IlaLHedBtEY/e8WDF2Ji4MT2Rw8eOFqfyDs2CzlUTrqeIRYm5RMVU4v9r3xnjkwPAhkmquztPM4BfJHbouGk9qwpN2nhBAz6UEQvkLgieLa2szBBvPLUKDebsgy/hoA9zFnwoJ1B9GHOFvqVN13Q2KGAQha6wH0PiVUxoBNtObh3Yn22DE2dqNcUna/El+srwOtXwo8pNwU1WZFiBh2rwdnChCjsfRpjZE3Rb/GWU5dGIMu3guf2XMRUo1Qg8Mv+EKECK85z5R+5otttwdVQ/me2X4jnu61tLf2EgKsIEkDQBb8Sj6/exaZ3wsXsyyIvNqm9EwfwrCI3vmXiJvkzcuqfiTKhu8BGraiOfAG6qCEZle44nxxKI/ca8zaurubl4joKxpDyM7bLhA0zLRHYWBH7LGvs7VuDWcj9lX/6zNuhs/4qKaS5/mIeCUKVkOF5LLBic/3P1Uzt3e6zHqRhKHOJ5utyd8xmUkTcpTqgrCUdIbQWwjUHULapulm2yChtvfHoq9h3J9X+aVm3cnmqMMwrNz3bVtn6zAV1QuAuzi0sGiQeajh7cUGtr2Ultn3IYCkpcQcXXGeV3uzw/BvsjbbAdShBcetjXiqdqZvb4b86FXXIo0sJtq4Qo2SiZBDrsjh+kEg+7ukmvB5mQxdVWxgAZG3b8Vybj96FUUbOUiwaOrxQBq/3hpoThtgz8W+uuTMOQ+DPaPzQEZqIRc7jbNJXl7aFkP+7ySMe4GguoccqTLflj9OfIyBv2AkMTrpLKnK1z5h4tBnbqskhBlkbbn3MJP6W2h70QBRwbNCeZnvg+XQkkLqLZcRKrDQbEqbOFpnr/z1aumXuj5EPDAvnQc0AEfcgniOsoRjSC4SxuMExkZ+mCNhYzUoo05em/x5Cy6YhNpOloAseI6RXPmpzCcuYdKAORoyOhmAPAaEj6jyf0ApQF6l8hT/ZrXOJ7bqQLPTMpTFFTMyrsCFjBJUIIFGJNRp1gYCdld/uYJ9pSR9e5F7qg7cp+dRubn/CQLA6o7IxTI8FqnnIMxyK/jmI4+h05EwXa+/xf+SpIowUZ07JQ0Pxagz2sJkeyrL0lY09WgKb9oDMIWKZ3pjKFnYTIMNzNZO2L5U+sHTgq8L4rZAT6hG9KHMg+sVZIF+AnhbmydkaxviFxUJiPxaPAHDHsxYqpIznEVJKrQPx02PMN1f5HJtButrvMlKLICdvSptaFrJ8rVrX9qPZ8Q8buXmhHxLcJGy2/TQ/vePdRpXe4ocjpzBLN9vh/paZU3Mv7AJbISlMXEZcQvwwiV0EIpFbVYAwhWl+XMNn2Hq2i9aAUjyZP+K/DL6RUd3rHJ53oXixVJgFABINuG7mpYwu86taGCO1qpOnFZ9gLnlm+7/dZ4WxCmH3SL/gly4mWzWN61Xe38lHwVxGxbeppfVOb/5Cx9xpRafRa0QcIxndB4rWLnUiG6I+3yv2pzAFXAyGIjhUPJR1E/TaNELOeYY5IFdfYIC3sfDBuTWrCmfJgoM9sOkD97edqN5DRi6tVs8eF1B1b74Ief0vpmBKfAdkwlb5unG0kWG707QmJQ6kWPDtC1wmklCZfbz6BHAv3zyURC9QNloZEO85baQe+UUUxh2dyLHah+gcjPHnQ2m3M2SENZ/fJ6jTexT5rnEiyYSgEyVX9zx12hidWmc/L+6pyEcgRiYi+/L5Q4e17B1B09tRDylCik9N5Ti2XFwqB7oOWQYU0ssmPULSbA+6XucfZZq833cwoiiK211ddfZ7ouez7/4jQ8KvzqkD9rNTQkj3ipkeqeymg4lNIJECQmRQ5hTeVuS/RjZt0h2JQPOWOBMQeiTlAc68sIQM56BusdYK45Kv7748Gen7dox0H996lWbZvxKH9mUDM8AvYoQNzZyFQYww5Z/ENBSNyiHe+eMbelvkf6jDFw4YdNX18E1B+o+YEHahwQjjxBc19qFjn6M9KlXegFO7/ih0Jmws+ZD9AedT24cekWqGAY9C+2mplG1qAIORSxCDJuLfvdraFYmt6BARmDz0jLlC7Uh6FdWeW3PClFTwmFixARIoINc6ZFfo+O4vZQ6akH9GFlykdvyN/HcvmM7WhDeo8xVsp8I/6F1C+5QpciJmKzCK+KDXogl+1OhgJkTwWTWRVrBWzRtsI0keBfQuzU/JlbkujTknMiucUzIv/dwQmGb0yplhBrKogD1d2wQtvI903s3eGn4Y1HjIGq9uDV5GDYBtMT5z82Nvsmo6Qyt9TTzDsHUle8KNRzLQkEtThG2iukNuiFozVRyjlZRe4qwINvx55krWMZ2wlKUxiHMwflKo36rUHbWamLHkvEVwna6wHKax0samcXD6iquX58LmzSQiLGkcbv85K4/CrLDlctZE265hIpo13zGdrUvvz+YDNigJr6+VqJFLuQxkyNS9N/opgKg3v14KREJA2WBhP394rJUQExxI8yGvv6PMa4EPu8azpKsXiyRM6KCL6ShtQ+2XkR3KXoOBAgrUC26pUJGPw8SCF19Fa8Ca2bqAp7sQidoN8UgfHcfameiZp3x0Va5FPArSOs1o1V0NRmdtH7vCoYbrr8v3efB9/k6g4XWAKG3lJXr6ZjWlcrCan1p4UZQ3GoDgihAgwPVcGvIyYB5oBOW20rDM95QCU1vvkzXYvmdK9FlOYi6QMBHeMQgdXQ1Iyzh4rDPvrvwBl+PpCmLiZLtz5OLFFQH74YXXXoZRAdyB2oQz3rRRFGqk74xx33wWEBEYaOH8jG9oA8e+OPl8+YShQJdZF3VCKex8z5dAL22zsq4wTc+blcvd0ulGV8NWAreH7T+ojvPTD2k01QJfAk/jcKB9enZ4AVQCjvQBFIie5jOrJdhyw7gvazPwSS8o1T4MEQJvUiklr7e3iGeI+Zgg9fXMTFiB+tHQEK1CC7TLuxOub93RBqnZYLYTGyGs8QIpQi2g0DXqhLdDYyV53x5czQifG06Zx0gDS5XkMJ8LHdQECiij+6cpkqeow7Qr6UmBidKciC3Oc/2do3T8gWjzsSoY0hmBH/ek24cuFi05YMsZpoxwknD2kUeRp/3IMapg7yXfpeQWxv8eMeeBt3p+L3gO8UQPLyxrmqA5KZbzmXw7hgNR+MMMbXvMLe/p0DLSfdbrrVAt2oUmc4LmsOAzAFtIpfrTeWt+hRmTC6iceRDhlS6KrF6dvwbtioHFyXqFDB/ekYiINFyXUwUu3I+H03AYuEarqTsm1Aebxk8EGIh05fNG4tchtH6xg9cQv2f/HEjhZMv7Sj9iM8T1UsRjLXzrVAZ2C8FWIZrlWdTwrz9QqxiEN4cXu1zjiG9NGU1JSe6oQEsURfcmP751PJBqWxqcBwuJqpxpgynKZfTDAJPBHu2vyy6D1WeA0OCK8nemgvzJRKKo8ngxj6JfOCXnAT2gw3RyLgCGK9OEFfPDSnNyZhaevdAjk8lge/8b1koG56e/k/F/WYtbdP/3GROF45nqk6or/eBVFORmzFpEgCusV+TP/xBfGANkcnzsB66YZCwsoQC82TPr5R6QPh8RG/hf+aP3aVvN2xLav4lYmrusAujuSw+9hAu16bmhEMUhJIT2XNriHarpvVxbp2VYODftoZalyoIG1rgkDqRrzWBTXl9RF+sxjGxgArAgtQ3/Fmk/WOOCiiT4d2zDaBWCszcOZCcYBDOjP/zJHtz4bBC2habv6kxyUiZXlDQ18v8BEe/re69LG3prFQFw3as3yyQJ0s4SBXuJJBasuTYipzafO4d0YysNx4TfOjYlUDa64Q1Q2yvDta5Fpstw29Df0YCwmns3OEg3bGb/IqXfj2W+80Q8vm/JtkA01FAZLhHJRIWZR6G/RKZMYTKmU1FihyXhD8irl9tN1C3DSK+Y+EmqSb9HcI7kr0xjqIPeP1ZKjacF4Fv+4Ui8oyc7W7x8LKkBOt9NCA9rvO+XcUiDjHPfG319LsQCjXT6t04hzFjcolah8SI0KzldVMX8Mj8dW8RcEPUTdwXtlF3CJZlS8u222yLuJHpCMX+9J5pIzXIGtmScDDI1kh7dz0Lid08p065J6jcDU5sxZu0czvrJHhAfQ9mvYPFcMFilpWAcXDCrENYkwarTaB42splwGMn1j+oeQjU7zEWSBGTV1oaVcMylWo9ofKj+b6esfhiL0//6fsW+220qHPNhWp8/Ln4r0NdYPeX0XWQlanxcdU6wePA2r8HprY59wrrvE9h1u0uSxJ/Ip6NYXJ5Emem0uLiuwqvEeT4m1ai2dKfXHzP13/x2itXGccm8q6XBH8s3Rv/65e+IW/WX4ZJVSFuPpGEzVi3jqKlzwks4/vCb1EUIu4EgZjyciOTaP4e1lPPIa7uPiHDi+UJXx7gdNZk4RCuWec6Mfk32evtiPkf309DU7uaa7Mf2M9znzetULy5mmYHe4E1tCl9T8dARb7UaT2ku3I/8Ji6OooyxRuKu5mhvGy0sbm8RR4g4uV526ZisSnEy80QYzaguqh3pfAMwRsOkNpb6wtQVgwCz3ctXulJwEwJqsb53anvispD1oBwOQVZGR/+Y02F/AkyB5qC8Uz0rovIOflxszHeMTv4gT7gYAcckK+E+XCG0ejWqJIa6DM3DM+qkRlIOJPauMMVcsoD7t0r8fhlZqHE6l4sY8bl7Q3ug3B5eS4tfDyEf1+5uhjpk+ElwPervstpdF2tlgZjF3eK7I3bc9zNbuDys5/RHxa32tNzHOidsO4a/DGi/blHbVG9NpQU8vRSLLcjAWIKsvQHaVf0Nv9UvzEN5jzwj3GEIF1Ce3uYYmNkDuytleDsl7MGZPfK4Q3BLHNX0e8vLRyBFczCxru+NlgLrIbCGhCwmT/8taO7ji+ncPBD2kCcmLi+TKeSIDYaX8mwtEWcZOF0zZr2x6ZHDEehTExTuJd1dZlZ6YQO24Abt1fn8Wb8SeLV5hczNCaPb7DIq6rxB/i2ZG1LMuGGlLK6tcgOR8xei/J1KJgtdLhKVfcUDXuQGk1vwvHG50SSYIdbZIEfsTloicWykDrlutLT0ypNWy8JPt6Xul4Enr8hoG38E8w1JSgop/n6c41pdWteKay7jzAGkR9iOgnan/KYA6o4A0gO9ZNNo69voDvbdLggThZcHAOtHM3AU0mg1zQD3jSN4U1sidVx0P2l3T1oMIidtsjriwiqSQaES6MJglsmhKr1NxrQvlmAOFLL8n8dp5pE4cX7q9MNy0HVB0IlcemxLdX0X0jk54fda9x5zm7cYgo7f4sGLUIR9e173yyOF1IdKc8aFaEcfA4Y2CHNX6bzhTnT2BYcioUvXh7kglw5cRuVDch+R6cWGgf1I/l52i1nu0gIlrOJHs4USasLMto1bKLvvtBrtUCp/HnLfWQq2a9jZ4wSePTZZ/WrHrIxSkmY+vXYVxNcDGUm+Yfly1bDdaKlf4ztn7ZJh0e3IL2KNvw2PW9w6y2CdxmikI8xIct5+a05gb6L1d76CilxlFqqMSurvj79EiDlIZXIRf3BffdEVIFxs6vw1Ju/8sbzc7FPbVIryvWabzfHgOE8BCc2IhJu2K7a+5uUHkoIceFU5LzHYt7cDD43h2q0+/zMp/F0aIW4em3IBDAn57kSEYCYNPYVksqgoxHPlTrzBU5pU3zsffjdhhzvNLuq2pY4M3i2oPiXEpjIXJ6kNqJGqmbAUzRW50ZgdRZf8fGcv9/1fohjkmljMQitP1yavQ1ekpi0+1Q14tvgVnOkhlYTM3ZYhrBNmLbw8iEIXAP6oHcGo/m2NYsgh9tf7hpUpQW3JHKFEtLChbRKlucEXgVcf0g42gducMdWl3WeYlLFqxYOD1uW6H2f4xbYyWlKm4j7lCVJy80K67Uj0yQJrfiB+QjLjJ6/FplpchtYP1SJwIjBoIai6RFpfQVXorxo8ti8PFZLsIbh1+VNZXOMYSal2+WPLYljNR+cEfvqkTyaK3Jo+d0/95mMhAsUolm7KNKJzHAgxx8snO64+Gwvi0gwrYLzjjP1HCNYGLtKuupVqrS/SI0vQDDcsi5Ebn+uPChDHRHK2opu9MpwJ7QN+kho2OwRlM7ryY5VOFRVg1xknj/cKVqXWxow0cLLYebk4a+S/LLeSaQpwMPglYOSjMOVVPKXlHo/f2L6cbHinh+siXPFWE9mCLiqArKKr5u0wMNo9LFzFt/2aprfmJ8J+Hps15S6mWwJTjO9CFgxMW7jUzUpibvI6wSPKd6rbxpdQH5LXYkYQVthswxladCHzUf+EZFQ2wU0eIjtX4pC5EBhnu5M+6RBAXey1Eig82QQmM6rK6KG+wJnH2aAylaTaLqPtAAu3Ka7vr21YG0uh26IKUXp/P5qxYcNjbJ/8ZfP+QwTRrVn6jfG/7cv4EfRNbZ65itzR3RvGxKh+dJAQXc+xpAiLB8oU1b2ExaoSRWxMJYsEme6VLWEAj8G/RnHY66fcLtXeiXg2XBbSZz1eIJ3pug3dIh4idq5aUWhA2kJNmBsoybL/NP3VsSYX0BWhCaD+hJ44OEfk/l9p3EN0JiAUda+DWFK/arPhTmcHBL5V8MS08TPiFEIbKbOS0Ejdt0zSl5u1TyGps+yiO+KbKLXXAtc/QuUOtSjblQASpKU4bWZjSOk+QKpVHq8pAcvJJb+iYbvpn2lLkSMqhQp4CxXbD/qSptAKpRP4mE0nUNo+icxdvJI1ZTctvARRhSxnCOH5MkvzlPh6OFRLypmMCQo/vhBJVqOsHh/RDpfOYwARrDHOhX/DKFqZ174OYhvQykKzy91Yy0FP4rwF+6mZb074AhRbdZ0LRB6yGbU6Zxpu1CCKJgQRRKgJrW+DfeArQA1OfT34Asj2WD6K7D1RknfpNcl1PfDU4gJTTgF4ebbHRScax2eOlcx4KNjEX1NoX1Xy5P3B521gY39vilCaYMl2HmN4bG3zVc3yLCiGWpZ7vu5iWEwdjnIrZeX67EwQiHqVoFB1SwjP7dxBohzUOxWuiPBDwubkAmYuhiwKyxOgidswZqFO7EgRouHMjgtuYR740FsTjY+p/W3uiZd4gV+Pgd7yb/nSVhEXh+1j4bHYhHvpt5WgSux/tYSfM9qoKxvR17Ro0lO6i0tjlhgAOp8pFO5LITAwaj6s0Fq3nxejYDhLEtnrMbeO8nzB7CbaGpOwYufRdrnY8Z0NbHAfT2NSV9I4c74wVJeEy955YIS4z1So+HsBYjIWgdZWA9qT9T+EU0LPcCpZW1wkj/mAQPfmUIyVKdqUD8aNyc5bOVrj/rnF3A59er+qeMJbNLRhIVWrDsG8PHF5p4GvA59jJhJGxxvcPw5O06PCmtf6tbHKDTDAlXRp5iMRWzdloCfp740bXR5oghScDmoWFlT9Q4k6YbxlpzFSomA5EbGIGrd4Wn8tvseSlqHxuwdz51mX7c88RmIH67k2b+zBDmubwcm0ILjktsaGuYT8KAUDlIVKKi2bPxKwnpONvNa7wfPaFZ0WQJ0g8UfdTZFyEPAzBig7Y+vuQtTTuzgKDaxfsfUYe9kzyZ/93lmHLr3ZaJQ2TOTu68aNi5ibxMvuuDOVvljEEPyuaQG2wXZtPZedLT9jXIhIX1vVism84ASa1LP9V9H8hcNSAY0ro8Ofkxl/WtqhTJHEY2LjxsuMS48vO9pkeqTqKr5y0nhEJRIf7/ytVtujeSCKIxCjsbz7/vOrbTbSsx3wcsqdDHYXfJ05YWaG+oM0PffVVFJfnHZDKksaL1cg4MVMVzp2K7K3YQ1Q3jbk5w7JdY6WNS7ZrpHegVe85V+hhGq5L4Oyyo2uOr2+ecdw9hCQeNTKaHHf1vGCrWi9QmCO/hZvyslcrZKstD9A8+pJhrpgM3i8kOZuFhbZjnj6+5mJgFX4QQQ8PQybNAPV42j32cKSbq0BEjcrwJHQNonULbu038PblJhVJ6Qzmv29Rks7eA+FVtLuWXF35AnYo0iQWxbSLMFWM849Q5q113wnMrq+/oGN7Wcuch7IgJkxmcpe6pLaofyiayOWOz1gDKFLxwycL9jgPRp4aF/rlVQt+ttaMVzWZIt3+2ZlIvNzaSMDqxovwurbW3gDTaOJ8QopOEdlt4VFWhKkSH0TTsLFmfjRxgu+nxsOCDc8iV0mCd/yfy445l2lKzAIt5CjL7hkJrrRgvr+8vvFRJ3FYPSEWhNryhRYiofvK8EXEQH5C6M2jjsXPha7rDdezIzOPl7hcp90r1m9yrlBk6KlInlXY2YcnYmAR08ankQIJ8D2GMxQKa6Xao7pZIgVRCl5JfGUxONavbEQfxzp0V8k0XIeE8x/x1bPuBZXp7RR+SyMi9MxMkZRs30pVhKQAzuywvG89HB6hfq/VYLljYsCL53709OgYVZ+mVu0qILvaXsZ4Q4Dsy4W8CQeUt7Jdn48YJt0CACLgfTTWRn7M3AUDldclaall2jFiKEBRbkz8TJOryz/3lVyUtRiyKqY9IHsxhXXYVgZwIncmNzHzCbu80p6GsETA6iPnqQlhsvAbLDwjSdI3XTIPKNujcDVzRAgl8T9NnHdoSij0R6sbu+GtZHLLRzUWRsbd27C0dBkmWziKDqTAXeCDlr9koM7RDHCudPboVQCBFFPNE8fja80JfzVnEa8L3WhV6qnadxBpnw2vbPkneLaNyjn7ACsKbGMWWRONex7k/wCTkyd3NVlMAK37KlLN9AujfCuu4d5XzZmPdP0eqnW8u57myHdyjD3rY+LfbP4PCWe1RCYNjiVXo3OvmIZvIdwJF+q2GOACk0drMGZmel77YkW/ZP93NKMUwI0V/NZdabTxv4ENKt9gsJ6tJHB+Mf/N7W0uigjbQEeL6NvALDplkPJXXVUn+qznKKUv8nKqXtlRaHVNGDK/YmZhUCdehG1MYSuF2+KhB9GvC+7KQEcL0a6RjIQPTPPAJrXqwjmwXnIMthmDdXB8ZPuJZih6MyCd5F1dmKoCACUskKIhQ1I5dvP/bpqGHvzmmswQiFgtqhhXlXF73+NU3HctSoDZwzCrDXJeKe27amJtAGbL7CN3NaTbLHmORWSxQJMPqCu7YrBYfy7WVNof6fg6Kwf6BHitEv2FfJRsk2vPXXZw3eWZEpQCuCpJBUNBqo0+bOyboQmc8N6LgtkxKDEWGvhB98xo0Tq7ChBsLEay5RTB6iByj9J+pt81OywuUzcqlRHE7OGDfM6n8g+FM8PSky6J+cpEiHLfuiTWGasSIdUVecxKnjwU+T0/PToNNT29/PRBo0DrTZfZ7VTo+ayKzphHwNAFNsgJfNSe8aO6fT5QukC2xWiXKMedgCts/uYxMWFNwBrfsq9K/RJm8xcKEqni0FCijbrEfVKR8vxL4n0aVduvELBngoYdtg1RvZnB6rtnhVC4FCzywS2B5oKdgRAzoG0xLGZU2ZhsNylSfbAOyi4A1gcHKlRxxXFaK4MTGTjHjz6i84dzg3CTtdzde03CVE68hOOi9Yw11IKIGgbaBAhM7n47upV8U1XNnqwzGkXjdAdGbPL7c+1Vltbi4cDMhiPjESbGLPucl8Zq6w1zuB89iyUoE8pn68U1wDtO+CN538etzJJd4cg0lFdctr7Snp7a5Xs8IkCum38bWq+BZTBP9aTPdqMvGVTRyY+lYGokZWSAhFZEpZAfqWOq8VsHWBMZTqwcIX70VJkcxucXAG1f9nAsX18TYy8PCPq/WYTiKAg0r/3B8k+1ftaXRz3rDSyhEgy7d1Wbl72TzNzuRh3nABkR5XEaW8p/qw81RfJT+gKTumWjIdMQnfesgHoR3/yPtOJCHa2V6JIK71uNwr3zfRZFVMfRKh9CBoRPSnoaCfjm3Uu0HaU7lr0MBqx3DOdc7KRiRr/K8/TWqkqjII74UqpB8c6mdo8xp1T1pOMsQaTJXxLJzd07xED6opKJF/RGaqQPRcoQAz9r1Zr+raYHCNNTVMQ8xaFmZN5yvdnsQvDBain4V9iXR9Jll8BtFYQ9mROnR7eJHnGbx4zlkZxxtkAkTrS31CO4COk6y83mNhScf10Yulcx2e3Gn4qUO7dbnvshtO+mQ3OE7dZGNQkTn5ohamh81ryY6lOHBs7g3OFVj0XkPYnhUNwbPYM7TCsFdq5bR9OMRwzgy5DP/lh9pGJnWjDZGSYrubY4UUMNYZ7+VdjL0cs4FBUqiHkQZ1ESUpQugKa4XywuK87jNoI0Uw0/NmVTF3nKX6xtf7mh6wVKYm/0PPzdA/SRYl/0NyofC3ZTuzQ7Oi/DGm5TwB2yxvvpgYaj7PuMEAgu56PTFDuRRnufgc2zcZ3WE20SXok84wZuUb48Hq/563i5uZKiwo2dlFkG4r0xGaYmd0GsEdRRFWG6fiHigs8jnHyFfmbxUuGyqqVDVFhSkm/zr0uMTIIZ2cR02rDKG/wlJwnYdYlJtNqEopDjpXydOzwQtKEmwi2uwzQESCFyO4zOJaPQCbiK2S9vU8ZYFOUzcna7zELlxPw00mBUy2TGA/WXh+4doO3ZvYC4oEzLAnOaE83v3Swxc/cQnkffNdmSx/Pq/aSm13xiPmaqNJnN/1E4CGUiw+RJsSMsOs23NXRTke4eXYT5Qr2w5LRoOyDReqCQ2JC0B48eTKed6SIjcd5MabMjNtBsB4o7IEeFdTGyvM+lPNclx4jurBQwvS3KLYxfRsneMdGDA9C9Ovxgg3vuy7eD30rbs76SQXSkiMZEeZ9eNZ8XGsoyn+wwylqK7deWo34aAjFuxHibKysw94zJjaLyEv+nymvhgGBJleLuamtUXuAwFAvcNhi8uv1alO0cZ8bfc24lOsr8zteEFD9Krc0hhmBkmPevKtmc9UA4kRuDUqy7FFJxE/nMAutn1vKdZXYMbR+lFPAZG+189ce4VkeXpkqs7B/1BEWLO4D02LRgtgu2Ei0eb6822o1h8yZRV7+rscGRgeHMd1ckHy2EIbBInnT6+yV50tvS1Shomy6fxIAwE6Uwo5WQ0iTtjcKxA79JmoANMdX+WiB8XXbzPb+L6nt36lJyPKifl4gDAQtdOr1XKICXKu7xrQNx7TsR9NIAGjQY6LUAYhOm+UFARxFhvv4FiyMb9Nz7QihcazT1eC7t9pyk4b+EVrsA2t7AEEjlCKgdWKXpsR0y8zt5DrUAb0o1/1PzLCQnAgQu0ouD+IzIyG5tQiFHAgGb75Gak1+3YdY72GXgXawSmRiwlgL9jLCtbZ+zEBayAOP0pVO6oHBLzrxcZLafV1KykbDrQVCJcZNq9xuBzDneA93X8uFQWuTJU6TeWGn/NDWCiypVWQcbvn77+M0Ilh8K4oM3jkWkqKtm6dDuV2GXyuV1mPoe/JsC6KsJKxg5VItXE554YVxZpLH/W9St4/jSATpnKvAxKML3Cy2BUt1BAzm12uIpRtwivo1LYowBnZwedCIukH8S+s+QyhkjJ2e+hrqOKIB7wvhmVDs+rzWCOKDSQfrhmrdL+wfoOvRKLtFdQw6pXpwMTZn0OBn00hMV5xG0uQdY6rSIPyiz6lfUKhqo7iZp5TnE7AUHLmP03kjofJE42rEqNm721wG15lUKvGkvWQLOeF41fruKEdcjdsxyITrzq3EnzOY/g9iw37CP3p/7kfC4uIlgi7hbpHzbErrKPjlnvj5L3r+18b9qZAAithzXGFo9FELaij/6D2WaEWK51PRwoC6s0DVIKCevWDbmWEKBY6Gt60q8PKwndso8bcl2m+DaUfM6j3cRiW5aznd0RZF4A+KdpeGUWOFjr9RCiIp1UQODNm8tvkhDQQ3DZ7VQJvq/WB7c+AyKu6GZ5o2bDbYf6yA3XNT+DLGaLJEgPAa2o4PfLhw9OLoe/6qPiBnTjtXVzWeLGsqzsSi1t6uCMw53aPofH2J49Eq7SW2emeS7+AbbTRnHoQeC6ZpHG4FOvqPDtAQUv5VUskFxlXNMWrofQmXm/BeBaIma9JvpCS5yg7Q3ErEsCu2AkRfhbuhWoTYc3TwlvSDS6dxmz8qMHDau24dlPRAjxbn8ZKT9V7AmgmxnvPbDv0+uKn5CKztGfPT1H0B0qGhMD1JxBn2cKcvCJgSz4/FJvM9yHyCWTW/P3S4ZHtTBTU/oV8dSpFxQ7Z7cofmnyO9lCBvidMgxcO9QpGs39h0hQf/2MVip7e+coAgf9eVRT/BqmRLo2E8bJc46RReUgwXBxTXx0yoQbIvOBeteWINH0ydrZgE0FMTIhUFjt5o2+NeA79FIBkOGe7ANTXqEcHhteLExDWvJlh2E4qAUIaC4M9a7MnvIvPxdc7BUrNuIG6+BakgjGxHHCYtYmpoIhKkktOi7duRZpG7c2ggIhu9IFogb+bwR5uKx19ue9xPiVFRQ05b8SQEmGbIQ8Szhaeia8kWOfl5QFmpcQJZcx/sw6WpQOsYNNY4VzlrF0On+NgmLYABEy6kQ3DYAPdVJ7DK2OKB2m3aFgckHwRfuZ5QbMiS9LM6scvYydVP/T3/T/VT+S4LQ6vyjyZ5BG02eU4N2dksa53eXGe65wWKQUmzx9ax+Y32Hj5JyePDq3CLtQQ5DmhOsQ6FLhyKkQKtn+8GMLQoqS+9uXZsR3hml5OTO9dzQHt3GjispfzFJbxgr2F5AydbkpvMvCzghzH3AVZg/8fweh+VFmTIFCvIlM+p31bslMktIqPEi5pZ8IUaq4M4ua1hh4YGAPFvVmNp9RduB1oTOr8azS0lFSWLlKEWDFisovftiuR8LA4Au3IgLmUD10NyU4n6ZzfBFXA1k+henwePIJvRFwC/mslNPB9p1yWWA6SSbNAGHpOnUf3bM5gXSjoqPOL6Cmj+jLweT562WsTQPEh6PvhjevkS9fIT6Fvv+hPxydeQLiRgrOGfna2isKiVnK/1A3AUu8dCDFeF0A/taF10PTCkXA7aeevyZlO1h2jHSxOhNUu/MGKLb1YyEqNBawpqPjGAo46ZArWKSB4lJ2a0Fu3CpP6QLUmDpenok+4WHm/Ub+r/vuxEzCuvl1cBmal7BmUr1bhwbyHXVTLF994HHLFiNrgDkA8+3oq06vh+2UPhWLKMb/7pHpK/ur/+i4EixD3jsfPaOm7zLMzDTMl80ZKdHXyvg3Bdm9A7sWPhl5yGgmZ4//NWsrfo1283C4mAZOvR8JIuYK0v6Auf/qSMkzfERSbQWKj9Uy2CSAtnWsq8ENqHKj+pTiWeY/pP66w5326r4VsKUuUKMlRRtqQmtP75hxIA8qHxKPd952jTFfa4KX/bxjCCyQwuIcriamK0g1zmXRaQORdmsaBJpnLIBz+gXfA22Cbgro9pahlrQe2GUVkoERaXbu3AcVxtd0KcnVGEbOqSA3aFmL75luIETLnd/ThpixMbEOsJ7P11nlrW6Ng5Ld1IvyKpCv1cVA6CUqNquBGTRduFqPSnlqrcW/1todFEuCiwhX0dhn43OHRokndN2FxVsoLT/DSx9euqacQGC+rEzcCqC9Ba2e4Cgq5ZJ1K7+Tz1+inOdqImJjwaswEu8zFzQ+zt11udlQwbNseXS6oOB7T05AdyaKA/dD2uuTNQkbEVZ9XonT0meqK9/LD+J4c2KewdgIumQIwutuz6EB3vLZIpNkVfXhzpFJIIo806Qi0EuHPxnRaYpy6Jz1erX+IhDBv/VIW/RjIRaTQOiM6xF98+ZNwG0oOyvRmiYLbOZ6IK/h5T0mcfDq7cbtztUrH6TORIRYhFl+PQx/SflM7b4v/jvlwvy7c5YGhDjQ3AaJuvE1DR6OIrXONW8xT0Z66NJ0aYj/l9M4GYfCaFrxjdW6i6nqkyEUqqdXhtO6Xk/83pwGEFO21N/sQq1NZ+y2bNHNJX8e0FUQltn4muD/8f2XwnndIPrA9qzfk4S0XrELAbV0QOmchJUrqdcf9/bREQuecbr1lTrXUuInF7cZnX/4XAAntjkTuETTwqM5icdgm1TEUXSxBBaYZXpOSlEUIRnOEa47vDsoe51IvuqNcKuK8vEajzCHZJyV5OVNzb/4YOWkuTbeyc+u2k0P+tXPCJsUuYIbib4BqyVpVlcu1YUH1aIaPiRixn/h1oRUagMWsw0YTFG07dKg+T+uuEhkHRpw0Fxw/DbjFq1Ef+dEQSKH2gB6FOA1Dectk/MZk+GWiY9eCF/VoOTxlHJeMdcB3o+Q6Q2PwdrhaMVUmK8BeO+dmehzmKevXSsGJapRG+yoQDV9GEqkOTU/SCOa9HgBhPyEXtB/aCJ1eEcmcIXxiK11v2QJTu86TlnXv1EwwASmvtQlMgJqlk4P+L3YPD5SYjlDF0PjfD20QIyZeFhhOrchaDWG6OoGOM9d6dMRfv4BVx2pMrdzYC1jEDtJFdW1s+jzd9gfKBGs1J0vzuZryUBfIHrh3atE0B5JSw2OU70LxBlvCmpPuJ+fshigFA2SpFwUO3R35m+zJZvnytc4XMfBnNd0RFfnKPBxOLzif1d2rBFRVbjC9S32uIQBVz2oIB1x7fjkOkkmo1/2sujDdBc58OUQDJgvsApQOFRjxFpdBq7pB1cPzCzW6k+2js77naInFf+lHXVlzWQ/FNLl3LEQxfl6yqzUGljbK2/425+ShWeUmLwbcXVItzTciPYYPcNo1l0y3u6VjwZ1RC8mIGh/g0o8KvPLKHJMFHFUZgTBTWviGZzryQmc3neeUwKk8fTXIGQJ3qsmusLYod06X5iNlSMMl2zI5ClqwK4PkpyyMT4kArqd7/a895tVmkwUiq9nySuJ0Lym124+/lfrGnLHY1VQUaRdhYQaPvJ55bZ1f3dYEe1LSncGlW7tGTOqA0c/tJhbRw+ATOuOogKF+wvjLmilP0YZOsRzMYNpZPgKsAHk1IIcptiQRLAVe3m17XL35vIvkWJ09Ua6be2csQa8AQ0KqhtEuneexkbkASAkb24sO8L3+v0H6YVfVZw8UsmzFsG7syIMS1KdS0+AKqd0WjEeVSp+80ukeHAXavVZu7j855FzlRFe+mTEarjARmilXSUkYlv/3rW8a9H4NsSagzFiYl1PdxmLEO3W3jPhB33qD/lDLSKh7lRREacPVfaMuSpDny4invlWI8zcM0hI+PuOQA8p6nCtvUWRBpG3Q1Olti+bV6wRyPnFVeAINzebHkYG1qOtm4Dvj1SPIR/p5sAAIO3Hh2r2SrbVz/HzsyN2Wk9Ha2kU9YPyJCODh9jR5FCzFBsw0+I4dc+UJ8xDmZItuoKqdBfNzmMU+CwLhK5XBLIpiQOV3K5Q6I3j93V1BU62dQnLrQrJcWtYfrz44dL9CdWgF73Fw2mM25X2ii3ChjUkVHImtXNIfF/FGWmgd9oVU3R1V9Q5FyoP4kht1sqwbIDEfcceHcG7mJDS0oIgWHuJqfj3I7Vp0o9Y54WFBHTWhNVbBAhIqo7wGOOsePKPY1+PLbWVs4q0Y60iWlrWFO9FlnR0Uk1A7Z0pM85j/Ki2y62X7uNfHGjD7uwuQIgoC07pLw3wQKWw4fdzOA336dcTFk035RGc11ZSQN8B6mwRzxImSfGkYJWrqC8kc64rMp8I9NTlMfyUuHTX0L6Twpdo5ylbMXZiXNNjuecX7m6E3FB188rTKA5DWkMmGt2B0zugn0CE4vgWJwLmUSOtHJ11KNlhUW39uO1xpHf228orihD02tb3aANo3kAZUhVMhbsin+ThQaU+ow3WDH3+w66+7lOlSC5x/fYUozLLkkNH8ShX11aoi14bADLM4XdtcjVHtA/hbP0jx/IZvPXF96IprKTsGzAkOW/o8Y+fmG/38m41+KCihX96rhv+TLUaOCELoToDgN3jTa8rPJ5prAG8FZDiCIbOLlOXxVNgX25XppbbTenb3JbUJVkQh2YxEn5q3fIaMezxcUyEfsYJWl9m0kk/Hx3omwcpwAjDdh87kxHlumSkxf7JVcljvb0nIup+vMp8cu8NMOV3WT3e6/dU3OOApxz9FS/ln9HST2ZC+EznBCYyaQEwxZBysf6DaDqTeOLBg02CLwlaZxMQ/7QEFNAH5fGcuFp74j6O8x4JcA6ZeCcngJatlF8wLYkB+eTKdZ2/i3cfh30oSaTbULQ8QPPi123U7kFCNWbs/2vHloq2HXpmxzjTjpmcJvi/8F8/x9yXJhlO5Hq4nrDeSd7UMEB2ldDcHY6AzmPtYeiOGGQIgyLXi5VS3Um2QpguKq6BwjQ/1sI7/84j/DIokEotPCLRowT/V14jA8b7WNHEQrHokUuoJU7B6NV33LmADxoMyxNHN05wCKRVvE5yazK/3ubiUH/V2E2fEOicyNc923VsAgKh+/p8DpZbRc+lXMqBLyoDqgCyvmwItjftUeiPtK9HdY5KPnWFnPIgb5Ytqe5GWQJpmbcNHwz8XozC1qZ7UgAAlsoW8JqqYjCRPGAwaRK+0LI5gCMeQzRpcc2qXZfypzahjbmS2vZUHgj7ACWaWYO8/LOEqoea78xLhgbWS7PC5XIXQt9p2jmye3R8iXcYxtq8T8HuDfAYe/k/r4HjvtcHQ+u8Z5WA1/M9BVWKXilm0KCu3KATX8bBgi/IWysn0RLKasKDdp+2nb1pFr3yeqwZex2NXwt97nEqhuPHI/6Cg12IPk7rYSl0z+66GUgIkI2i7ZZh1zRjBiszex0Zf5jLgEyXxbvMxf8zux0Tmej2oRHHoHuE+MagoJlZpoUEXulWU+tn/dhm9rqSwntDSdTpcXHOGilKGgL71KEhecwX9WkpJRoXJSUtSu/DJwiEYEfq3HtZlFzwogvqByZDulhyGp6cm+qD0OgvQVI4r5H6puSepHDkIvl9gd0Ue10s0uKz1SAIkuWOTDfYw6iMyv06avgpCWiQ7BRqDB88xx5l6dpnfBIVS9V0KjZ4mMfp5LYYrmCj6Wuy4JNnW459jRH+vFrsGOJyFJeZjrr82s6scvs1i6NhCehZgD8m2+Lg/r2KIF3Cq8MZZgpb87Few5H4EE3ZqOAlRel9Y3OcdZvSEcXDoVH1qhGAcM2U4JaUsVO/fAenlZDtJnKFoEw/ccC285Ynhjg1An2IqzcDh08NLLy1NzQqtaT1Cg23vut6c+QChSav7S8MN4asAEZWvud807FTtBwBLLFPRO/iWxFImNl8RZDZq0R9VevNT1JvBbBNSZmckLqEajLLycTluhz457tFbp/hSbA8Ha9kTRFaMc8zlLP4v31RJG+3Xc+L3jgAkHp0x9P2/iPm4Ve9vOMmRUaDXN4VvMDM9WGL7EhfbLjuRBB131vRXcTz681ZBudv62nUjr7I3Pcalw0qVniVwZkVTkhpQ1r0J89YS5AUM3Sww/Af1SgDbXBE6hnGzQa8HDuGAYhBniYscRDiqJDYXHkrvswAIyLUuAcJiC6gn46rk2k25Voic+y+ymrbdgYy8BrTnmr2a762lneaIKlnfO2z8gb47XUFaiwuxVz1VtmBtLc1XpDi4klGTgjSKx51OrGgVBLM8QRtgjw2JkllTzTKOKdVLQtYxucCFl7kEqMoxxFzaL8lTioOhuw9diLIDoq7sQ3R6k5m9RPZ/S2bSu9xqeJegdTS+Q9Nrz+ZXbGyDGcYblPRGxZbX8iqPefmFkONc2TH7G9SHgTON6wCZw0hPj5owYpBfKIJUIEvAwlxclUtvwsY9C+fcFt02tsMWzt4iMjU5mj3qsE06o5J4MegMJrDUpNFscY6uAUDmCk1RxuwMEgtb0QOthV8Y3dLjDK1dtVyVNp+jV3PfNMfGxntqgRCOCPqgVmAYwXnxWevcmqYDiV718H/qoxoTMzUNTG0BmZka8Li0GukK+X4dhCsZCczPQ3gkh7qvvnjUAvfMfGLVSQTp/xxW1F94OEdtj8Kw7zPVAdIi5Cfus0a7PqpLDG7Ta9kmlX0jEqIrSG8Vf/FiWDzpRT2iUt06IuS3qR9JcazQMlAMveozXxVM+P30BPQy1BujfXzxYC+HJGjzCEbcls6RNJ7cUszsKCoTWutg13r6eyu/zj757+gPhjcyTmvwUdbFaAnzmbwpelQ+iy+VWnSpoLzyhqBF72lD1xkXMoFow2YiIgWt4rIPESMsUTHWOS4XtGNBO4LfCcKVG3Hx8UyladfreN+gLyS1q3XN8l1OAVUfpFncJO+AHWPCnEqjUhV7mDeK/xn//VUUldCTcT3zyEg6T6iAarbndlLSjD50KMMAttd9uQpTSewc94RAPcSSbiUsvpR46KQpvoy+Y/3yjFxzL6nPypAgXpYnTSAziO0kfLjG8QH9DzPMkvSs9a2etRPg6gYqUciOwJOY+4nyBp1LnQagKr7Gzs/hdTsnwhIsLgMwFn7ZoP7p9/DFDa1uR4MyzZJD9F8d/VcNKa77+Deld0j+N21DeUaf42b5MfCSGttvFJc4u5G4l6+Us8jowuNuSCFun85ZQqIcxfS+EiUr9WyLE9U1jJdtwlI/ZPNolEO8TimoVpPexM04WfyvQ8E6pMPNuKXPEzN8my0FoyanqVbEjV2NtBm01dFEjm+cpTvZr4nhwJoWkGg5D7CFl10bRIhbra9ge+vLwCQDaWieP9wWtHMLve2hpUvmKn/kGaViGvu/2UmelSpT8ooktm8NDWsH92eGnLcWZ5U/r7UUWBdF/xupM/uxS1d7r8A9K56TQB9bFxBAO3JZXAPxhP2bNv7nLw9hmRmMHyfK36asFGm83faZ3y1QFp7rJAb7y6eVMEIaxAaKXbOSym5GYnzcwIPZKOVYNITjoEIToFV+4kSfVqSk1CBgn1FdBcP4fAhsfgTuaSj9wmlTiaULBDRs04tHAupR/dKV4rvS/FLnU7rJ0ckb+7SJpOGdBUNJO0q6GdTa1YGRDQ2n8+TeqReBVvgscOPkmlLM00AawOf+6HZAWsmnGiCLtoboIhstOiToWJxkDoY4zauCEZMJiHyq7pBp+3QeEF472+j71rwzYcc0eI2JDBmZ3zbH19rnRRHmNp/79/BCMYP82lsylpCkSE9MZxmKWVMccNDkX9Cu9mAEQ6e+XzFwumN6b/qC5/OxrxL3vmYnwlq7RdFdU98snmJEeham9kExwFmETevrAV0A2EbQifOFXk/Gp70uf6FGAPexQOABX5XoB2+/wO41x9VSO7uLgS0+u8HiqaN2NW3llWq51+WaT3Jj/dZsKXTqerZqmJsrwkaHj+UrxzUoFzPg4aH9tuabY1n9TFYcnSzjtcQCU/VaUA1Nvr97zsUY16fSninRla5inHv0JzBMkSR/UkONdiF49NJrJWXvoezwG06AACb/L1iefkpuesqcud35nZSklTuLDSxiq5+mVoJLYYSA1pae1YSFYOqu3ohqNHuHVsKActdBXX5r/gfa5zmlHxmhrFCxI7HzumqKPLV19ONUEOTrLjleMErxmeWVnRqLs7q6a9PxVHYK9vTBkwheEIS1Lsx21UwXFT2N4YybMYcRUsRnMaL30OKICqNbV0jft+Y4RYmrB9Oblw27w+QwV0TNPPjD9sA/XbOiuUXg//U1Acn63cqfMgCNofHtc/UIPptPUn9UMUIMA40HFA/ncA55UL/pF686hJH1oP1JXHaccvgtuJ6U6gixyf3H+gkyrql1PMent1npIVGvQBF9TLeb/uaOO3TziEkW4+JOwxSXoUcsE7HzMxSLZPb1fej8yfJkqQswf8YBNeqL9Y2B5OHxw3mijX7TNykSnjhn2GBCA3V///SCsDcCQ9hKb7Ka32SU6Dcq/eWLaSWyt1413DWCCUxFFQwCr8+jpTRoK6q4w4pOmpJIvoGYXAgngQsIi620pj40QBQh8MTSV2KTxNUH+OQTbm1ZcmVBm3MXOcZR4otjMp+AZeBTXx+SPHpxOzK4SvvjhWsO5LLA1IzBabvvzSo1vbowLqqTUZRJ73zcB6XKgubVvNFO0NfQjA238sS9Ja6fWd0ayU5Ck5J6HxNsRhaMswJalwSeW/0X9IgUM7HwYOFavadQLVb3mKPeR6PYfWKcsboLu+NBw16fiwoynhdpU7EjEt0eyDILF27PX5y4XXRAbL71HBqk874aZMRxLWGkoUcpYNL4u/jjZUdhizw7dH8+kv9BPJ6ed2gQtsscCLEhME8rkMANn3FsIV9J+OcdoA4V/A3bV+SoesXLg3W1Zt2XOsBsZuR6axcKpTcpV0wkOjpdcv+iy7PVcvLVmXjX+kYgeIWPshyZ7QG88rY6l7T3PWVu+JQX1bFCr+9bqBayRMrkkSB6euIyzdlRWp9D3XnIsqLrQMx0sI1OH9OJy9iWo8NOl+6+CIlLDuL1d4jqN3ZYEup6Jw3Zv/DpmDvHLFHoSNr93eOK8C4Ds6S6qH/3VjbYi6hj7DoaH7WJB7dISTATn9DjKeozvw4+afnpXGgJZyZFimpvAeseKgZM/7+rvW7CttVf1tdY8CNzTcu5PfklFT2j2xQtItq1ujScGAj3omGkxQ6/z1nPP5SHTm2o8NUbGtTkflCQ5UIywtEdV3B/l7gNCK8mriq19cm9l6jssBEex9x+pKPiLuCNI2mFkaKixd1fq0KM+JH+Jq7wSW++uKn5smWINdRusfKkrSYpCvrFFA0cUXVKHVbqZpg3m4z5/hKT4pgnn7zIU9yMCwOhP3qJo+IIestsIUs23NZCQF/IkaLn/9uJsP+iB1KIRbTmx+7OhP+F+pOqnyhZF/vrJmMQWAvBttgaHvubromkiLTnvH1d3QO3Alu+XKZ/3aNxzmYH9/K54LUdyMh9L+39qDuHglm+zgGOFZYxbI/+OrdqVOS+oRnVrB1J+637jbBzFkC9ebWzwWIAVxvBe7iKSe0joh53NR85VWOfgDawavE0sSLALAoaFyvS4e7VovbhDZ5uqHyd+ImjjLKssKe4hKA8We7/SKtGDrYZQR2b3lcXIHI2h4s9Tw+Xp3o5Xd+wNN95ibR/8fBKctKGxQ1RkWlD+cP5zn9uTkfud3FnozPFcKPM74V0eD27WxIcv67/8Z4riTiRqEKkdOtojwj4+sWyqBck9DeTWmwZkmq2QAX5LUwkWUlaYzrH7cGWaPQBPZHEjhb/ZJoiwEQVMaBRhjWZaoYzrLAZgbXw6xAfqshH9EdOPFRYSCOMM+jWEZ3TNzD6PT6B9RDWzePinj4a/d50d+73NATTQ5qUGCMa2zvAFpkmR+X/xtcGODvO9KvH/P9JfuJzQvaOfmCsuxkB1iRUCd7fDSYYxCxF2VGhyLEN0s4RopYQ8i0hJWx9GlHrIaihtGmKVX+Juvga9sbE45Oa/kS9RGcFunKXpldCTS227P8nOtJtvxUVVZGeHXZgRglWq6nH3xx9ok84E+UO5vXIVZZH7goetrxlu35mSZBrcX5pYIw3dGh1Kztc+ldERNCvnDSayjoc24jRWkLwPKn2kftjEGS3YqDRi3HirXUVU2bFU02aAbNhmfktyO41/HKPzXevJEBxXtk92GhmgabawEmRugHXEgs/bqrDiAVlxRu/6H0C5qgzIWSF6PqDjas9XAfbppczWWaaiQQvxSvKv3VRIlxiXhhnSVfvEqy6MS93g01yNVWpQ0sr4/tBit7I6TjJnVuzxGYUKMqslcdRZG8dPMVfilYlAd7JafP/TrnPWEdpQUlBeGz2CZamgAH9qtZ1N2CTI3/dI0m4W24+AFnff58F2D/hdFYZ78CdRuPJYjr5uLMwG4IEFVo0GGFRLnuN5l0culBEuBebOOnES3cVcXWd4dEGGmDU1IknMyQURucHtLGag6AQJj2Oc9wWZA+8l3nEn1Kd2YyZb0dqtH/aCXAconp3hFSVPhMCDYE1PsFXxlxblGz2W7FrWcTccom0mEv3/adhHOXHMEn0e7SDEyaUysaK+7VyP3l939EDq/+F9Ai5EIvXtal8gIOHPdP152VXE3XZ6lzMl6WAKqutTaSnEpkn/3BoNlZVHM4wjzrIRt9tYUizvpwQlPqhGXDtrgCfieD5qOb24Cesai9YWzuGQB4scshlQ+NLCRytIrcrHyB16FW3L72lC1S7DWGBWjnkl6tFV01Z09LRqlZk1rLd53fodM76QxB9JwZy9LRZAJ48+i+WtnNjpoi/GxwMpVBHALJrbHpk2yPSAp7I0amzpv8LsF5RMVs6I+1HD8ID3ezdBfVhcUoKYC/mGA3L5Rhozhb1WoyxrawYdoIgXY5jTbKjCemMoFWb9LkgZ15SJ1lKzyxx+BunCFulxGV/fjaFgKFF8xg4vWOuvCgtU2ffOLO7icipzqI376BHURav9KK3NutpHLrAqmPzmJTaGDlzXF3RyNgqTK5vYhySRWov8meq8UalbsK9Dv6A+tuK/gStsBrGTyIHe0cLsN5TMUxAPL7YDtYqKXPRUua2v2+0jviocrmzJ1P1wvZMxFCqDdEjZUjRx9sNi3UDvjrZBE/rt76elCWoJriA/diGRVwiM1DGBEPnSzIzPrkiwZOs8L80MMLzEqom6/dFp+CogM+w/7j8AOFRLxeYumNN9kqiwX4YJx0q8eT377degF1nXa376t/AGfHQhw8113XctgB1ZITRFg+kLbV4GzvK6g7ofUAywWEXG1bhJ599OdG9YoKY+fnA13EWsFNu+UvMlEpUMv7M5LEtPZC75f3FkjSCLWfRAfVv34yigcCIxXz9ko4Xklzq7N9cEIZOALv5sUltcaT41lhNqKRKBY3hJmQmlmK7x7meiaMUImnj6ImB+HZev7xXmj1K40iy40S3PbPjbzAWQnbK5O8h3A502OXxeSFQrpGMg3KYyaw4cbCxcSz0d5bUS6r2kZ/EEtai5C0hLtB/OfEasSbJ1nOrmvVZddQ/c2Zk5xmSxQHrYgb6rXbprMH9+45B9RIQ385P4AoaLoVNIR46rcxtzAcFjdXa92NoGMRO7p7xMoTNBwHq+0jUV5FbyhM95Lc2sakpSflmBHqfMkYohsJl57s9ayMyO3sO7XWSAwOm6NXhglbrwWdTRnJfyWFG3h2jDfD317zc1mXIS3A4m9MKn0aRXHKAnnQZjm6Zhf0r+ZtM6A9kHQVaCkwFxNrT+SSYyKmOnTI3FMcyIsHMqGwsSCgvbM97vs5JtKEa7gY1j3MF+4lNRWYiONp10uJr/AsMtrFwkFacD5EyXoRkz+5mScuD6oWOOguGzicWqR6zXaCiGixvK/xBvFwQl8457k8tAvLF/n+AlyO/Qa750w6ftSL8gl044a8iES4TMGP/PDiGrv1rlqc1ObwXo3o5mPHliawQSNaYfsJfYeZ9K6tn3ni4sBQNvEF31rivCjvORh/LLbFNNVih8wyjo1+2w0C9s9pw9RfCrJozhqWqypZfCcUP89w/Gn1GzGHMlHGLarelg707dSL1e5T5ppXbTc4n2pwbk2rToNnWsF53FuPJjTkZvWYgP1L37c78OXuGX6t5KS2Y4Md2Up4APCfmLa8KGi18lo9zsRuXp6eRJabvOEFMDAhWuVkZ0sr9arn69NGfM1YFfpb2W3VRnCn8inJaWs07ySBZE7BQtbi8p0tOhJuW6CAkOwwwmYtmxphPszAysj5jug84gNogOJJyNjzxD3UXPSQsA3NtMVtJX+Bfzww/MvcmmrxAdKA1U7Bx8/s3gMqHrK/bFbbQbHDmfyF2vNYner9+N04XE2dsHAAdAW4ycVy0Ik6fZyUDM83rp6Mi1Yzf8ejKI2vek4YasS9rablG/Uj4CS8e3rjWa1zE8IfFK8EMSmqc3qr5kgINimZj4qqRQhomUM4N+X2d6GWit73w92rHPV/b8ZlaMLHpGm+QFDvHd1NkTbKqUb0TziRuvE03BdG0qFh4qnYY+Gdn89+gmjZUZzXpxO7N90n3PvYVX/yQBX9W106ZzsxGTA4SuO/u9MxmsjsrNNc9U7bjASxGBXNkS1ZIaQEeTqL2nSG9QxKqvjomtAHMRDKvzjaiA1smpC77IfohBvzer+QNYXOewkmct3HRIXbK09R6orJ+t+2Ke/uX46KnRM6xAXz9y9jYIaruvCozQBpiNjSFtu81pm3bd+aMwRI/XOFhvKdTxOS67bS5jB/h3/jdGQiSDsDGF5sruxpoCeoFy+qXZ3HdsB9c3O4+zepGBbTc23LQvsMNGYNqSucwggrO7U8vv8E1OTMlTO2fz6wBE+TC/9CFi8m7yQIDCptGP1wIcApEGRjQTBwQbyiqga1d8dp1x71Cbed7Pi1cS+wVvAnat4wYHXLwKw6tKV5twrM9Am4Bg/DUTHitNDwWyMTWKWih9k62zCrFLC2wt5g1theca9CXc+C4RYr8wwpkob3Suwn15qMGkl4JsY9SerKx3nEKHbOn4hPxQd/ARJUE8HGeSX1h0WoApyPlq2VkwJwFW9/nHHsEbAYK6DZrx6Cgwf1qSxfNkzJUS6tKmRY+nYb47ep9XkrqC4HnDGlCbMRxvfagYjH/DpM7nZXVJkmCjYJneQiq8b05tskvm6H3hatRldE7++4Ky5bvPTeO04aKLkTw3fFpBFsbc2NOTfrVEyVmEG3Evq1HapBNABzErBwP10Q7S5tKHdX/xBoveZdPRGMVGFLeuCwBfibBunK4/rnU6U0hQ38rCOsv5W5H0jkGpJN1lFDLYsh7G/uMhdH66OmU0MA9SgBUDbkRKHQbZhEWyU8ZOlBnqxduxoJTWhzv4GDjtxwBVBCMoT4VQP2Jgf4ycIDaM4DikYhG/kUKaG/D53/lIBM1aR0lFdXIDmhtDwghIlis/pNiMm2u0+qh2QmJR9YY7jh493fGgAhd6eIxWhoDhsoZLyB1xdZAe0yJ8eYg82H97g6Wi4yIW1Qhh2RNS95J001mLSqpOJ7MnhV8DNZr5aCMTXJJNSB1O6kgwPVA5xWSqMbAf+7nzkubKZHZer0NHQOq0B2FWC8oUwRiMs25vvrezGKtWx+ktC6Cw+v3cTl0JwN+YGqPyopblp1prdvzkKNBWd6t8e7r3m3PiTiUUCofx68txMTItCB5h8kLtsisGzhed+3GHV8Iq0isRBP61pNUThpFiPH27LhMZU2TXobZ7aVIjSAB8AV0ej+TRT7PJy50dMHpAbcaBAbPJfKlfIwDRTuFfO1cL6FCpbTUBDxvDWqnCP0xkfLLnxsevoDpN2ohQDRtuCefeCvp3hTeQrEDowKygOkJABHyO1BGCvh/piztmDsrVi7jM9UihRivzjsAAHVfavs/X2+MtgeantY6HD/7Jl8niY0i3d9AtHY3/0vd29QR6OWeBtNqcvjpZlYm0wrk7Bd9bU5wiGOOIykyNHpK1BofkOpP8sk5ueWX05akSVDif7TTU+Ai1ubrcElUZ0DVFntPCKZYFMnzZHqXmxEgP0ftFx8yRMzOzgkez5S3Pi823Ml4ObrXc8GGSFk8f5gKbZ6rY28TNWSNm8pmtp6r3wbDx++/wMWDPyNxdALFY8nD2nzIOJf6gbrRG+wGx8oyEo+OI+3P7npIF3b+ACM1fT2tIZFhVmGtFlQY1EnXwHVKy3ih3GKFTWlXJYxxCB8FFxj97w8XQy+y/Q5rCpkcaOL+CyZK4Bl5soB11jzNqCoAoK3eKa1mK69lvjM88rwXmz0rrmISdna9XLBHS9eQGDTYAGzkdey4G604A1PcVXJKzPRCIyT/Eekg/eCPUk1Hs07HaJbKcOXfZ9i7iQf8lxZBK/UGb9roS5CseUxnMT9krk0iTdLr8sJvAo06ooRBMFDsMEfCQ9ZPchOOpt2t/loVdlYhG82Krotfg6i4i0HnMPlL4+j5tsXnko+sviJeHTqL7ikC3Hz84gp70dIAUNo4gE8kcv/kn/+4TxMQ031tz/T5+hcDLmXTMk/xJHgCX2sDab8COLqU/eGsSL8MlgIuaKjLfMVsMa07O58CuR1OfIQpzAqm6XKbgcM6k/x+BT4dmgLKF1+RKoZ9k7CyNo+ZwfFpITgcOwblfR6Kkd5VurDUxqor3OTfPCsYI40KgGnRR8SOJmuQQWXRtFJYH8psaZCnVCxJCAdCHKAXo7pUU2hG9dQRxRLRa+zpmywdCVu/0iGcdF4QnZ4cSEOCh4qa/Oitb8nqgF1JEqsjOE8jBT3c+AYANcSyWwpIoyYjJIq8NEhsGFMwvM5hky3+1QVjH4gv9b7x0v2zRkSdz9ixEInTLQpb7ILcqSTZ+ahhEHQCoK8KKgC6KWBLZ0fin3BD8rrXHM+igXOlIY+pnjKXhmIa5UsdJnPanS9PlhYrH+6FEqRn4AQ36AAp/e7dG6FeUqrL224X7hllJ6lih+0JFJNA5OWr+ONfCzankqvAlXDelSg+8GMFWopElHD/z7O66cB/YHHO9IYgvk2g6QpdH/sjRVccSgtGoYrLiKaH5fIX2T0QlC3jn+o/JzqNnbguAxhWxrTYbRaCkQ1qndYR7Uk26yllNvlE5z/gjRL24PlkbWT73SjqU2xKC3m+56rDaykWF1moLsrWp5Jnm7KWe3+7OCykFhVR4ZAaPLNOSibofStkVc10/EPd7qSxJREk10PPMVd7z+MqMk3ndxrE4G68/QrOLhwVQGIzC8o4Hg+e2cMitIGdEMgSPIhaTgUi9SgKPar/PS+IgVAIzlnEtzvHcEAefAiRjiH89uR5A4qgEA4oaels0RXwXlMLenESZ0wev2j0XZaT9c5S41YaIH/JWnC5MJtRprXAMjZdZfKLgA8+IeBV3iNQGguKzRJeN0ZV3ALD2fpirX4A3r5RDRYtMuHlefgpgHYxDudesx3RYKWPSWvruYk3nP5hy/fTIJdioLlu/9RQtVlCgazKJRpqbmKqJOIW0ZZibLtjdz81Wjq9oMNN/AjcRPASLd8qa451YZgmapICxRFTMWzJccW4PdH17Bjhfvx5kri0icZciSVATLJ7X2gaNtl+bGzNcGYcXtrBGKg12pSlFlZLKL3NWjtixTQ4MFqrjv2DC8BW0/dZ88h1FCdv/EUvEzNDfuLimh41sqL996CEQ5tEYUA9wZKoJKi92eiMf70NWoAa8xbMywA+YeCmYft4JYzJGzFaUzx2AAT1NRzAeOUPBdYn5FyOzyvk4lhi7i55oFEdOxw6AMfXOBN8Qh2GSQuXutMr+MixRnSCAUvh6FF4WO2/cKFJdpfh7fBd7ENLaO7KAQ5aidikOt9bTpdkPZJcQMWdYMZQ+vqJELa9k0Azw0ae6mU1bKX7jbkW0lYWwXr9KfboERcoS8Bqg4VvHGOdHrl4772cp/Jp7BMxosh778+Cy6LGQm+wdQYFzfFZRx7p3eN9ccgoWUyNLWG/VR/gMloRuvQLRAHBoQFGK0+UsBd42qFDH+eEDQLNRlzljqtqOCbusTM8a9bp/YJ0QPNAHJXPpW1ddgqcyXz4Axc3HkLPa2ryBJLJfOrNM8mRlJrP3yWztQH7X+4L+ull9tsTFFixwVxiHuh9SzCbXOq5jmzmvyZwaqi03nld8ch7DRbPSzAZ2pKlrk4JKEhyjN/mP+0sSDn+ZSCUQQxoUBjQlXT/EKPxqv4zr/Lq4XWnpJjX5AC7rkkTJAqRiNk3s2SO1zpf8bCn8aroMaufmrWew6OXt9vL6jeaOsVBrY6yFHmrXkzTHTSl6c656s3fvzgLO3vtryNMQA/uSKtLnP05ywICsmErwx30ixlxjkOK+jHTrr833TNM3dMfL5lJkW6MimJLnJaJGJd4KEM8R00XF2IK6JgoKXpjw0UhB5iaPJQaCbelNOv9qcNEN6AGPzFOGUMYJsuVpifzdMuw1d43+25O/sD77KlBXedgBcWmHMur11uGB8BXowY6vKMOX+yBdVYJz4rD8mKT6p1q0K1aJIdqO3PlKSxmnCYS3eqz06G2wEA9Ozk8imJJwFdVnN54yddOBhl1FejEatZxeXJhHOYi2r3FawyHLjmVhn2LuUj0k762ELHRs+ivPnQ4FnruQQHKCPgE6jPMFDOmg0mTIKuKd00TMoeUrurWAuqmgMPvHDRAxubciN+zu4p3h0lCZdmye8Tf1PHXHXlIw4onfhbgVrr7N16vnDBTA/fT7YgnXxqJ3MJVQ02U+3Z6TDLeYXG2VYU4g2LRDi1JW5Rj46cLfSSp1cJGNs4kLy/tCtvUX4psMhTNvf9Mv3a5le8z7l5xkWKswJPXDC0XqKt/1N+eQjDpr78EHTFaLDH0irX2XiYZQAxNPrfXQ9svvFjkt62nLE5WNQIQPxWlcuv53S7p9IrWhxu8t7FVUEw2skctMfczcoT+MAQ3kYkQOj+A27RDX38QrRfwL4iaO8L0GuLzBSAbd/25R2no1u3mnXY6vgbNM1U05Hd6r2ftESQG2K9RAqNsOFoePNOkEkTdECHDPEDH7GXmlSmWWpoDpjFrGXDixs9AuXFJzKKYv3c263MCJmX50ONNcFjPrXCvt0s46x/0o0ArLAW45+rYGk+YsjSXNH5LjLu1cyEzuONR2ZudocLqBl6BzwqwGhpuv6M1dr+8QebJ9NsiXrGbA9HMy2vPqC+n/8NFuG0G31LrUIwym/aGO6CPJoH0aHgNJ1I97MHFp9DNYb48cvqYTQbe9TmTpEGHpzJ5KTOTYa+ZG5GYjkpRV3RZ9CirAAXUd7g+KIh1q+vLQ5ZmiSwGQ1x+dQDFOJ3lJwTHqFR/bKVUuL0WgFYd3fCzgKA9KcDioawXOup0jBU/S58GsLu5zVptkR3Capx8vtx1T/om+yYzC4Sasn1zBAVW6+qO0a9NAM8lLbrXTivvM3HTLBB0moSEclxQhLXyfb0xArppO5wzJ/7X7TVhe0OiF+7ORvRjDZdx0cl7YA/qgXHpNBzEnljO8YF1qeKL5ysQp9g0NBSv2FzxTVQe2kfhpK8z96+DkOeKl6wT9YL5qA5jM0pWm4N6lr8mwr1MCWRtVu3QZ0HOfUOSbyYI6+GwTR/9MC5eusP0SJCBtQSVy6EC9NGHIsmyD4Vy5XyEB2IBWtsKdM15P/lUDuICd9FvlLnnahsou09FvCq1WdmkMRCE5BW2cTGfgBbZHoU/7ZYdOFDa54xdvuUpJHyQmrid+QxVgdW5VpirgZufEZ5xZcG1sCf97V2IfoVJmiD5YyF26i4AJzBpRt6H0LNpd/BcInrY3j5bBLApV2z0xHfoi3KvkucoDNOrtlvpu96gCdGfT/4X48XTvb6emdTBXz/ypGM+Gw9RIi3hx6CS9cwknEJKwZVH2K8emGyfjsl1j9yUd3b/boE37LP3uy8XfOrtM2y3puEqwwYcbSzINldxy9mUqhui3yADj50cG7CpEzpQMR+fIKX1CUYHVIcYUlSyR9ht66YWiIIea80gatVHSQ7BgtpcjHl3DdQNt1ApgerHenHyEzWTYFb60u0juIrBm1eMuDNixXscY5gtVw8TU2aF+RSR9uFUlGeI3N5sgYp4OTEOh/g1VnoXGDJzWhx6D5eW7vDvSu9LDZqqzFJKvv8Fi1X1oFZq3jfcizA7vrz5z1GkOkWTqSMTwNlEOnadAJFXz382WhHNdwyRtQ1IfAeOipKeSALL3wQYxvnnFDYnSBf7Wu6zHPwtKWjj/fa5bIaldfyS9xj5eb0i1aVXYUEQPw5NaAPsT+fcR64I3qjYYTs7KZHFF2vIxQ1NKKRO0rFSz/hTWUXdLLCWbYr5BjrDA0NPuy+gANccdZRcie7MnNVR5qXQUXSRCko8j1eSbf2MmTsIbsr0yOBVrmXQFETRwOgLO1iENZIPKvN8lxixz64zDyUQnOxYyGeHKcnEiLz2TJOOvtoNlvfLg+z1KEmNAQTdHT93kgo1GjTXXbySe1D1KC1kNeZTmJLezZe1RikrXKeoROHtVIXQ9L0X0QHyS0IUzeQMC2jVob3irGqn0tq8pyYOiYWYsCjhb4ahM0MVGsqjRvYZfLtM0Fzm0V3xHJj/ONOXGQxeiunUynRry9UBNhexBMnpOTHx4OfADQYxIYI1mE5UY6wuXjtIoKs7pcbKbjRJKEPQUD27kJz8RaoRlJ0a7nYucIm7vjNnnn4gWtI3iaFavY1SFbbVif77S8qojWPSUseBWVtgEsKUQquVQ+asg7LIlEGO2QuibeUbGE3i11bZ6thEsCpmsF5JSMLGWWg8NrFIS6ZJ9KgjEioYx8yJwl968bquoOxpaoOmM/dDB2/H3r+c9zPFRhxwOr87aqUIU7Z91nOrmoifgnnM05BxSCIIWMn4ub2w9ZwE0uYEKqqRhQGuX8o6sDgFDeJNFiRJpkLqWCWvh4h2ZcpBIP7c3FVZVOx4vFgwVlXRUULFH0Jdv12BY/inmXuf+WOJ6o0fvh8AxlFz8S5a11e8lEbLi+Wojv5qX5pNW4M1Ft+eg6bdv86lG5NBai5bfjUo4u77x8eUuCcnj6wJGSyuynD9aSWyfWkSUBZKnO2R7cirl6K2HusXsJ3WnA/NlvfkKcYNfwo+2CSeKA6cffrdiLYCa8XhOB8l+BDjlC5WbLiKkvGb+Dbj+ks1OLFK4SCBysMtZI4WoUr+TfQeevOXuqZxOz1JucDQRalV+aimUsZLptN0d7PH8jEDmaiRa7Rczija+m1x7J0qPZEDxBykoyB0G7tH/2EBMyASbFXLcHFuC3bI3XXvu+VMCWVDUc9lLxY6Ctq9YbY+mtfFmJRZJCXR5MXT6dIcOtsrhJ4buMtrfAJUFqOALsdwUKhB/etSB88/ty52eqmtEAvCzdSYrmppJiKwiAt2oi+woLIjxCiYAP+74ABc7oNC6NQ1SBjR/jCUXC5i3dRI+3pp+9AJgVDY3shmxPDtRlb02DUugJ1vK6UiveNmAIq+ZHJggYoJIe+JFQBc2RwMhTHdfv6XApk0r0cewj6djm0LeMhrPCQomLqHSz9kb8Ucsk+Cl2URvPPKIGo3NSooxj+6nRfSzCtjXL5TQIV/nCX0CLBbO/OU1+raRoozFOElfKBi7LG4rrR+U2TidTF1zY5XVh1HCB41tigRr100R2S78RgYdwJBeRscF/BFnS7bEi87YDAWI9GNtG/tN2jc6TWxvgNjxJ1ckLIvE0JvzlxbS4nx15nVnt5p6KjS4VvFf9/AZzM7TGAnpW8NVUHW/OC0HeXxQ9gUs/elU8evwWpPJ51kzlEdZ4cIVND2MhQQiV9ne3t04U4FxU4hxEKtEEH6xKHfy6cyr29kO4Xv2b46NHTQfmt7IgQeNLdFy8M+8ql+VvjOtYYbLQdndY20nlQR27HzUsyvDZ7bauWO3zRDGLKpDHl3kjMQvv5o7AUVgGIA4Mxt9CNtjsRhzefvsi3tUl/auyDhyoE0y7ljNYyfFUCdP6840AdyzbNQ06F149PPTnz7upQLPOgi+JFRleLOtd2o5zaSiVDvh16fR/RIEiq2+ETOXQWuFXope5JIEiniMCgM2zpy1V0jAGyPPqK3D3WD14vrL4iWg8SYBhYYy7mSIiUcm2zOIFByOlq2ik8LB4d2G7XuHn5NMbMmYzCwNyQNIOz33kPVURsM/EfOdrt/5WWYn+4mCDqCLqahjgioBePjl9I/HFjbB5qoI23Z8KBMMxj4BePuSuyvPKGJSowBevJIfqEFkxy4LCjTrFVCDi1mZt6/7NFSOljZWcSuezl7xPpiTSv+eZHFajH2RnYx5ohAMk2oCXs7wz8KJED6GYCiF+n32IKG4SvH+yI5i4RAp5UDiExaiVrDZl57Wlzx4ltY//eTErLBbNBez3oIpvvjWessJq1nBk3XfPHqqiOjR0BkOhKjCHAneTgKbeQIdvaOpV1vPlVDdFYQHIDlnQ4iOsoXdhey7+1LDOBsOg7LyGGXO8VJMf5hdbN8ynXboDV8loR2bsfd8CIhjbgFFBPDLq0AMQG46VE+oGLHB/7Sjtm0CBJep4Hi7w3rdcsKd9REajyNbprWfzy4ZNYnrv5Dj5jN25MTZp0WHIdb1FapoPWiIEfgDLEDh9G6bAUcQDGhb3zwJNaC721UHDTRriU1uFEW5mNob9JxTEv7HxhgWgmwDEjIyHjV1OnKXuddWr0k3d0XBdeK1knuk00MTSrRxP+Fo/WX7Q3cnf7HlXdiXwbq3aRZ6EwacWZ03iBwlcH8omxOKFaovC8ygqO/SX6B3IgeZWhDwqzDjxZil4SKOQa3GYA9++K/QPYxWjszwUFOjEn9CJDiBNrL6OGhmJpLfTdqgCQ10g6shzHglh6l7Q1KTZcMVxYzRlO4UQKB7dNatdF6OVh5c5iWnPWNBoQVcXzXkkwAj8w/hzt+0imwSFTpMk7Vtd9cQlEgxznPvH3DF7QSDdaU/MpFd0jMX1Rld5EJL+2JrLpBULySAn7hoHYgY4CytlMjXesRJWMmIhkiQbuFF3zuZYo91wBIvvg3I1+Q0/w7RWiTkCe2r9IGcyFz24ilquAPz5giB1fbUTK4ls4dfCyAY6FlHNCzAiI7hDYpjkQAqKmAKT3yz7GmHTNHJGDRu7z3jsAitmxfe8FLPG1NkK01ZFKWoEKU8Nbl7z5J9cSfiZRY/QJupxWbMMpOzKt6IFJlb4WQemdo9c3tte5u16LggIxeV4TFJIrgRVoOGzUBPrsX2PPF9nq5wzQcLoDl/MKEPC0ZcGVu1EJeN8vTpk2XPu/inFzB3ncuFJA1oAmBg6+9hIetyGwpbLI03cV1gbcj9NZWE8Vy0ofqgjgub3p94NZ+CgL+Q1R9YARO7SU9Nm5WNU4fCt9Z0XKX4MSDeReca6MwJnwUPmPevWK+DVhda93GLmVBbeaifRV0UCLnCsIVwEJ3atU+y1PCXCMj65Ht04uXS7oyrpC8T30d00x839+USXus8P3UCoGDUC0M0e2Uh0hCzKCkPsTACkGxWvkFE3Uq0JQbUvj9mU4b9+LizRkCs05GqqcSB5R5cOAJV1H4M4FpG+7GCNjgQQtA0tof/AqENh07n6TlTbbiqEdKLoZIJK9EfXcAftVYgwBVxSkLhsKbEcBgeGBn5010iiSe6igEX6Yc9y+KLgcOAJndwojWqnT+ZbAvFDFKYPQ6qPCGpqy8CYa3ehUiZ1PA5eX5+Pqdv3PPFB4GhKVmD5R3QVioQSh23BE/ENiIMgvl6bgR2X+C/f4Hd02jG+i0gHFxKQ/v4nVVsHz285pkhGc920Ci8np5q9rikT0DXCtILnTjP0khw46FEOIb/1AlStw2rXZsuwBU23JS6KinKJFbVYvbrezLw3C6yz3uRfrca2oxihXF8dFLvo/sGudwKUt7pCz5/u9+vZU1dHtaBZV1E99SRcmhxxA/xRp9kLyxJWLg0ZPzr6dKV7+nnKt6do+aDb/ESNWouLdWe6JPHZl0p7Bu2183a4bZiI0sD6U25N3S9dmOkfPji4I3HeGQJREf6KfWXU/N+/2MqI0qgZBkhvrcUvctM7FwBDIUa+fixJSdL9mIDx65WrTSA6HZcPczsuVJUgV1UZuHMfJ4bqsdBMJ7NX4AIy1art0uTnsSFszfaIqkQ+9/8l3zriu059rqtNwl8R4Gp9rJTmDiqDStrb78GJ3ZjcouXmcmLICKf85yzPWa10FFVHlzV4P/iaoBGYE6jHzalyejPWCLgVnHOoLYiQVmbTqABnbKn7bEgKm2CRF3q96H3tQR8q0X9/3CKOWxG37z9KSMaufPcA8q+dEQ9L/GsNGF5qZ1zxkpCbUVbYXeAs8HgT3/xGMHuutYAtHzvwYaNODIGe2lKRx7xLkEu5ZkE+nR24a5ImGHR0uX4Hsw2V1jlinIOk69mAilDwYuw6BzbN6J/mDqYzu7aqvsUPfZbQP6SygMc0znVedZWJ+ZX1qrTgSQnZ2bEljQ87LKaQYJr6i9ljPKHwTcIStfCTNOuTTYZgQLHaZCyFSRnCQIlvCp50E+gfbn/gxpK3RtnmgQgpanXq82GnSHHEOGrKqgRaL6NoUM2xenXIDeNHUwn2ys1Y+MJifafWa5KUhKchW8y2pwmy1Rz7yKEcy0U0vBmGRujNMIb0jaqu/ns/sNXGEGbduHSQOQXvCF7ciuOb+5ZVOIsbLiu/ZcYX5+TVSUIOgmB+nTI6hR31+tJRIwnluJvbVI8eIKxZTlW7zC+1KkoWPWKu8BgMFPcvlZURMOxECsdmfvPmK81JhdIkSi3yBr0yE9iKGu0Ntvqn5T0p1besy5ybLSfifQaziESpIrD26BU2AYqCGkC9dPkO/IP/gimvp1SDynRlbehx5r786zgJVFNfv6DSISeFYwUyfzKy8DsVMNsIdW0fBIgfv3UQsSSaoE193KwIS++00ZQLxDUyG9gJ0e4sxxgPYmoWB7lTjkGVJMWPzzf5jsd/EJXCRasVjd8DNodUAao1TTvd8aMEGU5tM1rdFuXE6lWSFzTiXs/WN6CSH06JxSnolDGHXp5V3YvSNmciNWNT0OYK0b9AdnYm60Ott7K8Zz/+wxqblLhvxwU2dXTC6Z8D6+apZlJyiNk9NHfMwC4ROl4R4taUqB34z+JFB++SrrkmyzGt9V2G1H29NdFSp2oVXDh37VYrVWdbRiipJcXTJwPAfTh0S9JXX1j8hVy9xgD9MVTuNKb+Onb/z1vc9n47FeRt5KU+VsTiXQdfyhLxlkJEtn44H/3gko7P0KjJre0NgZcWHS/hdrZrh/jETCiNXNjuOM3ts1N9RahMsYnmfJlEJEtM1UiX658CvV8zUM7HT8x3xYrsAj+YxcklO/mBnLSyQGBpR560VLJsKNa3kAH6LCrRD+TvV2dhBfcPkuXu1CVRazz5h02Bj/6nyffJf0NeqhFo8Q2za1eZT3kdzy9mKLYqOKtUV5C+2utz9Mpj5qGPk/AKNUosnYizCTeY77d2kwlxVowznmCHzXEH+UeD3NSgILr+ua4rNGSqKBtUHdZ1AU/icK0Yw64J8mDmQMIJe+wiCtKZMVJgnbL9wIBYNdyh4IxVmdPnj56RH0z0SBTHPwOVMGF4JO5yo/jlonmLNmLqVeAYXEUQV/umcLkp0KJ5xsAI4Y6sDsc2OyQ1tqrr25jlEmOpR3a+o/YSBl2ih6Qhk3Dl3NSHaAr9pbuGSJIUwUmr9esUBwWMZCteHnLtTFLGI3wgLBOLQQZ67YXDStnlxOs6Iiowu8LXYFSvBgfzNnSxr08M3rcitaY2nvgjXUZCoFjm75rpiCpdcI2F31LmXkw9Y+D9uwEr7Wrl5XnibSe0K6OMzd6QTqsAp2qRkTugAw4O63D8MX7T0kj68Kd9+IQk3mQrBlEhr71Uw1+/pYXgkeXlToWP4RtFKwsD95thElDL2HHQTDQ+mjC8jkLumAr+5zZ6icdEFcFqyK4ppdYpltaoyv6Fxpzyc+oIW1Y4sdjBjpmXvvSua/3DUFukHwuqrGaKDgAH75tkW8YNiyMFDfoGaUf90YCs9f4uhY6NwOCYtpSALi3CFY5WDX5hGAeqkzDD867k18UJxmT4JdlJ1uZHZK3aFuGIvAGkvxl+HUCkRrvptOo+u7P0FGn0ajOB8VhPLh9xYysy7fSBmsiNGJ81aZUgLotUWHNAw8OhWlbt8CJwwPDvrSgM2nB6vhKyfGhkOJBPdDM5UR/saf3d49wye9muyQarLDABCIzMIloVUc1ye0nVzRAkPfAXmCIGw7FNlH/JqFnNtD738rj1gBfsYOp54oZYFG3/6rWSpZPAU9E1fcXTib+zIHW1hkdOI3PYBkfkDfBU6jiwUxd4sfJSLwFXe0vGuajAdlg5r5LmDhpfsRVZOAj57NyF91F4HjrPw/2vJyqmMhvcV2pU7VKiGfcMS6Wx5iNUyWjMJH+9NMtlSf824RtOJ1mNqQcxFuH/7V1GzrCtjX6ZG03CrzfJtz+aOm0Th1EQWDLCfOAcZ+k8ucHW6cay1T3Q/XBsgWlyFWE4Pv0dX5aiFm0uIwd1EAcm2FzGZ5xOphq5NorA7Ty0xam7czKYFSSR+n7Bx4FcwkhIyiclPCMs+WBNscpKCIHFNnH1m77vOorj4kQQXV3T/EWuvZxx0xxG7CAz9IVw7HLG9Bw8X9IupP2Ajvg0A9+yYr/20crP0ILIDSZ+4jFwtwxZHb7wEvHK7pk6CJvxZkAIUleFfqOw1FXbHp2SdEU98bUnxEAEPWZw3aVBfK5nUhG2/IjRKmdYwavAxNRsUAm57MANuBYBYqTJsHqew18QzX/bWjLbFG54KhyaMtPA/c47bTO0rPVwVMcUDTu5pUB7EaliF/B7O/2vX2+Fca5mgGAGJhlMQ6j/rjDXg8iSQP+tWgipDu1c7ongF5cGep6bctCiCvG0O7JBvDRMs+sjHun5Dkd6uDmv3jYPrMfaYdHiTiQWOof71H8/Tv63FGTBfU+bp6rOm7UbDIJAJwufh08tUIKJ9geLvtNVKygV4ICYbKwhVKnQpt8qhl/ubAkCeXPCuOmGcT9EeQ1hgqmcj9UuFlDp+f4y5gNlmA6DUZjQuaHoBvAbj6nEJy3AyOAnTtGrE/SFiidQPafVtoLDjczEkX6vbF21Bvhi/fUWJd18hAzkjatzdX20npKV6NFx+ELnUDLQUKBgaKOuTqMGYI2KIQ34eqm9ay2GKvEL7isP5RzVtSOa2vGSnFeAryZsqwATLVn4VpVhsFvXLuqOeAdoRePYKn725w6dKfhYp1ZRC3rxI7MuTXG0QKBB0fOnxJKHwY1q0JFfzfzXKyhyuAFwHFvN4q1yKRCVDNzUhqb2r5FZ7eyzI1H13aw8KQ0db8+6692B08+KDBZ1tkogOkKZMQyV30G6a5U3oZftdnUPtZwmYqXMq8qDguqlmPCIPP5ncmBRIjfv0Pp64ZiSpqK1SVVgRMC3mzwxfik/yFtZ/G4Cn0AXYBMn5B7kNSWiIAJVvlCVbOsr2lsc9K5gGZTN5VZSaa8ZxmdsPOfct+cHPoyNRw+fJImexEAuycWLduP1xaCxs/XjZRNGRarMtWchBEh59OzkVk0evPccba5QxjjgbFZN+F4XFyld9hkR4ne1TKxtA+dqO9XvtZdAIWIDp3S9LY9KQIe7I3B9npNAKst5vLBW+x/JyQ24tmaAyp1QNe8zcS7392BIPI7s1/6thyNMZx2k/+/fVSoELAd9xGjYf2Ztc5yllT4AOz/hNBe1eB9lIiInaFzNDW2n1/wja/6n5WLK3gD8MoCgZ3beacTz4rq6xHTqAy3CbNGGjT8XSBrIpBsQ0eOVFXijrz631j2Kp9+JHbdP9+H2NOAwj9f1+6loMSRA5FuTkluUX2RSG7Wy+BLf3mpczbQpccJ3aH1SP75mi1CTzTu2V57xmaew/kqiV/DLrGUhPVgTYQhXrpx23WUu7o4WSBkEsuceGh5YBgFCmizdrNe6RGrUgzp4H8AQjJffTU+5/vpUZikS5O/65+2qrYCrS/oaY5DY4qgdaXPZ/tmH+0w3NVnXSx/4onkAftW9+YC+ZMlc+SVT7E7yM+70xBQvcm+1dilvHMkIuIOHfJbxXxWePoGphIKuPQm9537k+sv6oDBzszpZyjS7CYNZXExpCpnkbG+E8k8lMoHfJ51Y95UGhg9U0y0MddK3vPFz0a7n8EcZTPyazgLXNBN5OTWzMHZivf+JPR49lIfS7KTrtNi4XJCHNG3SxvfjuBDosGcW0V+nbAYagpdBYJBxTESNKhywRzYed8pNEy/Ac8wVqfYT3JsWixc8E/qE7lWzoG6KOLwE7zUbFjbRmiB2BjRQDpJpw8qRtA73bOtQfQkwjbrmyZYraojCljehTDmeTkSekzFYUDXuK1tdqIzSoyJz7uMD5gwask/bAC/ihO6MmwVRLbaHAkUxj15stl/xS3pkLYmwybvGhcQxQ7O1IO+NnKQksC/jtsgpr4U1xadG2ZkBM8X0PG+kUXF0xfig4f8sBkPZYoWGZJmgiRIAV0fy+WutxbfoAwLd7kfIATev5/pCp+yFX0ytdE1Hap7daQy1fZIqq8m+fUC4wKdaKzN7FiZ1mjcp5WQV+Gyh3THohyXADnCXAz7lm9qcfl2EmXPh+i28gq4OzZ4nJIuPKLRTQLy0zsTzCcaZVGoY92SKLf/TLzcJtvk16VomoQKqxGaHnva1rCVB+fV/akJXzj48U0+3xgTJjqMTAqyyloQmj9F+CR27KRGvJvnEk5/7TOh19/5yxrmSRFlVIFsPlRT3HxnSu7xspGbHZ7iR68Zd1VUj3OMEpkEAqetxysSThmiSVIoGxJghDXdavPlLyndYWi4weBfJHrNz3lu9GNIuBb13um1ndLIEM9zHdqTmcTfyifzgU4SaOl8jVDLPExsVBx5PC4rVIxZJlwYLpP5XvOoFC+jnTBuzc7+Grv2iHS8PbXgfXNRHH+6bp4z7kLP93MXPGb84ShY5rVcrNQbbKG5NX/FUziJQFz0bk5V0c9C6W01Lk7TskUOMFVLtNwL9DLA7/9qSTVtg16EVtmG6Xf633zLJaM6129QET/zvq1OdNkYeg5sJtD8M4FiEUEA3FJ0DHg9LpVgC9bRu+C8QRyWX0Oh6hB/aU5znhfXu4o5W4ZypQF731JC82dRfFgNbCdLHZgp4ZN9tNFFIGxnGPqP6TOC3wtAXu5bXNfQhJbUN3YYoYJAA6MLaDgRNG13XlYmoLrhRZSn3x/1UpfVyD4WGbmXS2QwIovl8gfWY2Y5zYmvk4ag8ULCDYDwWpXJQk5400N6rG/2qWi0lbXn26bahrRhwfKVmBW/c8K6iZLSx1WyzXgUiBFA3X71PoHtDNtOsLrFUYj6WLqzAAwRVdJhqOPYQXtDGuFuhyApHMmkBN567Q5hv141HpHqI20iDnDVI/G4RWKMOjqs8TNs1STEFR8V98tKAcIKiX/n0K51r1cmUmLLcy2EnKZ6zdIFAjPsVlizzpPmkSoig9BH+bn2ftV9d2yZEQ8KlADu35ddubM7Opprg78ajeXRfThM6pXJVqoQIFNz2e45U1AeDz7VHvKVtPI3JUM8bUpe55fwS3+3zXYEoDm2dIjjlVxU3SpWrNVNnoaz/zXD/OsFjCWAnvYrlLoKhXDTaiqC61oULlxqXhLmIABhQAPUWSYc3HY+Ad0OOgCsCT44CWvRW6jGaWMvbW2Gb9kZKVXdWyLP3xFks2ASh3mNbff6JwYkAcaFiRf+xHuPefW8dlhzHGRjUAIu/xjWbHxKto3dV9Rt3mLhbVCQVKR6ao95SoTTDVT/D9fdonxuwD67ntVRMWgXfRxLrZ9O/UcPw1X44unouLPhOE+CNlUfT0B6aN2nbd7zSftNu8XurjX5OZNZ7+3AYsiyDBtAU/eZXUmsYpqkyQBl2Pg9oNHNj/mvEoVoARmg7Z0RbVAMsyF1FxWkhMh2upNMazfDD5norqaC1xnf0eeTGe1TcWohjqw8WL4/MfhV4PocTgDop/jdg1ectBofw3K382Rx6+xOxpXT1Gv12yksqEMdSiMi/dnmItp3PD5j8K5Xu401B0S5rLLrmYLmSSTXHkgeUuhAxjWcU2KuuJ4lxitLiQkP7Y9ZYjywGzhzNT/cJZCN/fzn/ZIdIG58WsbBbcoNYShJEYahY/6I2rWPPLaA0WFEOCv+QKhpkj5uyp5cXxYVpnQg4Zh0qj7FApxHcwyS12vzr2+c/sjLd+W7Ogfzu6Ui9TUoTayGaBEsAM48Plfdm7btMyYA5oqvfygQGQxU9SPrZRqr+/2RlHDn2iUASi2lKBZpg9GLrxW4FHLr05nQW5JC8DRHDMV1TD/hdgZXU4FXC3s6iRJKgX6kw6kfYm0E2nJbDO0+dRIijBw66xKHsZ3J9ca85Jy/vpFL+AEqG8wWPlCUTZmr+UxM+j3vT1uGqFY58e9SB5sIYc9112jdAKEGChTxwb1yOpjKhmvvdItKaKo7vD7eGJpdnmhkvb7Gyeg8jQXXTfKutRpjFSt26ObJNUfVjyFOP3Ye+5jR5wC1ZBdTa7m9hAg22V3WJ+RVeLhUaLKJFFao8NlP7fI99g/OpBdAyPxFdyd/LNNPuJB4Nvwj+z63UkgTMh8IUcNACdKcEaDGBwNqYPO6JYsQwXeUPgQKQZQzZ1eatod2Xzm4mgWN0DBQTWb/W2++XdakXHk0KCm5K8UIKrjD3xBV7WM7kJIHZFFFfrQOJ8V7d8J0zswzkHugKAuxdKZIkXc4JJ+Iin8fCOnZh+yZMzTm/zkIllBCfNgUhrKhbA9Pog/AvztxnGJpKvapP/9wkzYu3XuDz1fROENlV2dNziFoYvYmE5V4tzQAV6VWOXqnZ1ERr0noTxMLHkFOwJ8m8lVybrEE8glDd+jUc44NBR+vgWNTIynn6o24SRxdtV4Tww9eII0KF1O+V4bARlJXjBDbXDxbZpQN31qs5r86piNiJClBnpgKc5LVIIcYG9DYx+IxqAu5kAbDNCPf1KxspQhspjWKDy8ojVCrNz6zeish+uG8xtaBpvIxVcUHzfjbRcAk34P8TkSvVWWVnY3nS0PBAomYY+DvX1oxsznv0vMS3VH771gev3xIlLYWU740xjhGmI7uq0uTNfncRMeHvPLYtjw7PrFaAAdA94pU0r9Yu8VUaHKA2RvgDlPifLtddbqEbnvoa1npII6/xFy7bupzoj92m4hNAGsOICGsgJa4ASPD/4py395Ia7v+mcaq+1SPFksWa9ACIgiOOJOCJikfVNI/tWOGo0EdC9+e17ITs341grzEHyWJGyV3Elaf0XiaXMrEP+EolamMo53TowePKjzsUyqlbG/nE1zeA4gyk+V6vhWarSbjSFwPLI6KF18BgJNstaotKBiAkjm4AjFApYmV6rIcCJDbPYU0CovAe7Wkd+72IQ51dn4fesr/stSvAOOE4a4QTsonM+4nE9B2kGndm6CwjXFIzUL1w1o5DufeAVXJWQh7yEj5QvkTOLL6UwS/R7wqr6IjWeOTuRdwWtNlBvcje/nDyuklqf2qEX5pgOf+NhZejliYyxaJrVCMzjPW9fP3wX1XmB9Vu7M9FgYRBObp22rOAdOGwspjpdDH6upyDtzNAEA6E5p4S7gKNjZk5oMVbTeFrtq5DCSjTmqr5d6tN/HPMXTIIe13WzGbzvZDNy2HNrRl67n/GsD/SaHYlhrwfSz4sJ5Awym1KrxTscY9rzveIFNgWEtGfZo5/YzUH5YHmK3Wurp4zsQjp7/ZxRraLgpmlVrwwSGU3vFdV0uIa2Q+llyYjjg6J6w5bRfHho4bsX+EthNdd5O55evjDTXbqoE/IAtEKixFsI+YKP4FLSOLD0MDhFNL/Yjsgh01svCYNZqbewBrTj9ARIaLokHK//k6N8PuSSGegbskvNqp0QYY2rj1UwMXC1qgstiP+WFu7fUcUSGzzFqnmuuV8pUkzvsvwht3fXN0i96EJJ83eX6Uf8pc6CuJ9I8mSqRnvA5faOU1wBHOSwDyeNul8CH5mh21sK+shAhX7QLhvOmu+9ZjjmRPEADTDUizHZ72zeMU/Fj/KP9mQlWcmRpwjd+hBSH9lP3Np6Dp/JFy7ttiP+SmAxe2ykqeWCVYIpUMIXyMWzk9alO8kSui81ntCi8+meusZMYTR0VyuZrsDrlcj1QecyxWfaFGOt45lzQVlTin1qIYsw18rVsIfXoffn9Y2Pl1SjrxZTO/JpCsTwUk/mRlURXm0Ed7gW+i5MgbMAzvYho2Ej4vIdxicyrVSI1DGq47mpIajN5rS8HmQbhYnVMuDZV8qQlOl6AH3zx+JIT9btiGUeq4DeC3Ek3YIhI9bhRW1QxuWxBKvmA89o+OQIGMGcNBpzj9sJqtAtn0lK7fHfxRiuQVx2lzEfZBtIwmNy1aZRmVThIXzHG4Bcakt+hfzTm+MewHpi4eFyW9/rTTMDU30lNNXm2fp9BVJ749Ijy3ZS6dGhgOz0gl3C0jicVrm1p2JRD0Sf2rmjWtQW6NnnrREfT1sEFrQEYMDk1411k8lvxNV41aLR5CcRNgda5qF5An+ri5Qs0FSm6yJmum0KV7PfDDnXTNVS1lyvwOmbJ4ffBn0ey8qFnb5YIDt9QP8skFkEv9goFYhR3QevmN8IlpXbuYIMqnPD2yHK+G35LuW1Klf5DO3R2fMXspZ6TpIbRi1H2Wkbf/Vu4C1L7CHw2mAMvME9LJwnZGfYPkIUcsJsblW9y1ft8McYQHVel58KDihx/3N3IHDaWKti3VyND2y2A25FE+CSQqJOWKhMxpx5t6AAjV0LAfJh3uWv+UITTvqFpqjL9uNixwkStzqxkfMXolCXE3mRu9jVzyEFMxfgDJp5YYVlUTULqUnhJmWucmiasHnieWkGoq1cti8bX4Cu56wAqqi7h22Xg0YQu/glfjoz/QkIbRq1yycH/4zMflV14dxFTD3gy/7wnNloIZz79xHFXSpL2llDCrVHZfjqvoDuXtUn8R3vo0WuyR6ETrafa1X6gmp9ap2KjC9to/9RksXuYZWGUmYJKeUaigFWsOiJuJmOZxPr/AAI+tQRxzXLuThXYVjSD4RMY6K2x8w8pEyzvjxORy/NTM++f3a96ODapwB9HUFMfhu4IUuiuTLDFwoQMjSHhi12pLpmm6uiJR1O0Ga6Zb9xitBsOba2q1070Bua2O9i7eLVyrWOOHxwubBJv5Pvut4K/g5QD6JjU07YlPyxAxIgvzKc3VrLVsrggvGGJ45Q36TuvCnbmgMColyqNO4kcYuJIHiWgSBt3obqIyVu9KL/AlLVJi+6iqND5EiGaBASfMKUeDsG29g2Agy9l0xFnGZRTmn0Q3V+QoV5i5CRfC2sfURsI54RzZIlv+oEqO5wbVnl5fXaqKy4spZdDV5h9N6OsE96c294+mgNgOzfId0Uu9Rio3RLzr/3B9PXisRdleLb0WUSRH95GRhBCreO3Hawfu+xZ5YV9dsjH0NDaLDgbDqRrWmVrLtIdUQ9fAKc2jl6mwHWUqVq1/szTn6kRLy9qsyqj3N/nczWcbnpxSir5S/FgBAhbq9SxtQV9p2n+NsYN7xhSTu0sbrVYWJh1kUruv2MKVhcVQeuQKOHd4zXsVbv87jB4IxOuHWbPwt/SfxnKzTKgauYKOiGeGSAl1NmwQzgLwirEQvpporcDeyBqVOY1rv7VH0FAeVsi7t01yziZjipIWhVz414/Jd83Wf3xeFfPwJqSpV+WLDIRbZ9CoYbUgYksmQTRWhQvuvVU/3RQggfbLwOR3NOBnVcKrqX6zo+7VmSIWtvoinD39oJaWdSUglyuTyMyi2BD+Zv4A3PM4hD9rBX3jNBBqZ/cugtElMA/kYtbVgewvpS6SS8WymBhVBV/9rbUawZaJHAou7nVPrVJywcyRkHAn0QYK7p8JKC2578kbnPJI4gJ35Y1KBC8BgxkWXsX1Q8h/bL6z7vohHVnH74qZscpoJHE+Kz8O7V6wDde28Ey9WJ8PwyONBYAVVLnZrgV1/U9uvFdAl/1ng31jczDHw3yPfeLU8J4yoNZ+hvODA32VOmZO2CxpxCIwePWiwYApTwTFNB02hTQkXJ2yvJKecWkIRpNGynBEGv9DQ9aXj4amJfBgIoH/8tsKGpv7CwHOM6dF6cg/a9oKKYwYKjX1lrYPh4kMcAWvpDTS7axae3EP3N0h3wUoW3cMtfVWjrF4M0I2Hcrwj448hoYYfsJS48wDiNHa93sDPB2jIoIzJue0Uxl4w/tzn7XhRySpFWselJ0XmEB2Ht06JUL4Nn5ro6+Y2zQzlgROJWQcR3FoX/ps5Du8DVvuNkytk/kvD8WOOCj1fu1+L6ofpNR3D2ZpeX0ziHvN1KSfXtYW7+57PNaVX796i8ywm9J/jZkL8FNkQdjX+jOtwXn/S2pUJUX5CUSCH/0JPka5bh1pbHWlu/q50pM/3hhENKCCmQ235nA2IIPnURfV4kHVLmXgmAQ9RLzggjE5wFjuj+ARMvaUTt+7VcjALXOQLFpLH0p27uv34gmLPEzlxelE13G7Mk6zp61A5LsTJWjFqDex9R5x1GNEyzYaFkj5nmm1yrd+8wdWdT5sXZOluIxnuGfm6hz0U9JQTEpVSyAf/2FspUIZAMUc1PiIw+LUcda5LA/RtBYYLouA7imMjWK4mVa0NHNlB0JP0MZj9mV8PmaI1zAI91hZJ7XCVGohCFp4SmizfC601kZFdwjGlE00ptIGT/H99dYIqtiCL2pdnhIOvAqUwdudtIygRh8mHCWYejTcyw9QNczObB+9Abe1Lms+cf2PhsIYZkrfu98yX2IpvuejwxQhYl/OEFmCLJmFD95qKY5Bv2Iyg5a+nrgM3uapYy4rHGPEZOgDnMHL8lZKGmOC5OibCnMvGmmkoODR5I3tFjKO+IoqIDcynTYJhf4FdBlwPbIy+lGqTxL/xAQrTiCcC68J6C/h14kFLZBAu++WasZPHe2evKb5wO0wu39Dsn7wiRALjFnPNJmb00+m5ESkb9sG84XMhBXRfCCaXZyAfC1iD/IBh9bJaeWDWAFMM3WaQ6NCuSBPyXWMIxpnuqdnN0apsiLFmAqu8uoGlCVLpHDHk7IjDbxVA313QGNiX7r5wyt+yU+hoD+ICdvmU5t3//XZBAzI1bOWKHad3l4NRF3ImhpiAWHWFA7BqaCZHfh9kk2Q9zRKuEC9wHfryauyuKRP/1Zxu8GMjOVh0GmMIBmY1zcPp9l7i8aSksn2FRRBODWJayB3XGIQm44vGC0sn+UyGHymrdueiu868sxkPfvnKEnT0dRmd188owodq99YKDevBCw5Sl8CdpYD6rsrXSKT9WwF8fVPd2PlH0STT10jGBdORKwwjC8WvClEnMj+XWgomRvTjHPakN26h45tG5x/CPPp1Jmm0IcwecAOC0tUPeQ1VIwfB+2kAKQUi+OCnLVZtNTtEZKiUqjjn1Jhbz4KV+MjO/cxVkKAL0MrTYSxa4GViGRfJ8AVuJGamPWQxFyJsvsAm56bqBNQyMX3tIFnO+CpHRr3d7uZs7AZMc2H6y0Z6jbxcLZFh8RzxiyRLbUabGdvHn1j73ImZGx1HGLsjhtsOU+qd29L3m2HKhYe2jMR7qf2qMtrtf/yTP7cmiUYEi37iiGJbpviG86sFpz+gBlZ6wLWQsdRsCu/rvR7d1IEssJaoKEHa9d3hlDfLZWHYg/z7BuAB9aR1TaXmLr+6NzJ2ULwf0vpE2SZnWV/t7UEc00NIr0t1vikDPJdId9HLF3/FcWM3Hi1aX51b/kaxo178WtOYAn5ggFpyc/hlQ0EbWWjTjoE+O+QOdG7SFRHVrRqiN+mvzX+MnRI0xeL1QirRDHPRknHapBv+L+94nT86LcUjYE4MbiUXhTtcWPqO+sfvUrfYzvJyY5z1ccCvr57ujMVBHChZTjzj6vc/WfkkDZoA9ltz7QaqOnD/J+oiCJKZ6iiS0f/ad4lZ68fhXZUMjdvgpY27F+43VY5mNO2oh6eqkKny8nuZQaKG93Gx7youKXLo/9KRqAG5H91CgCqZtosrhyLSAqTmBjOdz1tpIEDPe5dYAhCXnytg0UKn5M2i+8gzTtlbGW/Xf6GXENoOrgRP5ladX4VI50X6l2zQ5pHcsStJ6Aermtpe2qOEj70HFSFtWWGmtYUEGGE398m6oC8OH22yk6U39rZWLCT7qk8fnrnDp0iIruzW7wKDev4ZLG1tVm/J9BGelPpJjRqG5Y8jo/LhRpmASpyWM2D1mpocRnYV9scUl/xeGLJ0ERHuXUtByRgPKE7aVhC39GQp+akT6I/+SCyI7/i0STLbklys+nXgwu1Pq41NzUBXVRvvahWXf70e96vSZcKoIsV6iBeudnGR0Uq1NVt1g3URg1F4r3mjaqlpGSgNyi31u7w5ND22iz1m/RvAznO3wzc1Wz1skwJfcp1TTutyEjtuDQzPZmgwjD/F5XH7907wrszTSfTtl+JKpS5oMp8FSXc3B1YlNC5C/rhMUwx+bKYr4nIkZXx74mh78p7SxBMGK/2jDRmfEzXT50RvY+Nxa6BwGlB5k0mhokWmM7rXwbnkaIWqjMNocYRffrlxvNWwmDQpyXEiint1DHy2mjOMO1I2vLOtd11jaPVqEiOapod6jNS9fLMqimk2sjJo+cZYMfZmrOnDQDqz+2NzQB7CGzjenTML9kaH7VxoKUH7jigYEFk7gsp5N3DVwuuji6Y8A3MLQplBPpJ7uOW1T6jsDzVwQRWxuoUj+OnLWrtM7l2TnuELnGgkadFpVWGWy+oK/eIg1pLdrBd4dDyMUUlAMupoO/toCf2ZopDDNSpqZC6jSI+WEl9lc/cjs91dUv7GiKvfVF15LSvGCOhwpPVNbR8hLKAzOZ60VsQjNPy5h2+TO+5Eg5pfbckIGFo4YqUjr6CEHBLw4OnlyM3ELPU+IDUGcBPiLmdq1BQQwm6ektjhFW/spXZNnBJHwEvPs+MhqAqtEglmxwuGPrEdMwgaLGVU6vYpibxWjZskfpPyADHZbuYIF/15Xjg+Q0YkM4m6PswPZWoDUyZ568nPbrswezhNfQXTD//1x/zgNwLplP/2V2LQbgwBOMWFyZGqV8HGEQV6n1U0D5jcz/3lTaIQSqeajDxiTx7ZL0s3ly2qlCEni0QQDlIjCvOvx/v9t/zg3TVJRZaALnPs7DXmYs2vuAQBLdLlQYGR+YEKspSKgQKJrThI8A6pO4GyuigKD4eGT8SSuQMPTzAw38lbGX8apFZrkT3n8/LUxcP9It255IVUAMOpdzWX0wSpDGPtWgQxpp3nRrPtjVClAGDwb6f+eIJLcAuRKGb//8ioJWNgmd/bacMmzdXm61Kd7XlL+GEtloFOORk799/0H/bTLPuldPiGoTD3CiKpKqteUPjyWSaoRnJNNMXb/846UZQnYjTmrUh8UafcyDmkty6ZiiGlQQx0kVo2XpgVh0hUqMxTbfIbaodRUEEoKPBzF+6spVuxf3BK47ri8ckrkyKVvduknzn+5zmAto1npLMKwM0Q5mfpFq6vXnhGgJNZ3sAvgTAeNfwJfKVq58KuUgEpHUMpdeUCUU/q/vSgaOWyEFka5HfJ8/tafwvykkknbth/KTDvjIjV8BvJ5RPAkGv3yRe4L0PDCcpUpnLvWYZmDPjktllYBJdHAFuHGvGojXom4bEBqn4MuJnJJyItoceqWSI1NN3VpOwTFLQNPPDqzkcHjrtPDFjZAALO9HLEqyMmStZiL9i6h/SE4eLXZ4qazFzccxavnFy5jp06mEBSO3gff9AUvhlx+TxpNar/aR20sNgg04uiyhaKlWMZSlaL5iAqu1aeJyC76yBqtv9IuXgR7azA/SDsodKJEwKedLtvnUqRj5Y+NVwp1OdZ04x4kbXuc5q+9ShHpnvZVdQa9inOG/Fqza8PklIV32I9HzBor+Pq5zkWJYYBy/02PKQZz24yN4wJAWlabRQ4Ylw5exl63F9Z7EgdzbAC8aA5rEL+viwvreTLhry0phy7KEkZp5YMT874WLI+VINBbUpaNR3Kv+l1AAPVHYAucoyJJBx/oJAcnvv+u6oXdGCeLAqtATekdOGkFvG+cK1Uk8OTDcgMU5iVW+sNVAyWvWZBZR4/qd7mGnDbkKIg3MF5WQoalVs/dh7A8Oc2ldvoJlXidGcV6nUakRqVNR1zGny+MBK4jCqOJvLK43ld7uba3tvI9g6eCv9/O9kaxNJ6jrHQtDpluxA0o2vJsCWRQCjQheeb6TUc2yPWP5nJH/PMi43rTDvrVGGckQ01mSxWNl16NC1rb1aQWNXYhMUvLurFuuKov+PQm5PRzF+315PhRfTumCcQXds5b1Q+vsN5o/ao9ymDROUYDQXM9hFZZmr5S2sokWmEJ7IyaTN3pMCAHT7cN1mNonBUu1Ke9qZp9F7TMAIqeYPPnWxko6vUYoe+krVvs+TeZSiOmzcBgCg2pCAWl21meXNNwcEJ9YzwkDREFqwpt7n4/54McumLIP3DCE9LVz17jbof4xjnkLxu280uVGXjsUj9TW7wOUoe1cyg1CuAlcgaEhuhiZmEg781dyyX991WupXxQ8OH39MjWddqKCSKsPDMJOLxtbOuS0H7JF85lVNPf+uqYXQhuriZ1VH1fBPCxMHqgfseb4LTWp4YPxN0o5s/DQp/wD40YBY11mXoYp24RoaGXGIybfTTOAW2DlQvgTbylGjQ4KZSNmwDX2d5aQykkH+vQQFSIGr5uJiWgghAnMTmJMsMVBhcIg+/Vh95tPrckL3XFSff51jDpWmwzDYKmj6x/Kpf8SP3o8vBmxqgibGVFlwGT2hK/b6Rj1CFePY/ggyc/9Iu9c8e8UsZDKG2RNDltGvBveic8XGS+0bibHAl7k5MA9LVpUyjJkggPEqTLiZcSSSXKHMZjSKy2y5RYmoHSxDGsxbRBlj1K2fkAUt5JsOd0aQLE+K6s0cNLy/E6c6VEXeYZIIEdkNXmQwAJXAbl+nrKsyJqgfZaV9D1LLxIy1IMY2nQS0ckiDI4qDJZAtzVivENuhp8F2ex3UQp8ac69TXi82FpRnjtp1gILiIxsdHFAPs+puW9qe90ddlLEndsxLCUD1m407FnC53SrqgGiug8U94hfuU2pUOalib5ifunCijjT/vF2ReIm4RDcURxJN/a1FnwdOgtcKzZBsClxXfW78ye5dPjJcKD5wr0/zmFe5jHrKLraqKGmoL93/1IGEnjhWAeJXDMLyn+83sSTsWLgyK8S19gcM/BvivSPuiDAo958JJsJu9PG4aVmfN8vEmzoESKRGKkl/lPmTiK/pT/uMp0BQ9IgSW9WU55d7r02MlLSPEfQwWHMH7B7pl6xNAllp4WqxgZcLAraGK49koUv7Y1PW1Z2A0JhBaxeGkF8UT6jcdRXk3NSwmxsJonqo3Da0oAJC6fyC98m3Tli2lj6z+Tj3CG4fjSMvJTKKo87UsgLVmEIY1WeREIyDmC80sxfq6CIHX1hoMH7DfpUcpPlE6G+KR3kWWY2cwhAmhx+BMHm9R1Hd8TdEANVRBUKJtypgI8ZaLG5jsUs0A9lJMh+jGV4j7iQJO7XTUniV7aJ8MMPyeoEZK8qcH/SaGEBdSTTCSgwmcnipsqKwlx3HYJ/XSFFAsCFuRTeFLDZb7RwFrmyeeCnBUtBUoQ5vnLhM0p9hhmRkbS8lIr62KDWOW/bsFbp8G2pTsgHRp0X+j9gxDoAJGzhhtwOX6Uw3pcEiXtvycveawXrux+RTXHWEjnxleQ6kSKMiHIyggX+aY7hiFEuQdfAh5P9EG/M05oeUa4cp1ANlNaA/pA5nCrlPog7PIS+LWGioQGUikVd29QNYBYUkxx1AtWtAUxNmTkLA4EqINmuOBPZZxMRQdc0dxuGXYL/rDpg0Be9KiKyMPflLww/IyJog0hRNbA8lkCu9cMQ+xg2qmx+78vkEZ8Fgj0MJnBxjakuya/VYN91P0WI+md2Y50vSkpCHzM3gYjMuAiqOhYa3bNl9661IMyHTT01Bi9Q+D/mh4Lofe3J+/8p8gSAetlO2LwNez3pUjs6s/hf9HmKxTy9vMHZzcr8hPdh5/Pj3eyqH3C6p9kHU40lNWxBc53a5xXSuGVZPOw6Tss8xjfpY+riFQEyLLeQySbG6hNUrtFCNhNIodc1+ASaGVXy/r+Zfwu0EoEMvOqxm3WyB2qDDPpfYAwQ6KffHd+lRZkajT7md3PNWQlpmO5+BzoMAYQIaxGI/OmsF9KelHfpdOFMLo5H6a1Qg+xyDGhFTi5krK6/ojr76ggwa6nqPDYkOhoovNj2xpEabIpOtuNrmwqpTZKEP+0FAfp6AYgDw0yx95m4/4R7FJBCoIjXeCoi6YlIzOjnXxlo+zjy7CMUuQyO2XlgHrUK8Uxveji6EUhqx9/qNeLjr7NWYD0T2AIA84YcZojZau3aZ18MFQO2w5XGrdoMotSWpZwgbYLL477r4Q5bs4sgeq4R9sqmMYSWhjlOvomhB25DrqpvXNUcZrThDRKBFi6ekIsYyVnakYzlP2n2XZtgHkC4upDFFCwX70wGCOy5uDNoM6Jafc9HgJoGyZLhWsiZyyqpYsBZr6VnmhWO7AzbqF9zkHaK3aKvQF0oOdeuHbn06oxQSx4l2gq/BTm14A6aTNRcH0/PxxHwAvCZqBPsxc/T3S2uBYakGGvMWmgJPq36mdTmXMD8Ga5eT8YhJpp74LI9xLfiQm+0lm8Nvt3hy50XPZykJbLj+gi+bvFHWJwa3GgOYBX6H+ICJuAFlRJEXAX6lajW9xR+FS5uxtfB46OuPfoZrxCfSvBnK8bezqdN1vQvikIor16cyqSQDOokTgWDGRzXemy0Q8QIf8J86YzTfVMLzkHbcHFGy9JN9jLYuH3GjurthDMkGk/Tg0ubOVBbfHmGUeB1JqttKRzDvKe63hp/rUONUP/T88A7mAz9p/hNTUPQ7c42D0aFOT+z7M6BJhyH9IBtLjLPSy+SzccSrNCPpJAZy5Wky1b43AJhpraJIqPAVSLZxxEHOn/wRDRJ6dmmffCLnQQoTL3g4bYw0A5q/t9Ilyl++O08uWcj76aGAQOaYmWWELDB/Ype9AGXiClY60PMpnBePT2GoPGls4fr2XJ4Z3zi1HuJgYAwdArqmfE5PGAj3PbdLeN56IVKQ9y2uZh5OOweiiVsnj2GTHlrEl0j7B25Z2iLVchJKCydQ+v2rRR3ELyrq9z0mKSQFllNZRsYIRyn7YJKNfSTEsNzJQXBFrJvRb9nAydOS2c4pElriPQLDc2Q02KzNdY/sF5hpXyLveApQ5KtmQKr4hWcftPiaCuBcHbzMpFgeJIS5rofyu5Itg+VIs4xw63qYPTs8n1Z6kgnc3huZy3ZW2G1YZ65rd7hBk19ifNKfyrMtY+NllM2el5nK3T9orsXvNbIfA/EIWATdulbobpHYWdPw6v7lOZZGIgAb8B9IcC7ihBLaLbgGlsMyADvfIL5Ib2hoIiABdo9BX8lbCqVH37ePbk2BnD9BGMcLPLbcr1N+025VhJd46nsDmio8e/lZeajkjb4+Pa//9a46KIeXMjZjXepU2NdqfUJhPkA04V9PV6J+xgSgLKi9MkyctQwBmoSni0oa/MCX6ZDHU5Mt3G2Q/v4SBtECJO81gMAAuRRVBq3nwO4xUvQmjBGy3gEX62Ox1Jq2lsl9Rq2WQNelurm6mRLruE8dtARW/lhHJ3+tF20agc/Gnsofcdpunuzp/ODd5DrFfDeULFN8RfrLYB+ibWmCRE1JnlAwBF65BTcWrUuPqAwHC1Xy21ndN89zuehzQ+iNAfNfXdkyjs3HLarrXlVl8WAHk21CbSyeGoCdEn5dPSD8+N6qeKUJ0+4B5KdnpxbxgMYgiPb2Ppn/gVwhs4vvE5ODpsqQA7kMmHA0PnaZsjyG1q5qJSfF9zcuyjeUnwZpughsW30YMSxU6r5QAbkW/FxSAU0I2IQPxxdHFx3zKgmvRZa7HlTpVcUu5dmIQnlAyMeR6kUFXYJdJ9ohpJXU+imdRepq/9fL43DEqcQmLi2/aR1dGP/FpUicVlc/fErmxiCIm3TOWghacFTEuOBbCoBD82snuPUZyHazGevXrmL8+seO3ntLHIjtiGsQdiMYOrsHlgmBeB5TwbG3rmKU0ijDBIUhMdWVrIJawZTA82O6FYQSml0mihC9ot+yjKr3FUVjcPZikZYy9RDt1lIrPbRw0jXuY83FnOKZAnFFUANG7xdDhvTME4ORkXyEhl9oKnvtjsD50L6u76T10fZeLpaOGKIM7YCDcmtODYnbun4fgQosONsJG7Tk4YOCJniUpG7igDggftUN8h4RaXtA94DfUWVUm1NAI9YJQpIvSlRMDPY2iIoCC96KrA5U3NLqYFP9fCL/H3rzBQkiLC7Opd+k0ycQn/u6hqe7Jb2UCVK5AGkgl4HzS2XRixFncE9dFbKtZdTNyXUIKQT/+jqhDilSBjzmR0iHlrPRruBLxXjfvpE5z9y4UsKlbFnHo7dlxrgNjQpunq/k8QNfMXvwyEEWkgMWKzrCEMjpLCK5gBmf0xq1p1ScIQR0fYZp4a8bnt+DgJ0GW0V9q+2NCGAcSBKr5NB4B8i7uXV59sDVOT3oPqch/Ntpzkq/JVNKMqypBGgvvMivUQOOtLGVUZRDcf+wiEQbCQcfd4iJVBcHld/9eBXcFhRYYn4foh9DX/OLNfV/M6RsuM73sJI0yvFeNkHaqo+EhtdH9f5ZYiIk6wknxjb2eGLqiAByVhnYRFl7vvnZnDLdzmUi6eMhuIHSHg6zS8M54Z/K4tk3p3yql6lTIxLM6LOUqdG72jS3jN86RVCVCIdr5MPTJ2wmu2glfd0O9GfwBxJkYRG5ltPuQuRbt79bsu+2ISPKYYAzky6mfGi3onMPI0OVw2GglafvOvGO/oD8x1QkdShK0yOkwBt1e1r13aoxKzpWuEl0mpdONoT+TFO3YlrIsoVhaGmArBzlOfdoi8CFZeLQL8VyRmmnPgVv5w8kpzPa8cGefPmyyU2E14gDTBoe1KeI4oDiw9bgN+gzRUv7FzXX/L1RipkmoAaqYJiCovK9kI1GfmQJcY+Cs/wI7uzMYixQA3lJqP2yuuh+PQ5jO4v31q28jrx0eSqreQnZxRzgoATSgPZAmoPZ3ZJqfqUVYcrIXNhXHteGPMrTlS0sYUgcy8ErD00lisFMEVTxFNBqEtm0koIQyqBJv/kg80Y4CNGZzbrtqLb91dDXg0pInVcADpmsZkGowd6h6eV+sNUr0DF+8I9r0q7ZZQnf+V2Q1ndWc8uT3M04NMrfUxtHNKgszYLTq9TyITokwHxL6z2KWT24KBY1X/ynjfl2i7j6QXpWhHX/Mq1AIt/2wET5aGvH4BwqXqGR/eAxkq/U+VFSVhhiIBK/mfabzUVCWl/ca+2rVr5mb9UvUykSJlmvoMEAf7j/WKA1c0XR77YiLu44bwjTPWtdIbMOmhvS9VrKEXEbM+gkyWHQK0+lYIwQAZpnb2DuT/jB49bwdLcG+L2Dhv2UGQpZp3rAdyLHXqgR0OvwWnPHSOXSwhl/XLpd8AvqAc1a7EJfxNdhAA0Obke/TX++14tqH9ulZWrQzT3GbQN+DKSldNspw6gMeu7xRMiGVuSixmkbdLFXywVicNtjMfqrhS8binN8p0jVEHdItj1s2If/p49taWBCBKBWkYTfqx882pj8YkYxTck+3mvBJ0j+f1udTqYf+RnksndNrzxJaFcjNrmuNymrBKLR89US2iuVOHFZG9DFvrK8tKl53i4wds+ni90pzGdF0ucgULhQBzBZ1+DuUk2sbK51w4seuJX6IyghD1aRDiebd/bqtgXgcpLfCaW6oZomzhEcGymdpmzvwFSlLxr0IpgGHrneF0tFxELYLtDnm3CLBaBYhSZDXHKTc1P9/FE5Q14XA7qSk1DbQ797gKK2TIx3/wpZf9i4ceVYerIBuBPPXsFqzoo7hd6t2iv63JcNHniaNaIPkFLF3AhcuZhbfJQbX+KFRyvxz2EHp8ZpSpahwIu1wvYBXlNPUGJrfJWatZ7i9hK5nVD2PZe1OSXm6SiH5BlkdiLRSqG8ZdfOSjbqeOWppp6Q98nk8c+Am+fbY1LSyfN+PXTGnW4tqLnXaq5Jif0Xt/EQYVs52Yo9FiMcFp8xkGxr2x7+G9YGykyMy78H8gQdlyPDtfIfnZnX/otuRuR4LMibCXbFKVW0gKox6xeVJOxOZ1NvZmXaR4zJozZmJeo/77b1Kcf25x82P42L9MLHf50TB/XQXfRilwDXMMys9pEXEc3eySRocSML5Tuhv7sK9x+HVdcQWmqhQymA1aWK61BxaZd21PzaLvNpCIJjxfkMBSm5jMW6977IE+r1CjCuN+DVe30jH1wC9Ai02EwTsW3Ow9jRQyPtqEOBPBkKkNYaxidp60auU8WPEsyAsu9IZkK4qIwYBrW7uVzWO14u552bc5SF9UCw6OySOkRaJq9IXFfloUflNG3MjCLTe7bpfF6nIgA6aMYo+rLctmxKV7x0VPO7a5ZXUTMleex8y8KAFTQjKysuZ/XHs8r0tfSpbKhWg6Ds4rf4w+h3CZxNTNgT4i/pw8BmRBxkT+HfyHzG9W3HFr6wskwWdiBeihzPYMfUPJmMwsVLj0bjSQWIjphTguOIu+7B0U40x6iTorGH85LkIQq58nwBi81viTyQmRc7GSJwY9MwWbRq9IEsGfw5YieSNpB+SeMRblZoNZmoGwNd27iKBW7eLhhOqtULOnHgUihSToMg26r8ueFZJfLsXGl8DJ8JRMR6wPMbLY5axciG3/1YYxgOSou6zAkMHuFuGnb5Bp9wNpXNuD6+/NbdZtM7gqDNiQzkhCtwlKz7aG+6/c7YkCdZQOjxD2XISgk/TNPuDRXWif92Ux8iTeniQXgqCclgXx6CX5pv30JovhOcxaWn8h0sFMntYFzowiYvoD/C8abaUCxDm8KkZmyit42gd4ECqMzxE719AcoobizVZBtdwTJFYwDfR7USJloPMt3La+yjS0oPYHznRYKyE1QnXP23+OeIJoN0XzWUajgYH5tQSlgNngjY6VAnt+chOavjUS/XDQXIKLmhYrtwdzZG+qjdY/7YU0Xbo/GO13t48PM36+HJDF8Kma8FVsd9ASNSn8QLG9CQ5xQSH+uu9buTR1EsR1crIs/uWZEqyAJpwL+qXhgq5uMHeJ4WxpyWTOCXdrnLn1eIALVlhPvtqzYwPxmQUL/XL+NceFxZ5pi9CXr2cSAmtng8g+7ss9zfOOAB2v+ZbbqFhqKXRG1ugBf0yDRhA6+PlNImjAtnFNKHpDvO6gPRSyfBCTSw3W6S9YFXfKA/Rj9wG84Uk13Z56U0r3Ud2qMoKBP7yJdeJCIJ3Om5ZWB97ipD8W6sriMDj5mvh7QGISIsG6l3RP1eyJgjHrgCo2q+ph6ZGcJV/Vn+ME8Byj8BCJGFpNfYAkFsW5dci3j/bDvywmf48o9SABG0VJjgxkL82QVUIrbXF31EhNLeLc29OqunrXtKn3GtOQV+Fag90ba8ybsdLrE1U2ziztcOcP4dCEnnfMUVimrCerUazj0WBJbZ26tNNDrM33RCGBJHngazIGG9QtYFrwQn31Cd/q2rhiGCq9Y3wWQE9fsbXoGmj7fdP1fbQviqYPYERXB3+U9XBNI5Bnte+ytA8YeRjfGOriyUmlLqSwwZ40Mpv7RAwYqe0zF7LffInncUWLZE3TQ4KuAwbVMcFwnwN4MB/WfWPEVRMXjRupueTR2KV5Yih79RqVWjlPPG3UxkpThPEjbJocaK47sHFSk+zoiAlEneHTbJijMdimLBMj4X6Ab0xa3fbKINcFYwVbAIHoQd5jglWI9nJ9VBqfVBezBDBijFlxWr+zdD/MMFTrvmNDig1/WIQLHj3K/FjBOoFdIQJhj8J0ImP06d2MvsI+aFFdwvVrqVC8fen9bluv+SHEEUbXdZCeLT1L4sXXInwR7Ov1WfVwDb1o2QFCjL1y4Ej6A7sQL7yXdLkPOQjJtskukycEY+zpu+T6Q/Zz9rMNLr1MocfdW+ri+uWwHfbdcrxmxk/WXIDj7sPM0RmHED7NgYdAEXHSVEr9Djlbev0tfFZCYySfN4DL8Z8nEsPqo5Zw72/PVeym08EspLqNWLED+rHucKIg47RQlJ3WFX6aokE4jAtKmqPAXuPX7WO6jnBYpS9gKZsXxaC5HrRUeGSZM71Ds7qSR9g63SnGGrhQpfpQgCCeg2x02+gd2xtDVMf6HtKB6qWxXvDYBwF2zSDbhIUcMxR69eP5P/4mmn5dEtck3JYgQN/r+3UpqgSJ2sbThNUeCTLNhnu3d5upRkQ49jXDnTzBqvf218FNVk1FgA1awp00Rvkacg65sll0eUdZsLEH2AWJHv3WpWNs4rVbAymphEm6nw1vdbhwjzl9VZDLYseEurrsymuffgJn5SrVR5p+re4sgjhaIXmuBKqPS68hoJIdAexvk/0NxilGIKPbxIGIPNL5ryDtnH4naG9HoeZ3hZ+g6944eXnvRWXI7++0/kzJftRGKZUqJo4JjnpM2uLPNrKOTBhnVfjvL4vyi+VxHxNEHkUq/AJ+cwYQ/B2AqYLZ15QVXq1R5y6ymD5POUWG2wZStXdAlzLIBTBP6HzpbNnzKf+Pib1KjeMHKOhwf0GUrU8DIDI6EugK5MpCFUEpX6NkrrAWxKXjNzNTIgxfEMB2yhl7rF5kDqAy3TWzP32iwi3Ki97y/Z+qwRRGjnOL6s1XVT4yxi3XAi4RW/4NW8R2YXYjEhTHh1XO12JnnVa+IycM9qVb3KVOh8L8qm0g9w7BJZi/exkz5GjM0ncSw2LTLkXGM32vB9TgqIxHNY8U7YpDAr4HDjDSLTI/NtJBUYD0PYLpJc/oC/kSaPqbXKlxsrVkYreDXzuLX1gZxW+IrIlvaRz7DczZ+UmcFzzIy3zZOtmq7GB47fDv6VXi43gXQ68LjzzXpd9Hzk+oOaxi1CYuqefpCtbYR2PG6ZfvVfXSuAnrTpAxHBYwit1gIrOC42nKPUDBGIbvs0bPXegX65p/mFLNgs0ddcctTLKHiYzAT7nqkDeXFuPoSkqLkNkZ7z5efKL7DQXb26B45ntFNuARVYuMV2Lbb5GVpnxMwD8sBizy0U6JQKsW8ZPAnAea0e/m64jcUu/ts7mR6FkdH632udvZEiNifpj0L27bOQxCdPgcHhyu5jLUV6rAND3XB9pxxN3yia6Zlq/86vt65uU1YFgVpP1+xlH4Wo8rFbnkRdLZq9DrqhTYMocJUsrvM1QpO+yzm6sxBGlzo7QNedAoLsg197MW9oNSVtrH63gex2lORH1l/qNos5pc71qxJ2v12JKrYZGCb/YhmkRajAWur9czldHNx+PvUrKtA20Dobp0ZTnaig+XQnDhxKrHMZcsi9iyoQPOEgTif1rnDVz4LBJxUOedD+uDUmN8X2r5XRh0jM48ChuszEs83m3p6SoPpdspjukoxPAe2GdnXswWp8A1phXeCMIIlnaDFVZUl+H/9wx/Ba9efyBB7dUggP+/iR/HM66foaliDhM3RfWUQEcY0yEvjE6dMmVd1FTd8WWVh2LwGYYF84xAo214uRU+ce3oJp74ctHmkkStmdT5qCZv8QG9muhKNBeiwHFC2NAgaCmQUomaKS7QlDzRIEK/lyWro1Iik3QD/Jkkl02o/TOwomS9oTJ+Iwhj0kxD7IlcRLHbHJy77XBmPEh35hlkujmDxFqmA4nHjug4gt99v/1UPqCGAlXYRD+n9xcm8JZawmiKZQCccgSCKfjpQXFS6gQQL23KdceAD5pactXJK6ovbysJZNP8N9elhuB+1WnqtWLFw5W9/N2BtBQXpZmwieReH5fMsP3Mr8YAfSfshws/D2FflqoACP9+W3uc3f14ecpTXC6kckadmTfUojjVJ0pth3ObvRmsHowDr18KbNW08H3vxVKEVQ6TuKXNV3Yppde8jdfGls5827xh/u3DC2vy1hXXMXyafVLCPy5iodqKz20uqXrTDRT/GNkixoapqZxCEEOp/+0tPGvbgLdjwLiVu4fHibKrl4zAbsYY6h2VmizTR0C9pBZxPy/yTDmy+EO4lwtiv+iKv23yZqMb/BGCMmCmyAmdJ4NziabI1BwWQLR9GWmxFfiMlmoNc+1ngJjFainYOzn9Gscr3XMvsSLDmp37DI8TsTvaFSXEcfjHFL38ZUGln4OtlchJvAjXcyaNBloRlukV/1kpa3VuQbRyMKBuEwWozyJJMTDAgRFCoewDRnOzomwg/d8ZYEhL87HGwIP7lz28Ju9UJwJ6+wMHE/cjzEsw86E5eInBo69a5FD0qFftlN3HPdEL49a8VPVGcaYECJX6Nvs0/rao4EYpE6S8zp7jOyjhJAx5nPbkHtvb1Hi0/FsXdxx6QL/T7uWOfKUjsGGyj50mAYkVav8iALZUOIxKJ+Mm7RE+OhPuXWd0lPstgWmYu7RhVu+rL9SxPyOhmUPvISwk7dlccM4P4p5K1OsoDywc7JYBQqX8uNvY2zE3dzF5p7vsPsLuYdXCAeM4DjShspzsmhx+X6YvbNFseMw1aK+fjMqyRJR1SzrmAtMV70pNINRS64Ci8BaNh83sqI7al2YH/4lANvsebQge1wiNEjU9gesnNW5tsKa8xWEOGCFn3lklqjh0Rc6+lulN56QhCdNNBVBvU10wBgcFIew7qP4XWNnXlbyPYWvejLLcTBorf8S5H5Hu9tYhDr22c5cThRiRyAfLBMIjK+h1wNMZfZc2rn7dMc+VDSsrBjNWHcTylt5Tj4TzqvoXb+EnRemuLB4nDQUhpeY6ue3l25zEcbMUQ4zWIjl/xFPelMLsvHv2BAC+ZBY3leZ0N1BnzRVxb0U/VZ+C9pww8EBY15NEkzw+eXLoCGYva7D8UVlCg8lw7gYZO9IE3q8ekGQebHW0R4QXPbeRhMz9AZF8v/whhisq5KrWDFJO7UMl7u73VKDIvlOtRwHmwBQUFdBqqbwzqmoWU4B0YPU781xBj4Uu73R5NxTAHCQ2meX5bSyOxrWKzsZ1yB5N7eS2fOhbkhGZ9UYX9ByfbemBqyEuNuwIWI7E3+elz4kr1fjczePNGyurMZX7+eCSALReXHrRwk8ADcW2ERP4YOEYPVqXQCzHuPAKuVaWd/yLRTOVxhLWPRdlfd26v+nD2ayalcdPoUOrRxfe/CU7vs1NG1I7dl9XZlGMe1/IGcQN8LFdzz22wth0D28TAgJ0dsSXLoZmXiYeotE8tQifOoKxMmn0Tdknq0UFrq2TOsEV9VLEkxK+KYK4zBIR8cNxOfMfM7OvrK04h6wjK+6LcI9aIHOGDr/f37OcL6tirRmYh6NcaRDy0HqbtXR0ejRKH/6+tBwrM5Z7VQ9jZ0Rz5rSDAnAb0rrEeYsgmMK1mrGK+jcs9RueOouCTmszbEC4wCFOYeCprEkAbf0cixwI/MwxhnvCEbu7jAFfoTaqEdyJBg0Oe9c6R8YIOSWCXKLf5cJSpNzUYuFGRXCbZKM0c2GACNymAIWJwJ/kF15/ugD7nLC1CgVzft+tpBpGT3eStxkOkf6irdmhznqVHD281wx2JA9xYMjJ2uCEeB3oJ3pXGq0WIiHGB9hvPLtSv5XZPihf2BMXh9LPc1FXarS34l9tN8IFwoDLaKkKo2GxSNSJWYYcE4fT/r5+nEUVDoHsGxsu43rfDeyq4tqlXGzM+80pD+8CDrYbTh3I8kiDXm4wj+Up+YpS+ELeb3RUrlgzfGkwcO/vm2QiJK0p2acqar60JzgD170x9UnCdnjNBGvE9PTkvFyn+VBHjzZRiDmTXwGF+oupx0cjj0GfzqsgmM7i18egwF02LbJabrXKEXwG69ZAvLBu6vIaRn/Scw43mql4Cwz2yRJG96hOwQWl+YpIzg/NNiYBtEBaN3AaaClKJF1epK7/mQ1p08P8Xi1iPh7L1ooECpTI0lMRSi1W63uocWP0my1Xtpbr2pJLQYR2/DoBbht7g0SEw+nUd7jRfT3RojIo4uFuETdKA7xppNMxiI978cPzjlOhYrGIAouoKjvqlJKNM5f6mfWORcB7L+PmSKLfVydjNIQdReqvfHWH35WxmVoEf6Fw5Ey5orRR6W6MtCOT5DpbRQ+0Apen3hk8mgq96zWPT7BSCu3el26uCXRqEQt/GTjB+x6FhobLGgZf1PAMGrbuSWbA69w47fWjbKFzefD0S4kNQGF7A5eiNVnp+NhvlvRLL2tWKva9x+uE4oWiL9yyUNO3D0xFLrGtYW5ww0t1PrjR8AE0vyhQuo1+zlnmdvVMVVnQS/PC/CfT8VjByzcg8AIcgf60anor5eX0SyVvDv6b7eKJJM64KI+89CGN9wdIktiIQxeQJaERUtRvXZ3WexpQvoLzjCvdcE9b+XAR01RAyFhRSf3eXzhsbfpSg9fJ7JAN6AYxb+e5izJxi8h/qmlH6tuUOoa33B7/6Gc51TIuHgKPw8Kezih+jCvTeazCDdoVgCfMCRhMSqKUSl8tiO/lruneWb94Y0ru/eyEZC/UXtuCEVEbKmJdIthXk7AbuqRnfzCIdsAS5Zg9absbAPcyaBW6sW78XYdrENKIsO5A7fvlWPeDJ4hLBGwtwDqYAXfbzW3u8RpeJ4WK+ZayqyBiZ8Pt2FK6GraHXHrlMAQg0sZhqHhvTPTyDUiFUDl2Y4DPwOYTuDRQyBe5M0sWeWzOfTWTWC/FVUxJKPTAgrVIjqMTvtXcGVmLo1cgoBCJnhaibFBIDJ/ETaxMpoYlGcqhZOGWL/FOy800kvO9luTs1JAg9Clc7wHKafyro3EhIRMVyjqWQnLflW53EVYy/oi2X0b51kGmTA6/bcH0KGzu/+Z5eCOmlRI2AROYm+7tYvukylltQriucI3q2lS5OSYZe9CXaAL8j61W3sI7WvJSfIJetNKbzPmQQ26KAIoMIbwrSuld+SOAFwffmev7pVemhY2e8MXoOFyQQTELFN85rFzIjNfkHZtF5l322TGvRyOIR4z5I9+HVgutD6//00iktSvpPp5lblEX6uoZnCa6D3bgg4IgRWd7THroxGfrLFEIqFyvFVF/1QODwrwtS/+TNELzqwGcTqGdUJ7ifbnt83npeJS6qEwS88e4AwwK2MVVA9oq+L0ssD9SZe3JKigzpMQhF8o0q6Y6NMRFIUFL6vCkHVLFRUDaYd5Td9keCRVBDM0O2Wcpnq01gu4bEkZsJIPc0zU1BtT3to3pJAxhRFQeZpp+CXbfmqn+H80P4ZMen/QFoJL/cyu9qkA/C4EmhmnuraVVjKTyskgS5yWi6JtgbmhB97SkiKLxNroCAzK35Tk16sG7hZgQHk8lKEFnZGCDldZaUDBW8h6KxVDKW2hZNKvBXZm8k8+vMJmC6luNK1qkre5rTIgtz4XhYYvSx3hcyGc7a1ddwbZ3lgkdVbfq9E8LuKTWwLEMZLTWetdU+8aHTRVowvo1WFnCXmZ3fZD03Z4fMEGDprqJ/hi7fvHPCn/lwNEzXoSOd0Ur9lZstlMP3f2tVqDqI0x6aKDJPM4UUtycKy3DRzS2AiKpMfQuA5NfgAEireVOtsl+X4/7cTIQ8m2kN/mJwDupenPlk2kub+QGAe5m4RaOj40q4E+sdEPNdJQR+VwhAYH5UwkEsFfscPqtPmqWP+Gq2dX7uPos7oOAcZ1HdSgEApzO6MI0Nx82FTsH6WGNZVx43hk0Qu9+/12HLxzoJx0pus9FeFa9Ahr0anJa3K/u4a9jKlkC/7PvEe2q0PSAbH0RsNpPOxqVJkfvBrxgJQaSnkPv7DyIIqeTW0jZCVQkCtRmvvGAoWdRMyKHnTLPYL+qG3XGV7l7EBQZmqh0v0EsoSRvxZOr2uhyfbArlviqOn75TXlKe/qRLaVafOY0MYPwI65wvrseSw5PUTTs0PPygZhlh84oeVNBlia0T9AYdxb6juxba2NKHpMClHPf7Da6G3N9GnzGiakkETt4LxMwQEQ2p8DCjqygX5GVdtCTqOZCNpWBlQ+3CoE1D2vD4PoyEXnHGjrLu1Ru/BhfL6ielvEZyJOOyMXSuygcs/5IeNsN2EwYLsVrFBiuRrzK1i+3MqYGISpdX81bbpTD7UhVdoH9LgpsBguxYMBJ9juhadI+oChLrU4TQUYQK3RH1KBPA2F1iiDOfn+jXsoq8KcyLk/Rm1i46vuQvQIjqZw49mrWD1j/6BWNsUo9AKstsZUu1tzNCBw5+2AVNp6SqPWWX7Wn4bM/hqam3RV3yL6F0FhTa+xB/AyDaZ+3BpZ7y6kiibi2n7Th5HOEJYX+gouhjT9FQR0liRlom8NkNRWiw53+YHMHkjtnUyzV/INZlm5Mgf5qUljGoojMPQzgqFrjthIAMo92yAJ87A2ghk3pFWcnvXMd4q2cK4aUbtKTMAIHlv+5c9+hXOdNqgY54Mlw1DAESYXl+HLMFi4hxzKZucZC7CX2WQ/giE3/NdwBKtxnnf7BKHUDtb51e0jqcIz0KJPDwEFm9BBqWNG4bAum58LrFlvpkRqiga8whB5u2qH3/SyrbP+DMpbu3qRk2PldjYnxt2dJsOY8Gc2S3zfDOaQNxL65s+ndx4Adb+1b5LMoaCALz31N/V7HyP69LoBhT4OoZ5FTmpgmeTAwoX5OrCvC6wmu2rLieYtDMK3M9rZf7IpKIMk1rx+RVZa+CfbEOeM20zD1lfu3/boHOMjTM12ZzMSaRIYX5uIZQPzpJQXv4cmO9MEK438Qk/KgqwPZdZuHSmja7le+0WUa7ohwHp2DGbUHdtHjs+16UOXCIa5pfegCyqiZ9Ln83K1RW2qs2FbF8GTY2Zhp+eRl0pNEF2VDOwhyr+dfTAnEuP5xYRSn7FsZqEDvTJwMJZ11Rm4i/R5iv61eA+l6Y8HKs9mCyMKp/BcjDlkcQAhTx0CKJJ41GdeRUfN1aInLRc3P8HYhDoteNux3KxhkrkzOyPNRE3zPJienqdvkkwBCW4J/ZnE9YtP802KJVp23QPXxlBWoknKV7Gz0iflejasFIMdhgvI8XSiHRh4S7XcV8ogoa+8IVYWpTtYTmOhVYAYbhSt4rlgF7ij+AGTqmaAQCceHXK/g+jETBch/LdMX1IVmFNPsFlaOiQBIutuib065uYz4f4NkYT20mrC1XJQdqpXPNoofau1Q5N4usztgctyasxDF0mUzwAE2xIisKVLj05rBhUQ4DSMhODVRAr31m43vq/sBJq2okwZJKsHauYio+elsx6OXAVcNX+uw+ZI9YOP3igVRSeWvBZHI1P9ydacKh4aG0jeWPQ/9b1YQ9w33dD80+DLYK317aI45tg1n2kmUVW6O7OhUTnTR0p8VjZLpumxtexsuq7oHLdqWzklCMFUE9as/jC9NY8kEtgw9nmaXUHlSCuJ4hAZ5gw4TnVl2fM7qXR57p7RAp6u7eLAqB0eTyYAkYMu5z7qzfyJu8DSG//q6+sP89mYAU3/ZjoOSWM3VN15xSik6iy6Mf3E+32+WZXoMzkGmJqU+m5BsY3+ChnwCpfvNaV4YM0fod/74uYvytKZJtzjdirz+g463ZtQd+fSx3ch+X9J5CK4gBlsmNxa5l4FZIK7A7Vybxq48awr9ZCwN4vT8AfFlr1JgY3zR/e0epjxAsZzWMqcVzo1jZ6ZqJNkRSY25v5f0rZpkP2HJ3PHWzlZrjZUj+MaYyaPuar2o/Oez09u8LH86NohmzBcEmHn/6WktKpyPY/iFZZ9r1VFvh+iDgXmk2iQKXlSxjOH1i3sBNu5xojs9e0UrnWZjuski4qQIVjo+tLIGD9QmisrU+miQ2HnM1DF6Z6kkbDEeQPwVUgfJQXfSJSHVr74O9r+YPodaiIerG1+0qFAsYIDJON1L5V2woKg1OZVQ8DPLVSenzy5uBOnIjRCo6wEzzpy1GuW0nkatpWPzY7ypGxyArqa+DikcS31MHVD/pm6um1iXwgvXOs/KWQXsA94Mtgqy8vXw3+im5dUwM+uLWFeXA/5MEesVtP/7PVlTVWNaFQy2TUFkBlqfGyTf3xG+osEAD8ed8P3QzzBdWhvi0ivmck5hhxURESEZGK5SBsaR0ZT55POtU6YZJJr2/ZAjBFAbvKSq5oFeeNfYzsQQod+CmuZvPNoxo1Rdo7REsORJnpKBggOgsss0qJ56OOiMB6NVCnan4NFyE00HeGfdP9dGWw1FDRNRbynPdla1TN3WtVYPPKO51h5dMqDpJ9wVwfMYNQrHOQh+UTxOxvIF/ln6s7Tpvi3jQqrxtqpcUT58jlocbOjYf5ZR+Wjjc0MRjjoGGm/Bmh8qWXeAogSrwFKlqIZVy6YUrFbaxEeYKw9mOydrCl89yQ/uvmZUxZeo6Y0b2ddd8tym50DrlxrnURhIm7Vy13vgN3dc6eJFj/jLwMA2GCO2Mxb85wiZBowTXDzrC4nLcaRpx5lLWMO9Zcr/IlY5UlUiC6PsL4JA9dJrn8FhkFZ5eybGx8U1zmbo+fBqiPwrNYxyBLMydvG4Xnm+sJ5u35bksUNChJKirg/4TNcsmxdNgVSRXY6FVjQ5jU5Zb+7LXnAp6TJ1HtmfyBbZUxzAAS2QU5bG1sR/BB+5Z0JeBYO+6xHxB7EHhtMZ0P3qPTkEsnrLhji4Ft8CMOf51bjdmrL/2owBpOKIZsvmu45uXZeR1Fhp6GRuP1u9DVJzLNyAt+dCr20sFCZpRSWYfiOdQFblcI6Ukfk9Hw8b+9/EC5zXa06EhbwbiRSThzroxEisX987nq4g0bmbPM8Ud0SC1FyELN1HJMCIMfr2JjC8n8CmUx3nfELaeN8+M9ISLdXkSP3usPEDtphsoAvfGvM6WJEj6l4kLiQ2WfPNdt9nxkZuvzJDeW5EbThRVhcQiNSN8tUZByaoQS8TU9LyLoElD9a3m2CSGMpKiwj3eyN5uEhKH7nUGimOkQOgi3NB6voTRIWOz2WKmx8G9rZdh1PDkPxdOoSiREU3l+GxkUt+S5RKhXkcGi2KZoTW47EVcXqMXuOdxpxAV1+1z5WpJGO16VvEpIhUzleS+nbqhFE14xuPFDtMFRaQYgwR6QXbfxXiEJpTGF4DP24gCDKq8xX5/PqgEsh8AE/giybkstOKOhUFhU4kUTJN0NW2WC+QxCrfazSnJ89PHCnL41b8c47QMttUlS4ZVGRp2Tu6+hOeuTmXKombVlq1bX1idadt8XNJMKGSmUyBFD0v161yTR/IgPwSg4iWwXY7iqr6epNnhyn2FOFJQ6u0+1ZeDxXwm6j/YRjkbGV+hG/v8TfQcjliMwGjIvihos4RNmSpwrx/EbzqAj/QjC02XgLB/lq/30rJ5KuOvvGDsegrNMVbvM/5wuiSxWV26W22fJKHdMd/R1IBW3Q358Ho+L20mM6//gM2+DnGD3UEthtLXgNfqUsrVywLdGWCkytNvymXs3855aEhiwGgDxnDbNS6L7YaiKBqE63cg1TgBcNjc0NTB8gBKe3q9+Oqwm/JkrLD6gfOePOgpDBAnPi96mbXJsl1krHT3VLIRHr6gM1AMX33uq//UguUQkOHuio4g4TuAX2TzbmuFv/La+Xf3yZzM34iNOt1te0oqWm+ObsRXBTWu2nludcXpaQuijPkFv6J27a1exVxX1xLxFqVygKz/XDODXQ8FJCSmEgCnsUAM6PpoT7XMMBFCRvBCjNcA6uJs/wruVtf9DN6AhoYzRFuh6fJOpKo3J3FwuY2qHtYskca6o3WQqU24IiYNknQxggzZvz8LVAkLFMBM2DOr3M3O0pRh2GT6Pch9kw5euzd3Ktiqqc6UQN9LvNtyXAqgG9vu5Oj3YaRi2jlf/FrWtkGK3w4XKNzmDmi5WJ9ZxD+yLfoamWAiUlKLl/LJHqeyk0pllsKyTzON5bMTJEhTO9mCJfqWgyB+iJsPN/T0vKqd1xI2r2tWElN1Q041ZZFrbp1b1TunvHn6XXKceL+xDyQTIKq1i+6Gz47YrC3IsFSp/fg338KqpIUSzzr5nKKNc9wN9FwQX672UGEGTBoCylNMVdwHLMkGEwyjLdbAkfEENbros+UFqjg2lD+OHFrdkWUx/lq1HQFlLM2Uy3hzziTHfes6BC19rJG6zAZgnEjYsROQKL+6aMbHK095yOBR8qIC0BkyikKOiZo1iH8XgaGg2/pbHLf8gP/zyGbCMaEurJ0VLd6M73Dih/P2BlBqVs7JwLk9XnuKfDj/JcxADVqpqupH3XSzAhNIooEkvc2uIJX+Mj5QRQb5yQUHxaLjN/1lHpTYV8kCQqyBAqBz1cVxypBJFju3VPB11WpKewRNxUUK5YxIBnJRaHYtf4YHciz8Bj6iDgUUe/AahHxovLbZenQHeJD4ducWl/TqI1SQFdy34/QCtGFqIZ2bhHf+kNIVlsA0lmyX9nYGgiCI6H+R+8GoHrhV2KSHus7dGM+0SDTTyVWI8NRyhZk4VPBf2IIVYx89VLzbcV0E2Q3lKAwEPiU0DwRyrW7j/8GE0dTNiNxjrEUR4szuyKrTQybL3+jsyBCfLNdg5VpCq0BdeKz5wwMv5qIvpWcmBknQxu2/r+oRi1WTH0KI4DqKnqnL6gj7hJBz1mL2afdB8az6FIzsVEYjIIkg/5n4Tr2Et2D30B8GSxuQFjejibBxrZlCdpegR8qpH+bKqMIn6zUfkaZpR5cPQZWJB6nHiFm1bxdwVU4pb/BXeyqxKmPIneucT5enPBJj4090B9JsoHTC5NQIXkW5bQiir7IQ3oc45X9tLXzp3GT/uCZ2T+9faLyM/Led51Lkfi2lIPIG9E8Ek7w41smbrQ+P/Qj4PLniNuqP2bi9u/urt23yGJ1HUexQMzgz1A0W9BWgaf7AoE3dIUhJljPN7ZfTYhwJbR2g/7/FNJaPz8SuRD7HnC8IhAHAl/boYA+cIBu0TcwjI/A9fglw/g6Fbwfo3DgWCHu5bwElwQHkG7pSKyKd8V1KQcappJUezynba+q1lO2vpUygFCbivvET0loTDse4sA/bRZ3Yju6Pr5b24yVYZek5hu2s55vljRvBpGZrhpwUL+fkTrzR2lvMr4nHDbyNjPpGvmycyTqXBmYTZfgg98lcpbqeyb7sc7S4FKeFbRgLigi6uQdbWStLFClTYXqg9TqYyF7a5+32xpfkxjPsS7AMtte1HqAt+5/tBqsoDF1cBQCUtHnvrVJHX01DM7nCYmIbgibKnFgynt+L1LNIwSPcLSHyldxCuk7WtxAQj9QRNlPciOwFU/XXRWcV50UIKxBcmuLYk4X9f6sfEQHiYkrueGvvEyZ9FqahVpJgEePKYNYEwsxSIUQ92BBhsQ9PnCO+3DLLN+fcZTvLV89xycKGZVa3WxFGVKX48lliDFbU7YzS6UgCkwz9vQviqaqc1kQXvihgO2AV2cMFYANV23VVVx5052YpEJy24Mvhm9xzbwVsjuhO7OZEoxDucfXIWwSb1xI1fhVWYl3nYGWVQe/XtHghcriCRliDna0vroveZLRcRcqij9rIz2yYQri1tLC7FOUCGoWsZZL+vWEAdoWyiqK53kIdv9Y7nfOA/ggYuRzd5cs0JemaWqpYiuACWYiSAVZE7mHR1xDzBVMuOGH9vm47oCE2Jk1aDazgb6pOLVbkzd8uYdSVAfjZwLKnpzLiYQ1ORe/mSb/smTqfBlnRVAgthghcTm1Rz37hL2wRfX3HvCkjd1zvD1Ekze48qpPENlismjpPEflu/qWsspNT9pRalLdJ6xnIs/A9CF/EhmbumJzDTdyFg/RxaTZYu87oZiIhHjDCdDZ8PE3JC2kBKi51pnQ7AhgLAhxLj2yiO0D427eOujBC7hAe11+2WOcw/qywzdUqI93I40KI23Ll7g93Xuq+tHzoNCOtl8YHxtBdGJMSlvfvv+dDsxceSLTpsmQul0aD2FdGOJ6kugzq8aKbuSgpb+LSR9c323pJjuXEPkGo6dsavm2QZzOC6es3f9YcpQsDn07nE88UyS+8YdyczjKESZOt5JzBdxDIzfCmRWfyf7t9WNR/Fk3JVXTzlhKSK/kp5g7O9IipjE1CjC48Fub61LE2y38/9sYfQCf+SPgJBWWrQybutgM+2eDzHXZ25Wm6ZDFL0zTQ4mIY/pDBPP60HhdJqvjbytSZul7xzEl39pjrExpiYpVngNwPCaN24K8ZEie7SEEinTDQd3InyK56jbkExvk+YMUthIqeMcKuR3ifTDjGAPe8/5I7GHPR+579ZXoHeOcKYBoVzXL5RDfRj6Yl64GHaSnv7ybs4sgUsNc+N2cd3njcqMLwRF3p0gVr5KyT7TA36DgAe2qFw+HuUM7C5119M37CHqhMozsBGCc1IJ3f55yKGqmEziDW5Zv2WZPmM5UZN0q5tfTqVth6SqeUQrVEit6abTyEhsK00MYIfvMoc3FIFycCIvUMIJnSQ2FFQMDC7SxD8yhkROHRw9ClY5PdmN5KbdXPA2Xi7RrBMNXRzvi5QinChY72mrZe5KZq0409hep+E/dcVCQ0GhfQQi9f8bpavbuDGB9b1lHPR/EJuTo6107FhMTT4baXIYZ75txYsxPnYY3y3onnlhIe/GaK18VAZ0GpwnZge2Ssb03PcxRHz/F3aYutV2ny2dZ5BlfE4nfDtBeRoiAuERE6FMUZaGP36URm6Vp+xOM2Ju5W01DLNa8uUGGbOFieSdEJzt1AJ47U/h8fw7bommK5I1pyTTIE1S0nVhctdm4LAPetOMNn5XOonbUqGbYNnr/32KN4gwFZ+Drmb04BeM/WpCDN8qKVVbTnHivSX4xNmKl9pCdcxroz0Cyq8ct+8gmSZChdcwV6tR1Z+7NU9hAZpsL3vmZ4lHn6SL7VJkevzRIux9Eam93Rtxhc2MyaRHKsW8f3bXaNwGYG6xcf69deW9APryuKnPWWysKiRqUJZDetBH/LVeYUw1i3IQobWnZkELI4A6Ek9A1kV0zDk2xr0DOHUOuLB+jwOYONP2UCA0ST7MMdcLhbgd5fYpmn7PNZ5uORhicjOM/PfYzVByonKVOW1zPjyvXLi5x4rSAOyb265fUD/5vF+AzawgbitxZlJLZc/18ZhTEcMhBkoOhDGrSghf7bv4C9czX7Z7c20vHNuhzLmoVrLdnVg0+jPfUjJQoPibzPh3l8eRdTV0nJM4+Ghk6UAoi+0fRwEWFPliG+yBRk5saQM9Xi1pdro83VSbvP0xIXvUYx9smGUaa0ErMPqsnLSbHSOn03Ip+zFPu78Qn2E5ywhF/DXW8lt8TcjC6uoZgOQ2CVA5Qul/MbLoJ/QWz3ypB5CXXHV5/IVHtY3TkP2Y78cYzs7w85c284+mVCtPalurJCrYw0QZe0zPxmR75UQjnuSkjUIel/dZEwC4lTV8OM7FJ/DV26rnjoahoi98jybO6IsdkcIM5r9ij+OlIyp6EAXulOlRYk2YgXU4t991cvfFY+S0PLPkovLNYP47GLyjPgq7zQt+0HmuwFinlUlx1DwAE4yUzffuHIBKB4IwqUWv8J+MbVR1vJIiX9MMry0X42fnxiSixsgtTKneFsXUCzCvqz1pmnyJYphCQBqlbikoY1MxugAPLuwfPekouwVkhY2Ag86u1WWG6T4fqPlStHzB88W1UVvoGZkm3ZVDXFLb7U1lGjstdh3Vw3NrkOX1aMBF9HLcLFpAlv2cH5n1vPhbGCXJbZzi6QPAsUcyJddKnaLbfWby4Y/zKcJ5RVdZDwkHMhnGbxcrr5umUssJ6vJJyFbDk/bi4QxG/SaSvXA2lR6DXGCYwtfiFX9EKHYz25asK7EunAF/bcR4ERzRBKpRH3fagwS/FtijsUc2Yp2hQb8EYnJTx95Q25+fiq83x0o0ShagLId3F4TcxBbYNfqR/Hwwy/GamrSx5nmcwcVr37UoZFYgg52f/6nNwZ3MUs6NA0u45bgDnbvD9un4guw/QmaNslW9C61z+ZbIAVaClYNDFb/tSBA67b6nxPYUGe3byyn+IvnzOHsKKTAK8obbu0759sHlRcim4ubif8XP7wdmhK7Jg/pEigNMN3BVygugYNTABqylcJz2BBEvJ33aJaOtE4WeVq3VHE1M37uGv2NM+uXiWSDwIMPBtfIEYaUp7OuPT48YOWFvlRe23+y4EyIT0ZQ5BBBtRUgM3CSZkfQdukcrKxaREZKfvke5bwNITVIqi1F27jgxGUBznmaXLn7uDg/jfOSjPyplrM4/T4irIdys/b/s4WZNhpLa9EomdqVZakLglVKGkZn72TUjnjsf9y20VQenR+Pad6fyO8GacZEz1HYFb44zyX3otNh6v4zBtCcsUvHcSiPE88Mwx44r48xtTWfY37ISofDiadZvSIk+Lhng+GlWTJzbCes1wcE1d4dPZhdMu8O9ECdfD6HpgPj76bN0ILwjbpmAjOIZEnWxgOxOHAOszKfF/HuiwvZt1RMnunXyJ78UNalfnvChN3XV2QAjn6zJMqffWm+RJljckJAWi7OC4f72iIitQZIEcV00ron1DL+bdjJD0ZEeiwD+hd17bguG6WFPKbPZCVnTZQYzxG+JzaAcT9ozvbVKlyzksIp6+St+wxbo9X8pEl5ulmq4mkgOzVlLB5ujBxrNX0waUOVP6AdFWNacnE+2tD3vEURsRq16QhMuHTeNMHfOrv4xf/kDFk9oFoTc8/phdrOeI/Yms604bFVNF8jwd0MDL4GGLalb88RVQKA5tvj/h3AXjH6pHwgcv6rBx326KYjCtybBJvN1Kf0flmWhJCWc/vcLwdAd08FCXv93afmcX9Gg7sgS83Ujrx6/p/HxQHsPqNTN+SbH6sws13LiF3r0vGHKLBXTwYeOgCtCy5rAGvPRbY4RbOTseIU/xZTm/u7JvN2kN4mW/svZtfp7OQQgACOYx4b1XdZ4BhFI2k5vFyK2oEt8BrHR5GRDCkqLnJE7lhoezbIntxpMsc8bVsHnXRvjDLq0m/sLYQFMAOKDDM/xHyb0X4JnGkSca4dJ6xgHphdhOkiF8lhhQZtxpk0Iw5npYTs300zN9FH1kUcrF0zw8KHyhk56pWgKhMQnKHTye/gEWLT8JFu7n7GO5jfvSzLfZaqMXUIPBufwLR1r1uaR/EIJL1PKojCaEvg1lN93wipbfm4WRRgiyABTh0ue/QZGZd2KGqYtSjF2oGROlQuXDx8jisezROI16G4tTnWLF5k1xHFz8hAg56oReaKdnDxRfMYxDhk/5n4GkkUzJD4M4s7AeF/sk+w1npsBg4A7rOzv9l2MSLdyV92Zvgi01mWtKHp9ZMjcX/Y7GwrpbXZXCHyLcR2D+vLyxYA+8cSn92qoz4N1aVg8MxfgI7SbN1Z5nEdIqpeWdeoWKZmKp2PSdlzS4YlLp1/EBPJHxjyEWfLbM+DgkqwZGtCdD4dY83hRcrZMuvN5WqaWgmdvp46C5P8C7uzpl8019HMUrcdZ+dhRV09Qog6atKK+7pzyfZiw6zo0nQVevk2LVY93V75BffPvw1W/bEUMvzQjBrIbvoC2niESnx09kPpI2vulYT4iB3n4CfzSTXrhY0kEANbyD3A/Or+w7MitpPUpI3jFJAgldBAiwT9/qIOeFdNvG6lHzls4W9/QxnnEE2JvALeMMRrZgco5xkzcozWpMp3S+s7pvKOtGQyFde+tAF2bSf9L/4tswA+1Zt9hBDAkjXS0PSjlhkJ7rq1Qau2gvHLsHJacNrCkZozBCoG9ovjN/RaU253LO1l5Xqci623nELNm89Hi/0qYQ7DfsgV0slt877I+Kmv9K+BJdD2gWSDmoLeKOzsAlXESt0Lj8+NiiNhWTzgxhCZBMfFWvUfpktJ2vwmAP3n3Mdcm9sK2tw6iHtMguGdg/cCecFnlde/VRFAbtkUqi/26CKTWwxrQGc18wvHHnOTiHVFjqMxj5rRaw8GNxrz3VhweqMm/r/KUnClxXatD/nxdRZuHZ7N3ncxnU443xO2W4T211HRDPjhB5+sYd7gZn2aqec6pN8EZQa4aNg6HYn95F8p41dsYeGEkjHZYJiotMLrkdKqeF4m6PvxEqBuKc264MqQxVZc9KEV5YOSvB5rPL5L1cuE1QThKyT02bMZGfqG8NP662eWLEhVFXfXayx0T6k3BxTG0HyxwkHuwoIFdp1em0vKtpPXd5NNeJysqILAyBZ8Zciwyu8lmUMc/TTR37r3Vq5wgmmlzbTPDlqSuwvtv8h2GYTjNyZqeypPs6KgkbvM5VOeVninTHtzLG4f1++yWBlianjOa2OoMKeh5gvuNr3tSFdme7VdAfQ4Pw2MMG35KeK1Z0Gl62E7nPRPkMyE+2caETzjrLtdcrl+nRGRGxCG2wVFwK07t0o+lLDcRo0DEUoEQiSkSg+ugH3ubbASPi/yKcI/BtqKZzqRagaDqSyONH+XUaDocrTkAOnjPYhE9ajk6EOCFmVzitLSPjWCNm65HfuYcXW97v5hH6++W/Csn8hfsqnkGLuhtNBYPF1rem3QsGsgWMPYbniIodme+d9q68v1mMdnxf+ch7nxgFZTzlNbcxjSUrFc0dmNlgXHicC367oz/VZ1ATsfov+Mi8u7oUDEeIo/qfd5xupjMGgkgljGjPe5eoOymXncJYlw9YKb1vT+B0oXdj4LZr81475EKYK7RvTu/uVxRr/7QamkM3ruYusikzBel9HsNtgJ55gLIdZ2bG51YVZ7cg3cf7M08zuQlJ5UF/CbEw8lvN6sAO4AJxhonGuqut0TdjwuOslqFeU80tQa/XlHlOV0PvWJiYgAzvN7V1SHRvNjRQ5MeCJJNFwnw9Wot42N+0WhqZIWOl/Mw/sa2HZjIDRvo9ErMOYY85+ymrqJUTznNi1IPabZmmB4etCR1TYRwJa+M6K9RWYaBn30R+xv7mQo3N5kP6UxOyPNAnXywO0AhiY8mYaBelbg1njMVk/JY+GVrHhvc++33BcQUEUNpHTgBJarY7jZjxqeeSG6w0hgPRkbslmGkFYKtUDoTKkRkdiMQ/4pWPUTllSJxABwiqvvttOK5iVsid896FBxIdnq8aPh0S+Qsb32aXwfvOITIFfGuqteUrZGkkYM3hYmbCByVZ+/4bL/8zQ+08mASYZ0R+q7bFujFLqJ7R6aEbULYFdVEhXswOEf+IQOVuST4zXyDCCasR7xzXH1NP1hoS5ySVLssNaE2EXnlpJIsAqjam0rYDpm5EcyFcfd9I6Lwaj/vB3MtfLKh0flH8DTky7AV735dPaxwuVLzBz4jszc9Hyq7HXIBYc2xkD7EXa9K5lUTcTjlKOgXi0TZU7TtEKq/IJF6vC03ZOISy/c8N+OVjJtW5v5l6Lkhp501vQFlpQDLKp/VSsl4DYTFS09Js5/s2iQzPDROmzu5jgpWFHdfNi73N5Sl+5JYd6kR3VIc1mFBop7VfbEr3xLhaAo3DP4VaiJm3j7FGl9Dz9NhEdZbbNB6CUCZsVs4uyKIoDkDXdoBHhAGDeZdluNNbbze/UGXk3aa9lSRcokYO8UtGNlbe3slHO07o4lnM90vwAqqv9v5TwuLNsJZZG7z/DIp0jv+xNkBVd7lpTp4u03AGTq2axJmeqBySnpYZd67T27VDnyS0WDa+4wRrdrBOZKS2tDwZSPduT8c9O0Rd+cb9hL+5dPQbxim0TvK+IjwVZpzqTRKrwk26NY7D4OwNfwwdUVVdnfvrJY6NICXqJAxgmzFhlT4/1E8F9TPFcl8avPaexnMFknZJqxCmiOGzPFhhQr+qCKFKqwKKrVm2FhY76HIPyG6ChnqnRuOblEdcM5XlShjhVZhXpbLe+3ZS8NQh/Yb1AemB9N/yjqhKSCURVsU1ANfBkvwU0opWq57Lf0Qzd+qdBTj3SP+/hdzbPazlbor01I5MoWVVSWH1OtLIaBYOhRSsmlsMFFxwmJPd6fDncB3ngSj2kYM4CES5m0Mi6llNIUBxzM7+KBnSgsu8dheEo+xOXdonD55Mc5lcjLOISUUoQFoUH9W3a5KAI+sC1oUJZBs1T/MQdS8fMn2eGiD1C+KNM7MZPeW+xvmNjgOhekcAUZJ1ETW3OLWu7ugf4Qw0t7g/6jDDrfXX/HyCFmVMf/gjqLOAD3dE4i/ulKkeZ1WhnUA+FTkMnsVjN7GyKIBiebXlDa2PQGXfwXNb3tSNvIgVGBKHJ7Fi5dvMf29YS5Nm5s51neaFRiajiGF8TTauz32aTiUaiJXHndPBTkt01XCS98V0mz4RFcmHikQEjnB837vfWxMJDX/sS5IflFLLjFn3VubaibHEUnNSdyTsTSMU7ebs7beZTVhzj3C6ly3WCG/DCyG+6+n5/yuRhLKYugq4n9YRJtSdQbLn99vbjDzHj9EEwexBSmTbcwqOBJa38mk1UegzHrFLGdmOUiyHcbZKxFMLhRl1uGiNUqgrG/YWbQEk4NeZS/664vlPKeAizF2dMPHK6JGN2Kfny/hZBUhx57Wi+A++EYYl1JGG+Qn/50tn97oZMVCnBC8uuj/adb57KGbibIi8ehrIg3LFfxzG9wrXPFz6oD7sABxkfpeHu+d1lfvIjUgIBJaVRxgrdvHd750swVRa83VvbvKSMCPO+VfdmIyygDN0BdNQF/+3oGDFtHqsK3k6ZEIT3/4wOMRyNM1gtldRdExUXnMONa29JAor+dxHakAXrCPy7yppRzux3CmmoMLTz17IMtYLhoq+oIitwJ4PCrcCAIVE2H5hJIFm2nIU/IWNq6QxmXgRGU2URYRQO6hxRNYYrrbS18xexnoKQNWetYQI2OuueIpuhXLVWoyvyssLXp09sZiN4qdP12bf8pCwQDKLTB3tykJVdNI07SuUpBc2AGOdksttDMzOl6PGP0l7N01tsCj0nUkCGaMSQ+YTnxZf2z3jas4gLpBE9EW9tYbPPiBCHCuVKs02JK+wvaMEj/3Hz+NUzPDzPx62JYyqZmgAsw8YMYL6vdsoeW/89QLQYeGm7qb76CAkRXTX/xsZl0Hav4Jnm4W6r5660pZjoyeovFyYlNdSAGAo4DDKxYP5roi3bUKIGb+RSrdTw1V7bZJmEd1hvSoq8iwLhO9p6ovni2trW/ZnNxCQxVoltxNTrG2j77ao75XMEXZ02Ekl/S/h/IUnia2XYgJQHFKraNAFBoCDnySFpQEWJxHtwrJnrGtUr6LXuKcqRNZFLKHm6N2GeEgmPmO1+xKP+fZVOyCELpx8NCIQkV2UWNk5Wfc6t1iw4oyzu+Eka/m3D1YJtAEnP+x2vdux3IlkVXFKZzOdmm4HWKoHUN8gGh9rtxP4wYJbruO+GfJgctMSgtXd+5MShXJlJVd5y2cv8H4WvMwEeZCMFFBBus7hr9KNdmJSmEmchrHhiWu+CxnkXcGMRVEKAPb5YFebfHFFKQac3hUENhvXvk5EK88Qmi4aHd9XZhYR51KqiVDfgvyPaqBstY+LdnZLQCvEQdz2SymWsdmaqcZO7tMyP/J+aiotYSJzppwGFpE5WBO4GB0/Lrhy9uhId7ulNGMuh22SNyEp4yDELU8OK5UC2ELmYuRX8y8nDvURh7OYCyPR35sx9h0ifSbeVavmFojaGOaYCsY5w1PUljpF3SQDhUyHteWvZNEgugwHeEr+nM6L8R9M+E8nyRKUzihJhl3HdqFlms9r4FhjmFQ5aycnDHsIfIdIJwQ0DDFoPAJxFaGi4akiM5BMpXf/6eiLASz0slMCQPFuD+00w+mVsmeKi4qy2NNBwhMdVCKbSi5KnSikYOVH9drUhaWwnH//Jdb09UjZhodOBIZ2IhgVqtZSVZ/iAkRAwMngo3Tp2mlkMZ1h8pDWB1AmfIQp8Z8Wl37x8d2sUgQgqpC/zYXo9ikDu5fD67654AbZIRykp97WZzFvXj3+HxmSYiN4TW08dENatAQgsXoo9et1Tv0+g96JkTZHQLKLoIuf5O8nH++kZCFoWA93zNiWWt01Kxtr5y0jbY1FrRzY9NFE+wlw8ym3iV7OT81kffgiT283j1Z+V83RvcGXBWkjX+P2ip1SFJymcNHQIbM083Rfe/T+3voARMUabvzXi1GE+tt2IW6uOAImiz3BypVx2MaaEhBFChUhLa70VW5SCaJuCVdY/sp8h4Ba1cSIUe8okdt2tWmk/TBElJZe7KQnFH3w2AUUWPWfE2du4s2V88EbNQ2dqUUjV9P9f4wYVxEZKIokKN95o8m7gi6FPX9L3j+22qzpRy3N25npJoEHMjYYuFKGX8tr3Xr/8vFa1Opc/iMzzlPXvA0yLfoHQLf2BcxlGlPQAkQmmil5cD3PNYWlapfoXz1MbarCJPTTbkyl3dIB8m8Mtk6Zau1atrDYamycsLMrveFkvOS+VHHiXEY8RA2ThLSJhfIDvfNjrnHP4gRjAClhXidzXcS7rsgoRJ9GPukWSmJxXOFZphh0WH5LdAMg/w2jaQ2tlOi4y3dQ9mMhjD/6lazsASP657Oj6/e+DUeC9LzrD4mAHSe3042Rwdwt8pZ2BVv5bK6+jpyqgu1E5Gs86mjUi5Yvdr6cEWHF3XMlC5t+xhdbUf+pCBVm2bKxaC+NP0V0Zwxsy69EU3NAEW/WJKeDvPc2pTRCWIBiXmEsNSv25LBo1AsCyWc6YXzyQJ2IQW1vRTdFsSwMZxUysoGi3yneGUYEa5CScILL/MWJiIRSIxdkUXZrDnFzFHPOjFrlhXfuVVwIh5e+PD0zTdBb199abA1wJYJnC6h9dRP1T75FfsLq24eJshc85TbuEl3RJEQZeFHYeSmN9SggrZvpjIP2+cEgeGqOa09HXuiEJcMHdUisBkp3R3PpssT382f30/MqTTHcCQsTGovXYhbH2X6NBRfxL+vujzCpyp3MCpi1sI0U2iFgxKtNTF8HxCles5n/Zs77BJnZd9d6PYqmS7Zy1Urft02lXe9PCi2GIeOFbSSG97tOf8QQOR0sD1mlX0Kcsfc4HC6YYUadvGxyR9EDSytgkQLP1OeOqPEWKa8wwYQEHZHNQtVLMNmugOy1mamGAdp3KOTyonS8C6EcT9S+NIRFuNC9ULriK676XW5BsAt0zdlrIOVf3eFvt5x4Rpf3v/cgyQAZIGLY/LhDRzkuxfLH++CvOqkKV8RXt4xV+Rqhx7bjhJJ1K77whyc/aNiFS8uHbT3LQX1bhizvLGiAZDKhntuNp8EYXZDzhWuoNPe6hN/vx5lfxBYcaZn1pVJX1bxNPbbH7vpKe2OSy+WhIu0vs745t3C60RdMVVKU7y4oYnsOro8IEFrjHcUIwIK+smBx7UKaGYbCcEFu2vxZln+NCIBGcMOXyYv6D02s+LWwcFMkpQuapOWvBZU4wVt1yqZAzpVhXlY9/DpBL+xGfn+258LVumL70CmTe3/bI5vfGuZ3ANOcRobrdO3h64QcLxopcxvlHJ9Xtek1y/r+Z2Kinh95UK8o+gex8e58TrMS9QUdnLz2ehdcN7T0X0CyZF1LVLzq9CBuQ6cnC43lE3V9Uwh/iQPKJuD0N0ZwPssTvPKKlWas2G7WNQGeibToytwJDceE8f+XUa2gEw8UYPVZf3IYBOrhyRuj9QX/x8eScDfdyZ1t8mLsv2S8BCnXRO5T5NMLztll29JymJhv7bhWas0vSgsplg5fCY1GL5AybXNaou0NJJrma9W/v8je4nh2Q9mWGOJFLaVSLoakWhuZdGqCNX9RiAdF6tty1kypN6E7YIhRe1VlsqsJU4FpqV8Yr0Gxd8fdkJliUhxzKDbAyoINkhhAXfLoBUehTVhw1PbG2EoiwUAoU6tgED+2ezbDXOHGcXMNwN5s07nAn/wYFUSZs0RvgFbNCu10N9TqfsGan3kBY4u3DAJ46YCWprj6pNk905xuqSCHBm/H7+Ty8cbodR30DmySH7atoVdRUgDPBct5cAiUGL8o8FG6aYp2C7QXRyQ0L+mrTDKRkjaQ7A93QJ5SO9ugbhmMNpNSYTL2V6gn4tPFr5OOj3km6VlroIv6dzA9koU6JDioEht/WURf7GuJ0bA1rMRfjtGWahYVcl6KzZ7SW0gxH7bVQppAWEFCvIgLPM+lNcOf72PWtXUiEYw6sCOf988hfqGE+MWQXhj4qxyTszMQ9vv2VWnsu3BMTuocMFkHdTR6tSpswJ2gpWPbziVpmH3dqIM4VoQD5BTcn7v7wdCR7dso1LJOgsRn9MEWbIUTfkeG1lODRtZG/CrbqVEFci1+dlR5+Bb4oVCSV8iZdsC0lu4Kzc4MlTEafIlQa3Y6TQRTQEz7hjcMcY6y8Z1a3Z7rPMOr+w39RBT36JaXqfRgIhj3cpRvDw5ukjv7kKeMrlzoCF9zDzqEaTUUdery8daXKOez9z9gRjZfp8y+Sjrieg+uiG+r6fZpeTWs9UP/bKEm1AoumpRUPnhlbZEoimyWPe2O4kZVBZAt4kijt+cV6g+t1flOV8Iqzf1BPZPOx6yKs0TZQNguoyrONyWgjP2RGzmcchli2nJfb00qW1vq+lyYBbyCAgb8mHNn8mlU3T5jpK3GUHHf6e8JAApPHyRRZehfOv+CSgMh/YHO0KqO0om1Y87cJxNnObGBmLJeT+/m0QuWOt8h7qsv+zb32opjRKgK3yI2Ive93dQ3uA7fq2s+eUoRLPaHdPXeqiYHQrxMZ4+oAVyVBRLOePZa2OhI7Niwy4BMkK8XT9dk+IjZ6Z55omL/fbp52R8MpcLP2lYwXeh3pOCqA8d8r5MsrrzggkVsNeJ8Va+uYxuiyVlRYf63taS77ne16o/oK2QjHQ1L5RgRf9ELkujzeFBAwSKejVXUALXwoyOQmdRwC/D8J+wmghJK9xhAA4smp0ASHgyWFgjBG3nSYX3TrJb+IlRQ8owMcRTHW/BIaXCYwg2w/kRJfv759xz8kEJ1yPBWfGEbsH0HaeaqwCBnuQ/adAFiP/7B0QEhSDHaUKmGOzR3Oua5yQf8Mi+ydfJ61DGWb6o/Rs43g2O5Vb8qru6NWxfjj1aFkAqjyuuuBKT4oIFK5z6FGUZDZENSC8diYwV8TV4rNMfC9DBt5mrchLzqhqZvzEbkrY4RFrFQDgzKZZ+fRBttRfr/OQef3EMmKjzbvHOEfXpcxNyIz/mK9zErIbZsV4G4ONqREr/zyI8uzbcMFZq5GtPH+04UuZ9TqUImNpaaOoOHktCeLzS9sMgdX9WnQHBG7InfNYfI+Ux0SjaHH8+mstRnq/P4dWC0DUJ/JiOwSozQ3f3NMlL04m+1HFjfQIwbF0c6V/7UQBF9WT1v8Cyf1kobvCTRTWINeiavpLOzKPewfWQIQndMioqlaqBPx+anjH/rvjyCt6oFt6THQ7ESp7eyrgFBbFZ+7DQTHfLZpVVO/ALFiGvU7zyFWxTEDo1RA4oFYWyZWyiPf3PrIaCLTzUJidXPRLwKnEA9/siFhqaA5P+/D8siI8QC+w5QiG4PanbkM6t82iGSknCzzuXTguOvhAOLs8Qzqni4CCp9tA1ixrr7L9ayVQzXiAqDgjoDFpKd+T4qXI7jq4r8x35ucCPQ5NMbWkLU9/c4JgsHdEYtjlFVFbP6XaWndvoc4/6O3eeRhwJLDMP1pgdaQTPRYVa7LKmHRixgbI7xs2GzCjabmm9xetCwVoLhlR4gf9TNHdRepQwCIZYYGTSHjMowzNdI0JBUlZGlx+iGoRS9Ge9oa3gvO/bpF2iv8CYEALcTrF4p03cyaHwqRaRsCBpcWiaTmIfmmcnCexAmPQ6B7QFtW2j7xcHDZHIArmnXHy0/n2mF5LjcJl7srtAGplkPtYzb+qeFJB6jQx63U6rdb1YH9/Y1w6egZ2KLn1WcJWXQWpj5LfQtEqnM6iFlBijZ8HzJR6NAnvE9TwjVnXh93EtO7BCFp3f11hJI0T/rI0iwDLs/heSCkGr5Updyh0BzEj3QKa3jmdXSqceeTQsVQgtvrecCoWJVV8ntdh3fpkIXGju5EsupBrO6ZK26jPvrfThayCJh6lY0WKpbH4a/FfWhsXdVA5aTsUxg2pOwGgGI2EUGeIpbEJdg6JIpzcrue5k3VeubdgHN0S880nZQBA3uxb/plwvUzOBn2BdmOuoPUyuj2TOLGXuIOOmMkDersL39CNWH2qNSILdDdY90UgJ8VV5RW4JdKmCv9+4+e88hcxY6bFLRSqfRsaUIOgSi0PV9K859K9MM4WcawQwHbqxxXhxnDl4LUw8zgogM4KhWh9anZMgDUMydB6XcjMFY/9azLi/ugfQRcSfw4kS3cqZJTCjZvjy0EcCW2plGxSnU482l7W0jrOzRMqsqL541VTrHnJQusO84GE0WCY3+5D8IrOa7P01LhYokpYqViHeGnjhLpKJM+RevEysvRTHrCi0pCtKX32YuFXi2Sc+KpN/c5smdOSF+TkiuuvRprMU2dH4zfW837ZG3Egn9eUGU35MnKNM4OJHMOddc2eCpLF3h1sFZ+mJkMIlalRp/UwKR3o4Q700og2TJTUDUPcKcni09xFZybY+4XGZx9SDBdbdlE6IG3fAMd9dQBKSSOWM4i0FngmrNsdV4FagXgVd86e8WNubXjSNMoysFc0pEGMlwLn12UZYiMjYLvHpsRtlc53meYBilx1TzbryEPrpTMo2KzapPQWI00suIFBlWVhCj9LrVisRo07TcPSDnO9ipF1WlrvnyyiEhw91oWMWe3Q8oThanNwm21fQv15kMAYonzTag18FhzMQAED8kya9KPEYLFLwJPZ2NvkxysXqpuYtDAKGrtucr+1qGwwuQMafz5hOw6+zhoUx+kteK1zegoxYJWGUhOodNtDCxVfa7Fq02p9svMzhtdTjKlyQIbGFZsS4PEOoXT3W32pCUwf43N2oEjYh1pjh0CJdAmHlVxj9G1YIsSqyL3qakvp7aaedae8cpbsrr58Q0nDm2cCeST7UAeLlH6aDZuhmwMYQ0WJ/UuBJl/uv2hg7OP7xlT+eN73Dxl0ssBQ40ngpV24Azx+Kyf0HJZohel8RkIIDsi1Hyx2xk4tUhh620xudH7YHDfBS/tGgecmHnj7sLiD7d0nMsMC25AZGD7AIMpmJyHNEigfg3OfiYIOplTqKkeP4PmzcdPyx0/oVbQXZkI0HMCYw5J5pIEih4veA/LpTOcV1tmsItnagpC5d1kCMhy7PEWAboqmITJgwA/eLbqM3FJSDDI9kbcFgDuTu3QYt84mrSdPXSOEAeo38EO+7/baP32waLFcCX02Vjucw0dZrAlVVgTlpHWhQRmQG312pYf50AQJJxXPQ5JR+yYMtZM9TIy9UzZ4hNbO30q7IQi9OLxO95iQbv1X1GS/00dcPyXWxYV0VUMRkxG492+E/cPfYpv5JL4YrpiBiLAfEpVymTY++k8eeWa8uHfeVVQpBEsAubi6t/UsPQ6wrW6Ya0up9UBMUNOUh7QnsoEOWfoMW7IQLMVx2X6lajBtubGd1TN8UmxcuT44zLhlprX9cpaSzkYtLvxnaKdJo4iwrVkM4hh8EsJZq6NLsHWcBG69KeN98f2cCjQy2eUcmxeSfU4R9ZDtlmlwKLNbWbYKGyQOaPzr4nIMG/bC2u3xNIEEEhNQVLdEgGMExFX9MizytRjurSDZGXELoJ1n9tvUuskSXYmPCkw9vkshhS277ps3MNbBkUeSKDk6o7iL6I4NBC/iDcWviEIaYWcsh7vwlu+QyRRoTQPxrcSgF+R8sZgvZ3JyX1qgqZuhG1TweiH29bZZbhYs7pthGoU0BLf7xWiAuHdGVwJ9Gmqi7x8SCDHB9KMt00Rsd9BYmAI1LqaU/uoIm3r5WqMEjb/yDFUwDxHZ0mN9uDoUf1Ip6OsBd3gEz4VQQ1WBs5jRF1WEjLNSr83oi9kBzWbG8hWngot4L4Sgi7SuRKwlaGPrtV4OKHpRphsiKMlmQrSQfhwKVxM5i9SHael5iJbI0g/MDUs3DJYi4O2tceX2X5riBwBupVnT213CCe8/r41euTavcSlBPUaE1PNyaU8ftjW7PcNEZLG5A2w2YfAzt9EsO4I+ol0qPgF4qJosNB2kr5RwrvvSy1dIPHc6IIRLeAwAFUFhdC1/vb+PppXCTue8gkwxpgarB0VhxtSRBJ0NLrIPcpR3/aq/dydEPRO3G+F/e4oMQhGeKI3FQfRjVi05+9cGHl3SJmDorPBmc6iYsanwsGiJrro2dehDxlmGKkgfiyleRR61OnNtu5PTyaHzvvSfWDvRCNgsxcymiZeBImzi+6eSn8C/IwAVESvaXisrEFXGriS407Gk+qHSkgToMWHl1wLhTV8sHeodRrvewbYmWcMcGb4Ncur7j3h9sr1kMluPgFlsh3M0SU2wwRw/aBtpa52bRzY6gi4PSXQtXmBzELBws9CWOkR1ckAodptVh1g8LX/DCW5nhOAYvkdvA0H4NkRQnFH7AX23wpTJ7gq5s9wS9lVOEAdXBReJzgWXMIcYhJWcwEhnvr3KULaAvD1PXk483e9cHURdCGDN4/NIG1jtwP52LyjVXaGF+6cZNVY3Ch++yJ9fdDhPZcnBbspjaNy6vB6pDqLzW1gGcDObvGSrCawoNpMsNRqJHloDogSKUm9XCtIG5OL/VXLTP4xjJtUW+VypmsThyNtL3Su74niTULLTFhbA0uTn6xOpsiZlBOuiwMTf8JD4oXwYXNd88IWvXeJ6y3imze5DD6JFUPVY7p4NH/YDnTOTbIm1UAUVOCnoZqGCCU3v7R558tY0po4VvyC/Eeo90ah20rKMo2zvkpJTUgnLBePgWFtQuy664NdzY+CGmz8UMr5PuwlunQ0UCeJD9QAV8NESHbr5qFamtK+EaR6Sxd+y7NT8E6iRps7vQIcVKc+MtNfVuhqZC1/8y1hrY33Aihl5fOMHX/lJ+vn8Cln5mW66qKM8bw1M15yqT+okxccoxx+Wm02FwblWOc3eayReANW7x963PIVGDcpLC4E8lKs3adchbcyJX1qQ73xfb1AwSqavN4HIcnhP2MMTj/5Lk/dZ8lLj6Buza4hf4mQn7Xd8CrBjTpmnAptwE0JjDTIKSCcNp3yhjm8TeddkrCyX2bNOEbNPgOAMYhCFQO5kdqoiiEKxuKxgjlld0T1A25ne85uk5TzkRKRnwEg8hr7/o4VrimBcZCkBZluZmAV8D4DsClJD+EPQpvAvKMekTDMXvt3VCSD3iBIA/0OGW5gOL05Lc9NXhOO3IwE6dxH7dtrjLXXgj35kZPUeUiludaKQm95XqvIfDda6W8GZg3P4P1eREKUcdbDHufdBLS/NfDRBQaCEdqW5pBfJeK2C50Qx6zUZTl4AYYHVFmzvsmyqgY2vWCx+crlcD9/IjkoqiKZYuQBat9lMyd57xCjfO5QRFteBLJ4T0PjHmAas6JaT8AsJx+cRpiAGoYvgn4WUc1XX2FaiX2xpDkLcM3FjTxNj6oTEzsw3XhZOvZWeaolvEGnDzKiyvFfv+ASTTb7Usq5OaEvBXZxsomBLGksO0HSPIS6XLwsV8WUiPBbYkddA3evmkzcIu2Lte0yqhIZB6TVui4g4xbLVpKbrdlnURghCYFlTnckSJOhX/mf1wuxV+nB7ftCR1wo/4amylHYKPpeKmCVX6Gu3O0Uqa+Jbm+Riv8DzcA+UuyYh/kfsqNR8rPgCtu7VhrPT+79ySOWIPj/FbU7XNh1RXkswEZ/crcP2Lp2RQKnufXpY4/GInx7B4OyooYe7keIf5Xy/JNbuCwXo5temHydeupS2UBwlQBpPM4zD5l6e/Fv114rynyH4lnzZITOe59yQvt61tcWSnZrDrh89zte6ohXOL8eO2tk1dPf2kTgCoAmpSpy+AUxXC8h1jfbknAW+ZE3tiqX6FFXevJ3LcFk6XQIAtfa1X1pxZCKKOvA3+JSerV+wASKPEBXVd0OsLA8wO11YbCtgcPOdXsS8MxfbdoUtpR7RHj45YygQQou56Gsity/00Y7CzOfMSPyx9hSn5c79fElQkMBZhCtjREojJR6n6kMW+sGmQuKA6wlW5GCxE445kW02NwnCzYuXqfiwE91V3iBq7t4YQ0tAqUxRr3slOuP7tsm0Y7+cQ1/X6l7RHQ1/+FaKCSH1tjJGaDpYSvjkeor/dMP4s7CIHSfP29CEbOWuul2uxHLs2lXaxYpbtyyRImNpZoznu+wjJqSLiSEaIrhvpMkiTvMmjDiz94Ln4/WJldHKp68NEEcEra9ilvOACxGYspAiBf7g/HIp26AZZlzX2aAvxjHtjYYOlFYImOTJ2M8xFVCFyhX2oRHGV3T+AwfmyMuA/Q9v7wg6XzaUweAKKUXP70On6//sD+e2xdP+nWV6rLne/MTit2o1raojVUsdhLcruyGXryjGXIXQFTMwLu+gd5sDwymnsnD66duQHHTZEEC2ywlHzJggLk8bQuOXBvAy7HQ3FQiV9pAvgz8y4cQS4uMT6efFYwN5x0OA+tniM+SzuXB/YM6S7F5ujM9djOPiMLU9jgp3VF/nTrGoRVm/cPdj6wBxpG44hSj94vbluXM46xnlTde5DfyiWldQfxwL+fguvUcL4qJ85piTm7qyCp3GbTBQZsxSFkz2m8A2b9uG0d9FA8iZZmQfHyob/834EtDC0nSlqMZUeaBxqiiYR7/gCnyTnMnRxFLky+xyFLPUOuG32PxYzMSZbmZdu74boryieM0zcQndvn/8GaqjcOtzgKk6kW6UY1A2UIHUemnvtmnQiby81xrINXalOtkyeeLwG0HTRuAsgQnAgtsRG91xjJk0iN18UzIsYgZDEozl4Re6AD/cFNaNfwC0+uzckwO0Di/fjGGAcT+8VOfoZ3tgjiB1l/yUCup5W/6BnPZNx93NQVu/K5qLbxkx7ZNR7oZfOKGNAhnSl8rV3nTKGhMp2VpcRg17d4yLNIX4Yb9BCdcTjmsoo2G4W+koy65nbNQSk1peoH8RhCE0nuxp4IL3a+JfMktsQTInvo0LV0VOcoJbDb15M50asUiEjKMvf6V7NrhE79GYJIiER9NL8OkI/Mp6zcaVJcAMj/kEhB2l8upcbbG2QHEGVqGOHgf+JTzeGT3b4QF64reCYgRuyy8LcXLIr4DLaL3bHFCDDCAQTZAKUPAKMNTsGmo5VmzRk1eb/r7H2SuGTpY079DkyYpSjanyAo0SHVzX7fgC08doXVKerSHCO5xI+EvttpFbIQzkkjTJNtCteU9IsFUN3/c2xiKvJ9pxzyERxaGnacv7TaOuncxkCRCwpkrWycWztyjh5Mke1oVKXOtDdvUrBINmPslh6PK6y4Pr4KkPTlct4ccsToOvgeeGXrEi4j+aMvN3vt7K3rvrQqOBINhWw5brlZ8oRJYAHXh0AHrvIuvjAONoi0c/FR+vOfHm+59TxqQj3PJvWILPzQi97ypooMa3mMHh7oRwNanL71jxOi5DvnFzKwiBnFhlynwvSmuROPviSMvtClJ9bgAc7ABp+br8MYzEuFw8yMzkCHEDsoaj2SMDemATVbcgAUg4TlOXjiZrOZ1EJMlV2rhr+U8V+n3gQ+Q+mmRZpK3w3zjujNhRTYLsXDctcw4JN8qpkjv7EeeLu7Q+kp4cQpIK5pdocj1pUyZALS4ECD0M9vmkf8dzDcn6L/OHmSfQFTXAVBNnjwqLz32ZHKaeL17ZxbjRsuo0olK0HMe05NEez8O6pcQUNLsIsUe6jmBtv/wDwPBu4D9Uafyd8Rz40yKHNgBxfRz8ny6j/P8WLA9K/FxZdD+guy7cAa2PJcQLumnNKaV0OiyRKp34C7LucDTQiAdRobPpU5MoI51mcDvJE/8FA68Ldab6L+vnJyKj+P4NqqGDu+k6OWOo74uJTjYc8wFTJ/HDb2YqyDoI3ALJ9CAonlNibovZb3wGXDuSYvd3TnoM54F9tMIUGo92KMsztz6fgsLdXlsa3m1Zpu2SOqSs7Aj9bjBHuLXugJiJYr8NSmXLDNZmb0aw7fjXTFFJzHzqNZno2RcoOY6ykcSL14ed/BCz/02L7iYyz3aKt5lm+WaRH1PEW8ZdkSvusdobLZ7mFGpkU/uqqv6B8JGTSNogodSLEsl+yOEL1mvuVAiY7RRUVU55Kovw7FXoUPxSWZBfdr78SS+WC/Hv7Fd/zNBd3sMj1vDRgfCexfD7RAmvVh8StnlUWGB0jIDTN6WL6839OJOyGodg116hI0/WOP8aluJHJHqcYeJm7f0s9zMNrF1BKRBUsllsKOYkUnkBNVdrHJ7rVtzhRnaLEXI1PSrILDnU2EeXCWx2onCeQmegjfB41+naqtwRzldGpexvCjStEhUSxkB9Guin9lwtfeg96xGiSJdG0shET+2WNBE6cZ8os6Kri5kkDIwdDPuIoqLlJzCkhqYH8eBJmwf1Va8Ll1zsIF7Q7CL2IRC8bGcMRPiFnrF3O/l8NYt8vIIqEiOcqFOIuPacDeyGHeUGQ7YfZ7NcGFIojkY8KMVrOzoIJKh/a9oSgrhAv/2w+MBOnviH1maQKKkEdmLDZUgTSZyhymGBAeXT8nPyqna0pom1dSeCjA5wLYPvAN2dGxHvz9IeWuGvIRSrFK2AHINa9CGLzkSJDS1mCS8A+Qv9iGI9FVSRGPjJatQAzBogPWQ7JEVLfwrTkYU+qeaHRtbt4AhU1UmcHih5gw2TXNpjhLHaKjyW9DUd0yqlK4EeoqMrkot8oimF3hvIvaShTzhi3fI3s0+voZe2Te0mrC7WDHdD+StRTBqL08dm5Z8cf6b1tbeFP40hKiS0Cy0J97FZmbBgVMu+jZDwFuJngNHJEPsyG7u5jWjanmkLH7ikPjsBEZFApS4hQtATgRwGSLRbk+l78VP3b4eutL9vCSB4Bu8SHjRkpEmu4ISOgb7jgHHhGVIbLidiwwfXb+GjCPhatD10pEHe4b/ow6cSpkTNvmGZRVX5QW+p3bJamKQeRjxUFcMvHH3fDeiwVqeKIccAq2abFxUmmihYiGnTjbR10zE2siObMVIBRmH8FNBOFsu2T03I2bItmt7vzUQX3cn2/d0YlUzCeUKaFLKohAgd8AyV9iHra8PAbS29FnpiocDH5ISS3BvSoys6pR7MM+zTkJ/pCVmnZl4UcMHTXSl1OznVzrUW6d+IukTJEbnbTgBaDriEHnc+aBZp7KjiWbMuYITeAvquf3YNuoMT9QxZzAoUx8VBns9EWvIdzlaqjsmnUbe9MTDwA5rq4IGrlEx224EXdDMg0bq+YHGwbr5sCftC5l2uyy/4UZvmA0qwZSDBhyGfCH6ZR+VMmj53fXfeDl5UcS/AVow/A2BFAy5zkRh3yPYiE0oRn5liuzp+zoXQ+MN59hTdbyFJmFCgmsjGK7njHeFs7VXPBtkl0DGI6yPlrBNUbZfF6tspMwlLTDyzllg5+jUFvovBrdhuAOsVUYVvdGJrxHdFgSqqcbOLN+mGFUAvfgs2BcGR6L1x+OKex9QtQcHa7P795ihzy5gNhNuJNdFeTqfPJUDlTH+YwU2LKqy3eB5+wbnxFawkYWbe+3HIy8oKAOyszUdz6j0GuEiVhs0bsaD+KNB6amnb7cJySLDKvuaMGUty56DJ6FNWclzSMSSGiXtVVIqIdLFxup5aiJrHsXFSQmRl3Uh8BHaYDhLQt/LC/nUwCaT08N5gZQ0Xdsh7d610gQdZYkYkZ3Lv09Jx9ZXesKeZfHlCc/O8dMGal22+vVAj0uc6DY5lBJDlaJw0XXVvltaBiAdo8L/hAx2ef7z2MU6H3Ny9xHxJCDVIyUWvljn0DcPfDsYlz1Q8B0Vz1xjqlltvlODETOaB/QUuz+Hkoq9R8MoZLKu2snN63fnPLieMNFrKUKYHBR6MtlqgbR0dIuONoZHLhLrIX9ij+sLfoxYHweMdtJ7CGB3PXrvLaJ+PSduEtrqr//RGgrcn0JWaYQfX1arrRBMtFUAZI/aIJ4jyRJVkIYm78y2arzZ5JwlEt1Coc8wIceKl3vQp17a0Ch4VxkKYI7kzkYoHs4VY3PnyQvfVYUT+NsdV5WnR3XWK1anrm9hsRBn3PKC4IKYS+epmTmgcKY278gUp7FQHETInNC0yWItSpIBALnQX6WkBKDwarkR1rX/zL4p7jVPhZnDORS4+xbQGuLYa7p9QQeRvLpxPgdlQPoaz8ePOaBtZM/FDNYKPSImjIAaLbTf5UjvSI/mHPMsAq/HCtuL0tmK+dajFn3vFYaoBF2c/nvX4SrYSThf+zO2v1L4QTSN4lLi9/mgvQ1kwtkYTUqupkDYiiSTI33YFLHWPEFKOFpAnZfb5/IpfvEKE9ZbKdLAUTiHwxD6dkq0FAlf4fq/dAg+OT0vBM6k8sykgvpY509nEmBFAmgZemMkPIwk7XitfL1fuzIh8/LP2r9ctaSCC7DszZc0K/i/S1id4YwnGbwLCR2jDaKyM/tMbvv04jlHVw3yb+oc5XAQ7fiz6X+9QEYS1lHJ+fUMhLX6le9tDLCG/LQV5tv5F5dwSMe1qVDqjkT6rgiVuHeMUJjQ4CuSiD8GoJuT39quxtWaMxBjIUytdULveKIf/6M8g7086DekhWLlUMOpRBUuqKTCUr6uCgenlXkZXq6dowPIAmNYnmzDHnOZ2sFsX4CzRuOopIkYhhwg8XoYTMoFVrRNdSqO6YYxvnbn48+ZkGEnPskAuAraBdN0oDi7o3p0zB7cQ3RzZRgEWgb3TwzBBqq7EnzmlGibxyCrM21LIObo4tsFjqaARuy9eFp8d6wVMjvyB1Xx+d6L8iRL9W+3oYpAMIDf8cwy7SAUmDg70hqewMGqoIiPqHlpfXJ2zbA8zMK1yYG22Pa2Iw+4ZO5lx4r1Pj1jU9AD0IJ43BL/CytIpMMyQFOGObLpwREP7nvEE9ewaWOPebu599Nm8vZTBgX/PhWksa6xVjyvfMB++RRZ1ZXrCYLa4tLpMkEgaDc/Ue6UekihCg9GsF79DWKBVHiCwFOmD8jfBlgGDxsMMxzEYufq2vccvP1YBTx/gJ3vBrB23YnX1yRluQAiK3Vz0CnMyPXWiVwKUNokUUubrkJEXcdy0ZkebvuKs85XKBCu9iAYYLaHyT04c4/FnnwLkAowFM+BgmPKu6oV/J0m1xYvCS+fTf92huY8bBIWfTnsElLGga9ETkiSbuXuM5B9XI5B0dPtt52Pz8tG8A0Vtp8MnFhTsZm5DHnnVyYkoL//rOY5RS4Ep2TjR99b48BsZLXmv7Ko0gcu2wQGuLhoiuuPvgL0L75ZrkdX/PMMHUlk9LPQb8tMxzgbpjTjWpXRmci9dr9tOZYLoBaY3ZvULzVcmarA4yXPbEOk0eMuqGVK6dK5IZ3bVvJy4sybnABIzZPgNXtjYCOWpZYrO3z9IVP1Egm3O9QrIcG/i6ZiyluV6/fxYw2MokwpCWeGza86iADhaLW8dCerGYkEhixazGaN7vYtdjlCWKMvloSZbUM4e4pz37A13IFqowFX6+0XuOnOjOLzI16UyeAYa6MnNcxJ0fSr8J85ujkGGhfDTesfxYBHuEGMDpZBM4VK+DajdIrOi8fFEMK0ABQkzMR5ym8pF0hfCF3FdMAuhRhwoiT+LWL+5CMNQuEioN2lSFFf60WppA7LrFpAdVkwW7ofKy1Qv+6MNHzudWlX4L2X/v0XI6Dy5j4syx+RsWGQ0HTUXvORDafjC2qVBLxox5Y0hKZxaigj8Fnm4LrrlaKBuP3tZVOCU7V6uBkbV1Jmc/feRAOD9Z2TobM4LnSoKEqwKTXpFPlMxFIL+0/zLN9r764QAGvSv+EZNPxaZ6jwANFkxlLsaoF1/Iq6+yYPKYF+ZX8iDVFBQiiO/doSvjUlYYuKBfD1jw0rZj/HwE5EfyBVrWoHDA+kyQXt23xTkncG8lRfFrkvsPiSFTFD2HJh/utCQtRRw4Xhw9QfLTMYe6RQPIix06BKW2gU9E8QvcBJRgQnmCdel7KQQhpdlZ98WZoy9CCgYfenNgu4irhOxHOpvnZNYNR3leO4ysp5C/RfTivnQ2/noSm9MtqjnI1TDxxLwG1X4QgQLa9IDhMwvPWIQnAlgCx9JbsDc2tWFaIp3Ov2gNGcrUyczDQIUU2FoHPQdCpPWlcqGUnjpsDRer/WylY4+kw1i7QAaS9w//d1+QWex+zF34c0sjzeRiBrY5UJpVAsO3ZivpsbAYfnuKKn5lGrsarsT83EmpGHXgnamBHce9AaE9ewBdkATjyPyGCO+KMY1jo+30EpKmyESlaRCtmrlN4DzRoyEPoAtkNfbZXmnrlgO0J/H2hL3R0H9qg6J9R7B8OLUAE2iUiggikF/WRsvWN2vfU5Ixo678C78YlhiORIjaqSSuBAemnoBUsXXfxa7eZFmSK1lCbDJlJWQiNtQUSAOCPF1y89VMCEOHIPKN3NsHHY//jewB6NmEAF8YZdF3ujJbhL/p5GZ1fJASIMSdNT7ftZAJ06otAaDHi1XLDc9+1KBpUdZQ1YpHDKirj10LyE/wCTv5y22fs8uvGv6fyVU5Zd085d1Hqbu9ymd2CpyHdlypePWxEI5iVtb8HJOJgtNjM57yaJUWYFUnOebob7IYXJYRrYO2R/rmOokeiMgDkTx0y7IVFDmmzBMnjro4p5zjuMWct/e0ld+VqgwABHv9WfEeiFxSDr3CWyavF/kaAAAVsj3EbERUeJFR/2Ylh+k+V4nIzaSi/vgGbH36sM5pi9F+mf3m9YswR/cBmjUErVusLa6yBMLJIGY5Ik6qtve6vYInNsby4yXDSJSWzdD7ohTEDhHhd4Wf/bepXbuJ4AhMSu/44QUbc8FSk/rsYEV4gMOd6bqcGouXBqilwe7xXZvxN03UXn3jMcJxjyiQSzsNTgYKBxSqvktZotewKoyT/lpP1sLdT2PkTGBjQIs8O/eILPSp9qGqnj/H7bl5if22vG2fUl9qKzVoo17ToHDHpSQ2d3NzMfTK6lHISNm09d2fR5zSjhdfA+uTWguYUNhLLuYaMA2wun7Gd70N/ZbmIiTVN2UD08Uh/VvEyjG1hqyzWPcEz8IQ/DTqZm9h8pDeLSGP58U0lImLpC8Fi9kFCsLFhKC7GLCjM0UlD3rs1LkMm4LBtF/vvGN3DbzHHIt0i4/19ocy5zEJMOFAFXQ4xjryWukoZZixl3p1YasxFIbwoQJQew/lUoNf5eWF28VEsfqViI7qTWaQawukBstFP3evdiVspQNynSylzHcCSoX1UcYY2olzHtAX+C9Q6jYhRK4b9ue2If04cxpTlinwKMAkY9AdP+rg7rG13Toi/5z6ngCcW534KnLcMpCj8jB6JnPhtr+l2GrVYHlbNlHhbO3iqUnMlLEcdxdcL23bKO0LGN5XxauSbbxB0jceBS7JF3rwSh8BqHKfj2W8InbmVVb2X9/5JjVh70/IAabmRMduUf8vmllFNA9G6DqaLn8giYyuvpT43iTKAlSfSKgzySgV3Y0PrVXE7H0dQWdgvk1Z8JyNv79pTZ+pEqWsknnQp05+7AKTdi8drNxFEcH8seBup3JkB3dRY3tDDx+RO9Q4thHwd2nRjCLT1N1yJPkqECLwTrt0MIZoHJeCqunxS/C5mV0TuBfYlLAvqDnW60OPLuRVaQJybk/wzW3o8L5UXOSuM/9/mcokmqVOxxh62auuN2T26TJJNZulw/k8SArWnAe5PREmHkwBPmBy6pQQOaDMWumQ8hDlYy0muwAG6ZV/ITguvDWJ+a0ka+afrq19N2hWs+eklLla734kU/yRXNGIMYB9/hROZrcgNemRReXLTrX3CvMTZn2gegmPpyzIaqcc14qlDXMX4BlbiW8iAl8BpSs4bTwWkG8Te3ByUcLwhTu+gMkhD/YgP/edQxdqMhxO1jY5m/2iMB4aDxOPqszgEOVT/zBiBxqOVmfmiYkuoC9FfArlY0A8+R7BUeUmIz4+ksFnf8Qvxj7ISUviYlmFCqOKFFqgsotiSIrECODmmY+MG5j1biDR4SpZckqQZ2UXhaJZQeRSxZMf47UAVUQnIWD+13bccjaZIKg3rivqG9Q/E48UiFcZ0HDFs8HjenhNGgjRxKEMsV1mQe8aEghybNn7dixWjc/sGnOqQbQYEIr+I6sF+wLR0JUQvrwQ4y/ppD/IuczDg8W2GX0TA801oPOG3ykN//AonK3IZt7sZeUVgAtJQjX7MRa0lwNw5wCONSqvYUE6iU8V1TW590QWVrt3wPPa4WqlVZCpkkUwsZju1hL6ptjMY1qeyEShzZaqKRuSBlLjaox9sZlajyLugDYuwWRqOpRHANQ8VEmJOzhybItXxo/3xjuPEuYBA+XIg7XZ1GfXyWb9KjJ1iT+flEYdJUA+sUcj6/f5/Xje8kRqezFutc7PoVwBfpAZ9/kWVs3EhYhLc3Bz/hCDH6fsTZYeW2snZglJqKUj797ZlqEmoLm6F6JfYy6cMEW9Vfz+x8nSwy+/OrVxawGGTGz6ijdDoQweuH3gpM73gP2AzXZuVnjRpTaGXPdzxUHQwteYnntaX3/p3TlANo23i0/eyEnWBxWEg7bY+cVKREfZTioWDOjKl79qcClvU6c6uXWOX7A8w/hQzTiTzDfSwPAuvKi7BmOMiM8VfGYdRSlGSKNBRiYjneL0j7sCB9FR0/XS40UCpoyKgUjleTjZofQnWMy+9ox3RLCBrS3yvgPoOPXxpJF4sfDuDVj8UZioFrz6gFvJve5oSwFSgY2I3aF6m6PyVmZ6Bry4xew8A1icybeQgbm1ELKvrMncTGZWfnBjH+JJYgYz8m55uGUdrN4Itn3j+m+0VJEu90sjRgvmf91JU/abaxnTUeBJHsg8DBkYhuRbmvmfUMEJL1QzjVhw5YdAniZUEfYheA2FXWpW6xFMFrzYRElGM6V+fa+gkZCcy6rJTl8VPEtlMKKDLKfNAHbIHqaiqKYecQyGfj9RAGKZr7Kp2rcdRmureimVX0mnObEI145edknSxzsD3HzkCtrak7pqMDdeRSVZzMmTBXJK0lTED5edF4hpbWKRuWEeHmxDMQEDs3xcSQRTR+d5fl59Okq04Inen9pX5DlXXcru7dSvyaSsqJroDvMrKpycQMSE2k672rroQ8D1ZiG/WhZzLP2HslefZjnAI0WnSBVsaL67H3w+MbSIWZHExIhOIdkQ39DaQMdlwXoIXbiifnTuQt5HVb8Zd+carC2H/ar0gmXJQ+8MH2tPofc0zzQLZOHjSZGnpu0l6qv0GC+mgK1UlCgv7ZA25MIRSKnm7t5ttQxqsDuPBjUs/qnKA+U0tIbkNz84Ljg9P/JHRrUE00MwYIT6Jl+SfKHk3LT+0SgVZ4P+FjyBeyjPcxLxTvXZLKH2QlOb2BDKgaJVZgCFZXoB++v9b0fbri4+B6HPoNQPeLo9WOwzLuG8V1KbM57CVK+ln4jlEmchqzh3aMss8lqGp1uH7AU4xoDb/IlvIcpqWJJllBBQXFan6EhIBZokkwqP5Ep2g9wMXkC+pnWjFNqhinZaHVPbeiSlzri8jCBlwJyY7nR5ZlQ1zsFzHQMBrti/9j58DSJdK4/fYm/ugo4Ro27jdjP6PrhO081m/E0Rs08ujFGSEmtOtzl9ivgzNsXlf92+dejMfoWujOQCEHt1DqD8t1fDQZFkKVxWxv6LsTo6ap2jcDOrK3JPfjkiNPIHGKRQare6dLo6N4Zm6IKozeJ9ijLv3GQcwjFUhWxwvDbiz1Uc36t/AC+A18LKQukbTrcW+LXBKJyQpx7KLBuCSziPJcZ+vYy9MTaK2C5L+IcGMdgMtLlwX9+d09w7tDeGHiG0GZ63DrmxyDZa2JVP0ngDnlf3vOGNT0CYle3DfMiHDtuEgPlV/neKX8hwRBas4iHLETHUBRguamHRE43E9RWpb1sEBFD+mvGtVrEo/EZArUtI7tjXrW0JGcgEGqTQNfVPwvRwPPG/2rgk9NbRXlJVc96JMmuxH7YW09mnj3jFpNwqR09o2xGe/8VRQDd9+B+xbHmV8VE7Qq9OanRmTnkoQwfhW/GuyA8r4h+yM8BZ8TsTttb3gltLhWAl0uHCJUbBTdhqakkXZyu888DJr05/FKm47RnukXxwjh+Y6SsxHlSK/fk1UzT3oPjBtMI2IeYJ09N3vhDQQXv8/HXvtIQPTr3Ap/X/l6VUP+Lop+vEB9fro0a7Ko9RG3b4Busg/cE8FqveC8mXNDbJXhibs7h1thoCtypvB1fAmefsjG1CcX4w/VFLiMYRbBWww1pmJNEmuPPg89dsRod/r6GXaaD3jEXCV9QmtbhfsScrPVWhSqIk+pi0IDa1wdsRtApN/4EdvFgQhOGSxtrW3wCH6Bd4fZQatum+mTSxhiOER5bhx+n4wAIfjCFsIWv8gvRtIVZfCkHr4MVOa4DNH8FZ7os9Vfn78x55MVoeaRN6AxMC7MuOQjYnYZJuAirmMvpHONYbTArotcLJCCyshhOux1Oe4l1/N8X3FbNHCTY7T60ULPvmiHAvYz/5ndmxe3m15okArhAy5ob5DNedEGzphm3z/q3tDdMISY9S7lX8Q21CrXAhoIrsZibtwTsf+5HtF1tJGkqaNH46Ejypztfe0VDcBYLLyGws4v8WeOeRNxWyYg2jPRgNX+Eu1I3+YZw51r2KlPnG8z4ycCfcS+SLzxMA6TAwp1Hk5SHOu0WlXWi9ECOZmn5u+5XQjipF1AJ+LSg8orDwqRoNRhTfOjfO1heESw41oX2y1/qREOfhszOJr1Pw1UabWtqf6kIL5NvRd7TDR+i9ZCoJGur9jSrnkvn1ISgZ9uZBMMZTAMKKUx8UBElw/NMm8qbGS/kjdHaMYXwesuHuNnXwG8Q7l1Vetz7XPLobBXyC0kNVBzkUfKHMHkxlRejTWuInvxNn8/A5elqx8b76N5Rxj+qeLyJzpvCbWAfJacdYNDoDZ3ChPh0iUXIbEro7NW6jbhnZNRKFcHnup01+JCsGyEcuOI7jepUiXr8V//2GoHW/OYWSG9vwvYgR83k1MYYSe1+OYgKarLx9s+3cWGBdAj2tAgdN2SmxyBlacTH3EjF4wD4I86vpDDCoABP3BhXEAV51HYnFcVLKmXstOnvFFOFawJADxC3KUqeMFnNwNBHGmWw2DYWa45MFP0jbiWODKGG2okUrC7nKGNQcewPOQUHe8DQvOc+pHT/+NIsn9E0yy2fshqb7wYbmIyPqfV9ImJY64Hf/qxcMXdTsrLaz5OKyzUwN9SkEq2guiFCgqAFHUlNQyvowIpFpjPnkal2kfNICCkbx2CJNsM0lRp6b5hWTHeifDmAYMxyBeZqWVqRthFrDuv7Knv5CyMjJbY/vu2JHrdxlHu6b8S6rEt98ooMIfON+TW5oNX2Ge0p6PaANdGInjAKJTe98L2HB6Cd855TFeyO/7kr+rPCdRNHfCeGJxsFNqnRgH/msIee7P1r7UbIeBAKRReooyHrBWUhLkRpPjDdkdIotZBZY8OzARnL1R31XPQDJk4FA4OQGUBNWCoqqbStdH5zpaSXlQVWuRpG1GCFPd7lFGqrufTHByZkD67/csXC6mDLgV/kAZFM2Qm9hDecgozOXBjd7vjVzC5UwZ2SmoiFcq7BuD/H7Kvy/HiWIfUzVtMGPrClP2vBPuTTyLU4TXCVoc/pMjMgk2YJqSc5HgsXG780SosHH0b43sBMbpr9UfSaIXa/8kP6zAwKy5AIrJY3WIjPrPYpAKkY429nPSFKdHGWzrCKLEQknyh5OH1M0vlqBB/g72XBYoTdQCS5I7M/LdnOEoTrpirSq2bSRSkwC7qHRasu1A3jJqO2KGnGFHZpWiU5I/UsBaJVgEgP5dYWtdsvy/j7C/EIhg+Mhnc3FGZU7nns5z1Nj7ywIeWvmldZ9vMNUp4Y/Rnf0Ydw3KUtUPpuvwZKoza6zPM6JvvPu7d2q/Gw0yqfP6WFq3c/irspi5XOH4qN5IxheMaE0frh6cNvd4ldlvp2+IELMhiWKZQUndKr7BdZTapIpRbfBF20eKIsnk220H6/anp6mXnlXoAHdEmpK45rtB6/dKSrXuNEwfmbdMks0dLuO0zndeB19ZrBsCoLYAJPejXF9ncFK9F/xgB/Ksmu2qMi4i8FrY4MIbA1oVmEGgUY1Omyc8cMkEhbYGElNc/UGdxE3VevD56xSl5lxeQpPBdFcQgENF9yUkWg5wRXcTV9gTweWAUrCzTbk5ZiksgyUPn9CKvqCDcOTM9sW5FJFeHgql5Vl+80EblvPg5bb+ytZDGMwljg5Q7Cet1C21gka7jGfC761m8XjY8Lcl2Ca2EIRPeyEiwfkupMywusloC8m2Xza18R+VMiFDHKjA9ybEIB/eevAc7lS90OrPaUOCl8J+UmtYF3355k9fGa0Psp/R8PPERnksN1vCcAyJeXiMMtswzWL0Z29FJn4pYB7oPrDhSr0NI8OSbe2l7fQQrP9UEp8yYqc7OBFu1CsB4PTO5CJGadAP5X6Ws6ly4Q4EYFKTTe28Qg1aJz36BTmoDo3iQKm5F/7wiqB31JBYHhtwhVKxP1O3oxQJeW79Fso1jPktWZ6sFM3SoCrLd1jHzmh591XwaSrWNX1xxCZxVu0g7/oBXyBCnLUdiilY00Z2dcrCpZjsTPip+YWkLQZJgZVLSgLUKgur2wYhXINIyBDZJKMS7Bmb4fGbwJXYmTv8TfpeoZPwsYH0VNKf5S0iSLi4qJ7nZBz7le50ZOkX1WDg5IUf9yLRv356D+r4IEhFy2CKg+W4QZUg8rdfbW2vKbx2NF/QB2Ow0nTtv8HNhKdPcPoPYesSyW69sRD+0INLYQGfCj1H+2pcnELKzsMhRhKleKPaM4OKI3oA5L4JcfXIlUQJogf6rcu4lHlpF3kSuWO9AhDO57V7laJSfY9UEKPqdxu13YPT3yv0lyUBodz6kpZwuBxD5roOqC68a+/VNX4ZF3/pnqg37Mov8nHgUIJJJOIl7pzmSRn4zWU940w+y0yCJrN+yABhSD2yOzgEjgSqs+zkSUmoMaGrmH1TxmLTSwRMq9/UZwTAqh5ObkHs4bMcUrhm0OfSU3OvCi7Y3VmoA0rhNhsI2awY/BOx0jgt0JjSoTbQHELJFJt1vkYb2GWg4M2A05I1RhoB8otTocS5S7Gj2VAiU87Ndi0sfQj6F+aBCaA+JPoQ7IjoidrcRw9f2JuzHl4pcEhU0GgUIIM036dEHdpJP3TzFReifgVUQON/MRsFU+U3UCqQFuiNjy3eB0DNAqylyf/E8VmGvr/qCoeYc1okhWALOEn+IxdAJYZO+VfsGiPT0rmhFQxkHSQA0BOQpauPbkg61R1E972aW7Y5K4EaRqdXn+GBQcMPlkdYvhU8SG2CN6GZcLNJPir8bHQJd/cLgOCy5xRN6MTrA7uaqMsMtSmLDoHBKjyGWZX0C3DJPJ25xw/sIiF3FK2BheDYZQM5AXVgYsMYosF7+GM9c01SO8hzvOC2YPbvTMghiPVKO6+5saq7DhCezoydqa0JGIdgWBBYiyaZ6lsWvC4grXMfAD3TjvNjK3D20xHKKyMeDuR14gKiyNou/qKvt/aphRVEHii7r69+SIhfDfkxXGOIxA53wkexN1TJML7S0s6LL7PtoUHOGni9SrlILwgHCO4WFcz8rSfmJBKes19PrUe+tnvb7JdZPs48Idnp3LX3JdrRHCdXx0pcrepbiHF+q5TGlhs541vogHz+lpTxVQuNsGsHEiaeaIkGOH6MHda7a1R8md9RXNcaCm0lvJbYHpRWgxZg9qxeShfrJ/Z0M8m3yTLkPkCraDTdThx8+CeldBY1vtriHzXpO04atChahFRYXO/L4xhUhV1BH+hRIpuIU83N2VPXL/f9JY5Lke/v54sB5q/9yd36vk2tyqld3xypdNeS2ARo7pejwsjxb3V0ANTP1UaDqghHYlQDBeU1syPY4NGgfn2r3z/Ym2+ccoinTmMbpx8hBvVKqxy8arV4G/FIkA9Xw42MyIJM3lms8PCNdDcXHwO1DOVZAYkTDPbYK2N2kKL0enEwOnNezjexkh3pESNOvk3FCvxUzOFf7mJX02IcakHKhgWQAnJUky4EGuQrpyGh/fcIR1/BYWcX0d+n9MDJ+KaxcTT9fkNQvHPqpo+onzsIse3UlxXe0f8pYJFjOnCh1/krVlExrXMX7EGg355fzk90fqxqCTIGY26uXcA6yONUyc0GgO180OmEsc4VDKFXuBw8bQEyOFiKqGV8JuwQ11uko1UIHoQkzfbuUKSrh1CAooqUFtUcm/ioAUQjoPugoX9AQOvF4yBIxgG6InE6nMEkRhNjyL7+gillCs5mLDEa0oy0ZKBQlK9TJ0USXtqB0WCOhDh02eQR+cw3ahznaS4DP9aem8bTG1SEcon/pqxOsRePXIXoW0yVWvUsZSlyq+sax15dD1qBCz0813rPpS1sZNAFv0/INUnS6q19Fgda5MAMblNeqfOQThaKn5e8ogZjkOOr32Oi4QbPwPuq63/OQ+4aI6+Oo2Y+XGs1yIRVs2XAUsLt8j+XNBk/l9n65tzCsCF72a5BaA2bpmbzw/qV5EN6l2IgrxKuFvGeRP9W9Arh8WwKAyEg7bV/fClFxyz0+4dZsAIjQRq1QD+j+G558VuaLmr6pFiAT/RmgIcNRTkVHz/qmvMXJ/iWwkT5BBaxnSV5g3f3nIk8pr+Xryc2sxZpvncBiGg+LrwtTSoThL8xWU7aclfgQcM+jDyYCtqw0a8Rd02e7x0DStw5HubWJFeY/DFOXelI3YTfJINaURMyDbMPgcUP5xVvHn7NjGXedjDtoWFFJLexhJaI0V69ZzL/NediPk5xJBcGs1pakBPQCzskl0vi33cl31Z8zWOTOwW05x75+BoP/yM0AJOcLEzzOTs8VN9KoQ9eO3V98D3A6EHvKYSsD7KYWXsE8bSPwFtMTNoSYLxfcIDMMCpr939Y0dsTmBTVjU80xiaRyhASkipqsVCrip8/Hnv8fvY2mM9qcwycrSXp368K1k8lJdQS6NzCOj8ycLUqru3bac+0uHz+6c3h+z3MpNIhGqFYWANVN6T+zkkAXlY3PBmSTLvNQgHFsTJLWDZoaQIrofiWpwMiCSzXFX4HepftFU+gVbmNmIbu3uVE3UZvHx8vp+Z8A5df7csgOfUJSOuZWFxweBDiaYqlkZcFa+l+hrr8sb9//T26Q+kp6FGgzsOhvvKQTptpN9n1mPqWwUUvtFyMqzWDD/Jol+aIiJujEzdqWM6cj9BY+T8oNqEpcdas5EElbzKEOdKW9G0nnIUGStF4yHbykMq6CBT9rgjzJNR43vwVjOMSP6JetItiPrchZu/GXn1rfqoY+90RBVffPLN6DmxZSj9u4k99kSa8E3IQkkPMJEFWBmvYiJtwe2DB5v7zLkmFhH859gZWQBqD/IOrsTigE+PkLC38q2MQSQ71lthOXCJgzqsrkxiYa0gAIIWJY/Uki2pMwLqzjpsEIvckPdFYUgLmJAZQUPu/3FM6wwY6nnhMPZBve5wNw10roLngdL+fdur4hN/53TNDuomgafAUc/0RJ9W7mV0qDHh25RpgjlPBeEhuM9kcjHXe5LGzBtArYAOf7e+CTqNBtJVgyx3hl4UmBXHnoGZEUyypq2NQQAx9wQ0pFkQUwYeyGi8uWp24yUFjSTHgkOrkh55nWbr0TvSmeA/GU/r8ZY9tCWKLTNo81hJWx7Pj+CXeiCiWlfDwN9egZAa6pIV09nKrJyy6HqqqwHe7OdNOW3hc8rjzJGCTRx7BaIbufYmIB9ExiYXp4QrdnzGiG1vpIQ/UWWsqVgmPKuTHDkmR8viP7o2Zy/AxVuIRi3W2JZ+YgM1VTFHi4Bi12O7SjZJzS12T+Ru23U47HxABmk85e+EO4T2mouxfxUMtVhWUQUbZxMJHsl5Zj4cHSNP1aQTQn/4RXWIfRPgqF2IdvAXxrANXheGjqWF5NFFgg9VOLvgXRIeWSGj2Lm7fpfCrhxWroDlssPxud4pTwMEupHcs+lw9omRPMurwRbi/xkvP1CcBip7pmvupjGK2U9sU/hH4Zro8wfk6JCB2oX0wTcDJ3O9Qtl/kIvGy1mrLA+ToF5Oua1s0lZ2CFP8tngygRe/YkO2Iyc7c0v3OGTAHFQ2YY0B1Ac0QdrXIKUs16tA9E0bsczOaYY4WwUP5lmOvL+mlfdeZp5dNwflrW+9Yh9u2hOrpE8T/rOfUxp6EmGkz/5wSc5W8dgf2PtOMqC4qCT8kMTFoZhHSr54AT47CkYpWhFoj70CzvYVW04kj1VrfwOaafWd2lLFxEpzOKlLItX2mGB1XjJg8tH/ULWyGY0V2/1QJv7/M0XUBr7Jt2UAuErlgmgblCNziAQyMeKubMjqGEPLozxDKxMCMkheQDy2Bmnz91oT/gknub+Y/WLwzIlYElZnomsEm0IK/ruikpmwpy7kEIAhuuHOkHtynzXui5qkqtGzRG0VM+0TtNZ+IAucTFTmvfeZN9Z07FmGCm1FAdUld+i0qlNVuxuFOU/e9ixPl4dKcDgLHYW+Iy8BG9UrfZUMWxObpeDKTvBcWFCoQ7l0pC1G8zyG26w/UDbTluoP5s05i8SDEHFIWF8Af3/P8q5Vsab1EW6nTX1Ub7hn64VIFF+m4GAF/LxVfqSUIabNGdQ2c31mCXYtAou4Rt+C1QbXV7V3tTw0/eA33d2+bK10kHsAqABCYGDpK/gkCVXGqbbbaKMEPcI/osy6wz2twugU0qabKbSbS1vvwse9JQAbJt7nEeXJ3zgQl/KFRcqM0uKuzcESkyeZuWuNvYl6fVm9VlcgCY5Kr/2hcWpUXNU/rSe/1ZEV041CjOjiNmnOhYiZQTN/57Pu+Xa9ng93pYcQjm3Bed39Jbdc9I0gcIPsXKPPJY9lGU6ukJkH5moGvvAddUnoBYAnY64Uz0RU5n8TjkEpVfMePKQAr8P9ckI3Wh9dHJLQ4c5r9xcgbxSCxyWMJknGVh594e5HjhoysIpnmQ7F6kl52Z7Wd6j7Mq/Kl4G9kwySW/R/HpPcs5rtNivYVLMcIQrVpYDA1pHT8/6orqi6nK2EUBiLAuQyBrZfLA5t2JET85leBb817wrGt3QYb5pWECAbetPaD8RIcivgkkch9Rzrz2wWwl6l5A0x4gjZs3kE3GwwlTb6jF01PZigJRddVewBvrXUW/H3HV4j3+osYKaQRTUf1MiUPbNnP8cd6/UI+hSBEPuKVFPCIWmxvr0o2FZTuhkfO8Zsyb2KiPn7n6Cg3fg+EtVfryBmRZ1cQRk+dOAMY0RH5kJjPLBN9Gj1fU1puuCAXYG6I17bXyROWUFmpKDSCGNpBU9l0UgEgptkvq7CyZsXYKbaUIgvi1Mh+FYjyzI9mMXGL61ognjUgj0kVtKfeiJWsRifBeLlsPfEmJMnOQnTWKAR20g5jmxydxNYFg+b7wQp+C913bI1YkGwxu0jFYrRU0vxQUVlY2bXemEVGK0ueeIVsIOxrDwpHL9TyQyosiwDGjQGtUXk3n4oBHnvk8I4F9jJzepcwbZQFSTLVEP7v1Y7jdUscVLzrYuwPjcv+U/zBmwso6kgK1RyzNqwQQZcjhwIhyDCy/ieQRFRBoRwJsvLcQyyoNgNLrnrYKcL61CvjncuF4YEtEXKu10dU9+0iWWOV8x17lyGMbWWphWP3Vr4Qi9ZxeYXrnI1WgADtgcHfyHc0EGOt5p8mk7sMQm5JFV1BOEd1LmZIiwD6zqXY5FrhWs5m9fB/K+PkYalcpSlI2rPffr3Ef5RD9W8c3wGsgFUnEGQXi7og5PZH8YAHlWwPSKkugsDZKuQfp9uHFKkm/7PaI6k+MH32QRA14eTp840NAPAvE06x/llnv0Dlkgk3CnNV+guy6/6/u3+NnsKSHPvHYI1D2G/VbWb9TGwiACPZpq2uzV56fC1BUUcwPhZtK5j7hfoxmJokv2erIgda5wUC2TC/W4zDsnwDw1FIQVgwV3dzKhm/QqiuiKttkzIUYbpuRCT2v16vBLmXfNDJRaqqw7FRht9waQuBtAHOimfHYV1iRgf7UB4QsBbF9Fneclw4RJ9DqUcBiV7kJBv9bpSk8LuQxC/Tk95YuKhst5n/zO8PfuMx2dPKv07XiZtzCk+9HSZPYTGQ03bxfOovnXaLaigJmb/EAf0DdEHtyrHJPu/p79Gj4rtbi+uZi8tejlB5pdomP/Zyp2sODN1Yg8s+TpkfrsTVSgFdgQuM2en73FZ+hWzkxd48h32N3+yxvEwZY3CPKONG+/cKrQdSDgYi5QFVVSDwtrskt2hiyu+YxgqYdLDvFO9R8f8kVpzO7OS+I2fvuUWZnMzsqlURJu/+MbjmU49G8nYldK7K+nAazi3hnfljMwSk/ryhGRuDlqF6YPr4s7FVvjkPESaDiW8GXM8o494rWqqUPd+CzN37mBVQWHzw9kN7mlbx8xLrC6/SmUUSZecqj+s42yHE4f5v+vYK8gCJSRVWWZSkbobBBL01YwTbYnOQJxtb+DQ/UOHVTwQSVjwsSteu5CSmQf9DTBf7GhBOpyklpqoJYsQn0/Yr2er9JP90VZxQgU1Qr9g8I22ciEziYmhr20AyGzX+OxM7GNdjL5JeJ0FwoHkKwd0VK97mZG28szTTg772q5r1aHiesTsZn62Vc2a3O5v1W3EssWZHbKedhGFn066JgoLtEyyl370FSv0cKdMfLpN0hc//87W97iykAPJxt7JqdT+vxP8IZBqgsOXesiz72rtdtzWgfjksoAd5Rpc2lP5wg1bY/7jnJw+zATAj1BOM0pN2uMvKUo0HhcBiGqtpUWGUC5YjLW2aAC+A2sv9c7MXHA2BminYUBkEUyqpnEhGhv93zsarAQymMqzuZOzpBj5g5O2EEYWA40Rn58+RqZsM4/+BcjQN6CG8Ujx6svyg4rNnckuqHhZ/0vnu8ZF7HkP0nECUzJVQqG2oIABSwfi6sdVLjPX0T8mJsWaqB5rKJN709Ogp19sZNyKZLG2A5PRiUgAXIxCeknq74tlU6iG3dkaDX4XovTD9r3INi8bWxU/MIIEUWblJPysLnekNS5DpI6LWeRyiBtSzS00/e55i+tAPTKj4vu3qM/MBAjFjIzO7f5JWWf5+CShFSvZowz03fdBdP9aozGU7h5ViLVUxJulpoIHS5KqqNvHMmwy2iWtjO5o57dLZVD5atvwE32xZTKTcdrtyF7AYzQE8ziC0YhGndk1pd2dG0Di2V0VrjbWx5pbK7/nGFxzezQEylhpbWnxhe0Zs+VbOoVFeCYAvFzldlFWCGh7kw6MWltwm2LlOD2WrpZvin0LGmGHdyaVLGpBkFkkxJ2LbkS0o56uCn9MbsCXYAZTLnAhXjcci6zp6y+ALWjDICwPdRLlcSgwTJZqS/vRtpgKS6BKVmN8rBqIhxci242hbSfvn+j2GYt2Copnds8uB+PTddRMGUPy+l/0FRlOa6/nOD8XHyuuEJPjdD6PgNaUJDwZC3TgUPhAjtlnOl3zCz6Jcme/Nz067frL5uwJByAmJmeON/nfNQXaiKI86azf/xLEk6c5oNU/n2ZuFFBvTaxskwcQGK9lxR3qAiEd5SYJrR2i1A9HEFuyM/rESMTQKyrldeRkFEb0XGONGe6ipD8hVzIDVBktcnR4jph1sLuoVCTjAfPVbdyyKqOzA4GxRRaB6JOmg0AUbSosaak2tuzaQsJS2EpalrI09Ek2kv4hMDSFJ/2z56/lDLPjmlGmGIiY/H/NTuVhj8qcmcOKy32pGUIv3meUV3Vr9wqxDn6gpZzx0BGeUbVldoMTlQdNFmuznxWXSwCTRxkGV262Hz6DBq6Pqt/YZrvUZx+sbt0Sk3NCJSmGaM1kA09O10DBLSTPzmRqzKj9xyruTBaiJE4O//zSXVA2uHy8QN88IQNbPYEEmULDfBIPctVGAPwUf4g2UmcQTf8llOccE2W6MUrTe3ouA4dtO00gTzcC93qC4wbVkdUbthm7nrRBAlGzTBVgQ4NKJYXDZkvyMpY78CrZkfOqUb/29n9owfDGz9+dVOtG9DGZA1Tmf0ezHIgS1RInTjzinIRN1O3PBBHpo+nZdceqlc+ZnalvCT2PPsQ1sfi+vNsUfdpAak9VTItgWNoe7MqwvdO6l2f2F8Ifk0n45BwiH2noGy2OKddgNkUuLvyR7WJiL3vknO/4dL2HwyQ/m29vjLyia5t+ILuXzd1j6NoLJ+YtU7+fa+yIQAdOFdCP7Sty1fUCuubEQYmEo8KcG47tw/rbTeQ1upfePFYDJBEB360PYBN1U2/jWjfyV3ZM5c7ZnY9pztuECCeuX7ntU7dAn57F/X5t30Rb666Z2BJL/oRbWXKR5YrapPPIniP3rh/+zbsafmGYxIWLKzDE1oteX+mmUoCTve2be81Fu4kB8vh9T9vE7fLjQG2wmAZ4F9OMshdjX3peVUjAcZyN0bC9vlFlV5dnm/xXP9h3kTkaSrDp152AkjLhv6SSZX9WkonT119KbvnFwqJIOfjj5KKKekmQNhVJjJyPaXvpocVvYqHgsJQMdotRl4UfU64MH4rU0UpQoOUVfdKx/hs2zUHznElMLnSYARAaB/L4iDqmSRe/3cqSb9OBzstncOdfQB+BrP2kGa7rkf/mxYLtUrqCXa9tBNTp+Fa1mpbzkYLfG+WMOWgi01Q9BqCnzr+xOtDdMj/lcsuxWhJEvEwc4bj5+7uDfOMNk+MNVonHJXAEWLFUqPGIDHSVxzhbkpzlA+iLnJbGwcYEE40UhzxIOR00ARid3KD8NqqhvYu2NOstzsr5TYlyIGC0tFEr9iRfZE931CuHXatD+y/7WpoNDx6ULRdTBOuQlaH7Pat58fSg3PZDlepdgD75ZafIZPKvuEM5fi0/wAPAvC/4BhhuL1ji5PQk3FApEqgDdURYRfFdWkdmO1cTv786PksCX6CvG9WSshQGf5OQuUTNzDTCB84Xi+aNCQ9PGGwCYqrfDDr/cgEYY16ai/XqYBop7+ciF22RS1Vh0YqV5d9PxSYBfS18VVt6yvSNRfTO8/n1R4T4jQjAluC2wwe9z+7c1FV6N5XrU2RnVRG33272YFNPsdoQ22qMVabE87a57NOgwuuHnvcKp+MUok2iqQymmCShFKzNdNKJDwCT5ZvpirfixvrZpIzU8LL7Q11M+zYEJ1DrIvjRCIz0DJ1/9KPJKyeRjIajab0AwAOtQTui3q3+ZXzZJ76guFMs3lAWdgECrPQKa/lc92svQjeKlrUB0+b880mhP4y3e7Yw3hn7YlYxt5YrztAQPrthYMfR6J9g/K/8gQRQshZWc9xeBWHO6dh12Ks+By53TJDvXTa4cKsJVjtkkxVDKHA3qZfKfKDCnoIKFSf1LB8GDxoFs38RBjC1lliOwPp0QBLhNuyYW8kHXSnM7w8OL+WKPREOEfxqiFmk3eobKXIoV711LckoWMxbt/FKNnTWKXxhMYAbURHx71h/6i5TR6LC7wQL8DKtUt8chBopFVRP9xqaKpEtMdZDu1DHSVkl9E6U+hmDQld4nYa23tV0qmZUQDbGeV6eQfS4O2E2377voIb+OriO/UpQCHDGomsPIN8guJtGsoqKACdlxEzfwHAnluKkOGxety+ceyD6lDmr+UCPKpeUebz1YbxTWlOI08emvA1QGcQ1AKVDE2mnCYhMMrzIEPGOxtHmqJHLqenaR3zWvvbJZRs9j/tOSVWjadsqvJlZlZgEyNOZ1kU1u0JD5mMQymjyAz0ha5B5PNDUK9emSnLLOF0bQDN3kwUzO20GgQZ+Gvgpd59IaW3UT8eLzZn39XC5XxqGNpOm41mb/anBcvZW61/6PdsT6dX+galAOQVyvnTd2XBnYm7xO/7DPDykVlpiqjEk3w0ayZBHyVALIXGXqAc2lVZUCnUtHJ/ScN0QZJ3btPFMlNcKrTFXxr7ZIJik7zcjDfMVMBNl0L800PvumGawZp9qwtZGWXvjOD4mzstm1TceqqpL+ZOPZL4LMPc9vyhv1287WaDuXX1dMS7m+MDkrwZSDyln34jXJ+PHVqyxoWJcW/qnqVDNrRoEFc3oh2Iov3kUIOrXKYBP4cZ/5gfW4n3CnTMk2bJIADryjRKriRXadPkfKx/s5+KKUBg0lu81XbTtwLATzL6owch6mz8q2Xlr8L/qUfBanaDHZAgP2AEMYRk64rDXFhonvkTeeV1lODmVTfKi8J+LScJy5LwE3Vlt1XqfiLlaXus3881o1hyMbB3NzwGVOQeOzbfK+xG5bCy5aLAz6FatzLS9bvFDPNBOvjBrrPkvW7gmtWI1OQXoP3gtMZq+TjSjSvAlOJImbc7sv9JhWUKYEu7loWhoVBwRN/DJrq1uCuURkfaljM5RPLYkRWRAPJUbhVaa/VqBvpWLlFcvfZIn5iM/oe9V6w9DVpI9xp3QtOMxEA6u/VMiAwTRyE6ObtSodaL/JuGyJ/tyxQb0tEbP63503Dp1eLU723tN1OnhDaNNeO+Vwb7UQjO/COz7lfMSdv795oSntBaryFODJUBTjeoHE7OZusLEOeL2Nrj3zYMGZNaOmiD9RDcXn2V5GwoNX8KjAL522KbsJhMKMoWKBNBX2IrfQBchMi1tDVhMOTA0YBSC41bIGuKWZb0fAqjWr6vp2vAvqvug/ecZM/kwn70wiZXnRdo2+8u5tqkQW/ht11KmFGAajyOmmGHctU/TJyMOiUnSdDqzWTn7t60cvcLpvW1VHh6ZqAI9hE+0ND722Jc9fS191DQlBWSOl4a4dS/V1m3KSaY3Iu2rnbEblI54mW319Vry16OnYlUdXVXTrgVSISTvyjr4zDgWASNLDVb576WXPxRfFVS6XYh+QdbCpJ9KI+viG2/az5nh+oOOmXNtSUAn2R86cLNAenM6kbrE9FmOqWDBtw7yN0QGoxV6vndD8Y3aHxdLs79tX61wCzZjGE9BLdWwrQet5JV5zwOw2wbJc1w7Nt4zcaX2vLpDB/uNZfivaqQkGxV6+3Q+TnhR/wK2Km7rZD2EUwxvhISyAyFWYh3wNXIOu4WU+3lUFA/+XFTn4kEKizdUwZdlPBkFxxSrhcUKN8VeCDYl/M3hOR+LUflxTLdWQm4j/s6g5cNTjkOA1YtFjh0uB7cJx9tXPfftAGCdA30WraE1YqT2bBTvzzd/EWH1eo0KPkyFEB3rFBvkq5/HQs3wjObyaWJC4pZ20bwVk7HPxJzSWL1+II/hm1yC2DLBbx8XYqNuhMwgylz34vSScSd3L9yGbRLGpFrty3XxQ1Gwt3QZTzbaRFJ6jwyUZc5kcrX3VFuuWbCqdgHRmSn0tf82oEC5DYV+fYblf9MEsW0tDzx5WlrX3R6HUiuw10HReWoY89CfkXJ4ttxeLQpYMRvslfynpXABOvuD2ydhiM/9rb1OCsk+TxMMXlnQJfoV6TsGTz/iK0z6S3CnN7WKcFBaVpID5xq+J1NX8R84QbZCek31QCsTumhWdKpJBPmpnMbiTx9sWNqrKWooxm8kNaBT0hQKMnbzAQkO5UOvIiSD+t/2vzHDx/qliad0EGqRPLVgWPIioqVA4kQWWveEXAvVWY1N/XqpxE3lH/hYp3XI+QxSx7fXAYHCd21L0CCKHLfxyPDjJA4QyUb+g7nFSphQAHQruEYHpc1h4+LA3J95GSAGrJuPDqFb9V++nr1uZMEj8vFzGDAP4LEutdIG6Hkgc/9Bbvfx6tlbyCvkefek/j7+KHxn3u2F3waCPDjqYgyf3536ntJTdv0rUFQO5ygjc3QhHqYP6Jh6M03HrW37F9vokIzI2yrA/xomcKFzjP6bzDDFuJm8VdK9BQMEiUfBdz+HMT6L+QUA+lgcbQUkJrZOlT5tmgMWq9ZzBffGI1nkQ48TgWIhUwl6snTajvKAuOG4fAhiKShDqQ++WGR1SN3Yrt28JoHxXpsFSlJZ97rODDoR4YQGKj8fKcp4UuplW6RghwkPqY1cExdLbR2rMchuoQxiyIX7cZSUzow8MW5pp7tVF18L/tlaeBV/pjDkwjcuYH0HLO5vtlmWskMLv0UJmPbIX1gAJhBcTAADilRr0BBkRQvTr+3EGBcNyVY2/Jyo3Oeu7d5itbQtaGqaIKodFsMJy3reh+6reFZTb+sC/HFi5fNJDpLAE1tdgocVQveCK1iOhI+IgPp1V6eWAI0xBqLphoxCu9Fg+w5O9zXd+R008OXQKUm5JX+1Ku13Ecoi74Fgzui2ZZ3Qh5ShQdhsNg7eOcBnW2h9td2QwG/Meyxa5nMx1glk64DrbSgJ+ZWWXK4F/O99zqMnBYE+Zley4AF6nfN/9vS3nyAHWvos660nF7/e8NgJNfdcPeiHnke0MNmXs3wMv+mrd3Q2La/gQfP3OP1Giw59YnD9fci9jp/Sthe0lZOHok4LyQX6gtRHEAhqNom5uAkWj4IYADqB+RsVUkEferyPiNXIASnwCtBAaZsIz3t5GfJ65zGeja5lvqoMDkRCiwjrSlxLcrWVIJtLLscpjEUKH4LsvwUuQyGhrKA9j+cXE3k+Avy/JrBkbOs4/L/5c+nOEPifwQEQen2OdnZD8BHfjq9MPHTknertrPT98c/20f7H3v5/l6hKVb1yAAUO1MNIhbygbc7aid4XwUA34Z4I5YK3+gzq49zW8zMxa5S45bfkFYeXeDXivkWV237CKScXK6n9HGLtoWnQrRSju5+A2DL2KOK4JiOjv9+zCtV8ujP9NXhUDkJ1oxYDR2RRWaM3XVv6EM10BJEA65gD51dBxWE4oVSYf5YlzunkdlUQM+KgOGgvOwhcJrawpEtpZU2zwW7iPaFMjIF2KHqP/PE7IYJ61UCFuo3QkVIkMz8Z+Fbku+wzoubaWDaKAfAT7PMpe45xeIbF9+ieQNPRNoBu2eZ6OU2PvPtST34NVltzmflAg1M7JQPZHtcADImDjxdihM+cdlu53fUu1AkGd2VlJw14QW8ALKxY5Jbd7ekANIklaV6ye1oaZZJO7neCvDDFt0ZYSJEn+AltB9Cd7hO7J0AkOmdRp4o34mnVNRfQsMsk4xA+VlDVpI/L8fp8sfCxgeMXWo50AdWusQf9dor1J7GmZjbJeLtrHM3Fd1kX4Rlzy0fWm5MNsrwkkPl3RRBPY9InPlhjBQlXn3Q3a/nZxeIYzxxDDQw15v70AX4jTVFlcOjUQwgRuk/nBR32IkfaOQvX0yv5esmxV7j+65pJf5vmm6WvX2hHoitI3qDskJ/cEjoOh99FFmiEqXs6Uvlqp2RbC8svHufsTwPmGzppJ2x+3MLaBXVYUob3N4FBZsNoGJ7P5pDEKtSvZFixhM+nVSS1SRRAzHYPgi9/GSrCTORfMjEOTGu2MQYfbLKP3CowcFYY4dpmT8ua3jLsxF/SK3umDr/eMcdcGwCeKvCUEmiwcskcP4ba6TPOFejFPgHRFzItV8Q7oartwwy5ALc0QI0vPpjbKngT//lsCBC8T09rryirstZBHOQzXyGwYZ/fTDXcgP4efvhzZUOCBGMCK6ghtqIhGPLdsGltrThlSeoi6P1qYaNBNlPf7uFncVGk89pcDqQHm4BBARKv1eqYVnNpTrknPpMuc46vSRhKMKnHW6wFeETOLFzIL8eEhNrlk3pH+++9CHauHBSrTECvkmSEup53ojl2F1ethVStPU47aTpBZGdfdgdPu5BdGTyxJki1hrdFz28LGZ25SnV55HZfuBwjp93EFMpexFJ/I1w/2QPYnj42y7WNtoLt7bXerQc7We+VmMol+mdmyYGbEIPMMWoOomcULRiG5qWQw3g6iJUbf3poDJCIY7USQbE0+zDQkL/ry4+/0FndZjElmGrMfdWk58eqKYrYq89jTj98ySqerJRIK6DN5NFYcZ+xetuUEAP0sK96ZyeYWABjSf121KqO6YG5rJyByppjuSH15szqVWjlhNEjw77WBc+lPGb9gn4Vqs9MYycKOx8f5vgwCmk+/65AbsBmpU6RgZ3tV8bs8LxOjiUihvgmFLvWtQOOG7ZDhbxT2lzrczqS6tkI3lTQfCsDc/FzPNTs03BzMKrUuXAAzhGBNtoYdzRET2GY1cc8MdfVkbNNSTrJGdkxsw0E0+h2vGWa6aRS9r34zG8ju5TNY5Blf96V7XU7rPQaTU4f4rp++rYaUrWg8mHE2P3I4kw2GOA4NqQ+B/KjzP0USW/19BlIapmIikEKbHGOGQZF91sdmNQKQlJ3py4w9PZSgsdDC+y650uKAChkfDRF/j0ojF4qHCjfHSZpyOq67hB97BNPiKqPeBjaSy1mHLiPXVoTtQlm8g92XptejZMqDGmavPnQJpddstuzVQXaDfb3lH1HtkaPV8/0zKSfP+L9W8Gpy2ZrpeYk1SELpvCvDV4hEP1N3WwpACOlD4QgFwT2+ZFP+SbeE06/njD0jIaCcEFuTo2GpCGJGAKRVKld3nwFMr1S55crocfF1ICZSGIopcZjGKeFH3uiybpovWZIfuhZPpKs3Cw64/tPAiMnm67gSTcBYqF4Zr5eV60cFE7arSGY2sx33HTMRJk9YkkrIhlofbdkLcgrYKCAGMQ7pSvo1k9Q94VTBFVitZ0FPZfuLTtSoJKg8nXQtPzMm6nb7VN70615nfp0EboB0reHlv24waHbNlK63wcpxarmFQTifk6WTAPiYmZygImT4CFd7nF0ybJLnoIFzrG83EUUzmoNmEmqOtuAa8v8ZEj9PGfxd/0QbZRlkDHetB5OdEpSv/Wx53ukrvaaz4y/HgI+VhjWJKskgxlMancb2U8y7n2wph5I1Ktq+/Q4nws1LEpzSyCNSWeko8onIE46yfHiG0PIH/tpLDsY5Sux5l6k+BWXzRZv15h+b8z25bO5qn4LfUTTIY5NnsUTBC2NHeoZ+RZ3xMbrgJFzxnr/EqnFT+VaCNYQ4wQYbVQGYJVgLCWJi7r2+WKQmso88TLOF8d3DyPC0/fdd1po/UlGiW1Ey5XYTkXkNEavjWyv0Dut0KOdXZn0Tsy9raq2/RUlDKhrELkXaLRVmxm0BEM4wnZrAakMuB4tcq/UdMKx4KK/Nw7jBrx1IqZdsinuBnHUrqvJrxF/f4x0cub/MhQXcpeDCPRcLGOa7MoJZbL7PssLNVZKJDHVlW0hbvswowD26c/eJPStX00Ap7AJAyQf0qJwGhVndV6P+I0gI/hgzD1KRBKhZD+i0qMcSoHPDk7rNxwDaxV9M2RjBhnaOJcB82Vx2iiv8bD9uXors6MCSZKUOyRrp1hEDAhQDxrTYhIGvbU+ZN4hT7EXkWhrN0nwVlzc8EBlgGx67QBStHlV3/E17+SmELsln8RNbIr6nPrQWFGM4QT+eOMZslA2IcoTfQJVm+sjVnfpw/6SbCUhTLukvcrm9gZ+rjlma8bdPHAZqZe2u4ijO6PVhjUbWhFdhQ/jcKHMYjr1nbpJJ/YSrmxOS13MPZ6aNr8t0zXV7LzoQ4Z5MLPGIWc4zCjpkB4plKs93ZKBUJfSxMp6nmNPs99Qv9vkeCMRQjdXtlDzbVwwQ0bOQTPhLyOeuqNsIQsiVOLVtRiooA0JgU1+uI4n1V4OZGjXw/v3Jol4UsRnKnfUmAI7pZhz/63ya+K5vO5QMZWz+cKjVxjxjVGwf1NtbJKOmpeJK+4vpJLoScweafG3p+G9nJy6B/NNX3MMrWpcpdAW9oSpjFvlMekF1Cq99GfU5OJXhA4exapeRaWvgjKX9Sig3WY2G/3XQwfF1kC+Kq6AzY3DIvsXpf/oI4hpYjfDPTQjN+c5urcHSah5bFrQz4F0JH/v0J8TUGsvm8Gi3D2N8IZUoQzVGm44cQl7JNtnYQI4w+SdvTd0FZed4TrC6OBJNDKc38DiRc6fO6q8ZTDRD7xoh51M8yEuhDxzPzgaqvm559MnNHmDylvpt61y2YTnTXCePX17FRrFz3QnAg0WytbuDiG76/AbzXo/R6Yoz80nad8G1trDBrCdwwdIy08hlByedpOq5O/BNOTiQaeA8vzV2OnChHk107PWOIVRPGgiSJ5dTHp4yOs2rdHw5eYHDjN6ush/DcsdyD2WLZZlec/ycqarYuJSJLoG1ULf765NATK+enCQIUUQq+n0WRLL9MAcjJAuKdu8buB09HXzCwwqz52cXI4YprZgog17gUhQCUcDuFJHgZEfRJ0lhZ9TlweCSczuSVPobYNeUK1LKsw9qOQ7E/sVi3yq2Ee1Nc29FNOeQOGvzkwmxshkTkTm4Dg1VF5SVeKoAHkD9lpMp/JOerMGFOOYsDwCRPGWhoWT0ThfpJLQXtE8zHBvn4+pCTnPhsB+KXgFYm1Ld5QcrnbN+td8JOBgaBqZ5M6/EvtYoG+dXvjYQt7diS5cPyedlv28pOzWeIkMHSFzPF5yY3IT+AnvVLf5Osam7OgStktI4s0JjDUqxP6D4xwKgfvKABHBX1ChyL5lhrMaofD33mDyQxnKELPkqC6zZDLqEW1IVtWIfT8SEdOsKsbnCgdzjvpVy3hUU/RtokHq5u7ZdSF95ExJAldFYKDZtJpoP6me/pZDOZ+Ey9JraJ9Ui+ebvTuM4zsQpLR2W67Dvt89bGzDMAhI7BNBiWMCBqgYmSFWtuPDbBsEVdfmMXVEEgOpEZ0tvRP0akpWCtNgZH2EVj1u+LCQMBzN0MTHbngXhI5UU7fxrYUFpTX3LJuhW2IiihBBURHpoowNZI4diUuKtxbroEKljikOryA/nk5qbMVYMmXv3Hk2unMqblDF2kzzYST53oAc40y9GVCRz8ekPslQltk0Z6cL/NZ0sI5lCy77oMHI7u5o6RX+BDIIdCyRIr5TIboylJ9iDloYRj9Jluf3f2MKhAqdin/upRgZF8/XJ4GLrCQjSLF6h+SzYKyhbbfhXDAswJWUD56EghvWK8ngFKZv66s6Gb8d7mqx/6Hwcx6Ib7DmF2m1gXnehEU5rDr1ErCMdJeNzG6rCQHMY7ceHXLrVdCQ8N/0eA6lSHG637IS/LP1Dc44kv8FBlgiSjlFk1xTC71x3Me+oci2ZeSBC46NoCeWs0VlsjKdg1cCfZPa/DKt/d4DAJATw8NOeuuP7cmztu4panRqIlfHlfCqs+2yC4Vjw5zKcxuczaghJ9c3f1maRb0RDIla0WkMiA/8rmmf7F7Xum70BWtGoLn7OHH0KsLrfcWS1ekgEilz9qtv9IuULVD9AV7u6PEo0srvjsnnXin7+DEG55n810nufY+R/eDCty4VPabznFaQi9cAi9y9Ds9IJiQxSMcVNUrFmN4PC4TPTiFkLWnYrn3xBSMWEQ4Eg7F2LlBqGT/xp0/80THyiQRKm4CVqBAJWGMETaQdj+nw3wwWxsFJiba6i1dXfiJkr7h6f0VYqUaCGPaqktPnKh4b3AHEIPsoPDAjDjHt8ucl/yte0976hzSMs/jdOu6shpgkCu8aEF94ibZTRxZNCQu4i17oG32M59hyXln45ltdRN16Jf9QVSHbp8qMeoJF5jGI9tglCEkTsKEblQeBXxphogX+RnIu6w4bxiLZMfrnQN7E6e9NYe2A0Sy/i/dAnXAbSNR4RUQ44Z5Vx+bOCiTLkiZUscLjlCs/PIzIWysyUcsqzJfbIQIrID4szXS22Kri3pXFkVe9FUnBQWfGhGMGf4IYG1PFXAaHMJVA5huRqXQKy9V6yITbH7hi37f4/8UsU3sg7/UhBGIqACRuNdwQbeFG2ZNWF4tiQDDeLh1ObO5gQO5f5Dvu3quav1vnvDJU0SoUH9A0+SDi66WBMy8OYyI3D6FsV4fzLIHrbyqr8NcSaxXXemqEcG3vmaQyioN95yJAE30t0rXCUuWtJfaaIeOzcWdYy2aIVkQD4REeoURCBPPYa5CCsvNk4NVsvnpXYU6HWV20CDwuyfRCvV7wCwyIEXu2G2LsiyRaexMbAor3fjf2ETqcrNYbRk0SbI/HclXz6FaaYjITjA+bAD5pWCSzbJuAh8Vw0aC7hAqVrvM06vpP3cDXuP41pEqc9+KrOWBTw9IxO0qrIYxSkRdOaoYp+A6AhsLKCf3UHb6LY3ns/GHReba7Peg1PAH7iVVtekrRKelInU0cyKCfoID9/biB+4K+wlKWDx0mhXVAOsfhlvdi6zEFwPD0LuTQRXL/B8QUdRxF5z00qtx3kJSEpOXhdWhJnxj8wvBwu4U+bmcsyDU5FEsB9H325K23f7kKfrLv3+cGZbznzaB6oC3aBJQHlPBnX3owH2FrJP5OyU/tp3SKf/Yc9hppqn45VQOWTZAZNzwoNnP4/4wkY0iiz5SxoQzYypWSp6De85Er4KrQ+XyhdbNBbhign4WmDzOgGPYwk+j3Gf+gNWYlF5G61WSn01PBu9bk4GThOocpUy/iQ5eq/VdB6Bn1CIa72WjR4ArUuchGhr2W7EbtO/4IBA63aN0BspXmZYG/tKxozHJ7w6ZM8QhnRNZ/37UrTSwnp9IT+ONBYddqb0kycI3XetEj8Wa6y5ai6yhUFc9hFBgiZ3TPK89vmjHZN0oU+B9/B3xj+c6ygqkqnz/TDz/GsXywLOEaeoxEqMq2tRcTNU3/U1RxLfQf1+7NSrnojjbRLyUL9x6vdcSDa/xV5TxmqryJRozKpjgWKtNsYhEnx2hQQy2c8UYOPBdtcyA36Ahc0cXNjb9mXr9soCIB2ljclJlY0h+m/IBQAq1xolKzdfm2VHw4cmlMQ5GDDrjnmlXhm1mKPv5Yxd9TbtBJ+qCJxwFHY3N3FbESzorvxYL9LRAOtoqqW2Mpj0lyf0q9iKn0YNf8F9vy3i1nn8lB80fNZrlfNh1PvNRdiXKcWNMiH+QsiGxF8HfyZw83wVZ4oEDlrfPSCrkSQn43/uQdb2PwfKLQUPMTtK3R1lAte8yyr8KaNhxBTYUdc2VrtJA5gt9GIEXv8X/aFwJAd3L0N/hmfyrLsUtnnVXcMdJcHIW0uOmYKvypSS3E/drq78goa+psajVWd9O2w3kXekAi/mpOFpAjq+scidgzZeRsEVDmjVfOf25g9UxClk3VYeDlPj8RyFnPbQBmHdtMH7457KyF/iooa0jevfXj4jo/kLlMVkwPDn3x25JWjDfEBIuTZkfSAOYq4Nngm5muUvPJ8zrZrnTOtIIAfMGU7T3khzHBQPkowmvXpdKoU32EmfCRAmnJiGsIH2CC6CupbJgf43oba4Urqtb0SDu9yvt1I4oywwXGB+/opq9KhdKkJ3PHxQPFZID9DYPo5Buw+oOKvqcP77vNngPCiYvsUyzUTv89batCCxMawczPcjurGy4cYTS7foFIclCa0JevRBeIZH0ZHsq12juRbYUAw08QnGcYqrKvVD63VlD0unXzjI2WNmAcrxYDYLr2p91dBWP6uiT04D6AxKB+w7B/NNodTwmPZ+LGtXoJ5kFg9bNZeibrqNKSXa5S2xjZKS4wVkrC26opPtJVlWkEGiocszaOeYlqC83KlispAgxxBkZEEfeOBNWGDXDklqPulCGst6wlZ/yqE0O98YAxpvFmyW0QscurY9z6I384iS7KRE+IVzbdH1NjwhS4qLOA4z4rcgoR5vJF4GQc94W9JgIhUYbL6xH9SmQ+6rZa0VQYNhN7BqHv9ugLpaAnl2/QYPp+lGe39r4abxQhXP/loiX6ZN3Y5nGkaAiaLTS4hywXPMS+4x+IzgxvsFMLSGUP2vvs/Il8OKL/lthyWLhSpsk5sFyBtpvVJm3a0LB96RR9qX+uPvPQXJxfmgzt7yjY9Y9SciQfEAVXuQB5t+j8mSUCt4OHpDUoPOTpcgQ9CVKA8BXV8nnDudqI3WjC7MEWVieNGMQHhmqOsBrpNvcZyPPas9CXSwe0zijO45o7iNAl1oSG9bEAq2WdHUGnJZvMG8mPZUaZK7/SCy5pGVK+L53R9uWjl+NbVjXo/L/tbbimwUZL5LfZUBktLcXt+0uof/8SH5SvsnMHp691m5KXjbBJFt5OlNnfaPWofLg1HKDAAtAUgC2595k5igvTTBphOPCINNfGgtTSuzizC1gzSJ3ajbHRHFhfnpeTSJeO7b6iXdci9CEPQIlcblHs3k1TiX0DFbL1c2ev+GHfHKKLhaOQP8LxmGQer2u6W5LHA1DEHod+PnIqDktOCS4WbzcVNuybxmB28Qv45ROTj4+kPtrf+WcmCGmn2Zi5reIRq/OUzLInxa+WeaoVDDuClSVfHcTkO7ook7Kxj9sMKcXONoNrnCGkG8M8jV5lr+imyU5+19vK1HzDnV9QSJgYvMSkE0jgoI9esSJ0hAtIOWaYpj1JOLqh93rAJGLNUCbf7s5pHK49oCI2OLKzUP7CRYQi/uJMkI36qaB3h8KSyazj1u3WmGIjRgaHz4Aee5xyoR3NQIC518/9TaGTvz/NYghMx3M2zbVAFVsN1drR2SJmjz4g99J+Djfb6Q7Lp0RPoQm2uVHdSjNRC5KMG94sNxB7S+JDHmhFNcKH29nnFfJ4MsRgRKp5n+IpMQknBq9vuXcVgu36uKurYlMuUax/HNhr/PCczrmHIOsvUnfu+Yzsx5L+tkShsownJq3WEdVosVxT03YyvmWyvxbHKUcdJp5AqO5jiebMAOUfhEaT0YTeElpEoXJwroCKEYOEO9HKgWWekqOt6i6vgO2I9cMv6eNHYNwYb0qq6rK7sXi/1BwTWzRPw5TiNXu0Danl2GEnNjvDMCO0tGIib05oePuZJhGiFM2hq12t0jKi/6PSCoYnewQTmKFtZmLHme259kkC/UDsjk/B5rEqCvoPEOs+QLBkltczf0uixjigFBOCqtDhSYiAqFCa/uD9UONAF64l1TCh901a2+f8D+mIzUEN4tNcxktrmAbdZ7lK2bDHuF4kC45k1PdYi16Q4dWSeXbcMhIVuToMNOZXAzatC/iY3cK+zsvhUL2zv/Ds0nZX/8KtkLOp+GiEGxipRriCgqc2JeMpKnmVljCMM86ghkHDSEK491HKMjibEqbb3JntkgRVkUrAdM0s/c0WcSLCypDmkcc3PnuNBafcYE5bio+QbU687eepGdxiXXLtK0OYym9hmd9xG/CHws2ibWspufeQm3FdCISdIWlb5Gwh5x7FD0xmdYOT4EU8oUCw3kMeEdGfB3wIFmVaWV0uR3TQEEot3x/Kzou3DoE5pjYkwlDoq+7VWP7gmfpguHtK2J5RC2UjJa7Po55/YZLpYmoibYffJ4jcEyrLgZR/Yif5ix5J1nMLvYOWraDC61Os/iCMVPiySWqGgx0sVpSubXqi0kgr7NQWQ0a7du19uqPkxtwNBdjS8rJ7eg9TwbCMSRm0BSMe42FsPuWcu6Q2dxhI6YQvow3v5uKgeQ2Vm9fSFrUXBEa6RCYCLKQiSAe5OoWAnbZ4XfbMBn76fBr2d4oJrYz11UMy+lbdlU54GEo7gJhuywjKNT2vlVBxOvGEbVoLAArVD3q4civ9a9kARx2rahZXY/3Ki6cwl+o1xxLDwqZ0aSl0y0ov7d6o9/kPYOSaYZ7bGoOpIgimruGzy+nR3sgRcDc4k/+LNHYu+81tXS1YjAovPLFqS4/A4qtVwZT222zjyST7S8nb0aeXlAt5RHO2oCE+6Xl5nKaqDZw6rn+E7ITjXbHnkSSVm1tSRVljYqU74ePJ90M6da7aSWV+YOAoP6exgkV3y0vCN7lZX8u3BqSccjYS5j3aWFHa2nQ0kzthzXsadw/70a9MxWcRTooJXNQcnLel0htGYH3dWp+sbNvSopnXN5yXa1VbyTqIqK1VQipmMlGK/t0I83WSs9MBp7ztyzHcLusbk4bqVVJ0gRdnEwIOoWWu2LSGChF7jdUb5Gs3cVKBdsWe9wUkspWaIOTmdL/2NFBObiHBBSOkkXDncnRTdJHPOx1Hnrc6zO4ua2p5Mao3nFumB6ao5PRuJbhsfllywnvWtA1OsHIM3RI15V2D4LKMOXkmuRI8dhPeTTkBaZPQvnGry3BMxrkH6gR2OlQU2MAo7vjR3KPclN9CgDkaRYdMUey3N0Tf7WjUlxorLgJWchzqciJf4Mi+JosM6779PeuWZyWcAPqoCPYicyPlFnecAxvBlGMToDQG95NeqQ8m4Pg3qXcArqiZ05UFa3Byp8ehwIDCnUHDH33xLH+K40ycnlJEDRtlhG0oEtloHw5MXlRKh86lLmw7HGxGm0g8K8gPKGASv5cQ41FqqUM2u79Bq8hIYCQi4KebixbrYJw7GI8ei5wHWCO0+1R1MLjMaMG/lIrmz6MXeab2rKGJVr4kjxKPA2qdwtqckOxe8c62NCdPFg23TBUszQYGCxgiXmsredTSFQz2SY+BH5n1sJHKy6Kh45+8MNWP/l1ogYvwSdH8VXL5pasaKZ1nNF/jrmrRo1fMxb31WbKzsXD27IxplTRj8A6maXAnjtX2ZA15chPBj4XwZPDsXqG9Iz+jbU3LTp8xhdc+VBCITRIEjmiocBovlvGAGL35wNlTv/wq/6S9j7iz7qwy9aqVj5or3QM3bGI5e0wB9wrGE85mp6XaKN90FffB7pRkUMMTMDat3PWe1ESyd0LP+7ZxBkbEhZlyu6OxKp0gwXFbMHoVdqlzkSh9n3CkP1gZxXRdx2Zq85UdJMKXwiL4eWIbgFUurcfILM0oTmPfI1c95uJNGnPT3pAd6HeomNexhvOTQVImY+UFVcJfRa9eEusgltjWSjrxxparQiOz/6dbx6H61KlKmlZZ4tXCjtLNEm5m+lLVixhxG4J2vHjcxcdsfd6gt7Td5rkiMjUhCEzk43AI3ki2YzVY2/+4/DkmJUync/aciF1l4krIN9FBWW2y8kHgNuWadCuR13JJaOZLVNpAej17yd9wwgi64Ri+kyOvsjxL3CorUBUFTs1MAYP5icMMm+2Rf6Ug3SlweQ2r8p0loPFHUPNBnkdfPZ2PA5H+9DOPj2THr2ES0hMElveU4e+MJGa7ern6d+JzMe9JyZlh+ofe9c4XI3i1F9e2yWS0WSchaoLKVVzbyzn6RJ1YK6HQDA6MVE9Z6OfMDgJy204B39mQkBQBeMihi/lIKcHqa8iLn0KLaHpzD0Q5B/fQyXWugD1Hryy644pGHU+IPjlKDEWW3pizWANvXnS66powAvJubFz396S9F7bj+XdIeGUrPjybq+MMi6ZPS36T7jskXKoq4Q4TYLDnj2xC9Fn5ab4Sm853l2X5ylCeDmRFE4leR505UfMGfo++2bFIc8U+nJlP82R0uVPnnHg2XEvPwg+3zR3G3LfNxQAuXZaOQUF7Ou7w1O53wf/ZFvuElK45hhb+mkICH2i2BJyt7inzCFgUoeMCpFdQmG2ESJn4WxaNuwiYfHEZKTm1vHvYlMB1x0n1YFxK2vCCrqGX9D5jX9yFVS3GBB9qug/2u01ngk0SkfQmDjxP+VauKVltXvOfA4A63XJf6nADdiULNoPaeP/GFaYT1KjAxbvcfeIncpXJ1PVKBOt59LGab7aiHR+RtTGJrsiEpxmkYcTzu/xlxUhM9upPWFEmYVAnWKCbB6+xZGPLE4KkJVRyKpNQMaxEkpv+Y2jZaDNjc151an0oBTqy7Nszlm7qubck2rFehgEJ1jbkL5AuM6VCk+jSM7cmCammPKmlujYn97Xj0y4JOaMizN3M+79Xx21wJXClfxp58vvIkU/8iVnOlsAsevfOwUUkcrdiQcOk2yw7LRXD8Z0XhPPNCu+lBtRSKxjdvG9BINLEB98IdPgWbb9pncGfCGO6CQzP9WJOQv8DhUkC76G6IJacpAX0xt0yN2HtUn7ooBoumodUm/mSBQbVEoI9EHjMur5ZGjpab6bQK7O8Y/0cT7o/3jAGIBm9bA1Kunjz3tXjvpC6TCa+VbNpaq0nqTxp5n4CyVOe6Tsq8InbAjAVmfROjgGXE1Fp4zlzoVRH3/Mhz12exSHINoYySgdZJoHyx3JG2b/0ZHGmi2vIIjzCBjZBZfMzB3SWddtU8dNmSDuQAELefK/3IDetWY7NzO2BMx/VmlUuK1N0mFtEf/nO0Qgztvvxw0biNz1mnyxwPqdyW2kADXg5b93Gp5eot9VBIXNkk+sZwjP2KdHcq+zWx4GZ1Brm5O6c7F9b951UY91+a+FqHetaMAE3yVOIZ+gDvmt59y8jqGKxzhpfALA5v+lXyWE4lVBb6DM0Nu+GHVLBf4MmKaglGjZGfceX6QxaoeWXKhpLn/IK+Ud4XHim5CLbFTsMOhJGb3EbVrRHO41CT6bT16wuO2fuqYjieuMA981fjvP6DaSopprCCEG9jNc9ODIsjGRV7Fqik2XKxudT99XeZTdQDQAxgdJhlSvgnLBi/Kqaqs6V90q30RUwTTenuNGjEruo3yiLyjDHnpbrJTwC0iRh94am580vnWKKw/N7aw0AO907cfeFo94MFBKxtCe82+eR3p+SrglE9Pn91L6USJ9/gtt+qMlzZWlHRT09c4pKBKK184puwLmJ9RVoIgEQyYj8WeIZ+pF0PHqkJTNppbYanP5/c80puVMPiG3bO8oT4HS/5UGURYdkiT/fBAhaLA6vQhvqKTpBzO9PkEeua6UkeDsUJw/xo9wK+0FghvXqIiPGR6cWVuiedJ6s16pTIaJbaDeXWFkH0pGQA46UmksWNdA47H43lyS43HGmukHiX5HcTErkSa6V9wyTsHXUFARA7vkbdG58c7yjjBmQOZLwEbwu0e3l+7kxi8dEOHoCFYdCc5hUF6VkG22LYxj5iKwMp1ZGIhN3igUhnHV0qxE0WTTBShqXZ3jVwE6klKC/qimlIJo1mokHwqfREWu6Z5P+UAO7n4lPgQ2VJUbDvmnh8XLgfOeVxQXMfAYyu+Koh66qml/Mnr87UpnJe9m9SvG8XZsoqeZMKB2W3lUPLxx17HFGe4dc0P4ziUr1EXdufmJGmMsynUldXDZFcKzo+ncJavi2emJZR7Gm0r4ldwEPA7CluetJiPClXO/e3YNmwty4wKDUQssGPGpV749Apwgrd2WRZ21DbvnW0W4WGgR+pMwfPW6Cb+4SMRWWSF0wredhRsdFjnnxbfpS5AUqv3APOtylIChAdOQEzZNXvU8+6kD2tZX4LuS6v/L7uog7mKv5Gl9Y7miKQqGsRhuINjTbiLiwfd0KJjKERqFc8fBq6nuOGorPehx6RGCBc2XGF6fic3DVNZo/B+WfGC7Z6VsTl32YA5QPeSlRZomAteu7Bvvym/MJ1ZHgeneaggXhHOsXHSHiIBBH0IXlMQEUi0HhcSrIYksdNH22FT+nii9B5r+zLJPhWizG1bySPC6aMWxChF0wgKY6+1JdJE33FMTmQgiPs21FakOv0QYU23bcnSRfWqBLfQ8pn0RVtEZTYiIzzef/XmLsByV/NUwTiMJ3nmzY1FyqRuWi/y3TDfd3HFaTz9b+4l4t0lXyvju3RewG/8SZ5ezr20re/PlpeIlCsAUfLUF5IbSqRsq63l0N2jrZD20PQfy4CfqPm1a+Zk1M+Y5mBq7nb2Ozq1p+W4UtwZ2+vRe1ofxLEoAQkSdHk+4CzfR8VjvqnHlrAEDGkl/A6nTevsvwsyZXXxuxprU+KLmDpbyYLUcAz8wq5dJXQph8aQP0P4NggGxCs+j9OV6k4DwoIW64aM8HKqbQBlw+uoQ6Smhkt7Q6YzNu0MH6EGInGsrZnej98NAwzEtu9IAHDHI/p4krSBouWdKSpX5//le+gu9yR8Bng3YxRrqNfh05MFtoozk23dY1neRnrN91WrV+Z8hIoy0clcvp+nzeUQdggpnrK9rrqfKiFLOnxAlwsVd9hRZTV3ikqYR+Gj947cGmq9hIQSm8jQS/iDtvNamDWcpCkAHmJdN/gU/s9ip4vKyAhSdlyh1u+KUqrS5La3Rc7ZJgwdJ76QNBhF7LFAPkoMj+kbB0S3eZTNxhGyKFZDZEPMKWptNJ+6XlfDWpORGK1lA7b6bsQsRVqm8ncVZY80mvb5zHyvvFLKGckMAfWSuCozLV6gzkJn3g+wWlrwgtnjdWC6YTOO/fTbR/hWCA7OjDOfHv788cYKZafvURstaB4syW21uQAP2vK0NZig+H5DZcYykBFOW+gfKfrhJIVVvHi7VBuZvOT53eEUiRslgIJYrMn98eU/txCFIRxgIu3wJ8BRndZci6AI5SgST8iRkS82O9c4X5EvFDHl1IGSuF3z7yaP6qhpNCmFdWcD2cj4An61gL+R2rN5nuKI5Mklspb9/8AtmYZOoWkwzp+6VxW/bTEYRpTns2uirWtzF/ONf3UXUxdZPtZBs2egRzYozdaM8JZk6CohKx0VC7g6xUB9m4qxFzf7bwAHFtKhhY8pVEvQB2FKi/9ov8SjzM5u4ak4DTKS2tRsci7kO+FOR+P+1mdaXZ41JBUpKRMJBtbl8RTx2v6w68qvt15u5ljspb1Gr4i0m/OkwQDNhVFyIMome5moCJVJwXGg04Rbriyzwop4di05UMx0gR2EKpQGjbNhJq49/x6sA26cbgmUiFCUdyNILbTwtm86ME2L4IGDs/w57/dKqDwWJ7eId3h8EcfRSdlcFfUgutimEAs/Rfdrd6Li6PL9DwOhMvU/dw7WNpeHQu3stQeh2abtYTx41g5mV5AUXPEHKjzp5NAe8rfkCQhIrF2VTpRa4LY1jkuofAnz9b65VKwsyYThSiCXG4bxKtPTjoCOoMt5Mn+nfiyb1VSgMxZpz81gd2LijAMZTgVtdoxu9Milim5CAG4y2/UGXCPw8w1hfB9iH3hJWs84O7HtqWhhsXKa24SEXZSLLFR6m7qRxo4kV4jnT8bSH5rz8D/R3AqzlwHhZkOyvffbtlFyBkHg+4+jzNp1pbcDKoe2zBb1mtnyIjuaIUD0AVcSBoP+0nZ2ZlxFfsxSRvyPub+pI0kkAtRvs7QFx5F9eZuFd8g+g0lO2olu7SfAwj2kYkW8oA/PVVXzJHmJnin19rNv+zIAnROJRZIoTdI+eot8IG66bQ94citBci0Cw9tgmbclYiIJx2vVNTcQlF9tJtXZGUIkza5Q/qaqWsdbJb5UKZ+aW9Xg4cqPxH+E7lH2TcVcVyMrGr9FBr4Fgo2eA5zvAJcFi60UNxG/fbqEfAc/kyNHrvLfujwsnybfdUW1Jcvpy4ZbC4A+9ftxWP81iLYaW/my34L4DzksWiBVwrbCH6Vm8bx/OoIcFfH9Cy3aTwtsLdPmeiQHJX3iCLPLrMJPi5pN+jc88o4XnFU7fnpMx3Ivd3fFc1BChbEO1jfi84v8t2EH1DpskNubsWeHlnkwHWNUmwAQ1PIRyOWUGyWleWbL7mklybCFLEzygCVx/ODYOdVpSV2wVuDQ1mOdGysxjVOWrUGSzGDKX7T42DNQ4zP5kxk1IgVo15MmuRE8OYDnMv4VkeGZFL9yWhTq47jgZPi7tm5Lbo+cR6ki0mX6tXngsdVq0DDfGLXpVitXNvQ2DGvxTAo/MqHYStH3lkUM0FfY31vp+ERCmwlEd+ApI07SG5Ns/1TN5ALSWHmckitzBJOlu7onEWnOJLzFBmaXeOVM//YwM6FU4C0eKpuRHAHIpeWnh5lomFU/GuBdydmKgl45+qTWmeVqBw9WFc/mUiIetqwBy2g9G5uhTbur46VWUP4R6ziPpf4mA2koUid2tzobCX8WxYdVqP36/yG78usdDHDVGkrZiMVqh0817zIDbUlADkEH7vzTpoLs4f+ZCY0TV/sXRi3gcHFpUoIt+NR4WSHzGCOGsBhNEf+xfFBbQE0oKFUhvE0XjzEvg/jwgwbcIAoGyK6tgvVkc1Nk0hOSlOuIGgdT05sjv1yA0oJel+KG3O64N/F2Nhu+oiWKjqk3IaieJ6ipde0SbRC5SrZ9p+g1mhVs7LQbc5PZUdIYFHIkXP6Jd8bLvB3NgPB87sBcZlWax0fOag8MeHCYfu9kr7zk9L3JtclGyg/Y5lFrwhyUDq4IDmoz21FGvHwQz/Wd9c6kZnOxVgqhjAZpLW7wLFP9alFsZ2ALi/2c19Ehh1i+NjsZ/XZ43DqZsO1UJxJGFTJb5UfBcFV1VanzrSCA565EHdDp7Sj+UQn8zq1NkE6j41DkL1vSb0DR2VjPKz+TrkqQhfX3Ua7GGqiDXwhYlDxVXJripJ9Q/up7vdmPX1v0RbXgNe8ecenSxnF1ZgvizoEAdwm8d3+DlECMro+x28Ti6nzPGhX2DlPVDMH9FrhDp0W4ofOptjbAsV+93HuZwZsPD1J/Tu2BPqVhEy9lib+m1RJXmR9uv1gv6MMFEL3NtqfPitlyUTP504yKFR3J+mVvHwQYek+2zwRvNdkY79Quw9ffqDphgYYj5HkfTroYvzNyVBLuP6Eqn5AxtSTqf5qZD5SkC+8/JKOBreUy0oJEobzqv0RmMxihCGT3tyk/8ZCr3EnMX4tHFQdYXB+9QCHaygCDaaZ2A4yEpJGf8kgJD83ZQo6UdUAywkifLpny016c/PtXDvxumkkC8l9odCgItHFiQsszgJzqR/x0lB6hQ1t/1AzDp/tbnvzcze8TDJzuiF4tRAhr7ZBM4vcRhda3f3LpHCv7rk2lHHF+UOzJDWB8Q+01PupQJDjZGhID7uDLGOAaL2RCU7daKC5sQNBHhFVCWFWae5HFryIR4VXkUU6wYC3wUO7cpIlLQecrsCzE5henonM7sICHJayXyPM3a1EqntnT41+XV9ii83L170NLsEwgy5d6flZllbtkzKHczEUs2gmVawbTungKNh9WTioHqFZKnOmarRBu/2LutV9Ak4xwo7Iq+1OYSwiNZGPKMeV5q3QSpma4d9m/IffdXk9Y3p9RKZSpXT10dbOTbj1WjIMTwzayud7+3yLm3qahSC6XQf7TejkJqSZfGut2H1Svz5dXQAMSHukWHvkjnj6+srkwoz+h13qZQcaUEjWaOKHd7C6eIGEdeueh+TiEosnb73xA+IFNoJSBkvzchcaTjWenTL15OZVJMev9VgdP8AoSXx+05OdLtcpbZI0OqHIt6woVF+RFr1dh56cevc8pg2CkZwSLNKZ96fdh7UNP2wJZyiktp3PvR7ryNXHTeXWYooIwmlBL8QgJvJdqiMsIcfnvIqrsiMqJDKcwf4KhodGFz+zxcWTlRwQQoFvIUzPD2ova+9SF4n57w3FKQ5/Q/ZIvWV678JLybMolq9Fj6P0BR9lyf3PX8KCByG/WCnbI4c1LGOi3SnS/kgjJogdXEL3650AyKNy4PrxTcuMjo2HyN6ir5H9FYQe/kojZ+dbG/M9pOKVKCjp5UnOXgP4hlNsuKSHpNmmL8PJlI0C2biBvUSdXwtZWkzF0j7T+VMAWelkTj+CENwGcbXkFJGgYkyuCX9vE7eQfh7YcTgzMaSy5Ub1gb+uaY7JJwGm8kk/ylb6r5rAcv6CgtNIgWrGgUjiO43Jz8E+PB/Sx2vib6XfspNFcNGHnW14SNvmpbZpzBwoszbmZVIcafVrmZrup8kUH4hyHwpJvb103IyaqITFjjDssUS6l4gKZnZ2XtSopuSCM1kG55w6BeRKI6WjF01Sqg2+u7WGg1uQY4noWq6kAfPnLTyaV1ISddFxS50t+++KZBKRGQ9TdVdIbx/fxcK18e45HI9ssHeJWKRcV2Q0rxZe7xUbN16QuGs1Q8vsLBBWcZJQzN5a6sD391we/k13583L3GzHcyDvGNmhFnCpqLqkeiybDtcdelwbCr6Hd45dGdqji2DphDCEOGX/eLTodlpDeJbPxQkB7PaZbGOR6OfYJRFvd2whI6auaWrTY69fJs365WYABJBSQv+3ehVuxbWLrxeN3amExnr1wXL8tWUo+CoM1u/dOOmnPZHfUAHZ/NX8mmhqdk+q2fKy3Hsiv3kPZhCkf9n2HSEr3TzF19Wm3MYRHRH8M2qBxDNXh+4tHl2hwlqF5f7lsr4OrY9ISAuImyBJlSbt2k0nZHDXosfIS7UXirefLgZtZypUb7KS6hp06cKzucg/Dg1YQxjT7Q8uFL7GWzCdnjHbCDZkxpGlDssLUTkXQXcyWdJRBFPWZL4by87cEasHOGnQ1N2arOXgaOp4V1+Xqr1/dkFVT0AAIkCsOEy/YouCIguIK19JPVs844HePn4nNQI9A7QK8kqHEAYWbgrZvxC3vLAazHagIQ6tvQ8oNRNYe8fsQ2BmekhB+wlpP7nFbgepEqzlF7BOcECvZ5aIdmF7igL8HaVlFBQxbQb0rTxuxkD3mO4gMKQ0ZcVw1kEutAiWukNrhvZUlwl/JfQ4Rkx4a2sdzS6aSy9S+baOQJMiLw/asrNADvGoPJv3uNk+mLX0DtezqauL7F06nVqrKas+rgbdZH4fbxAp7i+/HFtuuw6I28HnAtIcjPK1U7TA7qazdaxmbydHMcmde54c1yXPiBhYLPUGyV1zZY7MOVUWlJgezUK/c5xfegjFTVslrxxq02VGDkBrWTzadP+gB9nqMPXiYeqBls9XldW2p1z4XUhGb4j4+JeoBN9qUms2ra+6UxUES9DGP9SDmCrXBLN2WJUa4o5Eo98WNhkFQ/nrJon6pbovQWkfPdqZN6v4jUiDXAovqUqaLrrm5hN1hOsWdhYO6n2yWjttIvRmw6UhhqMxEVKfSdJ5HzunI6zNbeC6lS30UIJxrRaDHfK46ilRs9COUQe76Rfb9nAN7ZnxEOq8Hl1HKxhGW0NeKbnwx9mKN8m6yspKDh+srMckhoSiogOzkKWKKFIqyk2V9rmWaMiR6UQ5C/YQxQWtdxg71HHuTr82JtwnEq1bhE5Uiq+L4fMrgYODjOrtuCZgGxh9A1gIymQbckGWyBHsGujwW18FhUCLg/akJtjYGyXAJrGYEfemhYWmsR+cSpE3DnuGPxeoDnkMRU2o2PxjUu+pqtEf7zJEA2yOUhRac4q2sYubtY0ynfyV9w3iU4+43jJt7/DCBv0x0nRfQn3PuCRr++IkpkKEwnJFou/tNgcnHbgXOMAcG75uTAeEQ65Iav4o8nn2ks9BEHZwz8BmmmYU/LX79vh9xZ2a41+YknDwJ3gAKI1OiO/i5yuxpu3abhwnUfZqHXuo+t573kHRwaoxsr/7/PWf0jrVYu2wddBDbvUJAW+TsQ5Npoh4ulngggAHRf4+2cUU4iE7HyCSBSOdaULKA6dUQuaU1JkfcxH1lHM+ZLKJuINtPhco5gCygIUELihZEC17iMm+ZN5UroTF4r8UUBck+4g3YJbLTMw/+CHkesW01t7QftaYiv+iXGXVGgjI6KJbJ1jJmVoCFcKvEboRMP+XmQGwnxrc4Ir/YmXkrWqanL+rBVnU/MzQAN9j3UAQOGWe4/wbexCBPq2dKpLd8Heozm0IBaWKRcLt2RgTJGWN/xlrI6QO2ibkIuwyBFOn8rg/jASet4BGOPIYZQFbHTmr2IJXKefUc9PRexpDaU2+DbDPdPjx1BYasg2BTfh/6npmsZ5m8yd7fU6diS6BuJjj9Bnbxfp2XUSp3SNXhY0eOKChtXQlKq9tjIKBAbrDY2Ii0p5igwkF1ngNQFUEjcroANbyOyg6udBsFySLPtP7FLAUNo5WKi9TqSOXpxe9ZGbfg69ocdM9BIAdnyNJowiK9jrLoxhY5aGx6UCWDA3s+hcRb12PJn1NxdrSAaTz49eFestjCcjXHgrpIa2xByDcC1ezdi9vfEQYc9JXyazRUTT9RNI/n5Wik9GjUk6ldFYcu1JHnD6/3Jmn2cQoZABTgG5ibz94kRBlga3yfI48tv6CDsPuWVia4Its8OA58yR7nyIN5aqyUx8QvTPsvz0FgxGQt0wsIe9R4F3DuoxfgqVD/t440Ktvi0y2BYqVOzIriTnAFFud3yZfSZTKnsk0WydK0QkT9jp54LY+qvH0oI4xZoHZ2hK7qltp9Aj+8EcwHVNFblmSar5209eXvp7PfvpjuBH+yE/ACH+cTFlFpEHg5ysXrA1nfIG40w6+2o/DABObcyJyzRJqVQyDrc6SEwymBnh6/v4SJ9ibYb+AhU98I82Y9WYqWwSrroHHXubuO/mPPgKzn+asHDsMaQjPzqk+godnlpsbWwA/QBClJZ4+wvGRsCQnHD4nVMO5g5nLCptqUHr+E3Gp+AuNIvsFcHrRb17OO2Ac0MurVUKTAJ2R2un900Vyanyqlbbm1y203wjMyePPW8ENGLVhnzgSxLA6oJQCbbQ62J6avb9anYLurwmk8UXgnGtwPEmP+ICiQHvtVAO2R6i1spkzBgkX70v8iI8RAlKDQBXzDCze1fE25Wh0Ut1eWDBIxXZ3hcwRtcpwiXP0oLG+qKo6gXiUprsEfa5WPVtFHbus0ZS70SlwIOwNBGW9Eqb6BvuC46hluEV+mXV7dkqFTCAhQpJUySAusIBWfpw+RlLbA9PDN9i377oYSA8dbBLz49IupnJW+lQY3hgceo1ODgzyyyIsv1oj8aTxrP0w5MxDGU2Bta6iNP5EiB6oIayRYP/ZQNHVwNpXxBDGYHHsT9V9hfFfZoL9vhECD9wAuaijjSaeGvsqUOExqhw9ypvrphzHt+JimH/5Jqg8jaU3fvwtY5zuXJ1LSxcMnslh7crW5h8GpfOxKK/Sl2aNy1hZCt5WlzfsPyXZ40qChjmhWG3EqxBzuNWdZXP3qLhsmK8qmHkxGVUHiGFo/m0hxZGPphl2RX/rgALIcIthUIAPlBPXlcgaP6FhLqAtcRJFdhdHX6RSFojx3pwJa98By1be4yDVgC+n0kNFLMlUZApQvSBn8LT+4OwYCx+edRkJcIHyDmXAOM1Mv1No9K9HekCR2na3Jx2+j/BgX435TznwukZol4Wjm+ClRxVAs3XwSUUkxUENMMHCNXjarfPs91PNWP7Hcn2ZlUowu6Ed3Av7M9XCGbjOjB93xCu3J4s/aScqsR08E5WKivAt4CHJ0WL/46IZt9maPFnlEsPgfsaQGwsE/KikLW3zC/TmobW6wm0nowx5yvTscfUoFmkcA/KEcW+3WmrSMkLLwu2mkkPdqgebBEohR20FcZ5hbjF9wJuEWttJGo9bZ5Dzha4dBswFdx5sYrcBFXrkWTSrKP/A5Rwrnf09+BO1bUkCQRAHiR1bQsvz1x+AIZpjpBN2GEOI5puGqvA6qhQZnmiedaNuq4m3M0Ak9WBTgNXAYp8swrXr5EqZn5X+ODqz9aUvlKSt8RETEq98liI7Bh+iSJncO/5pf/jSLHnZQVW/8NgLMt/L391Zy1qRhP0slFcRq1wpEodYTS42q4wg5sWjQXoorlmlynCcaXVeCsZYQloVUBnvH4mTWKPE1Cwng/BIS3wUBB5LL1KGkTMzodUQ0noxhWMVoZfApiBTfBez7h9NOEyjPqsOxyla8x7ToJ9DkpN8ntjdLPO13BQwIlS1rm/z0B3yknGD0n5L9EyEVIzdBtpY8lBPQV9a/bb9O6jjnnZNQE5knWk0kmuBysQGtkrRLhDLVASP/ZufqDY7m5WMGzBLU2zOrlfI6bmQ+PsLzxfhoRIrGvBbacLQEQOrGZqQnTiQJI5lMQN4BH/v6oya984d2v/aP8xUl+GB4qKQh8GBGrnbY+ruCwvC780+CnfjL7RwfqUAjgfoKqgeiN4J0jjyKAP3KpeEhvZmfP3i/+kX1Vq64FwjdcIhYUMk7w7+3bjOR7bam5hEh1IQS83REX5BCUL6hyMF6h9lDCiFJy2/Ns4b6YkMtV73Cs8/8w+1YbzGSadRAQ9aepV81uLvM5sxI33QjSYy4ueduLH71GPu1H8btcDaXp7nnHMAB/7ORA6BXaTaomItqnkUmED8PI+Mlneq3KaqsEmqCZQU0lyhEndo2RDZAJA7M9crBYdYd1QLQIyMrKlQcvcOEt6iDr4J1QkgBrCIs+gSZ2f8gFCx1U11L9xeLBIR5EQg+y91iQtCqEeVt2zqaejIOTZRkxmwAa/ukmfWQ1JkwYKaJ+HN+3y834xiLDqlrN3xc7lXtLHkJ7GVRW3P6j/GkEH70BPN9WmkyH01eDSlz37dJNBETfYdH88tvBsQYfkTHgceO2Qmzzr2TxIhUXLP1UPVQu/6yZuzxyg3pv5rUPR18P2+gOg/dQcbz6H/aJFf6rWRwi6FAIMLoucZjR+NUL9LZFkZW6LHGsOoWyU32GDwYEeM41TQTRIbPXQCXr8sfUyeDUGqSP00Jx9ELgfMbsgKW9HQ7Xcyq+rjuGZ7ishhgKf8hzCHSPlLLTRbqNnZEu8YeTNiktHhVf7YB1tWzvAytrmIJOvEPKZOP6GNMmevAzXOlaOHE7Mm/pTH8ro0ymVDjxlKryRxEQ1XQKI6UfTUTK+zDlEcVXZvu8/mXeau+idQ+BtYgTgDE3hDudSrbmz1ZIEBt1dk67OwrVOSM960FjD2Wq523zeFetVroHnp0XgJ8f+xVzi9yJWTjFGUtKwrzaXgvFq+JfU4XxYWr6c/JGVDysXV/cP+McckV9rAgSkoLTSjmEUbAbLv20rwMNnrQU3b823vR669Wbb9+tGBgZAwFZOL9pAwRoMVxxQjB7qbkyWcV6Pfq2Cv9fTK8x8ChJfdB8LtLCh+Xb6U3IWM6rUfo7MdYIFJcWeqXNAbkjFI4LpUK9Tf0ioif4mgYSEz+jzHR9mwLWNqMXdgVIyMPzsV8UvP3qvIGMTBQSTz0HZtt9m6B1tWSbMC3TE1IPpqSUf+ZZAyTWw5IOdQqHNegElYqA5PP83iqO4I24D4Pswrjs4AvAfYk/DM5KXUsG2FYRUSeuhE9Db7pTA9QmhuMUiuEoEyQgA9Dv+knJ8s6NTu15W/89MFjxLdoic0QgDV36/RcFJmeOTc/pe12zCQ8y1w++mboIFGXvYZeQUub6x4Wkl/xgBrTph/iicI3pRdu5IARxx+lY653S9hfVsjLgjByVH9kK+5B5aKi9p+yJ6IK4rX6lc/x/lw6oEpYixXH7lhR9oiaddTzib1AGwOm0WxPYxNlEJ46AJw/9s8iAgJip+X/+THJs34MBHi6Qse4oa6NWVhyTkGTmszgvr8o8Y8G1qu7Em1m1XzDuAk2haEVSbMmq0J63aKDtehsd+KzkP3x3Cx9zO0WnpqTQ4JB9qvK1LfX8XKcMjHUHyN9FDNd3V65pquCRTLlHWCXFL74LuMG0Gxo7stUt3cAEb69Fwz9kJVX1Br2ayl1FvaMVyiLjW7GVErqSBqQHPsJ40zRSgTqkqCexEOzoQlvQprZQAKSEUVblm3rWgtneHhrJdxN/ba8deRXboBFpKFTZSDXvFyuODqRdmUga09k0MJeB97VlZBMfwjUqzhzqOGYaTcBlGJxF15I1YRB2Jfxdn0+VjKL9RSuO2aQYG2SdmJ+WzUe6qpYZC8a3BdvUYJdalgC0+soIn6nV6+XhMlraHzkAM3kVSZ6zOO3J6weNlXxFHEgz7sE3i/RQBpgNrffTD+9nIR9Kw3ObrqF5g3gxBZf/nu6ZtuDRUz7ZBqIEMfF06htV89PceK0qgccMRmYIqZQdIRhrAjMeCsV1Siq44sl0EcLCe/wPKFLI7YqrmoJ/cNUMPaMjHUrO2xruRCoA+Nbzu64BJNljmjjlvi04qrIXbqWLIZe8uuqGeOvGvGtXSXsK/ptaNDA72C3A0cN1eaX6mDRzy42TBBHENqh4JMbgEv1g+ccUBpUAIT7AfdjHbZfYcygFwtbvvU/diBrmx0PXkJbZO3ZfhB0cZCc1bmAwgI1+mnXliomIbOM6YWAc/Of/3bxSvvKI7tmSmgcmKiN8TQrEkw2Gs+UWpeJsu18Ycp2VkaOD+/otJCxHpYmu/Fxqy1jziwwwpk2XvTBNJ7aTWRrZXdE/hpQR9QNzRklPWlqB6R42vQJMlkvxHoqSsf+068K5usHlIk2/VMsJXOYJfYRtmrl/pgdf9lL2uHjooWofPEphwsgMapWqjccF4iAf/OejrVVZfSWwttzHc8vuNkgPrC0p9d91eWly2sze+o2pA3SsWOqu9HjXrl/7h/TidKZfMLIPV0HSpIUt7SMcvKqtc68x9mSHz8GZF6AZJQbaQGI1sX5DUMUmEzTUgT17r1LtlhlUwr2CwzxpmuTk2rE5ysEdWsk6Y5xP9sqRIeVR9+TcqsT8IRX926KIw8UlNX4llHjOE68V1WZKXWt6AQRrBdlIa1nUcdC3E0zkryjg/LGp2/WNgFsr+htq0guXs+J4IaT+VGYhQZBcIDfWa1rWifLKCcavFObfPREq+aB/g/07Z2hGIzmGT3IxruogSN8POSfXgBYRIiMdSR6WF6YrD8AIs720b2qGKkqEI7xwMMeY6tEOfUt4DVm6Oc7o0mz1GVWropsjhSfZO3rA5prAHv9UqjHx4tDKfRAfbHeqgMHKgWC/nEugystRQTvw0hpXtpMpAQgu0CEQ2KZuyqfmq9SBSzhIpEx/2z0SehsM5Qit9OTi3qL7KPHMzDUkPjoqsUU8YnUvSGmDPj88eHwQxCd1Km/kj4RwhmX8fm7WEErjDy0mujjHK8fSLgIHTSzWMiq7KS+vzNLvYrSbINmqVv42wxHw5VWHmYPUBdWAeHVQT4wCXKXrLmWHYyG7Bu089FmLtYGQxhh8dtNBmryWhgXii3Fnr55J/Yi28GitZco5EGj2+Y5Y+5jpJVIA06K1YmtoPqZvxJYOOGFesQqzrVX89zmBc2ZKe77Am+TTGt80MUUah5rects14sUo1dskve1A1N+irY2CtLpZ8zOo3HDtXEszoSy2cZbk1M8gwME5F8eY5ZxlQXUVJit4Y50HJct996ehwTns4orKVZINuO7x/c4DVNo6rT2T56WdJc4zZvL4FnbebjERa3xlPJallHfvzBQLe3khQgs71j13XOjrqDLyAOPuCDO1Netyp5EjwzNs+gTXbFTZru7h8M1Bi5Rc3JCVvneH/bDFz3yq/zAbNLoJ0rTA/AI09DM02DW1oE1KOC/UN9eP7eNOn+C4mRmPtwSWQGbmmkUYCbeGjBK6a/i0Y4D+eYiPuB7IzWgRA81PxRtsX3uSZNCjCM1MlLbNDtgAUVVZSDXIUn1T/HOPjf9vmVBxbM8aWHIrd6Fo5gl1uvJ3wbLG7xMNO7bQVDpTViB9Uvyvt1yuWfQPqYfqp5baa6cLjK2VxktrJtx1mGXOZlXdq9lmQf82jylR+PIiU+9la/5/HPkUWYzfvZQHT6nmwkAsRHb6GeIl6XmRhslCLPhbZVKnWtV+6VrwlZZrWgVtbzBi135B1LZI5EBsxwJoQGmrQnbNrey4mczjTp6IC9LGxkbwoOaVSrtw0sE+Wj30b5IAtO3WMi91N2p+tykPi3iSo7aGLYgGHEO+nNIegNlJUF0dKQQmsjfImvspv/tpkYHq2AYO1im/kcKAlcsqu7/flNUf8i/9EenDLKzHAsBm/nQ2UIgPSA4h9ChK/SCuwFltOC2sJgaWJROS2YIkrbGXXiQYg0IJWHOX8/bTwFdbvEpGDAZqGhoYuEluO7Epy3UTTBnrU2X811kufp7aCBqLxmGYMrjkK5+O6enuKGmYqC9bX4eZZIHw8UBCQ49nCCYdIUgjt1V5tNsRyP0HgeTr53LfHigPli9lK844mKFAxzZxV4LYeyXkWjSMy0/Ap6qfwii5JhoQ+I7nUCkiNhjHpVmaFyi7G25YqH4ZmLgDUUwzgGop7MDeJ4bPH1LbB9wZMoV2kDLjx7TkLHvgbJAMLQbCB0kmFUcMo5YUcUjDvnB0Wa1bSuuRfYZ4MSOxgRsd3ERoCs26y0S/f3/yiIJyPEf6Zm+9BitGlQShSJpmdciX8vEJRq05Dv04OKTeiKTLNs7SNBhahYvB/WcfljzMzROJsRGtxcdWEL+sLeRLbWF8cGB/ZJHslIn1IKlxEDVWkaMiHTYpon6mCD/9kWp1xsOOS0zdfJICjbcSPYE2nAUf5o34m/cac8JsPTDlro7Fla8PQgnsQhTN1jCCIWMHFqdWBoFfJksZkGvfeLfOY8AECSuxz0JMbnfy62ATw7wdLmebxRxB14lhS/6PTBEXmD+1FDusko6P52FJezxPBHbOFLGw1In7dZ53bKgVzQTOHF9CNTkyjavK97NheD6mfAIranlLEvvdowf1czJUrTDADFYd6cWOQ4JHrrhbrhjmZ7056E3WObUQW5/ng/xmsUzLM/kWRFCcG5b0BlzhhNVY4DZ5OCO0xmBsuz5UmRvTybBodeZfgYnehhp18Y0wN9/WxH0fY+QJFrnisWA4W8ECctKqKDpYM4Mrgd/tq4F0809wEggzzORPxO7hUwjUmOVTvnmsmM0R13h8CONlDZ/Bor3rFW0HrNQyYH1HYI4vdQAI/tYsZ3oez6z1C0+O3yHWg8Ve4I1jFZQtJOI4yCyKqoByJ9tqN+9AWrMch2vch38gHqO833zeIFHpkew2aXEL9fjWqWImjvHayx9LPGFmNZNMBjxwGdV2b8hkDJ1o2EYxd/loEUBjzfatNFMfL+mYxIm/2lRg8TJliny8qlwtimt9ENctqLfnetjdc+HwZn8RDRe9p5qRSRKhn387N7ar3Mm8swyoBe0jv+UTj3cWipnVudSfYqumGSy+ONRWFJULUdKh34trWtjSTnvtULXxPQhuCQZI4OJmWRRdyT7CojaXcpF6zfXeq7URRg2az7as8C1bZkHNnb2+yzIwgh6OWHL1CafOtRkNX/Sn5cBfayD2SSA9+/ZghY9mhnLKmBiOhLEsoXWEsZExKwEgEjTdynQQpAIbCsquRhL52os7XuFCztzU4MpMJqZRuIiX1ROT/Fie5apBlB5/hWZxPypSTwxKief+uCHPxQgAruvh8twR6J3La48rRyg3LADwU5OJVbNtDzuMozhTKkMjsoLa49POXJNDwNPm6ycHx4wwn3+0t7qaRgcxhc3oRwPcYRoIsaP2hnhiVcQeW3CzRviklsuoOsHWGyaplaaepo/o5mTv3Wer9C69PfCjknjbAS0qNCqdye0RWlH83ietisCya8shY2Pptm0m/NI09lmJ2hu94kGUX/QjJcj5h0QVBSGsC0Pt/cQoCQef+l2eJR5pmlnWpL1XKXig7uR1x+7SwyDyuVEicyiilcUNw+thnP4pXuElo6V1s76tV1H4r5zH8laZInybOjVAUEJOBWeWRYXzM3cO+2jWze8Aj6YFO75mFi3W5+G3r4jZWYhxvuKALPaXzfTHG+IDOBrZMOCTN3jMBFXewRz49+rNpjO862EHMZl8194ic/6MRUzYnWc6WUgr4IzMwK3xD80WKQRtlhuMjO9Keo2P9W2EPkK3/8fuJt0rET8wrr6/1BiCEtxXXKNu2H3/Fi7LrAngfBixGTsDT9K7AmKgI9OYynHdxwEgLO99goO8gX/kT8rvxdJIRa6h17/8CCgA0CdUgSfC5YqnAMI9ZTI0MNAikidXUByH50Uz4KJ/KraNLfePz/nuDHJYrDVMDh0Dfm5osJIkhTt4KUDPpIwM6Urj6PHbMf3/BdU2vid6bXibnIv/8q3/tpCGbr+sHbfTxCdFY7Cl826ek1zUixmYDeJaB5gDOxLBEMxB7JEEWn9nWLa5/8ygmquCHBTqEe/FCWmDhcHJ+bgXNvTPCovzrMBs7lymYpv5XifvhplhrAvTdErWzjUOLx9+K/RLLMViHNcIKotUdib9KZ9yEPmQXaOkg3IIcAycXmT1/JbWRWhW+aSolWZyR4hZt9ycEwNA2BijAOIk9wgnpRikNN6PlhAg1yxzMyfqxfjCa33oBfv9NDRQLYgSSL7ffd0dvKXtrbwDASbWeAsBpO4EvVCQFiYwCJqhOhoTT+cFcy1bDIuDkcfVD5O2vfHqve6oNZNI95bwi5g+LqniJDNxNbLTvowLu2a/4D6tBX4cJhMBTvt84zAQISJWZ0VOYv+4RKpXQj1K/Yl+c0XRsTxoy9eadNsrhsPokDP5otG8MLyakyYBp1AiHGupWUTk2YlSnyS++1jEpPTGkppzAXUvHJ5pcx/qY3cfQ8pT2XnBvQTQytJRAITbyEC0Esw95aw/mdjsbTjmoaAUNH+dHDARvAfC2xYbAhu61Ippz6SgZ/BJHLmMZm9VZymRtPZzH2/EXXZZ8o5HxUuzUGCAj4+gq4HllyhBCD4c4EQyy73L3fsbzREYMhRxrOMuu0X+YhQu5usH3Et8Jf7ORlmUmFimgkcz23Sc7+/dCDf23gY7mRBffYV5682nBiAr/sXh7kYZbOURV1wuOGN51+a5lOpb1TbeNQNXV0eH1iLHK1ocHJDU+tHat/A7K1rEIrRMhOUahdo+cbwIYO0PhGzUw/eJxzFr+HWbb8W8eqUVYVYa5OCiaJ14v+ku4WTLTlwDUg7JV+/Guw2P8ONONWq+Br9IhjRLYRpSTzss6LlhRnxtcQMMqhngyDBmsXSTUVe2kyzC70/2rDp7TkLYvkJvOqn5R6Igta6ixe027VZA/LVZydcZ0U4oeq3qEGTY8gUb6A62YPiG9trAAY5hZewxr6Jr2sRlcWXkX/Z2WOvzLQBxwGwW9hNphXEXduwX5ucY/2tLck/z0iCF+fixzmSyyfhL4/rdQUtmhJllYftaj+H6G8NFt5Ndwlk76af1+KUyYpOqgR/S4uYxdVMi7iMCyN791OuNlYjFt03xvQr8Mu6DIVsHFzs/4xkzpA4S9eXUWEn/4H/k2iDRk1rRbPMv35FS85WcWFZjSLlsjeJff8n6cKGWitGnOowM7QJZ8ELA1OzegQBqs+/gMG7GeHhjlmbMxnOGLj9glVZnWoDFhNQJgwCcUvcbsjmsgsbBR005WTZ4TWHbRjAP9/DbIQVr2K84Jc9IfEB1MeAdsyw6D9zU6mSxzS0lkviA08+ikw86hst3p/uKvWGrqavJCmYMv5Hl0TxprYYHY4XpW9nUZ71dl4ShlujR0wYvgcC1lLnSBPnFD6r8Rx7wuEHQK4IPPXJ+xnM2lNM1VHqdm6h0k/IZqhjlzS9d3zHxqbBz8vhhvNIzlXYw3PPejqtn9VnPfCtPennDHyIbm7NUaqX9y3nxKLpzMFWhUscB1Wsmg3U2Bl7PrxLwWU5MZmeAGD+SKKRvbNF8nJiOpA4dh76nnEIIg+6b+ARGb2nw8uJS0Yd/JoxKk4MHAkq34NfQaUAYWeJggu9jmAvsMng4cu0n2hlZQHY94QmmrO8pox6R5M15DTED4WC07KP/JXt+0ERcFOujxUyhW/ILaUf7ndh41o5R6Wn4MIjQm5jZQt/Qs+uNagQzCP5fVnnawu71rvNtv1tdrkoStYkQCO7gw/zFz48uIXSDtfVgQYebd1Oi2kQzGosYzk8M1/YrBLp6zp5kdQq0to8McagxPMUqTNw7IShLH1BnI80yOsUfCk520o0OsbLFKwTuKH12mV3B+0YUXsFA+ycISwqVlMyfO7iEwcLE1GlEnQWCgpe/7PibWbmAU41IXPEetrAN4KuprN2ICKCcqU4ialko/QoAJlUBy6uGE4FXqWEv7uurl2y2BZDWxzgNG5Ov/Wn9D5x0gaG9hIXlgs8Fj9eFjvpo4u0c2ikrO5u6KakfGVFICHsbrI8oyIGhzYUtCFWvG9dXpSP2Wcc8wglkvMYOx6D1gOyijmkfS9MhGufr8ls6lrsVpSAdagxriVx9yoyLpoZCXlADYm1cbKwbV7a6XslVZ+AOd1DqpHe5pu5CIWu4QiT1B6Zznf4mRRVgPeA1/zeeLwAuMbLYYF2VkryL3u35VBtEGvULIvMkTbVJ3r7M4fLdhT4ygXJa82Vi/w7yRGVqi6sk2DLBQOJrsTSrHZMy6/jHgya/tcWYxZUCyNeAl8KKkwiGUGeuPecaGCqwWkw78mbejIZp24xvs6bEYwlynTzmypwzJcpkIK8UGeII21ispEyMsq1psNtdonwsBtX2fwFWdRASW82Yq8er1gsu6aJJ+0FBWN/Uvavi68367LDi9+NnF4FKRf3qod2GvKhNyI8VVSf55M0CSdelEAuPZKWShD90CzSRIT3no0UR0MhmpzA2kEM51vs3otvtyVS08qvDFSyaSLsXtmJRp15dzy2UpsF7ikYlRMwRqm1k9SE3JSRwaTH3gjzOh3q4ksdcToIWpVm7nLLoadWXy8gkIBLojtX+XPXhoKSYS3QXuXuRUc0g6I9k2uGD948Y7HohhuxHqe1j9YS5hYkP0uDgjhpxOE6Z88D/kkMjDP9LbckUwut8YB/TGDOl9Y450mnqhfwNExU1b+2graQi5zyZU17IXeqVnVrrmYf+pYG4S6KQBlZiP2CDdHd+ZcwYPZsyqRmXh4HsU0A4gfrwf/lSVVUVhgEhVYfBwlzxTD8Sxlu2IXc3i7nGDl4BU488TJHfaCLYwfDOIjlS+VbFlOOwY4dMMG4OS0eyE4h82FyznLxS0N/Fqb7UhokYBcSvIGe02DB7Vq04fsFY7GCGs7rJAoUCgkv04k4v863e72+GsWJUbijEqwPr7NaZ8nxtVUI3YS6sux8FKk+OheHd/wPSf9UDCO7uYVgNJ3F272/OheP6jwiGsZPpbuHX4zUIa7LkLg0eYZIfVoNZTD6duBZtHlBnQ/DLf+WMckjNtXT5AVzd1TJ5Mt0UDpt4UrSVHIswzYXvVTHEtuDppvYdm21DRbPvLMlw4+xh4HWtZ+V0KYRiGMaW/jAL++R4X40OPLsL6fH77knG2K330BLUHWb/wbdZH2ARxVRQgmJmmlKV90bhaTNao28Y5gxvQZSIpUwMDPYo2o95uNnHEajjtVGfoj8fuai+C1uuaBKg88ubjNu07D4ju6MxkSSl8hsLga3Efl42CFbNDmsZMT9VOsQvKRPepy0FFxvEQDe8rTHyp53M+Sh3+WLy5hogmKHTSidABbRlzkxREaJ5AzLJHSybkE5KaInp9yWltqmiF0ent7N7JN3vt3hOuH9mv6HcOuccdl8XHKUOfD35thzb89tzcBSCH+/LndteEAAv8xAzQ4DFyhkvyc+BkX+UYOIchi/J0MG69AEmu+Fe0ALqV5p3u1aLA0hg2S0kNDUZLATbrzy5HMVBCkqR2xDkspNUmzH72HLj4Td1ci8zycHQg0jSCaYh3RpP8BY0bks9AQw2yfJh4IFXOiiaVmQOyGqcub1qRtyDzF57FQkPQHczGyj5+JU5At2bXwXfBqJaNzO3vtw0u4aqedQexT0g1ezK+ApaFX32BJnGjOoQOphE4VHoQvJuz/CyCdgU++1WyMM8PZcYleL81z+/4yWL2hiAPrFiQRLl7P2am6od4lwZrjiH0hyiV9W9DJe7bHk+9Y6Y9kj1S59bycJvkWOPwE9hIuswlewhp//Wvfywjzo2JIH2JA3vY7iUKdsZTE6a4PAq2IybDE7UH8Wwk9p43nEUYapuB5Rv6B3rElCgciTYiFbK61sszoT+vwWnJvweKQLPQgOyRZpb1kQ/vSgCqKd23ra69jvtybpDWGGnJ330NyCY6pS4X2xD2ssFKmD+jFNcEakHkFoH9vnKTpAzE+MIw9nuJCXBJDbjLyp1ds+hFh4KbdavMjvNb4SiYF/QUWAY2clIDT3astB5XQm710muH91wq77v4Mg0WtGhZ73vaN0tRXJ99p8AG8Y1PpF4QTxOW4dDJ/qbyFIjX2fMphqlGk8/Xd/7TQcBh0Us3+eyA5sremhvPr/9//6GUXREqXeF8Ui+pl+f3u3AxVo1VYen5DjB5IwJMWaQ3Le72Qtz4LsVLtHJU1V6caKSgc/27dNJDETN1svqMqN0HLLfrNdWLrcBr2H4vHB77xyfBnXUmaP6Lr3n7nncb/Zd09BirwNdfrNm4NpXmfUn3BXEFjuLCOo5B5xg8kg5AmdkH7xl+jfk54gvqFB8pUecAh0cWdUmqZAe73wfC7xkArPna9X7YaBQIuGomPnHRzZ5BlI3gs6hG3NY0iD2SRfYbVa+jEeGkhrP3ufK17MHjOD8MOFbc0u0JM6K5e+CoK/jZC2YX8lbn3S9K10sN1srP6dZ1raLAgnQjdFqvo/w47t+BxUKzKuJVXvOOV5Eh5zCpXIiv0nt6uvDTC+6HQNgqIl8Vp5bGhaEHXsiYKwvMoJYHg98zGnKCA2bJgZDhXWEiBIZI6O6QpA41rz2FmaL1K6JTzP/N9KfWPGQMv4d8vFsFQX8DqP7tl2yaDXdhUqc/hMjFkcdVwtWizZZU+gxWBCxG87RBewVlKrJGfWOcok6rBHjw4wqJiVmJKojbqD4i5EeEHrifSvbM5nalEvwmhsE+IyiFAe6RWSuAM5iJyYOIS9iAOJgs/aONXIV8XS1JwvTVzaAP/hhYLf+CIk7TMhf0Lvj8cPWrAmlhSGlSKaw83GGqFPW7KJSKcKxDoqgCzCzHdLzPJ0fXQNwf75Cs7GAsTWQ7XEVZA1lh1PSXC63xO/4PcO9T/KW+/cEcsnFf5YzhziXsJnh2CDcHXKu8jtPacnhyw8QIdVF9rm5/QWCmSHEs02/7zLWd2+okBhkHoQBS3R4hUmc2pL5KArUsPebliejhdkLACYvKxOiajKq2hRZfFTjWJUpBIMXLrtw7vMpdBDnybtGNFyUj3Q6/Pnp+46VOxlllOGUH+LYKE1ksD4zv3chRhParNdnvpkST8V0zUTCVCJRNw65fpCVaCoinkHcMu9G4QjTO7MZr1vL5jpK7z1RoUkRyyvHwWq4ja6WFDhjKaSAUocK22xDrzMASScW2wq8cxUtI1TfSGYlqyHJEYTmBf/MJSAsGYC0/Pfz2EGBUKCpLUMnJt4lnFuVWmoUIMyxrpm29yjrC6ZuaV5/2QUbzuWlwYmD8FqtLPcvLBawr2TMombJARU677BlamJkCtpOK87KMDdUiCGP4B0K/VptQTw0uNohMfuvtMmAiZ4TvEmV4AtC8ACgE69e7NyXsgyKiqueTP7FgotDCjY6jeN0ZylO5GZbFcP6YFLzFUrRU0MYq8ruwnnd1AozDvCtPqF/Sc66dSO570DvWD05lyghUtDJedyg1y7cSfIs+b754pqgD6aL/y+nIxMGBPIoBpm0bUC6WfETIVOP8WBZ2ltdBO7IQjHbhtqpDVcIUg4kQYet6hMyu3SQWJY68n8d7YwyeXykx72xm22aM/bPLaO562Ok+TTBzy/4fvMWLUGoAb2w+0Z7dPeC/Eo+QIWtikieHGjCAwjZgMPqQ+Q8yilLAZzFi4WqgJK9bbX2iTphJbdZVjcyQWwpK0VTuOutGEbxoVgUI4NBvLDLff1CipU4FTWnuarFKzMsMkw8eTOZpV04L81jSpeRzghPNeP+tpISsMfJfSvmm7os8N8JKayrNI+dLk2uTL+HGOGIyxN+yBjts/SZE540kDwpv46zSb4OPEV3sRM7BIukSPjBMdsBrA5wOFjloTH3r0KyyFny69Uu+oTGv6TaXVN9rmQaG4NJNFnw4N1nxMM9gFdZjGBECDONu7l1L2rvic+4wP5FFJOVijgQ5Zpj9o/0Ty72iLm8unYGPPZYOTM1VpibearqeX7tEWrqwcs7u6U4eDh/ttIVtEB7P1hceUYuunDIlmJOtlL5rFzPc7Yu74iTJjZyWFAb4pxAvL3BngO75FOhTHSqnGplY1igYBq+3cgnlyebjWgap3rob8wyQzrLCeVGPaJq6vcLopaqfopEihEC7a7b8javlGUdi7NQz1bWUgIbIxF5tWDPrJEPG1VndLQGFOjpq8V9y4Vox+nVnkBSIFXqjbViIdFwlvikXjVm9BGQF9iTd5cYlK0GKf8BFv1EV4EDUvbJap+QNcQBAA/X6CTbcOnAEqQIcs34S9U6oA93wo4VOHU4g8N9YHvyXVuvWeYx2G9oZ+KxFsvrk+mrckJ2H4GIJQ5h5eU6+GdVkncV988XjUi2sSJ8Emlu0VGdB2BivgrgSXo61cVblCacIwRjzW2Carj5mhAy9wvlFVHO0h6hyzUGflQacMi/ayiamoEWFXbCxgX9i7fVchj0CWyST7pQ4x9UtqJlQfyeuYNCN0CgKnIk6Sc9d3o91yKjfffpH0tbEyV9kdQZN73+6Wustdlu4ZgfvAznDFSxrG0AIIhOX8q3n80FflzGU92eEjJOVorTslg1h/oZqG8opePyljTdjJdTEaKGOfiGLpMb54yICzUg7zY0M/GqVqbFu9q4GmL3Eqzu2rUTaHT2ZjefP++8b6zrgRlPfzNCOmmG4dHTu7xr+gn6A/ccm9ZHVvXd3Ww100WylSmb4jWuuiqOtmGebEJ088zUhA8U9WmSJYi+fW5k26lVLtjbpU3Z8YnDPTgtQ4JQSEV8auyzczHhmLjcpn5q9t6qBVzQd0oQTAIosGvx6EAE8XI5PfErUJYZJ0vd6O+mrVKRowMt2U7n8Oz8Xwgmev800y/FPSYq2fvwGamVIQVwg2Q73NUHGxQ9xQmfvGDm6fUnjZa3DpgKZiXD1PFh/k3+DwpxEv5Hw+YX0Jy3CySdmjhJP1ntL80Ultkfe/Ox+DM3nJR2OnsNIL7NmPRKIaMZpHwdz5/Po24kqXrB18TTVDXKuXgMq0iI9wbtSozPj/aRM1EtZNWXdZHOdlNbI6JfL25zH1I+cjmKUypUjitB5R/rsLpMZXn5ojoAYgJT2DGwqRq8da70Bd7TCxyNhEqP8aOlKv3iXFBU3JiA6hs1SSM8gsGoxajzaMLs9sfXllXX3LYG2K0n+a6pw+pv/AG9V2aqYKdusR/6GbSXSIjtY+32zxcYQD3PidgEMHF6j8KS7wG4d14kFYWaowA20JA5E61lvyrkWzmypCjTVGzTMg/CetaA2tvrtArtzse4bpYQ9N/Z9dGC5c2tpuqBB4P0PvB2zDvZybOrztEdBvdGZpdekbJYi/1J9G0DgJPWLJxQ/71zrg72aeDpoRT1FHKd2bJC+VTgDjsG/fc0EoghYzHIjjYeyN1g2/bAQ4Vlbtg8Y512oM5ZTbayEiLQBn70NWgSnJdN9gdNvSR2X+pGh+GMGseatMK9jfnWihOg+HGvLz6m4ZjYv3/xYcWBMczKq2uxt4gWsynxnKWkElgHWnl4L/MUqtrUb04hrzFuUDP3hy13Ylzstmoo/fBvAgCUT+ZMw5wcrCjRpOsFSrmOmbwkQ4cbMGMp7PaNCGIGR9tYRQLCTLh11kDgSkODsJ5pRzVV9H9775ekrTzaYwKWyj+9ASYxLsefM/bb5/UGJIPC5tJZlefAzJNDgQQyMbGbvSm8G1dAnJPJ8MvyNXPfWN3d8CsCcs0BgCzDCqIASkfQleclRzMjlfFz8X76rcuLWjqY8f3XGp0xcVH2rSuG8b3rt4bgBZqMqkwQ5zi/O64lqvJUXICgodlBKZX2v4U+MHsg7X07iPESB1iiJFGEDFN+e+LwGIG8VtMv3E+at0rShnCsOsNkym7gLigPT0a+KTcQi29uSeqf4Q/hK+UhxVyrT3VkJwQUqTkOCnB5OlbkD8l4ZH7E+t/7cCUwaC/WDreukQSjgNCJ+A85nkrJTa8xRyx1MWZl7JjvICdMLQE/lE7Giz9AXLqyxyHlyYRVorIIV8KCXz6MCUea3OLPmEagLvpsw4oMm/zD4Wk/LVddz+Kt2QtJ6DyPGGCKnzlvc8ZgxWB0ytIr6tjK1Ts3Y5shbljoGHhp//DB+x7H9HChM/QMygkeDiSFylX7USz2V7ML/o18rc36BfP4t2ei4Ycng2WOnSdHMNSQ2HmrwVKKUdJocOOlKpt8629gQNmw85q+NeoLeIgLgcROzzKJQ2JP3xyb9CIDFqXGTB6HoIlI/hOqw6iQccPp0dL5eeQEIP/DMG0YA7Ic6vPmAideS2fuKi91LYum3PvuWZwSZAysa21+qlQtVxp4jUMd1plk+gUJBENds9mWtXXDOebxKwzuXuF3vxdgT5ybxQX8dHsjum6WDA1/UbhjbtRLWZtfJr/d4h6BArqUtPJnIf6jo4MrLDxlB/hXmGIWsqDSdqL3VDDYxbhHz7IFxIqP+LedqyVAvsWA5ZusHzEas3DUWlALav5GMK8oYWjvn+oVMeavW9j2tiS1oCltqjbstA1LiBHM7evgd4rGLWv1UJ5j7MDpOdPhvOl9pNd9QDBznMaQBum8u6g6n50hF5sSof9DUp0m3lJaU8U1wYvcZqWE1qNC0NJtlw0XgZfoZN1V3fOoDJxrq3Ag1r3ejK8+vNspgWfWO8HtdQiIgvjBnYLKAwAgrxmh8mSFQbh5GxA7h0+gzAZEy5H+3l9j6hriOOtbjp3/mO9pTiICRjEANy98+c/nHnJlbYsfCv2Dsrd2eBOn4nP8OIH/IgP1rBRNX5xMdfddT+xdZuKgpAi8EFADLEpAIiS8tnVh3ndEeDgNAYVBCvi7RzXBlEo/jN2odsJuqWzEMI38JUjCujzNhF396BiD9ZanvRSi2y6Bu5JDURzftEuvT+vthE1l5NLLrcHFo6EFYuXUQkLF5d636A8J6e54eNRiO+cUDfqb5Gc3PJg6fmJF3HCzJPB+x+zdI3zOXuvdII71obT44SdrkcBQn3R/dKpFwZlNgyJQ9uaaP07VBiCbJjLa7RRG/hUhRgRT70Xqd5VC7wNkOOAbgn/91vMTqIvAF1912Oam6ZZDe3x/5ljvIBGchITzuQcOGy1FzLrV/DmIbqWVM/BinbQGxqtyaUL6PWVEoOUqzLS053KuJNL3SFvS4+q11urQ/LIAeYW+3Qh4wkREAcImySAe4pjsFqKIOiSzLyusNYXvxDxu56tihiiagI6HkIQftUZ+x3KLM9Ldts4lzmfkh84Ks/jR9tkUWmFluT/68axVXWRbO4cs3EJuQiIWDDFG0QDRVmKuAo/YvqBF6i4gnVH52n9AwaYa3Qxonkrs7v/Kwtju//nXzEoed84BY68hKsKgYjzzQp2AHs7ZM9u6/N2dQazdsFG3NKJcXDqyv3k+9E/Ri+Mvvk8Sox6Y+HW81CASfVBBbSdyyuzqfCFjYxEIhQFeijQBcn9dnJ4LFn/ssc03/FJ89eG89tqKNF0kzuYTWAs3V3d1IVZsld1gWxnm4crqG6quioj4SDShf/kfjMuB8ErbWA1ZaporlUae3fiJH1Xx4QZCJho/p0E4Ef7UKq0OlQwXTagm+Xc65xPfLtNKV7OPSolvEclMvyx0iFTvo0Tkk5r3ZgpX3hQD50yOs6r9iqa8ikZkrTIOeowxbQq4KxPI8MlqaXAuQscsPLlq3G4AIoSK1GlJ+qz/8CJNhThdh1s86k2UlsEpJUgkJ9uaD5iCQIByz5FbX0mDwXQmRp4M9VvO3I8HE2XNYypvCq2lE/oaZWct6wSvbwr0P+mkgiMvVfccU5lG7BYaOKGSd/ej/JXiVqMfhfMbad0oXPsPLmp1LK+QadN5rBGYmQaRoyb4COTljUHJ6inJm8WV2sDWbDPgQwmK0T6f+MepMOeYnYJByfNhWT2zmUUi/VZznvkfMx11Xw9mroOdwbFgRnagOUBhlp5hjf0TXJQ7tQohEj1hxsa3plOGNHoqA6XSiPJExv9MgLIaKJ776tKQNx1LRBAIt43/aVWTuNFXCStVr6g/enOPENU1ov541rJybCpGdvvu0vNK80/vuXuEgofRs/QOXussK/RHLWanE/M/d5srxVjWN7jhnvNP802fb0MotlSHfmbYIOvjaUX+tpSOEno3YNDvAWvwiRXkNvcpYBzGq9tRFPo0dCQAeEOalLHlA05Ax6OhKRr9EwKaa+rrj7PeP5UEFkLcx939WNqNY1EmM3QWOvAdWSnxEBFtmH6wH9X+Z3omNCsaDNtrWmpqvyEnqIcJuOgjbRG7kZXpDyXPEFXa0UjsWfa6Uwr6e8jizTyHfpVBHhGUoYPHCTk9hcWvKx9GWVBa1vLek5qpxK2o7TtRE5yH36nZeLftJT2zMvis0LC/Z6vubxktnFuFCoSZvUl59FdpZyUqFBuvIXYySbvuuBbEZP4RgUOezkTK1UFQSJ7OtlIK3ZQOkHcd358DrDivZrVV+dg01kCV7Hc8/lrH/nxSADv23YrSjNAsm5rDxV+/ivIzERTt3Jgam4ps0vQrbwos3KRcENG4BRhEbms751IrKuc9rFkQtNTDIrf1N7g1ZS0SSQagxLNdAVeFH9wQZWyvXaDAVRrb1jLL4gLZ5rRSaa+z1Lr+K+aTMfqqSE/HpDPXuxgtdYLJSecGKWecA3WshTGPQzoGUOKddxcIS1C4LXIb9RnZ6jEe1vxmMjFprFZMn8EeqUX3kR1wz52aYN+yk8sENfx6GY5XwycU61Xr6wzmUWIex70c7fLWH0aPBkCp4Mgx/KZWAY0xcPlK+ovGv0aYJ9/sGSCvLhjRRYkkB+5a4eQU2LdZmKRapzaYHv2b3TNjieJJhPPQeiSDvnfxjn5jvx+pGmVmkM2CCYEJdu9nZgc5x/lPplogEAS3UBTw973+POfhCicSoy5gl9fiS0hORHgUuR6s9uUJarNGsW6M7OyxFNuiGOPb6SoU+BmkA85kZXJqhpEnyYPRv/bZTMhQcYaO3WddA8tOrXaQ1AvTHJSlqB2tCxkVZm95IcccquUfuDIpb+cMySQyaSihl1UOoK1GT/ByLDQu6IYC+pZgk8aYuQiyNQ0g9F+z4XPgXprMBR5b6okadxBXcFQUBVw02MtFBjjilNDBt8mDjaFO0yL1/kHNkpcypjcDo2L61f/fslz1D5uhmeVVsIKG8sTEvCO6HlQvbz24/WvIpwEk9csFxMg4z7QyL+V64CNUn3PgxSK3itJG5W8FU/lnIsqx9HXLu2r7mdY9hj7VeqlL9SLz26LicrQqhDmZVaKukndb04CoerI40OMG+AziaNc7uY7yprTTnJdGmbY+Mh8dfcP4RVEF+y+xzcWdHqiAs9EQh2hWiEIXedxD9wIGPV6NPQh7o6EKSxOIXLD+S5BOsXS9pY3LRK1tdriKlhlaxQQMx8MHKoLMulolcdnV0mNAZL5frRSNIvq5LT7muHxg9YtLSdeqBSgx88YoYd4jS3Bf2a7pTQ8Pjmf6SLjutuWUfeCParDPqbREXCwtSrMVchipjJnJIhlQZJP4ALRQTErafrUbHTCDnlQn6rkd4rkPYcLhTB3MKvIHZrxlVmxNgtZoKJR/AXvs8RT5kq+8+YfYn8xBqLT0zerL9D13BG2IL2zb49Uk5BqFhh6nG3gMRIalOqWYHg8doCvoNKCpSz7G0bD0mA5dwmmKRqv4fIvNWdWqsIjcQEV+qOyGGcLcUcgHhoTxNsZTMdPp3B+HGcHMaPy77NXTRITLJ4WtxiCQUWHubB1KROoGR1VDAV4dd2Lld2TVg77NynaOcTyb1pI1QgV3juZBRSqFxhpkcUj9Bg2b+CWO2jJYow5KGTA3IXFws/paaJgKIFkJEQpTeN1ckoQonqslTHf/UZlK4fLmPPG2VWf87CEGXEjvtzzLxyhnNOZJvcueJU+iDWpQkj6C2toSDW+yMZyAC7xuxJFM3FLIrxDvLPksYox9OkbZEuErJPF/WHlT0xkrBgVBRJDDWVZ1aBRionYq3PvbjIQhETmP1c5lKV46HykB3+CTpae9ADHvAx8ERRHoo0sc6fPskDYrDX95FIWH9WDXdn/Ud4g9KgHqpqdtnQDUBb5TYmZL0nhM5qjwrUFv0JgjsS5KCDZA5mqL/1ycJzt/Tm1ATmPRx1oEmbNs51Xu29+2lxFbPiTJIh2M0p+k86JhHXCS6qmcXVdXrdKRoRxRDquV75t/M4w4sTFLddIatqxyZdH6GzUthQPk+AVcFzu9i9/qUfGcC76O8vzTBhDejrUSwThc4tt4nEihjDAjTZPZvffh/ZAmLMHcTq/jYWq/WW3DXh2zjo89GYJXbKcHlRCVN6iL0tcq/TuQ5bRnAQau3+so5sP0JloeACYQQGrgQJPcRBaS2h5ZlCQx+MYs6nSi/tkpFaOufX+OIEYLucNuz2if2WsjqqpyVEGknE63t1KH/fxkO0nA4ZfDJJVrQK1jgypcV7KebxJrU9F1qjNPasNdXB5gKNhHD1Qu3apvLOVW8VtfzQQvvysN9KW1spvBsHYLBsdzJO7/DfdozcboZ76tPywsiGHY5Iqqh5JdxzatcGjmPO9eqEo2TTq8joHPIfTw7LSYyMygjCYm4IuhPxRQBR27T+RvqgPq5xSRwXFCDu7xhQE/cqXO069Y6k4OXMLWiGqGmLa317f+bzOHU8Nalst7ssB30LrPng5C7jahLup0kzRPMg9SdgCqeyM4VFlRnNolJbJNnfo+hyQ5wLhoEVDvkORyq6GTsOht09huBkhsduWTEgK2wqwPLjyYdQDxzlj7sN7duYf/D+vyO9XlKEtoJ72MFPZlPoO2oaXZ4jSbDfFvI9HamdDIy8Osys33X9japMhxprgbkuZidyqPlaqRSC/1RHZzO+HrMbKbKu4AkGNWIhdowq45ivQXgnlroNSOEav7E1zIWHeX6cjJUk5rKxMkzltwaPEsx1pE0P2eQ9QQa6Y6JBEch6ybJr+Gz19K+VtgQl50U/ISJhJ/skSv6/2zckkc1jkh99sorBbq27QAh9bO3vigYcwH5PGdeHzrS0QMg/AG+o31qt+GI/kFEwUOzvsuI746iEy5eRkMj1zgkTsIgE8M+xsemAu9cBOKyLMMa+vkv8YZ7HbXP9dXLPErB8CzSVB4YgXpWZ8XYO0Qla4IR7XdiKPQn024oRIJESzcf6hQHsy96a83eEYgXx0rk7zGd/t04QY4vlaq1tPFR4OMKO82UnYQEUONey4QlR9l7gBKTTRCAdAky2KkOUdbJhuzu9RH/+6A/6LtLS5DDZvILdctyUzprxc6wTbE36meMPSeN7NtWWACMa9Z46XpwNXXxX4Ztw50wlQBaCyfFYR5fQHAJukkPmXpy8BtHgRQE6ae1cTB3q48U/i6+k4FA7rOWfVbwfXAIyLcymp6guhw2UhYOAZWqtHBw6OEd3GLLFTglRGUozPZUnCeyPkG1gOEm1a8RP3iKY5pZudEov0ZzXCmiuel8ccU1Z3IzaH2mME55YQYb0DWny7OoOmeLHbYZ0Qgwx24y5sh0IfEXotJZEBPxCSBGZBG3+JyP6aU3H+xhkoZfJDklWQ9nqynzUQ+OR6FiJYLzImrIFxzTjUA73K4sIrwJV9Zbs56lPj9tGPJgDy2XHMzKhhqjoYzV5n4Mhg4msHiRdApOas1P2qkb4dG/TVGbzg17rHpPfZIE+xvDxukBbCln0pJ0qgtqkA2GIHTWqauVMV3j2tufIAh1ZI1pnBp1+U8lc6GUITXvwJnMgNdxF+/a8YEabG6V5wPDE0xs31rnOND8tg1WhozIiF9+Ib9164WOiodL7DvA+5t0zYgsJTfe2BcD1qry9cJ+JSxu3SiwbYT1wGL8hBwAbr7mVjYj+yaVKbOYXC5RmcYyAcFG+Bf/12gexwW3HQjWWKVYQdfGjsvAGaxKz6ZMpTTQ1eBr5fGJEAsEdvX1T2kaOG08GvBrk8cDqahgMiwAlcArMZz8AeteQfGJ4hTao9ADUDjA/jP/zSIgACOpnv+FGBb2+6H39mCvSZdHboITn4bv/FzxBJdbTWKQYW3Tc/uoUyVUYKr2Y9WlD0WLqneXlOWnkKJ3EUv2pvIZoL9vwO4FXZls8/5mLHcbwj7rNtnQHBdtqHp73OR7tCP5pjCy7PfTIA4hXYPnR6xzEaYoYM2Eh5XWfAv1lkjn9qZtKINO137jpDumf04UqZK9cRKZLYSHtUZDWSAj6hQN71PoQ7p/2SRXp+57taVOdS/I0QDFyrxQtJcNvY3/cMv1Dk6waboSv3arLRhlPJK5F7qDPpVnGSNSn8JOzSA4RfSdnvsKnZTWdzw9+OsVOwKyj2QxkjC3ZOwBeldLgN4ylHmvw4tdu79tKEgsfVNvt3dkmS/hPFSqBnpBzgv31dw75MppQsdvWLqcxPc5QKneJJMuugvgk/BtZAemmbSMvo1e6kOY23m8YkfOUGAQBbzLlyEpINYzE3TZVOlf/EK8e3ddUOJByA7YUlm/RfgvVCF0cmHtFP7vqIHfNK5GS/pk4Z3Dd7YG/4uCegyifub07qL0e33OOyeNvGS1grD4LAA5CpmaZGXwsnIpJVKyXs58hV18OoIDFbFAftK9qFG4k8aYwVsWma9lOuClxu7dGR6Fqmpx3qptW9FFy7xB3w3lrtxWAqPcjL1+qSEOkllvt4G2inW4oUtVhwaFegdUYE+7zk+41pJ/fegzBQ0ZDU5Rim4nRuv/I4oIvQsOas1tqN8WrNu2C1n4B9231wjIosOlXCcZmhk9I/9U4PJqaqie8RA1xhLNN6dzS3uXDeUtN5dzRIkEq8GxRmB9YTqIaR5dEDahNq+RuKVssUM9j5A04gcxIjH9vPIHr09bm3hTQh1j/zuw4X+4voBnSgg5cJ8m0jYGpc+qCYHs8mH0hsqc9kBADLE6YZ71lb0M5K2FOFG1IjH4RCgBwkJPlSM+Lbhp5xcIxsklIQ03PE7mDbuW2JA4/wQNjAym0LBL2JmYIaUy5f98fVZik2j5WFv7+oJ+zneBIoe+MJW84hVVQurmxTNjqeyXZtMEatqdg81xieO2hursm/Ln5KbOnVU6+2D7jLt0CJ8fLNm8vigYuU5ZiV4QYJwyskDzTf4Ybp5VQuiEd7glx4ZND4LSsrNCyj620pUQS408FiNsVmrsYk7ueNSsuBuYhpeb0KerNV/E2sLYR7aTU2XWgtrvXGJD4xzd2KtypVeHBEy//kh0sJuPWCL8pS6OMSIWWfIUs5/1JtMsjgpYGOujqmwK7AjMXMrf1tRvEsuYCk5EgUI2mEtSO6CE3pLt10cCNb8FirUviX/oLXGCEGZqfIjXpP+ubZYjTmNDS8Y72U3a+Y6ShZFWi4B1eaCAyWq9ndTrZ/Ro9vAHCexS8bPsJk5ZnbUuCgQxYMCA/VnEmaPAx+fNC8bA654mnxqsJaD57OZKpAF7LLX9rO+sft8ddoewMI1RxM+9ZEZml0gsTWHyeuJFlSU6funbW+L2kUsCGWaVRcyvIXNesyHg1XhTcUMpZpCddog24NfUhXfONMxYkwgO7sJI9bT21sFbXZLBsMB4E5IEc2JFVy4P95HKtjL7Qurh8Q6ODqtctuJriT74iQYLPNHDI5l9t5osE56BDEAbN6cFMzMDTPlvtP0xN8tA86Er+aWadye+dzOmuX2cLjsJuI4t7tIPNYBHIkP2bifyz+nVIuDLK9RE3u2g1xK5BsRCj6RlPoROvFzAF6AwaqGQrL0Y9F/RHCgqH4CRTbxB72tE4y/6m+aIRDunkC5Sbwpj9uSiZrbu/SAUXX5rc+2hmViLFRy2/Za9XgQV7C7W6XEL1nO+fEXGpDooUEth0KZ34KOJW7FFLRJ/+9uPPt5mb1CMkX9jnm5NJBLkymhmntZTTMoLGITfnpCA1bvUsg/lx9UdbEi7l8IDtPflGAdNS1Xe08h/GLrLtL6LmYAPQjEfme+ESAZQkOf3XUYLt9G5SgZ4u4AvVtsxWQzIvVK8PUdIKkHE5QTjn9UQfwB9bw/Lw5rrsiYnbbLtR+GgU7gQi5oZN4QfoSxH0v4kUeDw0NSHagO/L5s7zTw4xQlu0GifVmrFO8nRkwJsGWbVJkNwXXl42qRDFcpv6hISzPTCnSTgL8iKZ2gXtdYFa2IH549V8ttWGXx6gSN+uNoCXDSJsnX68TFBecI4+B+tdKFfuFymWAd8nU9vd1itP96TmN7CAOVm1XW44NlQxbLbQgJfxxT++gIblkKeuonTKCk99dN97rJLyEY67xahUG3xD0APMwBbVBIwJwMBzibg/fQsWIPFxR+eSqyTQ03IfAUVbUcDtv4ucoFIOxpAjl2avatKVeNlP4xSxXDQi0M3iaaGXHGpSSA7TBgjo/WNyLnyA3CSHH7oGqgFTgMrEzQBRG7LLLehb9NktZ7WThQwclJvPN+eEe/JJYVFIzltXp4gR+OG/yOjBA7NZW2k952G7QX7y1absVcRj9nOowLWSV2k2St4kBCsyXmGReV5IW4+J+2Tk972e3vs7OxZcu0nkFfke5Oy9OSjOY/KHnmRwwm2uGiXWHashgGNy2cyPgRVYrrGin/yKApmjfUguAOh9oe919MbmWVYu5XKflma4OaUT4hHlkf310rVy+hmdHJzvRcdudHXj2cR9VAhqTSJEUv/pCD65R+qlEv73OXHc3oZVIJUzQibNZOlqAQhQNm75F6DxkqeIM/lbdO0t/auoJH7vIpbAeCTk+r3zRO9NZHNZxhN1kAnHG1d5Ts/N9eNQdr8TDVrao9C2//uDU15R/6WTW5HcbKmgFQhVUfKY2E5lrB518YfrrlF5S9LK0Dlg2TqPNLdLQGMt8SikLxATWqfZw7j7Q5zJe46HtEg0bOGUaSzn5jMkR0eUR3mgQItx/pncunh8dN6IiepfdUpY6OIBstbJvRAs0vA4K2X5qW3Bl74th92KNfOl2c5CGekex7BuT+m5CS9JVOo8a07Qp5kdgLHdcL23kOa7qTUtlBm0fmmBZUUGdHKAuZepsdSfTAy2grEsJkk4RfVmtz6HLFOP3mxD7xysdbC3CC0B2qUxlKU3L1JLXbIG7DSnRkvGU94MpeBmcowxYQlNMQt56sQlRwkZRQPl9AENlGqJyQ35kNqawTCWdbU8neHt7NRGppOQD/J+PwIeuDUcaH6ag8FSgJY6mQ+rWuECYibeiyCSABkGddh6WWnQtjdiy/Wf1CRWQ1d2nIVj0UdNYkQd5FH6apEI32IGOOIQY9Sod9olKiKX/dk3NYcAkg04ALNW77wEXhvax6OlRcw8+2X38b6nkIOpHiUXcylXOeJZyToJzmB2cIDxs8bdwIvUKnCXH1v0kQqAvxovfIEmg6aF5F0pIO8fT/b7SUbVpkeNkmcH8+DlMVlu8u4wN1TKQe2Dd2wDJUhGdenqGwRZ204Y2iwO+saSaAvA0bpl1/rVE+/SdRtdgfInvGNW5kQsP1gcVe6QAZR1Jz35KpPfpdPG/2axWp209igJwiyRyufGknGZ8zmbMzev3OLxig1BRG1aHDwK4dAUT7D9AzsOVXaVo0HAJaPKey2uR898e308o4qIqU7iups5nLbNp/DpfMmgMI/mhG6qI1APL8LLyPtN19cdYy7OTlePSXVU+mgDfiJv/ffytRkfpR0uSdxqjqQOUDNg4etTWcHiWP4mCxkOvemOseO/gI/aiueSdQSDu+bQDsOMDqgZzjRyiZas6W0LBeZAfYny6rU4TZbs/ovWjfpsFIb/7YthofgmqagUwzzSnnkLQ06HjkEfzdbHVvx5dwli8nC/yxJGDCEOvzb9SThUBvqJwp5bKxmByYNXizzIL5e2Ocpvnl9dQErdJAhN6gIzMtZbrUQ4fgee/YJPyrJLDcALWCaVurbNQsLSdfasiShJYp4D5jtT1o2lyzwiykc+znKV9dfJdhTQXQe4KhxjQtMTMGM9djMHvwpESqiDKCxBbD82CvG9F9UwljmY2rXvHXndbGOdZqLRxWy/sms3+nZuhfErldx/kwBQw/mBCy9ojI7aZugKm51ydA26vCllXpmr6r5RLHUEl6wtucJq3Wp9yiNIgToqa9PQ8oL2Q9/rZlOBCvBRwLaAZ9mrRmnwkWpgFAU+Mupyb756Rf/sU+4LIOLINepBY4sBMtruxYC5WrQH83DBO9QO1hXKvnexYuLL9KMig6Tyr0uBWesicCVQL+KZYwZ+qrsyAaY78hKgwLSXIFlumXHyh8vtxo8G6S81eLWN1Sl+w1lLl7fm6MvWw+QT9eGzI27mHgcqg9HsAI5twWl5dt8vvLI7PccDb3HMMBaioYpsYjkcacF0nHvyo2fwSGtTe1Eh8dc5+ZIoAheuhi71sBAXxU2sJDjL9dEgCkrgHLOYrrwx2a3NrXxz5IVbkjVXBXUyXYv4UPfUkJnDHdWYSgc3pwvP7glxDMwRbuI9Dfa/DXYxBx4FccU44NvNpih8+aU3TZVXoDvUtLGxYnXywz1TV9tCU/u+XsAB6Mx2EF2qr6UuKrzB84fnEUJcRalUhKBE95rZO+WYcd9eGW0eLYNbIFAmgFPUCVHTEfapsc3Y5IcM4FTMy+jBVYL3KPWLCNeK0TuWzO+K9sv4fPzmp+P04owxQVoY4Wc6QRRzZtkwtGwDHi4EaWP12e+mTjrQRncE5uiDPKEf3mJ6Qm/VkS3NX/46KVauVvnuXtXYx9rYtvXijAVgnsi9jAgLUyVnpoDBRroAi9uncIJ8HiCdIbrlQhBi+7EIyszIbNnyLyM7BEOO5xVGMJROgsMftDUUf+Q1xXiVEmiSOv524vleSDpgXJQe0hLFAcy9vHtSzYhgh6rzah43t0n1JYUJcPLH2corR+tcY902FbbH0s9xaNBf1pFvKZyUUVds/P8dd+26feLajjEXxarJ/gHbe9o+5Tn7SVaaN1K8kCRQNk/XI59sw4PkgYIPWr0nGWXUJsteFWUbEGAnf+S5Sgd9U/Dl+RvvaUi5T6E6KRcAGTd/CfJhgSFDDOrCrnK7yb9+dlkBBJ5/5QL103+HqQ5u/80KELQrAzGmMfbShg1ZAiB6VJaLseHE8Oi3fNIN0bRYVpdG6KW6BsdA4wWPXH1NXxDIbsXZD9YYfDhtWcNl3k1qhkMo+Sgxbgw7w85NOdeEfc3JWK0REB2eivApz0lhdax8MDs/UtR7x1wi7Hcfg0LCQV4yuXe8eURudsd+5d2KmPh+AfQ33Xhp/cahLOqFck5SGGHtF6uf1BG63DxS38NhjEJMT0pP8C6Mb2EIpp8RKcDYd3x9SnRRC2kiLkEjXMtTAqWiH8Img+OuM3Nrq+K22tC2doO0dHpWr7VJk0TeReNiItnBM0JXOmg+sA6003uWoepCJ4/IYKZ3H1WBCVYfbwAzs1ly7pX/SsPtfhdMoJ+KXuGriHjaMX0Xb7kvuS9KMOMbPVU6C9wYny04exU4ULJgJRyVXbVuLUZ8S/vBVH6aYPsWeCmMS8gnc9gP2GWobLVmwiY/JB3tmkyUhaE3CciaGFAhsRz0gv9V1tTDIDF1v1qiwiGVY1y9i9VRpv+QUCM1yAO82xza/DWIR594W+944i37NdrF9FEGLFqTjrXJh0xrZhf4ngfglNwcYaW5Cez8Bw36HZp3Gj5UtW7gfokhKKyAHUnhB3HcEdeLVpFhZea44D9JTdFxOxQCRKRH1xYkeF1Msq9LuKG8UIfGgblkTscq3GzRq7YEHEGdWx/ORKR0HxMqE193hLK8geuFksrzj2elsep78EZMVj03iIHMqOoqjoQzEqSdiBD+rj1ddYqh6lgXszzkeau0Wkwzf8nnftWcR/5Yi2bGkUWuvI+V5Oz/rc+oNmLyIRSfiPtbcE7lSyCdWiORrEb4yU7EKZ2yD3Z4uZGOjvM9hS1ziEs3Rb4dz7sr1I2LDZVa7aCdtCyyOtVvbgaKYm7Quw8oeAZ6o1x9QRjrwMC99etWvOaNXOh3qpf3WHI+HCrLmEEguM7qzIUsv4y61vtzYaUrrtflxeyzKO95ccqcUrnZ9mq5M+H41WxwBUtjZLJX8dxhxHxJR/dMmI4ycINbiFvIEBgw3s6tWjJ22ETnKuqu8KUkDvaDYss8+6FbS13NB+12zZ/Seh61kapeQfM7jTPs+A5CO3oKX17UU/h6wHRbSl59IC0UMpQ4lsCj8bniExGlSyWRcjKlCDtkBmC3J5RPb+OAcPbkz12xBFrSOEOXZG/NVfn/fjCeghTHJ2UpoB2V7CBs4vFsODX9XWWvIWwznNgbDvoikgjMTfIf0QJaRCH+i1d62J9BHc+1FZuufZiW+1GPz5eRLzKl+rnG6QaBHhPyao6kUuH12yMvFEBGyEwNbDImDISB7uNISTayaaBw2GJ5wiLH4Rv/pOQXiEMuYvpw3of6kKq48N+81jRdJq0IjlP+QMVGyAZySEfggB+U3rF+E9wFI/DgKt12OvRin22/CK0Y55d1rw5Oidy1gA+33/KhCufeToSPMCFqqzMVWXwNrdCK9pV/OXilZHVRO1bM/DGIHZi/yzxDxVCb1/egbxbwX5wl8stBPihuXViZlFpsopW6cwX25GvKmjbjgdt9F3bIxDen2I8jHqDyYg1uyWOYGT9ek1+o+QUq9RS7zhsSzd7jctJmLDnuifPYR17MBsrYopw412BSTKuPVWw41PtDLxTqe3qi7YPw/1u7qa5U3XFRZU3NikWWHfAhcVdyJ6CfOclt/p/0FOmTmwD4FPZ+5AKu87c4hn0/G5YeoIXOTjD/9WltKdfQ0/ukaZ5rICtbLFiZT2FCOY131kkfqSoUtc7VpNCI/QC6WRRznGbRwkMubVsecfNWBNMa/I6pZdQjBvBSL1h2uaz9Q8SyDGTo1CvH5D2ZHe4NINNERmOeVHdbmtHXd8GeTJXqLa190yA9/86wq+3N4ahntS5RlwRa92qwXZK9wma/nMhesSBmJnKAXzX0kgo4QJNWLAxUbqzmGFjmrzlVDm6K3dugU1Ov8nqi+p2s6M2k7FCBYepMEGYui0r/ibYym+E0owe0NFBGBTjCXurtVrvOQ05ZQgjKNMblvh29wRimO3B/z8SJvd+ql9fnP9EafMwy5Y3tpPbfsbNlgrrqqvOGLbJKaD2tEMGoq3kIQstAQ/CMMCtNUcyne+AtAxEFcwBMTvaKxrBtdjETPNzMHkvaEP2pLH5SCqZeOjvjoLV66oO9IN+ElR/T1jIV/EfPhKvT58cwbGV3+cWOsUHCW4srxKDuib5T1BCeTnpnBanMfWruZDjFlRz/aPenSP4dQSswWekUp7i+aycT9lUxvTEmPcFsf7WoV1537+hcSdcD1rXuN3jQyyKHU/9kDDtF34nnP7kha2Ym57nmK4oFEl5eYlzwDdVgxcdWIozBeACnaoWweJzu3hsBZhEPg5hq8rMOLosKdO7IIENZ7Y36wJz2UhQZOBAop6IPuKzKbjPPWEjcrQaFQL84U1RohB7hVBRyO3uYmZbjzYQOTsVgxS37+K+f3LniWfl0nbxNaZLAhN5sH774FcskFrxFqnJlMhZ158uAs+ra1iTz4W6YCJ84ksfbWi3/nBfIm8xtXs8n3FQO4/3eSEr0V/k4Pf/2MpH7+1c/EuK37dvsbuolsIlS8WpFoJwbKsNUUByYNxJ5MUedhDMKF2hATYWXuJplzpdyVaxXfW5Dp0N2sLDY2hd3tB7KRphxnciioeVAECi/Gd6AjNSUaJzCmr8A8mYRFICll8gNBNeP/OsehOhQdw8R86fqYPZYNmRHAlw+lAzsBrVCqG/K08mSxkz9QqTNoj1tPYw5J7L69p0L50dtf7MdsgR2aqqrAkA2F6BroWmlhT1BWFK/xpIyLZ7h5kCpgdYN9GMFlgHZbEylVEUVciMqRK8gaSincipSJ93j8NGGkBTCHORX7HZrvfb8PXUolweDlxK947rMg96wJjYL7rfULAN15tmyByrB3LVVF3aF8o/DN/CIhI4fp4bBqo1oOughxFEWbgju9TUCh6F+LSFWshWpp2Lrpph7GScAHz0rmEKBfn7ZDDcAUGopRk4fcNFwUGLIAZX7ZGvUXJbLZr84upmXvcdtWhhGZY2oBpL0SBSz/qfMEMu5JOFpGh8C5Iqnm5vEJPqbCimLEAajb+OtCZJVN+MVZjrMC9AajtljXwbXv5RLCMU5YGJjlO3BPW6vgx1VUrMffZFAdzeargGHZHJF4XJzfKeQJibwi1GNp656antCsHXM5bb1xl8u+Ouz3BksxFx1pFs0yOoiDYr8cgVGf+XE4kQzptlxRMVJlp722dk5EsvjwjQnh9EJVd+VBc5pKgpQbAAyb/uUTT3My4bf/DnWcxO5t+aQaeCaM0VVOelKZ05mTOep/Hq4o7qzgvAOyZIdgrbb7gvnbNfA9v/blkPH9wLy45VjKxJ0pgbYZgh27QiWxeBjOwS5it9hdu4YAE//e/osgaIbkwjN0JDIMF2gQM+EFJNE1VRBKCdR6heO5E8roQUYfp9Vrg1FY2dSo1bDBL9RtnqA7+Qbp6pIqtYGY2p7dERJKJj5Acnzb4XFcQK9jPEjuq9mUxKmJuiaL4NissLC6oMY5IZIx7LQqgVbDTIIG1sgUouieOdA0wy3TXJSS1JdrWKE4u1YgCfW2kjToPdNivv82f2EYLmGVaWNK82GU3AB60fmjESgKxJKVK7EpgrT/SKYuq8hefTObHJWT63W6FaTQf27EoMeOS+aTNfh2T3CtixEV9+3/8yV6h1tmHpVQ47mU4fnvRcmoWWBsdAOPqZMpcCX3KszvxlV8lnZaIk2QqWCf30NK9cm0gMI1L8asFmXIAGbczaWy9qzJg9bpInTzWsRTqh7SVFBdfnywqCNKhTsbfnKybu/wyYfuSXKvA3T9WJvAHye/qdbixgWFKF+Z/aAebHMQ2uvI+tK6tXySYo3lN7c2sdlTtvo+xVzmruM8SOnwLEAR4unK/ahyX4NmRgldxHVXTV7q06NN7Om9FODn9bkScPUZ9aRGwfEpBkFW7vNulGYHvC0LRLE8tTeQexiPCHkv3FJ/jI4YozQNcVULYypMcfjkaUo7yxM+RZwqFgzq+iks8OQMfKyXPcfU7O9aykdCOX4K1n6SfUsGqn+Yde2LbRoq9kIArX0Co30MRAqWIEL31tmdZkRPhqkKRbEKI/kVPq2J0NxMTM+zF8JqoTCasw5YxXxweEOSR09ELLiJgE0ElNHO6cXDmdwfnswS1/aC1nCu1iwy25mVjRpZPHE6v2CQ2+dQs/LKW6Fq6jPDTIdyYbwbK+8bj/a07rAnhtrWe+ylD/If1vyhNC6wssucbLcmRXkv5TRa/MgaqhhPx7znDnnCh+/5rbGjzPnaQIOnwDx8rpDpro8iTqn2k7jrRbcmKp+MvpdoZE3hnb1R2WKcq0XYsL86Kqx+pVUlGgcfn2r6ig60/yan3wUFVC1LDz/5r86YfGbHGCUObZvxq2ic4KixOUkdtGM0QzwErF2nDSELuod3KLoJLQT2mZPQUrq40nUSwb4cDtyD+vOLZp713H646owOr8U6bM08k5whDd/bp2DOUbCfmTbZ98oCRx3xcjXo8C21ZqyV0w0CBDyxRIXsrLgfNoeCCqHWmDKpxHT0Vg/untX5NlVD4ZRinHJf9dIi2Bp8U7gHxHR3PlGoXxeO33RZH7tCcQzF/N6lzQ1Mv3ipmvdgEjdvTVM5vejVDHRu+YSq2uj+0WdwWkkdHLH2+uyyCVoxXo7zy8kw2r3wNnwSKRSAvcN4+416J5QLpGK5AJbkCYt9aZDPWYkaOSZBjGHUbgD4vXuHNB+SrRvLII1kYQc+LHTEMw8Ul95cvlPwgVmvAYc1kGLeUGkdDNXm8lFnA89Fsfjvy9I8ps/vAut5qnLbTq8mmbw2XPuPVJ83Ir++qDDrtUKTif4R0ovlbQCIsi/vP1KPNM/ZctQd3yzcYgVCvDP16ZGTNe2pm0E3WZhNUiWRUgCeOv3cijYfvuagp9A3UdKrxiiwcRBej+Jx9TwjTku6uVyUJAypz8v2YQwE4MSMiLEQFcia57jY3h9ivptMP4ACNK8K+zRobLK1oYVsZ+lRiEURsU61uJTfsQC5vI1BgKfu9KM19eo3KZYWZ1jYExLa6RtpBM4G1LegVm+Xk35XbD7A9JmiXybrJAl7GBpGhp/bu4L4mkrlVn0DIlnrRvDPFEDDCmKnijbXOS2HrjWe2XqpXyNCWNH3E64YZ+s4iFrRq2xxRpElHYPkdfueKddkU6eNWTzCrxvBbQHWoW3DJyRSNB/nTSZsNK83R0S+lNpVov5yzgvjVjywEnUSSHUY3HUOUQRK1U5lzv1A5k71oTK1MfZ/i0NNl2Nj3vtucRYlRLYi3Emv5xZRHNmUFglJsMq0LwO+Hc1fI5Yq8pmqNNYAcDMFTpXubYcPkHSCHjara+INt9dk1TCSw2M7bl6GxcTLuyTKQ0cLFXwAD8AJWBegqfh0dMSWEVkh20xYDaXpuYz4nFAOpw+TM53stofPbVt2kEXkgcndq4hXGXPZaz0zo/z6gVcdv3YaYmsoO/jOLBsh/2FHXCLxgnXdToO1II4Q5kKW09fh4tGAuXRCXAAO5nf4WBnJcspNcFrJmREl0YsdhNOlCk3OCAXzSvcw/oDaisNKycBbBrxiaK5oRsk0y2oqHL3UQFofm0G11iVbwjNQpOfq2dWrtspthG21f5ymneaJozAwJoCU+MVNaRtBDZb+vcdyiU012+NKvpE8XTNBSqPOcHSlD7LXnaOkAKRLwKLvUXacjpPyn6574Hr8Jw7VQKhhnzZKJIbJNUvI/+78Jf0W+zf0N89AHf2pfO6zOKjCCrwYlTuv0pQGxlg8hNt5gxSIj1c2zxmgSL9pmit62VV2Ryx0FmfRx7nH5jsjSyYj8JD5COd2bhhLtQ4yLuKp3vgrIEJWYepiAuoVRK++Hu293TNssZ8DqAMJHL2tmCWAir7xcHExhm9+hEYczJYmZNgZGhF7el62RUE3sfV0HLmHgjEnVai5HXbP0rpQC9YhMd3ot+T7xA8Iz7NIfr3kWj4wpFTIVa7p67UaW4eRLZjZeiogsQcAoqm1LvvFY3DG1QtfhWcSNGoJtFVl5X2TdhyLxX4TmQ9B9Ai6mwdb8/At3rC3yuPoeMfgmKSTA267t/OGquaMUuJD6VarLWn6UwXMx4t9pvhSeGo95GC+sY9NYAt4TLScgtLW0uA/va7+kwiELN5YE7yVi1M1UpbfCEmPabhH/GlQJ6i9tt38xPCJp3vtHPi6eSQq1vSmbmcZ6IHJ7fcyh2gqUs7sPa2+3mm3UfrCo5ZGEbQlH7MV12zaRzd9aLl2sOyWA2jFomDesn8dc51D8c+I5SCflsKLrhuyh7ny99QvHW05dMuFkZ+j8m8sHZ3Uja9xCVTg0RHYxdwkd7drhcbkImGhZhCMdmjE8k3vdvlqSDpEd2w4A3fnYdX9tE5q5SV5Z/tTwvk96Fj1rRa4JxDm6SES8PmPTFtrDfq13zcvKPDREh0O3vyC5Kx56ZCTm/Ylec10erRl10sl/qB+uJyHCDrwMkjn+HeL/AvQtXPe4isl8JMGZxMUW7M+hKx8c78QOYgQBYXIjVvWVq4yfvN6+v2Pn92j3tbp0jbnvGsKxiG9hAw/54XujjND9TW86aLbYInxMuRtzjQRdoVKoeJzI64cN1dJ1yfIDpvIita2gphVGcIqeEisWiQASyVzQES0gxbXb+8OEa4NB9zxlMXpz+emkMMy2j9voub7mSK1CEyeBNTg/iqxrV+JTiEC5sPHLczIHyX50ubQ16COP6xpUrmLizFxT57ysLcx0F1OIgGLh9RVG4mUVy689lw3Z9rc6Jh0r+KdrTwuOz78mwFQaGHuxb7YGR+difE0JPxeO/Kkg0a7/2Vs0j356HVxN/Ooi3zzqrwAyDLD04+r7VRgIcTRBQH8TrFbGP5zqpQQr95Js5fCA96IizbHMvmdW1w4k+vkdjwueSEoEATu1drwLQmGVL0xsocipUuIEhUOM9EdHfUgHRpt3op2Ym0MqZNkTlw/L6a4KoMeMyi4ywz7EJzWmWPWLC3AH4gEybWl5hU0Hevs0XjqBGHLtj4/FUhToKL+474Cw0YWGCDbcOCOIv0zP7JGeYN/mYbkZ9wY4s3PEPkyA8cD8K9nZM1pw9bQt3/mKFg/dhnRPG9mhU6Y8XkCyZr8cGmYy107B38UsyxIRaXT6TPk2glGAGklzKKNI9MQ5+U4SAJOKu75NoeA16qdFM3RzzXpQ1THdHRvNBdaScyeo7XasovH2BKFKy++v6SlfmmvEYeiWzpc6et38pPE4zcDf4q55Jm+rfrSfvriNrViofKQ2T3HRk2LZe0zbiNLDLQMqIuQzzOeDjGuyXhfVy6Co2/ZIey/De7nn3NcnVej4ELsF7gPA7GOM33sOLtewMtm1Vcaqj7QnL9Du9thb+LflSn7YlCN0E5D+id8w4xw8IibzOLdBso7g4uYWtuDupROVL5TFK4dTVK3c91RiR/vBvMGt3mr/f8QIvWl46/hLKvo+GyzeiooCheSgvMVGK6t0cGduvEQaGYXRBMVViHzSyud8VOJ52d4AtDZe66iGvUpOsEj8qIoXcLhSHw2OfQD07wTuwi/2LRDD35qquKic04qV4IZ44VHJmDDgr77H3HMPpsWNPEaMletY3dOD1DMdnCap2L+4y0txVA9+/QuCmCAGer2jizknAzZ6J07ETMKeqScQrav7rGsD5nkPQPAw4YRuG+cKDnVmGoI9MQB3Xd/n1FNBY2PjTAJ0Ajr96ZPu1MTTrsOCdlfpMhkLKkx5c5y+r8DGyrxOpjft95ex6c0CAmKXAugediUpwj/u9Wz/kURz6DBom7vjHirFJHL+idNkCVNwO+GF5EWU5DBoptF4AHzq8pe9+0SDMUs2JKYhXovGaLFMmu6Z5wP0CROSPnAZVdNTMS5fRf5duzXz5Cf9PMmu0l2sL5fmhFQPIAwR9Jy9ZWc08+3f8MpSFrYKVjNCw5nyZLANk6tckT57MLCN9NVEpFwI8uQYcKF815B1lEbCjlszDzKWnvFmGy2YGU6x40vbJco47LKiNMYmwJzn8NHL5T8lnjzeCBN7d+AdkO4BnuxtSNQcBlAg2BeshGzQYQ68EPl5dl4iLP5ceMUx313Ekvvfzn214quOlJiEW7BEuFSkHVCxB0/g3yXFh3E6Vzn9+gkSooeQfuebqfHvQAgK7MMQoOiF8b7KmjTVpLfNY5rPnB0P5b0DgX8ZIIPoWukrBMB6DVzBWZo8IcztWkg8YqvSP7RKM47OqRNV1jV1i3gDd7bLlpujT3h8DKokVl39BieoE9aIVGTecapbegn1+tPMh2aFlk5XEgFmtA9SfEsF+/mChksgtUpZBq8BdxasXRKqQ2OUBPmxWJNkcX7dGhI/ZxVG40qlndsQS1VIOTEKhWa6OrBfpP1cRMrw5dhkKy0LB+ifW0mQvqa+0NxwjIpEOo38BwcS4j97gVCckzNaoYOZxGlVYjdj9MLuZ88yYpNOcQWvwidO8Q5aQAsT1aqY9+FjpoT6QlzvXgF1pbCEieC/HMuGkY5jAQaizL2OGpQGJOwuH0usLlLeMa7HNVZv/zopttcz9cqqZnQpIvKyO4DzVfezsoL3C6+ipMgttBiYlk2FCJu1LqBt/p3dGPS6CxFWhznIfxi2S+YNpx6b74k7bFA3ACM4xugnRDsgow5kYSRChCqtDO++ZNAX7LF2uPICCeC6ezfHCfFQKA/P/HGt6yBtIqGDajJe+LvE3yQwuUmLo4sHbGywzanE9NwQvE6kWVjYM1pEG052+WAbxdvKBegZhVgXRK3bz3smR2i5WcjUZKTIYmK1NzWu7QUqmGgnX2Q9eUyfEAYSAzPxvdkc8Of+MA0uiSOVz5dCSnKWoBulWk30s6tzZE5Ycdp0BrXbUjhiyVKuw6ex3IVkBQQDuqGwBdC+NN6YQwfDl0tLPdeg7x0kqaBHhvhzl/ITKgciVDc6Ntdt459M308shwm05S1j4twoDjWFpyIhjaIkVTnxPqD7uO3Uwx5iowePzuegaR2W71JQwXegET22UqsKIKIG8Jf05B35PNKkF1DeYQb2d/Z+RLDm35dcwvOC2SKrXCKlQy5yqVsX6rLYExLX9mMVxEaeikUvwI5wGuvr50v5LpxIekHS5KWLHIFYadLskF+lSoAJnDOQlYN5y4/migecM4aV2aOTSq9mG84MmkstQBi2wm+05ThUp8CDoDBYX79aRLt2bujbMm50C6AhMjLEZQhO4XCjb21J/2hiiSfBokzCYjCesQ5rGUsn9DDVTf2YAauCElfIQdep3+s0CzJT4fpvgerRXJSOGorcWNJEQEx233YsLMCBdTQedqNOrY89hkMFVUjaCFRKbno2IR5yXRY1AAXrynKUvhcsxRpKHF8qDgfyE7+HpOsMqGS2abQdc75fUr2Ep6TxwMvk0GhN52jkpnv/CPCU4/IToJHpOr6+1JPygbxREg6Kv90T5lcaBywq5OjR3Y2CRx54iE6fmjfgTYwaSUhH1MqQC2xmmd7EWGPMNFdi6IOqrkYxPjxnIYEapPO0yQQkLkqda/Ev3Ky4wyxIWhwCEmY5uBv1OqD5zAS7h3r0KYr9BnJTCHWvIDE955Ut7MtSuRKqCWYX0bk6zOM+0y1I8AZG3yVtht8LA0faEAyCLD2l5GEWn1gjTTHdSXxd9ooFqQBRPMXGGE8fQrXKwCJvMw2TD6VdNf3Th63B1BLhsx3oYWmB27Ug/B9KyJsvddgz7QzbnSFFXouwYuH7oQwmgJFQrjkchFZdIBCpHN7pXxUC9Onf0paCO+ly5gEe8nWeXm+FMyHSA9N78o4DsZE4r3xkSJjf2AApJ/RMIAETUgnENDu+Hh2cvBIDZ3nP99A+eLsL+xwMT0gwrRZILZDF7Xj/OpCuUEekr5d8C3aVbW3a1Lf4ZXf6hIFBaYQs9q9bgKPAo1H3kQRURky9cPr8qwh1riHkse8AljoT+8OlxrjDdj03DfEQmNDhUtzYiC62HjIUaTa8TK4S2xOw4IVrLUInGg/G2lWa0WqIsr/E3v2gt7UryG7+OCbXbdmnC2F56zC83+zGZJF2+HFn1mnyUJq0upfZpeqUnw/pmURuMIoE70uyaxwiULaxO89wVqm0KcspjrSLhyFU6XY9lYrtF5AIzzLQEf2QVV+iX7PP1l7L5icRSzEhuFLBQTNCf2pkBpF1uXGZjXdmcQTLFXqiNtKnYsojJZ6F3c4xHQvikC40VTL7H4hMy3IVwWL/vr1dJ/So6ICNol+lGO8eU4Yd5dsbDfOaxdTHsBCQ06t4wNEzMVkQAF0w7/bT6gz+DxvPsq4A+anvck+IjzSMLeBUgRDzqmBbcxGVXBXe1TZBqMzXAcM7R3TJFYFHYeKxv5FY/G112dLKXTdM3LL2cIuqkY8ddUvam8yqjKxz7p4S2rXo0hM/SZ9lWazJTSelxicQ8MIcwhM9/IE9EwOBNWt22xOt8aeHhxQphbdqaHgmNfI2cS17ccydg5M4fxQzTzAaPEnKr6Dxf85A4Wzc4w9O0vGH/gzRvIAdZq35yBuBaxRtMnNwRkHfUhEWZV6Qgehd66zQ67NFPVqUQjpw05BR8werydjG8XbKbNKhJiHTPUZUUNmAChKnjYQ/R6A7Gonc7bOp8JqCJPc+2NF0bi5rVWjKwHUehjCHi0ZnJ3YScFhaAIdV+dOZhESKEH2XKD4w6efw43EwcSFxj2yc+Eb4jUk6frk+1D5Pa+NSFmeC7N3+zwCVxSqCbYTdywxgP61qcswwa4Rew4HurxdvwiddeZjx8vXxR+nfJKLmjJkMW96tl9kR5BfqaBNwG4gA7kzBajsmkbg7n/FzhKDiVEduX5Tnn1eYLVQT7OV2gHW1zST0i6FzSPRRu/BJ7bf4JaA9AmMc6lsus+MEGk2TqBQ+EdGVLmHkFABScOpAF2piS6+GstCYO329FKuLXsn459Rc2LqwEQn/BoFO16dKqvNFLCJybEfQnIJ+GVmDr1h4q5a/EgQeQIYHJaTv5q/uusLiWxPJ0ZrxSRx3OlhAfG/2ZKI1AUCKtod0XMf1Z2PXp9fvtflyUSxp4w4AicS/px6WrOIySoTz+dvuE4JUH5biY036qhE9rcCwIYHq2ikoLx7Yq5PN7BkXd75fKDXvW1iWyH8iWcS7CTE+DINsqTRnKsNHnK5eqCj40+4icGNf3YCMqC8qqvAPqpe/xw/n0RqPAcjbHec+Gs0OjuJOGEiv2F4A50YsET7ql/Csi35sx8TimzWL7imcePYBWtO7WlXaoVgjQX+5NgAew5TAa6Q4TD+p8RGSwrfzNetBs/hqnl0H/J7yHW5xFI1G9JifsTL7dDJHW7H8+lkuvG0ER7vTLTdOfs5eCf8sf4f3UxVJFztB7gpm3+kWCeaYQ8HB8SQsnWfIkUzp63zNIYTtCRov+Gnj6vQhIOYW0h5EDwr0qorZzCYQeWdhmAE9qWKb9e9NGvo8CF8xY8aPML/Y3WUzR3O3LsiJs3dpq3krdWXy1FMdjdNvvROPkUv4sOJCc8aA7cXGiPDx9z6rPl88pR/ZlhRqgVuArdUwgJX9LLdJGqL2NiXLcczS9h3aUauJCRZB0rdaohx42Gx0CbFrAb3pzMGi86JINOW7bTUqC66FP0m0H75B37yc2ArToeEvXAyeYQXfe5g8jIGj0yYrGcyTEC4h2saD4SjP38IUEJz2I3DnRyQdZ7CwPUTlnYEJzP4I6raQehp7G/NTCZRRKxyjbPsI2yD82A1FY/jf7IW++TvdlNrTpYPEN4u586a0Yr3nFqwT2jcL1Bfpt3wcInS5M/AGzYfGAX4gAhrPEftrBB4qbUzmdfB9Drg/FekOEYgVi3FEwfO4bcTp/qN3vfyOp9TuLGhi1R+z5yjD/4oedXgUzTdmHa9bSuNRaZfSrTQ/Y+12TOcvKt+FqMIKPvkAtfhdsWB/QpbAi1t8aTmfJ2h89f5gB//Y+HyrwqGkphrM3qhBr5JULl1P5LbyhCtHhMx6YDxC6Tv43gMYV/al8AIApy6TnebT+hDB5ybCB2LKS5D47tJdx9OfW3IVgND2iSmQkug0Wz2x2EgAoOso9juiaSC5b6vlkoYJGG60Qgoc+iKqoke4l2LAMf4o9xxdpEs+04UjTByB+b2esxZdKaPkDWBP8OmDJ++RQg17xgW5EUe0fjOQTR2XJQEYBCTLl+2//M8yr55cvICxsr9lHOzN02SahtF01DPpwTltC3z4txUmhB+cguY37P8Q3z3bI1QKvTedFFJMY2SRp15CSIVzBMP2OqTOOFS526KHz4Gms3k4mMHOQkHWMTjXYZSOu+EDPxYk8R7j7bDy4Ud/nT6ZqJP7zISRCsp65AM2nEYpA6e1bnF5uDv950tNrpxCU/7D/X3iVew5mJgtYeLiFHBnzwI6yoSonH3Vorg3QpozHHZDK9OoUanL8tXUlxFJNbIJ2qkKgboLyjTkmZGKaMvOFmMN9uRzhcYmScoVD2lvuGg9jczwjWkFmYuf9Nn1TtYJio++gMyoCt9qqD3GBkw8xo1+Ru1ee0pQ7TkY2vtVL6/rQ8Q3YnkPRw2lu2xkpP57jAZM0H2FKNEuSTUutumuNmE1m/ZX8zxbM54zOHW0FDspjdZkBxxvifisA308n6oV8EfJXq9vWMagl1zq0JjbOwJm9bLBLf77pAb2iHKQFlHA/mI6hOkQLK/0r32qkPriKydFFoS/6ehKhKaS4F90EEiV4KZ/LrQhLmm87t1lzgRgGHv+IG3iT5lK1BH42jdrZEW8UNwVxulZeGnHntcw3YORA0ICXWI110voLRfF3xCLPHqfEd2IYbAHxfOBS5yD9pnVz22OZHfh9D8ilOxxDz9PhATa1SDxUv145kRkgCpjupFyZFkr2isqsNpuuc1bNVRxdQUesZ4pfQ56bUm63ANiJlMXH7juKKbK7ls80tlgG3ansKeG/d/pbhE9eyjpeNcQLoLIqeaznBr2W4FVg93og0agI5Jp+yW8OiHOgxYYq0ugm793AivfHC8oUSRW9ayLsMO/+CZsO+Aux+dyrrY2IvbTtvBT8trWAgEZBuPpud79NCiD4a1jYk+SIeSFLVZCtADDjKKggPrmGGRp85sTMx9RGyCiO0332P5beeoyCNXaSAXeEsi3JG+MI+zhgO/JV+QcDkIS4tpj6fXLxI+e14kRfS7F1QuapJ4EW/x5HOBGCa9th7Y/bg7zoFDL2lp2gUsjW0Yg8LzaOZdXimm2SIa7DjacEi0OCFD8Sd7VTAmADA4qgU5HQEzPhnhSXKYwYxbtCpN3yIEAvIZ+aLpEI2D0zKxfRRr9cy7rQgptMiaRtoSed9Q63QB3ge7OCTYl8vRblGfTyEpSUMcfU/huH7+AD9UJyR0Neky9SnU237d+yKOsk1VY7L4/fmcwZMBSNTxGHTusdk0lO4gDByFYnT3bBHK5y+tHyHGh5zL+yr39UAE60ta48wWn5WUHYxvni6GAvQgeEXafsjjrhrNs1Khx4+a6X63wD6mdJZUQRLitrHMglAYR1hT3opag8fWanjiKAS5AQocuZoBScf/fm9XG+U77OlcBy/0T+x3yww3j54wHljK/EG1LNXJh8g/DSMjYtqYJDNj+rWoxazkDzUMkPhVpygiE7ITiEEMqV3JF99PUplaQ9/+4AFm3oFKJSjgici3/Ti9iOF5KQdx8uOx9Us/R5YKBz5tcLx5G78JYLkY86iAikdY71/uAtFZ+drw9E1KzjkQ2p3eRR7iA64lw1Yv3RMqJ0S3lfW4+B5jsnmEKArR86t9LR6EaeAN+snmP1lvFsoxrqHn87kpUZdla1LKVq6U9drSc7XyloV9xRno82aQI3JWe+0uMhmMWqcYN1w3zWYvN5jEwkAQR/PY3JGfE+Xlq07JfoxBxR0r4OlGx28O06TezN8kAmXf0s5E8XVFpAc8H4er0XuntHIXPSzibnVBSOnLoaq0OFHX/ygoV09uahA/BjN9wi9+fm+ZB1My3jVHznC0UvxGWyu1V5oSczuE22N1r0YAXc2ybyfwtVMSNLeGd3OChG1QYQZdRKfcBIxZIS8OJWhGwVbZltZ6Xck7YvjCxley+rQELWogJP/XILmaZGeUbH0D3rwkLWdjMj5t6UT3aikfuNo1RUrIl+M+7Ki43NzKQLdMvgoL8EQcXHLWhxn5F0qKB0RRXjepjOpvVWbInx6lHk1c74XKdwrizHskWyEwSLNN/C11Qq/AgwwNNS2OgcZxOXksphqZ4zHBJPQRmOnGBkG2KiXIHFDi1aHxbEhY5moV3UrmbmjcByx85TIqpJ/U4mKVjLm6fp4dVBeiJXk9tqpO7zDKKsHawyCQ5fuqRHOSZt++Iq61l9wYhcwt6EDXUk2nSI+/Q+CmtzzpUTdkhnC5iWA4ZOmR3j09/E7nvAvVs70kkuF8Iy8gYD5c0jQl/EdBkIX9oCMkjltzOmwMnUudXN8amoUCMuFaIdWgugrYfG0vdZ/0buVu+DBLVEiNKqGzLfFyk+vbvx8mYZp4egh7fcAftmD1nCYJKIcuENnxVuX1y9pNbjlJ9eMNtgCaJpp5f6WEPFcbEwRMNkPYonoqpyqAaWwk2NQJ7Dkv9T678PZv+U/0IwOQqfNIsjTXgduwofqdHl+Ik+SZtYplDPKQ6dN7lMpcNHXfJRCD/kzyHusysdzfyFm4T9nmsUBi50HSVgsx6oDjsp9qk0RtWAONdQkfot+aHz8QXx8zDoXupqjrsAxLvb2kjfesL7wQJLneWcBS3VUcQ8C9NL8AeHx6kTvxB+3zfDx+dZrjrVYtGjKXjeBEKRmnHmPvh4gc9lKJLLjyprLkxUPr+NncKCmXJNznzmxO/dM0ioyE89ktREvId0FoYyxkYF6wdv6blcJxIZoWDaY7wdtrGGpoWRosKPlIQRuU7uCPJFahgHLuqFoYCoNoc+5cbcoepwcTbYe4ykT2IvSPOzzLINr+LnACgHrH7Bgl2BIqlq/47B43cfcK0hmnE+Ze5z6y/38XSLA4jqw6uPPyr3dRK68PCWnmyFG9/yisTmSqtSKPao4L5S/vcy2EkNpzlaC2ocm4Jp46U8vv8fb6LiDuZs+rOBdhRhi11mWwGz3MZRQ39TXmYyIVv9sn8gt9cCjVHDIaAXOqU7OtrrrPkjRAuALImnbwzLcBDTnrTSAr918cvGLHMlU/lPE1M5KjspurSRQVPfuqcQS1MoV1SV0uoCxybANBZVncRJVAZEH16ohNF9jPEJ4kGTMlSpyz1I1RO+S7C3vZcn/mCdeiKu+U4h3hy9TFiGfHB0ZyxCJOKlo8+qMbbtbumxx9moCyfUpf316NECBYf7o10naTQk4wnX//Ulot12RaIslyTSY02ElCeiyAA/FHE+MgoxC44jUWxdgcYePZR1W4sHs9e/dVj1F0D5TH++VSz4EA1ghFB8Ht+XxCubhS9rTXDa9GteaUuO5lUE9vQYDOgphrCKh94t9pqcuBjZeNGZc4M7wJLjmBG3L6hTWsjeG4OpzeJdvGsAJd+yY/ujv9XploSwAfgCkm88oM840Soc6Ev2Zg6Yku5LiKZ2r8IHQQc+TBCw3IMi2cfiYDGmWZLXaued4yB456yvhQv9H/sNGHnwX7NEb63AAuqGDFDe4pHU9i74nVAkjVqy+3BKOnQxzeGvScN7cqinwodnELZNZ9sIJw0jpvK1TUwbWUUd9cQ5x8eBhfRDDir3s+m6HMo0t6BoXgx1KgeNtgIAKQHnepeUph2rqSw7L+4V4hxOX/OCwATlOcA3MfRo7Z7ClVwwC8Z3g/bz3ZIz60Y++kBn5EKjWZdVnn110mtB1n99D3UGyAL6lHUSV0LEw9l4Xzpnw25hkoCqjM+r2osBty7VqqfEDnzUEUxwQldbu4WDUTdn2eAMcL1q/0Fsb+IHSW12uMYQpzVL0WKx8EoSOO9cGAEqtv7iJ174RveYaxiX6bQ7Ecs4aLOyWsWgaJV2a8CUh/uMeX+TGshfDsUNqRpSELvJwLdhaeH3/FbgCAjbzhG19KNW41fckC2y4i5ZWsdUzUcJKHkpwuv1AzkZESZJfJXsPAceshyoGA5y+I46tRIVstjvmj7sIEt57jUpPFFrOxLNPGOCE14+zWjO5olZclAiwFv4FaeTDWLJ94HnKh3lthqoY6UxQtPbetk5z2RQxpUT1f+1mm6gIAWSAVhUgOs4I2sThHbUBkISWuRToau9JC2G7XSfrTjM6rHrADzMS9e8N2N2685htWaLOJe8fJ93QuL4UW0gmoNzlLBfDrdBY8G1swnBWKf+cXORebutREB2o2cNwFOKERu8u+U5MLEkQAl3SC002yNjpGCky64fIxlQYH0jmvEynUAjHCBNZi2vkljYzS7J8+7nUIDPNJRqE7t34h8bd27+odA6TOmgzI+zkx2um6wQP6ey13rYZsA0pspUDlY0I3d3Z09C9WM7ci8Ao6AsqGSYUJYYX/YwYPEWFK6ra0jEu7Wp1ekX1Cb+ajGw7yoanYzJYmLy8toNtb6fWiH8C6fAUD7Y/U3jQDAO7GXo9e7rJtcDvy5dCyWdY+Fgciu3XF4E+ouXT4tKFT6vWAYqKGoOeY1qPRPJymoh856aJxt3ceeBI2gRgB+2gRgLZ1a/3Ilq3lOgBTxWRpLEm8fBhyh6EdJK7L9rLSEqsdfMi9GQlbqJHOado3tsgZzByXx2szI8lUX7R2vBQu8dun+5T2EnfPeXMnVdCYSAdPzoNsYbo7tGrUy7fDT1U+uvu3xASMDI0XQERKEAlY79I1Hh7FJ0Iwci+ivfjHj7zpN3vE6I58cVarQI5HEplsLtaQ0VgpvP5ej1aD+2KBvFMBTceI6g8wAIa1LCW9wGsWnKo5TKS+aPvxS5zDbzgia4c9qrz4YL2/QwzW9PY4f+OQGIgG3+YHs/RUy5sO8cJErB6lnLMD7IV4GxWNdl/7EMPhZwfYChbvDm/ux9l0athiE5p9v2GE3vw2UDIoPmTnuKy3NwlH2QnfhcC4dP2Tisp40RU0LOtURc7FfaL4JswarRJJ1cvHTzZ/VH5s1VcejzOfOE9dna+MyKVapta9/MUcvsx28mk/eEf1czujcNbIqrH+PY2Pb8NnZmOowWV7tEPm08Nxw6KdUasUMMkBUXRtHthPoXTqmoPdc6UDf/EDpYbgIXlyiv7b7vNgl9CwU4WYJTwGiugHVNs/3Xyz/44F8mHwSq7dXy04affyYG7Wf7aMWntfq3efQpcg1MxngSB0TpXzHPMX3vMlAXeze7YhdSACKsPhU5vaMWzQ4qBzJ+yCRfq0Qnse9uZviTjZtT2UPV8ZfaXowT3G+Q5gfr7R00tK2KCRzkulcfcFWjLbUeiIWgmh1aXjGzkk5fPMmQbusaiP+TuLEU+MJhHILZqVMkkNd2mSLxvQfIfRcEErAsJ7/tPlGjpuOQ9CXxk7E8ux01styOK4Rs2kKuODYrylZTK2iz7AuVEDydyv/M7uzf6iOCDVSjW4tvB4nzSHgiasXVFQu3w1C0gDepQX3hgnrSR31pHBs8sZAZADLjurKkRj9xgcq3Qp4lRF9DzLlGN58POowbrYHag/2/xtEGzmOaIqA1krVR7FamDihHGZWIif1Xan6G4E5lex6FpqUKAloLm1TP9MfdHYJ/W4S2CHioO7aWHur6IcPxa5kQVxkM1QKVYcOQYW3E+dx7XX2aAI6aEqjHB87Y2H1Y8TZIZCgbHCQPkMiiz30eiyUR4Qn5RJQqQIBw3Kh+spckOFBzIGpdTBnWUBUwcBtYC/rugcHF/XpFZBAr1rl4bXKwZhdf2twRSPbaS6Cvrbxp+H+E6WDjo11tAi4NXd7+YpU4Ji4v8qmOEhY8y9Hz03XZEt+RaUxaDOmGjTAqrTxDwoQ5rPiY0Ut9q57an3jAGfMg9QLeLl9ORjCiH0aVtlvTWhKWzXehQ3mPsh0+q0nkhfvbi1J4f4567MQ87wag/nzhytsP7RaCtBMi2hY6f/OLDZJWXfRGP7YIE7pHZZfwHmeUnx6LX3wkkU0QHgGazqbIEoXkSDApTX5YrTisIwLITOFEE77KCdXMNRZ3JLF24u6FcJxKbaWn3yjsSMzcMbF4MPR3ucUH7KprFXYeoNjqo5CPFCb3pwRXmuJbaBRBEmGYbJhs+F5ey28po7iGsCyWVxOc0UwjuxVyPChLkQyqJWW/Q8+TaKIkYPMvqAmysY7MG8shoM8qK90/822pw51tStm567v6PRwbiW0dHYnxcLs3igR468RPxHsZ2FMej23WXVtb/9PpDBu3mqCguZZ2VbTky8oGTKJRQbvB66V6rJlyzdZ1KUcvJMqMUzqRPWWGhNb1W3rmUq0vnj9cQDSiZYiHdLmrqpYHA8UVOorCZnbai3BodhbwESwePRbGx/hKiK+PPdQE0jQgIItZAlnaBC6DsVYYSD+VpSE7jjdpQ9i8sS5zg0nIY/mXBkFGboMcb2QKoRT8Nm4Rsp6IMLWw5oyGdlYPVOt9deXm5ZY10DKK0yuCLrwqGrzSxOaee7d+8AL3FDIcrGrVx8pRjkaXIoS9DfGTu+pqlOLrvfQCE5uQi8NviZAIMhWtzjlH2TYq/mfmCagB7IU/2lQMk4QKE3sUmWl1FwGLqhfBkVWFI6zzMRtQV+Crx99J2HVTFqs1inDi5DVK5wIXDG3bnPbhfejApCB/Mx04N39Ta8AXpuNiNEY7W14IuDjx7yYbNVw06dXMxvV5T172r1hkJbF4f914vYK+AxCJJOvPWPwhhEGcGGgVsDn+X1jVuYwbKq9u2fLYWAi3lamo4Kn+s2JRHM7kro2sv7znWJBQluokOgdOD2RUyaI1TZTiwAPYF+tGsSiLddtPPYUUU3Le+DhuJXQCc6ZTcXuzFEo+y739KU/lZFm2FtTG38aar09WLTlWUhtaxAJQiue9/c6/XG5uoShUpJ9EVMgoVbe1i1LgRA7nfB3d9IwlnEb6A+Pn0h55tqo6fQhxhYVyoM6lEz7yZ/OB7BI1/UNZnyZJy7ZPJlzMCGMxHTkCf43fnREupPeIc7YVPF+sMR/kUdUKyDz2SXFE87n/AcDludc/wvEPe8MP4qH46CrDRN/PrIrRa8FU47yOL6CbfSQNfQu4i30zJm5Kh9zZLGbbl1+Y871tOw/xnu6XXFGRUlyd4/YUBPETbMSLVTZ5bfASeGQnR/S61QSzj7GjfXXsN7zO7aGjIhvWd5yvJ9cTy3Z27N2c+1ce2BX6vfqiqYDsMtQHtUrcRHGc9CUWhK0Dvfmzf/Rs41j57D9jDWDn4loh3ARNT0N8TCb7u0IK0kEtPYGjpzpEi8JpmvDURmOhEPYOiwZGnKdO/cV+R1GO3aXrQS5ALt9BMwB4A6GYSq3zk6GN8hGSw6D0tzF6TlE1W5VA6adNTxZ1NSNMdQsze8KdSe/Jy403Uuhy6CEe/LyauHAYizzzMWCEoFd8BSl5RvkLEoQarD+3xkybtne22Qg0jtIfWOhIuV07vusm72w/O/YGd05kCGUothzLPsk6AyVlec0jkU/quzX+tzYN8yhOtqjgCSkktTNpknmu8p9Xzfk08jTwS1CmnaTKOVGkunFO8sRpkFAmFOXyVwezoxAAlc7JkOoK5PpSVdfE/MEb8JkgnEuu25lQCE4p6fEhCusVBWzwLWyHGLwIZWnShZWP/b1KTQAelhEeKPBEzqhATCDi4xVsQ1bNzU8i5mnYJP2lwNXduGzuCz+NIS1YsFJBxLydBXWyNNMJXxykCiWQJ1smLGrxSrqs4f/t7SKrz6SjyuDmREEcN4N+wMDBOsWCrqIo7PsXGkAIdYXD0FkFyVkZYlddqHUDMOt1gmSJTgDNfnh8d+9Xzh4MgImJIdp9KFMyRRQZnUD40SI1zVmN400VgzwrfL4R/KL+k26P0ipxUKjzTOPyB5KKfISfDWG21qgLcDRMdy3lJjCb/0J/68b3r3WoYyVLHGE2sG3cP1vp00c6VOMa9YdFtL/yYskWQdAonzo1LgVUmuNVMRTc+wpxNOMe8KL87ad3KjKRwWs4AYIAsYSS/PW4iEsSSnj3t4fvw2OMZMW4/Z42Xb1GrX/Acra9Q5a1JE6+nDHxigWZAPcMvTI8hwRlDp4DYdYv06pbd5Tkxon+mKj3E6hGX0Cr6sRccsFIj5v5budCpFxl2RCdd2ClDacTlGhKERIe4mcvO/yUnvMCrn/3VDVrHSlCKw3ooHFSAj6JXEctBX1bOl8UXFbDwClwoa25JLygPemryIJIFxN8Gcs7DftTXh7L7lD5WIIq38cm4eB//pd93tWze1OF1hbvnQYXXACjjcXi7zFYjOVe/EHTGRvPPgm1N1Ks+oxpN9MXUWZAB/k4MMbYYrihwIF/k+FOEEEKH4dVeYO71Um0DqGQ795DOvmFNOlt/eg6xh8B3b3kQi/Hii0AU21eBZoM3rfppUvP5byO3+CLGjx478FJ4xCBfKhDPa4Zf/7iFPMMZwEjlmWSqnbgk7a5kPZXEQbATqAhB7V0YvJSbRspMUGP//+dnlriB2ptyFh41cboo3U+EmRqoGhkV8gApsDPnrli7oLrqCQWBT4f04980LUnEyG61ryDS5sIpEyGFSVRAzP8qAYWpp/zfJt2z3F8eVF4llmul8dgAGoq46qRRAtvgE8Un0BrHU4i4WwXSOjmFDSaaB61yt3/YPAfa/J2T+d2EzYK1CbxMZFTzHuBX2e74GThyg27yp+/rC4xkSrCgNHkairiG7e/KIpFjeGj1FFJyQlYiXja7ny1BkYx+iMoKdgtesRaf2pLSO3OnAlPmwC9Gvs+6YkMvgvMDnTr+9EWC3Zbk8tXw28z7EMCXQh1EA8pWNl5kGqH9h7qtVbH1c/yqtu/+xHz7I5w29CKbiZF6PjWivo1DaXeZsxY/cJO+X48+13cAdEiC1cPFOOog6zWGGtne37rf1pEPBwP+2tveJpnN+WUsPSAzHdddKiFZ7WyCTeca4nBjr06yuS2pmuZA/u9CbiQf020/L+b+a/r1tzXdIN22cH0kTOzQqJx9qdK3tGtdFib4t9YDORzLvJ7HJvImyuETEEG7W81Llw1XEQPw7pTSop3RIfrqXHm26GfjnmroBLMxxrYTuVzU6OLsPI/EujpOoJg6k0jf79XdZ0O4vug/uxR1wL65kQ5ysZOxiPBIVZLqo0H8JTpzq10wx+yju2msxKPKWZkxCbhC3MSmdgAZoSGo0vJVzsEPebRjhr/F8G0ECRNtK3XnkezxwcjqNQovJpJuPzsfhNHN4fQFZ1wSvoWodendMUhaxD39AB9CpIxf0ihqmWmHpzSnCrlQlmT5gQzXs0OJQsOZl1lSgaqhlYIxN06eFSJzOyBgGZO7atH2KH/hTdBb49V6bccNt7WxwHEP/uxaYku6eVdJrg1M4CVPauPVMIsUERia8ZhPyTh7QPBIlCMf8Do6W9eVtrmumRhbC+/U9ROmg/9ZKh3zvpcBPHRiH03AZvNJQR9SJZ3B1QJZUeeFumk5WIBdpKH65JsFBDq16K67zn+4GsHFPY5Ky+qsZmLqz2TI34zRq010IAoBtAD/KDdF0PzL732v1EoEYxn6UXO1eP5sojqky2QNyfek6L3vfi/cPisK0OTfajW6+aaAusCzPo72rET8NdkfG6Mk+P4VosENBpRFyS9yIkaqcUfox3igoriRit+PUHahtm6p7kgm1dcjKrtTvd0D8uLv43n7QduLHZLXdq06nyU3NW+dxq4skxfeYVpOOBiQyJ0avyjZSbG14RNxrOutKtV1OmQqFjmPBli6vnOyChVBpUKF6GF1zyDqn1V9NErLpL7prZV+e5XmuWP2TwQ+GnzO6xat+L2PClVLeDYpyeHEHZXuDxIaHnmBQuq+Mj/keTm5PA+lRPgpDZhFPe/qHAf/P94Kh58xo7nx24+cVHvYT+pq93KSZUJPxVCxbJisNiqH3ZoQlcC4agBGjdtr1XU0b/rj0EpcJbYX6fT2akAlH6KIpjyG1p5bCLmwqDtWcuofJUfGcC1NfxCV4gddNqqdbM+oljT666nt5g9EW5Udsx+5Kfu48gKri52UmvETDd2xsFr7eYqTZ2e2wqmw2aFnv4PztOFoqcj+DElh7X4B7FaxRab4WlKhnMkhlXrH/+yXwjkLsYLbdjH7EUQFsaEi5muyChAkaYawegpywIMuBMxXbJSvZFsEPLAh/CpDlEAq/XepMicrG/J+j7VAZUM58pcFOFCuKagcOUozktm+uWWqBrw0r99ZOLeq4ZJBOHaxWHv8rapNlK1wfwl70f5Y8QHdklIp9mHT2mgNUEYlzXUyqRGczBtG9d8itKpkZw+5c9TPNwjasd9JNJzJCD/JxL2smzhgCiEGawuSTSPLk8VQE4aSVQAD4gFxivXtj9j/lCWIuE2pkpOxIJyGOG18IHg4Y+Oi7MZcwkfpVWxrVuFB3B+ORf5AUspfZVj/ViRnRqMkKdmXoX9u1lYdas3ykUmEw4vRxd6p7S+3DLoOBgKb/ZoWLpYr6n55MVsSx3fJECUNSLnZDtc0Bnw8emKwXZ4ElV5NR09B4JQZfj284YbY15g3UjTvlrpF0ITB7GC7NpX15OeRbnCBXAxF0RNmIBmR80kv5eHocree5oz278JiN8AC1/puBchH49x9LGYSxkMicUes5NmpiFfTdkPF0wiLYQ1KMnBMlML1hhrfNtq4gz/0YZt5+pv2ge3K8ViR4yAi4tlgzHHJ82nzCksDcYEmMO5NlaA7SiAARdxLf4dfYozICa7G+7JfwnHm1Af2jz80hHnhIWIk147pOPYXd3Ouk+ZYmydXF+rQEAEW05zOmlHukuCANdLkGQDhxmMeVYcuE8YaGJaXhB/giAKZEDCfQum5pTw/IXK48fhy7CyCquyAJfs9XlTZ6HKJsrXhLTkCuDutAyEGwLQwwo1tOi/8lIoL+6usWeIU+z2d3JGlkjP3STSIi21Th2OaT8qJQFS1JEJIjKdFQv1l5R/culPEEc1i+u+E0d058Iq6cIYM3LrxykK4gqSzWPooeoruWckrUGLmuENvJqcbmGJVUvKYV6xDYWXJXTNAnI7FU12njezOg5qgNh042T+AvkvOLtg2l3rZm5+l4hyuXLtnAyS+7tkSm9ALPJAx6y0htmZ/7jn4qLk7Rqhz5W0ysks3RrgVhyvq6hfDhtM6TU5kz7uGjch3RsWF6okuWgs8NP/gs2D9WHTDngYQPrjtzCo8hksrimKgaJqAMBB7vTJqbZ42RvCCdeST3Fm1venUxygYwO/V0v2WzMFCH9DVKnIE8v1vrGlcchho7WXJY7xDYscOBodDHyWGJ6SuAt9Bp7/YS7kA8txTZKW3Exu2YWk6fNdz7FCwW6IPbmYgwa1zbaDMliS2/Gnnd+35UjAfl8I8U28fg4FOqeZtkwJMgAaaAk7vFHysZ1JcT17SzqJ1G8d0R152Pt0UgeyAdp5taxdxI3kEbBwfaH5H3JOJEnc7/jFN7QbMmq2tlYYJxn8eyzQv65j00sr+32IXy5+eIigK5ZVLxjO5SOVXK8oxwMpv+8+d8M0lM6XsTTzkcXRDCVP9VZ9y0yxWWq/KaIZliZ3HzqtpK56IyT20JnMq57NuazhCy14RXMh5kQXdFepcUoC8VAsFM8/l7u7Ix2jLN8N7hxgh5DVFoJD9+7tLWVWX3CensjFPxXPlzw48yEBYyYWs7faZfrkEafYJ3owIcnbo93vSkb5pfbL5Qz9wGOsrLTUOOgBhrGFGGFVdcinGAJAIsMfVve9ARh0HKofLvtRpKl1xS2+90NODqp1z+uWcP1GmKCWhreWoF+mgBzRnySy2+6bd7qsRI72CQ5tiFjvG+Hx0w4thAgR/Mjmm5idrVPTaL1l4fd1gc1saEjF0+yz/pY+5RFLR4cj6LpUEGdpDA7PfvIsZl70Zn9oGQHjeNdhmOB1kvkeV8uKJMIK1DIMPDRR9za509VfmLT7pvJ9w6WEXJFXrXYK5t4LCOFc7Lbwx2NpBGtRADMKbhYtSj5jnQivy4Vfyppf5FzYaIDhWChiK1seBkbP7VNAiVPUOn52tUS8FMcUbLhinKFP+tAt6fzTrDKLCe+Mg24l0XYu4qtBP1sp2vNnEnviHUJKejDd5p1AXhuZndRV328O5QOaATKK+UCND0u9wItl+g2nS5MXS/408xOnX8o5wSUk2Anm41XXZTjRSTvyecz7EyGuSJkT+Vw9+ZstEO4a0ADUDEsvq7E08g5/2czhjx3PSJeOP4VN4lLa89U7mpr0J8gdB88X2hvMGu8g4C8/kZG9MgpOEumjF9EvqiEFnqPTticF3UV6kClTAh1Hgj/vVLKMQFTZZrJw4QN9Ee8YA4ccBjuapgCyd6CXI/PGxvF+9fmzc/gW3jLjfSs0VfD5jaYBKxviQZSuNZ1MnWwnhiG/rnmdWcfcAJs2lLkWAx+7fCsek3CeRDlbXMA1KhyakRJKOnySRwqNngkGykRnhTvloPrpkei6486S5aXP/F/dnq/Om54C+s1diBmdvcpS9Is6GUY72ufQpmDNTWV0LJgBC4FVbgBSGiHPmYtC/WyuGywbwSCFjZ2qrP6oJs8n51cF683FQfT4UaGDetH/DXUZ3fEVrsa4rUaUTj9wyqJqLfLPxrK6lKBP66FADGaS0fy3FObhdjQ5NG0qPbsWCgin7d+jEaALB/mKE5lLHDZdu1cBLNnF0AOnlYsAGcLpskpquE0NsZ6mBtg4woJXo3e8mFP8W18mk/virkwCC2/FKxzb1o1V2rlHCshwoADySr5MFwvFVPOHOLjbRLM+Ty9PvnIas51L9NodIrq+5fb7u4FNZ3Z0dxf9BNHPXMH8xusdE+4HUZSQgr3CTna1IvqTnODvWhntQEfjCYaMj9y/JlvjVb/gIvG8UdyTx/kf6eh00JKDkc1poavWFS6C6ZLid3IFYSNmlbHoMWIFipSJeF//rF6EmRnynrrz3muor6O2scNIKPCJZyofK8IszjI7ES3txzKQj4i3J6HHRWLJh87nW4I6H/nXi40cgDmBGshPDJ2dwm7JKZYTSz88OxWYbmI4XC8vHZ2gEWytCsUHMiFNBmOnBHPPKDMUjp1T39XA4rI5rwPP6PwLWmPozV6ShiL62n0mhGAh1Y9b91OlRGQ2oRq9JdGTjeeoJb0g/fEurufjKdW6Zww8fAa7LmT01kyWkZMsDxmZbGHe4chUHKoSGHrRntv/YHz31uyCJYz+wqAMQwisJHaXuS2D8DImTBy6t5q+Hk26KLgesuzVWGgxMcrF9zsGkgeIABTtpi/BFWSCGcoCetxbhTCDLLbzxYw0PlKBu5zzSz3BNPk2clBlqGZi0HVYxCR6gSCMdENV1VB2kULYdf39pPnZ3qcirUAbx/0bkIfNejUqK9JNT1WYZ4IMhHh8VjEs6UIiJetWUS6KgK1aVzqiO/4O7DbD1b8JzQ89rZX0crxnb2wpT/cwpOPb4NUfZ2TwERHMFWq8Dh8jGSGz1ftXzgLuPSmL6BtL2szAYv+n3pW2YT1lZpNZRs1QhE6li6uLWZ+a18asVDFtNii3mO53uurMIYftXtR07P5/GvxHgPs7xrYsjpzm7pua+UsFKqapxufHjBDsZ574wY1+RCiQlraTLw244sS33acRwusvUAoSGAh1wtseRsH5u1+amoG83a25v/2RIeJHFcssuHBob/eaaDIDzB1a3eDQLAm6AqapnaIniXsYnmxWaUnlTUAEP0/DViKNytVxl+DYHfapJUt+hWkmxkLNQx9aUNvzPRYew2fl2xt1K5BfmB8smCppw6DWEDNNKCbFE1H2Cvfvl1GmOXhZ9a5lpus8VcW96ZD9TOSKRrZeiJrZ4IkFW6Nv3TlZc/aihDlOtaolVwavO75yfEvCb/p1N1W72GcxL5NrwlnA2gSbL7iMBu2hF6fxMTN6EPyh3fcni2o6yuDZLA1s92bTLUvK+llHRRwP9QFy13/oCFFTDOvbve4o8Ae78/IRQdJGRooTE0cdNCx4GawnOiTGIs7CDkfe5oyFepwsrVN4TQgcW3tCk/LLc7u1Cp736Rnjh3dnuWqjhVpjuyne/wn/fkpTsF3AVg1do8vw8hyzb8Dz0J2N7CZnK3bQvLnnrJgbm1O50wHYE480ZZPC7Qz7OF+f57lJsiZjca9YA6xKGejz78sj44G+eZl+GW9fbxibYfti7ROz/xqJXq73qijaP/CKLW7+e23/xPA+q3Wen681dmag+4Fy0GdFb2zWZGW61RSZ1chLs5wwAkSOT3qS2QwdzNNkMP1b7GDapojRY61hoZuN/h730IfGmijaBx7fB18WwW33TZ+piF4oQkS2kkbMu7O3+N1Soo8lZePIfx1kV4w258kdCF2a1v9JB80VATwJrMKlK943FiVH66vMPpc+fi6fya5zYrwypwnpEXNbb751sWt1qLeDIh3N/uuzQRrDweY5R+eT0kqXyiqKZQzNg4eTtDterYuYMTgp1OUyqsjqVHT3GN3WlRDO213KdWwqS7umUgcB95EXvrBE6J8MaHE20ok/mmK5b+Yzb7nqJRTRpUERCngsYhWe0yDbVJlm8y9FaUC8/nmrCDIfQMW5oVm4RngY9POtmbQxwZEcQPcyY3psrS2j/LXXS4r6KGLMjEU6wmI8vFU7UnF/TMLNvN++v1wLur9m/U2d4QgAA4GsYMjSh+GRHRi71VoT2z00LRrAlZoZJNXWbjnvGC/Ac0oqDTdx0qQLpHxmbcuz12pcIwecORSrHF/HGFUR8A9clE+mi4kD1DJjNcNIXCMQyCcWgmZSLuJu0zvpFw/mbiY4qHFazvglLsiBvqRhd7U71WyQ6bZnZnok0W4s9g75iXeOwoCW9cJxA8GbFE/J6cTSnXxJWY3wVecKMj4nGGVUrBAgp6lipg2p3sLCDyy8Vv3/0ZFYWTcqTRZ494/aQsrxqJGTIPvuvEK4VqeW/HNkRsbnxtufJCFG7hzWzgkGcGwZCU4tmtndAQOdq8TYAtLx5YSWh6A/CYr5k5p/aXdX94i1bCjngSluAlhlLdiTGGkbLO+clc0pOxEMdRasg84Q868WcuDBdOwTM8mr3QQHd6lEQeTLDU5zjZHw5gAFhKS9jiZZedAi1FJ56EpigFaWRSP91wbaydBJXLIvb0Zwkdtychoik3UNPSQFzH6JXY860bsmKCcbvp4lR0bysn+giJtkGJa3w5y93Nc3rVdj4KKVecTNO9HPyuQDbXZlsdL/yvl0vgJsKI6TXdcJ+KY0z1RAZs2GC5FrSEnFWVHdYijGudcMhfoqxzzK8QWowhqWDO87bXnKB18XZcQnZ5aOocR18krDjDatusL5UqSwVzoQcgbL8d0t88kPfYvFyRq+oc7h8jyhXy+RyJyN/x3KVrIsV/Zq/MsLeDGWbMjmHP0H6Qu89IVgpahZ4RmygnY8wr0lpAHW0jfUM22sXydUTNHIx+VpmXyCyeZW+n9feCwfCK3mEEWcYkLB/THGxfdBqchk5JPeBvTwEvmrm+6LumLQVq/AsFg1+xK/ySKu2BEzP/y/SRrRET2qtQsY1/kLTn9MjwtxRz55nxK5u/k9uxNqukqq7LchkoV5fsFyTAjuVErYSNXkxqYRr0t3Aqu2MILT3o6//HgxuP8TfsTv+U4hn9E0ILH4TgyXa75DWfIHbWysHHyHPookxXG15H6V9pl5eNr89Gou3lLTUTC4VlIEkPS82AN5kW/Cmvh5LMYHxy4BqkUHr2PukyzocBmy3K8YQFii/OEY3iJ6wtGNy1XBfERd8i07xHXaw12la4n2Bw+qZKsI7uJ0NZCKZAhZc5EYo+oTqAJm6A9WQAwt6knESVNoo1y0Zq5SBPiHbUyaxwga9fhhLlz5sIn2MK2piv3QcPBGWnGxrwhQ9FMWP9vo90aCjs1Z6E6TXQ4D6qS8LwnAVJ8ypHVS9ToFlw4WlDJHX2iYd7ISeXwuTTQv89bnM82JwkgpWJ0vuHj33Clv5D1IT81FskLgBjGIOOs1PH2aMbsZVreQiCWMdV8q06ZWI+ntWyIVlU8hNMs/H8F5ROuBdyESeeXmyRdFnpMWY45ISmwxIYUxDuvXDZ3fQmIBG6XiWlKhVaujzpSjMECASnjw243jfmCfVKI7QGVlwyBl8NVGDn2KfMbOjcdacqlQPDybTYl102o7dIAnBXmBrJ7Y+69XPbY5s0FA78WtvYSWq4lQnUMtOdcVt/5rBafVXu5n7dJZjxyprYz15EUfnbSSs+SCUNez7TJjzI4WQNSBtDIYJTRKX9+N5IUZwlZtlHQ+MvqzJftVinLWxK3Z5uMbiL/SE6SNhGpcCUf6Xkf4qffopv4LXEnei9cx3zYsANM2qeboW0DbK0bbQT321UX5heycEkXMimgwalFdur/HarGsouEUawrjDRXPgaqJgXyu3TVhhd5ICSfkfMyHbrC/nLOR+pYOcO+fhObEYByNuHBk3+L8+duydIkUmO1Rb9pox2dvzccNL4jDJ4341tTpS84y500iADJ52uBjxKf2I15KONjhsWfQf2dqUt0nLVWBT4lhG6XQPLcSVd5FU20zXg2ZQQiYC/BGEqFI/RT0Nec6y2TERAwYk1Jhk9qiqc+GMMo77fmfdtEB6qKJIUioUf97dcPJPt0do/EUMNsAbxdM87oKCNg2XdWGuNK+JVVXzf9Mlg+fnZHo2F/bH/0/UjtKQUY026LHAccmdWIZTb5VZNM3Npxe7w2Ol3RlysLAUAmFsfCoo6U7ybVJjFQ9MsLOQD0tCx19gaRloYbnMNI+KVv05zq/hqIrmZ7Q70Jx19ObL9nxe2sZGktUo+/Bk6DlDesBxVlzTeOvZte4THWQEuImhHDr9SLrufmoGXGRsTb2OTgeOAmc1HeAUOeM/+1GmwMSPh3lFtWrGrH4MWiS1v833ah/iMyA8R1ElwBnt7qJ1STuk6XOkAMYJqlGjigUlzOwnO2DixRA2F28hvSh2tYteaQZC8HmZBto6IlklmyBzOzdPfHiIcOif6ng+x6Y6GcWAOA6dtDPPqWnlgqyFwwGsV2sOGz4XbPEpvFm5GA0daNhfkyCH1kdkvRGmv0IMY6mpxeAKjv4CZt7JOLVyniMdqrm/YnnA1ELTGBm+AOq1KyN7KAMjdf9dq6NlrkKn+bc7UFMGniTo5BqSS8ghvFmWXXUzk4nMm6Z4hI5cVIsYCraganC/v8jQdQvo1YdWiCHfRPMZQdwyd76Fokvp2IQVscNQE3Q5b5nR/NhiRdKRKk8l84SXvnUp7wegx2HVn9ledZYoKIYpsRqQJYZkZbk4JHgtyEYuzGfHY80rEgfS90gp3747w5k8KXfR8kNT1dPpWB33oGc+sqlq+6TGiJrxAYKk3jumZeSwsW2o6jtEdpVOGJ34S5gEcKJrY6/N7EVEtKglV0f/haoal1kH7tJrTIMGigRiZQBn3IH33GsQeGuuY2q2JnXUhG6ACxsQxaBTGjv7gB6Izx3+YExW6LMgwXt4QD07sPmfseNxsZTQv7ToOw/inmUQkSB235gMDj32cUv94svxQ3yfkl3WHipGGg6yw6xfNSjgMk0N6KyEyZrIWVg6l5tr7nfiR5NnysoKRmFc9s8pGyE6vFJW0DkdIG/GcrAhW10YWgI037VAEcHdqxdL59mLgeoe3CFexF3xSYAeIgIb/tGAHjcmTlQDAvxOpOdMLhy+vLtuAau3XcIjd5VcDN6oKb1Tv8GTci6nH9kGWqClfggTBfPSruONIIJcnIPGbYRM8JzrtfAsil88L+L8UFgtU9X2QoyHbvRIBNu9MVG+7dS4EnytYtpDa0zwxK818uXrotSh8nSu/4StXz6t4soMVVXzD9vX5Bx4U5qw8B3ETVlNwnoKsqGfj/dd+8HTGt3/3Au4kAu+k9N2bWFuROlMTTqPRJ/2ApG90fKk50ct9dDfGt5P+Py+KBNYbVj17J3pZK8CupKbKYT7nvTiBHD61OL7iJcVapWuPGat69/WjS4cowYg232J2m3rpXaNMlQXVqHU242ArUBH9KYpP7z9tgoGZcs7rla0vGfX2jRtzDSKjwsddfI5BlnKn72T1OQIuKKmVQfREnePZ29aptjywIBXOpGwbq/4+jlreLwvtdWd1WNdrg4dGRWfzPAOhdrfjH7rUCBYv6Q36xnKfs6mObOZ3ODlMLBFtpb5GKyPFThgeh+lBmbxSXGV/RiWbfb0GdgEVlWGOPBBxfSbPA82B15rDw8yfA5z01P2QDexUP9eMVzF3t0uEvlAMrjtJUX1Hb2QT30kG1IZ6wAf8RdVzfPiJBziQFjxOwuqsI5SQmzU5gAkdG7+TVay541E5eU2CT9y0aHPGXOLsT6KXAV9ulba1aJT8H/5smc9SE7lCBdKlQthQW9BpJDGYhCmjfTgBWc/1qxn9j0bdYOQZuMlrunJorhSeGHfcZOChBcrS11tEdGc/39BdWsV8Uu77/6hSLo6k5MY5ItwBLkkiDW9Yu7U+QmQWmfQMExteFlzvF3kCgOwu0HxDCxASVqMLJ6amhH5S0NXuqfY+eeRxn77fuMOe3j4vI61zTTpXyS2aj0h1pB+Ql4gksIJrDXffC/J4tgUx9TPZzlkGWQlOkodrVbBXLTE30pkADKslW6xNqD0LdOHbnl8pnaqj8r7eLW6HPP/at3ErJ+ClbtL84FnH7m/8O/+6x7uf52VQ3imo++kdNaY8zmlpp7htl7Yiuh6mo94GSApwkdjm7DrH0GAtH+IamFsMgZ5aX4e7SdtkkgW802WaQDkJ+HrYE9JA7XWNAjddZm6x3UMsblgqr+m5LKMhI6DHatmODApPCk4nj1nA9fCrAqU/WKX7QJPx08mtraSUIJgg4ZxB93qZF17X+E9fjIPrQBvu7Q+1ivOIlodh2/SQqoMujjNhABWWNTL79teyopH7CyX6/Q7ZApP6IF1Is6TXmqcVr7WIwEkI0rwWH4KbqqR+gYUV6SlxV6w7T0l2IdQJoWGD3u4Ovn1heCjvtXviM6SMHBHfEZRSrFjy5vPaXLx1hThywdFDEL8GlB/mGYqjbrQlpPVhAbde6VXxg/q90CFiSDOcJ0Ow8GQs+z5Rr6+qu2WK6WDLAEpLLxHoadQLoBwRvSlcZlw/5GC3oxDWNDMVEfmf4HJwfth6AXnGNeHD2Qy8OQLxwTlZpsU2DrhZeuc4hLTP3B+skvm3bCHyRMrrSr0lIE+bvfy6H70jEqYQsx82g1YTHlTBC3Tl8TJYhtSd0PxhVcMjGASbSLNIVO5emX+hfoLj3Vq5ufrhE+tCFykjwduDBpJ9OYE9yiUQIeDxBFjE8xxXI20t6M3fn/lii29mjScCRf4QNChRGzoafY4BMoIF2ANZbhNSLiqIgBJBmqT8JpyKB2vxI6j9uM7kqrlW1IojqkGoVqm6pHmYquSw1FbvfHrKaD/dFxqzFCqIKs8kR4/m42CO8KoZGgGhhb3a8XV4zl29NcBGaDkCsQKGvbZ+wQYDuJ9A3omAT/YkcT8ntiwB9WVc7RQYHCg9Sy/i3/skd8cS2U+ckTafKY+CiZio4ucmOyXXouYqqeamSo78jt2KlfaXjLFiwHm+WgMggyn34dgxq0TFUmD3eCwy+LRsmx14YqCJNJZX4/YhF7ve9r9GTIK38TzDc1cmPKfycTDiq4SgGXi91z7P9sX0DqZ04QIJBbatMagEXQ6qe/E1BzZyQJItjSI8CslLzUpFFdLGJb29UNMalfZDMstZakAnbuKuhjkYaUPNaWfKwc12+XBsGXUZovqzeE30dli3oW/BAmGBQBo3qCKvf5g8sH1K5ks09EoPo2SooKGyOcxHc3BOnubH+699Odw1vqc2hRiMpSSFFejRNFENzbf3iWwBBy/AUPywOvGUoTx5sTXwctyqPiKPU7IqFqBJ9fctamx+x6ny+cCseeJLUh/b+vkKwebi1wrTm4ojHDPL6geXEFR/z+QyWkBFyKRhacCmJ0XcYB8v5ygSNRoRaXsNCs5/+QAPwzaI9QifUvtyz1IVOKEwKA9nOGtzk/N7bfEI/ec2zdzcDrMJSKSgFFb3te7BqW1Ee3X7WH3Mfi483RT6c0gznzPHBHcTiHQ/2OGIvBjtmGZ8QRHH1RUbdtT0akgPRwxjTrcrP3knjhC5lZ64gAUexSjkj8zy+j6rC60BHKc8HgIYqUqmeXZFVHbrq7E6F5GavUh2Lj9NeWzH/COswnfXYSb+6kSAdBEpCrIoqZefnpQ9JgrnNNK//Bu7asixixbqvmnP0nb4Ts6GoJIxaJxXHkbxkEo7cMTw7qies+XFU4tsPwMug2rMrN0/Y5IVEeQ7YpUnEvHZTU5sM62AYfW0Dc+1M1wA52hmxWv5XxfgjIvBAMtDXZBYxRq41OqjSTf0Kg9bI7GvncXBEOnme9Hu29Te+pZAD8YodLHxtCPi2TN/ZrqsgmRkNBFyVM+0YRRzFLxJyjN9GXRXPDOdzFpqx6BI1Cu3S5TazNSoX646XatGbAmNYm8W+o44zE7MD4b2oIHH0eAH6rBotUIfJDPK+OO0Dcx7wLJDg2Js1gZdovAz9yiMdz6DXmGO23R5341loNKPbAcoLoGf6To7PnelJLzxFEKlMhfq1QCHfkNtdjFkVX0QBqBjYOBaCcMDmP0l2sb+UiiZekU18UeuPdHvY/5BPMjBrHPPTF82OkOkJLb2VepGjgSNqUrnNdpzSXdY1X5QZjPdwDAC6u/suhQtVOl5zLzGdn/sJlTjDDo8Bj3a3wg2Zt9VHbIAlb9Lbn3AMGbA8Y5JZ3SnriIAhSIBcO/WxXA5X6btTgMzm+srcgJbWQxks2u+BD0Kq9pS3Oq5yn4VcXLn9nhIBqfESrR6/ZFSlDtG0LA4S4LHA1eszoy5MgiVeXJlc1BbcoGhPIjcgy2JqjwZMuKr8g+nLLfT9I5HwxsRmKUTmao2i9Vl7CS5LFp0gcr0Gfn0N5CZENjmIHuRoVJrcKo1L8u60WjSx0JtEgb9aY74NwNRVWUSafn8eyofGOULMTqfyke4mWvGZlpuBgud2iQ7eV37q12edmLz/ipg2j4NbsjVSYHKgBQvoRLW3DBkfKd+zB2rpT0Gigr0aOgglfsUgXBABdmeFGJiiOMmRDpVu4sIPyKB4aa+AKITe3UcVR/9/8JB6o+u+hMe3tLK/7quzwyZEeRtArDNqfJ8RWRN1s7NYwZNwRdV4ddFJ+dIYw+5rnRp0UyJu53UO2uack3QivrfxmmLqc8NOzRzd3+p4i+oozCUDf4LF57Zqkii12xJY+mgA1Pr0yeUOdlxEYrCySL+FqywPtpStMqIcgTD1W5jQUcAACFEL9etq+AKYcm/UT59sq9v6xz1DCcVMQbH/0XbkyTLQ5QpIt39ZYACt1NaF14p5xmoYoJxl4vToL2Ob/RgbOW4NtMMneAtoYCkxfjXWzEydVMgClSPsFjv5AKLsLQuD8vvVG9VQuCOkJDOPhUCa5bt2bEuA/upttVev2loWYbvyqEx13XPcE/3PLKPX+p3MH/ceyvaezsfz1K9J0vuPmY4D4+sQiQJzU9NsuomtuUmpSQ14bPINCFnXM8Yz9zHe5ESAx8BDOj1VtaxvxSgB9vG7Du1oETqAQd1whrFJ+iKDroiLqyZjUity38RxT4/xTipDJ+1J4FraJJdcOnvmuSKb9ylsJMKoiyLVEi5Up8B9bd1sIuzz0l5SkgjvAZEcA0KvqH0Gu+h0gS37cmg7cxQUHOQTWcdCNmmscV0JtEKFDewISWQhRgn8bF3IngHPwe38rXdxvIlnei27rHJZy2tiGve8t1qT71fbhEmm56BJPArgX87wFaXeYJEAr4DxRJkYvIoCBuIXTjirrLpzdeRsSg4PZ5Qp/e1vTolKixRSE8yFDQGJxHkwUtlwNHb0Q9WsMHXADv5vAq+Qo4AndaeOO9ItyFefIU5ock2RhnSHzZMzpEVkGzPXtWEQ78Y46pT8V/YR1tavpETHZMmgrrllBkd+Nm6nnJqcX/suztM7P5f5MAiNot+tfCFbtOxziR7nd6N7Sjbs/qf88xcD74C/o25ST9Ey06oamdkLmytL+A7suJnT30W8Ivv4yDrfVh66byG406sRPNOUUfWnatlpzNQKKWHsDVGDDVRSN/4C3x8HkXqHgjEpOaK77niM+oL0l198hLKoY8qeABe2QOxe6tCZ3RQPglj5XMNdj811BzBvIufvTGgyGevdKmveR6pHh441/Ui0Xa1y9K3YgXs+LOrYv5NVl8c+Wm6ERRtFDtq1b0R3VkZQvI/afcSvzopBD0b+qiBCkbmbCx3Eti7qrl/cCxh06fQfMdy2aIrEcbvgdedQR2JPQ/F338zPnV48YzlcplAGp4h24qesBPrEAYUgl4biQV1W5zw/y9nKw5OIgKPdPhms8Akq8gYlgsrjDcrjBPZYqhqMiu79WABND9imo4Bmch3FuU0rUk1zwEZdMTZs80+vuxR+QacVeN3cj8xPsUQGLsmpdQ9BZ9XPoTJ6GbWJmydTRiAiU6n/DybB5KBpcAY5UGVoK142a95iNMznyM6Icm8qHFf+F86Pys7CD5kBip6OjsZu5JvvDQBGgHVRf8lSpB1nmv62lhFW9fqx9g7+fqAei3o3KzMei3xMO7xP1lIlhTGIxLoTPCDs3eVnPWEPtVIM/fmTcpATtYcrWS8923TNNApmuNWYZKYYj5KFo+008gVH6AO+5A5tx6AL+2dzoUjoSwzu8H4msw3IkDl9tpFNrtU+tYSsNJD+sq7s1HqrKSYK/2KBfB96LFx6ScsEtaqPbCMG0TjtA+9ktvJZ9yQVNaoiozSFXc2Uc3FRPOOM/psCHD5v2diRZ+cRCUZUEqit3lVqvWdSaK5fIoYLNce10FKk1crQPrKAL1yKZymtho4YAzIC4/D1I1FYax7ucsCWjrF1ID8wOjzyc6TnkW+aOHyGmMYs09LPAZZTCijbxlT/+16y18X+1xbSIukg+vRnCqdIUw2yjCeZM75niIZ/SwKMk8n4lZXuzz523+QhhJgiH6lttIV2xIgUJgXc8OiHOAGoRuKSrfpX4v2/M6Ar1jKlII5Xmg4KxbBwGkEmM0PJKSSsnwhYRw1Wk8+C+FjWV34+3243piuGjxjszRVw4tg3Usy6Ne/uiiMXPAyEUmR/2mlTWNNLzWghQSwEISzID5sA0N8vqbJm8uBoSKyipB+hpcAbz92Y4OIE4HS/J0EavmuubEQ9aNwrFTectTGbwNJ4Sbk2Je+0sOXM3bSO3GkhPw+tRIIkui1e3UhU/+52EvcMjROjcIVlPSn2UkLuasIDkS2JjPNLV0+JYnLxEqGbVKYo/hxtZiuiJEnlcmy9GlTmZANPWNigD/B8LBeRcdwAEg5X0VZi7qvhr96hAv7l6bGKZXWjCj9B7Qp7E58FksRb4uva+TStITAAgfu7L/B5yieKXCMEu7fkaodj0CU3MrnPxhCaZzguIi9oOtXi8DwJm4p8cD9L5PmM7NewQf6NAuqW7etUwNYp5tFs3uTeV3rNlEVDP7m/BSUBBkJhc0sFy8jUBTLiYRVhWX/JR+Tp9dsqAsyi/wgsyVYtzhai3JvgyL6zZHCKO/sVIngTF56Q7d6vlcMBDe8m7eMJykKmqUDoQrmdKvlUmP1M5xU9elgdwtvNHIEj4PyDrNHLCgdnUNWmEQ+TdUDcxJH6IheCxS4DJ5wzrDg76R/s23l0u4s7X5PUtZdFLXRIi7RWgHooIk73zAWPdLVJvIkbMCD1OsYl4KLivAg3NjaTtuF0IlB7FT/9NMkibVh0sc2UW8KuaWzWaDv45Ahgulo6L9OcHBPtqwfQixvv8L5loqZqV0oKtbIiPNRM5iAG7jSOjkH7Wc9nX+UrI6eUxG0ElwFMlXaq6XtyHgC7gMunqS8ESmUL/K2rRDeTvzkv7M0vxu+c7anyY44rfA/wSTsutCWz/92hsXdkNjS/4sjPzC/AYrJDxrsWIgh3w0t50J+PbYJs1z/B/BlkEKBHe5JjgAyp/YsOa5LxH6QDEHej8VtPkv7qlVV8TDWod7Ii+3osuFw8gVqDXX4JqFlVWc0PodaA8GSKwpkvVHm/AUwZl5NnfQ2YhV4LMJRxSjINjiBEMU2AB4yNPFTLC/cFTofPKK3TfCiqOBqGK+AgtYN8nmmJOHib9j3G88pOzYJCfM9vVQEXAs3I3n9pgE3TVHUzBvnWharOVovZmIF2omOzxKAM8gHFFauO2XuaB42bOVf2S8ghRCm2VtbKjCafPLZUD4QAmlP9snPwdvM9AE0XiqWLH1VlpahdKJzybRINY8DAjHKNueT5vknXoo/orx37y0VJqDqdW4eFxfJhZQsdjTtRIc9h/RCEAlR3RGItE42kmNSMlAXcUa85p6V20Wt0jAMZu2W+N/H6HpTk6B/o+Swg/IzGMmleJUehHquhkN0D8VyelpBvm3b6+352N5ASxd4bHOKODPDiceHmz2CLgb/s2IAnmQYxcr+JG3Ly3BsOmZVmh2LLyX8UPPpBIm3WySk4JudZmX8+FRKvErUEx/n9o5vQbj8ZrRuzZ9VH7VkWz+UfoEVLj8CyoZA9bTPnFYfQKqD2+9nyOaaMREs+GFLx60yhlcszAi0CyrvKrxc8su85pj2IOZWt0t/2+WfDljBG7O2cS6FVBU3JTxxsOa33uaR95sLhfVUzoiBo9TbV+lm0SgQQFirhpgJVaWv7BdTNNrDgxMqJFNVAZ5ffrDhA88b13XedXQ/RQffTuQROuO+xQzvGkPh7fYdeLM2fe8xakhkIHwn48x1PS+7HgjaN7bTxPSyq5Xq13f78+n++7a/MONbN8C3XbQ3kvup31DRvsjvyFKzhWY260JQPaNlS6r7WSa2Ao9euX5f4hmrrtCJyn9HNUy858LokeN0Sftuj08tqevQ8a5WJn2JHC1aGm3Mcna124D6P/HfH0SHBX29YaX80nxlk13OJy/QHxAxGv09ZmFSwnBZYIXGrahFmyYi2XUE2weGxKU8+34hTRUFEqwGMWSMNYC1AZezsmkmb355B9oKdd7SIl1sLe8YMPMGTZklrb2cBPrkWI4woXnqSjOb9PWTVsXNvwM4Lu1Z1Hzp1ogiU+mtnu+iG7l1xSaEIlmzS2qTvGYKjscf8xMiKA3DzNsiRb/aUzAJzk/tJ4DeNkf3eyzo03Y020gdM6TZlEj6VgnFvsHDZ8czn3ju3XkYlyGUfdZVTeSTCuYufTjkWE43FAD4tI/ZM2/CSvZFM4dBZbqH2wb85ogKzNEaqKytDv9EX6KtwwXg+kMutf3Eq6L/d6oWp1tEebAcemUC8mi/u+5NPFhsYZwK7JPyU4MjVc2ACfhfZpj+tqz3B1BYLCMdGGl8gLWMB/h4UN/KL9xMJVecmpZdjuwfdLgA7Qqp6FIqAvrdY65FF9eLxqsS00Tbz60ApH3h73Ivz36ia9HdQQ7JTaRURRDWjWa2Bx2SkbGnJ09xlSG84d1H750GpiNJYL9iuENtb2Kz3/oWtq9XSO1T7Jfsx4ttd+AF4BzEA9wpTgyx4Abj6fHzrWKmKSVLG5Gv6+vnNznV4yO4tk784B11RS6rd/SRG6sGc2+o+kTdGPm+udiVwVgQyAy8U4YPuAkbWPDey6kQHdelJQb6W+1NjMV2mYM8G5azW09YLPQLBa+WvTffCV/gS+QWBwf+xIC0hFO14V62YNgyqp8S4WeRS4qwCjufOeqeZ6XpvurbL8dOP6eJ3vg7Ia6BX50DfGDD8vW7r0LNePo9EQ9BOu2O8A6k4dEsNspst4exCyCURu/T8A4lBgqfJUQ9gDoHfkYJBt8JRr54DRkmKrQVwq7kCpIqY5CbJ7xlC3DQzxEu9J/KGk6K+GKXKzD7WchUa7p5BH+2cJDZyNy6RZpE4BIw/KUYbYfpCtGeraaqgZJM7poPr+Hip3JDh19XQfHqztBvLvWey3aHOwXPisD2ZXPBNh91MOI3hWdo/I2WZ3iBXrRwI7x0/ZSO23uEhY7JxDhW1iU24FMBQ5aUevaWHctjFgjXq5R3NevtpKBWHChdW2tet2519DIK5D0PNc4a7kdqhi4hkscNrree/i1WIbYY+/k9ZnkjJA61SyjLU36cDGdfAhqe6bhfwxv97m9UU54GVV5qGfsVJpO3uVjH5C2JMvwn/iLF8JrbJsEY9QoOQOx9J8Zk1hBgGLyPF1+GEuUZ8kJqGaGDdhwTlKIF6jiyZyuxWKMQmREcmDhFwv9bC21tEejlD5YRqIaqcFoAgsEOA37bfoVZEg2BWV7mKrgIR26zSo2h1MXfLVfSbAuB86iNr8V32zlZZohTJUX55tMUg+BjWoMbnzh20tqRIXXR/IdiJhjUayjyoMhorrKv3e86TCGbpnLbMdUnWiArP8LtF0KN0c2CGhIFGWGbTUsrcRWN9DNHMGLQ1op3z6p1CIvkrSZKTRbRqJ+Set6tbpaadsrByJrq/JDMLgGoMoBw3E22nkDon0hlCdH1GbVPX6WzB48WBk4mwJ1KfDU39g8HP2mNB6Ux9Xv7mvorlnFX6o4buTU5aCJlEi0mdbnwbL0X/5bqQVkEGx3wde7/BwLk/X9Mu3oCPYRjGPpYeReLEaJNYTJ+4O1AWjbsGrokxFzVtOvoR5y5N6F/WEKIdrdMDbJqpglwj8BvKcPXtdrF58zvyaJGIQA2P88pAr3LNMAyJs8u+U3GCjhpN/u4kxooCLI4RV+DKPUTXfUUgV8LLilcZo4Z1On0MRFPsnuNh6JzAso+Z88+9QN4kM4rR81u5QFEEwRDLuzogo5Q3Bjg9ccPb7bBiU4xXikuuSLIs6Yg5sqI82wt17oBCKk3o0ga0x+VAzEShJksM8cwYHGbaixGuTnHsusrpPrhbokfnfjHEcTQTVgvdNK6oK5m1qC5dRq3aFQkq+wQ8df7NcSi63fv/XKM+kDLZSWamcPbwqHbTvPI8i+8YRfNcVocTPLUXelSAoIMtDR3mrWznR2wdaAyaZ1s0sSmpuADmw2YE/UFAoXkUoHU7PZujduucRfCc09wmEKVou3lwAJTLUDtLbTyODRDpn47ejLw0uQU9fQtTHv9NJUa/RWLR6/E20cnCy7IiZABV3kzGvBLtMKek6nxV2cu7mcDJX1PoAXuUzCX/JyjIvohKs3zqnSpldwHsnQBpVLsA1q1n3euOdbbGAZuuhlU1jn+jdyb2fhos/uo/34Wu0C8QrL4afKN8+wGwvCbq7VAwoInS5phiRhT15nKFc7VcfiS30jpIj+DFWwuQI/TRN17dUZ2RvgvpRMJj6zW7ol9txUeKqNMHGZ9DKa1t5wUWLCrdguzeJhtdF8Kodxg0nLvFzVd/Ju+0yJikuwskrl9oEtUvGGt22NLOHxEmpHbk5tGdzrskRYlkKDlNvE9A5mZfxC2UC+kDvGblvmpKyfFJu6/428HhQeQYtfBSADRyjHvBBikhd/0AYY+ZV+NDh2mUgQE7MQ/x2jfW9OCYu59ReRukweDwV/h9u3LdMm+mZ6hQm4ldVqWXGjtsKGsNRZ8tBOCDHNQZskfFywseoa+qufOUo7IGnnxJ7E8qbG7TGnbHBhsujj/nhmAtftYx04cxtGnm4tvsJlM1a2uHAz4xu4HLDpWIzP/Mod7QgkKj/xivxsjLFc5BLx9Xcvb9YZjCIGKWdXLZYtjo12i1vvenBBh3wic4/IL340hE9AO6Mwl/5992hemLS6FWzLIzUqEG5UTV0DmcDzyqEnFAUs1EoZVb3ZW+l0L1vvOPmfX5aiFH0FUmuiq2aG2ZXyEKh3a++j+wK7P6MeFeqv1PuNbNRrVTREZtCsHGy/B+Yvfy3nnX5yd46q9CDJFpeyhsqn08dzVt59Yjks8w/9c+hNiTLcEBEKY5Rio+knU969O8ohJawdkBIxtZqGVldvs1lIZ3lfLTnxqW3eqQX9d/3Urk9DSmEw4tUkJwqCtDQPg3HvHry8alsdGICZA8MLds1wxxGoRaQEswech92C59GIzBs7uVcFzfhKtdlasaB1foKh/zHu2kWQp47cyQmv+uVfhqZzjSEJCyTqzPvLxYiGGYWlWsK7iIh4SD4SNnYSOfUz+2amSnEOhlU8e0HThnozVA30XFF7G3MGb0QW04Z2lJRXMf/pc76hbMBeWmBFjtevafbJFDZGlKElPN3Jx/lo4jsK1avlPjlxBOTo+/IiEPdxsiuSgcpAS/rucuKkDkH8+287jW/mkNcGxAP21zUt+Yb5AN04FyAuYhvHsFQpocs9lkicuG3FwhOLuT00jQbFKTzWbu9A78T2Glq40t94UX5HfegoJuaZAcESGSdoJwOWmpi1EfpenoxKhqYRgMAic8K6Giwpe5kwtP6OOXrrllEMRFS71h+HTvybYCQajIZI3KwfspnM4FCfzc0mvPvaDa0LLKQw1eTLVltsUvRUB4skGksDn4t6J1oZQ1pApT81gQJQtcGX2PDi53VSEzuWoPNmZbqgkJdSVDjfBCM1USwJOT43C1VacPn6JqlmeyuiGwqGs2gu1H302imqYu7A2G944r5r0KQHxjjkL1arJGVzmjSZMqBzV8j3G6qJ3cWd0yRwvFSlzSHJRxfPWlxTMb2SgGky8wZ/P0X9VgMc8Y9mwEc43GM/EPvvd3Ixi6boq4bZFtkbv51RptmKoooK38yQxJhnMxFNkVqKXz6liv7V8T7SqAjeDtyXve/LCn81whNruMxFf7Mzd/9Fbo53kpGsE1soiGTsczUnUEZjtL09DTL4UkZbiPXjAbjd2T0eXg/+IbgOIBkFposI2j4N2h16aFbhM4C4yHmj/LiJY1fDk8SbbEkBiylbcOa3jwj/AutgGDTY31eTOoUu1KFW9QGcGyYhh1aLScqmBEP/EfbcNsZp8DS5Bofj7RuYi9NQvUFj8rkYpBuaYt/OYQNwjcF7Eu5DJ2D1kkhdIMd6KHYlCLFCHh4wrL+P9gOvXhhSIo/pH6cOsGmwYU6q57VVkqoZlb36Q+pXyzyQjmgzivhErk5XXNgIcoUrsK2SthI/xyr7pl9UzInDSO/5WtVuPeyUES6ZsVO28AIlE1E6nyed5bTvLmnlzHxn5TUJA7mcQYzEkV0Opaf0qR2fjQeW2A59SY+GMepH4vPyzAgy/G4TnypEBXsDsUrnXckuS2x7tJf7yV8Fx7952wG4pqfirjV8exeSGfyJRf2mYydj7hl/2aRCe2NEfQW9kE/WRH+WXSJ1RJXfCdpCIvNQqZPnUAzFlSVXrr+4aR6lChgKPXzUqhEL/1YNGjD0NoKqmJSZ3AC1z36Dp3LRsPVLpNA8adQinHtUyF97tINIlC4NB9jYBZq72189+tuAxLEADgO8Y1uA1lZ6x+a2gfuKJSD05Pf8hkGc5F5NBjZVZPnLdbQyyDVz1fYLoCqKSGA+XoAIMEGe6qBMeV8TUSdG9XDoZBew4sVjHOtfivjQ4fl3VMYHHO+eU13IeVAuGjHGTxmh1kTr0NUkz+sradPW58AgcygO+XWmTIrf+rx+M0UQahkvBerH5rMoEfYUW+tkOhD+PViefYb9WlNmgxNMVirue3cZLt9nBSG+/qsJlyNzg5DZ0Og5/gS3Lhm37vHT29mHIfWz00hLfXcgu9ir08Zc0Cm+1sc0sy8gv3uJpBOKJiPOhTkeBoS+VNSzXEbMeEgh5fdbqwFxjFdFk93CNGX2d/GqmBOqvJs+yJwW6lY4fuh+G5xvO+yxZK04QIHvX2MWd/r8kSzhVbH/ULlgZ8OD5C28rVG3x9n6ZXp91po6lNINN+Kg2wYnyVGChvqjl3gHSfqL1AKg5tmPIutYk7NwgXNjZbCZopxJ69A0UlV+JFUrG0uCyZrXG8+1wvs5KfUUwHMqKiTk+nhnAZi8o+IP8u1rP28iWXXDCMQQw692A735eGClhEfdOfmO+fPx+l2BuVyH3B7V6jjegH9XQxSzWgmqN21Rng4hPMtHWSPyZHRwzbDNTzc313xXnawVlfp7OpYG2kBqldz+Kd15mkbHhzBPbS75btLKbPu+3N+Tsaa4iYJ+AqDI2aI/ZzuGKBNgJvxu+eA+ZoPpAJjNzuZ++PTPElUsa4PmNJPzUZemOVPvLtENU4Sz6J3QINALfAR62AWYKiUghTzZYCLms+5mkdCFDyzalKTDh8KSqM6j++pjulUoHiG6dfcwh/Sam9HCQrpqX4gZxAosF9h1GVBmdymr5Zi7PQyokHWPYHtg/bUSE+O2lZPfIC7IZ+9Cy5ZDt9pnnfTNtFYUTOBjSzNr/xojYVp9Ay5Vs4EGw4MnDpNUU9G3FDz98LFAr7t1D/pFhIxNCvab6btvaXhkxElICnBxdzxIqPhhNvCwIn1yrSQY9z3Lve5RzvsPovv4CLGeSU2/Zx1qJEJDO32MMNA3WuhvavGamfsOXRJ0MQLtZHd2PRqU7QGImpoxASlJf1sePVVjHAYgOEGfBiit6vyNEPxV7bIQBR+7JaUZZQJj3YTI3Ba5wAXz51YgqZmwN1EqIAQReYZgFPc9mAUWQpJqJe4x3rBOsTxseGWufTsow9oY91uqV97Vy0XZqZsM3r9MTY+6bf3wCGcXztE9F6mW7O2iNG8nwjVgHaHW355uuuPElKQrjJl3JpFYPluq/7qsPr9XO+elBTyZOpwVy6WgVBYWMeEy3q8vJP51Z7DbujE/CmvVIkmpKEAhrkU+3h/Vl9ceAQKx+01kZxg82Ll1ueRnFv0ZgZpJxg14bx8gEnGRj9P2PyAgnO+bQs5uLpdQpVsmJ9wc+i0sklQZkv4/upcMv6+MC6atLsBBUfEgMDgglzDzEBEkq9oZ2EEGUEp37tinMysUI0Yk7vOXOwt7/0vkf136zWwd7VLNZfKCv/RRrn9ex2RgLpFpXeTE8qZJEc8xN2EKSP+UF9AZW0JmYRl7xUUAu7hIgnEWJh5/z04C2GbzwUPE5BFmEGOyxNxZTOsPDbNAWPvtY+On6R6/9GAuu8occJ3cHJSqOyMOPsON7ZzBrXdEIAJi3u79Ilb96CWonwDagJGR3h4sCHvcXeoS7UpAadi5AJieP9YTQzgOJ8Y/Ivj3jcWsnaJCNRigUNtxtaZEjR2E6FyXvlLQG0XgDwu+4IHA2Z9MK8YP7nodHjDAVR+ZQ+wQM2erXb3iE5nv6poq+IDqlpZNnDgUCtTlRDGNjNGHR5i1cwd8STYa3X4J+WeV+nJGl3TxvmVs3Q9+6NCBJkLEvTlXJWb4/MG4zvIofUbet2C5CGIdUAOdiJfZCoFGyXPRw+hIWbQx8klDkVwsfkgPPdM/TZ3Qhbl/L7J8hJAaJJksZMOWN91FjnuYFjTI3X25gEWO2wUfuxI3H3vXf8XwDNWNfNu0pawFQx80z6u/MGi8/vfSQEGbzT7fxhNAaErsjSykyHDHS10PS+3iOIr8K44cIeQsqQ/pSbrWlgiFChZfhSlyNlZcfCoJIChv0wXafDH+iYz2EjR7Xhh9AnrwtT/bZ6cDBWN3X/jDGXzVPLafUjqfu935OuU6pAGGo/xrwTtwncMFQhWs8WSI8aLBDQ47aqih5oCZD2iLl18l6a9h8DwczEvSKHDThK2zqXokkRvn563mvykqX5KSC4ifZyxozyn1Zrzd0JNB8lCXxc4fCoW0iopyIKqa6ZTmFpCNWEAa6q5lVpuIB0hevBN0SBFF7ubbCGDh5ru/2p8mx3HtDv4KhBH1Sj1QI+vqHiU+d1Xif/5DJ/Aa3Rn0fxgtyzvMtI9frfHMQ8rDeS7RofdNrg35C8ohThICiOfQUNY8G0XE92HXrjCk9/2b+J6O+tYNf9Gv/zwVml4b4C8bX1f3t2PMpmIM4SRPWTdajScE+hfyKVtRNwTBedYUsYJPMHVeQ11QH8s7FxF2y0ECoxWDz4J0KzrI0Y5rUHaL4U0cr5KLDqzBTsRgAANk2E3AYxVt4Gv1JMXaQ7BJUoKdPwcp2ClpC8TGVP7mfLbwRyZ43pdxn9wj8ckWH5/AGCZ8RLmKJjaOhs8CgCFLP4HdniNdXphxV6Onbf0El3W8/eNf+H7lN8fy9U01gDe0/E9N/KqDbFL1tM3iESN9ExVIHRQakfj3M9Y06zJpCqo6AYdJ7j617R97xY3JrN/gc/xiaXhmsz6mGDlHAzCK7C3g/4k/IagT+VUhE4vaAQy52qzSGQx9OMaW9mkoio3I4142wcyN/98ayVv+JJpPXoNvzXHoNLdmB1wSGcEjs/Cpw9dq1qfVBc5T6O428ZZVNgy22pmW7YT0E0zNKl07T8dt7u55G3n0PKRV+BxVhGz3tVj34skNH8S63GohLi8IRQCMNZbIYTKlfxJrMKgP6tC4d0Uk3/u2N1p51Dg18BbeFAg2R4E2BfnfsBWKkOE7pXaL7vHGqIcs8DO630ClHUqV7bpbv8F7JjnaW7mj2R6Ua9c3w7yQAUowzh/llHdb3GQ0FutISZR4uvWUrN3jH9240Sg97bvdRfNAr7E/PE1HF5l7SsfiNkmWtUrukK0rAprGtkZbfA3731H/qksEbtiZ6Quh5dkxA9uKqJzf2UD8uJrsY+qni0RRS8x6nIzC4IEdkBRi1dkCLsNfJSo331MJzUA2Lg9iT3RiCpmR4/IO/E4y7/elCDc1Dk6ztLfIei5NF0L81QAQwt/k/XK60Ghqw9P0/YPxUCYwUALmzenM2Ixc3mKcFzKCnwY2K7GqeDuT+ywMzupq3n09CrRxQTH7Y6/o66NvpK2GL8TleKNBKJg3Ulww2YE2ak5nOd8jl3ECAXHxqcgiMd45pM1ONwmyT5b8wcoYoqBbh+ibmer+Ld94vjv0g8OeSyjlJFI1Fl5Lbi4AamxVCxXKbedmu8eM9RBrBbaCz8WZW2srcf6yNiHxML/ChFtXvRVBuAOuDo82huM8ctGb9Haj8M84IlF47oZl6BQD7obHdBkJXZ9yr8zSoIPB51ijrrJ5cQBaMlcbGdh+bW+pA+zUjNOJXt2GNlLWueavOkErsFPFEGSr2s77dRaQSTtsE+8vsK2R+lPGfA0NQC+4Ul+vQ7vRJML1IFSyySNx0KgZf/RgZvI/B/0kp47MlM2PTsIpKWqrPHIkhqKQVqP4hCfFgkv/WH56WZ+h8rsqVXoAl2FZpIsup2m6hpBrOMf0DF0bkrjk/71aCLAcAMp6JsDYVismbykzI1JOFrN6H/0m4y9IKs+89pxdDR+ThGwQOhc6Ztv1M9coolwZqLdC/+OdfD0EBRWwNebbeZoi3aPKZQAnPNXWEspwryaaWrB0lhCye67/GEzNnE3A00qJzybnf7Z1QULMiqDfa5fN/YSa01l3BvZ46oi8S8I9KpX1qIfB8x1Rn0QVTH81PCoz0csW83qIkkf4URJlrIArWDSjGT3mxkvYhFNvp5Vv6K6yu/oL+JLcgEyHUAoS6vaC77BPwoOVx+U09FxGUb+1P0SEhhoedEwY+55HWbrP1MhsUkBVaYLZm+6Jg4TO1IFnhs2gHpcYz2vUGGJnfrvp8kXJuzFbblPoERZUB30O2lPEMgcErkfxUsRvXT9R25qHFVji8n20EhuPRLjg0YIkfP0AjvZbw/kQgnh0/0KVmCO4FqghLCSRelvWN2Eyy2wgZppgVhrLhrlEHXlqYXKz3oZbi7/hrrWMGPVrL3Lsc+TkFrW/fz9u4sB55dknL3OcclJlgz+UsPrcn3igsu8nAFlRpPCXWgcOCE0xtHoKLoeP+aT9Z/4AxhNOmNp72EdJQSipFFQ4IG4mvBR0JVYW/+uTw5K5+VAolqW/Z5/cXZaKHqXuo0mp08n1XqG2v6yCjdgM7prjvR4JOoYCsXKIB0QJmpqMOwq+EbSCKhWRF0isjEBFdMoKh5HBY9m7oZEEeBhb3+bE5gM/4v/fR9c2UIorx2jqys4RF99Oro24zv1YWmRmpQK9VSfzp5Qd70dSA57QESTNfYqhbVphTrPCLoFE7GuU8k2f8aN8DTjzq9uTJDuOIxwwsu6d60EYYO/xI8sk7CG4kTEUbI3JFA6AAI3QUIiovcnqYNJrx0M/HuTeAlYWhUNlaPVhhChBHHirJnmaeYczfbnK0u1P3yenIbQ3seodjCEqAzZaDMUc1mD7c4NfZzWn0aFuJY7djXqsRgqFgho1/CvIdohfITmPgb769l5xlGSpV7qqyErz7nI6+VPszMhGLAn/fr2xxGaUFrYNYGtcSDfntYP30OO5rK2prkOH8PxHFmU0r2kzfkdS1LQO1DoOlDFBChHKJTdA4Y/m+mg29662w7pPEuSbNGKp+59YFDeK2YOiS8bV9oErHaq6TxCsMEz6ajuBaG2YXw3e7waH/WZjqoO6htl1JCt3/lxJmjVss9/mtFyF+jOw+x0YZ5a04rQTU0YGTHYq8+rgtwbXXuppMytuBTtIoGJDvdmm/mTNnIujAmq/YlAxBlB5vY6A3Ul6FEZAkSijKg52eHI1kPVSk+48o1Uob7zdO1AvKqPwCjD2rQ03NCbONdTvOdtoE3pJoK0Ekd9+oLOaNASx7RWxHzui7mZe+zPAVza0orynngh/5RopvaGPVNQGgehyvQsfMUqliVr6loCIRsv61Up+QeJmOAb+Ia9keeEBLrztewfB4nnQVbUqMz6gdwyHS7y9sPFguxfByN0sGcINZ5ENyaRS4SKHSl7Ubm6YFmhs4KKQZsf5HxhmHGMLdzohB1fNvaVhvfhsJL1nLh3/Q+VCVWFMNzoLefGyHCZv9YaZXUJsqw6R6l3vLi8q7lQB5e9vD2SdspxG8ueHp3qAN/JEEgf06HJfLF9fPfEoYqL0/v6ipnUmRPSQK9ZUIS16YRXXINrf3Jm3Hto2/i2MZzbnhjVoI0cN0toPUoSpIndXw58UTBsTjSbi/cHJcLqgrwFt2dyx6EIcWC56DFwC022v4Auadg3i4UXQFmA0afBBbJCKKhjGwMQ2w15TP8C+WFJiX7PtgixScpZle5rWZUy8axt7J7+i4FDJOTO5iRQT4ph5E6YPtNJpMue9ub1dHRhNIr+5YFXXtZdhLJwkgmZjvylo3akpF53WJf6R+Dl9iZHDk30BqaCJfADvH79G4NIFPjlxIyMO/Y097Md7ZgxVdkW9iw0SBCRHekTxiMu0wkfxzz4VA/puPFRtUJAa+zfr32MNQVqTcpjsTckbZSpvH2L/fyRe1uHhNA9KiNOwGZtIVK/lkF3C3pWAV/yfRMDU+UO4bTESOuCVpK5nW+MRymQ1gKw49lJJ9bdneCP1B9LN1rzTqWbRtXvnE/T/zEEJq5VzaIONtAq1HmPJy0F4cQ2/egc77swypmU8iUh9dH9M9h3rVpSB2pu/YC4QucjNmNujyF4qL6dJDScDIUFkcv3fyX6c8ZsmZoIeOl6ZOtWdS20n+tIPXvlWjoDMa6BDn5YvSJuv+he2/TWWCh9ByiINkjoE6A6gl8LtNCTFd8etTt2ebqa5wobG6Zko26W2K7zJtmmVpF/ORlNcv6HycERzNz9Ab3jLZgd2Y2/ZJCQUTat7VsNdYaEUo4CsJgCxuRIEwlwecEctboPm6goMiXJ4ZL62LiUaMV71GRgGHJyHTYukX3L57qIie3qoHkmYJlDaFsdMguanC6aoWj5o5CqHxQZBXseYvesHrdPWkIkes2A8vNHjM4q/jffjtQqjm1ZyjZOmSP6B7reZzmY0bYxPWBFDnaA9cg7Sd6iAqxjDttW7OHGCvDkNEcfkhfeJ23uwmnH69VV7zGjKpkB5REAHYqxOKG9gd8Oo9l5FTWxsgd8wYnLVQdirjVkR2e+7WQdiTqqoJAH0YO/CoyFxD5Sn9W0WHI4Xozeoahjt7thpWkWidG3stSSdyFs3iMq37OyIIJcEfZiXK5oHsPkOnX53uv3hRRJSeJJt18cKjXZXex+/NCvc/L+X6/GYam72/ugbAbHvT0fySo2uOnAppeHBOsMpNO0m667f3m9H7UQPDV5uYqr7uUVdounDMYD4/c8HKgkEWo+3hGhsd39FGyySYtFZk34Ghe5f7lkT2Hi1vP129FZqWO0EqCh6jaIfme2rvOBD+WUpGnnyoKWoa2Sqbe5shVywnYJd2X+DhSKjfmRFdYXsp0CH+cOyD1y6k9ppCqjHIn4calsknHjGhgxVIzGMLXD9zBRxGZ8GaqvdSgE5KLqPTTaqmqXeRz725/dEmoifhopR/l4n09FvaKW+Ypq+Tn1vR79KyqLN0X0Cx9NI4xlBDz7GQbqo9SNXIiEgNXI/caWUoPIumHe2O/3KafSRQst4wKHoyuMCJeFCad/9daKGAn5nEKRg4InBIthOfc4Z8zFvSwUfXhKRSnCSA6tcxMEXAulgaX7HtlAWE/HxOExoZZsZWySQvDvY9xpYjPpuCrx9ABipIW16zhgit2NMpJYjfTX8BL6rHYmpwfWIw25PoDIDNX7mjq7xFGldLK74W/Gqw/D7Xfk+ImYtNOQSoiVWt04U58jiryrX6sy9InHHYnF4HYyVKCYSxLp4FkaH0+HNwQbCPf+UcRq8ehNWV+yslS2XrbS8qKWDJ/12KLSXatGrutHDHjJrAR6Hb2Y849d+ZWXhsEqFTvEQzMgvWH6NVWgNCsJI1Z4tnwi4CRSfS3riIDXCcSne+sv+jtL6B05yuDO+MwayHg2nUudRu0sOOlN/0kC9ZEF4MscHQccWQyuqUMjCgJf18ZwebmmMbgvGgp5sdTuU2VsquAlPDEmzL57PvuaMwaKCoGAJI0+UTaIPYWcrDZjFjIGjYlmcKeOxn7hzl+YQjWeuhR+vqKP+jtwGjT9o0F9P/M/j1t88VaoX3dd5xxO5ausxSPZOAK90mlo2jr+mg+KITrNW2qZ8v+vBc/RTSQ+69W6zZxPLp8AMjjafH/BoU+RlUpm4rQMJnN5587KZw8AfHESBNZzLP/C+qoBbU+upx4R4Ec5/KRUZ94BWbLY/yj4F8oXy8SIQEMwueP+Bx1e+PtRZLi/NadH8wU47cdyYPRDgAR3xbkJA+LFDiawhA+nzMHXY3eK151RAWaIjYtvsERVOUns1TiwXMsJmnBKkft06okdt5ZNqVb9aijAVubvpML0ONatp4Fv6BoLehZAB8/zb4PCIWWHZvqB5iEx13CN1v2f17SHE1F6UMTpL6B+QoEKkJ2mnj+wkuiZXL8umUv1AkRTSPH3FoG1pwCOBlDXO7D/vokXKvBUgI1cYkWuK+19+SutUynb5uWVjbPCvGqkCnLMq5erY8HWoFpxOZqO5cJnNTV6R2skSq1tG8oR7X/akGcepeeHROcYrEbyoE7uUybLCR9aU501shjBtAwrdr7MyIvqsBnVii0KfEqqNmRTAfo+Nzv+GnH7J1A1vqIZSWh/3Y64c7vy5fdXEJbsvQ9pzVJBGDvDOz+vES+D13AyXvHZeaooigIFoAvFW4cMEdBCy71pVI1xihDS/DQi8YBBa2UDjJeTdnid7LASJSU2rX/tEDSzS5NOlxgZ7IayYypYUvXtBLRJvaMD9XnwGKulkR5FioAUecFbk9bkfZDHol+/ztFdlHFfAWzrQIZef8uIBbM/YxXGSE4Z/Z1WUBRlztjQmo5UXChFZZfoDouxgnnk/5wdCvpeYpRff9EEVwrhsgfUeXxeGWi4aEKHaz5a2uzl865i6dmZd0qEkuEn7KPWA8abqEw3u1ehLG65UwcBU5xt2dC9Yn5QDzc3gJm20XXeFEl8w/CWBjDCqfJI+3rDhm7tJX3hwLc7PFuOKzamAgvPIzrCy0qaF2Oox2QuejuuI+tZZ811+IZ6G3Sw9Llgyr95XEQSs6kRV7VzcMlRRMh+py5/hYaylbnOcKMXBFbCnHPc2CZHwP60EuzTLQO/CGPqwh7G+dcUkGt3KBiSvHA4g7isoFOmNMTR725/u6zHdVUpqq6asDlo0IUiqfn5skaph9FW7GwWWojlfP64WGYrPdFbMQdOT8Fk1fQoQIc3y80jJ2yRAqhAeiEGm1MCaZK0L3zmzq/RXIMmcb1E2sJh9asxXlOqyb2BnUQ/qPfp33gLQGnU4hepPR7DB5ZHvCHM5V2jMf58oAfmJyh1I3Mi7cNp7Vq5XPeDQ3HZXeBEPWhIrWbZM5L7rPDDyp8KZGNlDmFd9eWGVoZ1R9bJhuJQodk7+dVJ7481hcKXBlJeaJ8Y9V1UtJC5KtNApdU7wpXRW69k4g9lB4Ul3B9U56y4Cr5srBbwUvZNsBeK60upzEWKsf30LbBsx+bINon/lsNixX07xJSdojzHmUPrmNyL//2UelyxelZaKae3ghEsqhAeftE2QJKwXWXPI+cRDXWz3nCaLBH8pDh58b3KX//n2ITN9SCKM802dTT/6zVsOJP0cYzVZwxewYJ45vcUtLsPO75eu1mIW3BgTeU8ofNQX9tovGGCBBrfXTIt590/+mjv4UmkrBTXUQe8JWXHwdATKH2cal6RiFKqX77RVJ2hmjYF6UbjdVeE9fHKmipOE7puoVKNoenodTDXi4ajfj6jD47tHfCdoXW7cmoEmrJk9cNmcPM0jJ++YUe/jxpdWDSqtRl973V/uENVyoF/EJUmo8T9DwZOar0Twi26FFCn9Ebl5Od1Zmpc7q5gE028olTKF0YJCvJqFga/L4zujxIMbze8O/RnyiJmsFNKozq7b2RWeT5iIf0vHPVFvSIJs87eDHiqeYECgdls3URpmDsXl+m3LlyqmSQyfYop5c/ADx33XroI6ACsi/181ZG3aypRMNQTOo3eePwCxMddFSPLc+22Vf4C11p1dbJ6YoHH8XVlvunQpUkBsVvz2sdxlPr0a5J0HHOnY1LGYXnAhneyt2emZdOvnUruNdRJWG2NwTTSBm2WLhShNbljMd2gc0UvmCJagI3LTAmDBNBb3DAo/Kk2rDxEjElmVIetizPeYtkQy/XXSBQMpl0crmSYzVad1Y+etrBy2JJ5neIN9akG3jwqwCrUFX5Q2otHIoKCPsG5RLQR3WXNEKhKeEHHbnPWK5iO7txe2qzlepLnh9e9K3E1/tU1Lb0xKAWGLbNMbV9aQY325VZFdjBkjVLxNH49P1BSIWWvZFnDeHQ3JocFZos3P7N2EraCKLmC71IugZcHUvKIxAjVFzXL8VgL0kxybrh7DLmb48E+nw8L5F7Szzs3JYW6gzvIq4tXd/cRXaIdURtch0Tapq5Z2w5mq4Fx/vX8ttyfOqJiKUj12YrfGkTXGPMwGThhsjMmRjzd/NE1m0/GJE1hR/BoAxATFhYb/ZUCKmYfVnfl1AacZTqkvX72QtUhcJQYiKs7jt99FlnA0SRGFplfuabgv3l+emKWdCZQW36PB9zKAXXI4ewXmj0NROpt5i3hr0NoR34qzhUcn+tvJnZEd2KbJYJ1ll0pEba1pmqQvRgzu/WB9wHAFAMM9qh32skAIt1vOl7xJG9cO4ixEYiHXVO0BQeJdlNRVOsW1RHnT1F2UI6AeaFKlJjGIMRoIlmuJ4/kNoVcb9oAvpJPRQQpQNqAWpbXkP+L7iuWkBnvwk9FivNx8CqNF7DZh5ztjFh5BDKXDcaP3ijxYQKrPwaq2ptErTn4qZZZbO8ssE9H5oihfagLaCwA/xz+uVz/Hdc+glPc9Mt74SdVWl7S755YWg/ff+hfth7ejch8+Pkz38W9sFly5pvUVzDTLS03vD6LLNMthFA1ioROVWV6SLV5oi6Eau6bzpJx0648nNFEsj9Sdq9L/SDRnRLgf0qt+aFBxovZpQHLXYcWj27VNFIFn9g80CYr9NakPTaQlKVEzPQ0e69Sq76enrwJQxWLCT0RkzIheKnHGQpS5f53QC5OskGIpGb2mZCfjkJV7NCP5VbZ2Lxu67bVmMsmN3OaXIs+OfkMhM60Iwqhley6JCOZB4XnrMAAF2JtiD55arkRlwU4WG1SzzElNtx0+TBa6WF4/eQ9VQpXxAYmiJJCAY6KuRcLc1LNhRavz/REvQmn9JAEoWtVGZFLZcM7g//AZrzaD8PRaS5SdEpwF+viixSkkHESov7uny/ViexOpEp4LarxjSmpc6tvomotlVeqelXovkfD3pDikVaNG4LcLAyGG3b5q297qaQE5gFihoTt7Vlp0NdlFVVl6WqYZOg+BmSMF6/Mv6gXWgN6FVffzpIvh+TS8TwfMSrSIGwU2bg5eAjELx5TpitLnGD7o9OvAQwoEc9RwKr4Wz/MUPedi+N2AnxBJ2muG0bUKBKXktfD6FslvPmbU6cSHboJRguuiev0FB05pbMveqDRRejz2aQMMWTgtjNvJjxw82pukdUmlz5nYgO5gTTYBbN/IBmO6G5xxZy3bnWrhECeOOK7mSC5sU0+ONZM2wkSxlejrvCTvhydFWCyJRBk6BYLaibvhfv7zruDcDFDXvjxjBkUPhjcXbEHEySbQeWKqn/Qko/WK88TxSLOm3nPUcKJw64MKx8qXyqlfsqfqGCD2g/PQEly+HVKXtQLmqFSYg/IRyz9NFzfGgOIu3pA2BfaMF/m87iTG7jC/ePo73jWChYa8q6MId/VfrhOMpIxP8+79t9AB7TSYWXMv4zcw+J6NiCBOnB+VW3M+Kj7m4wj30mQwh3gMS4wM51+61j9YjNsbpNemmG0zkwQz4XpwAn8Renu6s7A4CincFaZE+8XZuG9I9sL9ixqR4J760x7KH8YQ7RaRYSkWFgCj3xhzx5LmI011YdVN+66IOg4RFHDy9Ilaw2zpFOLL5v1UrQY9PG/DR3prqYYv3NWfJHbO29BJn/PPUV/l3FlcI0Ck3PammfW62kuuf5zLuycobFxAuwRELbOwvx7W12fEPIJiDlnEBDxs/8MYlxYwBho1JfuTVjVChIk23RhI6Y9t27BZJFvk9nZKzrbkL4fvYwY1S5QgantyPHgjCrmFcPspT9yuPGom107m/EgbqtpIEPKl22UiOQsgyB6NGmuYKOskXB65ceKGKLvSgjJgxp9AjFCoywhitaO55dA6KqBYf8uYiIq2JTZiYnHk9GyFVAXc+m7KjB5+DnxV55zw7T1N/qrX7uZUDsyAN7RWPmLKHxudQykCsUOpXkQRBi0N3yFSOxkjfU3CGLbdLfAYV2tP/iur6+ba5y0z9u5NErrfvS5PTOSOUEQnUHprb3HztsMsDSdUTWVgTaMQOQd99DshGGCL1Ai3EysWn4bqDJxKdIxyWBoOFkvNkklRhDY2oXi6lYzfBFItvOQv9enTEfHnb9f39H7ZAho77VHZd0GTnth+3wkVSf5SBEN7hUKnXeNqxlBS20WrDPKwBySP7Xt86zpKsntcORXtaUpV/Z1Nq7QQkbkF7oTGS048F/jdXKHJSu12+4QbwN5U0BCHwl/N1MLQHaw1Y7QgOqAv9g5+pUbSDD5Pr/6CnmqTSjU580t5fLVcZYipBrtWtyfM78u5MN942H2Abl+vYgVXBdhAE29eegS4n3ZrHnpEZCd22HQv4I2oSDGZrYVUkyG3phjU8+r45crUazfcIEfRD/cSDjGw6MSgynuz2SoZwbPwO0LavcslBK7I1aTqjMkF453nHlqqjAT6LcV8f0bBBYLw+pV5Pk4zQq2G3ESprBsPvQDekF82Ixo52xk7/YSESBIxM1MJPowLQImLA6KcMKaSepO9AHwgNiuqjYKciy70PHD+uLXyjS1EWJ2k+5jMOlLx/vTam4S2o8CRIV130+hR1dBHHlKLGw1bKtZQb/Hm/KAaVXSeBOvkrb+n8CSq/pvGNM4BrxMBivsANIKDG2wl1vA0uGxycS353gIdNK8hGEy9YUUwGNT/2LJ2eUlH81611xHNcgeIb7Tln2wpLGNYZDmebz7SJ2KA0Bo4vRbv4Bc7OYiA9/smnuS9Me5e3tC+WCOuvHzafcZ1zJrug0BVatlef3H3z8bBVhdcZT0QU7+ZD3DQXr1Gs5F5X2CDKOOIz9ACtZxP3xBhgYRFSlJvVXhZgfuZ2araQlK4txza0kQgkr0Wz+ltY1vfT2UfGwa5Mil4g/HTpLd/vcuQ0BleGkCwMy4sF2HVqGKbUNPxaXMCLePmobrmVTlqDLmifqx9VixsYbjUhFsDZyY1XeTwSiQvHGmBqh2L0pJ6oybf7O/dARW6TDwXqPTLpWaEZPXhslkG9pn9UxGmSy73GB6rJCZ4rgMQ9iq3sTND4v59OWNmFaH4iKyrWoUzeVAkk6V323VL5OVykLQtTux5/lzLhb2YA+EZTikPpTHTiA4VYRh1GFd4WzHhmMVWGopWlujNsNPDWI6ZYK4oKgz4Dx4kbVUUAiEwJ72dtWkd7Rb0+D9HJ0vWlEBZZcjeVKuH+FKFCqGHDECtU8WliW0s7prhzWfpXjQYWcP/M5iwvK7xSpUl6V4/WYnmor0ttZWa2/La4vvfksx1RfyZB9znQUti/z7l8Mk6wk7x9//7B9ujuxqcN/r9IM9W/g37oPOnlGEJKW0EEulYc3JXo/7V/bdk10PvSFJFSE5pI0b7ddfEZ+7ZdfEnX/t8fjWrndc+3KUbJAvdsQUWZcTjq9PSpLYW4dFhNBjTZQcmNKSOWbFcgIv8enY2FnLRH9oKTEuHva2UsGLdKus86htNf/tzNwO3uzUQRXHR8/w4vpFHmSPP5K2UYTaL/fi+CAKtT3EyigN7zzdFy6HUOJoeMR7xiFuAopoDzCgEbAnup0PMuj8jHyP9TOyQCvilzVipr0Ynm7/p0FqAKQ7FqQvKtnUZouik/P2Hz89QEcx8OH98l/UAuowodi8B7BcTpRW5srnJXsbYf4tfegDa3U43yTVl0RASeDyqVnQ6HBsFfcdBJ+QZhajLmrTKOHrj09Qz5wfjCU5I7ElkolDJsKtqurvalq1sbjg6kJ3Q1TvUh78Rj3q6DzvkO/LYL3l117KTixUwe6l7vhfugfEuhY3FiFisprEeZyIiSBsc+5Z0MkCH/XhzpB87RCF5dgVbauu2m1BlA8yt/oclmfHBn7Lfutziy4G/YYs61e9CvsqaBW/1Ce72PoPRqnTpugeU5dYXEPYZE5JBzlwETeiw0p2MBR8U2Uxc3Vm0uIGOV6fMXgH6BeIT5iw2DYGxQKKoGUWmytjEP+BhvXildPLrG7v+13P18BxkO3TxVIm1AxxwwNKDykWpsvsEbtrViFaSHBnxiRs8Ee4CbDdSMhsxNBioEwWqPjSHzPBS+zx7+gy8NnS+bIhnij7gZEp1/+G0znSbcHFmSjrkDbM+d+gJ0Cwk8Iwvpysq+8MtTwHTYsw3ad3JuMLVJjT/fN+x+CXb9b5Jr7LYU5JS1Qhq197YzqKJXcya9DwZ16lkRJb05We8zO6nWhTbgxfyOnNX9s4+9PCEd8rAxCn2tRboUmy6Dpbxdog4Ddbebc8yH7TpBXwkxSm7PUdfu1s9GZ2rEc4JT103+R/1LcwMtiAFMH/cqY/R8jsKZaUWMw2b2ayfE4cN6+TjSWB0XhIsMvY6/B59ZhsGFxcP2kk8VlO7qLLXhrg8Dy6n2vErw8gNRC+5ThCN4abmiaPfKw9s6aMj0e7WQ15pb1NxK8MI/5p9hTRKiqImlTfTAWu98uafcBzOsSFiGlbKbM4WdaNNirv67xXYlgtM1tMmxvWrW+PDd9GGk6G4DwcDisJYOIqhYiTL2dTSU1HYQYXrvzbqYiqp7/GwZh2bFiGZmc0eMKsmyUu7kat/l/ZDT/QF2S1359ijc5m5sCm0WIh1d2xQyIP3myPyCFDMXF9tmkmlHMu9NyVXxadnCOTQwT9SxwwQauUSSbwsBX8nhzyBmU+bfH2b6wzgTBLw3c1uUW8QjvfV4+W21mDyRzAXP/Qf42xZAgKFXqMzwJU+gUX/FY2WiNBh3ZkJTym1kffYuN4KYJbOMm9EPuBP3s+rgy+7/8SUgz41cV6Ew1aNGS2KE6GK2Q9PWciJEv8itJ0KuQaWtGry1GZ3Hu5OHK4c9RFT5P2l/E1sKuZ01Sz7e/0Zo/5gCGVgHgkKagRUdNTKaBLTi5c4i2lx88On4b8vJQqFcC5JILWzKTQON/Kn/SO3RZTo8S8SUnmAgkBpX2e3baZajWNC5HCGhJV7a+6V3RP1QEr5JVpL6s9zXRjwceLchDO86ES/8VLR6oInU2a/duVA631ILrYZstvdxstahA+VNeJp6qI4LCxQEcJyBqIIGEBFE6pwP7RtbiEVPSwL7kM55x07bD/KDJw+nGvtv0V4JU9+RLCslb+4Az8U+xmKFjVXAX7eMdua0C/Sx7V/bYRcm/ST7YI71W5zhAD6pH2/UotiBeLgyZqgZ8DaxRsPIZ030M15ERdsBJbNPHRIXzcnkKqC9sVRLQcxeImv5qffSVmG5i07tToWr2yZe6rneYjd72J/dfmSwXJVGPt0ODoa7AM2WtXpN6xjzgi1Ix1RCzSHdOxbdELPBLATMiEj6OPT6a2OLY7fGDOunGwomr2311c2B7zBRkANrA7iXp8cH3K/8kyQz+qnE/iUmLZPoD+yWNF9pekykW+/pT7jEDXRxn3jLTx43MtQvCQfo7dzpZlT5WTbgNRQ3bQT/18BCMYCk2EytEEOSiju9cmoGg3NXSymjHDMkIazu/ZY92L+KTAQdRkeYjWrI3tXJORvWfZH0uUsSQOoX9a9OjqX7ZsrsXd3rZ+zz8IlfkFHS3V0qFMWmXRnWi7OMQW63IwBq85WIojB5VTICT4dV0jmsAY+mDrAAqatoYn4r+bZ4J7+CQyX4fGyqE/zUr8NeBVBtyxcbDMlrR7kPYwYmOKAZkph7TsBs6jUNG6qiEoh9rJM+6Vw4MQD7ja8Nhib0TD44pDvQjsK9CaobVG8hJOhFtiBxGps1z02dZYbMiCaqrvovuEBVjr6atLrBeM3/uwEK4Rrm1YhKoLeOXdWBuNsIbcgOgg7+/PSb96B6EM/qIfrmooo+xlORBY/yqP+pwhxLL2K0K1ziGlpsdyxXgZaaYhGDq/0Lfg4HE/T3vNo59WADEI43VwMKEwgSOZkE8/E5kab41tvm6haIjTHwMrsbHpRPWyv1BlFjlNMSPvitjC25CVwNbGfdB+dLHNEPS9irQsfxia7qwSDhYoQWp4/JHFDG+CVWpYuGP1dff/T1eTohIuSdm4n+LjJbKvusFpPhShyjE4BPeFuIZjGFMqhg9mAdi9de3JqYLKYCR+aVJdPP6QgF9qgrmQtL9rKOetBSV1U7sLf08iFapgPGqMGQf9NADMbbUHtFJf0JjqI9xpP2KOaTnoEI8lerLKwhYGdNcmu2/E+U8m01M/BUJ1RSQ47RiyOPVRhtAlGoBBLk2HIv61/cIqYsH0ygoyYHycKc9xs0ZVMGOAmp0SRJSwqrmXHBbZ4tABcDVfwsAck6+UIewoIU8YbLiw7T1zB9ZR0ZdtRtzlPsJYGJG+b2BwrumSm1K+EzuxaIIPpjYmbKn9HhG03+RE8kLrZThz/dHYF9M7dk3fOawNcsb93LocOeEF1VWcxzAkFrDyIcG3ayfLfAbsE0KC25LqP6oBYKT9Nlg2FhDEJilxyzInVsCRvqm+VS6vAUS5hV6FmQOohwYqwBcnbiYGAIGwHZ7AIXIJJ8GV//3HnuVvcJyONeeOY5jDSjthufCR/vqIkONqLtumTu22+bSOrkyzAWqUij7Fsu4nnFGs+SMny6ZfCUR4UZe7YZTWNXmvjw3jA7Mdevz2ihyWyfCF5gOsQ8YqS0ziS3jV9sbvv0WFs1wxND2hDn57Hi618w4ba+MO4MAhu65+T0YNch0Jh4ay7Gkli/8mr9S3+JErTvdoI+Pr6foGLXgrM2mDV+LixVkaU3TG03hU34s/5Lbpwf/0y7tpuuCBVhfX1in5sYp62nLXmTKgquOqXdKMsXJyu4a7WhGrA/PaZ20+y/E+xlDuNiLi1+wL+8MY6BviOsUiJW+AKy8iXnddtCh+mD8ndpdVCLed3PTQlkufLHntsnrddzmrxPJnWOayjRjXTg6yDhiq67T3L1Veb95rLOznwjc4ruqOn6gIM0LfgTnPo/SG5VSOrt3cHPmePOX0rJZMUHEhFQqO7wg5xnQ31TPp3ckDo8BXcWy8c7rUiJl30Ru6oLeczBGFCHmMjMSdaGuVC/Bh8997USboUthrxcdtI2eOmE7TR5BydRY+7eWKi1ZfuA2YQXylfzZxPD1z0Qgf+IPGO41egsAcbqlwqt+BoyUbIrR8zy5E+HOfgIZQO6aiYCW+hluOub42S6NKde6BgexEjJSZi+bN3Sc1qvfzb5f3T4cFe6j6v4EbjoU8PLGvXkVmR8F5gvXzU/JyDH0lnfOpf4tDG/i/cenn5pbydOHPnsOh6tpB9AM6gPb6y+57eBk0wMowGpVwRFn2h3aEs0MzzA1o3Y2XZB9YQxFypRqc32x8yn7T2jafNrziWCINN7WkrCshg8fJheXZ/mXW1ePodY/5JYj4QudSKFUnNcw63PxfqqKC4LefHsatYIRVSWyM2MJP5REr7Osi7Nl8bcy0AiwlsQuKmMQyrn9GDekvSmniqIKgyijUs8hUnjyIhTKRMOHyCxQ/EVd4ClOA5ObGdtFEX4taP+x3zmHWZK2ai66wYh4er9QF64c7JZfWA9sXFmvo2nrZ9Aqn3QukSj27kuZUFgr6tkJH2Ki8kXdeBtTqm8qOuKs/eLDYwBgbZAuYLonyoxkXh+4fuJDMCSUL7s0NulsfUOBruxDHyHLiG9LghtZSdqKLLsHuR2lztb88JXYq1NldX2aUIQKy+2Kdx8loVQkxvD27yNquQ0KWBgaLMlL67C5pwhqzTdZEunWZXezPvwcRDd0NRQA82xxwdW1BkaC3wWFPKAfJkLs5yklJEyfIuKaX7ctJrho9WuAL8MMg8Xa2mcx3s7QhCHB5+tGs9ufAVbgKSkfvnag7FZTZDgiLg/gymdkx81dDSMGWH+UpENoAabmRGnbSWGFgbIaBWm59qUnEjt4Hce7EUevAVUJXUa7BXZC5WddIpQZyjAe7IZlNhs/vH3DWHmRuLJlYJ5gu0XWYftDYgy6F5cN61OHNuqx3UWcyi7RPa84JfQYN2Jgmu461pu1X+X57yx8qevf5ZBtlMYYjSK3JcCEdiqAIilxzrJ4fn2sCEDyVPK2fG/6fRcTl7Z6SGY8dbHcspwTzaeDGnJmPeb3dJF6X1StTLd8+RtDraBfKus3ngMM6MkZ4FOSJLeJvO3be1DYwC9tafyDB0/4KfL9uEhe9ERktX9qYby3KmGMVdYmhnFLRA4T6fQzcZxagM7U/kB5vAZbNelKW+L3XuN9WFA+oqI2hxdH69CCRKtqNSRm3VwPQUK3zX1PeKDuR2k7XVtUPgoC/aPrtoKUiJ9q+MBcTEU+CajJECYNSte0d9tvz2kvNwbEZQPNOrv2nMpubaUTipHaTSN8TQrxaf1jhLw7qmjvVJqiKUtQfxNAtC73aH2XLexCrHTEv1bC49HVYEqzIvd605ve87m7j3kh16WxNtOk7EIuwsih/NsJ4eIhwK31BKnZxTlMsPy4OAwqKLkAhm9jccMq2z4ttFtOxCUh1fls/mOMW9qH/FXjxzQWYcivkHGU7Fg0/giRob7bhLqq1WdDa/1B8aL1FEEABRXBBFQiOw7VuYgG25sgSe5PKK3/G9nXIVqO+fMWFyHtEzaW+iwIffU2kvj1Z6FTJbpTH2qlnCy5Qo5lJlPZ7v/2pPwy2XSsrQa50DA2MFHQXj1is4IYYiuoMJlq5Jtrq1GoqkbeU3mzEnJ5zbhyFEWdiUjVZvGNM1lapFGOW7z8kZcwe0qITUfEzDRZ4wnUn+qm21Nj8qwSlaTAUenInmBnMwVkZg5H/vsNhUJEabNOCXUfmmZoor6DXO5RkkPe+HLSX9ZBYgQOZvHNS8lqhrVp1bn7Xs2n63iQdQBYKRODThEFRK1EcpUJU4HgksGUEDIiviGRWMDXKPMSrBCidLnr0WnjnilIDZYE7qoKIVr6MBOHiwlfvvSeGe1HjO78yOOmF5Sr28jG/cKbuXmkRNu4QLXsy3HGvgicKXmBQJo31pXsfI7CbvtAYCoet6T7qtolpEP3c9QO3IK8xsy5sdy9N8z7k7NAG4v2zdxXpdYxgR7XPIB0+EZ6GzfPGFDQsPyZml4JzV6MxgPSNTUC69PagGhjAt8LPUInbs7By39MEk/FC9pUiheqDFcT5ZAQ7nLDTtJm/OJMSduWAGwYIxrAz3ghjLSjUwY0DZ7F6o805XB/Y1OZnAyavV0sFSPXivyZVH17IpqzAvR5n564u2CiWKU3gxBBr2QNS+WYPYgHYdbwG5VjXttfCE67/z4Dplz/GFJfpg0Bcwg6RFBEUAy4A4DBoAdmwqwaYVBeTmeM52zrUsWmbmT3sAXyX+Ugrkm6+Ub2OjNEil1Mz2Xtp07yxP1DJXImh/C8GyE2uVt+B1PTBtsll/7MNP+Xkf+4JNvCTTJpxCbTg1+vfREAedLftS5fWAVi0ApHpXeaCBtAm4gY9t8bd1CM4e9EE2ig7ihsjl2dZriOhrUur6VEak5E5YlaC7NVFX8yx/Bsue+bOrf4cxj26zUyH9xaxyVkIGoDR4FTw9SCUosziFDromtTB+4xDNrcXduaE7URUTvXjghK/oZQmKAECgH9Jqgl2GXeGX0H3Xxs8k2MJeb5VRbvXLlzzL+q9xfQiUo7D2ks8VICSmviMGIZU/oZeQ16YWJ55zJTc5UFqdWa9VAG2b2HzRgoerhM2XeYYAfhTp2cWXTrQCZd9l3sBpWik8pkb+ElRNwr9lObCg02la8CWiwmyFaO0pIFri3APQGpA5P/12rp7i0H+ixfMsKf27FsJNTA5PWUJgUV0CvnxrB2cf+7wQuEPCqEAW6rfeWMKVHelqBXodqDV9fDU1jxQR8uITOZrh+8BJsyRde0ZAa9YqYXS7+JJK9Xe90hvxnTffO/GiF/JEvUElr2V3ymlX3p17DFq0/K8oX7Jw4cihbVNTpfqcPjS5tmhB7BAsS3+Q2qoVNF4htNFEVcCazK0W6pkeWtZFOoCIefpHNGMZD3OX/noI+Khs3Rw9IOc/m2eKNZiJ87edzYUVI+igBaTrqWu9j8khktUbO/QbP1Lj7V6zJeqEUmYuGn7TyiF4lgQwpCefyE5NzjHWa1G6NB2GimEz2FxjDw7r3BQiWCbvGUtmuChqnr2RdlxMNtf/Fk155immZWNvBpFkWDLT8cnXsNKQ5/HUCQjUx5aHZr9GHlKCT2ldgcmglGrS72/qX9IDQKf+N56IZAsrALUlXv3Wih9oolBT7wng7+cce/NM3PcUW9eKY5AFW2GWY9glXbjX2PAQobkNXMjnU6s004ztHxz5ALk3Zwm4ceC0KZh8oH+vCLIuUuE+Xt1c3SHHsVAeC6jnIJlr1h4MTj1TvktqctiFdGbVIOc8bckXrURL8SfrxF4cOOeJbMcBbput1Upkh3JTm0NtaxUrh5ra/KQ+WAj/N5L0vri4PGA99QtNtRqHYl4wnNs85kaS37z1YcLbxU/IoiZvD7P+zfy7x80fA8UMDxzl+zxPIrfx47V3KR0GEntDtzSZ9Dx7rq3lL6nbeHmMDGIZHWGBH5YN3CPgTndiKl9gQZVC+lZB8DmNXXIoKcjR55YU5V9nsWk5T5YuHaxiiglwrU9YpUL5Dx6YjrGrdtiVC3j3vTUWGxdvMaRsS3draBA6aXuH1YWKENSslWydBi1y1WYb7skEwiDuJdoEl8Gc7UrG3KMqXHXmpz4cwKOZGtxvipecmiGBV0vKlu//qRxBQPDUP61je/8yOwor9pmLuJHAqUH1uXPnXcOdgNYes2Q0boC0rBLJsf4kDHHAlqUaJXsx/aBbkxIWuf05ktpDWAduG+6eHUSaYxu7218R921hgSwMJHct4jtPK1/R2y1eTjGARn6vgEJr7iZ0XV5BiclXJMdBd7VezXjFS++zym3hNrh1UuRmXkJgZqWEIsKWZLHiDf+G2rCmp+MODS8WgQQQGKgNbXL4zKfwqjkwFSuhpv2GCmloJjqsxJ3FNVSifF2OxfJqu1aWjsZMTX+W6Sk3cmbbkso4lXeHp+DWC2vOM1ynQ/3k2Mw6nzKZij5mKaPphL2jr6Qyo13o84Rpy/QMzm00gg15E1tNd8blkgW8nHOQww9VQeh6s8ndvkyeWwWpjm0cDPIC622zBG2f3LlB02fLPGgbplWHV1F3eS8275LohB64StUufI4s391ksPsWE0j5IW665S3z/4ara8HRY5xHKRqlnxwLR2ICSxSawvBRZAJIOFmAo63EkWoKT561Thv3jiyke6D41tCuo+e6rM9pdfTv4SoyFZ2IhYC293kDhWDOeTwRrXc7J33yxt8R09V22/twbchLy2zeKgiZtmkFgrFrqWifM7VEBl1ENrNuk/T3iAsNicrruGwNUWuQFwAh3fKEorPhNlQwUa+X90ORn8fqumK4eokfxY2JhDu6XucT89uDsu/VdVp6lfnI0wtnc2GFJ3sI7fGoF5KZmZlHLR9cSajX4Rgm8uMqnNmAYR7ix1U7muJlNvvmBDCMEx3F5VmSuyFiUy8R6RfdNP7R0JeT3mDEVL1rqrK86YlRppe/rRRE9soMupyWlD8HBl8JBycBFedL9++IpgLx3/u1yJEgKOzLg0Diw1bgvV6C+dIcDhriAgLUWzVDHvSumLT6X7A75gQleZFJ+rWpYs1w27XgTvl8Uap7xv+oIL/FXh6G+GKuLGRNOuGBJAMWUHbhUXwRbUG9CZvp+0QyL2FjDtsXEzSpJvq6YCRlpM6mK+kSFlrBYzcQOlkdc679nPsOZp7H0hiYATdvi1fRsIGmQLRQgNj3YkiAzr2Cj+XbHU9LG77iYAeQJHDrkmyAMgA64qAUgM4i2tZb+T8d+nu9Nd6OdKe++tOgB6B0+p/B1mNDRWKjEcbc9naTt6jE1OrrLqwGPFhnA6Z0gX+N6+6SoFMiahfFDpmqgrO4faY93WDMettjo+zTGZpjscwLuWV/WQA5D0Jk1mdt3QfSbMrdtALaDDY4S1fqfAztnA7LaziMuVK2q+yhvXxLOM3a9mE2bFBxZMfLeCXGsfCqi2uX31rbXco4Cl2WmVP7Ui85WgVdpSXxWkj1xQyBEmNNksH8W1KGtTSZO0OPh29jou8i1UfH39tZsBUOsi9qego+WC4ryVuNSu24cOmhpBDqWBVr+nudZ7jUiN9ViNa+u8Gf/j+Yh9w5Rq2rbShaPis5tefQJABDZJnZrmtDwKWRlgOxHmbt8B9pv+DMWdH3hFRA30XJMOPBZ54haJYKbuPmcoiNXrCFx3I6OQHMR6pz99RdRirOHJ8qlCuqxiWuLjuw/m+0e5PAHFhyYx8mHzuAIm6D5WOmKREFLMZxJv/ScDpprQJE6Vi+TX2VI07LXka8RIcMpLwY5+9yvQwQPO8HhCOvwAS6NsaIst/3x/0n99WjVahBnpzVNxZk3i+yVcq58tYn3TW4BZhoS2kcI93QlbXqKA1MmY7nz5oaw3VYAz0/01T929vrCIsZ3IyD540C9kitu8+RKW3kCotxMQQMGurtsLfAR+Kwu73DN5mYoZDqVXs+SMVBOANvSTrI7ryBa70MIpcmD0brln6bAfZDxydKsttyoeNM+MBkUOrnYsOevV58D2tqKVTt8W0q4raWew5uXd1DEEM/FhXsPstAx0ZNA90fO1pQjSeyrovzbRq5esruUpGRPsRE9Lt6ArUYrdIpG1Lzr2RbjvxQKrYqpu+7l+MJ/Uv3YnmLjIoUrU8EonkF6UcMnbT1Y2B8hghFSVFrtTwO1qnNVh0jfW0wDAzeAQoDyTfcLXm1OU9K0d1SHgQLM1INVcgpgJoXbXmMdT6VXYLY/VVmH5GOtRPFu2dCzd0PIDb8UfVGBDgT9XADG8N3aAj5YKylTiN3UE4PokzU67CqgFcqXGjl19mfxt2y9bix/HvAC1k4wECKO83X5O2npEUOKogLbcqPjGKsvLOYrPU8KUJmgIPWT3RRZreN/RLzfjZy/chBerZfG/1nQhB2ukAtFxPqG+kalLLIict5JpZnVV1MbRiEKogk+gmYKrO406E9BDZ5IriA/GJ+BI1D0TcTkM9ZF1bHFNbg8lvjyKwsHp2IxGO1Pqrgo4DPHoh/tWsXpRDYmvA8EjbabNABLqW8HDGxJGasmoX0N2J2ZoTghL2GXcJBJ2XSAajNZhUdaWlpxnrpWwNzpCD7AnRDJ2S/NDjBYdPAV7vVGSoYQeFMRzjF9ZZOoCuKaKwRI+RMHCCewQenfgczcYs+6ftPAFnTlHwnZwDME+j4KoB16q0jKqNfS1F4+sjBkrw8TSPpi2ufQiUPizqYTUG3xJKnk2LHy2y969QALBN41vHjg6hqKXiXFtk3QVBDrzOArJNLpBgdGJ/HK4Y5nIQaqZsB3lHHe2lspWEfHub1nGLO4aq1boXS4A/x3jmc14RvS9i89mukJZFWxbJsKbTRUsiQQaOLmdxBEWITt63dw43UeBUgHiRZus8zy+S4D98DTjhZgBXhNdxVyNgQ5AeFtLwTTiPQF+YZdeCNUE77AjfoYrtxjTXCWKLvsijKKVO3oGNEmixVo33mcFXyeJ5JctN8xPtF1+uvRTXXym5il3Qw7ZAL0A9b00qjcWf0Z1vWrM1y7K8xWfd91aLTO9WjjOipnV4U02NkuZUMSN4fELjjX7rOaZ1UtgBLaJgtNtN/LvO890esxIJrKx6domF/c5eh7Lx7ysA5pXmXhnjyvkK0So7+smiQnEKVxR43egp0s9L8vlkeiWwlVYKbv/woePSiXT5zA5NmJVg13bN5i5zf2wRF0qgE74bmcBbZbPMAPFlVPsCyGW5tEgxT8ukPrA3KPqUQu133r1J+wy7lvdUjv8WVQilmXj2tFivjV0OK+w8s/IUTRxrBVqBjTvFsqlaKyZRxql7qdU7xqsqkUpK9vItVZQTXDERxahdMTpXCIRDJxNiUsA4CvjpmD81LfTg5T5AT7+RAjVhGIJW/XN1F8KG4kHE8VtFM44zYJngN8vDmuA8hNd30ouaNM8b5SBIbtgARigocHEKkemK540PEpPLtbBRkm5AOIbx1oCQUC2zWmURp8mKPBcKsHqYxvAhZIAi7TU4ID3ZUtNpXSEVsgH/i4Au/e9LQO8uwV4bzwPiCEQaFCeCUh5Ly+/G33GsXvq2VtNLMapT70fvoMQvh2My1wOfZ9EcJC+5CUzE+YB4hJlsp7aodztvBlrU4Th4zJicYNMOjfEsgfGluYpuWmee0chD7sPmtNzKGDBO/mdQj6CoFLY9b6crR0xyX0rzn1lE+1oMBi5aVHcf/b38PAmn+trL3fN812uZ2dKyHpgM21Tsf0Bmi5p02LzdwS2nIKPoalX9SPOFNfW5/HEMCIMKkLpijHvBcK4Tm3BH8AUFh96jQX74ZkLGI2h1bt1pjsF4k643WqBcqYJI1x4mg0ioJHg9WNdFt8ykK3EMw3gfo58QxlvWG09It+2JTvdwgFhLhP7a251JT3MFgfIxodG0Xi0LCTNsFf6EOms1Z1ejmDAMm/HOsyGBx1S+Zy4qoOtei5yZk4s7cerrZWzixoU/CfETVwadbm0ksxkhdz5skOWzTk7NaKVaiatSPu8xQE+W2emFMw1CpbbEuG80kyf0DHK0ZQiQSPNeBCVUo/PwMivsmVAYqbZ5wISPysCUnzDgNkmIG+K3a1US9Zc0Kp7i98lZ7Tj39MRHgc+y/IppbZdcM8+zun97Xko/h8Tld5uj9QMX1wS6SaF2qzjirdFow503irDbkMVDUYcH8VyxBsQdIhL4ItJbhqB4Ru5HEukLXKNyYNBZ7Zf1oXS0XkP2ZoKmL2EHD7xncT+cBp1VL+YWtQbInptRUc+2N+DbEmVgOgj4tDC5XWJnqAkyW7TrraAQgF5cGdHN7NUQ51BtG21O1U6CY19EaRaSM39jptmuhyvwFadBXw4N+uSwJBfQUsW2bd1RKv9jUjbHDQdef9yvQS2n03tDR56rlLl/7F5XMiESLUTrOfL0OvvUAGKcp54Bk2mbhyzHpsM78jNgvHcF6KNr/LBrd/G7pC4fxKgCEkv9SZIJsx0D1lLAQK66WlCY214PA3WuyYXgPImcay7epk6ZZiBA9chAe0buCh8TxjDSGuDXYyxIB80dm+RvHTBXw6H4y62bzL0KA7wpbudcgrd+ts1hINDRX19+45swEn/pDHvngWzuxBVOmDgt25o0VZrAQucqeAmqmvCYYCb9BUbtdNXMDiAvH5O0GdI9NhEqrW4WyFVLIlrUKBmC0Cy3AjZesR8bfayPb5kS3MDSdRlBUetCSqdKZyXbTzYo/f3xzzd81zYjgJjXXdOb8AtXRidOm/2q6EU7+E/ZY8O30X2NNLe8jxHDq9t3Q5zxMAzcR0mHdj9iGNx63ZuuYJq4nJEdwaStvIcaxSHeyypPI0BcuH71S4LuqkZ9YqBWXDkwvPP5x6Vncyf9xGp2wW4T4H323QN3ZFdoCQtXYIdHi5Hi6vtq7tmFMTDPpKyV4Sm932545ewijU7yxQnwhOrc2HORVS+DuFuvMU0H++mmxdsHRQK6A/dZPcXmEqw28vO6L5SdVZdLGpuzVMdi0q4m1TWWwaJDwE3G6QxoCFrYy1bxL0JZbhdp/7hWHMl2D9wvWb8+dJ7Co6wR7PM7rkpt72vhS7VdXCwjTcDYd0avcbTrj99ZRk+mzljtGRK7FsVyTWqsom824Gu7MLphHvMn5rAOnAQZmaWcdCBg5PE8DRL6AEy3FEDczyrJvgCLdug8jLuZVod1/TJs/Q9cwZg7n+CliLqCtMT/mlHAXPPWD26lQEpeMLfDO63ERS/osi3eTiMiSUS/OcS7E+63yfWl2wgpjgtSEhcuHHSHtW+4O08/Q3X6mZUlNxIzEfwn6jEu3nxY6om/tKD57udkoUvAYz2gFxCvh7BLzayBWyObrchufMqffLn41qYMJe757V+FEkag/k2m4A/iVDIE4pR+N5+BWpzsU0P6Yq8xET8jVXWaMiMK4jzkAqLWoaP2y1C4fPfuPI3m/cKTQmpGjVvxHaVFsmtfINKgVjVRrLlMmhpApu2rFRE0Le1j7L1Pob9hI+RPspNRa1ndvR8tLMxqRm8DPkMVpFA3RhoH6IVDyvnq5jKETyNRSI3qkpUb3BMmjxw/3Sr4MX0GUEYKHdUtgCzsZNtvRNYuXiyGA6HmCVJPIGNwvSTLtgV3RoiHA6DIrYVJvdivSeec57qorE+Zt+KmhTXrhDnvfVZ/aHFXC7RGRx5NCAOSgObsKAP5zMbiBtYyYUJjMHUubXryIsWq9nI/MH8sijSDq2bLKtnm/qkq7yUTpIQgaN6shvnBM+AYGYx2lZZjr8UYpTfaqfhe7ax7CENXL8P7LQFjsLIK976SFa1mLOC0K+on4TgmIN3Ib83/p1/GQ1828oOc5HZXFJUSuCIAyurz9AmxzdI9TRRnHpDgbflYJhkcrm0w5Vj3xCZizOVnGJJ6p0r+NyeiKddbw76OSRMMIYaRuvteu/WpZDdBXRPZQRYt57eMS5NnI9SZ4aRwHxJf7F4omIMoVqX7yLGomKHZDLLIGsXAeY70z8KmTJNadFVxVGhZLrploEZstfYVbVwYBRgMWuLTEhBRHgH8hHbavoFv8I+5s0qJs04ucgXB/D82gtRCWE2qUaUCX6QFNV7obUPYkZTT69KzFaCPQNV6bIWNkecFWMVot/EhMdbJ07DsSgwxhMeeoMaxUEOg/tyBKvAvbBf2aupmJhgW4CXJadNiQLrauRBEW4OP/5eKSVy2mnpZ6QWogHpiDQ5j7hWNDWhe7Dle7Ix4+CWXKrV/p/Xjlg3lEMZ1bVjEi1hZ2SO36NC/gMU/WtPrpKP6A24brkG4r2brnAMF+BLWUoSq9iKiTaSexT1qDdGo0ncjNrYUHlCaoMB1pRH+xbJzamWGTzWjkMJPSz+dJHpdx3lwo/IwdoAa4MHTEO/20ZQINe2fNsEqlTqkCkumQuIVOe7ENKuZNQe89biUGwYOU8zhpD9x0ESqADNovJWukgXOLnf1E+CfpwdrUVzYJWXtimflW1N0kuwSQc8v9aSyCzPMfkNVirDSi9wGiK/iWcV+mF3eNQfbDTUAd4Mr+s3vwUhYo4JiwDIUD/Pa1vauWNt7RA6sF43NqvLTHcoD/i8w2uLL/4KYlBiYs2y0SA1W2QIxhZ+/i2N70LxT6kOEAQ+ST4Nc6nTxcAE7AP/17gvslxeBbU6YRFf124DtS6cH1OYQbJQoC3oT0KexIZUaHH9sXMylLe9+N7ecy3QQsIWh5hYgkNLqqWJWEUTj5OvlQNdokuk0FPcPesOgGrKHFHh0fkOJoLGzQadqnABa/FHnI4aD9SqqgEj502yPEJaBiqnm4x3FA7/aVMfZg/TKbZFdw+D288AedfG2JNs5LgTEz7DJVdSIRW/k4bwHruF5c+iibLS+bYpqopDbTU/GVj2x6M1Gou6f4MJYlQyOuiWxHRRZK/FIHWFK8oEuuWIT6fLFf0O0RP3H4MeTfnAGkzt9820NIAGchhrCz+PqjAKQZtPt4SLhLxMhTflZDBot42RFMoRr0pj9xNuPMJ1pLFNedrYszJhV13ltJjdj7rJA4K1sZUG/g2oug5zpy4+Wk2ImPO+Z6azeTjK7QZl3CD0Vonqe5gkkMZNKWhCWhAKwUZIgSAQDT0KvdvzbU8sMbKxCvyiUC/Fznu3W3LuNP5Cd4/e5leDlGm4EChgor7EdQLt7j0ErHYGfmPLILEVeQGATYoKParhXO4oNsVBijUMaxNWzSjakSLO6d8bu19N5IdBPeT9OXm5ivC2xrhK5n+akWZWtVeTauLkjrAiEoMY1ssWdFRixAX4bZ5vBv4XOTwO7kyVVTDAqt2LUaRX2i7a9/QGLB7E3Rr1C3NKb6a8T9HdOnw5O9N7lwxHlp4LQx+t89VkVI9C9HAe2R4xDgTDzHJUtfDoh4skNoDCODpxvMEUneGEE0q0h1KK9sTadNdTjIfTNDl515BVTJ3FgGVkQ7OPYnV1BES50s1c1EFPLtuq550q9oyWcsS3MCOPzevmKcOIH8TxfiSpMlmaNpiJj69zaOMhoIq/8xJoF92ihqaoWbTPwXXNk2kn4ZYPK+18Hmf9dAbiymF1WoO38nxFTW+wkijoHrsqqBbV/AUu1yBBgbhIaCiADjU8jYbsaJXmHA2mTY5HwOBxeQSRBdNJ4knWKKDPMfEp87/drLP+C3CzhiNyocJK1PtIOKcgBuIAy3Yj8s1Ls/r3fJT90NvAZ0Ikp3QHu97EbLCxf/Pq5azo46TLNNLpag5YLMU7Dgy3zay3+LNAenVgBpW7azatKhINq/lnDAYOUdXVQ/CmUqNotYffCjarJC2wcbPhjGzLdD1I7495HVIkNzEBU64lieBufJlEU58WEmocSoLNSBjrL/XznwFJFFzMG9HCRQhUAHpkhF7xYt+mbW7kQol8z+1258J1Szs5BpFAx+fP+yA0Po0Mff+FVQQ2vh95eK10xof3ifPOvN+5EJPVpXwtQz7aHCBU+j6HzOGzJf1omlUwwmabWUVKzzhNAe5cRswb22qyNL0FTWRAWxpoPtYbaC17FoebKE5mvsVlYH4HrYi870Znp39GWf6W3AxJpdtzyES6d8TMxIDqm55ZECQPxH0Wdm0jK+cqMT1DuMZHXgoWqFrNRmMUxONqEHJSr6dfMAypDhKtIWWtvk+AZyrdBp7SUZDXRfzXVBrcgATamNKSoaqCUxUXJnJ5tOesQI/CkwjDJgy94Ic821s6bwnBQOycVufMja0uXrxFfLfk8YQU6VsCIJvklK5gGa8MlthDmds7Ci5Kwk4W/6FPrI3OCpB4IVWhWngrQdu1X6v+DlfHwGKM4hlnrCmmvZ9VaETuuukme4UYYhBbGZs4fZSVjSdv5t6idNFGG34l2x5ltZwdQew39ioB/88ehUtGziYG8qvjgUdWFk8RXqJroZWmcOqYMbD8mj2+DwDJKcJCQV9bL4QuwbLxRZZFS6Qzk6RF7xtpZ1LMskZBAO3dMZqfMY3Q/sz34whteThycOiHWdttYfOuEWJc0CUzhHhAoVs24QK90TiqqVgqAJNzXuwM2sTrKLA8uu7Q9Gqd7y5X61KubMKwvPJd1Razxr6j5GhPoFXHTUWJziC11I9RP1mmXNcQNxndu/LjxmH+T3ugVKnGYnhjLkuBr5EQ1Zh7vu8ttnlWtcRuf/sTedWHWLaknwhvus0oCjKq+E0lbfzXga6F/Uk6WWLGDI3+pYYRfIIhfYkt9vDplMiHynbXJaYyV1ZuZTFBIgcNGmfXayg0pSbbftLHZI8NBMB/7z0oZiL401ib57Qw6bDoi8SPb0EMCli2k5ivY4K1XA6TcM3bRTV3lLed85pMHN/4x5MUW681H+3Lf+lT4ZL7UpT76lm5v22a+FQx3P+HPckTk3AhcZ5NhsT+akdbY72b/T2S8offUFmPbr/cXWAgDEuRFp/3OvOhBmGq1XuOHJuOadGg5E8M3ob7hL+WyIS6e4YAhiwpYdQ7BDbWVpu5llD2Tj5gdopcrp+SaQlots4c35sAM2cotvGZI5nP3hRI+vmEqMROi454M1Q+s0MoT1jHIeleOQo7vVrnsxZxX+LayLMo24WM7E4M4aGX2orFXUMkJh+kp76aO/PIl8RgoiHrNR+1gxXjh2VF59aAGl5G+lWg5qsRtMVjXDs23WnlnmwdYYH9rIs2vw8o9PlvvS0nMef5SEMxXnKo7p1V0p/J1VFKPMfcI6xOmtGerhaBSuHXg35G1EpdXn6CuB1Rwp/umbj2I6fLovjSF3SG3mHRTtTe1HsX/3IXt+UOCbH+lGI5ZKInt2LxNG/fUe1VhDsuIoTICQZux/LR100GxD+MRuuUkcDZaPLi27rz6zBqsYJVeduCPlp83jjCG+AYZYVBlWPukre4OdsgkerejZmm721ZmmxS2z5YaIsMc5nlOph1CM3Pvb7o5xyuSGw54HXGtLAHy1fT8mDQwKiJyJuxh2gydPLGpYYZp73KMLjm8h8XbJlfpiESlUnY2SG4wTUs6ZcKs0C1ZkuuaCNXMDMsrwoCv8xpVpZgzNODEnAfT1suqfaxnLFrH03adgWe9ki854Rw4u5qVnBO4ciK2ml4b/kiPKjr0QofYUx3IBzx+7L0yarALMWMwvIAlA+zJ675M6CaCarayhv0YVB0KToggRby5mR2MA+LLmZDATK5uhGj0OU92xRwK4faaqgvdddcLPYiAB6Lqnet/aoVRX4J5cPyeQRf3S8hi/JwNKTt84GC0DTQruYjYfMwboRrCwsMQKb925DHexbALgxqCsRwtwD45LsmeuDcR6O3Qlp05iXG1lyeLhMwpy3vCR7e7JYCtZM+rHSY76Pd/QZOVqcLzepFHBmxTs87QHbGSQ1UfH4FnCE6jcV8M9JF4eA1jQb8Fb8qKUn/PvS9+Ba7ZpV8J6fc4fkccZdq+OGmMTB+nVYv4XEBJ5KOS5dm7Yj5gjahOpjZPSf6MURb0EBR9vyTVi9+xeoap1z+cV+WP3dUow6BNoGwZxM3//b2bZPif7mywtzGmjQ/aJvw4cA5u3JmXZGD43yYCMeanNqeoWBd2at8C/E8R9OZtKSPBcD8AkcakSXLhzGx9bdRN0vdFnco0uEa5f3c+fp471wb2IsmHKKXqHv9tOFFAE3Fp/oZSWvi9O3N4M7WR8DlzBjT6cQs1d4/mleTl7CnSx5ZYlsIVwr+d+yWq6f3kkhAbCnSVN3vJptHPryjv0flMHmvA7HSvmJ4lT+wX4L1+nwZPdj0xcsmcG7APA9ldPHCRNfSjHcy6O+9n39gcK/u8pCMqsR1OOXMNVJh+LLMi3JLp6TKTgAfnQ2e5Ze9AVOMvsyq60HBUzpszTogIw3joi+ou9oPEJVB5XOYm8ZN86HLRKJGGnj9lMwdf7KpA2kQMoBliYHZg+zoyOE6NICp8e6XYSvm1YcKw6HewUNLaEaLM9Zb1omxXv5zHKB1YDYPfVWRxqNdrmWXEEZmHzYmZmydj1/ALJ4HytwCHm5dvoKeEflQGYrHcUut4zwlRZhnhVJtsdOEZf0pEG24SKGCUcpyZYa1oYSNtdfB6jB43mi4/xG6aSZ7Jhm2v1XloY1V8lHzXuHohe+DYaz8nbBcC9AaWeuqSU+IZYPUcYUgT+jtEZsj8udq/yM3iaqLA80uSk+/NFg+GJs2sO4jgYS9PWFQ/0jHl8M0cSoCqaLyay8u73CiZv7CUOROuL5A1iR+EQep1vTARPCIRjWpvMfVmep3u4TZJhakSadptlK+mPwwAxo0jRDRyt3sxxqj4pLUcdwKmdMm4v96W9M/QTOkHcFTFfJcfutoV33yCntrTObMGNofMN7Zl3kTTtPT9Xnz8KYhsdfMozIjFiaiV9tJzHOjDJetUeGlABhiLdlNl7tkO9r2cTAcRZTg6QL4HWGfa1CKMrEz8chClyYMo5fO+yMNBpam8bUsRjhA836oSrmHFnbjvqtN24FzFBwBcO+XhYeykUMAXQwraJHXeNYlqpqs6BDGJKG6+1lkCd2948u6u3cjQ/3MJSG+V6rLFsFMgtFYeTBhqKGJFuTo3t8+RnedF0eIwq9oCjaRgY0pMN+bhMYWc+R3gqKe3ZuewtsfKMEzCDUgo1keS3rezgXlE0vVpWUDiEsGtIJV1ubfkvn0J7hV8DTu7Cp7TGRlPbLMV8V5hJ38UwYpMYtEYXVd0d0XAY4etH1RgpXekxGUhNuEzz5aACSWvDe8fuJPX15rTtDHT3u2Hih9PikLf4TY787aDXuro3TNOQ2Fgqvi90RQ5YinIw/TP8zGrK3KIa9U4oEdnr9cHG1Q8syfvecgDUkYMxZfsDExf0gWHQW/zEv/idKjl2SHAyIiWKl0oLRN4xkygzT5qpGNK9TdITJJyojlVTPZ/Ree19siCF6bnn7lyetN7lyX+Rb5s6BMrwGxcVj42VWenz7YWu0JFb/QjnkA6aO0dz4CH7L8JpzLv8tHqKfk1+XtPB8hfl2MmKhZt287N6mu83z66OhBZXpAvjAD47ecPjlWOx8TVlpQ6pthtjIt1ksYWNI8ANBsYmJg6XK/SvDc/LQpTTIj+0SskW5vFK7VmFQHqdjAnqckaGSxz+dURJXddWvRHizbs4mQRqMn9VkK/boRCdfsIYxW62kTR2Z+SGEuV1eC2YTxJtPxWWb2f6JP+apAboeDXRTrLMwYliTBNwaQ8QQNgyCI8hOiBMo+oNWKIgQjuCqwyvaBmU91LUhrhoHf4IBXxIrqVjI6O2EaBUcVfZR85gOWA1r2mkC0J8hIGAECiiWzJIhs4xVcX5UvJHuGgnmstPepUDkohsdDNyi3YK15rjuRRqR3I+OE5035ipVprouzCugoMN0S80JBfOVkEp5FiTo2Zvt3c8PxNDWD62UtewrzblIVdbtJSjwM7oReeH6G0wFTqGll0p6rx091ThQoe3BfNPNF15VytrqU9Iu/YL6eAdjWwT3DsyghldZzndbg974sT4l3+U5w1wqx5UFN9CtK/RdCLT3Zc74R3njc1+iZR89QHrsLtFy9lnP87rZpVIZt9/QD2Dtv5JYeT85rSmMzZ2/lOWoReKXuDOYSypcLo9R/qgTsA1uk8GQ1v4wxJoPel4lnWry+FuJMuwzpeJ/qrnrZ5oqsM5HFAZIqHIIjGxuTxU+/MGmmbxrszH7kjCBhkSMpnNHL/fjPWFDQwjx3yH7X2/Bl7mbH2sxiIPuGpm5Egd6gegyimsO7RkmIeuXRFdSMArHNV7LABNuQZzSeORlCUxJZBn+2uJWA9vPq6iFMg+PcDtOeBfky0xHgz0K8B4hPhXgIqSP6DPg3CCCVgFwzBxk8NFXNUGa8kkvmAIWH26nWbOktNXG8P/CjYDpsedNBJQdr/eM0Garf3T56H52r42ZDCuaMh2LgqhhlyJp7Fx46gP6xjtV76E1TjOp2uM8mci+9NcGyWsjcxwdE6vFt2wyRayZZ+Ba6sponJYFjBGsqIFWTqLrjHfu5VCBZMr2dbe7BjveXG1fB3mz4+VrcGrTNTVqweanUNxiyReKo6uZJHqdtCzoEycM2/lt4bBs6uMS6RMR3XzC+VxxcdrZsgomh2iayX8VysKuocdJFO3amydqXmmsFY2lleMKwMe0rNGoiZGHX8gBkNhB96Iy7+J7UWlNvC2RHk7rkr1FMPF7XkkCT00yOQEzfE05k3SRiVKkN4Q4+0OIFKIMJUaihdDM5WR4fpY9WkutgqmTa5eUsnrw9un4f3n+ePm13Bz0QUpXjxNrGearIFufLNZx+uRnSqGAcrnnz/v124zPL3BuuISr43uZd2fHxZzgwg0mwKXMM/xFvxOW3myeDIvmiLIuVu+j7ng4i9Z2jJFrM9mAjkUjLHQnh0dmihl9MI0lCgsXPsicYGY+AmYj5AQHyKuKJylx0Nfp55Aw2LIAbliuq9LOg5rrBc/khTyUI1w6VOXT0qSKMjBQcDPwZITP5VFbMke08ixzEYEPoJr71B+HP+CE4pSUWlWc1mxcZJXxL5ckwXJVCVgCZuQTz6pc+extdKg08bM/+mvdcnCrza2PjOCR/NE4iY7JF/GIDqRHVJGcQv6eILaf6qV3ly3SsuLFjHGykdncal3rvqtmMKOnl4RkupJX2LLSoINN+e9WcC+s2cp8Vf+kRqYkvBSOWUI7WkSK9ADt0pgak03OjpqI1iabRVI/BphcnZJIr4t/ra+rpUzCf/mzbQNwSbMcIvvELkxYUZZZCqdwoSaAXjyY+n98U9IL29CaZOcDMlmfLOu0Wr1ZMx4VkcCcTK/XRrzlFe0znvoBMslifhTH6unGlOMZCLJMwelHXyI8jhkbH7dUIlK8Go9Z0PzdcvSNpIeTBw1ZKA7gOUTNyriT1p2aphI+SLE20FXRgZYA6eV+VL/uDxephYWg0XpMjGVC0l/mHRaWLAlpHRtdvOWrvB8BunU2+3cKVOaqAq2JFRT8Bxd3G8wD7O3dys0DvRjPRYvGYedPpKs3PUxD3GA1mLU3+Ges6NfvZizVbgvqxSF8bHOB3jKh1nR3bfkpIeMtMJmlYgNIEugJQktWpUzTc3QxgBOg8nVp1n8mzPwfbXO3X+UaaUuTUTHntg0h0WJjN/KPIb9W4Yif1E6h+JdQAFs1Y8dcxCE2SortrVRV4Lie0SwGxgCmQlqLOGpP5dWQNCxz364OKStQwKayYvLIBURKRnAP+gcCOp1RFAxwQaxUIVZnvgcagNuZBtbWZhxvB404Gex3HKsGXEY03i1NqmRbOosiTYPBdRP7DzeASjdvbkNbJm2GdFl6Q+FJVwrwpTJbukmJSjCYdA+S2k/pQGgfmXRLdRnbCivS6Jn8LOhWAY7JxyktTxeIAN184LY1QWxRbhiHurysBRA+2Sv4fff37W5N/PZYtA19lvHALnP0sZJQ63iGhTfZ6f0C2793Zg7rbpDGE7h6V8+px1OlllrSGMoZZD/aB1JB+5f60qWOQD+9Ln4B34sBknVbahujVck638pIdMn9083sEEH2WDRHGnkUkj33jftyOI7EYPptTGQdrkvO8CNBbt8qs85s3UmZLxxtzdkPVDBYnR4bzvPIXRTid3gS2r6cuTeEZSjf8rzQ1otqVEhAslcS8DFLXUqcwXT8XBfWblQir5PtCxoYjhj1B3HPPhkYIQaZ8rgnTyIWBHaPjPgtqd+Y9kdigOhgTZGPqLgvAxOlA5fy311NnqlVF+++9Dz1ON10pR3uQnKMr8RHwoMx6ogc/cCA1VxvqLTYj0SRAHYAEBLSTypKbeEP5SpyaVujHrLJyaRLoVKsCIEzpXBYwgWc5x/cpzGTuWSiF1b54zfJzcykwuWITwlrkZ1jRg+jpWAhuAFar/5CfwcSROfmcc+xZ5VGL1pouTz2Xnx55quMYskoSztRMOQiIhWPjlZ+Nw/Rtuxn+mmQvEeJq3Ptp7GhjgqDacJYvKekCQfGFu4VBu+o9vDDJTRg1jOcI6HFjzq21wE5l8jUpKI4AgA3/v36CO/+qL5+iGXXgU6e5J9LzOwLW+jCpD8YZSKcMfFTqD8mH8pA8KBnaas9Kx9Z+iRyRk2TlsxbvcW3s9K1VxNFjMN+fnRZNU/jjTb6oo1jMsJuzTdSD7cpfEWRzg+BsxoZvhtMpEz2pkkKSQyCjOlBXxVSI2zqGLtJrpAmgAzQI7A4DUfYqs1soJ4CMO3pFTWJCMlPVuCwxT6hCPG0Snft2VVpbzNYpQa/agMw0TyF6OYz19ZxavbQ3e5QwV2+bhSF3N/qqKdmM969jES3JyJNV5QwLz0pMfAqzcYPQ8Q77Fbmyl9WaccfFrmFG6PkwreOZWGcZ/g/dXYaoqkhwOn2PNVndGEIecx7g6RWBGTV8brBiEZpg0VA4inxNzKXpv/vYrKgPaGrUwGBsXtKjr9yHIbIXdxGswfttIaARgqyU1Nx2043BsaKnGkKPt1vHf3IDuhPbkIVkHcyVIDXUUPndsHolGfLEHuFG4m6ZSRTdyxKZnsRXo66J2hbpA5KHaVi19jDEF0anFGA8TYxPufoz18R3VAG9mLxDw4/rLdWbzFZhohco62sCoUkNGqcmhELcHRrDJmjozc05ytt5+j9z6K56uNKmnNY7FDjiu+ehwq3QgCG+SPtUIjH78YE6kSxfcmcWeSqQdvsuCXuk69XU/neQX4YHpDhoBIJ6bPf+kmoQ/6bqZ4nvuWezx5DXLBMUCf85sokZGIQXAz4hH5V0yhchbYdBoVXglH7jP8AiN5760xfk3keY25nGlyiuDqzMGx8VJuGsivpPt6RZrIaCAF75bBN2Og/IOPPes8PmVj7ndh6h3eYdFbCB3BI3zwPbq01CVekFqoTm2kZuUtTbm9oVI7eV5PPOp6zt/rzRkwYreCTRSGUQym9WV5Vr3mQfmbEHljGW4LWmTrJORWL0S2TvsnjM4FDsv8JOu972epUvD8jLi5eav9v+JuyRaEod3C/enBwzdZNni8EhHp0LXYrqwMuV685yT0v57+REnGwHaAHqvOzb+DTSMrA4W2AGvLEpzSQbREjILXMf95D83QG0M0wIe1/0Tpk9HadXT8eZj76gxubWpOaJX2xeMWgMe/psxIDkJrf7dmeMv/veAYxGdUPWkyQBYdvOhu3ZCJcCFSvC/RjiV2+aNubYi2Gx1KhpdG/jqu5pgqeEcWqXayGMc5foNe8llCk3jmQ60bGVGWxQgPl5LX/5yGJp3Nx35Cfy1ByG1mDe8xK3PBFGKBbk06wFPh0CeZxN3c+kGdyXlkyOs1fjEuApwOpFA0cxN0ElwNoyGkjUzYzLKOAOcF2agPrx+mBKv+FTSWDYgnda+NlAyeu3hAil0CB/ZmpVcmgw3Jsq1F7nPcTu3KAxDyNfAATvt7QLGPOAJAIFklsDIYsEr/gJ9rdIIRjAdAauPA4A5I+G4BpWsbtMNuggPSKMPk1ofNlbZ+4bkF4hWRimHUhJhsCiu5dJ+JwDG3H68/v93VIbZy0ylzimjdx4/NYzHtg6XIZnhcoDJMhGK2qh1Sn1NvZk8sItkyF3N/QN9hXEPoZbf48LzPMMx+3XEUgK8xPC+sVpdB/haKwKPq4K/T2dxBPlSSjSKaQyjt7ngozr/oAPj0stMMyG88bNyiqHmSNn1vMLVY2UqmbStxn+3tprv/bGNeBaEwqNvymmWi/hS5OVeoiT1u0eHx4xtnKSc2CTb+TXGr1JwCbQD12rSaOyF+xiyxec9/8/PKNQILSZ4eU7PRu6Vt/oAFuHK27QO9OOgv0tMI0Q17ARDqEyZqH8AB2jbFF7Kharuj987w78W+q5h+Z0cvekDXg11Am5nWyFSJHRQ3NGM5Asm+KETphW2u+hl+IXla0xmYmU3f2KqDEDgIAjB/SVVXnZ4TUO+jtKh1/K3B+6ZKy08Babh5zsiffPPTmVBZ1SP1P+kW0aWOdyU09Ak8M+ETL+aitLi13BWzZblnMSldYM5je8cQHd+aO72Ikpl0ynvlVVxGl4ANb+qGC7EVD1PVBxCSLaKgaBtw4cW5vbFDTsYh0mgEKMSeLhYxrMC3sDOhGR2XHrsx5pyNW1UCmliZzcvqRI9XFA39U3JYL6tWsCJEIuoXxi0YsoMhrUw6Hyl9iWcF4jsEOqGKLe/sTJB8hRHroVAWSgVQL0t6g71TyiWNSOmcmkBQEOcPQ+4fsEB/RgWtlTHKPuov32COM+YkepiL8EaxnfaHJmp1jEVNLpJc1Tz8BcnhOCpwf++5Ojxsyootsjjle8vyjGdbG6sf6x2TyNwNfYEtF8433O4BjELOozEINtzRAAhjc4IBWZilu6I98lIwV93ov3lvkNe5e2+Hc+YdEJWAeAu8rA4IJqoUDcPMz0JITBwIcq2pcVzPcptF/6ymS5652GyvUXwvWH5yNH8+B6xhHRn+Lss7mzG7K5ZgLMM1nUqDkZHLJNmRQJ/S86Fg7waHPZCeHg9XoVJNJKRup6B6HG/knRw8jQ6Im2B55ww2G2R+jVXEyox2A/RMgT6mY8u+OACHHsYfJ+da1hXkzosf6SMVE8yfG0C7PmcgxopzQLqcZj/Y2VhDoFnr8NZh3giUO09NwZOKuLqveES4xxwntCZoaMBs7iDlPPMlP0etr8wHJnq13P10o6W+2oxTz7As7CbF7K6dQu4dfWa9PIkXC4DZvF5BQ49/wtlBFOw5kbxFEI75YNbiet5a37Ipgqh+nEEfJI06Z6K6MohYhXa+RCZvzzFK1R0DVevJhImTsYHaazreJEWExDgPv0Sq0JeaM1kfOBC/633VgNiR6Xo3pW6ZuK+9Ax/9RROzVTi9+ZZ3Cekq2zcJCCalukPskMvGBKSj8beKdPeyEjWDRjV18W+VovqkMu36XJJokk70CLHK0WPhLMFZpE942RxzzmLDwLEzLADivp7lRUmym5FoEd1jXALrv+/LSbiiRx/M5YVQlpLkvxhzXZyhyCoedxnR4pd/eQLckXJfAQvC3sUWnklhgEkiENmttql2wEBLewX9NvgcKVFD04N4UgxGQQ03ch1fmy8D16+j6o4yDghE/V5aceQCMFM7myDtNjimKC6fvmx36hEgt54bmY9er5q0HPT3QcW+fYdYFH5/SBaUd2EL+WShtPCrQtii6PTHLeP3BEQXyEcaiKJYxEVVh17Qj/Z8kk4OuDoMTUtrPt4wZUXpz6xxwl9jfPf3LtMUyGGRYbca/AkcSXW7CeDK+UZJins+MpJeCsotcLYnqZu4WAxxy8Bna0hi8re7F7p5sgD+UAN4oW2Iplg6uZGhUvPiuZZHbCanSiAdthukYMapi/psL1yeUTeSDdpSJZ809wFxLZqbKMzAe5ihxrtZMICb0vfP+P9QmcuDRidWQeSbbJhJneYJR4NVy80/tL+b5qqgv1ZLuVFaJ4+V0lH63Ri05KPoWr0gjLnQ1oi/jcFmCiedZE5XIasbdrfONKYvkNATXF6603uNnwQWHAY8rpjLINECbGNke9uUsCQb+D7Htkc8FIuyEITiVbc37FXKvPnmzo6mM0v8CKGge022vUvDGNrjVcaTHZpNyLuno+HV1jxnGsgN4CmXpRyIFVmrM4q3qsyoBZDy4VfPUcZVKdva73QE3C2wS0iiIGO7uCHVVTp3TCGtq/4NSYZjNMn840WSuwCs4MVI1vCi9rTAKcpvMxOofc+SolvHe1j6C0Tf6Deeus0Hwy+5R+PR1kL5wiDb3giieCEj2EttWCZczeoRJfKFLEFY0lf1g9i4AQ+UT9bXVD0FnJ3GLn3SD3iSsnrkGhkWkE/G5XX9t9VncIkgA+V7v9LPbNr9TYMV0yYeJjFoExaxPLliVgfXoyPNuHpoPulL2LvcqmFDA9aq6No5RSAfTRbn4j1OPPm+PH7EV2QOZf6KxWXwOyKlztf/9vUhrYtTxMuaAwh1BafzA8U7jh15W35bklNWYK9gFdum6ZmN+rbc+DwY5XkSOdfRsY1PZpa/7YPWIK8mEP2xJo58+6Fu1jIYUslFYKCmf6zYjMioNfWyo4FGNWmliDOb0JmmuABNow7lZknDo4r40PpFaD7AsDuxb5u6Ihx4w7VVidnXrkbN+Y215Qr65X7IBUq1G+coUH9DxhAx4vSrl3HJFFr9D33ur9k3Me800w8aWRNHJr83HlO+zxFgEbQqqkSuo7SQVsh0AL+PNA2Dodin9APKOdyhqHIjf/SKRlmaoxzzeSzF4y1G3cmpUhYoPuqr92wer+iGwGzGLrX6Rso+hl1KB20sWT/+xtCUjvRLvroWEz5BRaYSjeJgqTNbN+kFrOyReOu01pbmKifo9+CcM5s9gkHdOEhLEoAIby2pxBCSENGYmWACSTAKSLLulqZiJyNooncdYyB6vIWySIGJwRz741Ax88v7cmg+LLRGnYjqbyKBHBMcHclBUqMbDeT6TowcHkfXZjVCfWPy0KQkR07DevFur1eFb+ZOTI4ecI4HLKZb+zhWW+6qG9X/WtkoZdh+KmTe3bn+XPWb4/RRzICMmT4k45IYckEUdHoyTGgvp61dMy+L3EJ6d+eFfChR0Y/Tq+Tt54ssj7s4x0bB5NlR2MkdbPqXK11bw6OtRUdbPt3wx+3IYYmj1H6rpqIZVwCv7LkktLAkR/hh3CNH0r/nHRS+PeLWK/9ebGcsRJ2FlFAcnDD0sKu0YyvUyQgJkiETto1gbcAgw7P2xSE+kO1k8MY4UuFkerbpGFD6G7NNlDN7E7hU58sh+br0sMPKWemfiak+JCk32B37xCXnYGIBfk2g0UD0g1dy7kzSPCB65h1SxfPJQr1pjF/CJTPmmEv70CQ0xhnmMUilmyb3HQQBJ5KRQZCfLRK5fm2VsSPF6l7TmH/CBsDivw8N0r1sMUnqy+O6X5ZZ8zJ5domIQIVhtq+r1U9+e5vI3qNrEIZ2BS6VkXdm9zXhNrzZRm1ZAT1tAf6uwjy8TpaFbT2D3gPAaqw8Ok3U0hMJ2MiRSx5nf0kLCovWAiZCKUehlBiJUSMlVxW4Fn14CdAxaBy7pgUOaFa8YLfyYUijxg3a5dMjRn5lz3woBcwn3xuFlvj8LYxhx9touX/TSdqDgZdvI+OHjhc8aVGRz86RulBocOGTXnHdn5GIQLyMb0K4izxtDiu523v3cYBAs+m3CmS6iNSDUs9bTMGXF8nUT+ayaCoVO7o7KIkb4goPmxb5FKt5trlEwu3umEDh7MMDR3DGjgbx/MuQMsFl7781yqaoXIQp3nX4KJUdR1ZFlOg6z+1yoScDN2+buc0jK/9cBamLC+iZih2Nr3CP4MKI/LPDPLRhaKSnUTd1KJ8/CAeHkVt5IMnKRnbM6qNQvOaxZoacswBa8QLjS95UaUfwiNZ3A7+uMUVwtDJx+ekjUPcz+T16hPSnhT16VnRUjK2JHBzWAF6EgybCXV+sDR0dC7+7Ay8nkSVdEKwxFZWXbqA/AYUkSC9ZfjpIbYBttGo0NnL2xvJsCd+hAQFruo2WGUv5xPflShPKdUeQmXXjHrg2MW+VERgNsV8Zh0+leUU70tWqU/yLst3N2d18KA2sQ753XpaohjDuYe8KrlJrqBFPvKtQRapSLS9djvyvtfPt/J5vE4rYOPJZHIV1waKAVaYiDBLksfQ+m4S0dJzOfEvFyYPu4ziAXfiS4M4A2z2DpVkIu7plnk6r/lmMWryujIpYtlSjF/Bba7eMyxdrP0wQm7xxDFmLTSa+8fHOFVZucBjNzJxHcg2SBBZqo6SWcUq519151ia5rtya2S0HWWR58cQELv90iLKIB6riGN2FsVlDK6NDr63I4+VOvGBa+uVuJsCVeeIpqoX1yVmJR1UQw8V4gHwC6QbukUpVJGtIL3TuS+d925prZ9/A3LCVsDJdgqwrVJ5c6dxjHtbEqg3nsyKX0/DwtZ4R8P7N03nE9Lemda9ferQOvqNYXY3PUwCjII+J9WrIn8jHq4dZWP+01IdnaJsOVK31ffMPjerlR/T0x2JiknI+riaM87zhTNI7RZtKRZ5YvBuf87cVYfez+DtgTd4socxyCFEdATjNCIB6IYr9fifVBVRfEAHMgWMRmF3hXwxAR7BtNdUP4Y2VdY19TVnFmHkoUHVqv2jRwocg0bHiaPNK/eRw974NSAY7BSsQ2Fisi7GaeTZBnN7HPmm+AeZdtY/Mr0oxukAxHs4MMd6EE34QC+ww3KPH9dAAbmC63h0lmDNxaCh1QGUll5Gcgn4+/Gma0ZgLmReGHcL/OpugJ854I0bHv3yyWV1rnkQM9XJF9I/fko83IvK/yW0pB1eTvT+4sO7p4Pg1UVzliLVfh3n6Bu10nVNGBr4sgND5+yaF6G+lAdIOwTky8zHukfqryLLr8VA/8s5ugjy6y2YvQ/xPA7f+nhDKrXP4MithaiLnN+frzl3ABQcqnplDIVA1LGxNjX+w8m4w27AVEM0wk3WRNpi2OHw8ZghQ9Gzuad8cr30GhRJbAf3B3gocTiGx/6H7kXfdV7CmIp7NaOan4j1nVyuPDWlUdGn1b4pwfQ9fz7XnGQdQcdznewWjYJzfGlCJ/dWbIz0CTI8SMbgfvzynj3kasD1WcYFs0s/pLlt2jgnpsGMfkOBWDynnVznLwgdoA1hYw6rrtj+EUNZBEfcbEhrFNvyebMaETvPVqtLaVlAtlyKxerbRy3yfkaLNk2Aa/rOG3JXhEXxDiWTFmTSr3KRiF17cpD90CyXAv/xp9xkM/XFR/6X11Izue6cy85V0v9jk7e1uaKGDLOgtcwtcNajaZznrmJBw4CWfmAF5Q49JZP7GKIKKryPqT+OQIkSFXxIgNwtYx4KRGirp4RCJTfwP90WZmbiyrWbLbc7HmEsuieMv1G4SO1cnb0BBYFgfu7C1AzT2n6Uxm7PV3QyH+BOSfoaScFAd3Caw8eo4eFTA8jqvKR4WIvLsHhHC8B62g5HFhiVzfjnR4zK0qw/5ZaOmv9fhkqARUZ6B7JOhVhlhfaCAvfMNWAxCFalaVnCFGr5VlcylKbdoKNGcUsfBVu7Wk5roPfYh80wPWCZxj71qmOC0TaRhw0cu4imMCXmok0u9APThXw+vJHqshOj+bX5/dfIn/vwE4JhghqqLHmPe45pikT6RkyJBK1IqV43t1atKMJSIM0+Eg8qJywbqDcUvsBQeLTeI+zJVUTcFqm2kYvLW6aDkj/z3Kd11Lau/NfL7h8Ira/KwetuWebpDfOvKc7OMbAy9AVOqWrvVmIKwa+PnVSsfra8tvuaZQi9W70TCECUVfjFSTCCX72s/7TdBRPhmeACPZQ90Zj30NMhVlMuEBtr6CDKwGhNAj8DO2RNMzeBvc8N7YoW187mmHvfVpyOLdhCWuY9UvogTFsBdnH1SCVDaKkpJ60d4NBB55AvqPk/+tvsuRm6/K69WWRILYVvR5dbvXnXOQGhQeF6nf6kkWQEtYxRL0KpLfMcUKX6whM6hhbsKdSmWmNp9BoQWGHzdbkPaf8iLj6dnmGZExs9M80EbREnDHO78KfY7Jy5OLMQv2Cbgpx/goG7E7Cf6osOgs1YRfsCm1XerYb5lLMnUP/bopwvMI261qnvRU69oilBiJYmKYHGgiE0wJEla5HGmc9vW4TxJmbr0QNEP4yjNDFRk28GJfN6Q7S7m4QECoDkp4aqaYPhlFCPDXHZbqYb8wo5mpmwMJZ2T6stq1Rb3eUJULWLgA1h+arXAyQSWp2RmC4mnHGSjbijHLWZT2PVLwdI2i4dagcVUSkWEAPyke6OjN7Jxkz/Xk/0T+LluVJnH8Gi1OeGLNdk8sJqpuML/EOj4uMzdtY61lNUJYlrBquag6D8Z6N0DSpavPjcolQAgUZjwaEToKDQXrUMUsFTJcGm29ymx4pIxlpoZuWFdOGisPqAnr/3dVPLNSmAOyaJwSJCjbOYDVajIMa8BrXzbsMd/pcMZMBaQGI+QOP4qw1SdMUxNOxSXQOJp7LoAGTz9CGxTizaoj1WmRGxPj+go5FrB0KOfv8pAObVK5JC2oaN7jkDR58Q4gh6+bp/ipu1GzHnr0/14P8hoCdpAwAAke98ogLVh/DWiAVSE/+ONXZ6MEbRatyNJZ9rcJ5DTQImaeYLyUpVcF0Owgg3Ip/hiSt03Haco/z8ev9ZDMklo/YWSe3otAnFMcV1dnO3Yl96wcPaOaZh6QqKPaEkwitxNaACOh44FTy4RGcTzLIXUem8Ha+HnlQHy/dRwsM7r9SWoRr3GYZA0eGqiAXS+JoEBqmL+KfvPHYfpoHaESrn6AeA7tsT22gAljEd6QKnqGq2o40bO/QX8TF5d106q25gDk+E94LH0xEN5Z0IRL4iyZhd2PM+CfnL3sY1pSWXxI10gQxRVkuYB2f0B6ndFAtz8i/8/S+imYCvOrA7gwNCOTI15gEj3K6ooyR6IP//GO5jgeThSLeZjqTbJkbe5q4c29KPLbWeb2meqKhofKuIDFC2bL8DUf3JI6Cp1LK42Z1HRgoC5eITpNK7m0TjkahLC/J9wgFooD6v2K/j0d01jC6d09NSXTHc/MvwdKrPK8o9mC4FSdiH0eQor2b7gMFclAgpVp3TekSOVljNXhnN+fUBrbs7HSiOnx47t11/ofL0uy2bQVsgBsPFspvXG9NShbNrwEEOl9iHShMwSMlpaRumVTpJ/fH+WYCzAW1bfRoqkB7AwrHpc9hWggfXEualW2XfKr4q5Pv2sof/4Sf/WW8tmcAn55IIc8zh7ggxf9g4YpsSMhp2hSwtadJSaQcKJLhDYGbX7tpRe0Xf5DBY2bGRAd2lRc8Fhe45DaL8wGHZJ7MUZMtqk0AH7u0tUQF/DOHMjw4xLoMrWN9n6RlqMNdez7qVdols+lDvQC2XnCJkHtUVK7tCAvrBVfRJeQQJaWdIdYGvgoKhze1haEsWN8wGE+hwZsC4dyYmu3rUCm2mudfL0fiVWJjDHhNFCjCPfhpjilS5nX8EhkB54hTH8NuouX3+Z/IvoYjwkG8kCAS3Ds/cj/zMWKiXsytIxHz2iC+x6330uPc2ngj7ifBTkpwYbDoC9DbQsLFHO+xI3eEq/Or3SZy/mxIWORcrqyZmD+5ygFKGW0gKMCplXARyUaEnqyYiVujP9BsRcUPJ+xbCLvlXNCAnBY3DepEgCysA7ZEl7SVaLHo6DMmdnL5WO5QUQ9e/U9r6gMHmFEr6NPSnY+nAVUCQ16RYlZofUnfCPbMyrkThAaYhbITSNGEzcLkP3XZlhF8j75l8af4WxqI1ParVC7jgtJc18mtmfK9d4smiiGYxMqup+/A4i1/6ic1V0hYWBKw+v2NjTH/gQzi+HzanuhR2tKnsBhYqHuMJGIC21oAo7Ref1g3u9l1IUkOXFLMOMbb9KP5WAYGcSTnFKWFbdjwK+EciOMRThnU67oJN1aZ6wpuPlKOX99ZdH/rOCzpfHlfqrUWxesJBGF1O+EaK8V1RpPgtYXe5+xbywKZvCysN7/G1/ovN5SBuGsS1xhN/srIesRiBFugOacLNqc5lpULHWIlWyvV5Ih+UboFhic1Ho+RIhaMAhFAdO2aaKUeZRkx/WD16+rfU2gdQEnVYtMdTd3tfnEaBm3k0MuMdF91JfKz5Mnlr9A/kWMBI3ki4daVaTpuOo7eWU8o3ZRGHrWGHLHs4gB20kFVyfJdrM+kyJzgQlvH2NmkcpA59drTA1wKuxab2e96R45sRK2dWj/nvr4w8+LOOdjzIrGyt7uKSzTa1coL+uSOqQ/njMfh6JM/gwXjG+e+xXcibAfzS+tGT9YQ0Vqpx/Gt8dLbLVnz8UejX+hzwNCDRdPCyW7ew6LPdjFlUN+9Kv06DTYTg8LPRqJFI9nKst6Bp1lXIGdDI/S7GjhvtdfESToRNf0XnyRavYz45RyvKq8vJjcZrTOXodKJFP0AAMd3x9F1O1mc4PB169suyEruXejg4rBgUGQ8KuaL8F7llzMn5/XRJRe06RjDG0m4Vgwm2Styklntm+g+5q/r9JyWm/z/GKkuWvyQ7m9nC+JujkwhEUUcNivtqeUpXAsbLAi6T3t1b+BuuC5/7s9PWtv2VrbeE/BnjAKcDdHVq8iPpw7EnFXpJd5EbMUMqILidlxee8IcCMKjNYe+ylg96QTA99X4+AHVujz/a2nSpNr1xMOLUZs3P3I9DHBF7wrG5lttZhF6Uqsq6wyI+dUa4G2/13hc0xVRTzJUX1vfQBaW0ZPa++ld1mrXPBN6Bm5LKLpqurFISZEt2GICikHgt4ScOGlSGJ9kR6F8lK3LvaR7+/ZjiJ+q8DEtwujmVQk+61/O8lkNskhFFlgELYqjZ2k/g8s9EiHxY4ZGAXW2Nq21EfzhEWP2EJj6EBePMGXU3W/GBelXk4kc7ETtHTLBE+OD+xgt3YRMO/ddb46EfrzrtfNdwO2jj4uEN4YIdDjSoVypTtduaVMw4IUWYS3IJiMkGmjys7FXCc6bAE3tpG3USEkQlcBjyZm2uXyudCeBItHxT1uKVLfPEW/OFgSkI8hbYZqmylQHcoqM+RYwVHA/fGnN6KcQCtJezV4EnGzrXlUKMLA7JtMp1c0BhvGCwj/vo5DckQd1BzSh0dRQ3WQA/ulH96epZJUFnKtzyZMonOPqFdMKlzTWipYdxScrudmMwdRDbeoIpl/9zrDtp7LQeXI6xaWbGUPJF8nOm2RySwJ9ncWwJgpsQvBdTVlQn74RKcOzs0k+OAT/y4QQa7/zryrMok2fQPVVc+kPJlixpZsmzqepisfTc5RTKCA4dWLxEGXrkOZoBN36upVgpTyvZbZVR4M6ZsXcnSJcYaHqy1uiIeIBXIVEwl84k/ad85I6c/AMKILuQn/QYAihiJ2/vjt0PHkMr7gjNgGvzNMKbhUAiWslfrr8bKiJnXyMDq4GLuFibKMYPFCBokEgyNejJ4kPATD/atd+h2reqRDQgcG4sVGTyoKx6+psMbGcDSwRNIKH2OVn9P0guXltoYUxCpp8GEoiK8+EK1ZnrEXtM1MrXKfrKy0llH2NwJz8atDctttqOOGVA/E/nspeMAUU96ox29YT3JGiPoqRN3y8KWNu5V7sMhs2m5MESdHSvHJ+1vG3LOynnTsTMLvWSeHgp+aXpj+2DoIoYqsxfI3fTHLHEUuR3zcz1bkLD+mb01huo+cLcc5DbdgwKZmJZiiduSjEN0wlOTdikyRFphnL2w8D4xpN65ciUaeAy6wuQvwSSoZxGWII9bwMbjQgPcfjnGZpHeQPD1lLdk98io9B/oMf6M0cTpH1V9FymrCs9uWBCUKVJS4O+mP42LiwQKB8k8bFiQt3MxCOtVBEDvzUv4kZ+dl/BNWR9gobn6gM+cFIK56Nizd5IC75yK8RcUzehkFqgBWkQce45uy0V8DdnAHZB6SUZVDIP3qZGpWXBdNmd5Ss6SHD4WySl/+nB7pvnSbHFNUOr5qzYGksn1nfBs3B3YEKly2OCNl8YlqGGFJDVsoyBhV/7cNcj9pwOzWhgQCJ/yrhBMvlkYDd1JeoVMRIB5Mnh6DxGiSUTDzDGa3oGSH4KuvP8HDB3ARsr17AGdk9kef8PXPpOcTDVkHsmHRo28cWU8yz7Gnpb/qV4jFmcdyDBWDgVA+Wt/kUjLYGhaMUyz6vgrA8KlFV08cVytkhsTzRl62XH3FrDfzmedjakpTMhiIqY2VSPzdtkNyjI9g4gct7qO/nz3CJ62NosrSQB6PPyXhsAWqcebOMXogVKAsdNZogcCY1Yuf3ASaPVaDDCu7S1cubO3jlkn0s465cqGPISO63IVoZTMw9683GPCj5t0SihClGTqvtgj8oDi+HVfXhkND5uczh/CyCX3nz1acYJolExLxraflnQm1UFDlPtTcclI5cqSRJOzibm194ORYooHiSovEQDqLMp7/AlOXzuBuLxYJFNxQaZmM66spDYdAZjyjvJg6z3NyPqLqvp88/QBXi08YwNscli0nuAEMvAgCMT5jWsl0MzhKnhU5crMemuVvX62ZgvEjq3joWbSel5h6o+//ygFtV639EigQTszsgD8ZGUJMIC2eYxKpGD/KSgdUH8zCBeI4LTOkrY5DvcmxCg+e9hPdoZLi7iVeWuxdLGltyaORUH0tjTJvU7h59QFvFphAocsWfIsc9b96Ku8k+7dgX8QOD00CwTVYnuj036C9g07JYB/fCTccZ2DEpx8jW/1ry4yY8FCHRPIRO2nSleisst9uPF7nGysbsAC8SBRDOoi6KUSOvIk92Wax0+gArxWCdEkyqqVsAm9JXvUh9mbyl9J7zBfuB1WeGVlOi8+TCJlv3dzNfKVpsGtFPxmMUQQC3RmfNRIMtkq7K+0l8xpgIEEIoZBmU650ac8aCfhrqvcSH72oQz1xuGeyZMRF52Yyf5y4HlOXZMkuGldZyB2kYBS8jLsZe/7aIHd2ZmAJhwfusPIxxSIMU1KHURwnfqM3xKM7VA3WyqUWXEuErMBRVmFPvtD2Gj8bwV6xFnM2l50/CYgoME+WpBDIwkSK/baDM1ZT4yU9p/B1KOsvyi97d9zoWpp8C4CoitKV4RDbzB5Lw7G72ZafZN9AXhgTKk9c966a/Bt04wdnmmDYenuJUyxZD4b1OuKpx5/1BRD4HAy0F6Vq02g2OJP0ao/r7Fa6kGUnoR8i+jzeZVMAKP7SgF3OwZRga/9ACHrcfksuuLTXqE6KBNMo4A2F3K2DADSVA/yzg3wAWTMfWcMOslx0hit7UxXMQG/RVDPA585HojWzjCURURlFR7/2v2JNNSCWJuhvw2/ikCTJGlqU8mfCnDFS4U6YE7QoKpidJPk1nBjYhFl4rOLIE4E9BdpPOw119jiBk/oy3msvljDCAFujHE5Rzz1e1lC4etT2e/TTsxLQrdP2bEdqkE4/PNW7k71dBg4hq1N9MU+OFut+0UhpvwYSAVPxDXPvjoiFp1nqLThgbGyTgCjdR5LMa9GrWR+aZUYf9YxpdOOPBRYObRA8xyNnwOVslB+O56+3fgztQ7rPfuODZjfTUvdZEI6g9GXPUgIJOxFYfcx8cSZQwffpYUaraQY1gbiF5a56TVFRsoa1SEOIdN3sOHTD0Xcibu+DBn6YsRnxoab1AIk29RGKuuY1yYHzg/FR4NYDJUS5su4OxawHTZAu/Ox4Im/U1L5wJBLvRNSbDRPEFJFaiCCb7HVaUo54Lg7vNNcLsiinM68ZTbZNVkgq59Z8Z48cFygpfjLI1Li9gUKncvwj4PLMM5ZcptzLIn9GOLqT/azn7X3/woPdgk/ueL4iPUhK8dEqmKLhr0Rg2cTw36xhN5GtxKCn+zQDjzb29lgDzYQ2hFRVJCxUG0Fx543+y+xpG9UZNZfOT3Wl9JVUeMSXq3gZ557UGTOgpWK2PfjAkmUcZ9k8rHJWK+i0KLTixjj8EKuiQ8xAjdR3wnGScId8INhd9VHxbbERs8QWcmFkOvH0oZcKf1C/VCOVf1tQ4rGtDEm9Y56p8D/aUboVGuG/qq00NrVB4OlaNRodvLbJOIkbUYWepAoZGbiYzJCjILAD+EkY9pMNSp+ji4Hci/QNADsuIJsAQEwtM8Ed+Knv8Ri/uoZN4r5JP0txedXvkWTMrLv3C9gM0+BF3fWhMwKcLD9YwGuuBNmyqtpFmfjpkS+NjkZH/KBfFoNafH/3VtBTPYBQpx0o61QOiUVbC/B0+owqv9AX17lSUl9LEhcEfT4iRsBSdRfmRzoGEazLdNm/hWAAkBsArUUFT3FlSnBIdqGn+xkGNhFZxMtB4DKf+mA3a1/s6dHLHC2abRjeSPb25pt2ywVstOSahlb2XdWneCh4tB+NkIVj834CLvwoHwi8K+nJ05zmieHY901xhCU7kVrw1z+86HjDjNrp0d8+4l5/dD95B+ebiyJaD2gZRmTsubYN56BgwOkoGNPTfL41Uch/PSF6vLq8W8Nfm061IDIbCXaKeZ10oie0k/Xbga6Af7+VUjO/eDm1ydd5/T6bkFt+bzZ45PPSQBtQV65mcXsXmzcot11KrPo2rZHgbOWabvYeh934lUVO5bO88M2B04j7iwYVxiYULB9vFgAf1f3Oxo1EI6fpv7uBELD2y9t2+yVznd7LVPJS6VX6hiQOz6CkZTocjc6Z07WzhMACmD/9NZnIjJB8HUXzf8hsYjrq9CQvzZA/lV+l/2S6seWzoOT8aYoSwaUhzUQyCrwnTGXaZS4qe9KxW+9UY+VDrvBk/j+nLH5zjaddaYPpq/7UNu4pxefD2y0JwlS/JY3YUapcErBfhHERyUoafIYTCx2hJn1Y7JN8Sk5rXhFj7u3JRykaqTdDuZUbJi/8o1TEYcd7EwxW9cBNUGUHPNPJRaNJcUqTROMMhTNuZA2JTlneW7A4bpOBTRs8uJ1elAdqHsb5N4pQOF2d0v79iJEIfdTKGiH3NfNraIu8hvRfBDnjAE3ZxRiz9Syjpkb+syP1vMNr1Fe1H7/BCzJRHCkkYXMCfZ/rx4YbVcbMZXqY5UiCuyrhUJBC3eQ0zcsgyC8d1IPpLYPJe6DLlBMU04oer0uDpxUQs75IBkACFRTGSdNTzzayQpsAje8pdZjWGAUS5e+9NPpYKxm56kdh4CbCM8y6d1FGGETtJQ1rBht8tdBXGvtuDfz5Oz0GZCDIA+Rj/4oetymAQhR2X9HF+pYyTehCnvC7IQ1uBVCG6vie/iDgVXc+DSskZpwXLlPHw9MYm9dCwvEvZj1Xc4fw+XxCPmPXBts+UVbQsgDsINMmVCuRwqjV15N0+vBo2+3b62qTafuH/WDpAKt8YhdYnWzu8jBQ/pJL5jD4XoHJPUht8/DP6vP8s2rIgkzZK5JPIiV0xA7EJx6rRDFrBxNT7h2XKECJHurvM9h6SBxlQV2uPfzxTNrN/UNdPxNjDI2ECTe0Zij5AgfmtgvSMkz0mMzMDeVs5QH3cFUT8gCnyVeLYpUVpGmwQziKKOjmXTvOUDSIzmjY+Qix/hlqj5BLuy6wMd86nHBVcLlw0hDdAtylbBBgSKCYDoTxwV9TsUTcN1edLl5xzwDH/1K8IYUbk11GJYO51zu67h28dXIA6nLLZG04i3U14ww0L4hwXo6W9nBwdtVHPDziuFdRv2conI8pqARSq4gpHO4qd4Ue7Q0GhphfjS8AuZVBDXrpb3yyEtG/LF2YdcchQi87gYkEktR6ygy9/Z8npjR2HHF+eINyFfEA9tv+4FFOmz4oNJ5FmyXkTxpLfAsHYlrYU/x4mOB3myzVwwUEyWYPvfpIu5Adfo0piJgl8P2DP8UBQ7siwBTLApM8UtZFhHuF7uqqnjcZDuX3Y3ZOCpfBDoWLIpXl3ccET230CrEVbjl7Ouf2lD8tMEz/UtvNa53gXFqgi83/ejhY0NpG5KBSyYtDIG9fxpQpmge08qb2QDL4fJfqmCe/B0vVX31ho23MKf3oHCGawuWNrKlvduMCqlGVw5GIF3J1Q7wc/S/7UiLnZmYrtsXjKrleJo5Fh218wfEzKB6A95DJUcNLmGlbk+tRy4jKAPzDJwIwPN2Vpf7O+F7fEg8CBqFx38S/kvPPZ6cWVXQlDet9oTZNzc3mPlGe8eWEPAgVzT04NLxn/yGu1ug25vGhNH71rwCWjpbBvPIqHyFy7ge6z+bofod0QrJX0/J5n0i8DNmJUy3z4zkEEG2S2saYDQVcY/PoyjxHV2POdIunIm8UwG4EHmXM9C+caTw2TBx11YTnr5aRqdc1sSqnxRoOG7+Xcs5qXDsbchwkusQv3LVNOul1QRWh2D7M9DU6jx0YqvECnMq8xn2czzDe4+nA/o3uNw2odf8VH/sba5ZorkDzv4PD75wFZ/D3qb6QRv+S0nHHTNq3p2Wr7j2FageYVHesM5E4ICEN3gc54ndzTPF2JZrCtn0YvsQlfpa7JVwWNfSyGAaOVIWyWr8yWQkd0WO+u4Ebmv/u6jwl7rklReDoEeuaJ34O7fMd+OgqRUjtb4hIhg/a7BhnCs5O46R5OdN3LpChwZiuBBMKusMYlmtmZhZDO/sm4jwbpubVOS3Z118mXRKjVbEyHXh2F4x75ZNbT5MdOYde9k0L7LFgrkuL80V799EzCnlpvPhlbEG/6DBqkVAPzEe13BVhtQq3d4D5n615n4Na+vUTBTqtKXhwn4cPYkfwjcCu0iLsllZWKiSSVU7weskn48R5XeWIJx4hXQ6jPaEeytIbnWBOsPB1goEapM90q6R30D8ZVxu074bCVCIr01+A/rn+iyFACSFmd9vgPG5Ob7C0ZorOOBvM0v60xu3b2RiUMUx/ZnV5oQLL7OTxgYsgQvzfJHbsb+AKh1PA/SO4ZgcxgipFiIHbFW59CgDIj692rHJwEKWBTdL5+kvOkbEB/CCBu5U7Ta0lFKIBNH9YsJIU4QDHw41SJLK8dJ1ZHp+ietaScquo+zTZ01ORdxOh9lHHGVe2xnL7Bz13R99ap8ewNb+1osMbYBXPTRHzxHyW9teI1s9yWo+Cdu4/OfiA7TEexoOHHI9H76y+MqIxAfMrtA+UKIw2qOtTvxlsaDl7VWvLfS/+Z5yNfCvV2vGTaUyMj6SuL8hOOQ6/UzlRrF9RvaRxIatWPnWtXGmW2Z69zSW8BwHuUcPUi2poWLMwdP0Hujb09QKM3PY1CbEgCS+z8npbTw4M83/PQyZs5wUxPRUk3F+OtPvstYASNyiL869hB3aly6hxs4ZOuRas3SonfytUHmDjhhhUYH9lJR+izABsWqAN8/mz55nUPQvPaZo8+RI7X9nl7Q2I2xWQ9LakB9KnxKBRLdzhiqV5pKu//7EvKVtdCbiZ0e4nWAeeyMQ43zfJR43x7NAJsXW7G40KIMwvVdu4+nu2JQ0+cf4bBPeg8lopdY3iurPMtBBdQI0whoCagjngHNHDYksKubf72BFDOsBijctnWjlwye+8Hb8f4lmte78J2FWce9AtsaQ3HGl5nGamnsTv4pHEMV0JKyBC4zFMr60zFjkCeq2megb0OVaOIc8zQhhEb2/XAr86ejMwUiOhOjGRZnhF2I2yxZhKPX+KBf3X3hoa6PWs32BTr00PlBS7ATGWALIQTzpBo9P3yIVY6D5lG6gsEoT9XGN0ADjIG2bBE/rtRTZxJnQUS9nWTt3OEZdqUxilEvU0EzpJAi0OQzxfvuXg8NcrgCjMY5x8Y7y+TBbD5a//m3uSBCT0f3GHx9pdxWPgHBKsSh3FWk67RRZgCOBrLMftZubL4LF3zOAXDS01WdzQgfYejNzQOcme675UoyhSMJfCfTdlvoW1AKQYNsbCaGf8d8dBB74Cyp75t2cZUzCgBv3JNJQpZFHwnQT/NqM92XiakeNq2RvgWMZWG0bHvrBmngdn2uh3Gnmy24LpVZc4mGKKtzjAXtVxwgi2NFeITsyP//cJ9tn5pKORYK27JfGSh5OkTVaonvoDTLzb7zNGa+QYi7a1TMlqMFhKBZ8OiSPg2BMZv2UW9l44dzOmO2Bb5iGxnW9ZmMLWwOjIDXZDMZ5WENkmVJA3zCUVr09pCPhPbIsyiWYNwDuJ1ldDMc4+Gh0BX2F9KxgzjegmvQlhzbD8u4SLB4xP7xpIcCeVwAvvjt5ZuqYNVF3/Bf033GwAr4fFFhI5kR+AnGBY8sgjplM8MUYkB2fpftR6htWq6O91IPM1ZCd40smYJBqnFpRUoFoy0OKnKkHOdcDclGACW216UUUATZXXjg2Ol51orQmxqEkOqyIJ0lCVXQl8/BFr8L/MqApXgHBU8eZIDaYMRZuiRyi/szueUnJj9qYp8kcZdXfDYY0FB6S/QxMuzMkVWLfrtrVjQx9bc9nx1wVPAJvBOnsqK6QAfW65VR26XHrYm6Dvdefgg4dcTlwWzLFak7pc0yWva7iNHEgvYrfCNx98hP09zKCTGkLHm+QUpQbwjkzTHt6zw1VgULBMP0smD23IWh3adO8jWkOnJDHwwv7rb+DQ4WsFx73Q6DVTgnqx5o+fIck7dEj/fyjBnWZJpELDQNwvVjzjUZSoZW6170wrfQwWhcOjgNdDjpEksD1iJSin/Oylq29c4jLgwTj0IIJsA4E+TiPQ21y0pZOZpgDMajaweQRq/Wj9jeJ2oCnUd89hPv8Y9qOXyvF+KUe2DBT1Tfubuito/bRsaf36WVCwJHcg6bOfb86Kmw4XbPpGRbMLlLX5cl3pDp/glANoMPXD1AB09a84uhz/2N7f/VL74BDrbnkbFJL1nioxSGv5pZW3kC7ORcXKeOMeHTL6ffEuqtBBdPqw9ch7VGpiEeWO9TG/d8QSDo0AAYx0Bnaxmibnq9PP8AAXlODOj7K2LWNzomo1CSONgjrKGxKoimQiz9OZWMTgsTxRXEQvTe5l4gBL+75DKLh1sC+c+wRXpoMyw2riy3yz4GWuJjVFHsX5G0TUR+pZn46i1MOfNbFJQg0/DLZZAhQb66AZMrde8klvPQCpkgTfmAVMpSKiVdeqd15Hp4yglG6WK6gj507qP10GRZTu2mogAujvuq2FUpKzAIlJWINaJ7hydqeP1+tSZTskVJUvTfFmEPNCmndLcwBPO8rxb2cebblh0bWrAj0Yjmcq/b9yaFVtygfi5SouCGWzEFQO/4FZgVmiM5ffVG9a09NpIwP3W4NI7tYhgZnWEF9ax2LdSqr/Nid8W8nr7bPYlkNMVxcm90/i/bKDQxCxyouiqtTXgXDcMi1i3KDvL+5u9R5wuPz5ryQSj23YQji066o7DRusZkX+AFv5wpaNhzvL9VkMo0NdlHQd5lLSaIJT8B8rwuwzG9kdjH0i5XZ8YJVr6VbyFELFOrtT6LN2fQSeBf3/xSXa+mM7K2Exjws82sSvJxQ1dGwa8P2k9J8+mBlo3cQ5eXA+EOV8OlI9tgkUAwjPUuQ2NGUIfIzPSIVqpOPrAZP2O/ghrW4saj/4b1K5WQXwWo7qIwEMVk+2kV1enMAFcSqqc8wPQJcwrgUL8uvDl9UKdkIhsEBbiLJq1zaMXcwgqnCOqeOe7WcnUPx8O/sYrlFZctzg+XIpClQpT4Py3CzGZtNW9uiplfvS6EMbGEiZ06C7mbEjd8BtqcJYktGZ8ZIryqlsdBCYeIT/qAgfMVw6LLEa3ockXj6x7QyLtSrF5qwm6Cm4AV/Yr9wXbs8xMinfrt+z1aShdFiovDbA+XSgw6KdWXSY5h+42SmjvZkoW04vntdFSWtd0a83Y1E7wR1KazJud/vexS2yh9VtkMEpUbfvVbsm2GoqY6Ob9sQ6BGlKb5oTXeG4tZZy/nYCxdkoIJDn6KWbzfgAW3s0sEDEPPFgNbGfpwkIqUijbKpuGFSkYoiY8SQzthQFXwsPm8HRLe0SgvfeQdFDaO49RBoP/lyHfLhlJpEsOpZr/p8rdK0g8fbqalCp90qm6FkSDxghpsaSzabT9T5fE2Lm17DtHd7yC4/JSMU9//xJoRJr6go5zkzv2zP37Ba2ZiQfpCJFgIbsX5bjoJYOeDucNO+qEMMiNZay17JuapNUqkhl3MLJ+maQQCHpmCDxeIqNTBcHKgIwsJRFOgcxBB2bTgI/tQFkx30s2XV0snf/yWrY459BZHrBSTFLj6hqyIlenwMhzEUbw5ZWBd6+COHLzxxK5D7/JYtpphPzB1hKmJcaiHj4c3qLXScfQARasLtE64nLGWwaK583veloK/Ua+J4kFAu2+hESG9Kr+E+brl2oy8UJUiUvQD/sgq2PTh5hWrxOjJoaHSnk2s3THiTBhlfGGiYT+nchSM7RfF1le8F3oIHg1gx0De4z/jhJXoyMogbFLMz8z+Iu1dm7LjIyZ0t19zzJOaiOhofwjW7RAf4kH9OquVLdrw0Gf6gNzUwbKK8MJErwVnljn+k9r6td9rNf0aQxeWX9x5JL6mYWOvXxuPkZ02TYCYsPdCCnXEVzRcKPsZx1+dijrNWvMy9rK/EzOsYleV2CSYan5mnOg2b218ZMTVm4VXeiWuO+jymCaKeIVyoDsC1lrKXUhf4PNsabeSMT8NGa3RNfTZBDbpV6PM5868niaTgDX8yo+ho5A4gq8b+3BMV8IuMyC8S5Neqn4Iy5vgB8L5qKjBoWGQ/nKdYMIWJlYQvaUCXFasU9Mgs5t8WiW4QvNv4344xc9b+3REEBsieF2wmwO/OiqeXbGaTM0dPwnUgekK62+vGeRxGPiIgZv3ck7YaFKCrJtMBbFtSEV8ru46PFpcV2PPUtXW6ISUAWeRefQHfz6liNJpoiyORKqawTNS3QfEV23m2ALx31B07io4pqSVcfy3KgLpYgTQFbuGbUDwDDJ2uF4FlwF/8U1wmADgf2BHYceobL2+tBK4QxF5Wumclay3d90CFX7Mlgt8gTgqy42MNNN3SottnqjWmA4i5ZRLPN2O13PiYV2ZM7x7hv+Smta75Q/GaOVM3jpXvgZzzgR+voRGBEhGZDPeMHzVGnP58okVsxFZxHAAEvB+ifCj11Gf3mfEFNxMBi3qSk7JRPoC4q0O/KRjVt1uJNz/KvRi1AmBTKSlAD+LrA3CAl+LPwbU4QCjT3NmgnCAe8Ak7BJfxpvNSnZrKhHSghJ2q1x/2k92MTCnyXl5rykTMOAg6/qwmkS8oxPptxqCT392h0llKoqmS0zJwmRcQmpnTbzkuhyTdNmF3LCeGPYUjukwMiXGpR8PASam4jQK1uXESnqdruHEd9a37r4vsxZNIRn4/TQmf3HWnr+hiAikYBjC413HW6S8BCouEYZx5yQOp5yZYfiIXLmdP4YTVGLtP7Wawl5CZVhd7MsEdiJxCz1jAGgr/BM5786MF335838MpDS9sza5euUUjiVcxSeByaBBamOUUSra/IPQ5ezTIawVQzBBVAW1ZvfMyOmwl6CUrzq+FzPZCD3uXj3/PjsE2Km6ghxNBRt7t5gEYUMXyWzxSfzgqCXS2sPgYah2wu9zrLlUimbXG0w7k45mrow+w9VgTPavpaDOSDVmM1iTmI0aKapNUUSTUqX9hyd/cT1u1c+Q9Oz2dL0hwppUTyAiD8VvQKJSzb9TzL5EgGX7aaBSs/BoQCJTXsWMpjHrmROnxa+zwlS58iFcBDncnhpXVrpHixEBMBLK/y2bOtrmfKCTEWv+i6dPEpVdrzNPfBmUEyV/DSipC2dRbU3U3WGwf+53u2n59aPhocdlNhWJdIAPs+y1+fiHyQTSMN0Re0n+qGS6jrcXKnoi6fm3ME9r2t0Rx7tpMbcqxgSSxZOvqV7FQVYpvyw9Q2Ltuz3FiD1ZsKvqYMJEDhOgBdNXk/quXnclD673ysxShr7pEBB4ouko8dItLTzSx+QVxbnzuTkOT7+3j8jhRNfaif0UbREEu2jadenIchIPvfh26cqtQjfSRuU7qjV10WslJtKczB98nNkhSt1jx8bv3Ak5p81H8JxQF8pgA0zezJTvgooSy7yW0b9KkfVoYhiRFyIFf2JlcnTQkPvm1xwtWCTqIOIRaqYCDDEBVplQ0+kUfS42CELq4tXbFUET+5lVEP3S/MuyHBNjvdj7hRddtr934KZsU3K9LxFYZQPT39ht+kjMTs74gfbbrY+MJRvKwod7JwHqvoFW0lnGKobhN7CpcAAWEnFSkzN0ZT2GJRyPwWkC95nqqdjbm9iZyTFHBdskODMZVHxXisoFbrYaJ7qakFyt4b62muN1kLIJ5TaGjdehzQJ2LfGwVcExMEUoA+kQmUM7weQjAVOV1bDor137BNM8eYFdNj1izIrxtJ1XcXMza+lq5C7zsAXm3Li0nzj4fXPmzczTWPb6YSuSvIGteEjr2Yya8HLt5SwQ/3jzU1IjW6aM5yabKYrswFIIE1RX8/nt7+oao1HV8NZ7jBdCDfG6hZfmxfRgjmZDJxdRl4wTcTxDSeMPBkD2ns0RdbX1cLi3gRXKKNFc5PFh2QodxvfYHkXTossoJ6zj9TfcuW1lbIM+SoEGAkDEUF6diSYpq0l89UaQ/bhsmQxW7jcQKurcCLOuPyNyTdUnbK06p7HPptIZ/iZNkInP1PktGSIlDMNuDoQ7Ml0vbeh8CgIP7QBxfcGlLUpRKemALtM1kvbW0pRmLVxGkztYaMNDNRjmESmd//zKih9t9D8fgko7CjKDueowz8MjGsbxFbzliPGo7iIbasDITJ1FvtqlWZ2OA1XRRSXuj+1hr1AC1WiO5UvD5po31QnU3snS8O9v94zrwo+injxklxk8efq+hoGeSz3Ry59+jjjB38jxISGYXCi1O5Ba6Q0tHbwdY/y0emf8jQPIk2zqIIPwxej8tngw3nigTJ5kTeZTEDEHSVPhGXLiNqh4J8SszEuqH9yFXqKpTwZYqJPU0t9JYVkhTcB00KBFqi6aIblKrSkx6srFbUUJfOyx5KW2ONT+DyUifdcXKe3rYLWi+MkCCBPSQoM/M+tdxqDgPw1eMf8848GICNvbbwK4OMfhUBcnqPS0Xkd4wOjxbDxBDeGbP2RHMAmPd9gYUBwAZ+wo6AtDOUWF8ERfx8gZgJHepxPFRshl1crNG1Kp37SSTb8rGqiVs4nVX7uo6XlRM235/BeOp9E8TnuFs7sXLjT7sr9KgVhSpHQDpn3qAb2B9S8BL4Zl4ZkITyTGYcpL3EB+M5X1QdWIlSzXku0e3TdF2UYb+x1adkM6rEe0jrweAxwxbY+9Hs152I1tfv+ZB2fAK5riitQ8AX0RukuH2hpjONCRQsiI06n1fE9qicSzspQdTlssXLpRHhYlz7SbbQlTfWtWFvFmDUdb0CmrChnuQ84UL1+4lLDPt6LWrBkOBdXk1KQZcm645LUw9AR+RNlCH6MQWiWFBLPgvu7sWRzvIEhbpsNqCNpFQWlKsAbkl0PJPzLlpeY9QTMmy3G9XL3zZia1PPwCevpRRjvWLuNOzMatYzzRgcRiR8yUTxrTuPQwvDNCe1aOGO1mTUtmyGhZNGsueAJHYy0FD3BaoYwL6LaBwIytk07q6HrDiLhp2NQQPYi8nG+sKyYk7KCfAXkXJ54TZcz7tlCQWPW2sdXMoOjpUjMulmceWFQT9EJ6SmvteAgCR2nN9mnqF5y86Y0hyyQmFqJcDNUngMWwwhOVbq4IwkIXuL8U+//fjKCxylCLlPCso6cJ91s5xk6F77zTbnvx7s0MQQ/rg10kPiG6JzRwZUoEcK74ygWjNFb6Ts11/DUWwwhJOcXjwuYaJtKIbhE99oLwoyFJfDIGRRkTZPp6LxMqRMeXNkB6iRmHXj/6Aoxx2Z9GRFV4BTHheBbqp/Y0zknm6xtQXCjFdNtv4HDq51EweUEGVs6/wM+NrobiGA7IaJSD8jnFyQYxJdlaPymlKCftmN7ztAO23vb+ZHw6pNj5POAD3118WZQDEamKCiWzIkYlX0h7LZ9iEkfyqk6Q+5b32g93KPOYwP1cvB+yceOMB7jxGuOPCdO7+g/MVVitfDzqyfI0+uc+HdjdUdj6d18jqFt2EJTqDfH2jg2Ha49z7w6SJkuaS2SqN9UBdpPZKG0NTTX0oK3yEsiNka/5xxJE21gLFdxxIloONmrsOWnZv8J88SwfQkakOiPzLim9Z1vYo3ii0vDo9DUFco4oVobjyz37RA84SX23WIm1dS8vs8A4Y03fSxl88UqshNmfcgQ2bdBrZoHLgetswCmZnALqtYxCJ9RQc/0inqBBtwiuOzECvggJFq4+JxL57Xt0TizrJRccFrdcoZwzqWQu7pz5ZTmRffMc8nl1OZP55JFNc8m8OcghspQyYkROewH3rT5YPN32TXXhHTUt6dmN0WsvlT+nHFL+xcKwXD13H3K9LLOs7UppquofatHveYr9zLdGbho4gQeHt01S4O7YLeyKzCCExRg3U2mU3A0n+Ny6QswboXEg1I5DLkT6nA6HwXmrrSV8BMAESFDlG+vIwU03HTnxAzp0o114XTouo9E5n5DD/Cr5pS55Kc1mHQDcA8cyZ3kG+z3wUd1zvw5iCqKKvB3FsHGhDIdpmLl5b4W9ei0ueQZ/gO6MqlbT+lYevnXadG8wEIMTE4hZT0leR6OpnIvfNw1CGlPePBV/hlTd9PuiIR0+4G+tqBnM1F69Mf2+tdxOMGM/UxWuveu0o+dyHFiV+VpoiXiJKOz2WBkZC2RgMPkb3zQABHhkVLUEZ3yVXC0gp/iGbM1yNz5FNGK9QG/BEc60gbtNBA517+c6SPztxOV7HX4pxrszVOxo9ph9qxpiaXikgBZDkCbWMgCZT5+S6T3ERQwtSwaVPtTLto7rlPqoDYjJX479hWSqtFryoOWLWW9QtQkd7+8F/Yy3ukI0aVgX4eK6UEEcxDl0IsPALkmg4KCNLxdqpz8vkUVE7Bs11uIB9ZKtCapZ0KfGcPFweMO+pdteAOrE/GERW8wx74/0shesN0bq1C71TRuu9AuHHp6G0STb+D6QnzqhMlYWAS/AfWTAhGwB9MSevWhow9ITxVKjIW8ANXNfSQ57y83qz5J49mC+xv5iHV3w13YUE9l5zxoKsPJsxTxZOg9zdnqE7NrHUfZvyYYY0J6rwclMYhR61hGur254giW4lEDdV/Thi4b+SR1om0R+ZPnSqIFTwl6Op4HvTT4vhQVx3WiU4eANfnosQhLcUfUAhiI1YQF1oO0E+9E7WEG6bxGaRbeJkNeGt2N1sDHp1sLRBHZTHtBMuUYsyX01GaVZYDq7qR9IhvGs02zFGwsnH4dsjeyiFxEpdXF1pv9WjmapMPK94ZlKhMT7+8/avZ2TLsFW6KxH3G9WhglJJPEM0Ih/7HjxB4PCz1GubhGLSjEX1o7K+K1q5cpz0V6ZG8csLy7g4W4a6XjKqLw2G9PcphE+KZuEI3zdUrvBdQEPNjAlodEZM5mbkX6P7tJxql+Udv5Vtmlzq3Ze2a+9LhtFUPgq2KFAPakyRRdIRpo1w4kk4VgQkQ++S0eG7rq5yBGUDFNbvCFvi+W5yJlUwZ2DBoiKgbHYPkoyfvZITlX1D4fe6Z6XUD+BH3beVgJkFxOvhIoa8DRp+iu/UFIU3G0HITRlZPKzuyiE3zkmqrWyPRymUhxgXM2c1OnReHzpCObZG0HPvwseEbhZNmwk/l2suxiKx++iSNvmy0wSQAkSGRdm3q9cQhuDBrfgyFRTprmyJfd7Rg4uodQS5LDzgTXkH1tkhoO4vmOsf1r2avs48yilC9rZ7eRJluwB9xVKqI8OZJ5A+ktxUsUEsStfZ01w3gy9hSKqtjL0NMmlKNYJiTSEV/XtBFySv8uVkaAASA3mB3hzWrBKMbRNjfiwP4/Hm8IpvBAYHSsIHG6ewYDvH/uD83tYq+45sGMrrdLput9qSmyntia72kcB+JP9DW99Wou5InFEZM3/jPl3MqUAhS2yDLuakbyzEC3Xt3H44Kb9ihoWyalmMRuVuqWIkon1/QXMGWFN5jZ23dDOzQufo5a3J42RHrPIaVw4xOryr5s4cCRRxWr8hDeD/TA9MkW186KFel1UkaDAFcTR+Y5ek1ddA42Wj8bNnZrAe2mL+c4UO4p5euhxhpgf2E6eVBHDk9c+fQ6bzOfvnWk+YTU0S7VMfOSkZHQNDkKe5mGF56Mgq6oKt74jdX83RTwhsQ1nSANkS0D0qEAP4No7xTULwNjivssR0/2wkQ78+jaUERg00YTJV1uiiyjR3l2nnXcnDWrNAh4+Fodt/LoECKt9dA1JHE2ubNQvGto88/vCLqUloeOPC5wVj+n9BCh5y7mKVVSKXhyokZNQSuQx3J3VBgZGtZZPBDDKp8xoK4q8CSv7b+edZo5EX+/uxxfwW/JDg3ImxC33NXjwlapcHPRoZdGvhz6jlStXmu7ian6JycdnSAVkzoNzGq908UqZBXmU/V1+35yZ6H1C2kN1QVU7CCZXXG/k1tJmPJ/3sRcqTVvZtoWACgSByy4jt0Q0MTkEpExXZlp8fffPvEE3e5BDu8xKAhKozufS2oQecWU4ZUlimmmt7kKKTLuxGW76a6QUUiA3Jhao3thAvmIg0yHRrlq2yKwcI+R2OyJ8wSgilF9m5Q7erggEZA59RH+CusPpf8LUgFCOAIrSIl/VXu4XrI7Y37MPqfm2wPA7aieS/c1I1KQ5fKaeV2PGy0Zu0jVS0yWt9jM3SIX8uahatUwZzwrlpoIWdUNFsOKjAq8GlEFYo6YAXe1OjDzzNwzcBgugHqOZUOLMUTRKwJuKwy/dQVzb4qQHJTNxlO80GyrqjNjBLpYIt8iUS9E02c38d0cif62cxekPZNCKjN3c+p/NPHdiOaVBA4YfKT/Zf/bWbfNkQXX8wLYNYCvM0vMLX/U0a4TQuI31HSzyoQztC31Fczn2lNIWss6V6A0psceRZSCzFrWPIUYg8tGIlLKsASPLGrUzwLmqIJEJ8EsYUHjKmjejH5p+Bu7RF6lFfqYmos0dv8q20hhEmu0wop5KEJMpNYj1rLuFTZdO2Burj5SzgGiXxcvRr0nnKkJ5umye4xVtr4XSF18riuRw+VPDvu+fFo6goKTMfBvsxytfQWWGoUDy3y5P2E6INDTRxo56w88QzeHZWshUJ0rrKHYg5mpK/b5hYips2/GeEzCGGCEbVFvJ0ywbqf1JXh1vEZPycYzt4zIVdnkRIjaDM3Rmg9fXEARh5A1I71W9NYCb/hTmWmXdsABWC3Hg+zA1oqSQFhoD1+3p1LmhEkwXUY+yNKXcrjEKzKD76i5FTOIZ6tJewo5TsvBY1xeNlsQd0wpA1rO5qqVCbnh6TQ7EWrKY9AsCGYS4PGK/E5kWYcBmuajVyo1OlXrt4TkiDzPstI5mQYFmDQIJmmHR+SD9B+aAGAAP1Lp9U0zAyPDtUEWfv/PnhVle/FRO1immaGxnAewgXMlv3o/7lpGsGQtmwM9Es0Y2lxPpGghw6vEj3MGciy7wQPNxi9t6pY6dHKI5I5N1ibSl2CVGG0HsoARFcFGzn4TVQ++qoCGzjwCTPxiwyyKUJdJZkDyUtRD9QjTNVki9OaF+erdQwCFAIIqNml9LgxO8mOmQozBEujYkW5W0zUh87RUKZNjSvJkB6aQjvDHKguUguwYtMzIQjLZQvLj+6kj7qMBEe1wdhi59m4szxGvXn95HSJJFsZaqy9sEOON7n9Q/fKRnUv3ZAcAKoH6+14vJBNBwKkd6AQb1En/TeaVdNfxORQKH8nBgPiX/8xAPnVBZLgKfvwX6IByjXWRXWPf+W5cjh7SxjDnGwtiSsVvbQQSHAwqTXe6+c+c18+89y9RmGF1fuiHojZxtzwsFzvFtii1fwn4c70IpFaPkH6ntPXGktrj1Iovfp2RQ9Idn6v8/+9DOSVYGHokP8xOHVC6imeqMYLBv1LBnJTeFWNXmbJM+h0UkmNIoEDataEQ6bWQZRmCS4KQ08QUNCDAwjK/fTlo5dLlcg3trzT3EJe36nCNQc6ytDWAZBuDCDT/hghHqKt2diE0UVB20gbyfoG6lbK//u4S56WD/BsigWt83fJKmXoedRjjCgbNg0iVbNxOP2+gQgnxJQbm4M/wpKRJUct1vWIgzNbqs7wvpqQNfE977QYyaxjbXQfUdw9WB+Nfxr6fDLfRvMeNIftx13HJAuNVMWVVg5rN3iEKpkx8ISpxXRa7LRaW/9GVX18PerxeI3Z9ygVcoOoFCsFWiHxS7pT4+MOSEk09YweCn7ynDaw2Tnc9Z/MXVY+gGwS6qWbYGH8phlLpWiwyhrf8QosiLYBHv/+/L5JL9zrxhWvtK2HUOciuWb6/qXzZQ6rOwSnKMNpPwj4se7OealvwplZyfZhqjC/z0TE1dARqX8c3I4a0OFoleKGsnex8QQp4RPisDPeNOlQUuabtp69G0VNp+PwKzGAQLRLU0GmNdQYIdcSzPAAdZUhApP/eDRsbT0BA8JSU+Aig7dqSi6fvX4lDwesSL11Zi7/II0hI0BobJbrMPCe2oNpBZ+wHMMu4661EP22RdgpK/wOOYuDsfGJupkT2guqTlpU/7bstp6St7y7silBJOfKX5Nzd/qy3Ekr/Y0cwULUZ9Ad41E+396QrQc+RpAoXyZgf2mM/vtqpU8Ytmm5vbzLiTPY7dsHkkPOpquieJSwB53Gf77plAGB2XHZmtMhBpOyT/tyo+OKK18M++enAFoV0mj2nE9anoQx8YuVyBkW3BtAwRTtdcD1W8FCZp9cV1rtvMNrmxwKrkCGWD7T48w8o6R+6Khz8+EZgsugkDOJEyUtW8kM46Dj//JEmat+dxYvYkx7kXHcBPgUcgCXhD98/ra8k1C7csHa61GpYzt0qNn4JTRJ4PhiyBQTN+X57YtCCSac1SXtSQEFDnSrWtUzkFMe/XZucw9LNV9Nao5xGyXp7/EQOd6yF2UA8RiQrikBuZ/AU2GHcEqm5Xq59YphXHnHjCsXDRZkoJUOdZQHZfUa5yXnURiD4jHy605wNfwgOOh94t6/vNiPjaoyhluPuc3wYqHYbr1Fn0VFNh6jMdRyihdNhbeSOAJHHAbcofL+c/sBpcKEse4/37AGUEqnBNGqN5zM7xbGXu9a+XcZ2jRSnPZZfXIYmPidAtgV9BMSoo60OZsN4BWPPvZ1DNFlcgA1fRBS3E7TtrICdg+3g+cKiQ4jjE8O3zpMlTUlQBCOxgJsP1cPMll1+R//fBV4uTEcNtMni9mU39159wJ4U/BoqwtzxCPUQAVTOpFr67/QSBWQ28nnDzfWj8fHntw06fANuYihk6s3NilCOxlSxtmdu3fxvgb1uOOvJLFgYaHwKQRupZzZ8iDjg+9hptwu8huuvjJG6MXfiXPQagDbgaoQz3QS55mKkGplBNlNh9Yi4xeHvBosqLzQb4JnsyQ2DtvJHrEEcjfAmPsDRWMoG10jyKnr5imIgz0loRnlxTaSrgq2ynSrukpIeyg69P+Y1K/8Hp+FgaCUzKd+lJE0o1nEVX0WcfUzlK+YI+q0wo8v7wrdT6TrruUEkEk5xqo0uKLzZK13HoXTUoitIdmnpeMKdpc3jWICytqQNUkU/9oHqtbNyEfeSz/WWjJcUpIUmwJKbxoV8jfgQFlZcPgcAAeEQnyG1lAik+NhPLQ2fZMAQt1WAgQHmXzKrP+6SwUqVCh8I5wvJWd7p1mg2agjVmyWCB3CkkErvkR3nPR9gn02D5M7+Dydn8vcfZKdmgSOQ86ELRapXhr37dxKRsfgHeEDm+Oi7Aj8RYGHu8OaVTjaltN9/Le7m+Df5klXmqaQJa/70+Fw6AoPX9s0BLHOANj/50Jz9TeVBuoTcWVJaRRmnIm2fWJnUbEWVsWv2W1sk1YJ/FpJAj7bNykA1SAJL/iA/nseBvXqCotCF3QLc1kbpTADUDdHwbazOFvgaMXK9XT4yZd4DMcM8Kyl7Mrn2+t+wa/s6NreYQRj3hYTRrl8EdmbY7cChjFF6qM06GyCW/APIi8zeddAB0fW7r6WTzPEzrBV5H7i8NM4fIB+PDIbh0KCJZVzAabp3uWbZbmZs/G4qB7JAMONba0923OdzgYQO6VFWhO05Jy2LbiUQjB8TIAQEvxgmbY9FqWKi4v5uoMqqvfv1KKlWlPQKp/9wknUpsqir1Zq13sOeWiVW5j+J2BaXDZfPaPsB/JomVS587EJCshPHAhEVyN9LmEJg0KXriEukcf9q0XNyFIqEQd20JYmoIdsX5RqBs7FhRHT1RWhq3F87IDm+r08pFTp1m1gvDsscXVvP7BsIRfjqLj1UC23Fd96InJmZxLACbJgOsyWDUkzdiWVDJldQYsrd4FQ5XvNOkglLOKDGBNCJ3/+UR5eIgWe/9lWGWRdo/YJbu6Dyg/YfLhISeZ3BBV1gjdFzTvnRvKqBqbJnfz//dUWcX4BFWeUewg58dFx3pczZR6wikreYdm86HxcBF/RRwcQCQiMGqOKlkLQ3GeEYkkJaXn8WvKYFhZJrQQh9/k01H9+RuiFdPMXnatJfvExgW/TkTAfQLPuGND0+iDJonaBTjdIVdM7OnfBUL50XN3VKtALdj73KDwhpGKc0rHAdJNxNhXZ5k4pQy+1vCt0ZcRfwyZYhUwpvRENoAJly4uE7+EifR7ogDT/rG5LiL1qBl2mE7b8OL6XVJ5IwPAwRARjJBusSRmKY5FkD3Wg/cexyrA4eUDKKiEdCrEx93CE9iLqBrtCNz16fJYzZYJeEoJwOrXDaDcxJf9b6CrE1gjLg5GsBCo+rwWJc8y5oZX9012Jst+nZYXGYoM+dkuo069ZFIXphjfd1bfVEjk+m9IK3a2ZELZ5M/8s8LrMBFNdeCokVvHaRYTfUhxO7dtLaA0txkYycRGMSoOsV4Vm34ePA8+ZJx7vMoc6r78bj5eRgYv7cSq0Ty2M5/6BE39XG63Bjp9ewxzw+t0PS4U99lDHwKcb6RBUyv+HP9pGd5LBbihd67KJ39xnND2Gl0kjg0fMeiWZhzNTjKEQcBUCJ3cydPJ+JIWtSgVzksHZOw7GpgZ7HDasz6kZFRS3gggkENl3yKPbKESpPk5yBWs1CfxM+zQeSAdoncL7i2qwjQtA4MKGL99ex0IpDZxp6BUox4QsfFf3T/gn/wtxOsV+hW2WeFCBg4tY9l4rgPsZJL0mz8dZsDFu36ufg2B/0QN1POdzrpsN662c91eLtGiwudi7uG/R0sauAzWlJow/Pto51mOpTWJhSyvFubPxCYZ0mtuBYuN/qPtMlgtrfrkWDN4EATCdC296U/7VZYTX6urhzQHhnaw+8n+BiTMApyiW8KQzKBhM85TIqnKNWWpBP0Xrup9YGLO4XA+yRMtS8t/c0UXy1EEwQ2Ih3MOXkimnMDOL5MbVO4qHQekIJtp78zPhUpU0AutbojwqBACUV9jhgKKOhmmsLP86gShQQ71wrFAaPon2fovx6h3c6d0lJqODA5CL58jKv+nxtT70Ku7BNn53E95Yyg8ivf1QCCa0MtSQEg1KUvxqGqUgI7K5IPTP6zbXPjCEu2/TjcAeXOef+d2mgybbO7FprIIXuXOMtt4evrs+8uzqhGKqnUWtLHECJgr7PtL6dzieUhtlGawLG+M6QcmlLpQCqqVRW2XxVIgDwTKS1RHbUOwNbfWOf2H0w2gssvVGiYb5FKsBhI/S1yYcNhmtK+kRisipFEy7EaKli/zpMgmBidXvqNNFD4Ocr8Z6zLdCp0tjpPrysab0B2bmbUhySkv0kHA1/I5349MU0PXmvDkTBVxcYT4J2FlAXT1ZDHQHC0FZce/biglw7qEjC8f4f+HvGnNzJ6r2Pwqc2NGepFc1h42JmjwYBaLx/217hkKAkDod4Ozg4kcQw3H1TcLyOprjeZJrawMMB0OQhkpaUsq5cm49EjZXfmPdPmmIRm95ObBDCkS+uJ9GNTIihFsadACOETr1x+9HeCrBAWVbCrnqh2l8ybdALcO7wsr7bHP/2URY0qUp4cP03vYLO9+Y6wJTvzKbad7h5wrlP/L0gDRYIC2R5VojMs5LrL1epq9qVfXcX+44HwjfAEaLexvd/xnI7SMF251bNdkZTNUjLfG4DJGFpHYrzGLUvn6x+4FMf+Ymj9dbskJmdyTBHA2DELtdXuy6eVZPKq5I03CSOHBSF4kUoOQzJ82exv+b0f9PHuFWG1GLd49OqG2fhI5vSPuenAQ47Lm8epvKyqzAyRSW8NdRmwumIlX+SyFfFRk7jzMCrWIrTv82jMZHOAK+3GX0cpXQdUnfQjQcoId1zk7fNbt3zQAIbX0a5bSXaetK9tZkVRG05EDLO8v201WaqK17ElfxTG4nNHe2txUw08LDNJRwRAhjYTF3QnYSuqXOrAmRaROqn/3MLsO8HWuzhUOMMjHYG5VCVpSni8l6dCSaloGQigRgEO0qAlwgrubf+smwmQ3GfNLVq1cw17sIkNQEsl/IaJTuvKlfVJrcMYADKBqcGsfxS6WO/3N6WqxqaZUOzP6mEshrRRg5cIBIhWIEwtpDDAccD8d0MCUPcr6J3BPRgFZSyYr5K00zCX66iy7Q6mFxKnhNF+O/W5+iB6SLYtUuY7IBpPwJRRam4Y0NtOGb8PckGfWIApJuq1t1TuhPGdh/Nd31rBmIFur08DzLrMYi18JjufVbPUKOKHJ6YF+5t4s1WkeKpnLCkJdY9Y7DdNXJ3h3D5+w7HmvZZAvTjAJPkiup1hhRt7iJlR5TqM5WTkCoPPdBoe6hxy3jQrFpb1iyOdM4O21ngT491YLlnsNs1NMmIfab3/W7m1/VcdWBUKDsWv8GKL950xTeLtL5QAVPZU8ffWPmNi9Aze0QUcTfrllxxuahvNYJA10f9MrbqAWzCUDRBC/9gv1jKHCXo9isaj286Nivd6Qx1w8wf5eAWRRy/1adyubGmTh9xM9m4Mf5LKWpce0Nt9STmRvlolBWZDmit0DkprwjMYUhA7n9CvjItzHoVijCU85aVs+oPaoBu7QOH08XWQNkw2577kmJQ97PX74BsNcyVKjNzVwdSOV+WdgjhddSlY3UUda35TGA9ZnuulCgYyD1+Mg1fOULDzJUgvYLrZmBquWQSl8dWzdkNFuqFRx8vKgXV3loHfYrBMuURBmQ8jTZfV+v4EPNMt5bkUvcSJMydZj19X8ONLNBGBkoB/Ovu/xSGitOPjD7sd9ALjp/B4O8fD+7kWOxlaztoPuhJuqSz44vVqwDMQ+Zq8udGiLakd6rFScKy7SB7VU6jf+rcg78EFLkks+b69v1Vh57xqo08OTLZu3U8P76tcSTENzM+/9dkiZ6qhNpbRbbbc/uTYontApA2UiSvhWIEsX71wv8szRAcF2RMvcuAeuaP0fhlbUvBClvJaHei9RURsTdLyGHNGGhIAoL587QuLvQOPJj/VLEXftRm8+l8hm5sX089x06MTtJAbVxsO8opO7hfHTckP3HQnMgfFOyNShxW+zY9fnHAyjwM+mFf0YzzUjcEDj6J9m4e4ovPwzloJKBDlIFwDKm31VGMf15cNTuqyYjyQZcSyX81HAZKH7hUDyRSYTT6fKfvreIPDGzE83BiGCr0Zi0uMHNuK1om+2HRQnpbvmQ3KqMyrA70Tg+UXK4c5l5aqPGaSoha+bHykDd1WApKVrky7gGya/qql+JUpBI6ZyFgYMqQFg4eOyhDiHXL2KoH6YqlK29iISBuv4e8AJ4uVs0+gvSrnychs3aHAfC1+Ls1qSReUtYG36cop6PLZbxl00W51RgFAFBHb0f+zhX2ik+BO5oFGzXJaPNuPcmSV+aIWMqK0Iilux39AZu7d0Po6X2TLy/G++HoOyJaKvCGCKC/R/zwGPPFHnBFAL7YcNEY+KhHRtp42XUmLkXepPt+tTMnqXw0v+c9MIdRuEQqo/7qx6ma1Xf3iglSWkLuYqk54muHSFFJjX9/oSTjJW4xLhuz8P/hI7gIF4J2ob1PEucArlnleJlUsfRPyTcmOUTw1fioIVR4Dwtitaq/JGJw8E4zhHQQQaY5wbIquPdnSmbZlwopFuIQEc74Vzi7iYGzTRGZ6eKVPZqQvffGbzR9mTDi9R3IwUZALEB+/VV8CmNgmu956LrViEytac+E/8ccZf4jzNDERHDTXB2U8nuZLBqa26gk/4dCA/+igHzw1HHbNeeCHiAaiUsnQIN47b0kpT+/QXIfvN7UMavP6f+5cKqMXci8CBpBKcf803CmiC8lVoXQT1O3fEfq3FTUFh3LWpt01FOd+BI91rHi2dhA86xZgx+L4MIMwpC23qOek8VGh6IkwTS4xg+KzIYXcUPvuPnqE43cAzXSnbjFP96H2XLC5c48PG/aqHF0cnsdtxG+p3mIIE6jUH7dZuz73K8aE33gTOeBoXOPHNwEiz/fzsxQjywMPX0N9C9I59B5VmsnRaYFX0oFgkrxNf3fPeYZn0TM1lu3gD9Rf2bLY7fvCd9JXXRrFuwq5qTLpko/+ljPjYJW5kzlJS08ZldPH7jVDm77VB8oXMaYbbSWmV8FLvoc4r8f4wByncUvNIDHIsdhpkxK29fSUq/rr9Tlc3v5VKxj7W6KcL5WT3T7P737w06Ehs/7tL+tDKoFY+WVVsDGp/DKtaukC0QFKxvZ93li7CgUB+cmlIjoEhzDwCoamfcIyZPguwqV7I5fVpvuopvUMCoBxfStZX5kYKk5KnoZE9K919ZmpUhaj25z69azfXqPkOc8ejtX9JT62hGmaTujFbEAeYR4vFRivgf9xguk/AgXuNUznWi4Qib7WQmRZukdZWTCz0p7vM0HeT5tqUYQNR6ZIzn2wvn9RrwSC42QaFXwK4MHb2euuKd0oKH42eeILCMElPhUz9B/ZO/C5UvmAZX5s8KExLDOyeUh0dUPDGK3sZpREWp/imCs4oK2BdsxjGtGxqJCtMzWeVL2YPKPsl+DKt2c1NWMqOPtCiOIzljbKv8KrWWQE7eVA88j/NJQm4z4R4/9dTVOjvmpf4zqF3pKaLCoEBDgKjboht9znT+TKUfqmZRStwp52p/lpY290kIzqEMO7aQkukbmHBxs5GkpVVnqsknL4DOYLdOwfwEP7/5f5vA7xxEdZWYNY3SAtJC15kLg8pv88aKZhZY+2WrWfZMrV0oc2kwT/q52HTbV+lkUxPoOZ9h+s7zw5uDKu/YJ6N7SJh3kIOnkE6ovhgSHFyaX1NAOXX+ltY7tQttP53qAGYrBg93Any1m9b8A5A0u4EkI9xCNEnBMZTbqgQ2Td8gmwVgzjMNdsnZ4wr8jxzagTG2FJpn+lTvbhn4UcMilk2b/BQ9HFCYGhR2c+cI3/vcli0Cu8dWPCsnfhKO6yOgPihALDFFXRnnq7ZCMb9uxfQuJnO1G9LSopupbAku17IcnL1WNxUm2iF+l6X99FyVyERSESztIa9UyOWNTQniBwAUIMgXI9GqjAeTc3EthWPXE86oLgWZCGxvgMpkSGV4TcGVUwcg6FkAOuTDsPyje1wMQCrCEAB9/pC5TrjZxatIRG3ylPQ9eGLZQDqliZCYcvb0l7lDJwpOrLwPKwWprMrWzAOGhj5VyzH+qw9u4p/eSBib6LasBuHvzGS9ozMj7unayySjmaZckQtracqZuhYkjMrY7yhSZPdJ2qYN/L+JSccgG7fLlHu0yQ7UDURSCvI6RMv79zY2tzsBx2rsld6wJ/vGgiHEJeA6WBXCjFOcU0YYT6aTzMkz+r6k8s3WSHfmv4yA+WUcP3rKek6FJAs1WBQiq+7c/x4fsIwGO2lOzOiSa0UtlkzI+XHVyI0mfiTk++BmBpTlaczfXFET+0zqQ5NFfFqSykV7bYV5j7bgWSHqz6ZSwdZqjVkuM6Z+NKkQPv7YqqC6f+/zA/zSkH7hC1Ok/cSgQoB6LOEL78tSO6aT+VGUwkbo/MS6OHBA6vgKqtI/IFTc80lne4L0sh8BeAvx55Ym/N3xFAV0V8SacxdRwBEF3t7nEZ22j0scjdcpk574fq3nbc9KHdnyFxZ0kMViVWTlwWf8g4Gt5nFFpOX1m/E668Bp11m1OTpXZwGIm6vrSOHtK+9fjNIQl+f+kb2iaH87Nep2Lop5quOOhAYqdT/ykMRJmhjWzefDUY/Zd69XdXZvVzUCMTfjP6V1ieY+UJUJi1xtqWaV9+d+Imqzhzysk51KkTDvu+sAK/hy85/RDKfVDK8losOeAmJ+DdjOrDF1MdpEnQ38ntaC2glqP1qHHeIIyxHGluThGxa9fGx5MVzCNnQEOeNgxPNNv+yWQaUCQO6Z1ZypDeG1LscoW/ECRVDMaE97c6UHeLzXZ0YlDXHCpJmhDOy04YlvUK0taCCdW5A2oOaTt18DeyKDPNZR6S2qvqZmFShMul+RnhDnHe797Ei5Y/mLHOYoXj76SptJ4F3QugGBM49erkwnXzgaN+oklzlZIK5Wj9x3DT9n7stlbUk2d+QM1gUxPHPozgZGcF6R1BKQl2p7F/BvEMKKGNINi1TZwWJwaCpr4Ze9++1ZatwHIN4DbaEfuZJDXX+UfSk15/1b4EwJ0yIo+v+Br1pBAlaKnLMMvMddSww3O6hqOJimgxJzNTCdQPy6IvlAIDos8oBjtBYl28e5XjMu0Sw1+MpMMt7KqznDAyBz391rcAeXzj3KdlzgccXUqf4eRnWU0gaGnXk+lMWX1j7q2jhoeTDMNnuQf4c6DMMe0oVvkgUhfT3BhsQsqKkGczuO4ZK58/odvgh1ppgKBcPQbOLzD4PZoaB4ryGejNQxrykVzGRUFCyaDro/9xyCumkshFnJJZs3g58g0eEoZMA47VTYHbfTUPALF1oC21+A3C8cwUzW4iNw7bTpi4MG5CxY5FA1/YEoqgnkWZA/fapVXhuQ6tjD+/043wWVh1qICcpOOceD6BNDLTicTDgB73EB4EbPRJLVTOi9bqCWGfTWzO3QkFU7OZngRmm5A4n8N0uWZl703zfzKGHo2sstymUfvoBUpFW1/WVcn8ReNyaVrB2vtt1no2mS7oI0n8l56j2KzNZEaVYT1waMRm60LGQE4q10J1AGxnj5Zq/CxIohImMhCPc+HRWzWRw8NMsvEsQBxMXA1dsj2u8Fa/84z49+LoGmmYx1d08nxW406m/4nQrNB++8YDDr5ms1A/PH4MmnCZdsoG8I9UD3n+qc20CBLLE8szmL75rnA5v2P4aK6YMWiaV+ejfTr4Fox3R25KGteYrWqlHw5VhjLCcKTaqY1g5lFzxbcXNgBGkjMi1Y/AXBwrl2ALolAomiCaHuoPDA/rbNRAkZkbfjdags2VTfctAkJBqjyrHYe0xCOr9CSRSUBbFpcU6pjexyS2/xbSPzdZ3kAZLCh0JEJtGfGNbMLZjJHWAMBl7rDfvsAtKSOJl7ayhk7Mc0MHQvXax8YiiV6OBd83EEu+afx2erWa48EoooHG/C9UkMQ6ZGrOyjmTWTgavmdEkK2Wk+xlUjygrhDXnMV6R38x3SW8xDSkzHUbgmSUBkxARp49JE9E2V4vcXEro6rAwDZ4UAf9T7S+ffAXgWb46Vc5egdPRDa2u/nWztfDkKxTFor/G/Lab4Booz+2Mm0qs32X+G2Id0QQPiHvRkAK6o2nFeG0mVyORt29jiTk+fjIoi9p3+2WnYi54H048eeMUdGHnWuAVJtLRc7g1H9tbR1qMqxeyj4cm8l8hCGaVgHzvKucmhtPxAeuCG+UpLCcXEDPUit20pezz/u1cCW5yS6njbe2SQAJZQS52WnYsNnseBX1cEzq04c/nsjKK6EbhBtpuy3yoRz6vIMYYr/aYE0KwVOQohGSlMdcLEsNxa/EMYv8bum9gelgifJX4fhJmxv2/SQRMXftg0gFdgk/mtIHIeYWLKU60nKTVZXJzzcPHVMJCUCzY9PdyVw5fQE4Bq2bobYxPS+PIlVTsPf7ZMkPnLshf3xrN/mviX7OnVOXKhKhPIeHKiS/HhKSBTHiBX3lVxelgvDFz6RdmprU5YftKFobG1aZn+c3jAzBO8YlSPHMpzsXE3tmetIbg+T/7gCngaLf+FXoAfJI/CQN3EBKrdLyYtp6JmoWhiUqWDhLtsWGa7ESKLzLgP3dwGeufio/D/YwRnm//NSLV1NdhQfJA9sKblKgnHojbhjBu2NHD6uvpCpcRYnsE8djjfV9rtBaNhjdk/NXMbRIvPgqIKLenP6rKBgdzDDnSNLWwn6nSexdgBwvWRcD+P+ReWtWEeErEHEpW9klyXt4qiUuJp6uV350KwNyqo4l5mOc67kE2K6loTTBneRUL2+Qqxs9UsaersNgLWJGT8w6IJDiq5nKNPR0FLSjee+gIWxywbIBfL2cR5ucDE+E9ymdhfMqAT569VzlwLjUPMzDGHr2841ZZC610gBtyxaLgZWADZj8UwwanpXDP47VLXdtFs6G+y/aQAQ1WYPDKZx8e+RigeLjQu5n0tPJCCN8ygUSSZy7SOapqHFrLdl9ro0GdR7mg71d4ZHUkYZO6oSX6yKqyMVWLTHD2/bOVdXhYTpq0mqsVQNcOvhu18VDy7fWlmM+W2GkFSdd7hkr/ULexW2nKM8eml/N3NS/W4OFy7D+L5j05hr5Eh6E8dvjU1Bc433+RX+huCcALrmbd8zPwIfR7/SKkrucajYhpyEw3c67ipIuOr71Zca3jaa9TkmDoSJNnax1RywtdjYY5eiYrKjAS05pFlTjow3MZ5wVea+/JMB9ZWElAqvnSOnM7e/uKSAK+CW0hKCjw6oW2+fN+BnWbIEnNxriKcJRtIA7HFDPsD1Q03MrzsyxEgkh3Y6VDDYzVBgz/LCv6wI6F3t5V0LeCbUOqCaPKlbbPtFAHFJayCTH7w4gkN3exMvPeg6aP3IbQIV7fMPBVrXIsVj5pu2Z47hOKkR9ZBrKRbrN4kFordPGUPfLvthKivXBgetp8Ma6JUkpC8fyWEp+Y3DQAAIk7vJo0HZ8+te5+YcRbYtC1yKuNut5eRfjILqlapzJoFvpKGl9GnBrgSUoTHxLrwL0BPGuPNcsYoucicmkVqOq79r26k9sXUcS1gPP4Gv5JZKDM4f8/h4C/l9TMWxwbo1eAm9CdMJE9JLu3KPs4cTY/ahiBICT/lMTby3O4AFrvtqy788SLzLE/vTt4cBi+6Wp7CiU0QnDg/LiniBD8IpbJ/wah7Ego4kr0ktzTx8aVcZoKgaB2b5jYgaan+soF5PYb2MTO+GAaJ7vaNnzGx7ejj67ByYPIuUPoUrAqlIibtnW1hgvrslgOwvlAYAjMmvyylPyHG5ZnBGNUDqg3XDqvk9YHGXkfafe/NHNkKSD7vScRLp0jdFQT82EOrOnTZo2445xuC+DqD4HNRuL6qxG+gk6XNd3jcm36JjYSb/xsdWYj589WejiThQ10P89yEVUTFt7W324grSLek9nsOqXbjN0OTEi8OlInSbNQwIR71cTgC9OAuUD7dq/u9IlR881ElUNiP8ExFaF9UavJXltuvDlBnBCcK3Dh7ir0NiINxLQLtNh79DVQyux5HaxHUc8JMxIav9k8t5crhZe1ngZHQaEUksrsUpzx56BUmi9qej0bXUDVeogc1rdA0Uf2q3/3KI6dBkBy6fhCbjmiA0YSw14/rhB1R1JwA7b98I7TWWoNCkY5ExhI/aRRFccnpGwwIfp5Msy5nBuQHbrPp4svDR1ZlAxBY7gzfYRjXm2q2jPvacrL2gMFNZuQCL9xaWJKfujkFj6dLUuNaBsjZU2hqJcmjqIi55dXoqiCdiP0TFi1qPfGK69X/MMuGKi8CRLg2lng/yu5bWbfgg4xV7gvlbf3eBnQ2YT6EE6OZ4notE+eSeZKynsMgzkMvr/YuXrNzUu56d/pD5nmRqp6pCprWxy0iuHpNgyQNv552LS95gs346zzRHVnwvif83Aoaf1FIlrb+6XIoupyjatUzAJ92WTYXenJNAyrKnC86JO/VgN5OnyZMx2jY9UD2qH7tlgnG81ALKK6LfaTqtC2oZhaT9fhpsbbGUU9ZvMEVL8OKCkHBuOFpdOL2PJw70y9zd2+TbDVctNES9dVQTBspaMb80hrkwMiigG1gMdMfPWs26Qwdvi9whZYewd5DId79TNTkrU62S0oexYN/6/IwJ1YGYHC9K69gDskSxgKWRaVlDcNuoQ4hTjkYmE/e+Ea+pLInZ7vS6+0dD5JEdz06DR+uP55xMkED9KYtmOCTA8M73Fs6+9iEB6RnT+DPorvQn+73ZcmgqYffIA55Yh5G+xw4+LRtaYcBTk00KOz+Z7wA3hY+fUU6o6T8mXCyK40v9kO3KSPYgiawlM25Q1Wvc7542CCy/VTJAXHKejuMxMOfW21uEA5ClvvcO20sOnDFMakMdDC9yZoKWsemp7vcOmPoNwdi6j1TASYGMcts0d245qVf0a8/mhfbLvIXCttDI25Yx1vQ9hdXl+AtSJNUn9v60WjXKRPSreJgae0QNG1Uma7hzZ4dHLIgYQ8/JvIHbACdydy+FsDZk2W2RGgZoAHtyIz/mTBiiOCok50vW6ph/lJDIP5V4WBBRHSjHa1FTFBVdMnrn8d2DLUyrF2j9F3ukwiJVIOlwPoBvZUkFGJqNR5KgBZk7OO0ATytSntHaRdCKlzK5bBz624lIpn15G782Iq7DfwNt2HSyjEMXZvPBFsU21PfvFPH9gTcXu2dhHQE1RuSAA8Wej1w41JbHwRzxueIu18kenz+vkIVKOj+tDoBbjBM6a6sOR1DIrqxv1s1RfyOiHTnh4c/Z8tSh632WFut191knipvFPsRu3YGHKUhPDdMWb5weqrA4Y3RiW6MCDFnIsWGw02yMcRbGb0YfE38fAFj75weHZ7iM+imdTGU3x452xV8RlFsg6H3/w1FPe47mruqllX0mtRBA1x4BDIlcnJvHH6ab/NIpoIJVEsMFil2PWWTwelmlSI/ufoUp5E3o991uMkLoYdV3JX0VUEVn+wnJpwQw6ZVZ0Yac5txJjHFHlJVBDumz8XvxHicH7NgtppSSVVcY3g8/iZoDbOtCPSxYZek2uRI2zZTWYKI2UHo2etQJZ7qllPcI++JLsTufxHwPNDFdRBshy+z3bzptrUqgWokhodzoxr25mxi+wV2cTED3xcGmr8pXN2zJCtWWLibAsXdqxj13GNLOrVwnDXjASv1uLEbSVglO5EXgVbs3L/Njc+QMrZ3q+b8rZcimuYPk2uSrzaJk73RgfWUJQ5D+5eVnm6OukbIyjtF4Dcxa/YhsyQQSRgBBK0GMzMy9sY7puCd+gXb833whmgaED/LUH4hcwix1HpbjhyGlwSjTTZd8S54Ja9QG5IdQ2DFig8mRmLRMSYbFPqhtIHgtLEaE7euaqtqlVffkLwLyR0QO9VZZ53xmg5KiPOSL1lPHJbzWRBFUXzH5ERySZWp6MttA+xjKzUK6VETgFIoGR9Q13EKco9U6iVaSmawYa2ozxY7G5SfYE25hpnHAfglFQqanUNp7yP5rIaaQrMToWLSb87XzGCsKUwrUwCcNsSvxNdl4e30BtwC9+NvniCmbnbUZajJBXEtVkjxoUY2Fjv7+ew965OvsjC52vluumMHh4hU+bbAvPlLRfWUseoBgQHLRUwE1FgcMvG8xt+7L3LVtRxJ82AtIYJ+S8c04/7EdExSREkOMIrX9/p0QVkWbCOjiFTgWoolpxKW+MA2YpbQuNr3cly8Pps98aLJ05O66EE6/R9ZlsvAJviKKbMlya2BAA3IlTW2xG9HXXcG/WwAOcHB8s/j//YJ+QfKSzgOaQDPsHn6OEalSCavxqKXRQOCdODjJSUxp9S5E+y+C7CjyWDVgQKjzs1eGYNgAmOLzZvZJMBODxe9DDjUWBFQNfgo3lWmhWJtkmFpGUMT8pn37FWmqU+ndTugnIIHywB5YfNhr+t6wyCC+wwZcTQ1p1/9440frklq+NpeI4hjReCzgUxwMKMHBiVoE6PBpSQ16aHLejn0pFko5MtFoweId7W0MKkztHmtx3Nk9OpydKZMw2TmurzU3N//tRQzu+LvvoKYfaRpduHeAxkvLbdWfSm1unWPRWyVwEb7AXBfwuNiqZCryRDL52SI3bi+PKcmVmfbpJXJqy/cweN8VR3UUHCSNfWlgcJ7ZGHQAAH4/nK96BFZzhofNt2Z1m0SZUQgeLhB5pns6VnS4a0WQ6paLCoUAjvyclXEpW/TwfxmOg9/DSaYd0X758oLi1x/jE6byXdpFJ57pQcdo6ajKNnRyYvcXtCMbpbVAhjZ1X0XjG5xH5J17GXcB0MgaVjV0MO9yXU0VDfdARw6CEbS1AoDVgL779+bFyM/Od/H6PSASyQWT/bjTG9mGFOh1Dw+QYROtORbVd/rT9wKrROE19uprG/d4ettmlpx0+PrbfKEecnvyVeiSarpKcg+d0SyYWDP5+NJ1D8Y5b+OWDk78vSWv8JB7vioPAPv79+cGWZc+smVvdQIDzmXUr9OTp90UYhr0FYp1Lv4ICFuSQgNfYk0jRpHwPUMdFSq1ZfYSBQKFJZPggOBk5Nry0j4w/a+tVk+EOJnTHMpicZGPXwQoglZOfxBo1srmuNX0rEoM2dTwDcwRt5qKR7PHRsVDjyh9+QCssrKWXGPbdpIET5zoB9+K1v8lmE/AW/mEMzLoc6iS4CcESedRZZkVxxClq2HjOcU+r5d0SxhgmEnMqTOui2tHlIbhWA25Msv9NRsqX49lcOUBbqlyO6B0C85Da0sNLt2tJ0KRj6uIqXVkco7/Fpesk1ALVYo2fhQBLO05Fr7HaenULt46XF5Sl3TKUBmOfOQIXV4dwKMqJ99Hd1fv+0RRbUDtAKeAp1+BOOtdDhDzPLJhZnqlU6UNbK+SY7VEqoQdQFu9iENb6IIjRAbbH3T5djf9NCnfpa5fHmTvPp5uZEgofJ/K22fdbnHn1UxH3q4t4PJb44844dQn/IHR9WWF8BT2KZbPVXKu7cCHJCtUH1jGddD+VFn8SFGv4vUi65G6efFo7vRPzkorlGcpEAcJRcWOONhw+TrW1aeOboXi/YwSHus1FjC3wyuKqGp01NvsNDW1Dr293mlmhFua3UEsJTuKIKfV+//0E9zx92YcENuCW1FXqGWRFBAs3hIpqnI2hFV/fQviPtzImiTLkd6bwtHhFXzEwkJzQ6kRFweWIJo4510a6jR3BRfRvNwCJcisJkTbijLZMOrSbhMQ0RLt05udUPWKKLomHzgknLGuWfu17L9oQtxADu/baFqpF35VzmW2grkdShXQgTJ0T5WsNgELaMBlQy/+fLhk0vF++3kj5zrHqs84fD/CfhT3MLmoSw3fs4bUfXYVO+Fo5CSMvjPfzyXKiywGujBkfUuzZNyIM26VDgIFGHy3AaZs+s92Fc2efy7mWfnqjm6+zlDNLmCmg3vyqBw5VCDNL4tRI+WjgXVbkRY5jdxOAie3XRauZKXz96Q4jXoOGFEtEbYANtrhxvmrzm4NFxyzwraw+eAV782boNeaKNISBjxgHn7bp6LcGQm/ESBtQXMQ129YpI/EOQBawnnxXaWP8zabVc+OEnpnNqhhPVYly839x82ntnkn7Qya2B7qBhP6HvtrtPq7pSsxIRGJFj3l3vShkF0zEuopFgIZPWJl/nnUKpyJxGarAfr0WBvbO77nmuCxIl8dSVKLzaqD9fO5FyICos1ouHM1a2aJsEXodB8i7w6bkHdTNoiLcVFXz7VyxD/ci4OZe515ttO+MMZAXtvOkqwoMNCOFQHFxTiDIZ8SC06uamEqJgYH4MKHMrcpN2cTjdgtl9UK8GsysIpGomZGtFr6FrEnLZUUp48vZniZNfusTrn1Z4ez2KDiAnHJOm52Q7+EEdQeRcop3ellmhIz5xJLSc3aVSrSck0RuosyBxVut/TO355oX8NQ1YG9Rb0buWKf4b7ZaDIl6MU6wwTCMJS2VGwOMwmhj+4ViJ1QdpBViapax0sCNoZRUXws4xLdLXFskV/A+GIItNsU8PDtqufkY1ebJCkSgQYrkAShDawK6K0Pg4fcTNWgQxNyXkPR7KF/wYsZmEcJ2nmF5G9n16c0qBoA5JwkgHACSwEDr3UOxqAy8xENyE2Y/OJ91zL7jg06CCtMO6/glkcgfPmiKhr/0CoW6vXP5fpprrR7xTe26DauBaVDy43OCae450UuKwWSszXJYOscn1qoNpEp2AZpM6moBCH+M53xhRXrJqWBseWotZx4dbc9wPXf4kgUaF1psyo/mh4aX2nH9zGTNVhOXkKNimdvywhvDMjJs7yWf5F0rtJn+4gwECXu0zB+oBlHHar50Xw6CY+zRYiUStHgGmj/X/ZPFNFosPr+lasrCG+91Km00XZ5Y0aFpumTyyxs7UOKaBUb8+UjIHMX+JitTZ9zPU5HPTbA381B/4DjiOuR6jktUKQZ2yqG7zW0EQvnHj1vWZkKxrzsFMlAGULABDQlfratIi81gUVL9Y1gHVg1hai2VGpwbbYRjzFAOtXtT6SPU6TLahkInko8UZBFndoH+EZqBHjG2XFth8KHjZsZkprR67H+7oKouW1iEaZ1+s4+YD1STQK/nQbutkGMVYO+rv+5k2wOXc67GBiweJoBWxzmdVwe0DlGEx0rXSCkzr63/qvW5v/nmeJDVGXtakBNldxvzqO76XqF06UXsWiO4NzL0wtw1oSKNq+H1XykQ5I/Tl4hG2J6DINfhTOdk87ihLM6wz9PV3txszzmInrwYXEZ0dGeT4FkYQDHDo1G61Sdna91TOo6v4uJTraO9m/Ol+SqnYeeowffmWjBrVF9spLH91uKEtwyZKZOrS0+xyjKzFMq+QaFoAh6XsZX8fIW1ls9m/0vDJuccuESdOPixM/NuARzJPWFjFIUyA6MRuyk2wf4x5RtweZbP8xjQL5z8vF+Xu8ZLG0mPTHo60BfW9nm3gUtR7hpCrKPLiBDkOB4OQqrmc+9gNYPNF1mby5TnO7WyachaRZBd0lV/CkNLnHAHy6AB4jqey8IPZJFq5s/Gtb8BCFw4wVBX+724RB/uuM5JgRm8M6hTRY4/9YlkqPMcfhHYwWRD9mstvYClk5R6PNBITnzwZzjIsay2XOlF8Go6r5r7RQC4H1K8PLIp72815IzzFUDTbmi+wb1V/ve+nirtDfWq+0VJJd4J07RuMEc4s8AHysvgqAyDBz69HJmD+kvSE/ynldIykuJFK6/76EALuyCp2VAY+VqPJC2Ea4J0u1a0I+C7ZcvHOL0+egCEeIgNbywvlgTqBv7YxXW/77ipkT0poXQzQjZ5VAD78wsnOs5e3pOuMcsFItgUeGhJm9pxkYQbPvS7mq/Mw2FSq9PAfzlFomaP8nNCsaBsxyHSjgUzfORURBaRZG+lWO0X1fnHbVF3dSvKriWq4sIgkAJDuNXySzCI/BFooPvCvxt/R0pADwJrgA3HGm2Exp1ZVWvO5DqWGkf1RJRaEYIf44ewl4HQO295BoaJcByoxhS9EOYw2SNidjkQS90aAAjKNdoUhRpYRofLlbAA9wbV7r6SJI03h8FEjTcgsNaJTsD+fLoMxkoqnq/2JxWQY9mTZuFn2sZUq9KPli677+/fTYumXbU3wYAr3TzYcv9FOXK5v3lyo6JKbnAMuAczbCVhYG50H//SBYw+JO7P1k6f4STHFXaShXe0mMDvzyhKffGiAU5uB+QmWuxRZ4pFbd6E/DTJkR364nUXOwxdq/mxzkUUJBOj+YFFfwQsvMulKQP3qKyc0g0g9XkW8BoD50BHXpFn1UyN5ouvdd7QoZwTlI2BKKPIQXtW8Y5pbiKRmb6VOEKJ+MOo0fkjP6hmP/sROhIqb1kwwqWiGdFenkR8gvq7o7AO/+hI6zhr9B7qOJ6Ed56yHFrap7DQUlBUf39foR1XNcU7g2rx6Pnen3L3RDpuQ2+VCKp8eurOx+HCX67oR8pU1jdiQ4aHFlB69BJSFROtT13/JQWV9RhhTzcpmx0axA6wRoLxxOKGOwu0AfukaSsZ+KVjwQ3KH98AjrzZeiqM4vxX7LtQ7Qemr+x0ExSHTV3+5RUJsZA+xvz7BlzNtDehLiMErG32YtntW8wZBefmlpCE4ejagTqMjFMEMB4DoO7xVDBVSe3OHHg3nUgNqOEUTY8yLUR/oWHHX0wQpJsnLOlmwl+/U0JuQRkOVbdzBD+QpDMb16r9FYg5DiNq9IbYVRVOAwtHbvb4YffThEtXmmuB/gipUzQ4wR0Wm8Qz1dO2wC51n/Aut+l/sRcgQqzLExIqGeaRDnAOhY31VneIuhXtvfyPITQhow7WxMCGsCA9SDw+Su9fas2GxFAyXJsUMG7XKMqtiI6B4DYQOFW7ZameIb69saCPfanPeBJdxInvVZ6sEFAHQ/Be35U2ylAQtpPM2+YpCf2ivTJJOPzkmqZ+AgK64G0iu8GT7KIEBlv7lYLfIFwH9TsyfvybJHjqbfvbaAZ7DFMw0LXoXuFmoFT9wWzS1NubWJK0GlT8mD7+5flZvr64AH6OuPpZPrKQMsQeSLyjU+VIGkVfL4YGZOE9YJsX3rGewppQjNCThROHwQL5Pei4ksiHX/TydYxD5ykp7GMmEGeK7Q770VRAWUV+tcfbAYVRVbWBJ/A8Vlat7/VTtnx8vxzBgAl9skVvyv4kifG6sAe66JmTBizHJtU4tqkXUV51zkTGYGs001zneW9o5238D6RXP1GYr5jW8Kel33ukizMMK0e85iWE/FVMiT5ElftwCBt+5wST5/rVWZmWmRNPM6VDKMt7D8TtVO4jYmWKbabJbMEZyFTxgTnl4dnf9IPgP2W78RVhcnXY9YmYLRWAIdSvn0le7hlg8g+a5iB0XO56oOelKHKL2TBVjNoeC3M4/ERqmcrihd0iYqfoQBaXVxlfa2eUguaoElHdgK24m4JjV9SfMLtbYCEjPsiDd+ZA1+v/MzVFjtBxvKGu/LIblUibfkIiIw1ZnjNEOZ0WL9l14UWo8qJbmv0hfDnFcSNypgno4ZwL84zaMsNYc3rw26PV0V+T7kSL5/6IBY7zhppJgywF0ERO/d79+zpfQoXa6i8GC95gx+8JUx6AV+6Y7CSNtlZo56e2dQfMvioXH6nSrpOLQUV50RL1k5S/FbU5ATdxKllbnMxYVu4HzhXaT8Nz8yclLod3l2qr+7C/mPA43EAyDivA4b/UYd4Y/XxX45+A5nCzmS3xOclhkDzUUrDBiP+Oy+tkXvu1XF1smTDPU5FmTWxpRcfApdqA14cg4Q2yF3XYPcpUGhum0Vko4pgFqlYincGfeePy1KFVNFJKBHbzXBRh9ZCV1fTuDjXqBOU5RkZD87e/zs+RWLkEpcWt5q2pEzbeINYDgTSUNHp3O8TrIKZSG1rM82/ETNpaYJQv3Fge/zw2OdXDrsFI8hTREbb5EomBu3+lGrd/ljHn0VwlJQ8On++8JHgUjfC4XZ8f7bZGbI3xwkp6HQ4xEby5NYPbzxn+p7AHqVlxrtQbSrwfmv289iz9tn5sgRrN022RPdAPX6FwMvawOsjCkzZbcN/zwkbmPzVNXT8siek7OerhFau7iGy+41l+a/fK3NF/7LzEYvkfMzVBU+h2Wv4ART+nlbOghouD/1/9I/zt+jkuEOGuyg4pTt0JRtU9mWsuTAd32cMm8evAdThhto5/6wbe7yGrAbR5RYVeZMgrmVftNgJh3zCFz6U+ooJcTytSBsKn0pgsLEEI0tRiKL0AvjLzOQr53wkZVtTHp761D3cXaPQRpS7e0JkxFZjGSsrzcMWx4dQPBHwbDR2X0TDcN7OgLshYpe4RG9vT+XfNzHmnEV5TW4sB8gwqZZwjaQeEkDUjo22N9CUnv0rA3zDCpNRoQANIKzQ6yTpbrFej5CGKk0v+Gc4m9G5v1vnZmre6bbOGS2eqgq+5fOOfk2mBcWNsF4WmdOQGimDFBWKhOqFLPB1VSSqwYFPBMXgnfM8egcK5Igjo4kXNfSL7kjG65iKbAYWsz1RIyQx0ag5FnFeQdepnGUbmcvPQV5VqTeCGaDN88AFych0IX4+Yq6uK/26DyUel+gk2YKiwpejqnxGP6kUSeV9PDLJH2kTIa4nqRUkAQIUJmYvSi2UQRNHdL97FlHGXfihQNY4YxMZnwg8rGkV9GRMji+GUO+ee/bN8QkCeskR61f8W7OAb18w/NU98a2VqDLg+F2BBV8a8kVuA2pQ2qqzlB4Lfw0p9PeQp1ZXB+i47CWwBKk5D7FAk4jRI0/x73hK1TEnQIB4wwNAh493gumiW83McelhGhDUEyff2QPJYJnxzSVYXMQamLqIqXddzl3oEnixw1qpqSne7kpM4D/MajplBNhHF2ve57T0JB0H56ibljxo2VaYTmWTzurLgP8eKWGgHL5d6SBkx+fu4zvbTKvGKjdAYElu/rth10Hm1Q8Nj3FGjxnqYGLBIpE/xuGuizC/ElRkmRP0fUFb7QOYH/hMDhunJiH4mhsYzaSmF3s2g6cpRFsJJYk73ox+aRhSBO4UvshuNR8dRjEvsQ+zvgibFRaEvcWWH/Gq54yzhlLIgp3Kt2KKsDBAzW52XZFfeJgb0UbvPXrto227Ftinvvg46cR7UbKgvva9MNxn8E7HwHa5niXgwjiNB2gNIzSXPioJ49VHJ84vCYDpuq6WOQ6ebGB3+19n3MYBTTxKEzXhdFY1urLqxQC5cvz8A+koEQwudpA4Kua1C1DIc0EZqSSArZANDkieliEwPerPNlyzOxulAm28JZbOtW5LHYsmnsFPtUUEMhqlmLJQBPSD9c/85vJ0dWtjpLA1BjL3AY0JAPZgl+CZZRttZ+lWoYIyp9r75cghY1vOw8zbAamaueVRHKQP89IPS9mxwYWkIb4kugiyVpAlLuwixt0/aDro+7IonD++yJ5aEMmNuLYBrIxTyqyy8qCGLDVCMUk9qv1DrTtmRKt+Q+Av/pWQFwRue0E4gJ0oQYPz8RfUrsjDRWdCK0S10G5D3u11VbaEi21XiEiDkMjVY0RPoTMBfAXJsNMPT/I4geJTqsLuR//rxNQmfEERdAarjZU1lbbTzvZUuOOeyJNeKFcjHsGaNGvz/7olCylONZZ50cEKV1yLzoox1a3a3a49qw9CZKo+ATjEs5oh1V+gzGKV17DDOmzHyemosd2gpIacgf61YJs3tgHpYoKtljAQ5lA2FGJxX5GY47QN9VKF6gQ59c1/TUYDWWVqBDVFyCT4lnjF4J4ofevWV4PPdJV/7oSt6AJI0CN4x4xkSoj848NH2CxoOJn8Qv9nZO9PqakgpF8UkE6ZzkbKW7AsBrAeT5m/z9z5yKT1aF1OLWB3GPX7MjxWPw5PV32lq1Ri569kzx4+OqRDY7gEK5Ft+448kUV9GC+WdE3PKLdMCPLSLFbincTOU5pWlPvMPl2YmLxWr4kcP+yoBtkWe7OUfw3iQVPdIMcWeSMZ26nUnA6fQl3Dde2EhUxFBQpm2kWztYOGWiLHyHdEUC3twNsx8IkuNJjw2RD0Wxzw+/j0gXNHfIAWPY4xQO/fypinyvDxGuBJeOoxtBMWY7D1BnwA8kGqyi04AgXG7y8vnqRhra314Lpxh4rqfODdHk2EurouGoCa6sKW3OZ7ZSovbXyVb/svAsv7SZUMMFvSpFXTO5yM2VDXhQOvXWSGWRTrGvW+Mn8OiAaFU8J0kLKThyVbYED13qr9BySwkh9yxGKBtkTSvOmc9eT13bXQOF5dZ8L/XLhIWBMJ4fLUPYXVhOmO+7SDsQy6i0RXK5h9xUlv8yJ9C1v9ytcOCm4IigU2/wL+NmTd6iJKvkwao8jp9b+i/iP/cThDPGnO2ht+ERMZuVe72eh/0OYJM5B1ADHto4Vz5AIU0ASOfJB7v9J8m3GzzNCqlGGuq7nRN4+KimmnIzOgY7cr+J/6697fD+oZjzRJcOWtrolAYrVfh9Q+fUZ2OCGXRf37cpHWKWjaGMuRU0bohzLfGru86xzGdCV/0XJakqeZWpCWMHR88ori2c6MVtqD6oaNaxh1ZNSW24CYF7tI58gvISY4rvhqeHzcU4hewQepEqa5RZAnjt+4FIHRxFzh2Glw3BIcc7sMBWkbiEKzEgnFKbIxQbrWthGJbLg0IASHSvqQpa/LDgKMog7WyUO92Z4vVnc/kQClYLf08j7Vv0jKVNKwxnHsderUZiBe9En134cC5ZfXQ+OiGWaDCi1qccz5ptWm0q6l1GEVaXOVcunqkUd8UVRirxjNd3rDY1dJVoaiPpT6pP+Ggk4rF8kW/i+9AtQRVH0rtja4kShq1c+CC3k8x+Wl2irzgZLMXyXF3844de97yaGpTsqURnujZn+q0y2TUPs2K3KtDnP5HdipOvENe8oU9ddtPnjinkPwZNE3L4rO026HFKkDEB4SpF6WXTF0cUHFFyJOEmCIVToWmorFgmxUhd2AUbPWevU6FWv5+tSr4n4xFMvyars5QwIRX/8bLv/UJxA2xCc51nQxP/DjK4ZQyyurqx3YcFXrnOrRnfxNwjMuK6vBBbsjnyLzG/TWS5kGRcuPDtqa/TetqPJHhJhskIhAtltBi+9nUNeA1GkOTbtWFoyVwI1GwjgEN3LswgLXqERN140y3nOaUt9xVKYM9U//UMhMKgUnh9csVRQl+/FlpQzZ6sjUG3jpSHc+EV5iXShIVm4/plxnwGCv7nHnOnVDADfF+dtleZlUbs1sSfgHiAvU1maTjzSJN6TPbVqFHB6fefaDni29C2/4c9XHBCefYECZVfg02ZL2wi8DRwk6sT8VV+oqckDxpMbjxIYNuUdqq39sIgDHG9rZWADbAa6dZjVW+QqTwFWBTZs+hSu3LjIJCnm2StZYc7atZrUqQTDYRsbEEFXQOPV/6/NVqbS1Bl95pYrbnPLJR+TS3y3xJkMrXRPQP7vfDtK7sfogNjjn45sfTJtNw+18zdJFSPuK80OwRtMP95SHpgMpQUD64RgNOUqXXs74ZS4L7vcqGH7KmQ5Vm+EuU52JX7wt8MhMUzZwwQJC2nxSE3EonVqvnDunpPOq5f5OqUnhYv9Z4mSonp2JxJEkZfadRbonw2GK1acRS961YNAODi6B1geXnygFIFFwBf2nisdtM/6TiDJHv+LphPsG4AXidyLOS7TECxhldjDGeyg4+DIvlevK8Zh2Xz1uV6LaMmVuTVS8cxZHCvfedspHEMS1KNCIlMqP8cbkfFM7A0cXVnKaku/2a2kKzWKegMLm0S5h2qQjT/vnxxe7pFBtI3cR7kfOXFUraV1KE9FlE5KJpkWxewSs9glJ7EtVOBUQ9Ly/FkThR/56jGekX76HMbQ43uqO16eYBUmxfKT77g40w+pFHm6+6DmcISlBu5d1o9Ch9Cn+ePj84/LB+RTgFtgbS7kQtYuS9zjzptb4/orjctzi0k/0o7KHzVrxviBEK1Gjyz8Z2BFPOh/j9WcCoNgHGQzdHFnJARzKaBtCCj7IF5tcsYf4uJ5/EWrTFx41XEb9xqaW96y/Q99iT/Gp35sT5bESNsRQ9dsT/7iezSq8MC0unpOXlUEn8uWOH0qKopNvc75a68hBc8NLXwFnDGSe8EnHxOM2+AZZ6j9+gd0ryFmL5kfz7Rn3EuFig+BJ9w3rPPJ/uLTB4Oo3S/SMPjym50rP7EGgn2kXA2f2uga07rOMF9lyBD/qZK4Z6sLgwFEVxWjxomqltIcu0xsMxFm3ClmCfcHW3vkHsHYvI6IZJjfWBFJLghiWTYPxbnqkn6hP0TStFqQRwS8vfsend0D22+FzDRmNfV9EeNfVsjT3Jysu6cTmFN8Dy+sRgcvxBQ2uVlCFUo6rVOlDDRPOpKwEK/F3J3EmXecNdfC1vt8hzpkE2GSgZik9aPM2izbcbg4AMzXEXrFGaS/DYCxm38jQPab+aUkLSzmw7gE9fzvLJJ6zyzp6OJj4TrbbvX+eH33a2iOb3pjz+FiVZRheYvT+CM12Oupbx7ichvbgpRPOVihGdN5Ww371RqK4WPkEGo8wZag6AQq4X06deW7fi9/qRmuWWaXyxIQoJm/4va0Mv3IxbyIcPwbT2wVR8K62Bij8Q7LglOl/4645DY+UCO4KFM4MDSasuFeVWx+PtX1jouEvquw4NzfwWXL5X8fCE+fqzYk2Ginr5URpC//iSgnBZC+c7h9kI1JlDRknWsamY3wNxw4a8ioGDARuvQ9Le/bvQPyxy6csYIlGsLLpmvHuPCt8l0GUBPTDJteakDHN2opMcED632LY4T4MmjbB8B1qnM2iVqWB2eNchhVAaZ1/4X9aQpQzWaaR3B/JoGxUPw8hyL9yLHq9INosV2lFhrvC6iSlhdXqT1ezAZCavC8THdj1hMajqrcKalTa+2GlkI68ZjeeD2QDX0I39TnW6Jfbf70ysp6O3pqxlsQjGjOt4rwaAbcmEZbjg4VH2m0Pi4zJ0Och4DeWlKa/YxIlAtCHJnIrXUOT289yOjYZfZE+B/92CX+WuzyTyBb0tnta1ZYtTJBmIUZh/eyzz7BWni71LGttkok6lzxUPHOSClSkUaEgBsOrL0jVFG4DrfzeP5DB5gwX3lTu+o05/ENP63fntJ2cEsRcWZLGITWz/Y1jZTzgNNclmni+tqeE1uIYloLcn2SGvByKD+1WJ4XpGGQVsjpO24R9rcl9Rnqh/Yz3S+iI2sf87JNynlPgQ+FpitL1jpvHLrnCpnOVxLZbe4uPu0KAmjDI+VPfwBxhZfW6uaHIf6Pnyy24mutWyG9p+02sql0j6vzad57TN5xxTkaqpbVDe4nfSM7YHYd8rLtAsoh0Z1l/2cPFLH5jnsjhohitt6z0/bQzKNIG8eQR5bK8bnJ0cnCxixF5ctW/w3x1Q4nu4agls6qheNMaYER/CBMx2qcHtdyYQ8jY73MOS0210xUtkIJsUbRcKOe4aObomgIQN+OADTueTItJBr7VY1979X/3OF297SiDN4J0HZFfSRBdl9/HGqn85CpKxCPnZ/vuOraUyan7KuDSaiYT5zw3ZphP1CUH6RtKYMEARRsLusIj6YTSj1U7FAkOibH+MWEN1TUVFwU8+rLipkIVqnZLRpVTXum6sDsB5CmYxAEo89zsq9s4UNMSho6AUxtRntFfLDEFnYpg5wpsofM/QuQwcwwLwxqj8w3aXj9trXWApdT/vusdvYMBBJhlaUlp5LKxuyfKXkoqfu487OXKGupLU+3cS965NRo4xineGvNo2fFg33f5xf189vUtIF2JNzPtRDRvtIkfAikVZsDk1yLKgP8xHscZ1jwafPGTrrgTUcndnv68uKHpKPI/imOki8rlnzOWQyU8aCH/kNp6QZfYL6YjYsQXb4dfMo6PI2KroVd1bSTggCmS8s+r8eGAEhuQsUC5S5ciVl/WJG8+7iuUh3wqnOk4KjNLbL14RloqJR68X4edJlwcVIDia2p2gMIu1S9PuwgSzq8nh80nwEet0JK1+o+99kmI4rEgIPjnO6iSH2hooIkqH92EaUlc5GeOxCRMeqLWFnicTn7Sti/0bU6S2RsMRALPH7z/PoOASe6kJSEnTjki1K6kH5YlO5DIyCTmOHmutm8nPU2Pd3PDYb8+Me8RwOkbwL6CguMHVP/pBU0iBAndhNZO+O3pf2m9hguFKRc80reLZFZuLu0FDkMJpuz7Z5nNZ8RT95BNXLz5jmJeADdte1hCkfTUIsmxsbDO+Y7CwCIYR9jX7maVWVlqQ/E8xkjaUGgBm4Gp9x37L/BDNQn7dNDAznInwr2DRnDWTHtvXeyk29wPNsPl6a+f/QFPmD3Ci0SOjwnEKUgzNOlnyTiin7arMYwAjLjUGZzaSE3ed8OT1SGLSANdFwah8DQY9o52h5l4jMCfghneSAN+5+9DB6I61OAt1bv89rgZPlytKn4TuoBA+ECFltUa3jaTRJwwjlevWDte2OgKE7lyrSvh4kY8HxRFpTrXuLTx3uB12xIMpqukiKhMHM5eSVu4KZUO5GwnrF6xqCswjjuUxI2m2QWmPDzgUALt744AV8PxTa7I2dl8l+QyzC0OOtn2eP7cntPfFBgMvLQiHrUKjzcs8zjyLlRFFRDytUM3zvqB3/iEFS76vo82S8i6phBF6WJCbAz3t7FajUQ+EmCEPHXFKQuEV8Vx0TcRFX1FWh2BVurHeuVRz4eCeagY9APBJOPkscaNrUuBKzzQV/Hp9M7ufXU849ywy5aQkJ+O4swSJTgptToyv39RAgAMkRFt2Zlo37nEpYUR15i/0LvWWDfabQY4owyDAOtNwJdmSJZIl+HJ7x/539jEoeSmwgvLs/xu59rxjqDxalri4rStLltjx9HU1Dfy2teNIbvtaSIyS99kxQkyvN6sfMzN5p4zxk+Y0Rd9jkuFvRLQZ47HQiJRjVZedJm9xdPASI7DxtqGzDgJ85tWVfcC4Iqfv2xtBwugCe3QxJkoZmvCmbwiSObJc3VdXTY56UEqIctG39QsrDegalPPSUPsuf8SHpqU1/MKaaJzboVMxj4OYiAEJ2mkRI6DA7fr8SnLC7VZYlhhPjP72VD9ztwdjwR5KhrcdNBCCvPTNSG/qJWBaJVQm3IbBGr36OS6vcU4zbpXuOTGgyam0pSjTcxP7F/2tX81EPOywFmRGuRNu9bZA09W0vDUYSljvXGaHXHsgP/KugPr5crzuobdPAVeXGnpzv3PPCaLPHAMyjJpuoxZWMhMpBYa7WzURP3O+dVKC58z2V0mx6QSvpnNr176lCE0Jk9HWkiPJOJHi9ykaknNTBr0dn6A1JEBx4YWv2+MpbZ1dxFonhNBP3X1ZIylant/XzC546LFe7Atnut8B5AHAt+oLLSz2aTzMuzrVT74H9MqLnk7kXkAd85hmjuKss9ofSeXbz60bf6a0D49dNct1Ce5IudiI+AzkncwF0lYgUdvOqYxpQUkz86D1qFXWOzwUfjKq/2vNE1dXJMbyQ93crCXZJwr4MUYPQegR1/FMs3Q8k7o08NnFBjDp6EOC7SZJvN8XVyV/zgj/u2WzzU5O+aaeOMmHTg1d7Kfhcst2XKmpL/IrswTDdBSMKmMaeHkFM6stcsSwgyy4XpMrVAN637GKRGzq2JeoNFW+JDii7UWPiEVP+PbU3zQmnEwPjO5Kt49AOs3y3TB5wsWt/RzUbjQBJVUk+Hlwas8nIo44HdrgADbNOaw/mKIUiQ8wU21N5+xxzXlrSNURxIMQRoT2Dabwn3ZAp5QSAbGFpH/+S4ujOlb6+TjRVLgBf0/vcWg74TDVPv81Oi0YGV7ZL85dOvlm3Ixxt4CGsRPKt5HEHohx5/aaCO9HOBPpViFvBunBMRB9yaAOZAiVCf9fPL/VriI9OawET5Agwrclha42V4zwyTIesJosupF6h82biu7iyKwuGgGvkQndfbXXOpOx5T3Q6zlpHaY6FriGi1MmujxyaLav2Cv5gDtJ6t5r5ckMuEvCb8Eg6kJXk4ffKNEeTwPehoUK0iWiodw6R8s0SIJ2oRcrRVrKX8iOrd8mYjCQZXgxiajClzyOUI9AK3iUD/5Kw6AOKKvExDwO3+iieHAT5GfLL2cyfNzfGBTzms69SLklAgOO3vnvv+amUGBGVRn24zV89ProeUDuQqhY9DFFC8wi6uNLE0i8E9kS3saGzRiBgjXp6dT2gehgHQlFufpkBdHCuwdoM/ujEHbyXNFpT7z/41NV0ukLge8QjlMP6SdoJBfcKWab0jUVY/Z3Bk1KPXPd30Wkfa0mCCAOvNB+oLn7Q6dKkxGhkR13SaSUbzs9FrWACWbxc8Wjw9P06iIjPB0QUE3zYcPJ6Umy612zGn7TiBjax5E6LFy3CY5SkZIZWInuy8sxVB6oYJhLXpH/lOKyW/sjq6yR/flKFL5SmSb3N/6iUmq1oh45SZ8+nYbrOSXP8BMTbSEQGRjtaCeEp5Y/m5PMyWrhA1ng1e+ZcWpE49aEPJWP2RdsiiDYydQNImZddqglnj2LuJJkKi1suyWx0fqhYBV80gNWlNBMRnckWy3Tkub6g5zq/3JIOy3etNqnKZiaIadzPmhFoMoQ08fAIJekf9+eZsiImHcbMJz6iZ7ErkAkbas4lCc+uD0HPztieYwA0IqiE1tO997E76Rz3DWctJsh3leXcGhzMS2cC6XOMr73icxzq5mGMTwsWNU0BVz34GukFgPCpHnjbxyXqwN/ODi8bZlar0bYHv+Skv/DOoGkpwK5u+uw1hNEQNh+u78Fx0v0l/upw/CuCg7+M9/pxrRI6rPomubUXtRG+X39ZpG7ni3W6XaUjjls3HIpBMuZ8NwXXqFseLZGPPxwCG8j49igtgakVBrKNE3jmEqngP90Z+Zbvbf9M1XCJ+Kd7xakqx3J0NkIArt4GnnJDn/+rGbB6RToXQH1ek6CZUcbvZ+gHOR641qaGnXtGKkzToIgXHR+vV0u7LyUi78taIekntxIhjDohX4iQqMq4kCeYZT8bHOIj6Ds4rV256mewJcJFS8z4Lz+R5JbzTE3z9pNPCd0LShEhcXMpdHOZDe7VVJLV3qqCh88qVv82A/BpolPTfLOlnZ9pf+fPh9MOPXCIEh9e025NGWir2ny84NPK+0vhs2XS+xjQEmRuGV0jYEWg+8dnp60Tdd8Ei/xPimFrLX6JOuDT7PEhWXIzTaKm1++xgEaUH3OwdOZgR1ByU/EsgtbDM1kn2C4pRGlzRHazd/v6UoFYMatDXoC3HV6/FGVk22TH/hokOJ4lNFQSS7G4BWWqZyYXMAM64qUi0lZTgsvXMRsdfOaPA7rGagi9Dw26CDkxxu4YScFmCrTr0arw3egI1do7pqIqwju6mYWHCC3lVvWh29czZAVQP6ESz1ciW00TpKXZwNqBqCY+YXN72HPKF8lZQJr005NMOVKG1GhEPfdCGhA6b/JieSSNx2nGoLppx6LZpGjqIhNCEtJxs1hSbq3IIaTifA5kdMCUE/2qHXaW1UmKqWEW8ckawK0Op2OuC3rIiTJSOU9CheMukkekoL5C/PbBcfWOWY81TEDhVio/1Xxr5lFGb8pzQsPJfiqZ31G9sXIYXl+gdJTooQE8jEScOACf4soO5taj4tUMyUuSMWgZhbRH2dFCABVfdbpYozVdhrGr3jV/53qoB4VQfuwPSCH5S8E31gjiqhhPXtqkgi6i/xovT69/qWJLakGCP4Mg5iJdiY8OAP7mzJj24kUVWgjag0r/L16dDPkkxMAYMhD7b7TP4DHvduGI68JKdHGebdYJKlItxEZu7LOqJaw0Z9FzkKTpukJSmbCQInN5J4J/kAOzinsZ9Wd/9dJQMSra6BGkFPBLC2wOkmFnjD/hkeSgVc9J/QiqsLz6yn5P3eLAiqPjHVcBxWmg7Xx5YkDe9uSVJuZxWpthkCSZ+PFC0BY2ab5OeRk0kDD9VsAyjdkUgpdsfGqUIO+f2ZWZAC6dAdxqn3wMc4R6J8G37msv2I7Ip2BOzkcPfLu118prSrRWs4HCi2btiMO5SWsrznilHIoKXe31+WpELaU0FpFRZivG/jP0JbrVsuXrWdQBh3FmnFwA/gTyAXryhKggxfjjy4G+Iot+8tJuhrh1T0I7idP9wMTjqUvP4szqBZCfsYGP2tJEW/EK/OSWaBf0A4+zC005LMejLXUz4cKwnsTyCIxJKOje7iyv3IoUqwpWjDCkL7etqQrVg06ek/VnJBXp/c8ido5v/p0PWzfC1B/79lzjL+05ndmIyx76HGsgcJ/n6L5QtMqgWlHak1JpP0OQZ4C5eS0tEqxVoSH4pEI+5t91/Trk4kxB3X9YhacAY+Ct7YxU2gKWn/G2+d8g7FwHHk/9SLe5XHNthmJIinM6nSDTcC0mhTOqO9p+ysP+15sDh1Mh3bxwHISU6FlHCqIx+hXBWY9U4O2Sx9Bm52VN/DjrdlJ8Zq65d34LWMliZNOOHDtAZMEBbkIDoGXkoA3iQCAQUtchTbSwP5Ee5aqWoAzi7KiZuUKoc/qnpeVBaS8uJtu9NFQeLRb4HcUrnfSVI9mJlMYiMIKgRQQHjglvBycmldFwj6Lir9nIK8HAHdvPGa7tIpVP1tVszfDcx0pW4gvVcblfRc1U8rVhE+cEZdtpDJn89z6s83eFqyYcx66rI7HRRutkobtKM1860q3tvp3lpEAJJKeKVxPOVi9OYlffiHKdFGR7mkgEY3YNlBnuCI9znyOCxEn0nnONOnObQFNEBl8Z9lYf0d08x9ZkfqlgEoh/yfM/V9/lDWSrIrFpk5eGY3j7mnsUccw1gTrIBwwtx9ELzRG/sqFbm4qLPstkPfaU6RNfDYHh8K8bf2NG6uuFQXd67dWJ5vUlfWPYm5GK+ny8loO/bt3i9SdCylNTzKxuibFrj183LaUClm+uokluh4KLnlqRJ7GBKiCFNWyWOweFeDgCI5zrCgzR8Pb5ep5aAg8SldvQ9y03xN6FggR4hzFvX7i9D/eilFaw8gpgRFtHG4K158U/IAhpJ6Iw14MPXe4cutNC3UNT3YQu8dTXutJZPwtrHE05dy5BpdCMDfe8ZAeOJFJo6hn+c79r7FCACy+VTMMFr0Iza3NpQm9MKxjzpV0NGhF5Jq7Jom39PKlaml5VGkudqckh4p5tXU4etUcvKfJ4INem3A71lRGJZKY/cX28sWJaRRbTBHW3thqwqfM7ayGFU9cWq5h+igqD165xq97DC5tAW9Fjgh7r3nUF16BaBFVZKylBbtsABPzbRLYpbqiITlwQLOKX3MqCzFDnqwxs1RQUBfTWPloQWnftbqboJgFtZXw5PSvLvYrTTgOqVrB8j27UUBHVcuni2rQf70mvHcLASqjYCyP2Rim33K8AfYWMAz+/WgIKhBzRRd6Ha02J0Y34UqtEaFS0TPnV6i0oEQlUQl8HockR9aUxVX1IpZHFvkvL6mDmhg3mNjMI+bsxifWZJjSufmGJQm2xZOgIQezO0opdTKlAFOcdBjIqTE7Neytub1b+cnNWBtfOa/njKvH+9q8VyHzKI7elbZSh00eMPBVD60kwUmTQ/gUrovesqvHBiKpp2DOYjCioUQdwU+4rsTbfjNFsdfXUpkj7Drp2/nzDoa/6ViaCXPR6E22uNQ2Ox38WHS4uiaDX6lXTtfL8RbfE7U2nxsm6iyRu/PQ3WWIXtP/Yt0mdpfj+c1wKoZO5OFwZAFSEQfvc53QIeD6pcES/PIVF3738oD8AN1OvvG2A1Vt00aZYOdj30PGQt02A2njgWa7ykTq9rRE7WbYDTMmLEpQTHky9uOu+rjqW5EKE+XgYLAi8a248MjH2UbNyUA+sxxJNSL4XlcYHdG+NyTOEeZYF3/gOhVZmtZ2gZC/UqfWKUYlb0It8F8A8kCIdPjj/xA+0QXpqpjUfRD7ysu7iT1u2769bvi0eZK3PP/RdvJ9XPuiKKtHIxIB8+Ajh0tfj3Qif5ie0iWx9odQBFT16uO2IkfMcWmX2OhXtgcrFB1bApXep+1neMQF1W6BudMz7JaEob90fYUaObJyrjzUB+tmr32PX7WWqFvrmf+m4Fvbjl7cw5FwMcynNqxVwvIxd3K2UqCaS0qEOMHcBMVxHk32ULNw7s/5jd+G6Tuk4Ims9sbWSq1rDjv9P6MIZ3p6a2umUmjrDU1o2kOzh/qZR2097tdFt2aDw/QQRH4miRr8y3WTJjfRHfAnGt2tG4o5h8KCt+GcVx4JBZ1lw4oFchnREwY3YC2ANY5nN2PmDpnBCpuVDN8RRfvP5nYo6YxBUsIpboytXNM9yGRVglbhf9B6Vdifo3rZyJ46VY2TCp5shcGD7uIftyQVSB9gSOVd+2VKIgLIEvJCf/6FGKPRD88XFZFCXLKK0r7DYYGvhFCND9WUsXXWQmZZhW4Nzd9GoOG01j3p/BdZjwlb9q46ah7doH0mEMEZyT3d5xFnmQI1eKq1g14/emzudnwfuURdzdGK5RcYPk1nwFq63HV2h2Rg6N6syi+Y3XgI+juuG5UJnGO8O/QXPYEvwEgmwq5+IR3h8DmkCeVBKNbCYb2uts1uVzWQ0dA0IKf3AkmOexW4EUjh11HmokeyGLYbPkMKEqBipQo0jptfDl2aD955grzSNQIsCrLk/frcJiTucDC8LHzPuwpCQnfysrTOhmzj8WVFhyjKciBlN7wk4nJZqPFzZ8KReqeXitxh4YxCTp2nVndbQn4Kt7t0NuQKTrym7c+nCsyjoDxcLgvLgNqoVm5ie6/pzwYmdQDMcwwsndylHy1zMhQd77lHFlqkuz/siCLtmPNjHRFsb5UFsFIuQWSoeBoWvwLEwvv2VA0dflCrcq5e8ueTYsWZRoKkLQWatCrTX05zku5P8nG6ye37NC8jRQi+MHnaTkwG+LwFU0y6iywBCyGgWbJ+minyCBXJrQ1VgUGwHUU5KZb7fYUI6P/2Q4sqKxtn7BmR/IcALjcASAmEJyWJRePR05oRjRgkpcHgcHf76+OeT5WxM7TirJdYZEeJXeWCS/IkCP70Ar6RkO9cdBb4fQWr2WVxIdukcSVj4kGRTWHPeTwYBsL+Htkrkdy08ulr4JBlBTpmtxHYQl6ZY4ZgVzH8qdpYVimqrE+lF1u0p+jSDJd7LrgU/mGmLowTmoMOzXE3OqPBKhIQ1SH3b+P8hfi6YZanfMPMoCPvoOUKuAm7hskyYGw8m3Hpa3/LLplMAkLfG95DqrhQfQGvt20DAnltsAZigJ5OPpbwc/JFsqlfl4cTU/q60IG/Z5Ays0W2/H2O7ETskKJDgJGiNxIxjK7Gfs9zG/d8bkaP03MUs97Fk0G8uxaNW+P68bGD3RNQVKO7jxu0/0eXGltgYrzL0xdWijLoFjSmLWCTSTIEE4YVaE1X2O/cS7X2NXPWrPUkVDq6ICy24f5hzjMpQaQwWGJCS/FIdUyW9FV9dnKYfjQkeACC5DEJuCV3/duRXqeYQEeFNzVcYJhAguyBpKVZTsTFn4Kp3MlQ1O4c3gS8fBWNHf6tAs4gmjOLivQDP9x/uKNQghB8WIOcgcaxykLkg/jAHlpH45cog05ugyydQm8bQ0Qr1ceRwVs+X0/Onqwjbyxh8GxmLajh4ilbJYwlZ7Lvzzdh7hjy7Jnlv8bTvsVk3HUHSfEnNiIDjjlxWiZUmDDXXYpCnwwn/8uWPbWUQDAb/impBiv7Mdmz2zrmUa785/Ie+c6lB560VnzNG41yE2wH+VlhgIxpfIZ01U7uupIj6FqBWaHeaba2PPmj3exAIdik9HwXck4TxPHHXczRS+3EkdaMT1DbK1OYS/faM0yXLYCF2QxpUrQKyttxteRzaEVDZrdk0dcRApAIV4u/dOKewM9VihCjUv/Rz4zNDoGQL7Ng+nIL2mRc0OgGUb2P6jD6EIv4Db2YAJ8gfGEbheQkGPWA1A1fNMfsSkdn/f7H4tUiYIhtaeQr1OSKd/oQc4znt3I8BECWe4tJHqENVTKlCbs4lWHgEddgd+lcgkjXJIBsVFCq0lXG/juxtfZuqi0wa/pacgUgUFO8IdrNjuqG5C8TNnVEuJKwoKWUkr9qe7CqG73nw1urPuRle+ffyUVxMHHvuGasfNe2D0Srt7vj+Fx18KUq+21qrI4BbISwtV+Jpej7qTUS1lr7SKlhVjd/OLu48XwPqm15CRzBcnjH4Hgkn3Yy/SxqC1W14lTNJO7ZjkXiTjW8DW7dClFoR+updJs99EemyvOCYY2h0zvHdBAaFDSsBf9Clfne6Ye9OX5YeBk20vePehRbnhbM15Z9RWBvUN9jkyL2eRZeoIh1Tw1mc6S5ccXQbki/yq7irRoQeTFSQ5FmKteSGZdjDvqkAahFA6VFeCpmF5NzdR/Uj66uxvAAePelCI3HaTfQCCJBGqpodDuWKHWX+2LiFAZlZRm51/FlMbSTnTmww/zaYqOMPAO/0QreixTyt76QjGmK/c1JkXpVz589MPPitGGIcy0+OmVG3AiBdqUR2+ZXQ63oFFNENvE7+pH+huTsSVeoU0/fJ/UFwYELPcW9KAQSAbfEaEgSOREMXvLCDhxNV3PgvrWyJMsuqhBXEH087H/FURSzE+xQMhT2d/ppaEmAGcBr7zcSnT8c2EBcI1EJbbxCQgk+06SLSyy8InSHxI7NVTyzZe4WE63EyJ6JSp2iP5dMK4TJmwgkZ4j1GOoM/nKHyGF3uklFYs3yEcZpfSyU8fLzZl829f6th2Am2ex9ZmeuaKUQOaAwfr6Zodh/4IcxHL0wMtocJuOS4ItwAK/7VmDM5gHEPC/B8ES/XY1eZqiRYRXtwrXt9rweKIR0AZnaXvim1QxYEONPdliPxnnai0Q2xa+oBkvu4DmWiA1SfgQMKQ1aPniAqbIKwK8DZsPul0qL9N5DhRb4K3tXP2uWy/+QGkhinrhVqWqtIOHBBg5SrQ0bNOltddwH9NfRlxhZOyYkgJLiPk009iOqz1sBxe+BJazqgA/Q7OYyX1RsiN3RY4l7YLY+GSUs2JprSTFBVtva4cWccb/9ZNCP+6QW4z/51sGF4ZpvjsWBHqzUVCft8av6/mxgo0suWrNKGHT9Sn2EIzIwyoVQM4G+7WpB2Zj14XjcD2t3XGWWixP1eT3VXFhr6ne44ClqIMzY1ZkXjRETYg9WMIgK8kWVKoiXS7VgM10BR+85IWw3GsMnxATlwXgoeXOU/lt4u0jdfQ/zlT65wrUStB5QZpCD6VA0gxQ+8UC1dEpTMTTYtMMLvF2CQ7MlfxWgUyOTNO9VPnTr3T4JhH2rS7sqvs5R9CXJoDbaI0tpow0LD0ZetBgyl24GKHf6H+OAiStcvEYmuURfVUdIxBCCKfCEbpnY1zuFir3tQqzzcUGAyFzmX8E/FKPmYzLpdiKhrvygaRXcD7Znq3k45MnGTbuWVrkbu+hzzbPxrY868KLAnjWzfS+UseTFRXxQ5w3R8RhHyYkDyFlOOxbTV+CSS3GhvJgKNQJ2f7AWBuVugM3G18s1ou/JLkIPVtGx3OOEHQsP8OQOm3rFwRkCjOXqG3WHbj8hnQsd/zpfyEn4pOU+mo6rxlnuIDLInidK1AU/2gEwVMTSyRE/inZas71NP4/LwpcsL44SHstOM+FjRXpDeFHy6Zhw+MHIJRpB5a2WUfA5O4lbr22G7rUYLbIh3i9MT5sEaN/TvAOLC0dYrZiSZBgvVPSVQtr/BQ6dLF+g4YsexXUJMgcJd8DWVqSisNyE+5KFbNLX5XlsB9oru2+GQ2HLpWcg7973QJ9HPd89/skFsBLMnCGjfxEVnsR6PEiTl+V+yMgrNU8i/eU1S4civudgyh5EIisV0DAl2toWwBcmM0tKmBkin0x1Cd1wWwwN+8KX/PsgFRAKp23sbSJPGmpEzKT69aIFmqxWu3d6W+lXOcBhs/Ix83394glFq7NGQMRGPcIcnYxhpD4BlwDzbrQAq6C9hHKYk72NwGrhnE3tEa3+wAHYBghWJLx8KuOpA0sj1udzYf/W47ewrCkWk1+/YtBP/YNt9YI/3H58EQECPQC55b5gzkHLG6XD/LQhpwyxH3aw0unk8NdWS45CwON+ngU/aIQyAqBcg4Y+7LOJ40AQ9Io8wTH5smZ8Z39QZt3iR4I07IasT9BtS1q7foylymkd3abxCDfc7CYcwOoivJZ5UG4aTsWVOOe5tWB0s95TdnuD3hbq4BnV76dCBfsDBzgWj6al1nFjOWUPyaOoekHe8RCjhf8OVIS78cx1Er/F9rPqDb4qmosDg+SHanPU6UTrXZdoKD9A2v1fESO5UmXmwkW21wDgw3ltAs60Zju5v2vcdy9c2Jk0pywAn52SM0gcmJQIBqktMIgfw/uvIHtnt5dOpOIhc+kS+VW9tSthzEB9XhuSr9b+fgNsjnnxNpZS2XwyzNCZCCIddTNdWol7JoCunZfevAr1POSjKka/mdcgg8roMMzT0JqRoKbkElJ0lUFZ+6ZCK3XS29aEvgqH/gSpbVIQnewI3iwROH1g7s+Dj5/doUltxBvFi7LGsRTnskm3ya1DDj/TEOuhlRgOFCpIbfXm9OrunUYL2E9UkhS6tefFUhxFZlOL+k4nczt3CKLsYrJ889AxSCg60Np/camQbF99VkZ9Ngvz7XFiUhKAHxlyGMAAdHvaFA2AKkCkGogDFOb970oOm1+B0DV4/j8Yci69VhkDA4+I+3vjTHTFyCnaKDOH4U7U3eLFy6KGGVqCqjR7Dq1uITGxzQzJKr57TQDzbyZYNnKFeBPVVDld9ib6R5kDISW6FSjHRysibbZvc+YZYuG5uXaT5k9v5LPREov6VKToEuHcYeIXzrwkaLiXfB23+j/cc1f+R2yI1+dCIqMqINoTn3498aiZUNysv888STjNTU1cri5IbykQDJb+VVtYqSwHbjzSlJa6zLDSdX7O9qHr0RBla3wUOAdrTYLFJfFDAJJNftTFqWY2GUrHuMsBv5gpjhkpUvph2JNl2GYcZI+U9q3yI2yis46aM/un2G9lnp4jonDa6RUQ7yyDntFjFUFvSTXXgyb3mvnNmTlAMU/eirko9lDjU22p30+/SFQzMFNwTNm7yJ0Wo8B8+kUx6xcoSOE82Uw/nlz/azg8FoVA/fyTtQ4OMQbVdnUGBFCORFLkTtvzxjv2nzbAAk/FUq8wm+RwKyAJ4/S5rSQu6tg7xim+ZZiCNMnvetpv8YgBRLMCezLpxfWl62Kq0E15kwQY3RjJduhfznE/9mXlZPNORejhs/gZ5ogOsOWcYGtVHs8f7kKVA9J3x129MRSPj8ketogkpzM+rmLK+s85MpPNJdyyNUh5Oamvy/vX7h9G6kYpZIItHzycyqfItqplYX82CGwj5pnM5BGT1NQ/BBBhasFkdE6MDssNyf1QUIvOgK4p6Jjp6U+paDc8zcOpE+LBEgTpm/LUdE7l6VA7r07DuSGQbn8ZWkqjZq7d9kL6D3N3ZKm+0NTBSk8wA0MTLxZ6rdNeTQXaZjO71Af2saXUcvIW9mPd3cCwJy0+dqUD1XwvLS6Wu5hYbU9TxNQCF+2jDHF/qQFDqfQXO3m5aBs2SYYsT5k26D+bzK/gQbF4lVNMdf/m1ZPhIncS7RcmlmQzBLyskvW/i5iw1xgubwLDBVOdt80s3BcCN4djB1SqjZvsHmiE6DOKUVqTHyHxjLh7mdEly2U4LN3xWWu9BnNq4Fi/SE3ZhFpRXX8tN0G748bIT1GeBrPyAvSok+WLkvy3bcZ4QvCLSCMfXs9d+ooLyC0JVMNTYvKwANFfZbRM/6K/QLljtRSjsZIQTZu8GXjeXMJQb80XpTL1gH2G5cs3fgvNGkIq1nBqfnzJPv8Koh2Mfx+pac+DsuxysYECfwPmU+edl/yNNUuzzUugXrPZ+lo/4Q6QnTLN756eDyxVs8PCJtw/FxRy1xZdpIdjCfCyk/cy4FnaRccQ1R1egvkzb0FSCgHtDqH6D6wIbRwmX0XU9TH7DZCnscjBkMclBDrRUxPkqP/6LkapYjrvtySunck5QnM/whQ9+muBsj60iK/x9sTQoBU8SpL/XKz/9Ko7jIvn+nEY8yYIAQ5x2zjv7zNpiaQt5RCqgJCvo2/E9JxvnP26RzKYNpBt1H8B6GmE3QpULkIt/NIKJj4BAVkyi9ds9spODRDWihyGYI0I0jvaEsXatrKnC1mdwCNHWkLWB+aiDjWUpLs4uBPV5wDFgTnXrs4EFez+E7QjYiDMuYR0T2pUSPNI6jHJs5v6pNpth4vxZskSD1G6F35g790ogn9/R2ExsFtUr+dLKNoAbKMbguzKnjPvtEcrOrnKCfJCXju9TEWoYbFm2WPahg5wDYILlOKbHJGpCsBXpe+KKIZ+rpgVev3LClUwwceawUv3LHcSX94/+Eph5MVNnWVhcgVUf1FHLw3uOmtnixLyQH6mEdanKL8mJax9j9MHdnnDvD9kGSu/hmSNvngdMIC+IOVdWngt6b3bgq69unLR7JkonwYnsg6XJTeB3pI7P1U0DuYUPWWnCsD1UWr5nU955FETbQRdqHxU/xiun/ZCTZTzxLi1MnoCr6W7ZAoEaUoyrqMZvLT22EmI/ntyNX+Skj1If+1DC4eT7bWjCnF5sZ9tA41RjzxZlJbC2HSPVIoZ1/OU43tt+tN8bN+4CNEcRngLnhRq1TPokqNjnHvUAcJ3SAQsrh8wt68bVnX+zItVsT+Qia0Rd3VRCbP52jEwwgLRbV/3NqFXUrvfV5iSYV7T7HYoVCZ30YeBQTlCOG6mWxJhUSxFUTosE+48og3Nl59k6rGb2bIR2XMd/XrCv2hTVZH3W9a5sc/i8Xfj1muuFGJ/bb7oY1lVEWoQ39ib8ssiHDtY7oR96oLNh8R8b6p9GC4kjuiF0oGEeaTdSVtCGqG+/EsbGAzhpbunF6w1OUfh9U/Bs/465txZuFgvLaK52id7Z+SszPZd0bEOyI/v+ctOSlZDW+ER/Q/wqg7HlrFX1YIgxb75noDrATWNnzyxvtQjsDJpRrN0cQVQydp8ozeo9MTvlkW9YNmHV0S7dVjdgATuziABzAQERXuDTGT+tt8XNIwrIWruKwpEZBbkRcJYVQk2LJ9VpVbx5XOvuDGP8d6Zounlhua+tYPZcwbKjWeDgDH66OjPsI7I9qdZtBngqthvse5jTe4tB6yBVy3yPtJAGSgCiosqVkA7mcYey+aU0QpUffnLONL5vog/3jUdeUw0iarkwe28rhU9EvJk1yw4rOMnsjBZOY3Whk2WSXNHxIl+FmGwD+mWkdpHP/oN8sfW4sQvbC8R47lYgaYmmzMeeAC+U1E3jgjg7jTGlJM7iHN1+c942UnGZSqeVFo4MUc45fiOYnafCKgyu8B3Xv4Bk8s7tua2ynucuE4JOocKKeCSCk9GDCpgXdKMarX0+CfZxuG1YNdwYP3eOwTTm+ywzroWwbGI5gTDktSiWLUXzomfpB6QURtXoao0vokdsCqxzizS4DrnQlmAUOamy47WgyKdgOg/vDkPhneq6Q2qCPzJUzkrgMxwe3TdBzpRGptpqlrclRHKmsKCO7lJ0XXKPwyqHqd6iCtJY5ZCXtjdab7HXvKA0e3s2TuhcPi6ngk7K52dMZSFq+Y2RJm0Qbg+/9vN7yRuUYM8a134dIjRQ+zRpwcJ6Ch4Nq/l8iwVxl9XEFub0s83XlELpOB8ScFlcRIfdIJFxi0DZj0mYoBRIEyu0Kjnou9yDWZDUYAazOxvuclq7IVS7HQXMlT31urjCztWfRSQMjCjmpSo8u0+P7HHMkfI36t0EUZcEX8mO/PFbpdl0GsZ8re+/T4YF0Z+i2lMdOj/Hu7D5o8+icNViIOg389Q8eVr1/pNrT2zXAcW4ug8m5x4Ukp24U77uXsjN5I3GccYm4SqM6UXNamcMJxIlxjMdjDMA3GAYdoe5NoN6u4/5AVsxuGeeac1ui7yYBqmS9DX3Yvj0Apsyvbsj3sxJsryrI5ElRSvgT3Omy7BFoahPMqFiKkgBVLbubsf1fOjf/uCHov09FasM8jINX+5kQsYnu7Mc0qgRHY2HxS+tMBQYDKDquETXD9mUyUlb5Uv84/h0DOt7JdF2XbBMWG7Zo6wCTMcDWXpTjiEV89n/X3utldGB1DiuWs6xQ46/J8LvAKNBjQGCATR1M6qRazQBoz9sfUR+4TibF+VOQ5juanuhXfWjQ4hiebesFKd0XQuZJv4XaxSph298/NyY0PEQLemQCU0w7jGPwa3dgpMyWvNB1/NmRGvSd/pYk2YQgar0DE8oilSDdzsoIx7XlVsCAouBUOEOFBF0Be5W5maRHe1UptIH1GlhcQltfH654J1bD15Y2IBJqLSTcZz1/Dabbsgmi4re1S1FfKy01buU9GN+3vfx0D1GgLdnMLqbUywZXSwPf70n5054O2yU2mk4RmUo5nZ3TBd/0yT+C6LzxJWSu7bTegGA6ijOhlAISBxtsROdfioG2EpNn4kmouBtUvdif+AFemZ8L7BBOw0tshzlwq4grgYbBnuGuKtLyQuY4xcsBmEkvC+gmEjMdgLRdDyJ/dmvqZPUUhGLs3EeEcm029A1D4RjkBLIEor7yftTI7y88MgHrPSSBHIg8w8wcfgEoOOc3TLXm/iYr0rx9SMooMXLh0fcjdq7aFQXbcEVWv0LGRgo75ybPIH4uH/i89zrzitjAUk9/Wgdoz2l8eCHnBCNHKGy9BrAOIa/6UXAo55X1PX4wptU+rUt19kCif3km8eUucjjb2NOniNZ5E4DK7PXzYCKSzog+DUb27+sR+agpTVsZtG2CzajQD91nt30JPhjzWPEj3Kg7BXfL1TKcVohA+y/IXvJh0lXZvapIYGIf7oOCHZzy1Dw6Ve6PqYykimLIVO/cDcJveVzFtNWYIERUjkg4SM83MA+F02WFXkNavICx5JJZcpP0L5rumNaRSi4ozu87bPypGFABr1hpHTldvuqrl8TyoOUFFsIgyB7qF1gEji/RTirvIZTqnexcRzK4CHz+sZCPP/tp41l6YVdmEmHfHkhg+R/qrJgI2I0O9JNsVCaWeB/SMcAR6PDXFPW6boqzjFn4J6mjZqVbYU29NL1UP+s/FD7V5AD9RrJgf/ZPxCZKnDobkCyKwlgs12EZbIszdbh0Di8PjS8kQXNX+huLi+MHvUkJGOvvGzV80AjTEJmp7u5e4499yas/OTiz2abSbnXp0D7HPVj5dUrjcTmJLRzVegQmp0TZCBLCXs8UfZZ+AXei+xZuR1O6Y7WTvAyN1Fl4vU9NhdHFMzT7ubMOKI6k5ufdk/mNp7MGGJoZ6zg8rfTgC6jSv30RYfMN15pRSoGpIEl3Y0wTlSzdxVYD1duDNANpoAj3eZk0FEPHsBmk/EgubaaunakqYP3q+SCzIgu2e0ZRragZMIAnZrGAw4BstGtpSmDGZP3jlmwroYOpLUwyrsfK67OAnorW2JC9uWlJ4+Sref0+3QNDewmGLwp+8oTsm5YoNYaVRx+nmoFCzhlInElcBKA5XOcLr0QcHu0rOnuBMbW0IEgMIsSpO02wV9vnN1jYQ635LAjku4WcdLfXYZqenFayCu+3wgAhoTI6HHJ4J1DW/SmuO5zmjNlA3tdz3KbeePlgaoEL4t0tjq4Hukvz/Zm46Twzx3r70V0dNmj+o4J5e7crsgqW/tPFQI2YDbhgNjgyH8/GXn4723zJA169Zk8w7G+0sSySbDOC+MJS/zByAWF/iGgKEiYlp7cXdQ0QEshiAKvZBovrXjCrNyqjIl5ZwVrVbTjwxOT+nICjp3PfBj6FCMkTVz72ZgG61WF5fdRIImvd6d1A5cWK9lhuDT1YgE4uscB4nn5Hacf2K8HSNKAjgEZP+Gl757dlEQd9NImvDD7jZeBbli1hkGUVDwjTAHRXfD5VrQgtbd9V4WjnMVDzrWuqyxbQAOiirmEkJfjkRA+JSDrjQ7reEgtFW9SMSAQ2j/cjj+WKN0qwxPXGrdMznZ9Ag04B7IS+Ynm56IwNZlcdIaI4fAIQZ5DeazSUp8yplykrP4VYc72CdZaSgzDSZzxsT5gD8TLLLW3u615NyneRWw9NzXxvPnc5n6m1tDFy9CJo9In+pl82ZmE7KAze89Xj9+WptCJVZkK5pS8GMSCzhiwapwnBw73GstQkJ7+DlaounFW/Zx4kQspFyE7nTa49b2jaFVzJIQinXa55XhgwHkDlZwHeX2pljSCysbRDBTSwyX0k/M0Ufvc0YuKRJTwfHtX5bVBADx1FzbCF3Q8UsP8D3Nrq4PufsNAPmzI+rHusrI5oSuoDFG/vmM2h1ZJWImTPVviNRrDM8IPlxmwAFMKmPICJskYU9+iRsWtDIdMbACKrjAL+D+G6RyHmNDL1ZQOngk9xE4YfMyWn0uAqF9IRymm1OaOFh5sKV6jp5yvlaRUM3WyGLmbKJI/Uo26b7tlPeM6U2ZaCj9P+UTXcunvhkh3KrCHrzyWaAzwM5cPws5MfIPmARFICqjKBshq+a5SRN4vIC4oo2xFD0PyuOTC2N5+Wd4JWzZOsTwrXhdnwNsrRf7QhlwhvAcDWGfbsTAyGLv7D3VIUgTXmlVw0y6KkaUeFZDFEUnx1yi/IKu0EicKngim7kIwRa+xshYUiPg9PwLx2w9GxDDbTi+Mxf8TLseS10msdO2wHuGuECxcSgMVqXreioV+EHkccEkOMdyhQhZhpVqokcdkLK9uqjpPdnSGT9DG47PRJoh1+mqjwZt/b+IaIFYKV4XAfT7yqi0fC1p/kpY9yAr7UZKeOkZIQn7O4WHwhYXlHd8ivAfkJunvYa4IT87qler+imgujDvsk/lDGVJ0zIRw/qkSNTO5DQXEsNeNg3HnvbBKPS1hqbRsDzpn4ViLMEaw/169FqMkx8sv8HN4LqsGbp3kNJm5HSspmn4UADK9jkQZwmnf6KsMEVz1lXWgXkorwG/1ZIamui+I4iSoUa0D6wLmjT62HFYOEzPqYea0SSACWdvotWZGMnQHHHGNbAuyzH8TVQ1CFR7Dz07gBHDTDMty3RsFfjEul4Fpqd4nqoHsJNDFyhk3uTvOz1D3BmHaMV3Uc16TTnQY9AA14T9airZZFGkN4FuuL12nV4n4IDvP1kAfnDPuje8D0OsXugWTOFwd5wZsz3JKnEoF1OnAUiXDLhNpbkLlg3u1NUjQBxwfU8zZpJW/N8P9Yh/FcbZi3jT+DLv31aDFnt/GkeMn1jFkqQSGaPWXiiYL8ZT5+gP+I3h8TYSWgTMVAY35yYf6jR2Qj/et04kmCwoYtl7aJ/5KICK40lSFhqQJVo6dtOYApV4bXdokawPv6psqrl5MituYaKEA+QMLZBzOchttbWCbxkfnhm6LFHlVCSCYgH+LaOjDKErNYMiJR1/okN2Zji4zZUMX4An9hgSR93uEivEBRN9Z+v0qnN2fXSinZsi9wJWLyE6YCYSMO4gij/Z9Z/BQ9fvC0BcP+MatdgNb/TBoPd6txUUYA1j0zXC3sMVaFJ6R3KGp7lmNRjgm1BXNqwBjEs+tMKmej42tieUHioe1preqykp4ijPCEvduD4afTyDMkDBF8zNTNscvvcu9ETPqkvF2vGNA01JATOgOOLbuYsmSnrfMRab9HExtsbpuHotkBcN9ImaAtyrekJr9JOhpyVUebkhVqacBPcASpVKGiE39zDkbaaAmhkNi46/xdXrDxKx0E0G2YyXN5UrdukXQuRXLWJo8/O9ZPej2bKXfycHAPPSTaDl/zaxovycTS8Cy54WfeMGVrXQWnXs8TTPUedWMXjBbuVRJ1V3RXjj0l432k53Xfgw7YXWRwxzu3YktTLCCfYV51HS5pzQ1bocDSoLSrxcv2XcMzJNKouqWJFJ2PHf3R4OYlBbJ2H1kL+ZPrY49uPmpadiY8bHaHUdhjY7yyZXW+JLukPkvR0MMvOjfcoNThPTYldIKEqeQzdo2zjdew4grYvpdf7D0uf4cOU2KkIFYrKLZELFq/7IhXXOV/QX851hxTroNURJG/4rc96eqVDrfdB2GIoBQrckDch7TV+5zXK711FLLHmgCWmr0p55PyhEvyKngOy6un0DwbpCciROTlcukvkWaz3Jak8Ywzwq7BpSWf/Sy6QBxHkSURPgZCRHcRyL8TazoLAgBrmvCAUf34QHu6XxygKI7Yp5BVOfT5Vv/WYBFyviARfNE5AqsrloUdOA9JWDvSeRaJW2P2haSqF7wDwh0wmA/FeHq3agi9J8+hvnRsUBNSxUx2rrwIvwTEBMdaD2+O3WOY4wPBN8p9PfJ/EMaYpg1Dz0OTfai/5q3C/c731nNec+gX2l8GWyrWED6oa+b+UBDOqLxuD5HyOLos2sTrkGFQdKkJuwyga+CiQWtRJYQw7gFQWB/XgkufI8QttUWWhlVlQQZvadCTwqFkau7qH4VSzbf7Mo+4R6G+hog2IR3jajGiYj/6LA8m4um7fupFeX/qQjPC2OTFUzH84N/gKjiCyG/CKarFYUUTT+NMtCLpYCH7gp30kbYWkg+4IyNsZjyoq7qk1WI6jECJlB/TcGCNL/uU8zlUGmQ4m8Rk9ztS+eOLx8rUKwklyYICM2LzE1MaBshsshh2yhKgPVUdOrZpWsFAD062jH3kci8X0G03a5vYFO/q4+u9P1IgIg13ftQGLAEgo4uOTRushfH2u7wXvuR14ALaSVbWOMIe8REuKLYt94JD7EfFOhD2jkfRej9X00Qi1CAu6Yt1eyLE2Rj5w1qeU1o8JLSXmXFeL45rOZgKE21Kt+UknolDlbNs5Q571ouy8VMRlp2FWaLYUtYIjqmKaVnJXbObp9wDd21261SMjgAXm/hJFt/2ojm0Xydwj96ICe0IoSXwBehGFqtS3k2poAcpRhTwr1vurvdY/Pj/OFmqckfT1hD3G116oqsaGuFSsVvrLaTblE+3euHx8Xq+G1yl8maED4GR9/REgYTUI/H08L6ZPKNqNuHcdBn+LJ+1JNDj47AzrjlrUQyPmLjmY9XPHKg2AQE6ARQqc2gGOZPdaqq+iUGEg5yowCRtEA99ZKUVdmHR1rnnw61hDVA3PZm5/BTb542tZ5oE9/6iXcS8r6PpBXJjd4/rDfj3cD42ea6uoGyYMj+JK7urCaMw/Gnl98JNOdyRcysAwdh3Htl8mNzqJiEb6k/JwxSM8jS9FrxCA8vVBbNwfE4J8qPFgJOYTaBTAUaIt0N1oA53AnApTcY7dkGe8u/JZGAGuQfSjGBa5yDv7KjlWmQY+tjoR41Q+8eEJWsCrxs18ovVvSGuaRkvDgCWAP/qMKGBCUWXezaa8kVW5M/ycLw9Om/ygGLWQ0tIZCjH41C25/rDmk+wJrAsRcARhX4ZZi/ConPkiUFOy2YyxpaJoze3BeW/hLYHl8aDgaVfHQSal4EgeukZ6qtRrSnK99rGuyOOpjAtqBU2OZ9CXUyvdge+kR4Z0ZDDWC+4Gjxqlz4hFNO6d2J9Wdbjp+0qg9zUW7n+Xndh0D4p4N63dzziZ6erx1Gxxww1CyWBWohkiqBxW+33gt/hfK7teuip+6OBZh/1kIfmzKHwujefrKNFnx0FwjGLOH3ZQOPtBXelxKxo62KcLlNyWGIeW9F0HrlRqCB2EMVGunXmoAQ0tvBX1Mwt0jyWZw2hexju8kcCxbjzGoMfCbHpgb8y8v3lEPR493Nx3Zuo6P61zxM0p3T9ObMWiob0j7hKzBIMCWLN+uuZsSVCTd0oyTzw+Tl7NFJe/XsfmABMm2B3rIXP3LDwSI1MR1CZuHZzQWMIICSUbeRFsifYAFw+kFCNJAuFPlNyx8rb147UhMXon8h34gqjJ/qMEKslrWHZfmHXBAE+oWHTWwp2RStjuFC/0LFMo6s5XAQoC8ibB6L+mflD3y5gHzTS3wcG3xnFyiKi3bz43/4qn2lAevEqqfxuOv8ShXb/gBnV3KIY29dODbFOBZecKXEeGb44BCTjliZ81UC6RWLDOGOHWjOnUo01GnDWS1ViCabgGZ5TrIZ3L7R92BM4YTRryV32j/sBb3sK1E0+C3A9MEw30pDy7vEG1UD5xAlr7CRdWfOxys1bxFsbPSRUgDYeGXY+jOyklX90i3DFvXabaI8qcovuLAzrkRDI1epiJhzCbYu0iPe/0CaQCoSSGCYFXgzb6uiG1SevQbg+1P6Lb9AcZdQO5kNGP/5E5/UYjCHcpjmQNUvchBI5wvJoRTUu4qdLI3K3grst40SdrN6tGiBQOVPPa4uedkzk6nBOrjfIoWfcwXRH3b+vW2K5trIcCjm75FBWWuRKCZJ9v2XCvENjCs5QjBHhUJx50+nScrzNCWCHV2eLBbnASP5/p9Jsu11bq8T9whEtHFV/+Heyn1UN0qEMRXy2TX6DTgIUuYxRETRvumNC4/Qgv96keIQzjedRo4nHMCdLTtFJemOd3gv5Ts2Zi9Qqywx0K3YIvzKM7lvWksyNbrYRn1zigW1jCGhtxAT4cyk84ht55AFHgXQZyqoyF/ddd8KRnd97Rcy3QVWUfiiCOaEbnZ/oSUWPvBFIcDaUZ3Bni4DgVzOVSSWuZkbGz2Xvan5GzpPAQ7q/HqYP0H36eW5WYAqh5v0+57l76e1mfARb4GeXscg8VXo+7IsGC7JkKJtd2OfC2cm+wZ268kft2Zw5kkn3h49I8ycKUOSwBb486L3dhbgrV08fjaOWxnPwQOoNaV1Bu9UvNCVjI6h+Rn2kgAAImSKHxYoTbOgde6Cb5fT/Su1B6UPOZtvcO/NCHB7SpyxzRf1QzIjRAoSwmPr0ExBeQEMrrqaXEkt76JVjmWGKx0dQRg0RwIaUZQdFtLsO2BSZ7t4dR7NebO3PxnFSOnoY06tRzLlFhT76m9m7ErJxaJXbLFYvYOzcFUK7YM+hjwKYNTnheru7zmZeqpL4O1gx5zoDlqtFNLRkRssllh/MrlGB8vSExSnuOmoDUcg4lnWaWqDY+lxzUnDQ89LQ+mkY2JoPYuYM9ZRgiuSbb1jskXQcPzba+6pRaOYr7NG9+4S8E1fHdd0M9juoD5FjOJw//JNsYiO4lqdHaUCDNNWucZ8ktyRwXP9BBjMbDlFAyFynZrtAXLU0/7z82WtqnGgFCHtvJ+9Mb4S0ZzlliU9TYmvxVrkd/CZYNFfTjfL2bLE68QAxwSjq+suiU4R5nFDe4b9K+INvjhHMvlP89xhK65fp8NVjtvh6p25n0Qs+oInnPCGvKMIZsNETSh+P2GESiOs9GOwoeUPpcRV6jb88ZDAOaeyhaxKh9yaucJsgINeRgp2cE700jdHcL5mWjwmn8YLcidus3H9XMketXgxE0XJ0lr7/gSUH6leB3Wr2FzfyEj9UuQYSS7Cff/VLMJXt08P0EJiH+K7yDqyNJnSfbuxLU+MrvT6JUDUExxfHD5qyiV5jHY94v7jvkY6yf5r073Ug8MisN5vYzStWwc/+0qzA7VQK4/oCI+b4AOGfQ2jkKMC4F8JG9ql2P6pTP1lTLMsTRIgaY1h51Lf1BNkW8od59Jh2VnSRI2sxRFn+Lbjx6vWx9oQfq7Vreh6dj0UVZU7Fvc+whfsMl+zYIhIHtHxq1JcBS40TPvvHPxxazb6fEjiBjUcGb9jTP2eA32oh4PxdrG2iuwyyLrjSK5E+KR5o9dRMSB48i0NVio8U3gZE9WS/uMKyp/p6UQYJ2B1/VblH5KTRZwJV+Jgsulv4fcv24EIObIuNwttJy+Jyo98NySuILqABSXh8xrLOXvMw9XpI0baUNPDRjn1OIIZd7uYny/pqV3hvXE1hCr/Km5doHub8ou+3l9314WBsiduRNH55/+xQ6x5mxka6iwqZRLCUZnURaIuRy/XFBlO5UOpztVdBM4I62HMrTGKZ1ySv+2vXkyp5l2j9pdWdmnLqHf06YGWVn/Xu4LH+ZcRalpGrACO6qkVkilhkIYqNbJtQ7INNCkr83B7icjinXeNg0pj12ifdIbw+Au/yHxye0IkQuRCLOz3kvGReivwRgWXg1eldQfYhltNWpg5ThpN/ScYhqDp2ZcKBzt2lmc6FGTd1332syVBYPioEGUWtF8T+pU0fdbGn8Tkmfn3PVyU/CJD+MSnBwgNz/o6NDDUqKp4U/kjpYG2hm59L3qho8g99NJqA4ntdZT4cBhppR3Q2mflOunhKy47+YDt3skf5xhDMcbc6vbmjy0YVUhpKPK54eGzAo4h/cSZPvohKXskC6gOYOpfm4ekRL8OxWqQcxMwZ4hMrHClcDEq44+iBMbES0y81A3xTtVF0Z9TA870F/InNcVFhjcXWFGsdHeWlPp4YBGReLuMdCbNDHFWkhmCXJ5F/pvqPn0THCgWLt0aB6vD4EKIIETMEXZJsflpIQMlwIOu2daREggtcVDU5pid5I0N1d6jDMcWJ15mcsmyqbdQpmkRFO4eMlgiDoixE8STY01VI96/09gM66gj+/35zOmQgnEZBULFt0F7G2cVn+gJcPCIlJlGJzSIHBoeR7dY4JMm9JaSAJKm3SYPTGBunvJaFhd/1KBWNim0EGvI0BBftCxehnPNWzCkLhDYbedXuYM/jJdyin9BJgTmcmI6rghwJWKFPqf4RMaZU1G844fn7zwVAaluUEm06FpDxD3raPZU4EXoBuQHIos/dviGSvBGDKB9aFmkgIOD7X0Z/CxKBVx8JM8fL3xD3sNQdwxy9wNE4MSTohTCjEPps5FWh5mLFxAgZh+LiHB5kUK/QxUe4F4Cqkrx1dFl/pnXLtOhCQu8zAeFdDwy4sfVyskMvHe8+IZm55U6FBaSxeTHOMMaE7aUnTDiF9//1D85iKJF9REUNql2dzUvEvCVAF+h+6uiF4o4SgC0AoUb4Xy/6um1f61UkyxmnplwPuPxFsdHjN5MaPGenS4leSKNiOwVWc/GL5S5R8Qn8QVRNtsmNRBsdmxLBBD8H6iJzAtfmKHiRvj8g6uMFMsTKgct9jt0WGIgm1vaT9klXGKPIP1vqG/iazclGyKFCHMR6EqbL5CSpacR8c5sEeuMNogkOh5bXMMZfxX1VTNXsxrW3CUAcWcn774PYaEFQBhsamHUc9QCXgIhDsGyjxG3qxJthOZ3fjLHr99KhQEHryqvh/U+/z5N9kU5/rCYyLRveeL42HBhoKFkNbcnGA5Tgkh0v4gNMqy6QoyG0qmfstCifxqMzcFFZu5AYp43nYjzGu/5JcqtOE17bM51ei+f3rZxjBwuGeKxiqB6xWAcWGTzOPOvPUyWjUlpxJDCXWF0/PWRZ1p/DdkMay1+KZFHmy7HNOXqwFj1+bBtiNFazeGEbQX6+CZAjx6I5zmCL2KOs1A7RaSn00CC2qdau6A1m8mG5eJcQGd3bAJJb9nlqjKtaKUkmDQxG7bp18ssLb9SnWmnQiK8yoSIF63QsFOzTB/634gyFdRg6CeaHfl7BPO4XC7mkThpbExEhioN9pfGuTZIPz13P0T6c3po1633ir1CGg07Zv7RbwOxsJdHvVGe2Z8PES/RKOO+H5q0z2ItBb2uw4+iqqXsIx2pAjSTuSNp9CkhXbtI5CuMOfW0fBxHkODnV6wMi+Wi+xbS6RLqG3AmsFd4pciYOFhYDk4LHnccEvK2q2d7XtksGkkbLUoNK0Euk7Iw1iFVKXlhEnXvhHC8f7KjB+BqsjutL8mCS+uivDc7A79WrXoruQh4qa3re9VZ0VRt0h5Mt7OlGxvWGal0Vx293tdZ+68F6Z2G4HqXZTJkkspecKtwr/ZIDMF/3GqSqJ5IrgPXDnxWZhggmMtJ/zk6ZTG/BnD6Rbl5OWBwBBca58m/XePjjE+8bgYt9dffhyDvvtIfCTtuDoa97YjNajOExe1ydVnuImY8cdTM6fugpgQ+TiSLySJpGuolEXaU9zX+ZJD/HjhbRqQ1If/awqd1ISvrHzFZ/8MsrKZ4QFqiIFn541QSQl7gECUpcpjkbXWpvxowvat1kpeLNPz6SooplB64ERjlX6MrYUsAPZqwXyN73wFIyxiy6pAv7QW5AU+yOVjPYmkP4sU0t3tE4vkvib1hwbyIaMSAr0QNJlHLy7O9mu+sBg8T/MEFM5un6OPKvN5JPKhSQcIDKNMvCS2KJ99Gv20KbeLlSJrp72vajBvN8TpY2Hd3LiKA7yWZW4+fLXSOE5sasA7i+p3rxP1djtX4dG24uDGaMSNts6EoG3hU6aTAeJagdsYxhfIjK0OwJmoDqh4t7+Z0m7jLA2Ffr9rLxCnD8n8lRFcOUGIUf/2sW2rO9JexEpCB3ouyiZmkQV4WMbTanz7UYH65fqhZcBM4VskYXpMzcMv+kHbBUBw6hiU5vzRcuikI4AqdenyIErtQYvlaUrbm1XMpVDU0OrSb4KG9XaTveqgz99JFjvZ76PixNvo4Kqvvpqc1uCtU/IYN1zA0aQ7wZNQ7Ala9aYBtWYNt6j988I3j8VCeTvggZ01FiaOW5KC3Ajxyl8blScRM6WcZT897787ov//97qE1VNCbA6bvEJCpOcAIO0SL8G/dCPfs5X/kEgGT2OPdmS/dMOTDmT3RkQcye9htJSEs4VYLw4HgNbEoeqo3X3VHsZuQkk60uID88RP0v3bNuugQekIqShP1iiaTTrUfRPo9Hia0drrY4UvAanmNDbOJcOx4LYF8fgloQOxX/0LZ0Jgg7BgcmLaKTGO7I9oCWJRFxleF0rhfIoom/7zDEeLcPu5rn6un5cb6A7vh+1d8oCW21hWwE57MJelfQdalSU+tiG8GYJJbbEl+6/UbMVj0FQNMRTbj2bUFhA+S46ASZT2kvgdYgyB3PDWSsEeRCFxM/lI3rlYe9xnEmBw8JUbO6Uf6o6f98DgtLShoKnFbxYJFDkfbXLxm3i/utVtUVpzn1frych0PxnhUIzw0opWlviZpnGkqzqI0qB6D93ccmd6AvLsFaePNwjr8b2TcdHvMF+ugS3gwg8WvKqn1jMlBqlOY55u137/Hn8kUqOtQTKPECxjqGMmcBGPSNsMhjpx3pINuTpiUXqLcAUypEkjoUa8WilOtBrb5oJG9ZefElKqh9ejXL1Jgt4YTdip5SAaHfdzX68lVBmf9VmKhndkaFTWUit4Z8FN4FIzaai+IbYe6o/2Uu+Fs+qw6hTBm41anL+bJzc/LPkEPD8WXtT50llod70scmtrtpA8NGQHKU7vGSeNOvW1GAwTrGm1onM49XoUDapStnNQDeFmEcKu/BhPBhbYUsctj63saN7OmPpH0A52eed5TErKdP8HAFyi6Ro3OpPx3l0auZEDx4oE4jpddIUIUiBqwZbzRLlFWq87cacX68AzbTkSeSjQfssCFEc9mWCQ3pbVO8fCus8IZyQXhwt6RU0ciwupaZhu6NcFIFfm462INIBo8uvOaQcA+yMNCZdXnTKlr6nXfL8sfJjNDAE/NP+FHuJhYNcFy0L/TbssO8DJaWubUVrEOrK+GpTmeJSQhakt41EGSnTIYf201X5GGzpE60e/O2xBRBfnsmnN+0NehU/2VnxATdfW1/7FTAgwFH2nCwqgA8runAHhfsNYY6bTTBQYkFPBNWstt4L2npCKURd7l5MHH/LGHFdcP8wO+mNy7TmwNhlxxdo6RGpAEHbGwEdaR4lHN3CHEJJ9H+SakUCt9aWkOX4RtkStEzc/SLn8YFRS557AzCm9UqubNcfUJMPXZS2WV5GR0W+H8q+OrSwR38ciuoG7uIGX0oFBqI5zNfQE7S6RXI6Dgy4Yzkg6JG2GIDKUPWb+xrhRO/b3NsVCckxuqRF1r4DX2tKoerpu/vGg8LQgYQz40ZJZ1jTwGkBtXfIBMLEF6csEwCgtV9ViWIuwtwlZzRP72UWhTUhgyYfQL3PIHLU8sCaPcoz34vcd34LeKmr2U7Hq+kIqyAzcRGUEj5yVXe5JIc/cyPnnXV4GXJTKOIIm2i/v/ajr75WBJqIoPtIulRMf3VGWZP4uXj5sbwxVJmP+UNqsev+I//0+5AuZ1HduUvdby+BKUpCKgyFp6uJ6GkN7bdGAlz6hBTtp/fKzjzQlPYf6fHVCcg62mPEoiBzaHPL9nzxwBF7tjhrVI1zY8dSrvuRsOo1PjE7k62DYaRn+abTKpPJT1ZijDkKPEsRyMFbY/sxu49qMA6trxjr3b4XO+uSHaJE6C5Tl4qsW8Vr1fOpGzz7HpleQqaDsdLecqeJUvBWtE4kOYUgRvzjkx9iQwQhXzT1M4lnzEALBnQQG92UD1vFDY5NT+8USWTFT+7C8m6DqcO3pnDyfSq7lxaUGXVvnQxmRInK3Binw/Ub4qQ1HnJNTyxUSZl82UJJWznB1fdnFB+DWAUw5JiuHxqYFPXnlinVeogqEXP7+cKyGSajs8m70BXyEWMkWa3Qm/awlo+YTBxrmsRptFnD6LgW015g/JEycZB2LdEvjkQ3BSMKzp8q3yeC+7Oj7MVgLNSEcRl1EMgTMhfXBsbnVS3SLsKRAcvVdEv53WaHsb2dOf+hgg6sGWOSEDuTeLJD9FJGi166E+pe99yJo8T3jieildW+vI6QPhTD0ry0iGU3WvkPRLqSJ/KNfddFNEw3JKBBNTYz4vCU+LBllaH+NE0cUOFWGVLV5o7IpUMSUlPN3X/JEH8iNoqbMJngqSpolYjhKHU26jkySZ+vbP1S580eGeQh91TdByZs/MiRaYHoWACVvC6Zy/gEFQFTnOBf2Qtw6rQINGArAaEZ3LsuDLQc8gz18cl8nIzxGdF3fF17GaL4BIkEXnBxa9YQ73dLXIKg3tWHMr0csYXK7ltPkLLA3x/smb9we5q8Wh2umxcmNP1qSjs5zUYWeL5c7Zj5hG6LU+/x0j5BNbGRER0g58Vp/uwFrDKYfklRgo9urecsL9XKMpCaloOoAzfhR4ZKiymsRUnD322tTYKVY4IuQ3zkOabr3vcv/JHfOQOAn59dwjc8WFei8TNTaUeRyhPeDzNxLgUivgEGUOqADrdRgnljmlfi83SrjLUuzFMhY7o+ZC10Mt4CYLV2wzD9QNOkcrxEYF5K4VL5GuQMKTbsNEjzJ/KcWuxadZuwrWLsHxvYnMDyAAOAId/he5NZwh7qBbYKgxvcYzrTEb7rJksCFQWpclARiVObi7en5JCo+1njTxhJsVitofmw2cdCAx+cjtqmzHSlH4blHIss2pK5Ge3y1TvvSmJpHylecI209X61Hsg9T6u8bwQndWBVWI9vZ37TT5ebM6XwxP317yOV1sfgcvQu2uvRR30j8gIXLsdwn8r2wvwsQ7QAAm/DiiM0q/h6mNwksJ0k6BDZhX5ZZSeFp20iJiQMBK8bkVeGQ0NyQUTdphx0Lkgt6bizkI1zdNZgzGwDYtbpAESikEqaQBDyaEaear+gPUwXu8UAVBd7M9K1BRdANBYSNIiUPVjRbmj1toNj8N3Lu35B3Kk4+w7QTQUEqYMr6TfnXY5Nfa2v9DnFwKIcbI/G8pyPbUA9jbRjNwCXGrrFiOcujw3+bLZqzIg3HNwAZDusZ7Ruqx+rpqMEbC7TYpLsZOSmwuLqamV8quDYP43L5wFpf50n+h6vsJsfZAcQabnzGv+doQDuAxK+Ms/eFKdQg9AeX2lf6+H+lHxaZYoWo979Gb7xpuPbzz6PxvcKoOM9A38naoGtlQ5CQA6bzgY5MXgksc5URZJwfDDuherd7O6PhkxFaPF7a9vu6wpCd1/8DUaDgqQf7PDezZdn4SPYrh9mkqY2rw8cR7ZdY/glOcju6qdx8sy656iucsSlwNqGlC/0lgPYi1qUt6KK76W7UWBHyAxrunSZWv43UV/gWCnACHszcxfFswLKjb74SpBL2u4PKfH285RRIUWZbxWDNPWuEStIw/uwpHi361N/uOCql0LEZ1q/xSXZtZJo16TAZXG3uMY5Mlq219DapWvLQw5HA3Be4XE7wCmQkQPhupCflu92nf+6h+fpPq5Ek5imgrn1WBuQ8bXSoVRkFf0qT8nFThNgrKIyBDo7O3gYb5NSKaLd503h68GrpDEd3ybQvhZ+M1xpS3J2x8+8muq8u2s4B7YCxZJjkT8BfnV3IedsotMxEwixhb+lUjed8oxqXF/9bIAU4zA/YvcRH0oDEZLE7RQ6cB2T484SjkgDHykA2CIppVbg1f546DEsXhKAkUJAqgv7Dpz39RPcRTxmEfssoIR9ZwdDPX4DCQiFhUkgbwwsgPXTnogu3yL1FZpf1fXchASEp2wdqp2lLljfHzfTKh2bQ+j7bchxdkHwC3fNzQHmBBPUIpkN/EJ/ry9Igwn5p92bFHNzjgdKzB85clXGMHr90X6u2Vw4sLDUlp8PdhwsomrojJwvZBnfIwZ9zOBl9N+gvr3Lnoa44QNCEPl3Y7X+pngIqjadZFjS0OH4JVs6Q88CV8PQzZGcOUZoPvSSiibSiYCjXZLUyl8GU2iAF/XFURY6ITFRRPvbbufWP7jOW6ydps1z5ZyrGe5Pn7lvN8vN5MO7FyNBwMRZz+qlnOv9cLRXgWLtBMkSVjtXvbuEwalqpsY1I3qBYiGq2+ZTmyxlUPQfuf4UHMO9YHlcR6BNXh49mN6DO0jEXUcE7wtTI0GNac5iuCstkagzgSJwR2ex/gKjIptIEJctCz+0Q9olvHo8yJS0JFobzwok0ZUwo/kF+lxNGTEHUHacmUCsodByb9eGomXG5Y+6hSDvWIsQnwgq6rGjbuTbU9jpVCiMZBbxGVMoiGm9yOopaKGmJ2kvKLdDu7oOGFSRr5sJhqZvFK48cCHxEpgk11vcc5bW8ZHwQLXyn2yCf31w+SPnKmk0dza9c192RamHhc6UU48qFZ9xY18ncDmbgcrbmOHctj6DGaFy1qGH9jcDX0+56B2opqqW6VARvhrFAh48gLfR4mwNVwz92QGCyl/O38kftoQLs0yQlQcP+U6g3Q3iOCq6X+pMWwwF20qBrqEwrpFmS5IUyuZuMy4qOk4VdwSMeVY5Fl81wcSrfTfRv7BupFCN3GxAMpTjQXR4dnc7NNJYIPGHFMOsoA5oP1X4gfWLE/QlrtKod1Re/yl07PK8jSVjrYlez96DRMUkaEsmcLR1A7fQ6dhnsKVX8C4BZdL8QlW7AO6/eYrL9RBzkhQqe3yqe3rbdd1UI3MO9cGelH7fWTPwtqddAULwP8pv53oXRgbjoGog4CZCOv+1RJQsFXEAA9JlPzk9qfl54iRBYVtaQuKimvaG+gLl1CKDOD5dwEK+GDg9I0QSV7ZE73d8Xo1+vHgoN3THPCJpEPATo3XuLykMhgtvxopWnHeNAJgbc8g9+ZiWORZhqA5o3JueMDH1LfOeQ6sZchvcfuqw0Pu3kCHXxbsjJbXrZa2B1lzz6U6QXxEPYoG9zNLcYe0QGGLkgv3hZEhSutI9FdkISehsV1y4x93flWuVAne/Jrgk/cmFzWRQLSUHiCRb6SHjEr3zIYDYNXbGLwVkF72YONcQTPOlks/0gdVERp2GuZhb6iymP57Ty8fF7Ew6P0/417ZgsDNds+Mfb9RuMYW6PI2Q6Mo9Jr3bnxdeVG5g6nbd6aGJr37nl/fdSbUDPipI2dvt7J2c9hK1ClSNIqdKPWjtg90IugKZLK0gfV5gZbHPUt52cjQ4tdl1C10KadhZjz0p+/ZXBsm9zqxrx0/XPirYbatFCXKV39I17nAzmqaZxTOq/T+zZyOEFh1iaSiHdouC2Gmv5ENRBjhKH08369DuEwGR/PsaP9BTTZBDbfzwxD/ZAlgH7pe/Qdv178jaWmRVxFuB6UwDhHh6W0pqhSCmkTULTnhAk0NUzJmWAQD3q8sYnUNhQx6I2zODQaMQMcbJ8yjVCU/PvS1djFXqZAj2l3CAPjneV7MRDmDc5K9bFoYOmILDn5iNhSvPWZTodomK6SrGd1gmsp/AL6aW1rF1p01B6xtUUKRVVld4DaEuuqONVvNoo7DnuU/gm9gTCHq3aM7+XpVP7WZMhvlSolVGs9t0eNKKYQ+q+frcA/HH432l5Andk64hCi5CyiYpJrtk/+/UxOlhx5RpcjVhWO/NxGGpMToa/iL+F7jWR+MUv0xToZBaVTCinhDvvHEUgfP5u2FnjEEd0HXGZIXVmKfSgSvxfS2eyJv0rk1wxyhy6hoWrdaB/XKXRnkvDJ07qt8gJlmprdo+EPntODVFKcRNRMJ+R3xq3lDUOOh0kA75WrqXLVPs0iRvpO/4Q+wDgCWAkUda7PipZZUA9sM1pquJ14ce+FUPNj3oDI5wf7DfbgyvR+R3IBDFg3embC3q63mKMlMO5jcDFNsiLYsgY6gvWJaOuOvxYHkgO5YWMiAlysSMRDcY9MuqNlPPoi4gvJ/PU11SED2Nt6wbHUAUp2ML8PFPw160Eykl2s4l2RaRKcSfiQT9jHGdcSgCJOoWH9B6AJG4kJGibp91/9icRNKoEsgEt6rCGn6MzaMaLCy6focrV4EIvgXE7raE6daPxPmYkVhdggybbYMTV16FJDFLdtp52PT9BF4TB89x2fxio0y/0mjc0gWDgMoK9GZAHvHVA59rVCuGPNvUb5xyCrdutfRVIz6J3WxuF22gDVD20n9jyeqO9mEIRQjfwDudPTgedesZSUqAGf1KZd047kQ8wdMdMNuQ1VXSv1jWbHA33ozO+F30ahfW9WRSpX4IK2AwIF+3IKKHzvr/RcWGvI2OeulCLDO2jhdturQeaBJ1oxcfYTrJZ/BA8tY0zhjdUlH0yT8nxdMgdWEsBLf7YT0EjqeoIR9qatwOJYlnLHjkGwr2VIFpc6r8+lSaDfWWIu9pDdmMjPunxzHY1xjtJnrmemEKtuyhJRC4OdV1L+5xLVlNopng98svkbGy6XD7C1KOr015qaQkJPJq8Ajp2Y1YQbc+nn2uXlhkofRVcq+WYEXVTnakaJz2jRBLkxksH7E+opFbG72WQ8mfrAN8/9xJgTWejEidQvhjq/WKhvxvEdKBX3x/5h8C7idj6lspjbmGUqEG0J51lwlVRiu8CTyteR6tLTRRwNbgCRqVNTX/iXIxKK2w/unBFkHhTz/p2e2CRU2aOj2z0bwAYLBFc6qLL8K/hrGiPbGsFu+9+/Bv8DtDMCld7Z98nTq3C161Q1B7G89U2mZ0AMDABRELL0hX/AIpawX1eRa6LciSEHeWkVppfBRM/MIStQBVNtvklA+QenK6isI6Ne3f6hUpEtOlcG/6LbeKqSIdLYeoKeKV2Ts+tTREiGC7MKTAHFfQJCXE+wEerv1LBoT0O6g1svXmwIR0PcQpXgrXAxIylWIHlkTLZ67E4ACMAQ+JPsojH4o0Eo7c4xZBeegyBPryqtHApydD4M+8DC86ckNSA/9q/kuPLJ2PU3EgUt2FbncvggNgQLfg+QjKU7pw9P3j/XXkMJwrQsEhLeQyWhucbrGtSDcMN+n90rwkPp8eiJmCEebxcNIr5GP3igRvdjmIOSlikBlgUvJ/zqgy6iK9Kd4uG7DWNlv/UXfBnDEg5dJbicj9QlDTlEWpY0Fj+hCz6HRkyc7YEQrXC6UVh1cF4n0+zNGvBh+je24/uGn48P3Mu6pjILHCegmhpbwBScgwKG/fAHXiltmYu3U4Sc+YqvJTEQyZW2WI26bCY5tVmU6DPWYtBfN5Lg3KQxBZol1If7X/IuJk9pKhvnPvJ1DimNg45H1Px5ZiD7K1N9sS356JyP0eSab/Oke2KW2LKSpUebAN2fedelvY6bkcMZg9MxU/IFwOqx2yxNjnpvQHYaieHl9qh/02w9qUxetyU8QP/6wgdvq7PSSdx+PGwdf9tpaYQtZsKUaYTS4FoSjfs1vW1wjCRkA/LLFB+VeQFocR0b87I7rJgLMPqSwp6cQsUMrLMAMh1t0TIZnNXkPxprP3DogFtN+t8+0PATzO4OiuaTKummoSY3V665AAaQI02ZCyWMrV2eUf01L+XPGafVjssYJ1TyEMG38NGEYaCJXBkc4+hmKgmQPUXo+eHPRu3sstRQoRJKHd3KW0J5RKnatI8QC8Ev2+VJJm8dPI17HQz+O1Gs6KE4OCgNNoiSoZSaOzZrxOVq0F2XD/9StvPCczWJ4mPLVvOxYyWCJuHnI81NHXv1SDnQzGDFRCaogbxz7fCY3L38ur+v0uRAIYOcauY09gprFfcUl5zygOUXtFAfBnl42C8qXWlWKni0BVSKWeGz74lZwWI/Xc2N4xnHcxmwAu/T707TbHQjqwgvKCIG2ts9Q7Db/SJchm4Iz1zN60P3d5Np6Bw+SyDqNAzMsESzG039J4Kb9qI0rjqEwC1/ydUAlBJGG5m9PuPZzACBc13Z90C07HslZmg/5d8JrAvcZWq/8nnvt95lLztAo9QTQoiy0bS0tDqXjKu3J078Kf5qfjXcka6jK7KB5puKJAGRGKxxH6Bd493bBi5DkaOWmEFrQ0BkgpnQCZnemM/PeHjC1G6iGWaHbstfuNowNKXY1QGJnH/gN+m7ydM9ZeOagI7SIDJtzva0VJgxpzEQ3shj3PLbOQlwHYCGQrj4iCVdJGcRuh7PGOipnhbaGWheUpgQvvN65pab2EB0IZML3reDaQ3rZ/6Sr1h+SWKh4DK+bxrgzPiHLA3/skcCXxaV0Qjcidgw6WVea4IF9hyrNdb/hqHbiMJilNHnCJm6NYwtGUr3TgzO7SzEsHlnSBziWRzK0C4PIlQvlO2l5MfyEZeeOSriz69T7JpcnzDFFmtHWfSeF+vYik6XWz/HUTdgbtm+tZpVdbB1NopuQvZ2FIRDDvU+c6Mgs+E8p7sWDXwimee+psdoCBuPQfp5Y/03anOz6+89lHXH6seoRCk8/Va3BaSPt1uEfzYJjIXqJd06nkbjxNuFXBGmWbWIiCXM11CGfEcA3vpQFHWV8LqKLLLCanN6qC44xoFIggcsmejy7465daTSquNa0rV2KI2IfD9ujWG6RYG7wfbCqRK6Pp5Q92GHATZchmabqSkedXj6/p5ThSIZVrMzrU9aVoKIiDGcXLhJbnQMkohUaTCSSM0v49INMJhynRY4HqzkQr2JM9Q4RNq6Rl8VdN68ToyJ8LqCWAXoO/JA2WYcdZIDmWR3o48fD3yjYTKahr6ssZ5fjQWiQFPunTyxYfBh5XdjqW1cQ/BgoczbfB9/GIgEctQ6UfVJ8hMXRnWhZB7Jz3Jz7N3pHd+rbextDeNr2s8nWR6cm3NHy51wG2LMx8LEQIC8LDTFvsAO/sRVaRWZKpjAV9Rkz0MnrgQC3tRCxnjdJISN1J7weqYO4RyrweL4pNxEm+/hjLd7fVqGUochXhWvvHGyx8CZC+Cwjka+3cgzQAVVswb3hl6kcM0kkPuV9DI/yQIOfht5JHwsVqoZ67aOH7daEcsy0rHtGa0IEfFjM6R0Kbfo8LRwXBHcnfy8FEx3OVpHpmQwqRmXwrutc4GQhy82rDdXOpSrfQxal3753Qch9keiDBKDSEuR7DZs7WYioLC3XnPuDcRj8Ba2LfDl6MG5Q6vQentCy0upq16PLMR9GGmxCMPiMhQS+9wcIIyiPIXAvdZ0aQRlKqlkD4CDgLRKYIQCagN+U83aDxSAai6r7dSZj4wIlmQeHaqPBi7inRBch4I77F/ZnnCNNVqUCaAqqPjBPZFcGVQ5Om8Sza5LHUTM3iNP27BZgfMb6PdPdKao8kLh3YNgbIOCrnovYdM4F4B/aVsJgCdgo6UmoMfCwiPZ0yLjun3Hw8a1pGKGfVE2aTB5+z2cMk5E290yrAjqQM8z01Ybnv9z7ObYGO/MG0CMOsUXjvX6OfqS5XlL8J9xgy7kTk/Z1bi3LfKIDcR7Y8t8RRA1qjLjKGB732E3uU0hc0JqfgW+VsdLoOlNpJSA6dWNMN3XWUfA2ZAUUdW4CaCZiDjNCUEsFG1wows+8dXl07XtLW/j43Cih7p4Hw6kv03xJSolOOQvb7yNA6HhI25SFH1UAcp6LIdo23v+v3dIG5XngrVC3CSeulXjvpwv9iHzEugZyYTiLvoGg/2Mq9jDxqd2DibRKa5AFQOOFiHsqjiw9vgRJaYdm1/eLQ0pAC8+xp+yIl150Ptc1Wmg/IhiBjeN8dNk38j7g3s3l/yCKW1/NpPgsjynQe7YPNjH49rx8u/r2cJHJwkbO4/mtYcE3NHA9//W7RmbjX4Hkppf7P6AeGWi+PNurJBhH1jV4ycPVqUoCantIOsc5BeOxaYgmjV06MGJzxa1scc6PxzrEqvODT1Rg3V/qJ9Pj3Je1LRGHPhLAZIwvElSgZ2BI/QS5u4FBH4MMy5qC0Ljx+XCqsqjcYjm5XodxI5PiAxLsdsNr4A0MFaW6oDvIOFlbH1a8uw3/iWB0HMLBUAS5KyfD0JX+dhl+2NgwMWcQvvxlinrLImnRTj3dzNq69qrA/b2Dijr22BytNrWV28fM3VO9UTPYz+EMju8IgNhZyr4h/+n5R73/m25e+UeillkExTop6L2F7xPAJEWTahbl6RjL7zLc8BVyO5+Uw7z0pyhQFHjpnUKlamlmlnQzXMQCXp/QZxb0a8HVxlFcqzB+zjvxJIJEu02YjoWgaGG2v2br+4bjFUdbS/AVX1Gsofi5XCMWVsVcGEvWdxucGA74vDTPxZWBYElk/xyUF68rv7ShTgJqa7JNA0QkLTJ7rzJwphACTvHO6dUYEU8aTAseToPwCTsBzxYpLJzb9fqZ99yqLtyPGTyhcOCMqMKAA9xYnNdvka1xi0zrMmgU/TM3VvqC+MEyfV7x1qNMaBYOSEIVI4juxwJvURJGIFIvjTtpGkvYfZJ/W4BTuS/4Nw3a3x6pMz2oDIaKf6ER8VD7xFYHRafgigFCqqdTexik62+1j7680Xqn7kaTLF8xJsrUsO1PZxacOQ01Vpywl6WgKDVU9E1yUqSvfGLcJzneDu+5ZKwddoxPPyr3ZM/67qu+vX5TWGUOSez6tKjIgy6vxX6Av5WVGedbcSGItUA8/LttYpm12yVvhxkj8vC+exKe6QTIw9e/QKvhS7X7DiXYqFfUN9RQSMAOFizC8v5295xu2eC5qHzkBjo698GIY2p060vCWgkbdKGULF2evzFUbL/f1hxxYhYC+s+eR4Mgulsg4vfsr8Nykzng/PYEkfgBh2zB0c05qBAoIEgWOM4AHSO1ST3M3q6/zOdh6h92aViYkgwlTgMqHC8Iuqs2m6F657Fj4Xr/lKEsmJdc2kXXhN0LoWaYy6mMMQjVnPOZTdA3MyNSRYRhvLISaf9C64JcT/m71CRjwkFpLDSHK9oROJ35D0N/8ujiBMjAZnjOHZc1iuouVvQYHeY77WnGaFdS1QAEbR4vAcIidquyjPJ4B6U6CDUjoEtBpL577BKD8JnBOz3jAgLeFejSA3MFQq/feRgHyuG1bR62DV1oXjT1tCvtM+zxEZFQetltAOzo6NNLfMNgNAn5KSrzp/jl9c/hhpYqraYprvV2BI1sw0Gnfj0qBsCKkKpg3qY4vurdd9BcK0JBy0dIlN109aWIpZWz+K9wSBE27v0te5Bf96suNf3osye2h0s0iLFRn3oAxYQeTFddlQVo9HLJPnoESXVHT+5pqNWkR2SgTt6ZG2h4XWqSuqpykHQdv9ZBvm3u05BYTSnaZ5Lyo8jn5/DfzcSJPsZFJNaOJ+jsCpzPNp86IL1cyUaHuMT/INBVDy7Fb+OM6ik053y8q7zuuqDPHUc+cC6heW2BAHeILQek4PrYYL92ImXzfl5GgGUXzmZx1QY1P8+sCPL+3Amo0q1aK3ui4y8Bp8KfxuS6hfZOQttSPrrnWZoZw3bXPkgRrOwVyMu6iseq/Ek0B/dnscSecwcVs1NYE6dCoewI9bD6+xQ8OIrsDw16RrjI/RZSjos9Tgu8cpWgl72nMu87DOD9tuHC402ZWUwhNkdoysdSZ3SKTHImOfBFPDKEcuvUyUCoX4Iwv933A6MZwcjCNx5LGsh/M1BY92hH8LRaSbniiRw0fmZeh3DNbJ41axxlRBcmcHZNhwp0BCtrNh8QiDzJbk/gaSB7AFIIU+rN18rEB7Ssb9+ycj4uQ0lUJOiILx2fyPhfwlOJMDuXe6w7P37Nj8SgqpdjtFwMakBSXbxS5LqxQ7iv12E6Nri+q4Rl0nf3Lf7V934hOTiDJF+ptiyMqZP9PwL1MMdFwfjJU4rW8g6jNPPRTXuQGnUc7ei9yJh4tQDfMEP7ZZVlKsNBb93Qmpg1brhevs7busqH4AmL/8QB/vSWsYxuoYEYMpeGpGEptT3IHFVwi/aQz2svAu+ivhs70uKG/X+XzAORsF1sMTTVxGffvFt7DJfe99MNOBZujdmj3Iq4Jt+iYttuJeVNjEo1/Xp7a2VbmKlQ6zrMmfDtllLbYpCsHbSnhaEZ8CdXSlmIZmReu7pGiw3aRzNBXD28IPB1HZKC2G+9rLxrycXsM3+qhNrgrLV4gp4jjdnAuedlPEJsXhwb6RnlJkP8a2+I/DAIC7kaHYDmJBusXyDMcATionbRAweo3lrV8wqpSDbtNVKuA365Hvu9tpgJ7bKGIW3osq9d1VmCQWHRXZaNMLbut5WcuqzSGlW8F2oyIzIB+A0DZC1azVTvNP+7bLJiPvRjvlZesJSwbWNyXi8WRy6KowLVEQMvZiqB78vCzYBmsw7mxdpr/zT6N9V1T6oT+VygTIMuhitXNeyckH6jkEcV5zyxrVNe5UBVxviRpzPwfTmBH9IG4lweJzBCV1d/qDsOGT6n+EhjoogJ9Qlz1oWyPPJltpRfC1q3Hwm9gXKcZhIwZ8Bz4EMESPhVlL8DCNF9IatrnKcoZBfrDNs9wQsO68IsX9Ndgqz/UQAojhjlQh2HJ2esCrrQhoZVzP0ubupPAYNR2PSZN+zDmhmySHjEKIvpxKkfYM9foTx7nf9kP+OKbpaMs0gsYWJO5vJHrGyvUl/BZTVS/vXzb744gTo03wVIwf5uCkDvLxogcH6N57ke6YqghWuV/68kDHITo4eJOg6t1v36VBtafkgX3lz/x15ztiFQ53Nysb/z74/tfVFJNLwWGjVJTEQQOckw1JQn0n4+7gOMWI3miLGkPlO5TLiK2nBLO9pc4Z+5sG2cBdCxgx6Lb/zS85FYBtmVBW1ol9JV+09XN8rOkHnbWYoyVtKN3M4Dc73qQgjdrCBsqNbCWkzxkiWlI0CfSycU7lDWSsSCbseirdm+Zl+gtlPplKWQudauk4PS5vwOoMejy+bNuDZtz8pqafpubPbcEaM1iGcPLX1v5Yh6WFTRC+iJHR42ktku6f+VL6E/VAL0BUVMZFYF+LhJdQr52G8g+KwJyV85ezOC/cLb62iepUnhpL7j3Y5h2z2nVzxrHeT4zGMpQ+kM3rM2mLmGMCKre3VuaDCf2PPJw6eiTv639viNWO67iG7wTe7ETmMKev7SYmvnT1ssvoIJ9fHvgJ/F+es0VwvurDlmyURJqjM3sV85dacMcmrlNMYwIfdxZk8IKR47QDXDumEsCkRQ4DJ3IM/bUgYqdQftispkQJgEMlqUDYMknDXOkbYGhKHK6sI/wlONz9+4X0Nv0h04k8pl+LFRxCB0J0K+a5Rp+b41vLP0cZFng2VmxNXeAYhNZhPI3XuQwm5RFWuUlgRirAdU2BjzQy5d58XeZ7MEY85C7yWJZ+89Nz0gJK3fHx//J4cYyoz16OVUyJBWeEqdU5s+LzjNdqXOZaVhxIypCpckpc2Kb1AWZLi5Vu7njL04iVAymEo8P/R4upHWeZz2e764Ce1yB0k4/PHj1rFhn+gcmNJylUZik8hMJ4GwCIcmtmxvrpDUg6cKXsK2ha/5dWSAZ5ryRCPuDHphFLpOA95y5nQtwZWcwdUpWDkNkS9mVe8YAru0zT3420fipRqxNM7wGdwEPlVar7gw7SSPqb4wKIZ7x4Jfy9a99/PD/b3g4jDUIsfsA7y7oO94RDszrrL6+VBlKZF/J8vtZm1nwJuw4Wvv16lTYLGr7QAHW7+Hfen1qHcKMwkdWqvuqaqUTC3uWshKcv9Mz8oF6ohKM75Ku3cBcsmHe8S0CsbroqOaMb+7z2rsQJjukjNAwsfB0kAcyKrpkpXJlSqIFAo4Ni4zG2OgosyLPek49vEmHWWI/UN6Dcu6AyHDL8yAbxnIMMdpbSLwQCB3U5Esa9DGzvkiYS0W5NAGbgvWCqWJWnDxj70wT2B2R1iN8ylt+8E2i6KFcjJWlijSzXVFko4hW23LKhap4TCDz12kb3R5y1IL005lCEwX0xRx3GaY0+WG+Wzjh6sIvs57E/RTPJ0PH8OqhgEmlu/Ro+OpQ6g9L6YRYMddXpMQxF8GBQuwUfp/N8n6SJ77DjJhHidW2G9zN/AHW9X48AK+JZKR9VsiSl9VNamBP8GosgMeXLDR17DtSEsP0TaS4ltYgR8fYNnFYA3R5DkxinYMlXb2Dp7eB24zP/9EdpinY2THnfUqUunHkkw5zLKgjQdLJuItqtW2Kaf9BYiEf/A8KsAvH4p4Sy87ZHlORUhD4Wi8ArsLfzIRnhO0HukeXAFF8maahIaqhWPp1HjAKIFVtI3luR03nKhMvH1/DlCrBdYlNUmuEsU93G6JFVFsADmGmPgrZSxPa8E6499xr+17L22dh7jNj/1SVHkNIeqs2ygvux1LPHVM6WAHTobCNwKcezvGNaVHH2pADWXfXZeIFd2BYjhi8GHja9F4rybKLtrp66f/xJhYRsbPgfAVlwrAZM5Q1waXKZ2JyT66kSOmcXbFjPysU32GuM9cX3weK3Ixg9f3QFuzRrSUjmesdO8/Ug34bYKQnBXdzekdCqz1fe+el3k4I9bOqnAjgPm0E3s2W2CbvAjzKR/M0YvqiXRak2rtjUNECNLMkwrtfFcbgfy4zY1qmndIu51TQt7mWrn8S7Y+aBMTHO3wxRwS6oB+UmsQXB4TEcr7S6QPS+VQo2rM8Cgidio9MlxfpaCHvn9JVrRfu5O9G4/ubtddBBkiIjoegdGiL5dpJSKxBORtejQyXFfwTUWeNi0Z6nAPexnO0+KpjuOlS54jiwzB0nXEkgEI5WlZTRaKzSABPuKTr4/bJj7BeM/KfQ2J0mCmR2o3Wj13xcprhTAuZPGtP3u2DCmJ6XqL4FYKr2FAHf4HgmXBW+ZYV8OVilozSRYa/qiFvJSgkUARAopN6eSIFHeyIVBN0V8wcVZEk+rYiJFuaXHxlQQ4XZ3nhv4/33K5xjWsdf18/4Ci9FPzcOgz24EnPlXAmWrG9JHnrsc3iSGdXMogkAjc5WueO/b+eHcR6kBFNRihBwTj/sxqEF8PZhg/MH5Wg1b8RBQwRzo5ipdalMxRJSuY95y6/bronX/yM3rZ/1ZKOZVdGSQ5rCAOgbRwP/F+rQNollyibb/ncI3SY8FgaBCBnkQwBTW0s5esF95THoL0ntM6/7gCfjSZJblzAcRiL3Ky7c8hL+xvEPnFhsmrVTYBcsOFNMAq7pYIGn2XvuU/vLvHIl+RXFr3SkLYbiLBtI0l2acX6wlJ7Ur0JwtTXL+fFbF/dsuE3CYwOHDwvWJ+7qfX0PBscee/LHpkizVV1UqRCM1TvHy/d85h8VEN1imCBtDloWnh2KS+1OIgUN8J+BDpz0VgaB3LCfV6rGtcG/Fp98Zvda57sQrDf0BEszTqFklOrfVC8mV8Xf3+a6hIyE+dvB2ZcHJHhCH93KInX9vdAksSuxjhRejsh6ben5T9q+/I/gqStGODEEE09v+BX7I16gDO/4x2ANjcUK9r9uwOW5PaYnLjrORb33IKdMPhixIoOABgq7+mG5FrBKNUFCvblBQbBFR5J9HM9hdvoqzBVgTnW/6x/9QDab/aqzc43CQ+mSpfgWgWyHvdGqs4EV/BMGO60wDDVTVUTol2nG9xS4nQLBY6c3G+JFKbjejFBtqAqiGNaRZ3TixNjlW5lL6f8v9YmO9Df7ZEPe6YI8tSWYgqoLLLrOEQ6Kx7qvZNcXEyGLmbBdalNjZny8ZDw36AXPIcNz3Y/DlTTyn6Zh5mQgX3d4hZx1yfYNsWCl84XlQgSH0zp0+SwnnZM+6kuE/DEG4ORCGVGZ2OwTuq/qHc7LA9WpsS7PC6kAKuT02qj81JPKKOMsEcUchruWJTxOjI3EisezbBlFuVZht9zAe7vxM3GU0bwJhSb5ZhLght517COiLtDz3RulSOnmStTDm2C0CR7bsJLXY2lt1PmRDqM7G1wR1QylhtbiZ2uQyl0PHnssjukeqzyVrHp6BIudsU0NsaKvSeNSWl33m/5Gy/KmW+TjJAJ/bHn3ataVcBpq4f9+i2j5jTphX0eYDba3uJx/he0ck2GKU8+ppacsy4c+wLTWuzecElVuBP4aMFWIO81eGAymS8O48f3/fi00Kf9OMAzH1A0osORWGQvWO89DewPrp4+O9G74VD/RSzVvnMlV8GkGc59nmozmTaN68TckPc0QWSvd8OWuhQEJuaT6MIVP7nzAsSJ7KfOjJtwRic3hPt/LHj1UrqV473KWzZvl56A1h7jji3kmEGVHiawxgKEGFltdoNuW+UKzWtiwLZEXwlTsWpXiWu+76Vh9HI9lAlNEBPGJoDY/h/RW/9J+Wg7c5/2Mzf4sIVAsrp9cax4x5lTuEFouTljZyLMSwnlyyJ9MQbrYS5fwXJtV1aAJ9VxjGDrMc/P4/3w1NIVs9hfcSFXGTaSHMR1FiXF2vpgypjkvQmU8yPax6f1cdZ6RafUhQZsCanLdmHfNE/o6cQOAFzD4sOJ8mC9FfzpgxqwIzxAHfDZimROU8vRvKmzvdu9pXOWtefS3tRhhW1B9/Wfngw/HUyCIHGtEdypcrqlrBkyQIbBz94p3D7yHS+vt/LKxcI35XUNTyldAd1tGZ9glJy9bt19m/dg+D/53krRs8Vdtg/y92SRiNoELLBJyo1NgtSmIHsl7/7nIg6qsyupC6W32ACuXaCGBnyb1fVNsLbQ4WxwoeDggFMINoafmRNQX56ePxsKKfl5O7cLrhu2dCnVc2u6Z8iqod1dVF4VQFhqwPFd9a+ZXhjF9ySSLT/9pHq5PX3sYYg1gZvHAezoFItqLq0muyKjkYMgNiEKY0BPkwDqO7OoSaNeaPO947sOZujO69qgxzb9oK7GB+8JfRdVi5nXR32UiQTNozPYCW4tvWnL9hKjjX1lJEUxmkSpLbT9ZNgqLZSkFmDQ/6bVgwe5rfJX5ozFMk3H3bHPUTz3fpdzdnONFQzdijZF5JMwXtqSWmedexb4yLg77cRGbLxYvvwR9BdLB9Rg5UYkC511uT6WheK7nN3ouZdVLpPkZu19N83o5go6SyGGhpxWe/Zzj1QtQHbOJTCLbNWM8jMlowVETh48l6UyktXXPJXziDaswoeQinrtFkJ1iCMb9kQwgynNIpnUuEASgAPtAWQZnFMhkGMAf3HcX14I4lP5Rnitd+smt0IsyHI5Ki90cLf7HPrytea0Cin7ZfKHjkXPvPeQt0qKZuXNknvytZc6aY5JkIgRPEpXxGSProj0FNphzdiXMf8b6pBAjZCB5Vfcs1QUEJ325lN8cDfKHB82cFfZy3ZnqEIa//6FxZIFQ18HxbcG6AeYjq5kkiSMhpPTkw6fxBJ/5H3puKhExmBvJWcnJsb+IVei1JwQc0eeR49qz8qapoOCa8qtIrSmnz1xgJmnHK40kZUUKA2ThwcbknMUj0xgOacEO6O3wK36lW0RVWUAO3JQx+MMxbJMDwd0/RA9O+4xByAhLh5aXgCdqUlgku/2V4uf4GWLdZZMrGNtcEvLwNY8yLIErrfvfNix0xJvr9T07jqk0iYUJKSWIq2TOrsav4pGcmi1RD4P6QmRa0hwZODZ29bJEEwwVzHUcb7hWQobre6MI0fS7/fvqjd4KIVEICRCWNynqnbyU+kWyxOYiH5cokuVwBw1MRn8TGtPqwKFbNPzqNxhKi7tZfgxYkek4qE0vy8mYVINqBkU596nIgMZVdSXjh1XdSunf+gDWngU6IzEI1HyohFiIw9C3teocjbPyrTTeiOeKryrybC29GlpNT9JbVfzLWBAJBPbiHbmVfhq4vqabd8Grck+GX3HD3qvvX6fTFcOyFi/ceU1RkgB4Jwsdt2Yc/+vkhfNzXpoJF25h32brh8r9Kp9kYYenx7nRPXyXMZHreLYyEYcygz71D2Ew5d6tFGJ0VyX21XrPkzHXTNjwkPQsr8XpB6QPANMVTGVq8Ya3iUBPwUNCLJTz6k8iI0xXvyGJ8dOY9HfcdGtlS2ogrzHRPWqA/1gkbI0cIfQ0rwb/pYp2kc0nP4DDWLcjmbT+DEA4sEY9KugSoaZRUz7qyvJhf3VlpisDJCfZgOlYYEGXseAOVQHGrHF5sMWzX/2Ni2Z+YqFBVO4qggOIv+22F0N5ks0hbpnoD1az4cgTGUUfQVN4Te7iDL8Sjc/CX3lJ7pKPzjZJJor6Ma91XcgFBvYLgOKp0QGQce+NQpSSVnMKdSqLkL+6Rxi+by8W8it8Qz7fWBr+j6ImVQuu+HCnEIdB4dygrplIsMaofUzoHQdiNUo6GrJjhR2OruGfOtPqzMYEaaQF4GIBhxQxPjlw0XrT79YM3/pNVue3u8/EF5PBp/soRmWDxaWex9KqySWyI80vgWz4+JrOaHbMVS1xzyuFXo1KJgVpJgmICOQTaaxlpDDJa5SYecsvLI6zHIcz8G8fXe0zJAeI3WJVxTOX4adTON36j48aLstUkzLCIIIoumIeFCp7WD1ChjIcHLw7TuZqeIaAesb0e+QZLmpadCAj647wzudVMspYr19qd9VP8bwg0Dq9E0D31PnbBl4egKW9uShgiqSOgaPX1mdH6NoMf7IncWvVy776E5jVRW0g6pO1CycvJe62cSiUr7Y5s7MKQdCMGoAxpKSCIxfXHfaVNTODofqB0G98Z0zimvjtrYW/prgXZj5DHEOcCvcIjVQMp0DxtAKP7liQRMEkZIXR8ZbrnTA3W+UpATgNncj+N91wkimG0eKxZFLoXSo/F0i0JL46oAnTiUXrR72doDe7ZVGvNNQDdTaqn26ELszNYaMm1txhMG8sXQ5WuP0BqQRrNwJobIzACz3fyyGYqj+w5IZZ5BaOuV7djpLKt5vBXbKeWaYVs9duSYVSoxrc5JdoGeC81A9HH3SLYdBooL9xFe3Ip0/clmXmN9wwJfQilhM53+O+e8QahAx0y3+Ex1KSitSrJMWLFZ06kmcY9jZ+rxLzz/FHs4XwS2MndggX4INwmQlBlSk9Jsc/nBRkyMuM7f0zmBP5dtvIrnA/An1PxXgzK5r2gdWrl4Ft6l4JRiJ2PlPWQWmVEmIJFX4FknKzhvp1o4ZWYaD/jy66QukgrOlGZn5OwvklOMKQ1AH2fepIV3SvC1F/r29ELldr1+Km+dQRD+Kmo5QOYAPt5SNW+tYAj51oOFi1xJJM8sXG6qTgSsxjVWSj2Sd5QE9QqEOhVJhOm1W/UA9fIEDR2P+IFShOe2RjZW8cWDpUZn7uDz5ccbHVgKn6OoAxvZ3I6qwu8CoDWtMlebJkflO47lcH7stjkabyZhZrY4EunsDP+GMM4m4mLr44+KfhI0oIe/DiNrwXukwSv3EAdVRnAneOOEo1ylmTVNnTN4TphiR1vJxZtEIEq61JtQY/ubb6UZZG4zBzK49UKcmGmDj76Q2uSzC9UB77YB5b8wuWQuMRKSs2wbczuW2SMm2SbDwbFHfa9c2IHqY9c5jDylvZCoEwX5UFxyULb5o2gcxo7sfLcqe0Fd96wnKa6LkWqs50+kMie7jTV97p5b0LxHp+wDSor/O+/sBM9gx2E7vOupuElE41WBzei+FMx6UhZa8XIIpCpli9E8/cyUMMNid+4ijEmj2f+kZOsr2m/cu7jZtW2Xakwwz3n7sKNkOkJfBM55RCF9WfMq0PbukRRytShICtDiwIEktnQjQKYzMPhIOT7jtypuDPrOia60k2yx6m0R5u6THXUK+NtrN3dokkUgIbboVouYrucQAdCacfqeZIrAUAxIhou0MYTl73Fu4WlyxkBj3qrFes1ryRfj8UKyymZDlp49xpKg+FjNNo91ZUXzdw1ejsnhKVI18L9Uwqxxdxb11cVEXE3JKPqdo5AlMWZEw6Os718mPPDYYgntl37MmzwrCOLUrFNZ380BUaFBRVwv97kpSahmR69ZF5VV0LyCPSm3o+2aLl6YS52xQnjrwoPrnh66CwEio0P4GLsdWTr2KW7vq1t90dnJ2mMFqtdElm8l0VXkedQiMhEzJe583tbgukR0VEwfgxE8wToyasxg860vxZUN8ir4EjUWtnHpK7PGyKiYCusPERN5nC/ZFM8vgLdNFeCiI8+zuF0ePjxTay7qIgxEg6y9/9q2+WTlglYUuv71mNkI0tSqYOXVhAmGS0VLdk9qua0cp8lBkwHNKDm0QqOtT6B5k1Y7POW3AmrmrSjmeb/VS2uV3lkC9RwzeLT/3ED6drEj208WS3RArS5hovVoB2Sta37ARxm8nK7eXQmCk+NsVwKmpnYup6JuaK45yU8nv3LVJ3jB5zNMWFcd07vNJajD9tqWEqeCwIasiAb9XSUIc5gQgKqVbmp/Di+daA0F2NfExQXeX2R/h6wn4N/sj0e31R93v3LUKIGiGhsc35gndfnCr72XEdyr7zx3MWTu/3L5XBiUAmy1EA+9jYvqSFYcYforAoyPbUvRsupVhPxEYzBALHAHnqVSq8HVULZEFwOA4iFq2HN8dAKIwoRoDwpx8gFlhuW29hA7XtB9e+Z7Aaokk0TBp7F13XH0A8osiVsh2S9TnMOejfdNtY4E01t9BJZVaqoVCqzXrKkli/j4s1sH88GsX6nZ2oSiJR/SqItXuMlpH80frzJ3A/gJLAxXr6vm4wA8+WhJYSIp5xUM9H+n76Sdf9MvNtBm3ioKXEHpENAECXrXJ5s/HsEog3n2j31DK+ZE0wMyKXveH0yTek2wX3ASjpuUNiwOuotjdJs0j9sGa4zp+hPy1t1IpJATgwzZzMPxNwdCVJ9SM4xX9ysrd5adsG/6UDIXAu72Geqrb8jpfOBxJ+6dTQr5mIKRO5TnernM6j+nULBS1F8nCCPS+eoJ8pdLvzm2Fb2vXf8m2J05pVh32f130aHCOpcW+QIZtQDVYJvGZXq9rGZCXo3VlqZKawwfmcTXf/RqAv7P3AmCmufhSEnt/XZlR8N95yH1uz3RqWClVjA0TCYuhUas7rlyADfpeyVNRtL2d5/1fKij3sHTb/P7QbEgE+HaxEYWuGDU+WbGZzGauCsnx9Oe4brtPHk7mWmbc6s9qSlXRiryesX7HFB6asGwhtVrWb1xbteJJd314QATEOiNyIg6jL5jYLuvVW3ubaOw1rhrQSQyJbS1gk10NF5lIdiQlDsFiQRVpK6Xb7K83TKcmi2aTB/r4Fq4uSxdUqzm5TPK3X8UyLVvcHOJdUD/KAUDousDZxbyJIlBbqd94C5YBblfPEsVDsrIjbq0jQnVOISekuyeB700mNg5OQSVKJyVe4GpmX/eUyxUiSc0KBAdG2e6kJHcAx3eFa4dFdq8ieXJOSAL4ZaDChadLsG6HFp4PPQe+F8sjbUG2/47CjxrnDnmkQXipc5A3OGW3uL8vPpFaj++3d+1RezJfTgzIxo0T65/VZSfg4VgSnNnoYXA9taaCkKE9v7IxRRUvgIHdHWcyVA5v3LYLnjCqHyvHVGfKj4U9gzb6hv9qi7/ESVHVokUG+fSL4vWNy1JiTlT5LLOxmE5uPLGiSQ91bMvq15b6kFFQXXnhvv0ok0bv7BtwB4M9hn6z6vUDbcvKL3GrLQjdYakt1n5AfqSO6k4bmvc5/LPAMd1ifPYzKs1WmREBI7JK0cruvpYDXCdlqQ9cA4+KafbZGyivrZWDXVzZkOJLutknrMMCdj1djJjdfE28XJw65pGCBdcohxnsX9CujCgt7UmYwgtMvIjG8Ck5ijYA2wJXX+1kMmBerDxSnC2JHwKIFvhS/lvYWE0uKLi6csqzoxgEf+vRLW4jdMjtLZ1TUwor/orz8HhIVr6rXsYSjCq5g4I0F8gRIc91O8c0y7jT91RAOnVU0V6bhKpiiHZa1dluoIlV4QB2qJD/nTUzdC532kmHnhpBDzw3O7WElIyCNZuOYq3ZBXkxL7cIEp1/ioayKcV5QxulFEgoIWwM+Xt8lRaUVukfsQ2gt1toZgluDqGflY6kz8DkxXShErTPlYQOvOs7ohQIUTLcVzJzHyy3zjyvYBlqCE/Uqj/vmBtUGbEdwMRUgPqoyPFESaIUN7SfVBIPYuUOKqPWKYDErdPOFeDg3IOjOLXgYMu4DPwbTV6iG4VeehgYz+2ShHOuGRgjv3yHqE7MLmUp4lytvMrssy/7zMhl3x/R5UZqnWeiK9BOLwQCovbh2QymXDilK86OCONWk1zpKYPxblzEc8+dblfwtovvcYjvfKZdcweMungezVUR1PIqjrW7cuUb71aVpqZlYympyh+YF57tCcuOd1+E5LPt5LSEnQuG+hPE3QoDaLQBH2ymrvnkZbMNm+1B+3Ab2AmcnOC6xtx2FdfwS9+2eNUOAk1wqaLKZpWi56sJlTmCsjd9AnEpLu8tedzimgCSNdUwd/GLgOJ1Q/O1uDpKvskujBMXDZDmoBLeFXIQoyjR91nx0/j7JcW0sphfnvoylfbOsQAjy9nHEG7+6jCVdUnh/vDkbl1UZdMKOIE5snHt8YQgSEp7BhHeFoV3HD27kCOT7D5nk1eVeCDWymrZCN6D0EJd2gOCVDhp6PXc3nkywkUJJgbCxQ4vu8fhOn2G3aC7IUQdsqvx+dZzxLE7YS0EKIFi7muEMFbW+eaw86Ogs9rNzifVb2VOiXOTzlCOXyl69Eno0BkADyq+PeHN4HOTCQLal180wC8LoDTE5JJjHBLpiswaLhgjhCkijbQDvIevcVTCOH+L/SEjEd3rVoBgvN6vlLPun7GbigTWm64Pc5ngoAOpsByV3ZEu2fLiGcxtX8Pfivi9qChSdB2BGoRgjW29nj+O5Fbf+zOp2+/hEtH29NThi7AB80i0spGe4i6elqEeU+a58tivdXtn8TwDyXA80rY7N2+CXGnI5Ua361NOreH4LimwrLiw171sa8YFrIJ5P6GyXb+RGidaKsxN1pmZhBa2Ypd/xsV6YsPTUT7104uq1nPE+K9xL20raZNvyFyxNjZPOmbwTlbw99GXs2/iFQbjK2/obSd/8xaa9QFpbSScgh9XPDVIFnR/8W+EMPWIOVR5pSn27cAM2gX/A9UIo8+YhWcSGIm7NPxfe9WFx6UiXHcjJ3MqkVzwC0r/P08kkUPjLzjeCkGCApKQlm53vx8huHw4Cq20/Pd9Ua9fP8KMDXGKQZly5w8wQjefpTi2//XI2V3m7KcI4jpVJKqi36vHdt2LilXLwJ+Pt/CmFJ4vK3QgvRjXJJn1gzM0pyJ9HOmLx0gtY62/DPT57YSDgF7qLqnb4C4dElImRWXlo33SQ5tBsjHS92QI/iu3kzV9Z9CQzhjX+k+glhZHlBkjU6/GCHSI5+XoaN1uhq0bC8PySNjZzwHot4QKT/dNTBxb5r86kOrtAVva78i8mrjtbHpI9WxICkwgNU7PsHC/nL7WVAdhHcuHjoEajc1c+hwZpcHDzRMT/wThKzC+MXVhj6425vvFFQK/RfRaDPtiNAL6SHZONvZm6DqCHnR3CsCDHA2hR3O1tfd0uessg/HXRM6PkAcOqcVaeZgA4GlIuYP7PFcmCSGICVkhbLIb+1yhVz3+VFQChjCtlIwS8ZhH56mV2/pqKDYLinMHFriPk4hWg70VONcr/nf1oj4ZNrm8+goWmUU6EeHWKs5ODxA0841nr6vOheVXzhomL0CbWokQ/TP0b9/udM3PFgDRZY7AHnbpOxoIQGp3gswkCmg0qYfkDRItBr9zLu/xCUnnqVfyJ9BMLUyvk3R3Z5diWM+00vklAo7ebXr/SMueGH8KrB9MX73k/aOQMRsAtDLLpe9w3Q2tcX/E7UJuYOLKj5+wPqXAI5uOeOhMC1uWaiDy6FGEVGkxSTkcBkg+17jNAEa4Ucv2kf8FnspVnysIBoUg2Iv2/JvWRxPu8WPCB0b1UZ+R3R/atYli8Uvt7k7QlB0vCy/fbOffRfiC9wEF22oFJRyhHNDQM+eY7yttAlpWUppKYUM1R9Mqs30nYrRDXEaKMUSKrXwbX9HMbV2TMoy1/0N0RJXecin+Qm1EdFlTX7dJyxQedrINanaSIFrBcMeD9/S6GCcoKGm6wCjuL3G63boPRiVs9wO7CyKBhNNyK2Gl3Np1VzFCHxCTc2gHdbk4bDPBeeQxgmlfEuan8VNKSoSZ+ACz7rgMqCVq4O1TDwQPYSsNa2SDzzYziruvltTNyXzvu9f2v2BGyfhomsFfiB3k75NpLWKjoSt+M6sC/9CDwbzdQQWAeFXWaVc5awkfGfu9aN0AIblmowdGQkkz8DtDUb7+ZhCjfnWm4pzvj9QeZXinTAKkq54sXRRIspOrqAAGHXonyI+/hCTNxQoxkHz79XMakhlVfUfzTg6e7w6DDvVJWUi1CKXX8vyqnf2ChX1qwaUTryo6CS+IlvVxOG5hajxL4Nfq44TZCkQ7EyqtJ62FauaSf5z1ITq6FZ2LRMdQjbq+63ZjirfndCCfto87GodHl8uYEDFb3pBqYQSG1iZvyROhS67k19dl4rUXRRxl3D31Sjwc/aOwk1ZGzNWT7y1EI7xaXKTJA3T4piROLcvkb5akbw3TU9YyTcScGrKaQvLt6h1/gJ3mTdSRpOyyWmH2n2T2frphxx7KPm4+KWd38yNbIsm6iZo9WFbaKR0c/JktW2uG+vPmzLSw5Tg31gTLeUmWfCvKy8mVqlFFUXBBxcD9KsLQRRlNNXSjVUYBg6NcFcdzTWpu3/vrIzXgYrac+xYkcJg1nMMsitDSI96UWw6OAJUC017ek2RP1SP5gw8TQmDUnIdOLZht7CUVu4ZIfJvrUcCAw2hEi0qNyHqzlIX2BNYWgwDROufo87sbHWzqXsJSYEM4aayr9InuybX5fRc1H/WrfDOZjanoHLbY5kNkyC7n4ksd/ukGXRQCDaTMWFoexhlNNB852NzXEkYYeP39RtanF0AUPwAYY2ueNFWyEhg9g0YDkAKT7Qt1uaS/54m9QEl2BcuY7/hoU4BDq4ypRM+5XuhhM/HNWHHOYXAEG/LLwCDB42kCDu90PzVGZvHVkgAqUFgLPYROSI0tEfgBZL4c19obTwiojrPLK0u8DnAvxIEo5A5sjPb2ubY+WiX/O7edYHSCOvFRNqCPbdczGJQZwCbRRCTBEetJiTTG3umMnhdgLJ0d5gVxWZyEot4HPr7p88MjUmjbLtAW5fypISt49FzcCJfIyDO5sPJzhBB8Dse7d88Qowzovcsc4Bw1cyTKo2rJpSxzWvtUxx2KoCdiDP4oEvr5zm4/uf0pKcSbJ/UM/Ca6EbO7HpOlwIagTAy1Db686Xjj4cHAxS08f57+/FQgfKTBlff7eTbaQ7XjC22tpjzzKVGIvwJuvcBtlyzNJZeLi/oVoX9TArmex8U//MY2vG6LFTEv5VrMvfHmw9VoDl9siKFw3VVn+lSCm/XiSgXhaerXmg+dQDINzN47YnLytpKp+RqeCCHWeTmI4kQkd5GFzA1WecA/GY5zfyOYgp2UiqHon7Cegq+ly9LmXFUdirudpwxWlkRa01djl2D1WghAri6OHbKu9ZCP6/rkjYwGj/4fRXJ6U6vRqerK07xowB5JLYryZY+FKZfUNLR8DXB7m1htRSB0d7Z0rI12QGUaP65aGlFS98te9famUfMqLe3RW8T0tEQjyai45Yadl2/7jAa2aKYwk+9sDC3QhlfDZq9jOvTMS/fiaqMjp23p/vLPT8p6xkan190G+D/cmh6ytkBawTofGHzEsPZ3+1mnHrLBD1Iub38tIgB0cTGVL+t8tDTXcDzYWuHSIuHPMeiDSnkdlbE0Xdx/uU4veXMDVVAzofp4vg5wyXT0M4fThEBzUUrlGDn9KaUo6ior3gwGTWkCJLU0Yye3BPEvurrtE5Cnja4kCq24w4VqtKe44P+7mQukKZL/Z+6skcI4zQrIArzGHUqdw/k7XQMPK0Q6kBrGyXwOqzb58PJldto3XudKZVQQz1SAqahnL2WMJWNMkD0UfGiyQxJ2f8pPjXjl53C80XaFqBNbUYl5ATx61g5JWcsyYzrjgF53I5Ziw0HK20SSAD5TJid/4wNxOlQzM52igGIfCcOtgALQE2K9rG+6TsEDUoRBbpgtdKVrGTYxMT5liLgMcCysGzNwIgwC9C+65HMTS6DNeBXDPhWh0RkcEeXvvNTla/XKqfH6/YMdTovERAalpNJLKu2iI4/dkqiZYDyM1/baWQnoy5E26HxsbqhrY5wgzq2+WiFG8RbUemPyo0G2gW76hB9iV2lK5U6LLMpH1x+/wgdRFlRsgYE4uOjvfBdpbBXEob1Jrknsrb/i7QCHFXCk8kTXQ2MOfMFqJbB3l+7GRQsoPvwbgSwT0nZ+N/uUDEUbuOfC8Dgst151ISQOD/hHPm6jre5de7rnPaRb3Glmvo+GKOqVvbnYt9Zp4dFHkvj4UrO8BVFyGtv7/UpmDOZqOQKPQvc+o/UoIVyXf4qlOyhKfY+/psz8XdDpX6I//Q7Ajv+nAkp7f9jfTHVHCC65TFotpPMDmvtvjqtQTAzLzH60cq/xV2LZ+oPIUl005zNZT3im0mOhYnwL+jGYc5qTNlPk992Z2bJnQTnr9Fn069glRAJz0M3RgHr/m8yroNkvHVS81CoQeJpj8eN20nEhob7hx6mBGl8HnmkG59dMYFENX0N2NpbFxxNl7IxLUquLtE7nCh/3VrxJ23qk9SrUclRT0mI2XAWAPIq4RGdDdQ6yQa4ITohp/CQubilFG95Ix9VkoJlnTXlJfeYE+01fqPtxF9WarkIjTyaIeymyO1INh7m+SVqSBB1tZNZ3RhJi3Rv5IUHRFTQtoVuIPm+SpbGwAnAKFeZQz+yeIEx91GYT+8rz3Fy9j1sMBfodCyppKEWLAtp4GCqIJ20tBDJ4jRyS1vuqj8yI0mDgWhuF4iE5X/QZtb9ggboU9GrpCxhSU8ZTlHNKFOeID/TO4+d1V09/NG+57vs76PzgfOML0a+42/pGkixxaAKnXfFsxRL48zyp3LIOHEbjK6AEf4KrPPCpbt2BFLaD0II9oZ4uXFQbtULT2IgU5DO6KMNOFcqyklS2eCczwjTXZCgZxbBfUwUoMFkvrw/xcTPDW0PZ+da/I+NQSKk1tMjzAtSjYpsNrNMktXbQ0WP00q+wmOeLXWaf7FGNJl3uD6vHKjLrSN4qIf+z4nsOw1bLiYkw1Hga28MFkLagMe8XFdGuw65hP7f0nctLjR4YXyTnVYbEeKAvZfOu8iYra8Og0Zyrgn4MKRbLkllytg5KPRjjKuB3Hp9cwp8bFKAsP0EfxVqK+rOHMhIh8l88pyY/OZWRCJ3r4xMBV7FDLUkYYOmmHmznZ2+i/Z9F0kU1lFouF3WalYJFWqIU5bIOaPE4yWd8Yi4Mk8919OQWffwaeGBoCTtUNqP05UdXk5N8A8DXu6zudPNRs9glAZqP+5rxg8tp9cnba+5D3xPirNAvXwRi76INMM4sOxlLMRPEaWGnFHXKr1PaL5exi6f/CUlDAZ1eOoUy/ktgiVq8csM1QUxb0wKb8nIRCzZnXMjh/Z7/yUW+Wt4/fL2jhRw6kqX/YqlaT27Iiq3rWDQe9BpNhZseHKQdOvl55q5Ja3fLmShgW7tc6N++xPXI+a8F8JGA8CHHZHlSLCvKcqtz6oxLinXGjYsblk9dt5e3BWmy6gciTgWsyQs9zT/rIuKiWuFavd0W3GHHyhLTt5W+wnhZmJAJa8vkp7Rnlm7016FTLYMZqSARVSJrU34k+h6bV61zhrAspUbS9aUAYhT4DN3jN5DwC3F7Q1KHB/NU/UrdD6XQJWzwJbmAig3NohjzyYbyQDQOvCff1EApEggWYMuqLVVVnUmxzTj2QQ0v9JVuCJEI4TtWfcx8qwp2FYpc4aX2eYHflE2rsfLNpcUPc1N5ETUo52aUR+QNVri7NTwQ5JO8VRQ7FvQh6us+fdsl5o28ciIqsurfQpUDcGMFRTFZ3yAXXO1epXm8dKaKVzwgesLFMu3k3XQ3ONB7mI3WFTjG5k72f5z6A26cOLFqOV3iAQN5Yprjm+IKStsDG48p/sFAPGd6BjckAdhN4JR0yVQYnYlUpL7v3qxRx+4Xkl0Yo+JW5xT2/GRVOgWcIn2r3g8I+KZs0vx+1xs2dEG+icag3CvdB7orM18PM1ajsTO65BHzdigMZvhexnwnEUNjeov/TvdmVzBFpZBIhpSe9R2shVfodxXJV/2+pCMrDscazRTul0Gh7NiH5BE8TWVnGv4hsuG9nRwkxU3QuIsyAmUAloXIcEF+MEhJdbdLLh2gE3ZJCEOt6JizVPJZvl10V4pWpGj/MmsJM7GXG8ydM8yTG6zYR2u0LlZh7sxb9IZa4nFfn73fmEofvPzE0pbLQGszpiqmEftI37rfWeFGFMna2ieY+SM6TRpKPBi3IcDUAWfBygdIqOCNx9PBp9Qn/kxzBd1s7vdL3GrHZkcp4aenNF5JvbzEfp3tRou90lf4Igyxgu4+URPSqEOACKbbz3rAxJgq6uNe/Xi+5X1C7D7dzyCBIX41CwD+gyer3Olvgesztv6M9W+vQxn14c6x6NRhoEziUlRWUMHlncGXIqba71BzbIgMei2WL448CfMBJ+uFUuZxOEUxVP2DSYBcTlFvn5GMpIwNpKKW6XOzgHOLCLK6aNVzb9yRryDCny+V/w+K8TlBk/MmTY+NRd4yNObofwmcSc97IyEWJvOyYJcmvMVLeuYjyXgatAIrrLtZH7pCe6k4O+rL9fEKHQzjTKfHvQ6YO1yeBJ0pdHq2tGEpKhxiGUtqmbe3yStGDrDnM6IEEw87b39yj0gr+ITOs2beopKRlsDFGM9DrS7lmi50Qdr3UnLH5PWfY7yiKSqdtVTDZIU16oURuiSezao9T494kOgce0I9d6p2p7XEmkTD2hfNr0XRIkC6fXOXmjQxrUrfZvAzyT04ui++Bz6hK93XrWq+Pscb2EwlOLUe7RgGgo18Wb7e0sRcWZiDDkhRLuy+edl5dMWRebkX2/PPMwssHHrxb7z/4UxATUVJ06U4QkFTusXgloBgZOmU+962jTQgUbeZ8T7OtaDDRf0zf/RKKHOLK/vM1ZMOMRMfp6KsvVkKccMhOO86dS0aTmC2O2da5F8cpej4AptUVzMSufXFQFb/Ok5LhYanaQ/IOrr29sKdVBD6fdyRGLGnJS5z8TKCpldTXzGaKEixx0aOza+AU0gbRdbkGMyPgGiZZVkhzJv4ETGaa3H1StbgpiH0ZmcOvBGdPoSYYEiw0N3g2Kus7kaLbHtFWQctaiWvWEzq68q9SRawb1q/ZZNrwlPRLUTcHtBH33zZpcIqYiEsWmMM1GY7r/OaN47I7TA7j9/+74V1PmXA9qYxN/Je0GKrkmad5ZVClAjvBtzrTxsc/VCObxt+ymfN7nKuoAL4kwQoF/zDAg/+dDCG2SMVIfJIubf1T0n3ypKp/wKo6B57oDv3+L7skhgPUEcpVm38fCkFtACzShNSqSB182JVKKC+Z4jAIBQdlLVRWQUh2Zd0NDSRdF+ECctfjebqqOr4+Dwa0mZaJV5BB/uhC6bwiG6M4pLTn7kteRiDu993kM25wBZeVRpVMbFbehofBf55wVDSJc21CaOT0Gwx0CaRk1H8ParKZgsMc6/z50iUPhdHJxZLBegnOHVon9KMghuL8lNNAtFW2mUFjMygRTcHe+GQZT/oXbvmygAUSXui4tmJCdEuaGJCbQrWhiXU0RQelGf8+huTlluY2btUAawWl20oyuY2sVQopgnCZFDVcXL0wri45jAj0r1q1/WpkPNgXKvELsPAgFO8qJzeskSxQn4AfibN9Ny6eWsx34lhI1ETArUAESxaTIahiXcNpyO9ycKogaQDHC1ybGbQuKxBU/w+lN40ObxaY0v4V32biO3RlgHuG6JV+gVlyxnfMVwvbF5Uj7bOoAGsAiohsSMPnK/vLKHWvHa+NXdswEy5Drf4wVYovk/63nIogWVbcFWVqIX5YLsw2wnXiKrRg8nKahUuRr26FS76BInIcjV7PxWpGiI9Ms4juehZBOqHyGGtSteaKw+/5PN+wHmy6nmp7CjqbY0+FUo66hC/PGzoCQkqO4O1G9ESBRWFJRwxz6kzUSTsWOVjuzdVB9KV+Jn//oheU0gE6OiQcoogrf9buUIK2h3LjBa1SXpy+kd9wMzjNyj8GZ3ORWgK+m9i56dAAuz6umXENz4PmJ865PzemKX6DjIW9++BP5IgG2cynVYNS5pClXilwKg9FF7iQInM/z2Ug0hjh8MLaD9QerBDeBHc++9RL/L+hZdhwrDcUbehnQ3o9tT0q25tbF7iaIeVeolFwssKrSWvT3jxGg5RHP5+Sf/IgBRnKY9XHwVEtEE76TK2N+C7GLddPia/pvGLn6yttwyMhS43vw9V6UY0AKgOInWxeuhrz0eX4GAf9gQ8vyTLm5VDShxchd5MMDYXntmGMAcOKWSrAj5B/wrW50wjOoY1/1173oPkh1Vw0OeVnrF8BevK73ngpKmGxoo9Zf5cqTLsh9bZwB0IA9vGsw/9IXn5cI0hQDZGWl2pg8U9PEHwo5b25jagiFk5XfEe7bwsVuh9czHI9aW4oGQu1tUnPHGWjF9Hq+iwFnFuqL+2Lh6/6KIhaXFAPKyGw3l1WmbYx5EvvBW711RxMX9utoom9mKNRBSZTEn36x1Rru3hD7AsYmGg8CmMwrGlBJu0VdfEQPmZncFggI0kCAmN7FhX1mvTu2O0MDqU5TI1EBGPkAzOPcz/NS8ecu4kTyz3Crb0dDnALrMI8lDF8pl4YQPYCYcCjDsUmmbDj2HkBrnOmOktTpwbwBeBiy9u+h3E7qxVWgXfWpLCizv6NbGFEAAl3qrMq4R3g2UPkRX5ZCQju2qM7QRz8KeRHrCv13SaWl2WOhq1mrnx8QcV1OvepTuy1sCypsNZr7LRZqIXRcLq+f1l20RfouFHK5H9MffQxIuknCijbcEObxPcj4HLKjA7RjNRqqDrRc6M/aWf4Jwp+wGR2q4Yl3PJeRv1/HybsUeQ6U4B7cP8Mya9zApPG5+nKYBqhNkT528XQGApS/V3BGNgV+ZMSngo5/1nsGyqpGSxH8SuhN4DLWu7NL1Wl8h99nj/3Ot5/Pm/AK/GXoinnR2mt1cFip0js80sD9Ahn+S58gsP5fPRSNXPZceD9m7AyEoou612rhfCCvYX9NFtNdFKsgwKyMa+JIfZJ84ASGfyDfbNbTtABykep4FhmoQuWIEENjUj7jvzbGFm1wQRtSq3v7+Q/gCxg+jekK+udXP0MsDaNIYUVJUsinGeQlDM1ofcAC899tIIkEsTW+osmtGg3CzQYbQqOtjNCzuOWZX0RXBKGkuALfTknFtDJeopwLBbYEBbL9TJMSKQY/fw5YP1B/CEixvqgqkNue/3r88UZkF0x3x4MbcSWSaHSVGUn/FFnmJSWeX35wfyI++HuHstbouyuaBSg+MmskAfaLK3p95WSFtNrvBDCu89EGjyESPpdn+xAhJXyScWYVemub0V1pVWrqDlfaVKpNt3SrCIOB6XwwncW0G+TiKvjXLS2Pt0Zm/vkZDU3pefM2XOb1bMC+iQ6D+QjOzWlN1I1kND5Saw+8kplMi+a/GJazghFus8Iyx4Y5fqkFOdlmpuGQZ5qFz0QETK8uibuK3Q7J2+NdsFMBxGApeBvMhTaM0XwEMRtlCXY4iJJru8vAP76NBroiioXrUsjAWfvRSLeiQks4+ZFta0WM9d/zh3DYrSVVMcXt8Zdju0HvymGOWYC2UdXK8P5NzxFryviuxIPU8Sq5pjOsEY+h2ZBt/afrYbbi2wRuC55Ho/lzglKxIi5cVNgR5d9iHb5Ca68oszgjX+f0rAo2L8SDiyAJaEyHbGmMg0ICItk2yLXs+XY1FXLPQiGNhqapcvkoA2B+2m1WcUifWHp/2hH3kXgfWlf+2CczFHFfL1HyORqmFj/hSfsxjI9+NOXZTT2DDcnhdd0WR8Ql48usPmciCzbg4ijjzNkA1Acgc8JGCzCDa9p/CdMU5Uu9d4yNEDEPsQa/ayg2Qy2srVXqoSEJYSDupeuCPSGVzr6Rf6h2h1tlV+n07iVyQLF3jhqUr9FCld620V8KiN2d4kudcOuT+/Szb5bp6I2HfOTOQTbhMeSPbWWwKo5avxu4QfrR9w56rbr+qlVNm0DqK9Bozp8fux99JDhKFZdp4RZIIx9hn1Rbo8aXVw2jcZPWBLJAyhVYFWOJK/EY39u8u3ihl0Rr7WjJFf01No0KgVLC6Us1bG+j3aopZYIvZkRfDlv+6mUEM7mcSaABY/3WoJdXnByLF/PPpQ0fCOcJuf/dgQuTJNwajg5iubqKQM27ehoFQm9Q3A+9p2hCO/KCiISZ9d/bgANEd1Z1eCsb9Nes8s80VS3ais1twiD1Z/mGZeJtFtHeUKj+5RvwRAIOElnkXbLuJcZM7va931z/h9azn53swc7YWT0qe3/hQmrYGK6cibB8pYOestS4eRyFuKhM3a0nBYDs7y+wV1b6r9t6vm1N8Fcln+imtacqOqnjC4K0L6m/sUv/767dyJp98fK2wWVSghtSZqnAc3R4L2+FR6PShcKTie/iXLFfUFAUjy1tlZX0gWjAON2Lfrnb1LYU2ZjjWtpcFg9GX83RpdX0ByBOSmGAOnAWu/SQCO+xTc0iXjaUn7vNQJDWNei77wnBPWC+e13LrbwTzkkGp4R1A/ZAsvMXj9YmrVg3WY50qlyABxWM8SFoGNFnxH+XoMNiCamBm1ZxdkAdekeUNNMY8YJHl+tIbJl9o0n2ir9Ty2+dhWQn5KWAX44f/e+5ywbX29v1lZM4VcJvG+gYPUao9mRdTZq2HXz/C/T6FqLNXNiLls4ojshR+BPy0xMxNYknwz8fwGokk8a9HzwIa509PWcSjLHU4IYjGqZN+ukbaOFM+WFG04RHTS9kvUHvYIvm0YpwPNSD9q2orUp+Gs+2X16MJs81ckDam/4KmlA+4KuC+wVPcGF2MUwiAWyZX8NvnzNqTd1kLgTTcXTEey8w73m37fLpBl/eiEg2rUqdJC7g7ROhDkr3Qp23eGm99jd3b8VT2J3prKhXF4vBH3SNVbimL5nt8A0px7t9IIqEs0z/V5DTiJutAEOp7dtquKQQqIbfViEAzzjiq/t0c4IJf41kTq6WMm0FDCF7Z91kLTq73eYcgSdcY3psOcRas9IPJkCSyc+c/MGC3rxYkBdtAAoaVLuV8kyU0Wmw8n5ORAGBQUnTNwMVRTVmTWY1tpVaYOnyhqo2ZW70mWdkueTwq74ewW//plDNPfSTc3djqakpbKOYsKyF4ctGPLJfUGlVi9uXaNbj5QW7jLUfe+Xfu2SEDHSVNMrZBv7z5M+ozglN/lOMQHHbz8Mr6Xx1pAd3Eyjw8ii4PTggk0CHL0rUDbWgkwnOd3tPuTCqBn2P89P7n/AivfxF7c+OU5pfCPRp4XMnBq2wHs5vi92dTPhD19969yi9s6vDaJT/gLLfDWb9gx8/hEgb/iHOcKHnUCOP29uGP8LwlHYjuZxm7DpCjTh4EgAOilPum2lsG1Qe5uT5V7p/h4kqyyFJtEj9spWjZkTnpbWdr8Lj0dQ5aCj7KIoe3WbwewmTFJ4jKBiYissjv8UCfyuXUzvJlgRfLvubqHsWP383gdbmFnifW3SJt8TzLixQIj7MUcTnYg/lNS0VtofUKv//KU0vfQQyAPgHjZSZU+G7mC8vJNB2hJvJbmQ7MeW88SBxXJQ0XllRBFlN7eVt/Aigfeq9sXfmYjF1Oi29vQcesF/yTyQwFFtB7ls8+Om5a+WSdFo+rTcRJwOV/uSPq7bt6o19pTGJuueyXDbQFd095btnoLJCTRWNeLoyL0x1XE0i3vC1AKAeaaXUmegdB+OHyVcLep3jG6T3Dr9XGKd6UTiXRC8xQMmuxCQYicnjMjwxLNW0gIyI+/5J+1cQexUavJAzeku+mgp1ZGdDr0l0hkkuSVV8higmvbzJc9V+dVUuH+1VhLgVZnL+wmTjuhztk4uqvvw3comqcNjoAlMDLbefrRr6sKlxaELzCNq44NlQxyBw7VJZ7RexehVVJoPKJpi79b5zxPh74e8wqPHDipg24dsGPhAvi4qNbTat2Npq8E0UMg8GO0LwMV5zzuGZor+Wl23SZyQNQNq8po35fouLabGRylGl980pXyKPtwsCwtP01jp7+CJU3iSXbHPFgqr8WxKCeGjl8v3p/MkjVdy1VQefkYZy9XdDc6HFCOH7LzkwTv7MkSCPsx4OKngXtNaCJM9YspYdAqsGOtIBdVnqC7fOiTZLJvHXskFf7Nz+Rpgyo5Kf5EVIK5hoaOqNNrxjtZ5NrHvSCBGPhle5xtGCaCcnDpVjQ55WeKiIN8OD8dLPp0w5GvRqFidxwPgauzjZWjKPVdFFsdaoil94QhXuPvA8DtdG8cg96Fgw49NtYvLMvt9fwnDAuc6OeKqO7IacN6VprH92rgW3lafHglOK/DM8pIVataW84rfBb72P3mSQmuZtEhkcnWK2WfqluJJdFpCB8Kf4mUAiYpEyyD63xaP+Zb6/QqVMvvZS8C/hJVWFX+FTZfSTbejPCzG6EyrEjWC0pdy6eRi78LVc4IZimIVFLFhMWkIcyEDbvVnKAHsbY2U/2DCbEWrOXF8SUmJgb6m8Y3mHSuc8UT0LBmaZtFa2u5GH/3L+LodHFtHK9QCUmKtlha6IEPYo7bxMzydXpNW0iKE0KlPvHSUYtzEiCoKB/q4+05Bjd/X3f6DNjls6rBrIXAfZdfxOwXazVHFeqR2hwJpDk2K89lppS7TwfoSpwtYKG8fX3Nuw4pOtCPmtpiPgoMrcc7ypzB/1FAQ+zpY/Vx2D7hP+EIO+Zuunx2DcqSY27LGeEBwrkqkXxZKQvi/iOoMHaq04O4iM6U2419lCIORhd5KE0ACPL8iGm/g+n4ozCkGbfAXx7aldV82mFav+tRtoZJPAjWGhlG0R1N8TjvTe4gVaRJPGEkH87fLLPlMzsvZm17xL4wEyFXSFc+ohdPiSCRUwtL6/p3ZF3wf0aXoYPlrDdbAk2CiNoeLygvpC55XFxWuwTmYuvCw5H6wYMl5yFIjObUDjwBCNkr7+ihvkHAQUkmoha8Byv4uLvxIDpjpIuQGHbWOwuE2j/gXoSq8kL2D4SjlnNi4W+spm0ZLSjjqBZu80ii6KxWs0oGPC4O09k2SMYFtmq5fhSTJHcR9fnbOVEMB/td8/coEITicAHLBln7/2/9lcVVoI4kgQE1H2DyliuOVNzrDdwUMKQHFfqHxSUVTJSTmByTpEhKe0Fmd9d3dJBeu3Fk08S4hozVHfHVkT0lShHIjakI32Mfkt2ayNbizN3Z80YeIlRe9SqvbwD1obQoZeNaZdSL4jS48+4EPT89pGwQ+VDJ7ltCKtUkF6SUY9skUI4GGPprBsD9Ss3lAsxOfzZYvwZQ8GB/GRdC8VmASOH9rKpaP8PPLfVVUwGxgQwguBfMfGmbukgSV7DaMqSIn8uflCiMzHUFT3NfK9wfhNZK4JtsHWikLBtstcKhyHacGK8UoH13HFm4/vB2bT5fH43iSVHZWZ8UqDIX25cSLyreZVINjFzmjtqCsqUW3hBZfGAfEy2CDtFuo+YP5Mhcv0mADy1T8t2+vw7e+5tHy2KvVk1s5lsn/BOoBa7dmzEunKLSw6OJY7+qR8btMOzMgFfhbyje4KAM4gjU7hAzxvh7EKZ+WSZA2U6L61tqPiO6OkAvSlmJlcdJkarRndFzmu5cTZgh1ZMAS7idTFRmXt72TGQarRBEGVi1bS1GIkpppWlyRI/ulyTrzpQtTVKWPWhKrHsPOoMpwWC0kGRuvPp8Dc09uFszitFUeSLadrEPBiD2jfG7AifT3tnvRSKRJrCmKxWgwX3ymE+/E2lsqogF6JqYPStQwBRtlh1xyIMNt3tj1W+jZve73deodiXrAUwJ8FJUsFDjenNmroiqWWwAjHXHf2rDQInhVAlGaCUaQMZRDEi1xleXuGliUH0PuXVUVrmapWSRFnlGqYT7sT/U79+fNOmN1zF3JUM1Trqoss9zTM7jF/UvyVh7RDA7GgeDcKLc46Zy8ROHFdkPv9M/bA2oh+FMjW+e8ZEVclPzVn6iFeUJKr3EQBFLBkg1CJhZ0OTHKHSqckHeUJCL8SE2sNZSfVj1vaKZysjC7qJcoDL7W/8zms9EgWpXm3Y9+wsySjOxytMyxAQm2vnkeWYvWynj607z3EXz0IFf64y/wIZhoCEr8Aljz+bbaxMMbExtYE3+qHtJniB17ljgvAp7bvsbyu7Du0ad41riajUt4ygYWMiqyEgHFghsJXulnaqfxfRhqSi+xGha/081r47nDDbf+xJVsZ0I9fohPOEvZPM37LNVGrEVJhAg28rearRWN3UyCbxP0jOkPvIE9EiP12FvkFjUt6ZUJ2S4Co1K8f2gQ4TznMSbC9y447CSzq/z7O3ByYO+t7qqwPv93dJdgH6kTxZVb9EXa55HkWONBHU1yd1OyzbWwl7uF1FJZODQkPHsrPnPEXr7LXRx3J7zIPc+nDfRbZRAWxW/bgjm2LTKpEIIDhJjPGI8Gs0wqGN7SoOL8nQuC2XWvC7Obb1AFZXuIU40VHWCNFiyacSbGEIR6SpCrjV4NwrJn5YE7Qg/nZBdYIw4LoWR5QXHKRpPq0lSm7qZF+mfcwfZz1ZcVNjAEKXQa/h5booYJvFr7nNYku7MNBTZCamC8txL0Ah2OYj/fbZaIBmBH/c5TGBA+LJYd/kJQwdpBF3UuJ8uy6hFWCdonGe2okKaiCmtnTy4RQ/xeduq7lf8gCxv3trYN30svkgQbYdSK1uE4CsOQbAK5JAUqyOns054u+2M7MW/OxlxnHfFnlBYNGwFtFDekwEHnL75HY50FVoJMxW/UmfNtbZdTwhqD+3nItAxPJmn5Y6brdEtC9WW+6Q8FwjZ5g4N2qcZMUO36XrWDMw2YUFXAUvjEc3sYvQKrnSofccvVI4czdCD0WslkzveRg6X+iUvkQ6EaOx4gb1BdElWLBeVlS7YA+4yaA8U0Sv9o+XU3ujFNuSNOk5sD1OMUGaLDSKGi71m4jZKu3MNrYWOOfFgY6oR6SwfQks/WC1GhGxp/LAQgB7D1Vi3wP4dZJrADNRjCotCY2w5s3Bhri0xX7M/gzmlLfR+n/YfMnsUwZRB0/Z/tRCFQ36Ei8kv2K5mxle0enW7cxvgnqe6rUhR3MdLEKH4u/4j+igFUQQjsPn715LGka5X+Wcz5MaqEbDHRZXJtsHEvXS4dmDd25XuAfQiXjZNfCMtdRkDcVwDxELuEnyIKFnM1UFhq4AnT1lZjyvzg37KV9oG1FruefcdeJKh5fIHhx4CdgOS5Uwlke8l6zT1qT/VzHPWzG1nN6GrLY31x40jdFY2tCUzIPiaPLpmjCCq2EvDQDm8nKMV3lnYMNKZm17Ta109F9h51vJ09aXaq7E3DHFAHhJz0Wt6NRFPiLn3ZzXIz+y84HCRX0o57t2wMPgVZmcpVifK8dcgoDM4MJT9XTeThv4AXuNRAZPkOGPL5SUOA18HTbwjqV2OLcUhZkHeFUc+pIxHxiUoXJTCool7rh+BG6J4N9nxC8GQjdur3gsC0uQUvTdFBiUnSuCjKeGlGZgLXScvCIwNGJDE1rLMcNmqlpDPKa4/PJDkxe7Z2oAb29Mcn6Ph+A8fn2rhrDTZIV5XNpKGW1xv7YxIt0kdBB6QQnPLqPfBE47ob30Lc6rGouOBVK7OOpI1DItFB5OPGwO5gC5UGojfYv5zmXDmZfvnMLwQ1eSx0YydDELozrCbRn5H3o/+tuf7UVUztraNXdf/1fpOxMCnLWr8HFE7HP9gCwDjDBNAOSdki1gBP3Wjeq89l9ESKJ/sFe1YZuT4u8OJPvMdZepG1leY5PlR78gfnFoUQFpCUTn1qGp8gf9rmC7/WAWqaYoJgRWpoEwb5W71g5gYS4LqHsKg7F3rbh5tvs0MTfqZQT2VwQG2zLHh+ctwxF57ih67Q5aYlDxogrDdB7yZKxiKY7tsbATyLWoi6MrVq1Fps67MJS/WlHG1U5TzZNuySeNL5aHqdgJUX6z12hUIa3zpKXBHavGNvbGMfiEcARYm+11DE98p5R1t+xAJPgdtCVfVWrQ2xWYmpxjjyi3sWocvzrkH6jL7Jkk2muPMizdhw4JuJw3bjz7aEggEw3G8ReDb0NJj3+oBN1hzjeS141GK55QfvSaEX7h+l2iGolJRU2nZECa05WrzJF2oz48+TbUQClF4frdet+JGF0ghIOq1M7Q5i1vzIHuV1sauSRRpRSnA+IHyCZvptyQtIXHdCJG5aoBy2shfXfkiHtT1s1S6rAGiE47RoTintmeumKAAOMp7SPkPZ5p3H0dqfTbltcWuTX5j7Cg8y3/qqYiSFNYowjNh6l+a6Bxh/Lop6qb1GjioR1mFnoDjV5YBqyqhKmLF8xu0LvO3RZu5C1JA9ZsYUxfKpmglW3ZGo3sM4n9AaNLi2CdDWNJGEhfJ3FQDO3bIhKNoQA2DXs2zmqaoJodv3U8roT2daztaNlMK0/oEQMn9A8bkTFLeyvxRGZvww+V6Qff6Zpg2sdu1zD+MMYNHLSYtQcAasp8zLQeWys6dUoVmx7cKxAE/nACGNlvBlrwADAWfeN94Zh+11omKtTTCEi5sQfNq0+U0+sQ3wdrnXOjza5aFSYYlZWbd4b0qUZ1+rFuEUAQF1qxL5j9HKlmQDgwju0KExzNn8Ar1EE1cngI/rFpVFuSiqTF19aaop2qbQRrmKMpKnXYQl++2fDd+3rMXIMBBRPv3XXoev8/6Ogmbu2sCuhM2/PPgIDXS0o/8PWVl1Q+ZzmIfpV+8tGQc3UcpWFkf92fBt56/+X6WW2Br4TVux2CRgMJxVLIucDMYnp21Za6lt0gCDwjdM3vWlsm/BSWMdeMYQ8xOEYYZVkcbxAJIMn3m0LsODgUzymwWNHkH9HWKQl6qU/MoiuU5+9V282qg+bkM73SK4FFbuKwEdYg3D7MhN4FTLidnTvdoBnjkC4Y/D3WUL28xT2RanDw8YLQZP45cYAcXCGVsmcrRbin7sFeOPmeLYnw+Wmn3DOxQrRAZyY5ISIu3GqPvFVrshPjrMhDFY4b4j75sg7kz8Xi4mn76zbvRZiq4RszohUCbjVh3+EcS9JrjahxBDXsSnJ3Oq5yvwaya3ul/+exg2iuvA5gt0sJa8MA7F9zVSibDckUx/nYvyK18WgdUXV0HtqAgiyvfZOrX8s7tOrshXZIuqmeKa3ifuK3FwsvzPerqY21r5avY0NRe/fA/fFU1qXlNAsnxn325WNwk1dgY8We+fXfGSnEX2L8ix8zd9gn498Vep0WbGFhlKgOPeqgBrOeMf81CMTqvt/OrbhlMaUc4czPcWiDnzziSXlIuga5c8fI6NtDYSDWFrZquvf2sYfcWKtomNB9znKexviNYLeP7OcF8KAMpW4YW1gyEiroz7xTW+vBm4lo1WXE+x4R6dI0fJHuHm6QzRLx6FiBLQMli+h4sx9fjT4dsTlQSa6cLwJpgs/jjBmk0vI7Y9FYMUN8E6v/dOvM8UidWoBJBn1CZczjpxGymN0GbhQfLQgLibQGJPnL7vIc8zIgO6Da6blooR21KMHIbzpvsSN+rJux3f6Y0Q+lMsTnKG6ZXX8qJH/skaKNsw0efziU7oAlJes8mNB6S2MgkN9nHyVM9ksre/W6r1x4itKYrs/yXyFl9rISK3PwLllAraHNt2jy8UQVgWuEDFXjhyOALCZotBhTGSmVdS5d10u9zx+fB0K2k74DRg4RuzhObUUsNAupjnp/xRxFq/pfgoNIbaY2q+t4U+t3lM6SfvRnIUEldvlzpScjUT/8EqgQhn6UMKrt8ZdppSp9SvbKqLswASgXa9RLeZoGT/L4SRErXfNKzmGDWciGoy9vDChM9ECdXwTu+SACgD3vZG9DO62xb3MLKW5Zhq5NOu7Z49D8lwnvxelisUyoPiCS/YsfJmEmH3AyzAC9hSGcIlDNcD9p4+hx1xW8opWBRGmTZq9aGb+Wsv3GD7iheb2wtTdNRiaawy0E4DuNDejkCz64MOfj3uqCMmLPwBdR5/W5PaaAkkJ5kHJPbVMgF6SLiVBGhcfbSHK14A89cHOAsK5GdsEk8ipS0/9ILkB5Jng9uWnxmq377hv01I4JM5s+wREzucC3AeNx/esl1tEDcRAtLgM15IZscPXCz5HNlbKIRiCpHP2nULvR0th1yQbWrXme/Pgd4WSOd/l4TOsWXUWPbxKu+9U4OScReD1Wn/thyMUzJOUMq1n0f8PhDCOYdRdEmiPV6sR+lky8Q8ltJTTXCxcI+mW+b9TSPhLa0j4C6NHyZkRWGaWEwtcacew0O1Q7y9e0NwsT3UvbkgAxJMaRyHvsZbBpnZ3HJlcM7fQ/dX7n0oSd6UDzXj4Yv0H8JF9SkL1tNUrEyhMZ5oP8pEepdiKY893/+qgsI3cMlzFWXVDfng9ZLTtvGdNrB0JjXKj2SgpasCm2g6k+ZCS5kH9hA7o16aMHKGZLkG7aKyAdFHM4mG62ruc8w8hoq3DRGBvB7WseF0KwbJJJ/Z+WWWn99qsAAyUdw6UmbhvTe4TWmSP4QiOzKhaFPLwsJNAP+Q9MkZkTs0glRuj2okRAYLIsRwSPsaUuL/luzTf/JV89rg/1LRZrX42jChtl4BUPTTE4PepiT3uOW2HBNcFkTwC8EsuVaAJ1fyeNULaivvlnGVtU6Umbo3Vbzkde9a5ct/EOFGiimlxEwlW2uR9WqM9nHxJluBZcaB63yE7KGetb+gRrbPPozD3OxqIQHuu/+G7WHXHkOP2rY7Iyfrkyb04YYAnIID1M1moDnldqieEUMPXOn/CcJrMq+HTLOC9fE7RQp+lLkOynVsdh6ENvxrSXqNJ7iTc1nkAgBtw86Rae56q224llyD6UWp4Ckg2TTJ/0W+4Yu5Ur4o7/B/bi4qMaCaFQujrMUwDRxZ2c8Gc37VqdXM7WJTHKXFrHmgTX2tms68tdAi5dRPpxQms4KAfogsRp2+o0jZjYiTlS3UAmuNQ5QIz1+OYYJIIktNrGwzHw8xUdoxvIRfUI46nKpv5eHQXj7Ziz2XhWY+5DpqqJMGquC6XlD7lv3sMWUDIaWlHK5DbhoUQbZ4qfpBiHHDUEId67WndmQNmPMZoxFZZXqW8JSHMjc95CTdofoy5fNR3kiq2XpG+/hqB/He7RYsGDuBRkq+xGa4JeyR8/lZqzsfAxU+TGVSgHD+tHex/0Oacn4YMNo21YtxKx9Pc469JuHdgNEE5nhNC10WKYcDpudCeEoXFGKqk7BSHqbRCtZT60y0IoMhjaSqTn7DKaAdIAZHah8p1W/ev76sbcQCSQWvIUQOOJCsmn80nFXqbwug+Mk9plhTndzbABiBU6nOK2F9PB3qgY2kHGDiDPoa8jsxZWsK63pyr5Hb9QZeQ4EfIFP+DTbeX7t5ZjRyU1UFnRbpVpE4VDDIoLu+bkoZ2OxrJDkmgsFzg02b4DLBQu3ksQbIW7RXCpcw4f8do3+6/g3zV53Po7XL+D8v8OfwjVyxIDYL1Ehl07kIyDbUgBGilUs3JTeUIJ9Ix2NWyxwHu8CcIXimXnrMJJoJXQ371/dtM0uzo4t0jaLiw/VwoZodQi2vAu1LDzf25pkf9dgGPvmGCNeQwzF/9f2Ana6T9h1u7uBC3tcvHdiffacTB6CAq/kfKYoXatdZP9ssGBhn00cJYBmwvOxTXAPZ/5ET6+ftjoCygCXymIxC7lHVvskML1GwosX53FBmO8/Fzzm1dWa4IqsViy2OSHfezR5p0OX+F8DeyhOOYNeQWOc5e+IbP5cOSTyMrrPcTQBsBTOJo5AO1RQgfWD0shho1249Vj+wHlKhE7evZULQjpu/GEtltkfoM80JjchTE3RQN6fPwKyBfbi15ZGuqwo5ilp4TS7nI0Q2XNmfDXJutpD6JXPkPqq26/G9G1r4KRoJpVexH/yMCh3/ryEWUN+Xt0i61I2M2pmw5vPAU1e+V2Q7tBZEi1e9rNV9vdFcjGe2qkJWjQo2rSPTimWa1tCtxm6TQkwlxGLMZLC3SqaGwGfG7n825kOHes/tL8m+mxwTQenfbUb5ier3+krDq8lkf1tYE8OmBrEp+479ikVq+tiHiKvwFzMr1pOs8MMOJXHbDUgvGxTmvDFXEBl2hbk7SpKM6w4aBK5UUFQVXpvn/KGqq1rKLEj+4IANTGt/Tfh1Rp3pC70dggjNRx2hsnfhfTnD2Q6emQBD28gPp8S162bzST0aPSyGQP5Nq+4fwerkVBeAHmKe+bNo+XzCRxZABu1B+dZz8VvYNgabjhE/krInW3D6iueelALsYobdu7O2iKF5J4Tz8b+jM6xRyWdefm09n0X50o5IBKG1174tRCtuAL6GmtWT1L1JSz84GiY5eJMe762ssJL7Ojm/C/y2mFZBuN8iwxFpjBa2QeOxa/HtM4dnmN8Nt3ag6okPQLS+DMqcu1ie6OXZr4/Lx6onLyUTLfuSzKEtTdyvoZ5YHdHJFic24VuamaLNNsHkLCaJRpeLNiREwtX7MJvV00oWUSMkywfKBpYm7P0wHW89R7BFu/mr3XVIoJNnuPcV0okUqRhH+Cw0n64O53Wc4uJoIeRgmNs85wAUHBhdt/qBkYFK2AW9m0XiHnmIUQWpJ9/uHSW6LQHfiqne/9wlEkRR/b6wWOV2AR4etcX/qjDzT33oecT5CFOx8vnNDOys9hCTmk0X2NVNHC+2HuUs5WjJHuFLwXyzvhkkzHZgI62921VEVq5S9VokAiYtc7qG+xCVU/i5lWRUE78DM1QmZdl9YOVZAEEn4M2m6n0I0IrCscbBJ4CbQUwIDWDCze490FOfqvMH681feJ2ldjfTfbpojkpUGY4d9NeSztdrjdfn990uRR7HgYVaaVgmVlav6p1VabaV6Ji6idLT3XIPlOV9OjbTRtJq9u2R97ijbupA0PItMaAmMZj7z7oWL/HQHVg1itswSwQUE7xM9u8MEHKrE2UJnYUGA4ApDb56doqMqzTXjd8BG7/uAxpopENDAmsVEGrKGC/tpl4FSbu/eTMlIDsOkbEvHpU0IdoPx7yepAuUANG83lCUvQAwoWX1N1yhXQQY//ll3QwrGQQL40W3QgnX8qvMsTg+zQZu4Tu81MIpcDZq35EfX7WDv34kI7y35DlbLl1SMYxAacTmXVb1/jxJnXeljEnFukeN2sebMTmrMI3BxRU/hHeZ4SyFcqThnkkDUeMyEsvX/fK+E6Ih1W5MQ5mRTvq5NTR+f7F+cNJ5JFahiAiNlzLDFKj7BTN33gS2EkBgS4hlZS88l+jT3GHVLQXUYiwagk8wOtfhhaUtRE1miopU5BT1S0B0aHxnZpfVVgcE1pRMHN2LN96Mu048c6EPQHfRF1nYahEXyMANgqDQ5qHpFXfX/E1EwaypZjcBjo8lNxjubHYnfNiGx3Wmbh6TZG2Z3OPNy8PZx2Yvwq69AhQJKIGZgNlnkOdpomX3iYWx7gUH1U5yZKpDtM3E19FiSrepCq8OlUmWld+v1oyOwy10B7ipmo0HtZ869Fpgz5oSndT3+R8QlqaANP6R/bwsroGEp1x0dvblSidNo91SozzJBK0DBysHh/2zk/rdV+wsBw4o7R5gpwRtIzWTl2xJULgjH/2DloOMJw9B0zHkSaTr6+Dfq47YHdzUfiVRC38ySiS4mFspUytSiYQ2FoKrmqv5NQZ9E7jqxzKzMEXTSkfmSNI931PIwu+UpB+yhtkXCij1n8xaiZozPvUh72hqcad3x9Nyzc12Clg4KR1EEkgwjDjgPLgvIz08zCCllh0Tl5j3sySjz6IexCFmFplQBW7ihhYLadFxZZC+GQhuQWu088+P3nDYoBMEX0NdOVWZ+Zb+1mumlo5y2iG2Dx5LlW5HbbzSr67g+aGcjyoSLcOGdDEAqBB485XIbHe8aTsVDNaVdIPul7hOtIdFBCRLx8sA915cYgNWYrlSAiWhUBwb3o4fBm++iEOBeewvzlXmqyjuS5tOCqqymCdEvponql4G16/BfuJqSZZ43/HoBItdbV3TQ9se7o5+szOtp8WoYKYa03gN64SENOUrySNHUa+MBCY40ohIon61rfQ81VModZeuGuCEv5OpO4fSU+nE49pObryv4laH9Zu+Sc45Ezp+r1cQRfCawSes2HaHkhpgUYmxitSrIUvwp5T0+LKPH/zMAqb2h40KPif5vGwQZPilKAg89npQhGajjNoBWkofGGy82PI8g7sFsFYHkfVpRZD6c9ThUuG/c1k8VQdxZVsGUB2p9bDlUDLSMsqW02PfjTraNNSd5APN0lXEUncWRUjkFqAkes8lKYH2PJFIjEY538ZY5+Lce7DkHGXUkzT1vCQiQTBZgHjeFLsvbF/zVt/OXv9s01JZj2biRXKxp71AfbyFYh0/KELLTqGvqvZs696T2y7RpKNd+wIb0D70JD3cMqPVjXaAHeNj45820Zbb0EFcL6HkfgZSE77WpyMWckdFytReddiy9kAA+ua9yLugCSeRcivF4U65ix1/4ub1fZBjF7L/yZBM6oSP8yC7Q7+mMPKjunVLIjTwRKL5ch4aWiQgUteSzx/MRHOHIFYiDVUQT4Nu7QQbhlVPrtXntwF5kLJykunVjPU6hqaSMJyLOxCZcPLA88NqvU7RlOaNLxV4mIcGfbgNhnsj7mc/CnWyRc430cwK8R+Xk8jc9tipXaIPnSS7W8YNU4uGTbP2DaKG2fph2452GOstgq1a8/sRyu/WIgsXrCmtE7861zsXBq+1RwWpsaN6KvUJWHz9ydQsIHJAkQ09k4IiaNFR0eNm6X7t2ISh+fGrBhbThwTxPhSiq3+BmBE6QFjTT8FGmE//GTVn0WGMesiWAWJZsgws9XAolR1X0ZExd4hI2VP/s9l1BAOmUDDmmQHT6CjfCBhjNQD6n/eySuJ0m+wxDclNJCmzEKI2yRdeTSAEvCGLfEH4jMIegTgmXU8lDjhaZOclK+nwSpa+05JD2udMMYMoVSzM3sOsHS6uCVQwImkEO/coS7Z7Gnq/PIpBOrwLTEbfv7TcexAGnf2W0A2zAtlBMtiDbcpicaaF/U6nQkT3XvCAx5S4d2XB7YggrJnf/PDm8QJGtJcbKXAAM2wblyMQn8tTB57eIXUooXql+WkbeT4tX62smyx7+vh0UtPxzvmidijHO+apYETeBYN90mOicQ6VPGJ76Xu0WbB2GL71LcIxV6gHt51LrN/bopiZS+4sCZz5cA3VqYLqj44Otuy0qqGdMEv0yO8uZ2VFIMfdqw5WV0/cAau+SzrvLjgs9pndLM+lDVQR/dvvz3gY4KHoZ8vfMDLQpmNKs4Qrq3QikSZdSRJHYUkzjGuBGhOsZvD8eS/F/VvDe9zBf8iQzDYMb3fVbjpbUDu8XkAMyHiyzsHtfgHAIfJUesfaNzFswZ32xotW0qi+4QmcV96Gkryh/4Fqx1jpe0Jp6KEeT2FMPqqrNWS/CcUEVkI1n38mBbk1bhrGkgrwJO7NOUjYKGIcpQXE8qPECXWDgpzgHcIxLsPiJi2V2PCN4lCORyeNKk84p/9M2udEf3oCfGTzXCZMLyhn5OD4x5ycNrGd+8OjRql6pH4NhiMumlAd8D3nxtCk4PdBnrLwz83GSep2AKbSr1ve6F0h2MDSgkY8y4CbFB+UjvmE0mXmLM83MKR25OZ5lrmneL9q2YXYdj5V1wT3fPxnJLRmIuSSeBpd4r/u5OoH2QVIARdJRU5KNmAOEeMgMi82WpRjZIanhxyTU4ThvBaON05rwPcr15ZsjDBF5xKJL6ZTOdmaNTQRguVyPlHD64nD4jmrGb/kqXkaDtG7OA6BUFffpkxXmRWimh6GT5cgWWZlIOr4ylQXICK3lApfuNoW3HXXGOuVwUFUVyFTKJbU+NlGFhhulWiSbk5MEn4YHzaL9RjVhX7Sdyu/WQ22K+F+AUbgqFffmZHWbaccRO7cXhXBuu+HJh6fyT6x+vmz7aNDpjLzdU03qICZgRkhDv0drhL12RWxWzg+ISjnZ6StHnS1pODVuE5/1KpKQNCoDa2OSWYn2sWeSs8Syvh9IX0EiheVEf7rbTDTd8of63xefU7X+JUT0NOUnUayX14W2AqdnV1tFXHCeVlsIXGsobcGQSdYwbs9NxLMK/mgJ/Klfm93DEy0lk2L/mqp/foM5TpI3dk2q47W6A+I/y5D0dud6AuD359A1/kZu76/2f8OyexoWxAjrU3DktrcNKCnvdWeKbS3AH/2BZHKsOyPKns7QJ0tSxuZHwR9TXQOeGkl/DQ/g/1sLVa84LwW+3k9MaglGZ+6oObeCh/emEO14R86YEFoSNKg3Qdf78APNSHJ5I2mdmgoj7xGmx94cM8+//0KUINwkQjhMJ98PcPoaGXTth3cF7PN+knhew3pUHFcHzGJ2I1gK+F/nR1F0V8OKnGaqRtoT8TzQcz6Szuqj3wN8OSXm6M2hGl2erAqCiKZDvNPqwrZvT+uaKJkdUmqiVyeAO5nFbtVSSjKj8r5RHcUjnsxc9Bs1Y/Ol5zX6XMXIjPu0bqFZ3iZK86HEaAql4nU7oDqQVDoIcAS/RjECXDwirf5nhRMP2dVp21ga3tJdUOC+S/2Z2URCek2SqXf4WEX8TdMiliDYeyL0B/jkNbvZX2PpdngNgKyOdRpvi1HlcDMk2kydC5xX0IvUOdFANg3TdjdTfyfQEG7CXR+FAd4WvA7zeAl0TlECHoMoQqJ7VihBno1A5/IFfBhoZD4CMgVPVDBOmUQ2xCfySdmwLYy+AV4gtAyhnEZXy+4iFUX4P1C18BgH9Ix06SgvRG3bYFDG1gomHHgfY+2ZgSDFavfpwrMHLaVKnD0w1AeDPOzs1Qwr7tbT4pQDnomyyg4Yt44vCQ+Kc6ZmDX8WYIQ5+oNju4+100JFJNhIUD0XMquk8s5K8V4hfrxAlhD6lx1mHon3gZxwTJvkuKxAXnvuqUIcwyuB6ut8XTMaP+XTV0bR1+8xf8lN7jaCfzqOohpJHSUxkUVSky/W8TQRg+HiCQSZqgqEnX9ruLY31nV+X67PHmOQ15BJSam7ZomddxQ6B67tVWkRzLb5WqbA1i+iDlYG38qs0HYzumXiAV1A6cYu2leVqVDS1fFR/yn3MVDBzjxuKWwrba5iiC459KSCJKxW0SqqFeFcGT2ce1Pueq5eus2eB5QvpYOwPFgLK09o56jvcP6nQsifVsftOeeKljgcagLtSLdaibZ5B6s8eqXOIfHMu1Jd9rwsGg+M6jhueFcErmARjic4YNJpN0Gvsz/rxD2HgFwGYqqwLjJnrLEbSSo80XJjJWXnlvkRkccC8gF4rAT3qAp6MsXy/pvxVhPdLNaITDJgMlqq9LHKlO0+67vm7EGV33wqM6IByOa0KqSAS/J2EDbz/HHMO3ylsaxLNLuo/GOl+PZMVKbdlQ2pQUnqyduUnq3SZxHHyqI4xlo8lFSTpcabtr9sH085G1TlHsZ+t3EoorUMJAt+5ajW/hUc0Y5hQD4o6PsX0B7xtz3MhjGFjVma5RtAtHqbiBU+GJp4NBx3d0g/lGserzKSR+7RkgabIC2nl8CsKfjuqb/lb0VZrTJr7xt9uZs3oxI+Mv9wCrCUTb7/Sqrjwa4yt3Mc6Q15UDQTzfxfdeIku/zfdUx2qIxMoUA4MZCRH/OwYagg6tqkY/6PPYpSmhho7ZtgN1cXqx46ubO4dxLuaTQniAbDnLVa/t2b+djq3M5BY2Gb2Cg3K5hBJla2MUFmnzIesVxRZsoF2hC3iqN3sBmxc8IP7JdB2t1C1oDNIHCTnrMcGS8dp6ZbTWUfhztCe0/cfjqZT/0w8cXhPYvBSTYp5zBQ7fMW5Wo8y41fB79m7tv4n9HMB2I5uw6CiYYqn/8du/Q8VlACVlYrLvSll1CQxhiVBr9cXqWHVUsfiZW07OJvaM6bOcQBcU8FdJE3+lhrtsyGhirH7c/Iyo4Mf4kU6pFrh7IxiwMj5i66U7XXebcD+46IzW1B7j1MZlikyMDGnTm48G9uVnO17w6iHdv/hIrAupGripVFI9RUpNeBGlEbOUaV5u8KJb57qrx3+isgUSMwDGxFY/Ph0jdqluW9OabF4GlqJVlwnCPqsu+hawqDEWUJja2yKRbpCOXjsYt3lok7of55YeigD5pkSNFLFHWrj/yRINT7qaV8VHG+EAhAdyRg13F2ZGgXzGCzWS0kYHG/0YLSAbKEW4vM0pzKQFi0ZA0z1HHhN/l9C7mYS2iqkPfVdQuYWOpCTfP6pZN1z5/zpXzsojbhfFTpjJZf0LEuEAwiXeo92ImPEB42JtAIvBMiEk3TLGMsWJQ28yXwCOqExfa6xuYwhCC8mks94wIG4BbMtNrJYIVPWUlcRybotw7V0fSSphVRRXqmwNvDu/Twu5SUxYmpUXcpD5wbSUJh/YdXm+5J+WrGVnso4mjqlS5HqxTzM6+6iW30dc77JzP6DKBxB8u3d8qcnZO8/f66HoUYdDC9/L8ENgZl2yrwom3ZY3mO2NMahLsbVtrTsHQlcAkGWRKxoZtWyWYUrFMQ7a8gxMhDEol3KOcBOTLLz11yNYb6XFsA/Gja7me34eKNhDfWejYPsbXlwxN3twA4Toi2oSapWM+J1f1h6cKOk6GzRGRetu763rw4G3q2WI0/AoV9OmsaGP6Fhxz56Er/8179Z3p3lbD2NitOmfLir3W5uxy9UIZrp/JjSp2aEZY/QFGvgVKk0RbhnkUfMA7lp+llo3VnUjKkyaPnNtrd8fyOLWSDT1tS0kULvlXI5bm/kVUIFGO/yESROoVvL7A16BUhzQj7LZ4nte0v6M9kivOZGeurGX0EM9np6yfnpiRpkEhWWbHgj44IMSZ4eRyQoj+J9mh09cJh2XrJtYw6Dd+U4TgQJ54us8gMW1OBe2zToRWHKQogqfPpOqWhmPof8gUIar0YHI5fw/XMuoSObpGaVcV2OhpXc2NJFKouFE6Te18ZR/kRuDveIfg8j1sU/5+NxtYFsKqn2RIJKthnZ4C6ZhkPOcz83vas14s3Xf8YLi8axvZyAxmk6gLEXbvRziYraiXrdILyYruYIPnyoi4bPoy1/Vju3HwEtsqoN0CUXUrNpyuoV0A+ku2KnvlYHKBCLOFEz++OqqfC3ZLs4UadZx23a4OIbp/DV8ukIUGe1ZAImNbVLHGDC4McDKNuIqlWK5ThdDy1BqKGYjGL37qmfyfYC5IWxKShTGqkNTkvCKZwTtJsP1mrgL7cJz/Mwcnk75plOIT6p4l60Ip/XZV0+ODdyi1VxTG39PPuxXtnIEaFsnF/ZNFreJAdf/aoikDvwoI2VgPKM5MJcFB1/Bh88DR+Jy6Rvjy3zjiS178WrO+6yHERSCb1djAkXVA0x8b8vu0qZaCuIT+XEJkckZ5WXB7AYAApn4up8zKv8qPftg95ooue2rSQn9VbFLU2iTHYsHbQWHh3qV9Ch9iB3K0ZVNWokoEnKswy5T5Uo4XRUi93J8eDCSKVpXL8u3y06dHTF0m2MwS1KhsLjkeBof/XtjIKN1/I180NrxipLtMVLZ6rmhURFFYhMzeLhdcl2g/Rm8IiED1zQZ46A7HiCV9B+DjA9MEJkAipB7BMzHBUNUz2ee44+WiR8xfqgsZ81o5pjjoImq5Fx/ykR2XJCIDi4gqgrTjctkBiX6+vOI5YHWg8iArOgk5edPI/ydH1+Xy9Hgo/D8b/dpYxtkNiybDEqluYxdCPMqV2x4tzAz71dM1erkv0B9rvEVt8wOXveFPRwssDXMeYMUL4+iGHQ55AaVwYD6GzMNxD90ckv6SMMTFWCnkR7ZG6YQD8mLQcpJvN3Yg8Z2gOLIlrJtlxb0kt4YRuU+dLodx3YMR61LGL2W7Tw6zPrGguQvc0Wn6XGaQG7uPlQT6WuxBuAqVdjCHisuwfMcQBMSClgKTagFT0RAQnG19etntpYPzp/30LWRAleF9b/dZa22DAVdN6hZpOCL7ZBGtGPUnQMLvJTTEwEjPAEGzNdm6dkYC1O1vYMh4ssSLLgORsdOvruiWVfbaA8lRkbZhrHqvnOQz/EflrWwBV0X1TEQYWzq6536l+2eyaxQY+/8XmqBRdaRMhD/cKCzQri9yOej8O4WxG7ueMnfycKB+kzEumf6ZKko8gyxpTgyoT8ih37k1gjus+sNFEkPz0UD0m0vaCue+rTu5K6TdhlzBC7pic9LIDypER7h0tvh8uJi0HpuekuNOFFVofe6k3iQt45L3mNSjzXBMpILxu1CpHs/zEJ7zGaL8+03nu/NylBrxsylsITFPt0M+vrT4tcFWs43oZslkU+MQPIt7To15BwmNEvwuI9uYl9HLn8pPyn352zYq4DbTvd0+hFHykEcgp7qXgEZaWHA9xyPze3TdIqLuKuUiA+wXITPUA7Uuga/u6Y5WhPOOUV9ZOJ7dElnuecR5nZuX2toIEvCfxngBn1UwaHymjf23xVGGYe5T0uPlKZGcnM84GoCnSD0h1WfQiQe/d0SNQl1qEemfR1HoPOZgdttDDUlXqWQm+NlIjWA1wmIA5VTnfuMdzOhcvTWwv0IA87eDmgTTGf/6upwCTUjVn1Bh6wO3suK45orcSc1dFHYbwRPqOnjmoMPsN4sZuC1L8zEsxXm/WuG+ihMsBHPjU/TmZljphvTiPSA6bpk3u/OtXiELqoxI+TLVEE/kHYCZLr8lla1+Q5ngAUMUbsCILSDFt4stWrxmnBW0egFECAwWvdPDAzfbwQ55TtuPosiyJivak4McOG2e6uhfI3XXfOyADgBUOmthDEZloernapscX6vG8xNWuLO4laqI7b02vBgF5XsXgMh9/QfSMcmvvjss5f1Zj3tpdxLzsv4NB4VctnibP8A4q8xszO6Qg4jVSu0+RXjQ6610PbiNlVm71//ZgJajKRCfNgjOHtWh3RcOkHrr8VlTEJcFKRX0TYT06WY1CmxXxp+Wu48Z56lbZOFnBV3+j8R65AJUR8jEzYFqaRPAZhvOJurjhSInvElIaiYblrUAp9Cfv42MDuY9RSCNphEH2PTkzTe6sQ0GCmYL3ZnplctdrCcSxbIAgmTkkO00S12ioB2ptguEjJf4ClYJcki8SHBwV3FTdBqW52ApzEVaBi/Q1Q57P6Ig3dq1ZaYjT9VFvYFwxrjkCxie/ovEy0gOyQFHAcA2M4hUGYp03CpHF9gHrR3aryyN4LRnMxkELoYlU5UtTLZLjO4I7XPyEjDaoui3AEOIm17Kd5ZBZJfb5v9q7aMTJTeXUAwfNxcIOe3VPOldd4yyFajX3X83ZtMuMtbiUbmPXc/SN1Onnl7yLMtEBKsUWq16z9dAWBwR4KpmcgsCLWaSbwDH6UPGhuoUQ5tVChrChkJVvTDG9nfMVhm+Zym4JBaYeF7AyoxYoc5dmosHY07rkA0bHwQ9qXyzjYSE4skpnVUt6Mm6vz1/NqhyFmn8vU+1WGZ4dOff9gohKQoLOY3hryorAtu/V0kxrsgex07e0ufmpxvKi77NaxL5NGp1H6Rk9T0GYQMK3KpfJEoC3X3/u6+KS5dsGxj9whRNmNGPRsgm4x/ywR6vqcv6Rl/z55aDTAp9iJKUiUIx7YIOKIQaWLZ2c2+JxLxvNVXjyM9OmhpXYUS2zRPKZq2e88yjmMi2/pzmQthZ19MZGsNwICTPU0JhMIG+NoZY8ZhfVEjSvlj3sKfmFdUa/fepf/arVgHD6qsLP1M1PntXxhTfctNo5DgJUIeyUGTRbHOTO1Jfw15JJmm57zTdDCbXTNaWkuVa+cgVyXCkj+N2sbcs5W9sibFzZL4CeCCqq2pqw4ivWCkhGsrnKj3RPvENTo+KhgyjgrAbktXoKrrgyaGV/OYBuyt5e9oiU8JD87uR7TuEfrRyT729VGl6eVab0/czKzekOX3ILnPbAUq7yMlt1XPmLtrwSTs37sykYK92i4b0o1rFEJ+jPuPsiNIZ4rvRbubvm9clVgT8kRWyuUj6Zgfz5lHEVkm/ScjlMwzD/7L34NqovdUVxojAS+fq6EgYx3LbhSp1zzpejb6ZY9Wv1bqUEfujk3DxAO2eYklBN3BBf5SM8wvtS/SatUys8qKzqNPuft7uD4P2wmUn3/XGWtvuosNQZLzsFkkTCnOMcDQS3LPgGXgoYCbfMTCVy9qEyJZleHEr1H52g3Yr3lQYWpk8IOKG/UlWCLlpKlJNxif/2B2q4V7Ik6gpdPDmIRNGcgzh4S5uBWY4w9TiB5SjT4+7df1J2sAwTst24hhmzCx+ekyascUncPD6ziNHnn20pdoSROe3hV73OTc4x2t/H2kf0+GDyTpUjyje09H0BsZ5mhaAkXFs5EldJ0mTnd0HdrIj24tevJQZIfJLE3ed6Q9y5EGcTuxlYVU9L+nCeuPIhtundP7f9oZh7VF3SoEylirg9NusSyVo5iRe9wqOQp6LmSRn9xjkNlZYVfJNYItY08aO++dZ4W+3KZSNEYZTAzc42D1Rwn20UnxOl7Xb/LBNgD9hCc0/GDYEdfiQQFtzY8zD1wvYwGrPUqyWuh2RHJDfLSejp2SJ2B04utZZ/EPSuQpgNOapJGl2LC2X/6p8QAxSJyF2IHsKaC2IWystzOfHtILryv8fWZ+SJQY7/485L4bYgq95RDUr/SZ8Lc1HD3sTkntJGBvPtbDHAfvGMacj9Clbw64UGlm0z9YpRdEtnnRVvn5082Ufsfe+76uFdkuWtrXA6SQ3uu9crPYUT7RfqvLDJBPXNYgTsAqkHEqN7CnhzVm9g1lCOOdISGdNK1BNI4Ztf1JJTVB3k4wdH/oeCNZRSHH4fwfbjwNZLkq/fNspTGhQ38Go8YGNqqjjsa1qNxgz7nmTmz64tPCeC7h6iq6+bhZonzVjyG8uNCg5a6HMiW77D1hR2I5yuNnVr2Tq1sjlKlJ5bu721LeaR9FPo7YrstjmRoKicv+e2JjHvZEt97MWtEHwUPQUAJMK3wYycKdFok5FrGT6WoivoMT9RbDpRKFRYX/qQ65Njlk7WJYW9VHfNeAW2yGAI4Pz7wO5MBiOJ6v9t8LI2XzxPfkmfqqZR3kp92qhTQ/NxVa0lbyxoWwaDOf9YViKYFqSVnr0tqnDW820qj4wTLqT2d0DwlznANOE+8lkmTCp/XLvZTaWrq7x+pvDJbYnCfWIjVbas93F9Qe2ij8ZRlALIA6MjDD5topk+pQvrAe7gldozBVYZeajVl1KR2H60ImAWEH7hOhJbTvMQhV8OpO/mBHdvDDcv8Wcp81Fc3FE4IIImIUO9cq4UGW6V+VWb/g4U2/5ybFenV7Si2GISEHjWuRjs1P0tSOXelmPGPf5plxwYvQMaZQ5csUTf0tF0kvq196SH8w/OORyEpuxzZ4GQwmEj7JZWnhY/h108hR+U3pcitZob/YzUKLjMHBBO5sUgM+9IsUpKVIhB0T1nksCZkygoIqpTieWfwE5hbv7CybM86Kf711Yx5I1Wjd6QXZwjw7AigDgxXJjAlqKxGLKTSycbOTu9POfEMr5r6EzVwna58MyXQGb/dRHh//gsRyFpe44Lm1hC7wzT5pSHYOqvAUC9PVntm5TNuZpaFDmu0I/qT965Wktj6RrlVLIYit/A8Z46g6Ghye05LPKicAriTpfb1q7pUDJBmwddxOX3XxY0ak7RfqhAUK7T2ClWsl0yYFcOURHArDAppOmwRcbr0IRXBcq58UZTO9aekyGyT+lSjjco2dI6I9GP7RDrh4EvaXwNF+vJoDzeUHmM/Yo0O2xFZHgevbA1oGCKJ1ChZYzbjeArRbvii7tiHUL5pbyPj1jd3MzBlFxnzh0tIUwAxnhCVjiahDOuSK55X/IIAHR6Nwh+yjVfDrrzOwr4lCApwiCfDBGk0VFdSepWkUZCBJT2fZKLIVlj9R0Y6rXdfR2b4e0PpRw1gBXuADaB9rUrxIHV1AJEH+zjTkPYQB8RZSJ9LQR93HvX3qjers3YU5YKI6WfZl68bpxPE6zh8LghgI2a578JdC5ceXtbxlRpXEa/1I5cAg6vVyRdZGP0e5UrC/l0/M9xOnWBCjxAka6clp1fpBduUMi9jVaGItoj4cSsy5N5TL7jGYWe6gpQNQiTWWbFYS+63lys5xwpyeJcy0TAwlFwocHJAXthIKbK+x2eljSKEARkUUgMmqyfHVwMfgESIjjyausM0wllRQy6mlrZYN3a7fsJL52wfvsbvJqynbUNvvJWJiXnlMmtp9rHg7ypn3Zq8wBOdUBqIiAVcnWARGblEOHU8KenTDaTediXGe/2EQ5mUzz/G4bp83D/6PagwYI/XFGK/H4nJN600bZoo2UpoRVVkx0HbP1FuzeMc1lzqTbVsKVRLTJ6P8tbCDnq7RQ/xYS8OP0Y0QBt2OcbNgceGzK6+fyM3+eJpuEr+D2wbAigTV7Yk3UCGO9EkowzuR+b7nwcZ1rJjeF5OCZulAqalfrK2p4ldKfG1XvmwPXwKfbw/FR/JmBQDdNpn1x/4z/XmO7VEcakob1uW6zu/cmcrJSyk9Z0L6XgUM9HCJkrYAIKyTakVQgaKMZ0dMxxRcVWUYZa5NbcN/xqFPY3W7eVjaP642nVzW7WDvX03R0HiI0sIlZhrclEtB27mtVbErArVw03R7kSWi/+pKDMnu8IV+JrIHFHlfQ3LuZLjV/osjzWTuQsAJP69nkRY5hZ9PI4vctQI0hfuNkTmdkVx/9+g7pbiHcJCCP/YwthYNmpwxJmnkv20wcdb2fbCSCKB19JGNQ1wmr5j7MqErdUowYAkTypRglWUU7x5PAPvQEuWBJ2TOzMn27sax4yUtaF0YbBmzYBGZp1X7nHocJEogOp4/YjKfClh5zGPsdO3u7B2QRG7thWre+B2GIiJhzkcwwVYCNPLDF0pPn/Qn2Eja1alIybf8zMTKJHAe0TnT7nemdWlIPZW3xRHEnHSvQ5Mwp3AtQ2NuQpGYvm0F6iy1/HZ+X+axqQKJUa3YEeZ7BKsGXgwJu/Vv3WT0Ps+9eYF1Oixp6GyNk2Q5C6hYBgkYSUmafQCqzNOuww08U3EehHtEGh6bX6gpDmXb/4Lg9EOLgSBC+gl9AS8XTQ1UaD6TMEWD7kLqm1EIIPzPWiqqTntUywLaNZ3uCntTHOd+sL+OELBbOq8knuV57r1n7/JsCOvchISi1zlGKu3aP9kltfxDytHYkJlMHIUNDnEs/5EK/VHB3A0vWDz3Kxthp13Wga9Q58dFokiC3cGDClReOPzTTU1DXLviXp6hfmUxszqDMScH3tHMDvSCwZT7CW1DKA8GlxWyWIMS7gJarUTitxCUgeMMdXP16/2Xzk4kFARGrbRht4rVHjpn2RGnARn0xbmH9+MiNG+uptT4rGOVpS5Pz6gt+JQ8ijb3gQfp3w0s6zgxBCTn+bFwQTFBHe/r3MyDgns85c7qS2p4mal/3SjQa+HHvne6aHhfpwFPA5gV6CzD5WzfoXA63qNjb2qsBRMLqyDWDN4StFpEwzZPd4LOOJrkwKFzFOmDVrXw/ua2N11vV/d9ho4p9CVOFqD16nT7/kPlCjLfxhwzh0rwbrmY9KqIdZV5muSsIhnfF6bnoK4Zy+y1lk+TAh1EUOMO5cEMoCgeL0EfpE3jdvtVwitEFbnnGAIMYxqLC6UZpwIYFmFkoTU3K79JCY2fUQGcRfkMRUZVzVSGWYFxg1CFeIczwMPEj5uw+PxTUNnFjgb4/70pzEgSDnWmk5ZhtGGnCUR4RuAhm5DXQGYeNwbkVyCyHYVxeb6nAu1CJ45e3Y8lpMYoUB1rvDC5RreczexZfAsiEKZknP/SVDZMWcg7+x9CtYHjZnYkrWVOqC9/uvR+oHpsAD5OYWMhUS/m7KtiZjxWvDEcSVWrAdleOBSoMHOPWMXniWAM2gONmnD+TVPhLJ25DUXWIayfEAVc/h1GSZOWA3kUe+ypyys+QbZM15n2V/CSutNyBKxpzZVlwccDdIdnZDo17uhbxctTe00sNoTIsBis9OiKs2KqSfH0KtJk6LykTaFNx0aJ6EKV1P1k3rxtJXBxGbD1safehHgtvo+gWwNGohPLI/fg0zpvaAdbUbQ91G/NxalVy92rjSsMcYuh9pkQ1yV7WHU7jjORvuOmlw3EmgaaH1hhhWpDgzGd1iqpbr8di9Hj1ZKqh4QxvMWYzB+C1RF6UhJJgvlmHnbEtCcJATk9mKVdDrZN11iczBI20gXQ+MuxJhuaQZowAUN1i1TRRhITFHM2Vni66FjzPNsSRiNsR2WSB6SJavYlmEM0/kcrrpeg3cqo4F+gXzBbDla5L0UbnanoiAqNF88Pk8dlrZHkcvzBPQC0s6rq9S79vqMkEOInxfOwMpnpUJ8L6jj2WV7i+Vn+PpsGVB2+fSZMuT6s+CBPy6g2oWG0nXTI/8QtNU8Oj5RCjD/Q42c2Qu0Ps9gsKERp+cQ/vmpakkt2AEc9JKBrW8VfesO/bIFOuHcKbWrE91Yo/mJBm8ozZbnIR3qI7eSPxQfb+CTZP7QAD4M4qJlZaRPYzXUpwBDD6rEK36MdjxZSMgJGB6os3ppPvrLNz6aA6kB3yamado0u9dK8nc0gmUohs6IqQ/DpU4K9U89U3j81gcgedF0+9BbwhXIBuJOUXdofWc77GUqOOB2Sl19u9PJPa4U7iA915Msn3Qk5oZdwKGd6XjIS4sSREpslr3Y/Z83z7iH12RdYYZ4cfkGl/R/HHfL1TFvBiyMra96UzAdVlPkyMTqD9/RdPkcJm3OfHwtsrpfJd1J/mkTRD268NrB5luD2cODBcZq7SP5fMN+1+6Rsl+hboCOaGK8oAjy9O6KIQ3q0CdoxOWE6jiOeIWgs4fTEUjH9soeR8xt/VJQ5pedWHfak45Xbjt+Q+tvUlambHpmFN+THDW/ydKGZkG4zqCwgHCzCkNxt5dHPNl0uNB2RajpAJL046sosX1GyCzGvGdgDboxpWmIACIdA1UPygyTQx1QRIQVFqq/NMg6lJHEhXGNsBxrWy1kkZp/GWOIAIsJG/63SyOC/k4QiCGPaqqWo63H0aBsapNHo7aPS0ns8wbBISu4MwPXmszhqHok8qk711gWh9kwSfUXztWH9cMnfLqDMGZMMuUpfOY7cisA9Xtb5Rj51kxZjJAuHpQ+zflK6CKMI4wnEbtc12nqpca7XSTbcDL+sWQ/NsKWBvpCeWsXpMHhwCpu25DDEvEigQU8oLckQjxnW7nhHZ/NuA/QEuQGXn7obNFHJ0K9xP9+pnkFh/CIY3zVeBKU4IqK3GVDtMPF47n/lOInlZSYNN55W7TMyOae+PZt9ZDTuwN480xoYZDc3N57aGF5ehRt4YLBChZMNw+sYK9rMFJKySh6oLovQlj1hQl76fw29Yf3Kba7oWgUpINlwcrzRyZB/Wq4s3uSYMs+wDKHbpTCfVtzKqtqpQGGFtck1uvGm4tOo+T/1+DSa2o5+KYAbdYbnT1ObFQAVmUXDOLOZS0LjindmJM4Uei/ABztUEymGGdq65dLV9ugodThgVrUTg+qGsP408LeutntDodC+237OcgiOf0PPuz0SPUpYrv9+UVTSPp3SVDvpOtTCVbe74VGJzcq6SIs/dfBFYZCxxVrTBzvT+vAWtYcjajRqpzhTsc65J75dyLnEHHq/DGil31hbBIbX33E+MUj4c47bZWuXm3RUBciEplOU4zzn7QRdtKsemNq/YleIf6DSHDN3wY7JHCJD3c5YzaMV/hCAHNFmA5s2L2obgv9c0vxe3dRxq618OVJ5IxyWIHusqg2+6ZbA13yDvSZS+Svi/UTuS5edQIBMotnggaLIJXr/mNS42qdsApPjDLQts8KB/geur9UpgKbH5mQt+gUAzIDlzcx2DXWHNo9N9gVQyTzlxA84TNLU0R/g8Fiyu5QYXzD9mgOdjMAi1qC1d4FsQjzeSo9YgFfSoZ6NCQXiPSdJKyrnSPfxtLWAXtaCBRP5qYPtWjHfclGjPCWBgZOeCK+VohpWSHh0IZ8uOSL9jdi9KIslspsBmMvkrtwXs/HvP73nOGz/CzGkFS9iVUv2dN6IT0gINfYDl7nB3zTvM5kPjtIt3YZaLbPlZRtU3kX9SUnZSkBhSxiccGBNbodxfWIffH49u1mls8eE6JOE2u/JyHCu5aXp3nWWtN9TrJHnLq9o47Hx3MI5IkRe4XtHPISX3xkJNvsBmPMVds7TxLh1UjcmaWDRJO1LZzGc74eubcXMyFKlWUphA9MgJZ9w3brPntAqb855Uou3GFftI9bSgtYrPBMv9M4A4gHpHTPe6LsV77j3l6nyFanRDBkTxYw/yE/iZfI5fz6crIjUtx/hqpFdbBVSAMqAd8BctDVVtYQu6eexRbFnq5DE1y8Is3TlACMKLIebK2/4kH7FrX9XUsj3dCjHSxlcxyaOakUiirkDy5WCLzjasy63xQtFKTFY36n7iLogbw7dKIcyl5d9e5eHLkt5VvPOQnTyBfxi4n3I4zksdvQuTAvutsMyhkr+3hTaXr0VZfQg2lFPV6OZr8l5Mcog9y3o3CbzqYRP/mRw0FDmT1vJAG1hwXG1JKU8RFnttQW+S/MGw8oBR7bkHu6EBRhY8EoaZT2a+WHhAVBl1cNXwWHv9dhuZKYku7QrtdajfPf+PMB8XgkHt0QbYKsCeRlRdvQEUuGzyqeHDISTtuyhwR1l9wOr9JXu2v9j73FSsKv/5CjI1ighm63E8AYF92O+5zFZwf+7DNCWG4l7s0sT85MY1/8+YHWQE8zFWHh5XYA5W19pUfi/gQICsyR5f6lJuJmvrwYaZckC42hl/DXvEwIQBa0kCkuwJmWxcEMRkscPGWQuOTwycOO4LLbHCWJHsjOCpO/MEaIFJMFvmz+YOH9pKcLWXeWGNIk9G+fwAqqTgQQ6uN0zLhTaY4cCG4Mj6pH7X7C5gEVkmqFny6L0yWGI4eoB10nxtX8/4IfEJ6n4GtXpbt8NXcwoO3IedHjpMfmcQ6sEuuwcsVH63IdBEVN/+bGcskvbCkQ/h1Do0XuVh16ufzgZGIQXUol+RoFyhw3meokIbYaiWN0/Ne+EesP6J1CvMYNMQ79Vu0Iu2k5drHfsN9Tqs84LEIWm1dm+xuAiSIKLeA3iHS00hZaZrybZnFy7JdMao6ggtWBM2JWaaNgH8PB+WMQVghn6Vap7SKkKb6r9nJdRRaK0s7rrjWDr95TC3sUDAIKUht3NLPYVnm7Yxm0ofs9NeaEcBo1q2p440l8aXGOAvmxNDlDxnI9k97tQOe34uJgCj86y8NJd/y5Wgaz1xAMigBKhI5YyQ6qIRw3F9e5nz6mV4fhMxA8UyN85BfwNFkeTASdt8Qx+NWffChhcr0c8iB/h4knpF9OylGFiBkl0w1vinDFg2eOVf1xmYAwlfFgU/C++jJa1ezFy3k3DX6+jNFV6BB322mbTGLr/pRZczWhfx2xa01qDvNDSPWhRtv5Bu3fqrJZKVgio9nPbP9Wn8JIOW+WQolPq9MPaq8LuJawrEUGnKPkJzihP1c2FeS0yHxk0e7mtY8f1YDB5awpT82mIN3Z3RBYgtB8HR8xTughAPotoxnD3SeAJbtNbz9KQSsyhOPEJX+iMLxouECgoRjhnUL4s77p1t1QDz2Yll+gddChh0pObbOCURFmBiA+t0qvMkjjImKOfKnAkBzozzL/LMb8M5HK4/U/nfNPsQ6/7Wt1jb96aeLBZ5vdgsH5QDpCJP7w/yW21V1K+WuqkVkkjS7CSDU8Xhw77ue1O6qsA+vbPXd/g7fKeucvG49AUh7uBdSRUDavP0GU6OEgOTqZL4eSf5rN29pz/GNptApQYbVAumnGEikncLo5AKwUG/H7gf1ccyWifKBL0Em9rtejBAeynoadJdu2ahEOvQJAYFv1nioMr0CbgnSAnhhbJTMNpAbFrV+6T9qDFua34XOLQTNX42wxjsx1jb+NiDjE4qIwV8RC/p0wpHaSZcZwCDClHUL61CJkjkutAIwsOVEsyrSEmZI+IqQ3y/xCUbG/NAkZHxytGRmYva5mDwqBBlln9xc6p1HiPr//56IX3stjpe3jg7ynIq8Y/IBlrtce7+10xDXEL2TM7j5/bINoq9p/KU2UI+8cp7YG8NhVtJlt2fHcdXiuAMxyTDTjZmkqeZEEnakeOTcba4OC9nLUFj//EvAc11dvK6yAhhmRFCNGmTn3s4aGig0d6Bh5bfRV9P0HCSdMnlELXtauOo4Bkz001UWhEGq2H+g6eOZMUVOQMKq69uizCSetjANpgElUamTCc+wIgv2t+FnFODJSLZ9XUOPjuh/Deic69G9V59EmQ70iyABpw6Pvi/qqxV30n9CmIjlEKN9q9xcWrpZYSutQHgY94+DLB8rm3yoDRm8bG9/wbZYEc4agmD2P4OuTRGJyVm2HmfrJ8OaH4LDM3z2WA3yVcdl8WJwP42pXOMcc55VS6lIefXIdANUKlkT8qv4WIbPkzFwKfBKcrOBFIxbLkRokwL4poX8h28TX5I+MsHXvq/wALoJSdmUyM27ruMCqei5YH9E7PtbDZN/yy5WwinZNxoV4LCZA+DNvTgH3zFbi06ulBV1UmHMbE8gxsB5fEknW42W0qlEo90NWjFkmmqd24bgWaf1uvEbOwjcp3UOzA+zN6bA1NtMoa1Z2JNYY85x6vwuBVJ866YdW8NhXLL3kCWThLwKXnSJiogAVss5C8eC8G+rHpJgxVx+rc4N2t5w2MILzmmguL8QLf0GkZobq8E51AXomTuh3jqyFkyUGEZwFGyAZHvo5+vb8PKruUyB7vjC7GHHtDlsvY78aMO8Xx8fdSHG69BB9KybpN5x37CXlVsTeo6RFMda+kweU1lfp71Jkl88L+5KrwZsAX24Uh+KUVeFPcWzOy9xIA0+PGum9Hhao0EyrDQAfDSEhIFqeXAw2wZuNHDtsRrsrU4oEO5p//8j2X8jVwXYkZOP9GC0ZDytnKenc3dP6RHhpnQgncf5wwuvjNu8Rauu2wbiu7XqkARrYeXq3lw5/KeAty7Hu6Hfrkeh2PHjUb7w8FY4NEEhgSl70t9OGAB+LAhBu3I+WgWkcb17o3i9R6WupzR2vOTaFilSaq2Hgun4CF9L8haajnjCbwNJqdGq59IZ1ZK1aILt/PgtitRPjzVwt4jZhkTyOagaAvUoOyQmZio+/9sHmNOMFwa8Jfnz0q9M8RT3GRkPDZF+A/UPbNG96ZwrrmkPSz+2ySMWFHxBOwVzYa8LfhGAxmXGEyCzpEk5b0wDjiyKKk++fLs58N4G/DG+J3VE3comDXEajJeAuo7qevBhRt9lsJ8M2qSud/VoPg/HHIhhJCKKOgtMng9fBMp8HhRddWUgqRF4k9NUX/hFH9SIb8XvDdD2AZN1PKn4Ir9WExw6d35uYfGczXJVrIZEqS6mMN1TgLX6fuFD4YNOwi6sX0bl/HzQRQ7WGmLfYyPv6FIIkXvsXaX4mmcF350KInsSBRTagB0ayHjFUz8HqK93LksPGO80cQHjMo0AlAYegn3BqAbKYWVCg/FwMo/gncZW8PfzJ0tnZR7rE6FrOodecjEu5pPesoLiPaBjDMOfRh8HFlbo7NMoBGDyZtt6aMdnvMGYFDwBrTXgWFqCLmfcBaKm0i3BqFt2zUpP5kXcXAuVUL//alFlWV9hsfhJ2bIyzfEEFU1kr72uCmP11TPmiGTcqWKxB5NCbsNKm9j37rPa1fXNvCwaSHMc2JMfcUSuZhVHKwmyLwhGzlet2N/jRf/1OI7BJiRP/zGgzFm9487nVL8lTSs1SQvjMH5ZWJO/DAxkpJ83KhFUAHTn3PbBLwdKpIefSeN4RulMTFQOOveoxZc6opGJ7ybfHPs7UrceC5DbZ2KbhVL5tuM9GaT1ZQzPBD9t/NSeCqaPSbROIPQNDDaKHdP598Rbig8lNpUnlVWUkEptE3RYegaqMbBaAEJv/xPdQrsX9sC807SF6AkOv5f5x6K+clGENbkx8dafzmgc/auTcKnFI64U5ESJb5KhlWKTbLOvRv/PbDl74SECi3dfQhfKo0QU9tLjWFQjXq1m+tUnq+fxwYZiM+aLteaPzBdM841NB6ory3UpIDwen9107lquA///1AVNDzODM4HM6J8UBTmZeI0k8nUPsKl8EstjJ8vy1V8QrEJGt68U/Ys5jBud1HmctriQ6lYoYcTDW660wD7VJv+x+c3CYCKRu+875MuPAi648Qem7k9ehpdA2wHjleh+J+mJjjX4yqCVyElitPdq/vxuE4ww0bThDixnOEi8M4NgQFXxvD2eR+oAf6x3nHu6O+m8/uF+UwO4NILny6em2CY0g4ZGqDxqwOmhpjYinPXIpC9bQlqoFWLFcYTow/kVLKSiJuUgMlEH9+3geb+k6YzFjKGgepFR5vw8XVeqxauubjgUSii4R7lHr70pAhKqC41KhuSe9oT0VxSHkLLiZnbZOnPv3BpbHWiIZbWKJL3U5oA6xdq0IRxOumkO3/Eq1Wzv2S4KJpnhc6H4QvRtZcoxFXZMXyCYIlY9+ynK+WuwlzidDMky+q5yRlIWxGWdaMNPb+Y4RW61KPAbir++WbesR9V0zvIiQcAOSjisG/vbRz9zo7WbhVH74XnikR5xDpiQWgiN6oSmk9klv7mqYkb0eeExs8Gc55QxfB3CIaumrOyB7SkIlCZ987DeeGwnJSeHOB6C06I+QxSra4yIM3UEfXnIFvm4lZeed7NvZ7lJVP/2vilFr+8t0rBKxV/ft1tcY9A4jbKw5ip/hcVGlWMNw2QDxAXNupbFlV80ZiEwPSfWUvVaDK99IwSoSAzlQiowtP/M1T/UmDh9umxNgOzSaqUcfuxg4rsDQ+QtZ1YbjK7x3LQMIpB+epKme5tCNwYpN1oFuAynKRdt3IU/SQzE2Ny1ouDKp/VtUfo9srrmLeKcWN6sPxiSaw4UMQYVMJh1u4lIHJBU0Zx2DsqrAoBuyY8aPM64dEEWZcZI00s61GwpkkeRRnxuU8F7DbH6feiLCSxBWdOfF2ztaYd12/eDMmcUhv/Dqt267i/WHDm9KdHlTvf35ichX4rDFXweAdjmTUlXgTDNizW0ezBUm32bG3XOrFeQ0mpe2C5uZn3FISB4JakqrDs/YZBkWQHS+viNYkLR+bRsfglgoiWSH8rraMhdjO8cZHrxeK7qSUMuXwj47QyWYRjFIB6D7rv1GcnuO+8BcEkCpY7Ai8xw/VMfEe+i8TT32sFjCuepn+6Y/dnIS1INDjeAt6iMiOkqwrq3pu0rGvX9fWb4xD6y2IoJkNUB3fAoOmPW6GmlbwGJofQqHXVAJlPAPBSwJ+c89Ce29FgNVdL5KfdG3F+2ItfEF8IuNL3opFgpFVM7H65fKIV+kI8exUthtYG43McFuwn3BcEcFzqqxg9vmVMz+XLCkCp4ed55OtSof5iSgK7NyS/esPfi1GalOV+gNYEOWefqr5u1CnMWx+b/k1eVHl+n6iK4MgA1vS/IwckRQy1gHAecHV8qXq4Mc1rp4UfsiRmhrwNXn/AyMmt5qYeERmvKzpoBbrKEsqvB1xtLR1IQogGIY30CheiG4xeaayyQsJWxlzApgA2VSCP7mZrNA0zQDMVJT5QZdtRuqcWzxFD0q2bWW3RNdCNq9JAU99qJymIoik6+N4rcxalxZG8yEOXUwI+iRGvrFbwjUJzMgNhr2lUblITD+TprU+rVvu1HVuKn2UdW4sWRuD+WwukWcRxtMkrlTIjAlIZV//XiVoET2dzFwPNc59kFyVPuEOsDEVCKrds7sXMYeo6rC4egXpDpSH3+qMR1ixzFBvvqBhOzUEAtCsKgGTcOCcvdiJC7SH/OyMZxy2eOorzN0FmMTfFZVSxuAY6uMTpzrORu7h6zESMwDO9ACGSecfy6T4gsJ0GcgjQJSmUQQbebbzlCjCSBXQWB4jkjc6q0yfCqvul9blmNfl4twC4qd8tY6fvzgZDF7k9DOF7Tc/ouPv3ld+ySw+FC08Liytd+Kp97PLufP1vm79LgJpz2UuUT0vGnuNBfbNGvBxp/uW7HjK6ri9/JoyEw2sd0ZuLWZDWt3+OZNNkYQAYEmWpf/i3tj/A0Ki0mljolLQkanIS5dRqKMMNK4/mW7Q61AH8l+0CEh2MDV7+pMrcqcXKLOzLtwu44RU2gHuLoLWGOch+MQ68ayCN1OBHjQvvdALDbwRCmdHzZktvAvLlM9K8jfP1O4kDvR5PKCiaCxY1l9E1TYP1VIq1mz8ndH6a4gb8+cFmWADw6FpAOx4cy7bYBTNPQ9NF65kwmyinzMvSE2mPZGnDbCwVLTafQisOtapw8rg+yx8sVoa7qEIEL9eZnNf4VnAetthWYLnOytnJL1RyAlMj/QLHfYuIW95n30RjKPcvpfhwtqkjE3k9wm/6g66IKPVIfK5/5QcZiU2pNzcFTUWBwgTIbYEUW9XSCLYdXp8+zwV/4pmAGIFfYea2RFpTd9+LLemkiI2LbTRywwbtySsUjWtYmj+2rZbPg/pX5bOvCfO8aKsQtGvk8TS35kPpGVgkClzR5vzS/1nPA1jM9gRUUaVwotweI+H9zOD3HqZppIdLqVF1zvtnqKP6l2tpxa3TljwAUfy4R4+L4SDM+d7PpfjXnw6XJcbN8UrBXnBBWM4hO9J4PN66saTKe9SVZlFVNENt1hmAZS/86E9614nPSqF+X2J9VFCMZszQiV71ytYvELo7cJqoROR8VRt991We4Ph2iCJk/98zQpq5xl+s81G+BH00R4bO4cHY+2CWynatlufaacvkkRN4CdbxMbKTkNEc9snNDhgumzcboYmL6CpjsCR4sOCoHMj2TeQtkct0Y3UGiTDz6DQNmB1S1UZ+9jqzuZ6zdgreaQRlG6jAXuuUA0dZxQB/6MvghpJ8mLuGXTakfEjDFvf1/mnCM3EQVlHFNT58+0qav3hJtyrWgj41lC+FTi/5UauM8EOlhzHyTm7IXRXtc5Xvt+7+8kD7vX/Iv1WEbWUupIkzfTZBtkE0EjuSOo8XPsyiO8QWbP/8E/jr8JVgB9FQsf9TAQVR9qqqBxFjGUYPPRAoro5PeDNngn89WFV5oMU/2Sk8+yiykhKnpUcpXDeuOAQM6bkn6a9DcLY8FlDIob8We26yu6Y6yLqdwZk94ps3UEI9f6g80lVonRhMOn1rua4t7fO+q8rEyauyXG9QQi25M0Ljwlkkez/XN9s2n/vTfc5LPE43vEiXbWIq8sT4CAwPIB15ySngqRk2C0El9pTcCmEbXAI4dlA3X+RF0lvOE98o/aaEi1Il9PvaSvYLsh+rmLdiB+DRrZOBKzybMDgKIQmdLiI9vJ1AD8EIw0M3a7Oufazy9kUx91tXt5+ZrS1tBmsjX8wC5hiayWYw1OzSicavhVYTZX1bnp6dObDMTLBDIqR8e5FfG7Nd6I5DmuDuFUNuQssXzhcePUVS6qGepu2WSdv58WmU88FIf0bI95qVzeuyo8XR6ClWuoqtAdDW3ugd7qL/siDsUszNNMQSUyxHU2FUBxitsFooyiBvGt1vdFJr68qkWDn515BOl/swiAMgKsNG83NGqwQoWxBSAAgGvE2tpo0/xUkY9voyDK2LBnjwYVXGEi+r9mvxBP7rjDtH5OCOx5/Ztmg0ot9ny8O5J0Y9T84nlJZEHojfmyjt2k39cZ1Ofvm5lhbEkGhKC7wisKkZQSErmBANsHBxX0HkA6r7GPD83fixdFKvPC6ZSUGTIbiNSwpX7CxXPYsvpfOLWM+dUHhqs6wi8S7ACNt/C9h/Dgo8aeLrycKt13iUTMxiDNipXCUeqqwPqIRgySqW5EXSF98S7S5OMMXmA5ordsecBmDDOffGowErVS0qqIgg4YdJ2AjzjTRuVfoPbOaNwYKpuV4TQ9DbdiG4/VfFDp/fzEb422W4+AAnEuZniPiW2OUoq0g9eVj9xALbJywOojQqVuncLG38IDP9rAOktsLSiTRF77emKOkSUNZscQoYnHreqH6O0W0kfLs+b2PIEHrGjL5lGPkPKP9a9fTTRzSn38FGeEVdfbXVIdHNL889XAtNleAnA/Bb20Ab3T5SKkVmGsvWTIQBTFA9f34NsfC4vqhT9gbNcpm2O0p7tMIPacQN0XJVvh67DDe98VQ1iYutA9NCzdsLUfUtoqnJY4taAQ4O+mCIBrkQagI+k3h7husEj51kHiUEleqvvFKFB/4nhtE9v8gzhawpA0X+LTb/yuDUp5FgMQqJ+VAOYykKth76VuyB3I2VQVIhwRk3UZ1YXNDwag0hAfMKVQmljn1oVPVjpxgDTjHGvN79dvDuJVIzH/Uyp1yjF2uKqzIzuCpJhvyvioAs8Bsu/+mWH0PUIQMu/u68H1aMnSHnHSDtUEAJbCK5Zxyf2mwrXCk30YSUoAiy6DaUuMADwrSsdgSRGgviTAhe9FDYqdyxac7cVFAXBkvX4QW7bPta2MdjmHVJOD7VSR6lJ4UQsfNyz70gAkcACscBrJAFP27dOECSl6cUUAYfLJ8rNnogvr/pPcXNQsz1gG1H/XnNI0FKztphGse+VmhjaPnFcRj0E7Ayp1cqGKcPhvQErUgCqXb9GQFd1zZmt1KszV5CMQwzD+0Dx1zQJGnQhrB44Iojv52z9z0dCXY/tQK5e4K1ulhymVp+3aN2IioybYOopn4GZo2lazxdI01JwbWeLmF2jv+H+L1Q5K3cIkb68ti94AxFONrRNvTxEn/i1Hv5ojcrwcdNqG178CkXvDQ0Pw/EheFFU6uEv6xrQSYFEKKMtrKKpzaI9RRbk6aJ9jGAXUkbARdV+LsyLTGgzOrvkyXsJXRQZtfzwAQ8EbnCwRXqHNXHrEqUbOYYQ6LaIainY/5sbw65o1NTJWl72wM0ZdH7U3VFLmM4uEqNu0MXGiyZ2/7qkVJOlUdNR6FGmetgX1NBhys0Owz65nbbZQaVSGD4toZcjJCNvixLIyRBBuWoFdIIT+mArdJsH0dj/YTQXRc684QZM9HIuK5h/0lNxwC/xwz+G8Xs4qcVBOdAfj2yvY76bs7lLv7vkXUtxaGMDCSazA/slnWRu7Spsf+OrEVu7CgEHUljgdmFu6y5dlgJgvS0MS1LmMiT9tRlLhi+2YzAygRkYwHjQNvevDDpoW5W/Ta03Ewl60g9o3G6eedBpFvRBxD1+HVULucGtGImDRozblHXmcucJob4hsrYDxLby8aop8CpSmHEDdc9blsML7HMmDdunBEOY/Ixzjq2Yh7VjLAGFJRfw+G/yad44AJwHWqDuetzx4FlUd8SZOxuwlOoH4nn6INonwqV+7HY+HqTxD2pCfNwj0flb+tQma72jFilirh4Qe48RUQk8rHDXCeqXaQyV/cP45GZTQDXapIw1K7MX8OU8sdysaHJBiJ3ZclV+IPj3aj42NGCBdZGOUlL2d0xp+RNOUAxOSn+pdyLN+IA2gOiZ6OawudswA81O8Abc75oU6f2ZLd2pMNWpN01c+IOJf6gkqQKyRwWWAkqwQ/WFTUNOmuR9Z4K6iFcJSeCnlel4sd4ZpS3EewUf80bYHN1RJ0VngsLQldh/yDQy4UgxvWOX3k65p+WHS/THGogbwG/MMSyn4QeAOgAMnY6D82UwvKXW/hAM0Wnmayu+i5xvlSuspVClMkLXM2Qgltpfq5a/jlJiVzllMqpuYcbFjLexfTlPofB2sEX3fcMReyISqYrElBAXaAvHvRKaRMGR1ZPZ2Ts6m+OA9dU45Aa83Vaysm0+8nMpr9ArwFFodsi++74273NPKCde774UkjhmSrH3+7TJm0Rxc8FrlZRRKh+wrKRqHGJaBfTwPCv8W2GUDE3FhTqm5ElQB44BkSmT81abs9QkIMU/RkQbDRhFHB8iIMEkAmdUblrxk+H0gcwUgeFtjnhonuqGV6yPyNzOAvYU6rZDWWAMJq60BoDnx4AF8pq3asfWwLh+LY/XWNhPPTzefFzgmeeIhHOz4O5oeRsJzjb2xutTJyqKMPGRvcx/IHTSwVJOtRBP/M9YrOnMWjYL2MicIOnGIbGuujS+abhuD80cDJ4xXTdRaM3UrfJtRMshsKNgimM90aa516CFyrlR+KQpdfqH4zY+onwc3RV5R6JWkbN1mfvUo2yWGDkTkenABKncIWKp7SI6RxjKYdTZRBnDPFqsRJ4lCDbhAKgQuGa4fIbhntMrWmL5wewr7oB+FpGRxBYXpnVXymsk5XNM1ncwQ4ypVlooKRhGG6ZvaqC7KbwZGRaWy0UCzrVyMhX3ENM16Yl6jm6xN/jcRWVoFEaIORkAVNfKwxQ1bv7Dykilw2loqYiBCdAnEI0tHKIIkuS+Sn7aVnbqRoOsGoAybMmBUY7hJB6UgmpvoTD6MliUrgcZvQ0cPaioRkakezAISPhiwsDHp9lpys9NQWL69+QZFeiFHHDkY/Hvyi4YTphbtbM5lK/OxxqrZ2G/Lf2JN0MctjUs/ZXZz/34LMQ2VPv/+J2+OVi5lkXE1mTDwBGZj119zOM/RR/XAbI/Hl5xLa/qo2OZOL+rJzJvmXpW17aTEvxk0TJOgnhbDX2drAFKCd7GCIXh8KxJ2qh94xGwwD87K6DDa/+jucIG923YL3XYtwIr9l2iz0G8i22fI7ro9M/keA6aPaJ6udiiORf9j7jekNX7c3rI7PUpiCQbuvWZ7poKkJZViPuv1yb2IHMsK7wlx94t98uaQM+JElGlV48Qd7qIHwzzwYK5f/v2FbTpq9xpy7MWLWQRieRXLqvYTmyAD6O2Q8V3Vw6qKf3m3X2j62TgJK/MqFHVMCByyRHajAGe9A9ku8SN/t7uXGIn4gvyLln+ZMZz+wRfURn6eLzRn59X2/6rHAeVjyfGIwFUSvuFu/1CC5i953mexo6tdVCQtscFjmgppKUfAd+syENlgiDSvwxZfM3eO4rqEXOib870F5jucyGwoHEPIWybOUhc3JVUDnecgIULqmhRswDrxBefOoJSorYO4pLFLhocG8brGYjNS5YOUD9sC3Eymkj7NkH5r1cyNHFA6M6lVSBytEJ0anwu5AsOSMWUgZDdcgjsA4l6Midb8R92zRyP7dwfmcuwHYKrfUR8JfpzMz+nGSPsjm8d+zTnGAnBeGEa0rhkxev9ON2cq251OunTWYoNubG15tMljw/HSqdi6sJ7IJm/XaW0u+3TQZTl7b3dzwaHvyZuZGp3I1a7iUjuq2zL631w+wNnk3uzCvWL8wtW8/zYdn1mXU6ON8n0VDLU9QoMxtHoPAerAr0PJNQQsXJ90P61Yv9IJA5b6TmSSYuQOAIR/eu/xBYaT8Yi09Q18bbr1lJd9ZK2rHbY24mDuIlKbiWKm0W7poqHy1uEO/DoyEU1ANmfR58Sq1T1uThjMVUBroIOXaFyNHbYgt4m14dSLAl35TiJRF2izw/ESSA/SiZnGEBH6LhcxXr9s+6gXzYDJnj4A3aUJsCXBTwAxwd4+vRNek2SwaENLvAzXR0Fim0F1zAy+8iFVbmv4t2I8bS+Is+dXMJRRQEZu5qiz/Qk4LtsiGMN57P3U/nt26R0sDgy2AoQUrCtqbA2Qa1DOAo9liUxYoA6Nx2tR1Tuo7uAljn9kz7rSfpA1qCl1NDRP964b39NbbDGSLAKXeSXI2mVfQ7MMOK7dfdfUQpdSeGJeWm8ePujli1CL/kNJiam8xJbc1cM5vA2izXVT2JjRZBRCvFOwVDUQozMHpd2aqg5DGoY+/pGpQZZPQdz1ABsO26lsHqMRfwlHYCDt2WfMrPvHOjQTkCjHwQ1zZLpmpL4dntFwtjotweaE1S3b7RFgv66tw2IPa9p2OIVope6MgCIo50UKObVyqbPWKEc0t28P39kF15g7pv4+QX1HpJhIO9Ku8ZXmf+MqsHLaUMEm9aJ6Z6UhGs9QJpEXB8XldV99lHPTw7hTd+1ALTrwYy7xpb/NZiaCYjI0LQ4VZAeuoITsvnbrieLwyTWXRNEKpG05sJPYX1cOC3Z1vweHOg4H7JuSTu+bczqDSQbYGwR4rLhTLGeBa7cMm42nmxlRbZtJ3fOCSJb6VTyS8VtHJJ+W9VnQJWpT3UuMl20mQg+Bf16Qw9hF704hyMGGSHslmLWtFtZdHwIJPw4CYVdNfCfIttv8H7EysWw2nB2+NmuHDB2PoM+pPP3Z2TqCJkopFwBvKb2qHcu0oSXmrZPG5KoqsK3LcgbFEDBOCfUi8dOUMAd+SZnmU5cbBU/bbwdmKXO/DufjFbfgBGewXvBznlXz8zwqu0x7ZtqzpAp76VLK6OuFMiA2EmVbirQO5VoHn0zSCoPyBRHl/1hKlVkm7bn0pE22tIAoVp9DmC3MX3RLabAlPpRc7GspviM2cGW59JnkXs/WEoy73hLNQSIlUzBmTZeMc72xdcZD8K5IfNnmPB0brAMTRGh1+ueSo6hQ24uvadpmAg/fNgqHDQBMElGQRvlk5aivBoANIONaNbV6xNR1ofJhxVDM36IdnAAMgmxUj9o7qkL7zdhBrfjA4+pkDNYSVq3/6mTMWo58FAucXGUwTWuHMAybc1vwBwUJy2WtwemhrOunfKjxJOLxq4rfVes1w307CUJfj0VOR9rt3xb2UMnhXNjei2FX0Apg1FBhykIX6uqJNWWlBgD0iUt78LDBZ07QhBdMe3bFXXmH0oRsgioTlnB8HCA5ysMQzChkE9V1/5+h5VgBhFf/wooS4imBCFQUsoV77zMRPdUK91VHXxLB7d859RcUeAhKuGa1bNxGU6Gn5UAOCvGeHcwLs1BDJrBGHEGgEZIgLz2iSydI907uZRi/nqzpvg0frPnVU5pJTZIWV/2qvCVxhM8NbYZkudYTi/T7sqHSvgxCi4MfahN0gukTXRczO8sVkdDpt7GEXtfLkaPYc6CMI1/UTKcu+aUz53NUhkhoN9TDxDMeM3r/yEvLIe6BcQ8u6E+liyGlEb9VuEYEJtbQLAe/mR5IzGU2Vr7796rPJk52EPGjec8uXKePFLH0bzICRf4vERdAWVLAmJND6/+Dvci9sGmjDrsdQWx1C5g/7D/gDddRj3Pm4s7aPuE9gNWIV9sHJ2T04UMRyACDj98gmZizfhjAPJ5Yy3mXZn+0Wj0T+aOcFwoGhByxKFQ5Fs5tLMehNRN2kaTRmN5g69CHbWbwfIUc1/wEUaH+K2bHHhURZGi0qUADLvWVETHdquwiJ3nBCONqDJtHhw5yMpwhemYtIdshB5zW3c89w/AlRfDCXedFRy+xJCDjca22nd4Kqucwa4WeTaJtkxfwKwKl20CLGr2gGUAVZpJ7OdHVjKkZp7Ab8QpFfhjR97kC4wfXgIb2eo2/MTzZqJVsyVP3/6jnmZcHVj4cetTfTwObJxW/cHlMsJYZYdqGmgfFV76u2cf60s8JjQC4jPhfMaVbNYhupxAX92Os3hZKvQtVpObK324F56YqLKDk1GdCid6q660Ju/S0CsuY+kg/AKh8/jR0nOe1R5AUruE4hLuZVcWX9D4Ba9fLbsObbzMeKWo2ehrTOJ8LGSvLkunadbO691Te6lhZRnbYAcj2URyyZRVOk90T/Jb9O5bJr4Cnnsmx8xhgrtYuqJGeA0f3tZ2GEg7bLzjjkGf55EuqFQSpi/UnWlaeno02LQq0zIbfva+vC1uN+L7dGgwgK3/5f5B6Ro8vunCcSMdpKIKVr3/W3XTxJsjsIVfAgPEBwMZsVzlaX8NQNOFvGj9BCWgsgW2LyBfKPkHMVv1PrVPNVNRdcnFYFENb211lqqgaIB0qdE+Jkucr7elYzYtYDQ29bqdCveMvMm450dsBRRDCNZaGaGtbDIh9dHcr6ORduFGBPuhmwQPugdVD4oAGeh01tu9lneiq3WvblpftLcSnTx40CJPKSJ6dgIi70xHZ9uJHTwtUhxtvPOcN5PCSpKEShHhdf3cXxT5tkB+kJL2NjO7F7zPZ09R7fhOysPchtBKg4fpyQ2tW5KK16Q8jukpWH8mva7TWfBRPEC+SSCyX6nMg96+1GLAUGD/Rt2er1a8WcGlJ6wN8vzwZw3tjsXY38JlIGIjT5lLBTXmUpaNYlYcOSOfHLbRd3S+zWVdzQFzBdfuUX9CWdPC0NZ0rQJNHefbm4apVVDFUe7dW94UGBNU0axJduOYX+dd4TiQGvC/xoN0AU6Tm7mNWcDbDB7yzH4IXXgH9j0eHHJlYvXhIaoAQkWjCMhrP629jCHGfwp0o9sbiYz3TN3IWvc/NMHyMyRmuYT+stZvKAskklrbyh99mZjxWTHjD13IdKWDmsN6alRXTdyvXPrXMGRha4C75Q37q9kKqqa3i61Kh/xVuveFBaMpSyXXTBI1cTiZ9COvgDiEbyvcJVxC+qDFJgTJLhlOWhPbn5EEO8/KmbVOJhvIvCBOwrNNplpFUJCJCCQ0W0FyYVIYGdZsIavOe8HqFhEafI1J+TWz2Fh93QXxWRmm2/vv620jt6GpdF1wmWbvEyJUcJimFj0WDnANMV/pd+nmb6yeVYewfpGFv8VAjmoegRHvmzLhGyNoD5pyaqWD2U3h9DhezDlhPoslx6jvwjowqCcifBXT55auIe0iVgSkgpY2EBAty8vp81fb/etf0gqFgituRKX+RZcGLvuTqf9oODx4uiSU4hJ+yLziGquIQ7SM+8E2m3qadATAY9arQC6+SrpPlIGT+Fljq1U+Bp18tAwEecoqqRmUjsVrsLnpG14YOCiOmn78qfYE1bGqveSdj7xeQBNJiCiQjN82wxqIhX3Mxh/otuoaxfiE1h68qjgGWOtTOF1hHrZeikRu7i+mQMj4XvfpFUP3iu0hzkMQBWsQJLXskq78SXcbbVbbYTtN0LbjEW7gV2257bqRndcDw2ItKltEFznoODoTzHufh3YcHx8QCqgeYndg7JN2Kt9BLSmqvkIHO4l2X2FCk8sg1WoR+3p994/xLQ75zy5phS7quWJoekFL9EVUbRyX5ncR2XQ6hOS16njC/D9J+LRPg6GdKOEtb+8zKTVaY6eXIc35nGg77suF3QGxfRVd04LkQxEpXPhutg8O9plkCaqzQBtC2M0+gh4DKatDWaO8M833dpN+QNgWZSykT+X/mjj6xUi5iVP7FUTUa2NBNyM1gtf6akly1dUBtPTF9ZxvbWFTBSh5SY7Tn98MtOn5eiYSMPVbxeg51FuixcMa17kg9uMapwt/JiiLm6hDTRaHwcU/IEDZDquWCc2hZSh7Fi2VRd03dtWEieSVMTeA1HhVrUKTbwA69/ArWFHusV9nhbQ/YaMUqMy3hF4G7Vgr88OoRyfF0UwjmIkGIxfye7msqjAfJi6izfJA418bAIBLQ+UZiTnLA1Ocb9LAFCbL7lSHULYntBSWn7lftCQJ9oaEZ9I4pMsVmLJk/EFbYVr7t5WTgc4jTxNWpIE9mcy+wbVtOa58fgbzk3Wx1EfLvMEoMEplSrf34dbopBPNRTZOOw+7CVychDu+DQ0mx8dOQvy4POuO3v0JDlWlAvLNPYzh8Fk4MnuWMFsH3JM5Oyd9BeleUHrIL0+4XWuky/sf+FyBfIZ+7Mf5HZ9bT+iukWSMK1/wwZyULSomjGlTWKj03bQEyBTqHo6njky0L9vHvdpJDEs0jzo3Eer4CDB5qaM/YNLrgBXjNaM+zVqmU8k2Pl6XMMlHVAdvbReroEOJUXXkkwRTL6fnD9WZK9l1xarPdsWmzYIBmzxBZ3MKieuYVyvI7bR0YOIYo2t8toq5MPnwE818EP3oEIWfxoCMDXkrHIzZ4HoFjcgKoPmCiOSblAC09n2eJ4TIkrpD4j1FnMzk2Imnj/cTWaHzS4lGmIKlwtpR+l4bdDqH+eTS4Dahrq5tX8bM0GZdXd9oztVo2O735EhkxL8dhJeTpNeW9asyc1aGuDqapM5Rd4UuGN35YCVO8/4a9A27reBXxayiEQ2RCO62SZ61sl/YQX1Ugmo2sPp7caAXjkKPqmQzmnRb9re4imZ84cgj6JsyYsAM8ZwIysyRWm3a6OG+oLKgCCZQdB0isXr9+ZRa4sREQKpNPwxTQePYb4oRd+7h59A9fG8Zf4EbOx8HCa8UVyG/Z0wJhvpcJYgeFIfhCyqnk6AREFgKh6fnECZVDpUaRdqQ5Mjar0It+M1JnQH9n+Hoz2OUC051T65GgHUJflYXWyasdsIEmnS2VnVOu6XMAveW9ujGUG2W3B8HJTdWQuJUNJ6Uzg27v5KgdhriINcdqkk50xODvvGoplQSY02P9HEeYEUDP+qj6hrOPT/KJGHIwlKTKKDX4wkrKMpE7FMu+sV60WutQyi/9Ed8z2VK3Fz72GkH3k6OL9+nbfb5soPY1Kevb0t84Vz00Vgto+eHpKnN551nMD3ImU+UGEf9VLsqJp/OwNJ7VlDPXVP0Zd/cQ63KCPHC0SvXCGqOOsczFonvbesNxN0O1QBJN9w1ku6bYM/nJhnp4PKrAogQwz0YbJibBkcnxrS0PFgn8xOf2ZiZjDK/1+6DsyaYxk6h+b+INE2x2N0/XjKfxSQMgrj8dbZIoEtS+QFFl3BrAPj89SWBqANpmCD5/xCrnyK92gJOjCopajbeqAzLa8UvEtqbyksufZr/RDMQGDf9+7Wak0KTKihtDQpIeJDM+CrBPDyFaOKT/P7EhJtp3R6/iCModIWsCdNSmk8PcHjxH7PvC/As3Vj5UkNMhFd9tnPnb7eZbWbL6U9e9ct4QI2FIhamnspFX6hvVn/61nA6KIhqd2vJYqhJj0NEzHgFklHNPSqwnlipS61EHtg3bhkjwU28zvogPZxXNEP3CFvH+sX81+UPs4e8uIG2dL6vOX1I8oACEIRALM3BKrPCsNAIWuxnngFlLIG94JqpAc3HCxpITfXnZoBXm7mfH3Ul/t0m8AYErXhINf98X+BSAWf+oOFz2a7HnGHFkSpMtzYtdWV6UoSfpB758SqtuC2vvT9g/WqB9pR7UPEYYF6fPhK48QRaCTiBv7jCk65vT3+4NJoWNmp78aZ62IVetpfCy+7ZMejE4od5I5c35eCsL8R5Ls8YtJIsbdndCThgwS8gvebdSSO1kT/GWFxFY9RCQzksowqyquS1st5XPptlJMj6chg30Pn7BZVWG2rsea6ZNYrwKpmuVGKhXaZgxdPcF7VaxjS2GHrHxPlsSa5Cc4DVhErs8ZitSC3o2c5jAMIx6SBMA599FFaCQvdqx+mLIGg3w4IBmK4sVwtmdyDmJ5Y8LjHOOt5/wT8r+DROtJWQXxD+bZ5hc21ONtm6+g1ddLafwTTj0DTwL5y8nhCef7w2TR/prhqa64wa7RHddgemLgn9K2HprR6KdYJDC8MWwBfymjLU6NnZvDcAhyUo6OSaRSXF1pZ46AZNopjl0c+iv8hLVlEu0McRe62ik13ZucrNPODeR65lfRhnj4O524FnGh2gATSe58TQ0HtobNDEDwL/6MbU02wGrufiwm6LrevSLKDeRpav+3KgZb89QO+TWEoUEpsZupcZGDCdltlAfUfBKG8JBixa6WSfAvg14C0EhmiPgtIW+nV4nJdqnJt9cWgj/Dk/x97nhLzgF4ywoiZ9sczRzl0lgQC53ZbmAgcODR4KZNwmsbrUOZcEWO7c3lSCMvQRtaAqGk2bQcA0+GFYtvUroJa/bnx0fn/SE3dSj+a+QKyIFxvgoCuVAdxWEW1U0IIT0fwvpGGBPHkDZGDYqUa+f0kVjKNt+LplyRUf2cJYfRyHmjN/F+nIzBfoYnqYKpncGzgufMQpRh0tD4mYBzjo+egXym6j5n6magye+nerQ4u2qqFXUo8zLpjX5UhOpm3Nrm78/mtOgdGTiQBvTA3qDXc+HigYUAOohrRzUzAeyveuVsnLhsy8YUo5efcIBq9uk5/xF84+1xic8ojxhbYdRj64wXNeDkP58Ewf8JHjX1hO2/7Z87fSf22DptcdV3xzFcbRxEH3ZQJqkaxx1Z0DdM48beT4v9i3sGhKIMnDs2DvcJKV0I+3kUVV4fdtEjhyY4rHNA+HwzXoiWgv9ko1xwx/0j3LeqzUBLHVpTF73ogJQZ0X0tIsSG0UaD03UtGdBEy56k4r99NugUBALboibMq7I8qUPe9v+U9KwrWljX+WBLf6pfG6+nJG2DUrHkYwo7pYcuCVGmoZ45pNl60nBZtIgIfQWFwTPOnpUZ5pJXDAbd/IrkaHHNZT2UZ5Bx+vWAqmAjJaauI1gBD7RxGyvWycmubgOyT8BR8oMCnFQx6CrKxThewUVdvfIG1l3mfxxx6goppERBQj5wgX4NTObTyL2lNUbR9RwjjXyGvPk+/GBjEROM5VI9jBWcWFmMJgiY2zabZLV0lV6OMVMcP6gdfbfbc6ppN4Jd4zYJMbY3zsAo+oDe3qthvy/os/i/oiwfp7rpGa8Gk7gREU0KdmgJ7nNs+tBvynJxNmWW4Z5gKUWllM1KjaoCPsWv+6l8kRGf+N8yTz/3RC/gcQxwakUnxLX7Wf2SI7/QaZQkafJc4011FQ12O2TuA24e291cmrhU/3Hnl6aLUoOojGIQMJL4UHDsjQ60jBb60mGDQtLkju/PjWU8MF5WITjP2WpS+L+akdrmowbKHnuY+bgtN5E3TYwPnqT80AsK8pMJ0mmVUHLJOhxmxugRC+H8AKCifPRrzqBFQxketkpTG4XQfA8uGAQyA1h4OR8OJck/oMgIrRYH8fqYoaVaZiaMzevCahr7hBJjFAvBCLyD9vWhd8qL/Z74yUACJ5Fqmu9ViGEJfTxci7QRaMwSCREyZO6WUadeUC+UvYSq6VzNnEV68diTILyZkPUJ7KzOtEOcmgDGhRN02FY7aUad0x8z2TK5RRHXNFmXhd8gYuMLE8lzh8pQWcB6E8y+doQjBsgI3NhzvyX618pVZwlKrpTJgIFGNkWv6Egz2dGT5kz50cc8rx3OGiRsIcCTSW7cWXwyyKooRVdyMexa8QDEdQk6PRnI7yBzd0PubUZ3aSzVWJ+m3QpMpB1XC0vOgpqZ02330h4kdJR6UPLF0i7EVRYW5RaGZvyIIpd8NwMmioxZyaAN0kJlTo2GJsSwYHKPS83WdJcMeZ46l5VZjwSGFK1vJ8ShD90uYI4If7fSJ0bvck4yghM41sHQlI2bwA+k1MvP8oxYF5lWIeNCu5lxvvjKxrZ1zOPpgS2uzOz4uug7lhmFxCQ/4vILrctVTzNb2UMOHBGk97tLFP0EIX2yZmw/epQsv+L+IfQ9DsgV1xgjB6DEEAbmCq3LO/qHjV9shPCZcAx0IN/dQpx0BgBYf2/uf0skBgvWgXYigRu9k9yJUlwnjLO8ZAtvM9wKNZHtvljDp+J9hQcF6wT63bD5QclEVXmUsQjh1xtudH9BU6xYWERF0Vk36eJOXqaAhZrlUA+9HPsYfJy/79vDgNole6thH2q2QUiJeawQPVV1OU6MgHvuOB0hz4bBm6v/v51givzo/21s3SXEEvPVuTc4pwmXDW9MN1zV3h6ZvyWfWfTQm2h5nDJm4i7wdQloNcqKeIzr9uJwotIDznfuBpSKQp1eCKC8tSL/j9rcl3CECbmAso+9l1ahsLqqlmiK+rrwGSsTyAKMD7EEZ4qDNscOoN22MxyD4RCeTWha+NEuJDdQwL+s1KrmwDoa7CecmIG6JdXeDXcDZjT5S7bvqWSD09yOtMC/W3zK3vg7K6ZgUt7tPgTGpTBEDbRX8xQ9ZqzlFtgGvmlaFKeKLfjZEboLExumXj+DmU/e4S4J5jZ2y+dUGHIi4B6eTL1QSPxMVvoEjhd9JP4qEXLipNZQ2l84bcnQJ36EL47R15H6ZbxtEkRAnEmmCW0manUo06nUvyvt4yTJBpUGIt6n+ctgBB7Xf7Txg6RRhwc8vSJzPnmlhfXZHd0zcyE4rFJJ0hf0I8w8XhbhmMJOP3xbaCS7IV912W8frddjVSZPLfRoPkkuXVxarZ/d1B56dURfSibolrBUwjzUk6UYyXD4nWLGCcWvnnFUN9GP9fJYd8cs+ckp+s18qeufpmNGx4ptkmvt9KQWV/sETdt7scSlaw3ykugvEEQ98NeKZHsW1M3d9bRZSvATQVQbSNeKEPVpfvog3RKp9YIHUimKP9eOd66sRWrC+Od8AYJ1gk/o+sTIVf1jJlxM/23cSDTwGEFeMovtxB+lWt7xjClPvml+b0bhDYXV6dEErP/lgNFxhShk+bTVUqfWJoXq2Dr4+x3OBtPV59zxnLujETFbPQH+Dc6QkX1J3rzlNZCAJLIwJ1w71YxCWzNMIboD0139Gg0W/NT3aKsTJjBDNW62KR5wy7GlkNGqVBCAw7+OKdWoeuS9W2K9nm0Dq+m7GdCwR2d/Hm0DUuNQuVI+RmYQVbYXOURtJ982oNmZGiZzdmm0zhGnMkxS2Gdt0nmjgqICvNda0aJkuIQ4T7PYCumh4lB2xnW7eM0OUvfny6yKztmskLNbfzW/IkZe9RxjUpnYgm0dg0wD0t/HWJr37s7d72CTiH83MeBNLH0UVQ24FkOhQR+T2IdO0a7lk9i1Hxhkg3iNfpBIAV2z5OnscG+j0dHKTI2hrWECCSbQjDVKWUUNn+8bIjfuOAwysqHIqXY3TkOm9Y8N1rBpj23p+fjJRHju4SSzF1gwH5AlPpXvc7Ssyp9wiBEH72kxoYiWTH0lOr8MHKW3X8RA02fBniGC37a20A+swLN7x6sWVIKCFVK0UXQ+N95TGj7i/qIZBDrF40yqYZvC+qKIcxoYzsIdPMmAq3tMOGP0EbCedZ9rBQPBC5qWZ1g1Q72cja0fbm3uL6HAjr9rZ9JaRnngoqlDtV9cwzaHQbB7E1GhCcgA1v2ekf0dY1LtFieb2Fp0MCURTxZmfMhavxVkJhOCJmkOUut28ZXgJknKoFipnSVjsforIgocp8tFB7WKI9MWIsYHXlhoTtqB/GtvK0WHqYmH2GvE7iYKmcZlT+ZDLp7j9jFz8WEh6WYGo85bfL2Q7fC5l+3kqimKEmKjM9z3mDtApDBGvfwLNMG0iRSW/UnLtDTFAOznvZnutEBFcmz4CDCkD+bFPhrD3Sl/am+VnrK69GQraTsiabG26jnEwuYPDs3+YybglyrskAx1heYljOyGC7/nswOVCUIye1YwXSE2Blz+gqIPxk1f1gfuzFUu6wCgyqdzEoc+Kxk0jQWvSdZJ8P9GPE95+qF6lvPbgArHF0Rp+uX8EWrTqNdO6Auw1L5k2Hk1NOs7rlV/pytQnPf4A8sD8HVfanGPFEGVb91WJLZstbUcEdZUYs7uJ8u3VztZsXQUG7j8FuFd3a6raZuqadb84VzhTyv+uic/Aqh7qkM31s4EzoBHqZC0AUDiBuCM39Ob9D3I8NhItxx1JJlBOOI7xwg1rqp1iX1+PeNy0Uq0V/Ma5STTOiH/0ipdG0LuIXspgsMHpf7Va11bCULwYW8yaN3/b0Pu9f+ae+eep/n9/LFDV1MSNIAqGZxEjQ3j0jgi1Z/JIYS+JPPajmCUPtMFj2AFIQSmYrZabTDBdjzyqdTb5Y99iJgJOVOi5hR7F2zmrZGIdvUG+u25X4VQcwFFFZ7hcI3+z3I3Qx0WWWEgnBvk1wPs96LSy0vIIHsiZTA3dmGyAomvP4uJDPZe9D9CRc78CUCRDMEX/R7p757psw6l+SMLUErxrOsxAinTuVMGHeQkom65KAbsCq5uPSvlUHmhgAJdHpuIhb1IYKna8f43mNwnv4XnsUCH6QjBq5U1oiMFOrAxObP+3U9R1NJnz6gfrb3z+1yc9keM0Kqi6KFPk8+up9HadUCkOc1rKnb0MkQMs2u6a7yHdu/IvJLPmJROE3V72m1oPqmNFK0buEURtY7AYjL3UFBWnbcDewttTLLd5p06dP9gQbZoj55iIAn1Ys+vPTjhv6PeNTPu7laK1hmdSu77svUjsUYCNAbkN46u3eE261PTh4s84B+Mx5PMqVTMJm9mMykEIT1PXh1rgqngl7b9Dfdxb2lq82Qwo7B+jHfc8uCdkTyXnoex/8RP+yFPpmS/xChXMJU/w7jmbYZbIXcRzRtP6PiIxaLY4wrAqmMVNtuqVj7djUpBWnSVsyLAxzBV1LQqfMnyXZtgSVhUpg5Pt2HmMbImD6jlTtoj6NhuAc6xonwFlb87OFRGdQKtkQ0wN3piE9TchhuGtm6iWOjcCHh2xYhZ2z/VcDTsoxFmsScJ+tZyClX2yHCcEPCYoD2wr3k9kqYufqXkowrbhjAdwPPHfozYKjscssbSkiMaArDkniLIIzkbw3nhM0Po9BHVEh+rvO/v7cPm4S7gRgZUFQXWtc5LSp5nbJK2zfmdOUZT19wi/BHfVPYEWCJoRA3KrOHMCTn3HPWMUBR6l2t/o2PoRKcZNVxMX3KWaOLLxexbxE2xW+KF7e86Gdno92kXeikWpCM7TaU+UxK0teIHOeP2XYEfK7y97soB5e6BP2m4xdQnDjKgyac+a9LvXcf41kW37HqSu9XZHhIlgFidkTLCrAnjt+ON7iQG1PCAOS/WFYPMKsa61u1J0P/CRcoltR5Z+Rb3oNyawFuxJ2oVHsDht+P536GwOkyKaKucH4Xuu+ATJ91CiBjWEMpIvYQ44ljAMc4XmaqrhZYNDUhA+XiRn9ePsn9b+Ljx+3UBoDE+LlGhQzqjLfIWmbX3CLaamZUkzwbs2aQSB1S9ChU5EnrjbxDZ5VLYJv80Xhbw0kXVQEB3tk7/wfBYDc97BSpkw/qpawIWIGuBHC3SPA2Dhk3iu7pj6jDbwNKvPmbR9ZrrIvCsPf5Whp6VQh0X6awtW4XcgVaR9rFYo8z8M+GVfPaqrKRcBSYmZuaQjk8ZZPdqnUqEbZmQdsJUsEyzehB0fmTajDb/4DdIbsvfyZOXJxrnTfFpW1TlUKQ1iLpjIFua+Sl677iezAtofEzH4FLnAlU2+f6iytEgQRle9cbo5G6LB+JXEj+fK7k4D4fE7CGyCvluJUWuV7sR3cObUQyVn0nsuUrO+XCzmrOD7Tz15WBrjyU76xtvg7gJD++3semEM93ME4Vd7LjU9h1f+XlMJaCtZ0e0uJ7VY0+GXiWo+aK4oIE5QQ4OlZy/KYfnKiU51teGSj6TIpUrw+HSphlb/oXatSZeJZJOxaC1tKTPfxua7+ahZHwL1IvjnLhbX6KwyBLHfScOmdUneE/1tFqAkvuBA/iyYu3Z2xUQ+nov5rfbgFGtEpOSciI7GefkUdVM3qPTtU8QwBTBGMuN72kyT/6/UGHSJ6Dv65TcXL6uICpf30s3nhQLq2fVcfxqm1t7Kgik3FpTdo1hpO0f1UkYrk8dTvui6U0UyHP4h1u7sLtmI5KkzJmaUKq+4WnbErLw4fa6YtqI0JNT7v3HZqjqoH4RAq9itddECJMXQDxoi6Gj6IvAEt9cUa99F/AUHUsXlpCBaYSrStbqNQ/+icoPw2vaL+SCoknYINE/6Pk13gpAbiOD+b8+SEaGJf3a9PImE6QTvQIGDUkjVGfwJbcRlfdjRQfNXy0pJD/TsUY4GbLjOwv/AWYfgijsnIpKPybbq3FYvYBRXq6LghOeV4CtaeA1mdu5a1f0ANo54jZoU+dDs3rwEzQu+JUFARuJZ+xgBMvl632h6YX+wkHOYSDs96Xyz7NStI9paa418jKXw7Z7GwBri1b3to6K+PBzrR7hHt9MEKjeG7hqWVjIhX7vUd9WuQ9EpUwBNMmcnU9LScm9eh93P/laWQHeObJPIcfVbRA3V6Dbntt0+VwbmyX7UUKR8zzNZ4vdwxniwlwTGeKrMyyTyj/3+Zd2DUFDcbqU6CT9N1wVR/sIQpTncGW9kGyfkhiwchkXbDpd/b05Uz/ui/H/e1GhFmq9cD2PnGbcn6R8TVcwc2bvZv+pCiHAHOLpNbjS2gkt+f1kfAZWqTAqZluLoUGUQfCw0OgLAXVyEnkN9dW6N7UvCIRJqgh/XmuNFv+pzOsJ/oRT9BHAkiOHfjBqx/RS9KQiUbpyBrkZKEj9l7LoooqM5ZqgQ3mYbH5aaeYmFTWLN5npxsqGcFyJeQYvgNNNNYSDdUqFlyGYUgGHwmTMn6qKsX82syXVJnD0/81N4u0Z47J7HZeqQYe6MNZjclFnL8XCj/mQcuBH6HvsywKSPHdSYF+oQDXYoBCAaPB9yOqiAVUJF6LOfG4UaU2ZefeLXr8cMpFPChA9U6L+We+gacsRNaoVvHRaPDx3gYzx6o/QBXRIsloNOHg8BsNLo2TwM1uW1ENiLg+vrudUIDVOcCN1Urt8n+ciXqN0W+jG2FR0ZfaRdW/pyDXJ3Ke/TVQEXNDSNcX1tMZvCJiPS+e9H+D+TQ/e0fZzEV0JVijCjDanG28XI2E1aampj6gHE9kSvcnBTDYiXJ0/NKpFnH3BPJkpWrckFdwUhSPShS3D/GLroa/nVqnd0OQ5hugIPiJh5TpEloa39rvtF2JExAok8QwEngmEOsHTZJMWa1P06ehZeg8Y0fybmo2J5QIuGuDRmYjC+WMvCitl1jBZKF1ZtSOscmLR+DfgW5qiN6k+FWBBygSWHMRZ5uO9MyKfsO+abQLY61v4SwmpnNwFcrqIdRBANKjF1xD+WmsK3GoUTAdNF7dLl4GufSXoP7Ojc3cY7TIqze3BUI92Jk+K08E5VJVmoMJ1GHrb9Kl5sEX2BlTwQasTxfoYyEU/M1WMkjIPUdXMi5O1/r9OSwKQmvUnJTNM1D5LndNld3oP97apabWQh2555eU8h5N5xMQGH3p35UpPRgaKkew42sqEx1+sd7URZg34JW4PPyF42Y8fJqPvvuEZUORBo/+qiOeMuGKsrFBJHyzpPzaxEVaYR2uADmzJHk5kz7TG/IWJUmrzOezsW7Olzxx1d3LOy/YvUYIzD0aBiTYxJwqLs2SkI6J3rNSbY9rYNgp48egoT9uWRlo/Cf2REJNf4hHNuJBwhuPSAD3Nu7hkxcy/v8ntZET2OAz1e0p4KoNnwM+SOkgA6sX1YY4WfHkjTyIZhjVo/53hk/lAckr6GNYDIVo3FdKfPixThAM4PLp0mCtdCl0iZqW3jFZpx3uEYpNAo4DXt+jMgWKbJpq9DfyRhCIz/iRLvcqgMWpEzXwnyo3eC31eIGZtJEzwtDxITVGzJMJcDJBeBavogRKYOA31hM+7gnBs7xV7FYvSeVLdsi9q+f1HaCjKXc9jh+cyKXiO1kIPBI8D1aRB9FLitCWYNTOERvEU6SZ8p4LT17ecCPhoFPuhpe3gukCLofuoaCVDB4OpysbPBXBNJFePC/PuiQ58D/3Qo/+tvB/lVgvbF18wxtygj6sLh4eqAgdkb2NouRecGYIETCC+oLDpdpmKUYgIemvXV3nCTskNpU/QlVNxV5THoxFh4RkUo8bqL5lLnsV+o7lHFA/4Zp9y84xNo22h8G1koctVcOgwywwwTci8pHzWAKdMXm2uG8d1wzGDC1Euh5qYDW1Z6QMNDa09eaZ3v9hNnW7THlyerwzJ16xiG38j0FdVlbDYj/PaHz2kNg/YOpWFsoo/YtdD10oFiUSPXN2CEJkpvBNkigOdhLZPwuum0DkZquwK2MiW+BvFefTNqx66KtZspwt0DmymvJReFMcCIYHS9CC4z9jouikmn01ICiQ6k7lcGK9Qf3Oaei59hPouxlIIPSWpyQzwgkFj1Gn0pTjsJhlQNnFjvqf+ZGJ/OMNZt6cam+qlvdAcHh1QdnsVI4/ok0Okboks8H6ob+yhv+sc2gTP81H9M30OLHZwdxBGBfCVWMr5qycF5hWBaY28E7HI4bG0lZCPLm7UzGumGGXymZ9QF2CrzWiPpr9NO9hjCcWjXZ2b9I37a3ncFoTndb1wCWXcVFZbNFYO5bZ52eN+jvf2yNa4hYjwj4+AZRagY9UOi44nENhuJzEK+vKtiSlD+7V0CubBQHlxUa6+vYbNNJaY8SsmzMkoLMNUs42zTGz8bAelk4sjPwrb/eW06eKc/R9D5tg2cs8MPa3LlscVSCR+AHIGuHPuG64xzw1SeD/xVJApTZtykJTvNVqq1NcVIfpVGh8pCVzT+qAVj+B2cgK7wI9PoC9Pn3I1zWlBjFJUTwrszVZhM+pGfnqmuYtQFIx0dhDbZQNasxNyhVzav6y+P7KKWSRw6UO7j2E+Azc+yZiXwh2bZOcbwv8PJNull3gh8SkPS07J15X68jVQYTKUY4FFAQ96RIqazEA5YNfOF0jmaCWKtGwXzYVTb0ly6T5jK/ny68ydj9RtwdqaM1fhGTrqlyDqu+PIJPZDEgulqDlpA7tfcAxZ+PnFqhcnAA9Jn1ujc0GFSnyhdbUJ60OQlOTqnNY1z7VwPvqJuP2o2qyooen5epxHWvM93k1C64ODkDJ9RXkPf098kP5hBqhRLcNbC2dKmMwwNnRo1C3idt+ZcqTds7d+8sDwoM2b+6SdDMCUCLcoIugIpU0hdPFctjasr8GG/C8GLWeRV49pqLAG1JOrKLRUQTprtvluyG0fAP/iobHzJFJ0qi75oxPqrzdhm+v+uIQ4w7nr+QwVYfgkFILFzwItwJT9RVYBewXP5gGCotIXSkvGE/uXE2ooBzxaB+X1T/zW6G1JGwkW3NzfmJ2/9i34wdZL7UrPLywAHv9Tarv/sac3jeRC+A16fW84rpj+WHF7p90uZN09BXvgzKtNdi5AN31fo6PSPc+uyVx+F4N5yFD6IXfJVwybXzAvqxEApaGM+nMV8nfgiM4kEJLlMZdw49iA4ZlwPHuFNjB8Gi8E6x0sO9kyM2mlfrw4VRmFYFGV2yxKwWLjcu//z6zQp554176jLvux1WPKrgrFT+3WXQwr6azZgoJGdF1KzbV/TqQyYhr9euDujoLTOCmhfwMie5bGDG9Z4wwO+4cvDgUXvd/Ii8AOPoZqWXHvrW8pi1IqE0GcrylavRuXjRZ0ZlkNAo0KbMBM3smR8F/Yz6x3wRbPau61xFocJqoSdXH3rlvEpsVu9o1uTnUWGqT8LzF/fckYkpRBQfTLiBC5ANjsTzwmX/TgnKlNRnNh1um91vaPqduK91J+7kJ9fk9hETHZa9gFWMSR+a10pFo0VuZYBg1iWTsFvA+zFetxsHTt9ScQOeQMGExcmnx4RvWC7vgpUi0vBLQFBHl6+/pDc+YWuEl6bQDc5g9JnqvHqbzBXbI+vo78LZNssjutqOzy3hW8fLsdaaBzMLw8fb1Yy7imlbkmCqmikz5F2qy2U8F2Z36iPOwDxP4V/oz2zrMxbDruyqu3Uu8rBf+JaIHkcqOzHZOywohUt1JfwsgieLYzAese4jYBLe0lzO1LP53WU2/G4kHPljxzkBZjFJCSBZ5Yz/uKVCIRbk1hbC0/GK5dT7/v+3ghFerwRQP+wTmy7VoUE4jiXuLye/8MTLOCbTslIETOIwCbP5NaPOLHRPr61oJKplCZccFTNjZMt80DX/xlzqUeLWwzqCtmnsJ0QiT/GUcvEXYRz6J9Bfk3buAoOGKPwfJavrBPz62SbULQhg9IMfYV29rv2nnXS4s+M+50JRugHUit3C0MUX+XawB5Wbyyuf7Ic0ZgCv4ZqhVZv0Y1XQRJoIjMnrVtt4PeXl+HLQ/BLPvMxpNAk47rJhIbmMxCx2zMVvNvskU/ZtMteaDkpRK4iDELAEsXOSpvpIrQpx7YZ8szktqnijSBqsLzRqNJL4iZ/3IfSQHXuNQ0wiV40SU9zijOrNCl8TXBjObP03N6l6U/pmPuIsbBqJ1iNv8/qkDhH0CXpwGOCKTy/3wdgL5ZTv7Wa/9Z83PPmRykMc1xVoypSAVa/QKdP+2zv+vG51kQ0+P/ZTVwz3qC4vZpZBlXaZFpKoM1bJhOZJ4C8kfuWOiU80cYnNN7LnXPAX4Ay8hxNUmF7lry6dFWgDg+csJ/NSwA9iho5GGYCsQVfqoTw7LDBY6F0rANuY8BFYn473YAdIVc81sbB7sjMRc1tCmZ/kN2mRn5yhNzATPns8Tm8Nxhj37w/Gnce+QDKN+4G3psvnzUf73bxSIg+SIg59yKaE5MLQftXC5WXBYK8RY70s42C/iKN4lc2R9CMHh2MgLfmzB8hLyrQhz2XIR5na9EkKbWU8lsV7p3T47rw0XaXqeJqLPgSBft+zkqjLTHVfA7nR7EtZVUnrJ/vUJlBzPJ6t8XwWtZ25FkfHhBvrNqGbTs5LcTR7OcFcSSDh6Ref4VmbKVpBCYIIEt75XZQ/Va7L68neMH/v2RaW5a3vZl9spIFS6FIEh13geq5ZR6wAY3FwpRmF7Q3Y6C/Dk9JTY0JwEdjwi1B0Gy98OqOK4iQ0/g93dDFljyLMcN3xaXbDE5dES9VX4hd9Vm3l4j99tfLAJaQfW87mjDI3Os5U2wSe6j42jcExHQO6l+MbR8E4wvUKx8Yb9fXrFXu469YonhQPlurKFpUXEP+ykJom89LJsEE2m98hyy1jdN5xmy8BAWgB7Dzra80eN6BCe0YI48QR6mTtHMVIPVYBeOa6bGqGO9fSQ7Rp9jV1E/jymFCC8mYtDHY16LcnY8yXawTPgjLvqS20R/ZbWev2jClblohQ/9W5YBFDH3I6Lil6vQrzgrnLE43GHZKUD2PUrR/HxvVke5Qma6MAnwuXs/HqmgzLEpBsA5zkICRqMwY39UvbQEeIsQq3n61DSrf+rU21kE8IWHCvOSGInghFXo3Oiv+aEKBOnl0OU9shSGsADDbqRHTrXP9HXa2SHyxW+XRkxcoxNsdW5JPeHqzm8a3Cr5emqXJDpLWFslggdcvWGOr9TKpCAiem+TnROeCgWTdXkH9G770X+N9PJ6Tdbe1NXHhu+svkBRrUwlReN5syOJ2O5Q9kA0BP8TEAvyyhSSDRWJL6ezkRFZ2j5mPwD00+HQZtnjH4KrGfi76HRv+KCBr2IWBiR5wH6BVUDGmRhOTOBdwFfUqIt1ZVmuLRkdkVCgs9Nwp516hz38vH9AdW2kPaG1PPhBMxcKeAD2IlPBitcQChRlmuNttXK4DG3dNaRcMzqNAjnHG3pYmFiYsXKHv2/061nVNljtBYr2GdSC6/pIOidubFj6+iVJQMH1jBLfGDux0ju3i0pQZ60LEjumdlPlZYTrLlsHlAMz7onLJ0STxeMTIZ3GEnQx0kdDGzriptb/pV32GQAuW3jR2lMYtnicn9YCjtOqniRlzyGTDmMd+fiplZfk3nZS8BkEP33S0J3yXVvfmeMw7j4Z17YGkeLlON9sExld66xhoSYpXJgh8dAwJCustdahJewxJ/96abkqPZUtYnIWW7HJiuXTFZBAgM+x7ihUxyUoJYwRxXHzgzzVhqO2HVYc5pYE5oLCEOoxKtohbTjW3kyqK2bdKLyZu7kawt4VNgjjArFG9vWOiMGI7nv5M6Fx1lABA2BC8asu7fLvS5CDkL8rtsj0LJGxhdxiG86m2WcC8DW2BMKtjqM7KoDaooL91Csr+rKWAHTRk6HRmfxi+l96xzMKNOc6lXyeS8BI5KH4SAG4Hl0TETlfaJB/srUp3C9tRVafNUcqhivVmorN27gASyQrEgr7wtYzM6kWsVtBDd49fZsUP46/k0c6MNWeIGgASSbFrp9olafmFJPlpZFn1bR1E+2ydRieHS+d/Gy2BNYF7WkVYCF1fdVWdFAv6dnvUFfARBC3QEFhJCJ1KiHV043yYZaG8xbjegG1ZcmqLKSigWNEPV1fNAJ6L+OmzdHW4ChKMrcUbtdk4R52MQx5T0/SwtYmNterwPenO/QkQkBDkd5EHBB6ttdxw07p6+UmlQNPqrPjVDnmVhf0Hameg+4VbgkbphKk0KO4TC16ES3XYv+6WMTlQf+cp4Ec6pFUdfa9zCAxfLcX94qgH9qSpXDL0uTdJgjDskk/5jPhSy4/1k2BTUFMl0LsGUp4pnt9pgXKIUTdbwNC76iZ1JwP3NUmc5BaAMXURKgZm4qRveTniLcIG/qm+LSf90aIy2rKX/o+rcEZYYpb1i1/8coi5CGeekc5RIQqxnyGHdpxte4vVlD1rL85XsvP1Hf6kgwOtAKWUYt4R4RPLXbJDP5FyBVOtDXDar8zP4+du3W5u0VBxNwk7DhK2K1rbhd3y9NPw2kWRr2DAx5CK6EVLGJf8sFn30ZQdVHfLo/0s+8fqvllsOz6VQgztoFQ7uHxpcnDi+yiV0FkadqLmKzwyBMbJOhJfNC8uqS9GxBKva7ClpcK0havfdgVwKKLVwp+H4MNgtIiIz8OtQxgCYwb+nsqwTz2myvmUunfIwEd1EPdQsMIC+R3D7Ve9pWjBbpfqpPKdBZUpadxs2JXe5rJgShChSDAWbzfipjskIEr/DsmY9ucIJjw6Ui6jzyGnKcueCCPmmx/4fECCpuwS2S4rrLg4vOfJPTYw4k8hqXGV078a8NurirxgT+SrLfJAlMqMFYehQKhQ5xuPhJ/mR30wNufblBPdT+WTFZ+FmP89MddwYZg7CmIHgHhBCF2TnxwzyBkfEoPcvBu8LJ9OmJO3M1ZeI6u8La3XnbqdC6AQzpImk0RYK7fFM5iSdFMzHrohEWYsmV1oIkz211fntAUdI5DvrRQVQBkGX0omgvVkiwmTRwAicVF7CxDrrMIPJ3gj4nyFQZATbfpUevu3BiXXNCBdrQitlrSrK5wmI7lc6eQtRXj4wluY+K3nfEtVeRSDol8PXDunBZyzye0+0CHhkR9/1B3YZirMEoBsq3ll5U9HOnVKUQ6R+no5UhLgxMg/5Zx5sfYpqBIVQorCR0esLfucw/HdLnxo/rULAe1MtCGbnQe4DrFWx16bgoHgZ1OsMuSwI8giGwF8FMXjuiAdg6trxBgZpVDhZwMNjpvgPJHke6SjqI4wgQVmYUdRDEcGOAJKCNXuHqKGWTAl33oWjGJKPJjLgoQk8Zdedwt0WRDAM15RqCsASUOq5BQdamYmDF3BgFhrQhv/S/ip4fvbi7SgOW/4GwsRmkiOlPKEuVTHqFly4wlzDI8E6vYNOr9pcu2piNU14rqiGneAfO7I1TpssnjM430/afu0JtRI4/vGX1yfqFCplPdpvbD81B3f3gE3cblYVB85kWCVpkLAdxU4WaJ5oggYLtwpImffaYqzsj+wsVurhEgMcLPt+efJSMiMLC7Fhg9FqJ8ivTQ7prs5gxPO/DTJKdD1B35p9G7t/mA9eXa0WxKwrwURJUrk9HtikZumqQugESJhPBwarKbvm7R4AW6xxAylNpPk55yMVUSkz5j9HGC+8ADOqv/R1bEZeOUEEoiHx99vZAXo8cA29cfGvIn0piqjdWn3W44Gb7vFTEYbYG7sm0N6DKE06uxRl32yYdyf2euw/0qm6tUApyUB4Pegz9AF7d2CdcRrktzwihlLzjpjeCZZjbUGK+mS4l88FKJ2xFl+RRHldhWUyrKBTHgQokGhf2hPrMHDkARMpytXePC3Pz1LAcpIxiy1kOx0aGF9JOrD9zpST2uUZalNgo/5ZNhayMzkDUsJmdDCsFVtBeTarQc+OqxxhH8DRu6y+1X09G1Lmr/QdNpcsqbloQuVk7ZvwYcOOgzLiIEFzHZK8zApK9OPFWL8YyT/pp/+0SLWnP6CVJghjml5uCNtF3hLmPMMo3Vn0C/rUAiCW+gPeYOC3u/mJDqbuZIVXLIgRBhY6ejMHRkJgChQPq1kOTKNbkVtnABPv/Hr8W+YfqUaE6bmnSqnPvK4nZ2gMlr705N8t+Dh5tA9i2ymeZjijpMZ/w+LE//gV+hjgwgjJa8TCWtRJFWNonIpg8Xlja3SHkkxwsaDjwzB/KIDGtwLORaY/2Of3CVLeRABErHZAqD4+ChESxNGb2DvZtfhlnOjDo7794N836skYoZZPxeF5bFuCv/0wlfsuyAZH8eMcDMJb9LaS8WtAg8YfM/xpERnABThSmAHF9BgeHNBLGH4ZPH/OUxrZJD/iLUReE5WE4MUTIHIXfNxdDXqhPbb98fR7tu2EgFwZwyXlTMZft0mZ3PEma55xWPsRHuq3BCcvwlqb1U55nosaZ/LJd2k3ikT0TMAMryFsBIA3GZ27MK5VAm+mG9+72/uUX7VOpfPfleAOAZoBZSQXJlscxj6g4ZvK6db5n8Tjx3blqO++81BrjAY51VCOzEFEt1YVkCbVwFHhlrOe57Od222xS0sH+9MZhV+TcwjZolvtr3Oj1jxC3QhCQU0x89j9HcNpqp1WNZ/pszKRbOtaUHvY+h6hFLbJgzhj3TxctxNs7LM2PPdZE+JZirgIvRHtAUURq6KoUaFnwnZox/yz+7zIRSDCjrIXTqRcwJgayEYcgwdQC+i/jsoZO8Bij2UvndUp8W/ErV0YzHbBuIfGgb9AiM7mMzzmhzLJjPRE9yPydY3XIscHf2RalcbqEJXHixHEdBKnN/oIM/81ojiFhhzR35O2p2TRd1h6VUQUXnJ7D5RRam4oq2CJctZ7H7oPy8Uss3UA6mp/N8C5asc4eEGrwHr5ZfNRIEmHhwnkbAL4pe/AIDt4tpswRLmipLpkBx1mp7+XVX0fF/FlptWHd1M9EXm1fZGlyoDgrwNACaaUd/tqolxa7L6qGL+4ZbIa6HjGj9V7IGZyMdPdXL6C77lY8X7gIE6HfZdyia847Lr0u+1JK6bZTL3oXrPSBNPylBrt2bAzBpn4FyFa1NcMwKdFZBq7DvipmuYnGt+HQp+0Y7oS6zuBSX+hHR7boc9gmcEFvbrqxHmsL6B3VIzFD+RYM8w89ZRbKT4idCDhRXHhVrVkOXgAofPKd9tqNekHhdt8AaqbLXotghYA9Lg3oxtlyEDfwDNCw5tPtNZK70j3bEfGpaRHxSvevsFwKYwjkRXCuOOdgO1nd1Kcvv1kENUyQHs5BrUjws+crETttz8wTfQdVhjiQCk74h373GJkzH4g5rwhZikwpCjDL0TRSGeKE7K77PFVB0ud43ucXJIdRmkJn1xRJDnff8KPwoU+o7k7C86gxo+m29uIhOxZqpda25uIEZyhx5hFOhqG0h5bWOfORR9zrwMtQXqqTNe9+ZQ1S4Lde8GPsRcbue2R+mfFws8geDD82S/7nVIDZUkVxriOheKURH+q81RQjOLIBRV/oIOTbV1tLY8yHEz8F2kDMvLbBom3SDpAE0zad4i328ImZNHafc4yD7MS41UQHp7HxIJjKB0Q1XdWy7mwTiMY1GNEgU9iE/vfme/36iIojHxb5kmVTrSISNpw05wd++PdwBLABb845whkXyWuONBtg76xyAuUxUmYAm4ERp1hw/DuWRD4fPo2y7Ddfgto7SqwOZk7ODEtPkBPdJVAB+0amsIAlMvZmYPCW25kWtwB3pQTYhPhv2lvVnlcn1aDex6NkBEQvpATYWbqilxOQyI02IIJARS+ytTn1Ccn04UjBtN7ej81mv58AMEXW6S3IyVwB5E7vLTnLf582jWiELKGE8Y6FWT9tjP7ryaIkvj5ZUCfe9sMXMHQI5coZvSU8S4GRbzY8t164kNieP78I7apMRtGuB/2CX/WUHBTXp7YZFyao6v8AwBlA9qQh4BecnOB8mt7Pj9J3OrwJ6KZOoT51z8BkLzCqgC0IVbC91Q6ljpv3P5N5jmzEU4aA60MMrNqh9Fel5v5Q8ymeP5fY0fjbJjUvLxO3yidc+xy9YNjhsryQeNuDx8s5S1utvA8Fo8d6SwBx2CpZAbuS/pmMKp2RTmxDdv4EJiDlBLvinrswAXbNeEb4CSWHsZy/qLro2AI4fZfym1KEWkzuxaFwnRUmDQocsxIcmQr4oDOj2Oj7o0Oml759q15XBH63sqUOT9Bn2fe2IVeGSLSh24sP6YyvHtI8yx8drwX/Ly7R/iM8M4k7AAh0NbpKUODY1EhHHdwT0xd1J/c4qvVJvUtYLUBDrgnJBb2VBt5c9uavu2GEUljrKydDsTctRscFq/vCnrRbAPakZYmpFOSDiWxmgJXGobV1A3Fk3szTQwx5QaTzwEBLhPCwdOwkH6u/b2SK4X9wwOeGrSOB9IZT8F2N5KCP/RQvima+HeyaSfD+zlxKNBwLm86RORYwf0iTXOea9q9V8dKxeTVEUw5ECgaP5mWXUQzvfguo2mBKj3yQqqIgv+n27LbvqGZJ2W5BoBU7+i+soVMzWF+OYtG1VnGvTTPeK+OaK1rCfoMFnpN6UGQuPSmAyg8HDowwFa3GzBkOrRPNjc9t7g+Uk0aBGu2ceoN44/kJzVDJk6G18D5cFrNVqpt18cDH2vXvZQnF57WM0NVbP1tvJ6hOVsuC5NleqLI9iLUw3pkFLbTslqjleuSxlKucE94I0VJ316cN3d+VpQfRC6F87bZh9AZ0gfWG9RX5X5uSLqHZ3UAD0Ix2lylL7lKIUw7CGLZKlvRj1m9hao8dSbATgeeN10h2VDg2RF7cqHtwMZ0CkemjqpL6ZIirER3awm85jNMjiNiGfeu4/G1DVUdlnVGxwbECpGgIz8EU8yA24UHt7t7PifdSSG9vG6/6XZAdhqWagJVbadiwWZzSma6KGLJbbdsMCA7ounC8AGmIzoAJSA9rXGRWSBL5i1NQpQhzjk1+14ZWTFl7PijbZ5rm3pD0X+oIJxdkZsS8bv8RWXeIhFXSAegkO82rDQn7iTBlnj18zbTVu/hAFpCEv0DlXYWrPA64SJ2/rZmFdY7g+coV/YHGZhMYvoH8CkZXaEgZGdEt6UnDA7Q8gEGxdpZn04gpDYI5Ld5pzdONKxhBXnF2/c3lvkm6xQHkDgxhChsCruRZ/nU3+0v22TBN+GpGo3skpP+Vk1JCyxgpUVQJ4PLkafdqyHnIor+2K9gAL9bah1jbQap2lquCHGq/6SMFArw2MJrFScKEVqeec/cE/iupxikzltxX2QdoC1VWu+xl0brX/rqhpIWhyuK6IFotPEYtim/TeQ3lVV2JdPszkP1mEbpqtKrSPdqDmPrHQbVf2qO0jRu7TxU6mSKZCHWR04E+81Kow3ptY706dtEJP2OQIBE9r5UU8jLlcne47XoklzOGLU1DkDFFH4lHM+kDN2aBdGztCY/s1Zv3bEC8Av500nbmu2izkhI6VuOq1UERQC5DFcpCnXQTbSZXcIvyOFnguc4uCWTGEttadW20nL8VMzOUJJK5omSQaome6vjKEL8o1RZaKxL6b6uZJRuEuE1PBMkpakx5I4VuX5iRr/KKrTXa4UFFSLq/Ykdv7QcXqTdsPxAVqchZnSfRw2JsUO8dwIJH+XdlGnA2A0/ntmSV+g6Pz/XmLpAeYf63zyBxW8jcRW2O54Cd4oM9w+8pu46OHPwrthVkSFU2cL2nP6DDPaMAwnK87ZjWy5jmv8VmDLSNUo71hJUV3c+wBC1LDJFNNpIQL84y/eTTt+3BbW1nILlvmu9LhVA+a6ctVnQCeP5BYSe3ujtD39LT7X8OZsCZGvll+BqO9JTqvLe2dXlreSr66VZ1QZgHsIugIy2pMlHsxAFznNsOUNA7jAyaZ3BTSYPDOtULdL16BUEJtzgu11UUYWFwiaLnUIhYZkQ7Io5gBPZMh56Je1ik235QlBBXs4D7y5iAqUn+f+bURpJCoTzrm4mFbtk9Mp0Ylhg/VJlXN3PJUBAyJhvNYgYhZQW4b6UsilNzV1k9MeUYakKtt4aHiXVvgLs0G5eIYTE2L84MVr9h9y2I1vFSRPgqQgfVPzeEKWh622Y3bXhaGK4QGNUkmhTEnKXew7IYLXLi7Ne9TJID3VFUReEiYcldnBPB90Jdloah3ymcLIUplW2834r48pRKBJNkCqguLgnbZULPNi2MzRFXTqNFPnrwc/uheLQ9mkhJCmQ1DbxQ593sGckIJHYn48SRT2wSzMKtv4GOZ9U65GxQdfZov6NwhVjGfCAwSvRYOTzFrHzZ2W9R6iZuZOAgdMsumbh/l/yKwS+A+Z0cb8t3ONJ7dCgoxvqqRgaX4SGcBx9eiE/yFSHYi5snnIFnZbuE3Mkek4q1PdcjFVWNN0OifEK2JH9GrR0ISmAdHHJzAZ9uV0LkAK8IqqzhHgiCBA7RcNpPn0eUbOo0Jjg0azqPcU8fcn7X553Cxvb8GyO+jmCSVocwvGngqBA/YMC7PaR8Q31J5IK/cuCShyYOE6pGEyw3E39/0H3br6KQC8hBeVZwvVFu1yOWXDvWKyW43RSJoxbNECtshtx+5ONdwm6uC9+t87wHjEvoKZEOeH4WzP3bvE+vyi8araamnFgh6bTFgZ54bnJkcpWggd59sjo6BjxgfHbbD/6q4zgwMlhjpEtaEYUQWWsydJIhp1yC+/g8EDv97YPniWOENq42zPdbiwUEJDWgY8Bm+1A/iExlBi+CxSei4+dD3X4qfcZo78bnATbVA/ePTphBH4lBG6FB4yh3ykbk4hgVLE1ef4llaIScTtbdQCz4DEX+hOLbaK0qjLi3AA2N5AiRlyi0uqIzVwTjsijKpAB62ag/bh006ozgvMd9D/FE1Xh3nKPErcqoLN4TxdP+4DfaJaGDFb8mM7KrRot1rSSwyoDwS5wQbFWolcoy68FBmcIkAnYV5Jr9Gsw0jCCXVMfpiEfF9o5hH5KBgP2HfIzG6vO0EHLD0FH3Bh4g7L9f5Na/aERhGt0+KtW0O2UW3kPCwVXr/FSOulpiQLF2iuDo8LRWehdCClvaaFTJn3hC9AKttcFSbUJL3Tyb75rGIO3s4zQjd6GFF3fsrk6tAJY4kU604jszce5dVnOES4Ar8vOhZXBC25R1GHgTu5asN1k9OMR+Gc5cCokV4BqdqvU7+oElHP41mAAlxJHoDDNLrMe/Qo28JU3eBho/tAIzggMjAmES94oK2MzIBp3f5E8qWj9rPU5whK121yb+WYTT8NicsWfunaO1rTJhKxr1q2BwKLPStnqa08eqGth6ARhHfYr0ll+OpzeXi/R1DGSV2HwsFu+LjOwT5D42+FGQ5lTqj71H1CHza+bLHAkAlNXEOjusExvgHBoozqxURlKjXwVuRkzF0q973XptccSAxyYpTR6tGhjgVw97l92iiZfUQB9U4N/sGhsKOeuVKp3sw0dhwuIQFmo/v/Nf1fWfreGbHUpItHKePleUCGQMh10thFLGZHs+p4W3BJW/Ip9SoBDnOJoSDXWg+hnK4Fi+vXZ2ZlLEzlY2pqXRn1vOdcNH3skZlOT0VX/+1vveB6qibV29xOUdJzDhYHaR21aV6FXcWVjqvCtqwvyAY9a5qf0vQTBNl0cwPQ2KWw/7yE6jjulHgQ51TPWJ4apJ4YNjfb9whfgSkuUZgeuc4S5i4C/OOaQ7w4Yjqolv2SLrB7RFMBkv6m4ePr22eTqS1xsdjOTxA18KNATbe+gBZpqGySNF5u53KvX5SFjMtHxDps80X3B7gLAXWY8WrX53HswImFv+3Gk2hQrWxgFLYRzAAuZGQvmG2vZwM0HhNdr4nUYEqnUoGVw8Pt6UuTT6wJyVnBwtaJoAL3U1C4JHdWClGWzhaxYfQ6UGCJ/tQaRSUyJ/HumcU6ficuROdh6z2D0bUWfV80WdZ23XDXdH/ymS1heD5YW6w4Lf+iO9AFO1X3Jp+CCGVReqPA3lcDyxgEiW1PQrTVA2fQ+kucAKKVRDnAtwmq22KyHnwz8ZNbOMbn+63ooRzLSlQ5fUdV99QTfpV7lbz8jt/+Y9gk+bTV/5oKzLtCr4yAQZdnMokghb6EekdCZmqM3EVTtcKKcdNdPMnDUzn6AsrKZqD5xDCxmYOl+UcsaFcmG86NkyktKK3Pqjxrdu+UbGnubZN7WcNOuRTbZ8mSWFKmkHQKnBj1TwCuLunZTAokKwniZpH60Jupo/HwFTI0iTOCokZyld+lJLd6+VbLR1+Z9lt/zZYUJasy0KW8DmXp8FnYLKwRnljczZaAeOlBYUQViOKeDOiMcq/tZ1h0QZ41OFd7yX/HOg+ryTh+1Y2M7yAn7rR80Sv1ojFpyt7eFRW51M22UXfUC3SwFCi9hhao6tC3YHLTtIa6r4FNNJXbHrs0jyzgq8rV9w6zRqcEsfn4MVt5w2EF+Os0Iy+ZGaEhHhHvbnTR/lL7X1ywx+NSWEtzMYkaSLqB7PjuhWtmMwNAJFrVdw44LGArGY3O21DpBBrIDui6Y57EoDfAqvCwvqiJ9t132BJy/+2DgCQd3AEts93UY+2vIbwcGv3+KDU4o+C9+biXrTPWFHKweHVZVA8ga/8QHAEEm6/jhk8EO40nVz1ENO3b9JAL9nEXXe0oaOlyFZYbxCYc9O0iUWVzNT8Pw52ElRUs4TPDfEH8LDgbEk+krPk1qwu6qzQomx3wQ8uCz6+2rV2UIlBXXRmOe6Ddxiaq7lEV5kosqsIHrqCK2EWM6OOsOV7deRFfbxEen+yyBPoumeoeESex/+GzZApYnL4RoWItlR6TqHDIOU8JwWz4VJQafVba7PuZv4J2HYvXLuIHgLzGEnzNgEVY7ugg8rMdEhn09TeNlvi8E+vEnjtUk1PTW6lVmEH99P+MQzLMQKd6soQvFQ8rZNn5V3DrWoyT+pRcdIY8+NNXIT1jBUcXAlz1W6uxRKFR77DoEfIn2UWcIf+QMY2gIAC3iyVOAKfs+OPEcInp7LN6rqalQQwrqD6acwRLzGqYjQRawpD3Sbz8JoZUMqYW4P8IRay4d1Mli8IvX7l3rwXIgr8Te3ONYdkmVEG1GqDCbRSmyW0Pu9SzPArh53Fk3Qd+ZleXlEfmWEWnRpP6WfDHSjwME9TZqpdqkUCl2lyD7VKB+RqgD4gZT0a6qUNLJO9oM+raou50Mj1yVExeRCpfww0QZXftb8aKSmyE5CzZGHCDduueloy4ftkcsXlbqdny9xb18S83PK6Y1eFybWdFzdqnC2MGcsHhfIYSux+4gMDEW6fYYR1hQmsVvTVqCrWP0MNF8+QZ0iLoKRuRKHEHBNhTYvuu8mupk+sOFG0dY3DEUqKQHZiNVRALoLkk+N/cxE51gWRjb7HEtRM8AMDMB3vav8cZGHB455bLZtY2BJG4/wvOTWMtG7akWT0PSCFrbUciLIp3P5LoIb09WA2/pop52H6MltH0MbF//SuldlaiRWr0qdx8RL9k5s+59j6QFmwvD7AwdSNwv2aD4Qne2qi2ZMMsp1QgsqqcqhTYX2+Fs3UhNH0iTz4lRMHFc+InQZL9tZari/X191O2GCOFH0hM6zRPAwVE03SkeZEsi0hAs01j5J1qywbbPuduVFYmiDDoyYKvNBc0xsZZKaTwVNELltuJe5rOC5Sv/y7I3sIwbGsqcZMCwGKD3Fpq2xPdP0JEqagPq+R6HPWs9I1vdQX3GQKGk56l84vrGiaj5Ew8W9ooNlR3mVyA3TvFMR3aVj4eOrjt7fD1zDOFhebCacRYi+pJrZmGe/P1Rly4xVqLlji4erdtEA8TOjzglQchDZDrgLRycalHBfsTDKIkNu7h37JNGa1IcX6QJWj5AM9lsUX8S8itcZLG+tAeH+byoRKJAvZk2dSz1ghrUUDoaWg8kviljf//78lGtGyFap+RNyQv6CxnDb4/mPW384ebClOOGpdeDiuWVnKn/N1+WzMOBXMzb45N8yQ8zaWlrHrENPXRmR0bTif0IzI3dJkzU3ORejhjZLeIc5BKmT9mbJOAkqMWsIE2lpYNhOICV/7QgId0oqCKpABQvr0iSm/a+e16QcvqbB7OJknfhi3/DFX+LFVmGC6gFSkNnD0Zk+amvCOZujLjQUbd1EYtjzHk8SJOcXew3Sww71PfehFzMP5ADZoxl4j2tFXyQcwY5pVPKmxGhvdbq67NxztWJ6ZZzERXDM+Srv1NuDwDYCfVmJOn6AoR/DqIY/pQx+FJ0mEdeuWpbFdb2gUeUA/lpu7mVjZHv/jDDvNYgWt8NJiBOnoeCSSPNUEichC51Vg4Yr4xIyUYP3XHmnwSlKgLGsLx25UiuPhsyT7gVzTMJuBSQtsfnsOP6rRYV/1ZROkLSDt3PP7xPPg0bbH4XEQKMcDzdKaPrkv33yhuGRM3hCQZwiTWSd5alw+9oOW3DxaMmo9rlHC0o6DjZUrrAZ5TtOKIZIwRSjU/3MlIWNu1BoC94opCFPclJEFZaxJ8u6T1iJrYHfGTgDAg+uhliBQp8gYOTtJz91LWMWGsib+8zNVsgMOyRuNMUNgSZ1ARr7d40EZemZzwOhnR2b/SzpnEUEaEgU6WQZn0DTis3sJk3oYHb2QnkHyWk9WinLENtD6mgVmCIRd4AgHafxKqrtcoYMweLoL0NELDZcpimPSBl7HZcU/hwZwX1+eLpQUJmyUBHZyVnGLcEtqZSam3fWJ1sBbSs/wZN+RsWhll7i0WSOuy5zL8XH/1b5sIZjjAaZCyo5WVNezZI3ln4BxLvlf5ku3dM+Uv3oBLuMvUSY0BXkGs67aEXsyz0DWysnh56lqcEUdU2N1OYPEQHavIZd76QIKJrCKTW7tD0twIPa0eMVRGJLGdI6dmexp05DB23S2WgCYDyN+N79nzePL7V9VfdOxGp7OOqEeGy4FZS4lTX7jROW36CjIU9Ap+qOD0DllEPxNLU/9ZynXJ3qQqyDJceQse5exw7DUM3QFvbOM+T5U2sdouHG11pbgBTkOcR9crLLf/EI2i7B1sPdXT0ClAVTwicC7HdEFT1TZTmmn37yGcxtMTGJRVp32s6Z+Vqsc0EkMz8MwH0g0aYMgrmJ+vH+zQhtZIvOLR1Shved2D3BnixnhMrdApjmD4NQLuOD7YdEADAvEN8ptVYdnZcdToXL9lsYcFEblUVHj0OMXvDEY8W2y2vCa+zJ6wd8xA+w5yszvhsAGs8c3uMbFRFzDhdLrYNJlCbjtTdDBc3I6NXbEeZ667BTVsRD5xli8Wl2VR5kSYSBK0eN5jdSBRIm/ACHs4gObO14nppqeRWhl1Y/qG0HuZDua/G3YmR4ND4wmnnECy+Z2yBqA3Jj3gfPt10FnDNvbQYe0OjmqLC5odjcdr1buTqlaPK1I1MBtAmC3zbGxJQC8JI0XWRUxwQOCzKrpd5PnL4T+M2RgDAiLHhTr1RAZ1muRA0sa9NLjtMAcDBkrK0IIYR3KmWmDmrSkxCwD3nI0k7fcVKX1ggcu4RAyyHhvnw1lb07DzeLxB2DVfAxk+sHlx1/By6WYp3OE2Ljy1bbJhh3czhlV1eNg6pgvu6UaZmmyXwlEp6dAtkw+1OPhBTG5n66TKECwOH8cBJ9HKDEOf4EVs3byLcTUiwJcXbPAk19Q7AN90j9iPR1dd/lfbEcJ37YhV3eS2Tv25KnjDn8TQrWqsBPW5hk/P33/TCUUaXIr1Zlaj1yZ1uw8Id9ALQSwfo0QiMyNTb0j1DhuqKDrJ410ypYbG0Zt8lklXwreKSHwnwswbp/+PZ97ISPwHkKNlg4zP1YxehiTOTDLw61x5h8kprrIVOBjgS5wlLGhK+TkGrE+Htx2CYJne9ZQxRWYcAasipz0XO3HKv3VPx0ylyRE4usJTd7fArVy/8aI/IQM8LwVQS9q4v+7zNJtmONBW44PCXWk2iMj1lQTTmun7IaTC22RPQBXAzaQCHwA0qGbQoKqrfnEHDLYWkF8Rq8cWJp9RHG7uC1aL9PxCMEbEw2is2/bKaD1nmX7WGJWhfjHYh35gJzEh/++cFVnFT8+NOstaVUW7gChFcIMRk2qNTGo2rjOgVTuhfQU78/0BbA8h5C9gbklxtD5uZ+AU3GlzZGZwrGXDhGpI+5+NGuoD660a1oj8zHfXAtuQa3FcyV35zIyWqE0DAUj7CJQ6vltz+mXhuTaFlFI++EkpxS75ljIxg+sP1J4BcHQaaEOv6s06MibmCTRZctJX3JOuFOgOm6on0i4cN0GmDZN+Gu8z4TqAihA64v1Am0HUSu3aHDnXeEDYid6xkOfuQBBcgi2vLCEjTZ+DuW/Fm3bYR36c5HEHm1GR5NX1MftCXF5rMqnslXG43OO8TbAbqYtI3Ly4Q97a3+VJpOoFR1jwX8yIX5PP/LWwVuQYgtqQ5qE2Gt4ktazD8GogIBGVZtqHcGlhxodAew6ViZvDnZUJ70qs3G4jvyOC3huxazK/mOmis71uFUFKB+mtfYsNSvunRixD4U2IRQVHpXckVYVO35IjLigXWNCcqHMVY+gNLN5n3erkzOYcFkAgF8pYX1CHrCz2O2XD7R/WkndqkIHVcg9lwBFO9c8floVNdGdw2iuDa7jNYLypku/N8j1NMiBBZC89kHD1Qb9O3SEk3zf5BIpnlprDgpj4M4TG8obHHuWHWa03eEDLxqGP+91HarIo7jmI7XByHq4Vd1ZkR1Bk+1HWdkMFSflAAoGPsYH0q8ngrePAKy6Bp9cc1pAPeap6MhtfAvF3OXm4bb2dPO4gWziGsuhtNSlYPc/85WWCEz1osqNGpMtUuF6GEvhQTCajve/RRk6R9U8fr4uMz4A5xs5BMfzU/Z/IPclAfPRfC+vc++iZ0nTUTuHWHZOUMXhf5dMkbZfQq24luLGxi9mlppklSRN2h0zp+AeDcI0WQulXlLfN5gm/0/5JP8yg6sSe7UQ4f0hoqXXeTVHBcHCtRznb4iDneBIvpCle72ZIHlC1136Z7iGomIJw6XVlwAWH+z3g4Rrc3+zeuERLwHGqTTx+0U/GjFOpCrgrRP1YYxxzCzfuCaoAjrpIL2r8Jfe9XaIZfyRSm5DAtklXFvXvoPC0EBEHe9bbtK417mwkRyZSG0IrZA0kcZnEPLtBSpSCuxWRmjnVJbGKYz4h8UTXpJNp+ZhGWTeh/VASVzfOuGXVJTfHnu3JPxJYq63H0kpikhuJJP7L1hk0DR5GZIKmP00hlmDGQL9nVVuG0YRbWg5d5AR2qN1e/YU0NcCYxei8CeEgZgn79Eoof+YAzUyCmDtZJoGbAk9nbUqY4WYNl6Qi7snd8G5PuQ5lo9ag7weKy7ccp5Y8ZzHw0lScNiu6hS1xz763jpqG3QIXipWqkLR9ozg3TLMwIz4J6K3YswHVmCOdvcDQmiYp1mObW/tMRhBogijVIxte1TwWqYuWm/dwYg0gvKzBmH0bjtEAA5SGiipH7MxiKGYBACKWKEkvqoi+rFszAsgO6E+Jgz8fN0EOWYDtF1xm003WSd6/0OyXH4i2XQmq0/3e+OZELtm5ieMDEIXYdlRnsZpzA6maQXLUF4M9B51EEkv8IuDMz/viDt0W7tMei3HSeGupF7eNERgPC7hMKKxk68PjugHWM0Y4jyhTQQ9Gg2EnBWMWxHlHSIfuSFVjSJcJwVpXzKurwahuHvABShdlmEtT8QOhl1Nscf8zeBKqkuQtifdlHEbQ8AN2c391XZ4tdge0bcR/skwp0RzX6diaFmSWLOl3gjHHAR4nMaTqHW72cZXnQDi9qf+D2Zbmx3u9VlZQbFEwtBG7kDDjbMpDkdLv4zbKEaqSixAlhkKuaVit/bYmdV1IhIhXTytuHtB1T1fh0QLyCO6Dx2PlNEhsicLTb2sxYrcdMeoZQydc1Bjf4XgLC5IHjn8JmHtL1t3flUlP69aMVHlgBEBbPd9qkpT+52qVbqKEFzFIhr8fhH1RkMGEfouKoHGCKR09QCA0teG4+aqwSp+7ClcDd/5jgpQ8e1uLNxa/j5+DXHgN4EmNhMRCSxVFCqR+863xcitcTaYZX1DpcAgyXew04hCkFwOklowXZEgjFI2wESawnjcD+IX/y8te/TxuXAVPBvNZ17pNaIvUSaZ0qaknV+y1emaaTwoS9TAE6ya+lmJmnOe+kT0Jnjxwdw5n2nylnJSdaTBrV3jmDlEIVJqBteSDBHFJQ4OTxgfN2BFcEIeLFZHi2ctxkg+ifxuduqo+qF/50oAXdqLqx/579Ay64cI25thnWl0vEPhq/ml58O0toifTDsqqXvJkOXUb/eG24b45OdPMDQUxC2ExoWw4z5yFgWNXfFf/i9/eoHWbqbUZ7lzKFzaGqRNJ7iRPcLUQFxbv9t1bZ0dgM+Z7oN1GKTD0/VXqPJRz4dhhXXr0v0vqJOJl/DniWPmBzgBE+USHnIR34Yb7f8vFgeZCTdRC/MpyKDfvnqC9mnOn5FlbhVAytX/kQF6dHfqwNWFJc0/zg9xWcUhdUec/hFXIYio0xtmir5UJUwYGfP+zbQjmfF/qUJudN/NKWJyWXUv2/tnuAQs28QcVYWZqNEhRyLdgayGkymSpXDImUKYnr9IL6APiZKTndscalfcLnlUYwAdCbKIoF9EksjcjLm9wVKjo0LR+WlyG1c8pvnrT5LfD1l+ROjPPOQj1QBj3jPqQB6WeuNiYfSmX7EWBQTJUqV/kXrngQAJVLTUh4b3vfzKcy8iTXzD1WItdXwJwcIT0gPhnO0d7yHtQwBBNGD6dbk4f0jiRyRIuWdvuUmMQtr+UycndqZyIcFDLh3Kdd2UY+UUwYfThYyO3ZShwHnTbaWVp6QvVch35r2nvGssedYB0Pac6pg9viiKhSCdfMyFn6ejnPyoH3ZcmS1z6m404C3kzAS7wrvvkQb66Q/23Eg3lhI1GZMMNmYmwhzALaLBexsJMfECsgPgCdXP4c1bM5R7DDgc9iBfR0mYE3/IIB5uWBT0Y0bZpkoZvwOwefg1v71Qf78pvnQjbkrNPnAht3969ZeHbrP/2Rh+dotGSqdgmfT4gGL0t9DDBuXUSZa6+TG+e26ZhL5vDqoa6MnEKN5A2mlItfQ/1nJzvXz96Hnj3D4rpekvka++xCpVWbIAKVmSWUN/AKVuETBRXYBWpQNfg0f7Z+gzqiUeMjL/XYZ1a21nHSfFQREjfr8sgzGcE3aIq3lrp5ISDoW17cwzCQDzGib5a2w87O9YeEYZPTT8Jq2RjVLScsgnCstC+dd1FkAXfHRo+SMbQSY5mDis1oa7ETqrQRMF2hdAXm6thIYYFPew7sblEDmBHSI/PMWdijA1mgDCa/tltMcDo9NcXNgmPtyvUZ9fdcFbVwJFYJUm9kL4oSM2F4TDYJ2UREFxmHg4gdNe+oi0g9xvg7Mdb8cJzgGTXTv2fZiU8yQVzRhYCLDQbIvM027W2fCz1qkpyfOFvtqnqqh0Qf1DKlvW90b4zl7xTyJtlbKcj+D7ao1GW1eefM87vsn35f+zTPXvbHhEbewTio5Wwlm9PMZl87dkrN9GDFS80H9LmlZaRaaZ0lH7T58LQZ1vh1wHi40O3BgXtj+G+eTztFx9v0gNmEsJPLyzUoyvsrZQsUKUArjBqD0FCbDqXp9NGDy0zJjpwWuXzYJy23Wnj2BuleU73fPcOpLcgVZN+0IsucRC+H+nhGvpRMwQrJBC2etK/eM/GIyXCt4C8rUlKxilQnWUFYkd9IWqpnAc62Gz4Vvy6joVjJRlOWOCcu3wzZe1njGEqyb162OxE/gNMIrAHGLDL+PM66xfyeE8YM6TjgiAZzTcS97Sl7Qf1/dJmvaBrzteNiagySN8aDYhLIjvi+o8Sw9vpAwLDQgUkSvi1uBlFkvg+I6rdWB9w/boo5dvhD0rJWHpRyJ7t6HpCjOgtJU8beBNcy6/DBKNoCWlozTsDJXRgnrlpm/p/vmDxe7pqOBy+iI/P66ueKQRWGRinZKC9fBhlUrCng/yf/9F4unEO3Aei1g4PzFKORDUhyYIIO0W+AQwQ0ZLK8va7R3K5MeN3W4aPiW6SgHagPWX98q+UqyV070S59qYFXbQp08b5sPilEyviDtv9YD2+nsur31c75reGntrkZAHvAViZ1Reg7bZ5T7yk+U6utvuDGe2mVK3s+vqHhdqJtwmVp/KVxXRc7nxEEbQsUxqgXL38EEs22Hqjp5dnvQww0o/xk0+z7LgKq9YCkuxGk7pCNGCCJK5nO+wshw7RC64c+LeMOPNm2jCbtF5/BrbQoeio02gRGCMoH0N7+dshcyjbnG/UIr9AseJRIifp6U6jjxzBwwk0SF6HuQXl08H0Yz4i5Y3sUYXhMVXqXudcBdny6yDvA0GCOlrrtyhRGNQabBDYhSXOiI36ueVl6bHn/NiFpw5Xy0MbbU6hMWy4Fps6SoUMqneQE195ZB8KaCodDQH3vWLQASmHngklHIzkTQtoUnQO0T00YZ0AItoTgLGKv79kui4OjXEIkpaTO86itfpC5iuW9FcBdAhOPulj3M6emgMo34WhSVddFedBSBuqP36SsD0UPeGHQROO/8bQA0WMiVzkA3+rq9khK6pAZRAUmmA7Ny8x4sfw3I+4GVi0S6lJVnmeGj9GVWyV7jSOPCVoXrfNqiGAQWuzM0T4SpgvUsmNKBaONMyLy6Jh14aJVnKRsWXAEGVHWRF9JeOBwW49adBBSKuL02qyqwA1xzcNY7meKpJvYMt0IxgHu8Ahf+6lYai+XiGIWfG+Rt83+JmaDFejnAUXrKb70dXPSak45xAVR+Ygh8OJKWGXRtFykZ+9IJDHtRvJI28TnddBev1N8TL6BVFP/R/xTKCTFtZcaC3eDqRRDiqUNlt4CnGfyazSxSoFVrkLANO8H4xk8T1TWEzRNv4OtkO/fSRUByME8THDJN+VOQhqSxOLSYp79hjKMMiZumO02KRQmzm4dAp0j15eB7U6tyt6R3GaxsXXvJjgzNt0UMrpcFxU2ACMn6bd4VrnRBpNCoVBfdHW4D3TCiTb4ubfDBPKsYexryKyIX+BwXekH6TWTzXRPD/OpxzSdmYDxA1t+gzSBBxJotRrlAXJnf+ZadJXKOey5dFLbwtDk17/9MYWkGaiepCsJMiB/OSVoN7juGtj/vnwpL3/kvuNbtSXWxSMWwBKPRZgItfZnu5+iZLq7R7NfJashvV0qrtsW/Fn9O9wQSHS0YDNNeCNRIpv72ep50o/xg2eZFEp9btuiayvrUL+5C4g7mY4EY/RbuT9Bnur4iDDZ1cLgTVHqm7imHWkQ29tHgLGMYBbPu1Ng0hLbBZrkcXQYdRzlCtV4SlUfWVkwywXsYLn6n7Nu9s5PgzjmMlRwr2mXUG6s8FJWyCLzB4zfjF7fE31QFKaHJkN/P9zQNxGQitk0bFzlgzWLrhIghWunZtabSJMffJlilBXe7lpEWP00fZqDaM8WH0cgahWeuhBSB5PHcgjFVCZCfW8lzeT3AWikYSNSY6+zp9ZgfRTUyCWyc7eTL1P7SqF1KSSksBf88cMKCCa+3fPYW4zcFGv5RG3xgmVMp6ZBpA8g7HXj6DjY45abnX537RRSjNK1pjjld1tuM4vXjNHgDHKlrM2HKU7EsljUY9s7rtAszVkxgvxL+qOw1m6cwtQXsMb+c8EFNnkzEADla9N+bPWNhxJQ765E7NzexgmF2M/7J6uTQSDUgwFRAO54rfxfuVTMdtkKb7jgmmWfWB4kgGJQdjOsCVAGF24tsEnvXvM0vDX77qlNIWnfiPHvZkfHwni2Td+JHZeRPt0m6hdd3h4AHGZ7w6lhZvq41WHrihd8jhmTTEOob3SSd1xs3FHeW2764p40t7T96gs/d51qluw4T9qBdtsaDXhRbPtTflRzCPbiJVikMY6sCKrzDliF3p3x5/nIqWEmqelnffa80V8+ZlTysePzGgxVWZcvLyWKwkeNKOSAJc3mFwofrzWTrUlC9Ckx+gWqpOgoFbAqkFWa9e96CCYrgkJznrHmh0/uD/4zAYf7IsJUjbxRYHTELh81YT6T258YoYnZUrUcWnEYR8xhOXX4SXHR2LGh20UOLf8wQDXKcMMkz96pMjQCdosBe5TIJVGM/Y6rNPmaNnwTV248/EMmBAs6rTN6dqtX3dEWCzOFrj2gFxtZX2D+r/JPBVqEzq/66rIq7dOQWP5/i8AUEGoWtq3aLNbq8PrR5hdJ821K6L/Pv0oM/E5gnw0WYo9A0vcp2G+O/FJBSnSLABs2MgSyXkIaC1ZmL/JUVdpUjA1QAYTdlz2oMsTrP9gN62BSTjam5z+QJAIQOcfo08nQnNZ8nBATj08jP8BYMoD+JM+66xyedC1J9jwgKPBSvyvOmJjgqghTp2zeb2ETFsjirC1bq+BHI48+QYvSob41SjUm7bfcUxqxvXpu7aeJL7ZQv2cDJK2LnAwJJinzmcW6etVP/avUPZ9FhItn8yjOsZbR2rx4RqfVDtgPZA9ida4ABfobmMYZQhTFTrTXbRYYzelAU7uQXgk93r986/63+ockZUvR/cpwdey9x80P0IOgO+22DTkP4iIWMw4aNL3I+3W4ajaXHBuHhh8eTV21poGoREhzUzxdH/Pkwy157V0Al5eK3r5WB2w2UlNCDPU3TLfdUQYYnkSeTLOw++H8DM5p9tRzfLwt7aGK8bOOAC4XchnHe4chDC11UVClRM99G5AoZwFFsicQj3k37nqsxlP7ZsHwcm8MG0XHdVa6XwbE4/kGrsS4kLF46coqriEsF7uSz372in6eTiENbhzHlouwc+Mh8zT14zaEioZDmbFYfx0yAyKzOSk/TomL91MiCAgUMFx0Unmjvg404RrbFjOYxyyVzjU7yV4KW5eyx9r+yuh9LZMeWXeJvgA7XkBYxWxxgnzfJZ1donNcbdWvRLr+w6TzTcN54P/lFbs9ogJeDsCIFreTwYTF71RQ4L8WDktSOw/BYyEIeskwXYTH+X7ZiXrhKUlQJV35ZrAEVWm2we08Juy/8rm8C3DJmOc8bxf1xuWeB+XMrhb00g/wCvB1KvSScJZ5Y9wcbXVetQDfopMcJe0xiCinsqyhQCAgtrk/sC6X5Jtz+9/9dP8Fx6OhvoGIFLsEPiKkNW8PhK4vRmD1ss4C4kWwIfN89ZJMGN80usjJWlYNWkzRh7ujU8yltgN6pbQRbveNzbEsK5G8jDKk+UcIGqsiLSOGx3EGRMbtmhxOsBkzLu9pawxgBciUrsIADmkkTeBrUPQnZwO5XRq9DkTr6bGNnX/hX/RfrQrl1vNhweSd//qG0LLP2sd+fpBGZgPcf+qFFv7jBJuc3mWlqbOl7BrKsp6fziIJjtp+NHR19GXmhJFIuuBn6EujZBdqR0dY1CWe9XSlbv62dlSreqzG1Lk3DdEFTh2OSx5M6Tt0mR1XjXIeVV+URY2tqfHHzDyR/DhuOqqMCPsfr+By7+CflhF7bWEDjCs7zHSjMErQYEdVs5T3vEfioaQcHnx395xssjgRnFk9vHnwwL0YT9yvmi6bZlabdGxVS36FuP0/vB2O2ZFosFDnSByGuhxZfuDPWQ9yZEWQRN46jQR0FTxUhLbaA0kZZttrLe1vQYPxvIdyTiznU2lnWmzN3Jid/w9LxGd4EJ/mQSzSnMgOG28OwrQaV3RV1IVMIOy2+LX38byvbBHFOv8g8imBDNi65ffuM3LVCcaoUtrtKTuUwq7biTdqy17xfgL7EyJdHanycEss9HYTwgvyp7c6ZZaVM7aRnB3f+wjzmuMMH4BPJLbENCJBWzzMbUy5tYDZ/cQUoUhkjzUbPkWxP/0osmPrNTF+ztwKWkMQLf2YVcguoAUlSjAK3BUXGs5Ak16JLJNdnQRiDP7h0n4695o+Bx85irfiiBtAfEUHGSWhZ5jbwvZcBq/B5fRJ0pBxE4sS0w82DBVnZpwnz3smNb2OicTZdegtQEfQIQj8yebxX2hgxV3n2oPdRJFWxDfZHomhRm+cnJ8XunG6DNO/4F0mnYsLiLynOzDdIqzwWQngkcea8s3goTydPKsQ+/NSO+MN3r7KauiFYTs7K19Olvh0O4DJxpg2dp8/mzBj9h+lbRLEcbiGZ7hi/errV4Iq/U2nzCaV5iW2TBClwdeJ4RLNuggrkB51g9CsJAIGBRZbbrcQkTH0S3qkzJYGskVNiA94LQwVZG79J4j21JUcFC0vdPcm49BdVoiAyPnamledb23UgXTDfwKLgqw5rSquOD+Zhh3RzHMCssKhpRGmdRlP2GcNQ3JAw/0UD6q2oNYchQ9buSxKlq3LgwcZsIkQoRAlBl9sshQtNRUNoWKN77hURxZF9xcHeg9A6WqG81Y7zG+WhuUHPl4pfQzQQLCARWOKWBq7YWz5pS3DkerbHflPZTSy4jwHz5g2w2sryFrWHIV6BZUAurB1qj+Icit4fWvaJslsR0Ki1/JaEF5mRm9SYPfHL79sFsemmep1QAGddXYC4DXS/qTl/ta69P1Y8JHq/jyo5BZyYek+Xk/HftvaWYJNi3GJMd+DWHkGUrjzVvG3WHLYyT9luYssq9TefvMkJtH5skyxYx+4X+GiepLSWP3JqqYAS6hgA8kewINReusKZEc6/pvrs2tdZ1z5SdpCZmUbAoRDRZJiAci5aLzjJb8GNJLfDJpvqz2EuLOrME3y+RokTjKCqxzkzqS4pWISc+IJKpq2Veww/xYnvII6Cqcz90vamWvRt5HJcflCE5jdhhDh8xH3OKeJlUkGZd/NCvjtncDuLs+Tb47ZVJqrSXdMI54NIYnFCwLMPPiI/nYy6K5tXxDSzMK3DtnDBgQl/0ZwTDsPlV84aAF6paz5sm/EGs7QZl4ZjDmBdES/hCF5ucH6yYdNeA2c4WPHyLAEp6OeI/Y73OA6pDsSXTKp3uV+AHz76losEMWG/4p60WWXYYHS/KGxwfpumRrRQLFShiMoQRsN0u3QnTw1wtHmFv7nXoS2T/YbrxcH2SebYVgWEFauLOQGff2XuL2QedyFJOZ981F19OWK6wRkZy1aaV+5TXZ8k//u2caS5dXwyXaseF8CuWChenbzWqvQ6jizfOWzfi6edlJAUN3lKRR25+PVRh+/W/ahVv4xC9So9wd1sKC06tIyxqyrvCBeEgYfPhXbdA0tXIM3bXm0S9HQmhGaSqdH5/MDOjxufqqC13WT4CtNzeMQTrK1bM4VS66+0/jOjaVmVK0biEdDIwBtJtP0VWyFKgRNUHu4WdoM8eFh2oyC5Mm5FIJk/N9ByE/wJtdJf5vnV/NEu4Kzki8Nq0K5YTegm2SIgsfL2UW0IndWw7EuBkbbOp77C7AlV+7S2II2g1//gW+8ZTXXOk/5bbBKucvCfkdpowBx/QRmyztcX/w2Ufcx2MGuMCS/6P572fjL59vMG5rRl9J824RGhNWspEjPnvRotw5FZThDeg+la/lp9l4aEs9Gga7DXcKTK1Jh7tMTWd3NuL/blmQFTb+5n7udovx9uTDRbXtmQPWnlj2GGvap6+0v357v1E7MtdpoRGmM0Gl2wCfmocPksZVjXAi598xHdGyLSxcew2bXSRfYeYOFvqDYD9SCiTP1pdn5moztDUdvMt6RnXwrS7ljwsNgPkUE4Zvp4mON1heKjOjR63LxFw+0rhDo0ZN//R4zanC4G04H5UnLz0Q1evqyvjfVZi0fw5OygW41FxyJRITMdnVwYoDeaihXBLvIK37LhsVVyV6lbF9/zGyIo4HprOb71ZCR5BGKudRmKWLs28pTErPc9bhBNZi1sTWKeFowZnqqVcljPEdsXWxl5j6QZdbjKYHohLfsc5vYSaz0LJdGU6UunjOgj6aTyfOGUvTVpoLBCT5eOdLAaNxEbv/VJ9rSUM3tfxjxyImUolcwViYkOD76DvdM/OSNm5+Y/wgQ6OIIrUwsJYvQO1Uw0LjsEtOXDSMamobefgYkEjM3tXRC8uigrMOaSOlOoRrAMGbPM+zw32DEwVrYw+uka/f1SgUM35QrfK9S5We8LEfThrNxrwWyRNn3dzccQGO099/R3y7FbjxAIy8PfkP34Q0KykChnsjHV9+RfuHV48QIOF7AWuvyEEFvdQPAHzueP64buibspurxrjdUW4m5fr0kVq492nYD2lqjI4GjwcRqNVLLVSle9ERhUmdlBoi13QnBOQ0Em1buXleZ2A6yn79K3AbIWUZRwnUxXml9ZhFOY8FK7ah1aXZh2Qc7FonhLDm5nR7OIX3aA2YvMrKM35hnQIdK0c2aAIv6fqmnu673fdckzHFxAyz0JRgHB95B6vnOi6xmlQxOwxkXLg84OG8hsh7duHTKYQfqItjA7MXfbdFEEafBRPBsD6e+3AeG6NjztN/Rr54pqs4r0lI0oHIi+v70xqu8Y2jq8sGgXhbnNZ/a7G1BL0LbzUu9GbBzfV8h4+F0rfwPQfqLuRYhDFt1eSvP8G2SGzfrg3Eeu+zH90RJxw3TmzXSbMDmgP9QjMaT93D+WUxe+JPsQwGcAvR0eOamd2dwjDFg39vwop4AO8fxJ+y4NxyYB4XAl5D2aDk+MOvrXybFpWuoHeJZbuy0TUyA73zbiOmYXe8mjeZHMCCOxT8ag4MuIO+8hzbgbBDIKM+s8yZCqCYfkHejvbLQoHRuo24j2lmCPpBukPpfD+VV4LNxKjxDqd7nD8h2trMxTMKUz0SdwmfMmz35r/hRT/HQJdQ+fW7eawKydlgpkMtfjtquf/FPhKSMvnaDfqhXWeB0A5YKpvX7jrT3Ex2PbyKGrX358S2b3BowjCU7OlEmwpYaiWnHcNcg0QeRjGh79upMtg/u43ElPP7MaLhndzORUDzdQF2XqUWLyQ0pQN8kTfCsi+Obw7zxL+AXRs7apQIXCHCGHQ5L/+F8buCIFhAuZzWsV+qVyqZi+XQiuRiRprwkI5brcYhN9ft5PVkXJq7Q2vJUJS1b01bqg0Bj5CCOBmG+w2gctYQ5l+YEWpwqmwnYW8sNAjeqnpzJzC5VvXizFEq0wTe5zWnPRrs5DyQrWc2C4u2dbvcSqhf9027I0BDs04n9WGkMgJ7Co/GjGjWG3ezwBPeQRmv5hUx/UsdtNxM07robVsiKSbk03xINLYIuNU2zTZ7SvbJR7OozOzCR8jElrWTwcrlM9JlQVh/UlEqL9Lip0K0qz1MfjGyE0mAkx1bWoAWZKdiDYOar8XBqpS/60pRErCPMk16wXo9wtuWNXFD6TgEZL2Auzvgy4bM+w/+AAx41nNn/s6ELFbpHFUJMH7NAPGNJFFbCFjjty5crUtKco+75KHnd5w6yOInR/AbLLDXz9CP8WdbvMleniTWJ6bpJcHJHAgOuiRGs77Fs/0ZhszDymeVF81MyCxeWrIdZMhvXGVHhCqUaXNkiDcq04prWX64/XH/eB2AG+h10Pue2Z1qYUfKuEAS840nyADvjo+VdoJpGB2cZLmX1ynW5oykcaZXeFXCvMlLUjlpUHlzI/D97K7UcuEcPTHoUFwagvlV3y3uXczVvjemgBTPH0IGawzZDo4/2Mmich0ES2CsZ4vi+ozXrxZOQlCi8kvJ118FgdY90lfq9WQw0DfZ1b8nyOXuTyDi2ebErsGazSiWJo6FOpyyPfjFibVRnG2W3CRX1kUiXC8qjQOhAVGApT/ldVoDL+23j0d3zfkt8f6UDKn37homovva2R/w+NXtk7K0/Mvgx6IubSx9zWZUiEYf8vZMJ0BLNhf/+C0xVqNfx7m+N7Q5cYMYvRBlFDNTiUYH40RUkwIUPbPIPWSarzVivGrLNnYmpl8oboF11z/Cyj5fAR4GT4cE/AQ14IgU4uete47BtSKSEfKnSaFQ0/lR79iUtkGQCohKIiv0I7Jzxqc7AQaj5llG2q5RM+mJW0IDUoANsPN8smUWtu9vqM7aCnJLJzJy5Yc6j02kkG9ukfQqXc1JtLzVD9OZO+XxOg7C1HDo3APIG32ilMlONgCo+N0yvXKjWPQThoVzbogxej7AKOrgkxvHbf+5Z+/6FTCKWfdFlvUiv/mUNHwpzH924pNAcZOwH+rJ4Gfo/Xt4fxUs3k9cMQcfPY4JSQP9dJJHfoCm2YkbjMeOi6nhppUnMMTLFmL7qKMqL+eEQJi0J/nCuoCDnSQLeZFtwyqZZM3gZlxQ+2GaFDQgixnRJwXg921J83DJS16GK+gSjQ2r6DYxj4Yl3Fn7kkJcSxs/BkViYqKgzxCLloARP+FCYdb70npLmxVSwHdxcg1P1JuWVB2fVhd/bhlM9+HAolwbInSZk0eOYwrjq+5ze3bANVGs1bt0IBdQPquZwxmEz1lH9KjwaGIy/C2y3Y6QguRWJo2bWiWFQBdeHlhexrp9PNwZbKGckFvueoInv6PxNd2xtZzoQgTiVAH93hHZ5biWFjCC9weN7kn+OHqbPcsZ3eOVDvzr8Zu/IjK8IGRdFmcI9mqn0JKVFdZLJILpDwdcy1dYfJuhOlhiEeDHXhTKT8l6OXRmNwFVdo/reCWfvPykXaUNfUhhkupWZodAGwVIKi+CoIVVmJ20jmlmFlb0Yp5pv2v6xXTr26Ck3AHCFOtqgcY3GFVJkOgxAAZh5xtwWMWEjN/qvFdIfzIxrWYBJrn5QjUsPTtnYu64i071TAPh9smr+wgZfU9CiFujCs/6axb09A5tqNl+ZRiU5QU9dVUUxbm//bmAUwP+sCQEzg0eImA7BGQUPSbK3joe8UoZHLC7VqV4c68Yyxn7ejcUmkAfo1ORJ+WjT3R3N4Pv9PUVUNZeWQKKGKf6hE3EecXasYBNQCa83qD67b8cRS+L5z2DyaeFBNwHqVMcx/bsEqAPDheqzzF6uJPQWkEd9qltOH3jY11EStixGSiVYl1Z/Ml6PoGSNP6qUtHxS6rF1/9GrtkBRRtXqljhmIRUrL6V5bIEkG7qKHZbUiyhNYPiuONjVVH1NakxwKvM7kDyedBj/QQa5eh5jhjulWJ/d9nEZsoxl3Na4xxrsPjIUAgfwGU6Eq+1Un+8RCzgXgevZ8sg43u/yUYdz5Uonx5FdpJWSpzdQ9LWK/p80D+qVdfo61RDiqF8MjtpCFTIJIkuDwWyF8634q5Et6WjjwDrZV4WQbt7z95xBOYGdsgOSFCzWxGBQMt1XD11K+GwriBbbiM483ZFiMv2WLvM1TrBVSq6QvuA1H7jFzsufHgSejHd9CBkWlBfmfCUR88PfAzP+DdNh4XWbQVP0HLnobKkXyZRYmxcS9TgnJcnYhMJGhxHND5s3omgPgH52ir4NZwN9jZKY2Lto8RNmmZzYrWpOHptkD8nm/oA6YzUmcCUvBWabLOa37v6oR9qWZuI8jOunOtpE9VOtAsJZL3raQmJ5QEC4MlXw3QkVz7PdeLAH9APmA0349qUPqKKEH9ZN2hMrNlgUH+zSn+6FlWARecVoEh7js46+MkOrbjsys2pLTK5dOeuIg0UU4FRu97ip6YONdPFIhvN1QM6Ofrq8VcLInLIgAyNOvhCHgddY81vjOfiwFCqfGdNUOTMjf9B6MT4o87CaWhRvdoGgT1zWL4T7FMDyMsqT3wIz0VIE6rtd2wpbnfO67QSO9iC8ZoEu/qmnKPXU2sTCq9Yw72MAfUK/2AA649i3A59WER/nHwJNJe4rEWiJS+UOk/Iol2WxrAG+cAxWYh6HsIGyvhvW1j4a4jSggFJvVIxdHUIlTACLggynCwVnWyRwDVTiDjd22wNN3BK6Kw7m3kf07UdovOVScsBtO6dQsO8Ucp/Nl6d2/+myPzH2sMWrAHyetphOsqV9Jy6tmZu69vTvxXjEutbbjp+F9PcpDNBCMmU5UqeVP8a6YL+DjXkvQGXakCrMpqkG8Uh4axZaF5vlJ8gtLE7TzZz8jHTkIU6jScD/RLANzt2Ilofx6rKVoQuZtT+M03mNfoS3AHtZ8CYFJMvMTsBaYLAcXmrjptpe/MOqDSMKGEb+wPJSX42zsRUn28VI5Hk2/1K2Cbj03vCKXJ9R2dyqewdc15wrisrbAXdKtHqhrhtHRbKd+heB8XilnTmNdfoWkeAVqk9mmtDfIowab78w5ZjtkvaV9fuabXmAjReWe2Rus9fZa7t/J8RFbqhAB/R2UOSmqonsX+2H+/KY4BW/qVpY7ekJq8ri2yfJtN+GvEzPIaurgvc2rIPwDJhGGyvMg10oTB5wLxYCdJ3WuxryWXRkXU542iB80awHTbx4JmX+uZdZe+FGlA5/7/TmC5Cgg2Ut31i70Dt+XUSCED/We4XUK/VwD7t9qdPOkFiCBX1kqFe8nqJOSzI3vxQtOGof3YjSrC4UAKngnVvK8L/jI0T3gZ2hJCF7ynLCc6NtbSkFnEJoJXE0w+Jue1DeF6fQK8fKuH1ZIEOMvJdUV6DzclGOH4/SWy1VMdilsBqAE4WOdwoxGHFSqlYmmXA3unqDvndC1e9COQD0W6d2OUJPo3qZphH+k3GqSN75Y7oiDwTr8lQm4787mYrF/OaAu/aPG+ljKBqYe29bQnkg5VpZfLd0BUWA1IyygoPxvHL7tav0awd/1/T95lAiZbFxT5hP7PxMJF3N1dGaQC4N+Y5G4NYNzHbVIrYrS2/QmXefLN8bNmTuGf9dEFhCDyGOBd/WICCbEGQxQ+n4w9LAZUeYUjgp37DS1LrNrwFYYlv4DSYqp+G694LBrXmSMqbnqcksFZ9L97geICQFJ+EAPZa31cEXiSBa6oedTtKsWtdDeQFHp2nVkW+Bp1JjN4n/rd2ekCIiiqpXR9ze5rXGnwmL7S5V0nHt0rkSq+bX8RRmz0CuQJ2p/eIr7WqlCBqK11cYXQ2e6uzbNCC7kXAp1BFXnEDGGuYnZM+i2GeSVRUmr0wmU2Hi9Fbi8skUkT94pjTldeMbJOOLzDOB09RTL7K/dV3C9gy787NDOZo2qILdhH2LNcoVWltxNad9ueQDCcDQmIZDw0/PsKTj1li+jkQ1oGpoW3ErWMJrw5/AaiY/V7QKXHjFruPQrCW9PPU3lp5NCEi4rtMnWQ2PSNOO2jwmSPSjsp0ZFkMeIYhmBkJlDybZVF7HV7cfSnKgJUTpUiwH8pKLwH7W4yaPOe09+eTWS7hrzHwj93ABRgUxI8U/Tlj1BOrBwXXGsWDRjuhB1JAPtKbyz9aIwgXDiA0Q7MrRM8QhTjaVq76B9PvPcRGj2n5DuFMAXX8PtPn0NZMknT7Xgzbdm2V3lGDzCch2meIzpjzrj6Zqm2y8v87p9lR6XMoC6TFAsw28Pq/BEIGbFGOCi5Zn2Pr10D5O5eXzt81ljk2SsSwzTB9OohwZbntYbtK0zqPAcA7w9pKAwOonls9Vkd6YoJ9k2yDMCEtailVrmgjPkfWRTYp70dZVc393rZig75poMsDpm8qQc+AoDpt9j0MM+9jH5QnwJtQ34MoB0E+pEdyw5Mkuf4t5g0Nm8RXLfCl8SC7/6JZd9kSKXfgLL4IOdvs8kmOi79sNqqwAGrvfBHN2o9JplXM2DxvtwbvA5Q2yN0DnXVHIKWX3YtSpTqGRENWfR9MgK+M8cQtidnEtugOPg/yxJnrWhNkB+Crx2ArAjkFD9cB1w1rcUCqPFjnqUBpSDGULG5+F7bL+O8KP+PTCul2QXWnjp2XWYUN5LVl9SgWTERUJYQCX0vPmNgKAKRBvonUsa21yKTPh4CcH0UIQWDWW7hKVE0HQmLA/G/vJoBmpcv7XEFFFfAaEqXeqLq8CzTAQjQhgMQOhNRgcNVg3sK68PNmsLQ3JzgOTv7qa+Gtz91jhqv+h2haJLz5zztLCxPqxqUhVm9G0UQy6cA/XvX3o2ut22SonNyUVPcz2O70yYN31HcYBmdbyjCQt6DS0aonodM2FA4hGkVAZr1oSmzHRcZyKujKdvNELsc15xbscNqUvb48AsZ4vZGjJqgcKzjjyDHVVMUawEt+gHEqSZZzzQNlnJhGVyGzP+FyLjC5JliorcOLfw9e86GCQ0kOT/2RV6Sly7v7oSOcIAzIKah0m310Vdgsn4JDZhCmCC/eOv+dlBh0jYVEJzixM+cVzEb7XgSBc6E2QjicraLqGhKL6GdAmo5Ph34qzVx/v1qZkUKEiBtlIx20umtKQFA53PXFrCCxZiDuJfWBdJYFuIlWrUPsDkQvUDbh6HXOB1g3SJtv5qkVd3GFZef8pJUn1Oaxrag8f6XS17JlNfCLS6QHuBzBJ12mt3Apzxax5/e8hggEBfusjubgX2q1Y0Cg2LAGUKEX9Y3eexaOKsgAGytN8ni8l75aaTw8ModzDj+wtqJIeaK+bD9OtCXVHjbCE3H5Sv6cpbAaT9L//iSMhYXgIH/OHkMxJVdtmNfzK62XrzW9UDJr0dbOFPn4MW6+AsstkkU1iGysscIw4N/EyLioQzeZDyaRa0rV7Nc7O0fu8ybVBe6Hd92OIwqNHhCIvr5Ojer7VE55vQw9aMqIe3qG81PrvVZIFqNbkPRNcPakdIexGJRM+E8nX3gFx2nK0TWylfKF6Hl4dDWTZpNjaBCi/Bb2H7RzhWdZi4ARadrvQbLStlsoCJC38deCv/E+s2KyhOig9GIreFTbK6U5fgSqqPmH4Zt96GG6P1xHpSAq58XtoJPTDUXoet42/5eDG6DHhuD+wPwkXU/zhF8w8aWUSAxjEPDGYugl5zSgLyegRQPWp7LN23H6XpZ3Pjy17vg67CrQIEDXyGTw8V35bAFu1QRSXTgTXbpd6xAB4w87E9obB41bWSIdKd0rByF+7mlpfuFCRtoJhrm8Er2921kDPRy3SEhKYQ+jSvGmIDN/CokAezTcjLiHrUIu5AzqzLnymk/iXdhlVLKwyxNodR7/O4H8jVgZM7Ngz1dAtuq4xHFDJrnqt/997XmuLAk3qFfYOfPZnwsei0arM2a58xJsr3tt0YhY85xq/6Wcqu5dCc3boNm1tJZkg5E7YC0b4i7EQUjtt2PzGOZ59Pg4yK9hp+1RxL8iwTPWEg8aqbaZ8mHqS2+4OgQI3OYucOSGw/mezvBaJrR3wLTR0OvJ3Ds4W70dBkgNqE+0kYdZJUyeqNjM6BNd1IPWENDn+kz5HxF1hj8yS7XoL8ON0OF7FaiaKAHua4cVE3DWgaQKcNi98/6xV73QxuqPf8InaP4S4S5o0ENyjvdKB7cmuBCsBTkk4voqzqNY7dn6jXklwoXojeZxobvsMlTBEi7jqQRaW6inj/PScpLMk+90TsqeZhfeU6be1dMi23KoQdxLF1eYX/fcz6IePCebZUqtnDkDDk5l4BwwYi6AieX2YSTdrKrXQV+tugtZiZ6ptqcV1W7ru409KP2sLWug8Jao5P061PT4TRkiPEJmpHZKrxGOvzwW12kcSefEnrXSvPXJvePjGZOkqZ0bc+DqGxkivReSBHmlnecoGh+TPkIxQ70w6C87wQUuWriu6/Yj2KPIM3MExbounhI8mwjC/EbaUYAfU5bAHlXeqRJato9JOh2yqvTMLWzoccAMJktM89Lr2uGXDoW7MaHZ9yJ96WijmzohFbmjMXlKfziBkGTuUQDiUr2NuCBV5JV8MDpK/V9mFMGyRCB0LR/AT2PtKsx6Ee/nXHvzpZBvm5GVDnlxc+uSXAvGZScoJIOCKrQ2iWc0xzds+AojBfZdF8JBhkYQcX7MLqe4pOU5Odgj8EkAJUwREyGO4Gr9C+Lvj83lbyS4pug+yGIAF4aey6LWY35uGNsL/50NKDaFn8FjolfKtn43L+sGaYTxnvsVFpJT49cNzKjxs7zrLevKkp1liJSghSUZ9kS3sSj3wIKFtiemD33u3oQnC9N9CvPCrVxdA8Gz2nSmKMT3QULIXp7BSuCFoP+ffzUF+8Qh08IFQj5vDeo+VFoRCXKEoWxJ10BK15OsOssaarsSfRE7SqXmtg+c4aUDg0QJqgcXnlS2wRC8fqwjeqcfvWnUqrkp8lkQ/E4V5OKTo7ZDKMpvrFBfY7g/t8Uxfzi2iRPMY5EMRx7kHzttc1KYRWNXwKyeypIssGquTYSeJ6zIEA7VkCfZLoxLx3lSeKfQMjS3Yo1DsT08F0MaLlkYQvmAxhzpohkXa+sOHwYymJC+K2/FLxuywdLA5Cv7IdNEGVN9JFJQkI31m8nmsTwoD0mpKxI9YrlxRklEZeuHU2QYYVwK9UG58lPHAuMKJ/NetQws9+LJSOxn+ls6/LXCbmswtpN0Kq07qBTVI61L6r9yYmeOAGvwkF4TdqAe/fIEbbIT3oGYYG0et8kikpIFt1OTaNLKqN+3R+mZk3+cYf7hEWeGcb0JH8p2N1/ZMZ+iYtrs9/W/skoRDuk698hlaIx0zUpDB+UxeOa9rbLcG2Cw6gRdHYfAczw1WAJCflIev+3lgSyHoyUtKfGntfycSWQc6fqudMss45siIwzmxViL0oC8/jxngQubLoNZ/aY9m/IIRyJBZJU1O/ddIbkdca2iC2RyAVEdBQbY8jWnLyB0jgPZXo9oAdVKQrSGsETgw5HXVaTQQSBQMhiVgQuIkljyQAAr4fj6b1nvG2SrCCI/o8WeCLSoKD+UfZMBFN4KkCW17JQ4UunJ2UhNl4RLFfR38sE2zAqbHuug/V58eiRztjgLqRrgArZviXg8hVVJqZYY6eRM3ZbNqjSvFSw+hexz5vc7+/5yxr1QSB8iVWDEYlxd1ZWn/eHkjE30dI9GCD+df0prqvv9A0jxVpujYHa6BK7bmLTOljbU3xQX4WY+6GnScaoKLVPiqXgfgiIenquK8bw0QmyidpFhkyn9c3PQQb9bOWZelBQpxUZPjBufccaG3Ese81cNPwCicjO5lkzoxBGCldxcFea3a6G4mt/X7XFRk8HjtAIRRuluDVwYi8woMM9fi3PkNtOFZaOXxWi68nkY2n2hZXvY0+JDCOIl2/ZSVTqrT3s0FonEREDf36NPfq4y9OXPUXayP22+CiWF/36C9ScgE9rqTvYY5xhYPjZWRbmvlxHEETfzdEEllM+SStI8IKWSiUC3EN4NbzX6m7qDRhzBd0G5E6vS0V5oIFgyJEMhOIlGnxS1xA4mp/4fXKTVfzHcupIU1wniR0QRP0UYNw/95wA8X179lkfGFfzMpw/BZaxT6zrM85gQCrsoVcxfXtnIpqP5DXyQjbIggg0LzROK2eRGTrU5wguDD8Mi+lgmoZwVDBiHoSYP/ZwSg+INAQds6g82+C6heQFN63xbEjTVPFJdG8ktKBNRYoBZ9rMbKjkjdd4Qf0U04aC5MPku+h8fntCNMt8Urb6e5NIKWuVJyNHXTHq/nzWb3aVAUZ23KqK7BXjRdLSZrQqy1DZgbY7aD14cIWfSQ/AC41WUxSZzH1KKU9Lrv0FcOZsba/s0bqCsev0GRhRH1jVxXleVEiEddUd722NQLkb217JWHeCyYBfO+tD2U8kZ+gEzBzRklSKQa5CkqvjfiEadrSoy3Ycg6OB7TmGaYW49YRo/7wdXeYRrgqJZTRf5dK1ATUfLBpmtNI5zY0G5jD49EboJo/IbbjypvifUdMoZRK80uspP8HLh2PawaEBMErGlDi1zTiBOJAe6QYidKUxMpDFwV/57yFSPSUnrN+mtG1QNaeN1+AL9JY9qhgJQn7drMQZHBOqykwXnc/QUqU0+MWLBweHMbpE4MdZB4Gaag76qqrh9Bieps6/J0y3ZNsVMoL4EXyBx4omUSjpzRdUQOjwBDvPxi0YNvSNzCsUmmn0OcUIPdA1HreE1ffXEyJ5q9EwG89wtUMz+kZ1qOGkWfuiMEh1dZmg0O8hfEf10v+oFDi+yOJoG9ZDh3sF3iaGwQCpHXlmX4C2UD2D/iQDlm7VqWZb91x69LqJsiXH05alzd8f88Rb579iQbBui+GCcP977D4lpGrUQBuGwEIvQx9ATGChAvNCFnUVn81tD8RwzTYxFkZZR+tXfw5vfhS1II0SYFmJVnrcSxORjus0TvSsRLq95k+OvOMqNbloTpkQ0eUKr251azDPgK0hBOYxSlNMi2HXCgLxHVKhuAomAnVnpENUtxyq20HD/z0jVKqzVnDzC8P1Tj0+0bbuAFYJo/6mShJTqA/H+m/JMPLVNBpFCpedmTJ0PqLUDNyZJH6pITxVdyFWyoj7SPP2BGp/DwTk9fmyouzTulArZYbkXFZ4S8FnqhOLdSD4yF/GADvN8G7IBMLyG1EWAT3FWbnPhofzjoxNuHzU+oMWMeFgTPbP29hsjGl9ThrFvSzTkh89l15nWX4729yQk954xSQBV9hUwT/qyIYCufm3EylfkSEBfS2W5iXuT3K6L1RGkp3W6O6Sz8qdWu2xwyTYyHFrk1pL6Nu6wyKJ7vv/cUZVZrNUh1zh+yG9UqNO/5Ri0x+FWZT9xtdwZPsGJAlX0eQrdCnpCcSLyGbSAj9fOpbM26KhMVWl7LzrtIeDqNAvzNK5dtb7+j+z/eumODZGS9708QzTa43KcR6z071g4WOt4lBSe+AMJG96ZbWCoxgbpRImJZ5yEx3IQEs+TkV+qG9dE1omXFzfSyItHG24xjgBqaMyJ2IWZx/H+YSN/87NOq3CsZywMYkkdAtNNb0CznDD+fCQL35igl8OY+X0p9JjnTdLRAFky5yVjXQLgNhEldXl4VmWJd0iGoX+SPICFWfL9liAjom4iK+DEwwg2XAhmtblhZEsxaw3o2/de+CPhHRTDvTjYjOlEZ5s5mNIBurb4YBcf4VEn6a8zZsL8PiTMCcCXXn47RWgzSVN28nzrCZjxRWkrbNkHR4V6mOCAOLprTIN9HDFxCqWg41OcDvyCCaY893dRH/LArfDAisdD0Sz32TzY9QejIlIyEP1wUs1HcVKwnMO4QMpNTWcgRDZebc0U6tzQPKToH9TfRcgw368SC6gvQLyzMNYoNF871mz1cMH8UWMXEwkeA3Vxcpxy5cYKNVt3GmTbGjJXZMJogRN1h+Pk2uH/1u0w2q7uvr9uzvLCS5ormJiSlLsHxoxyPrmVCXXcTlN4EV/0+myOwwv+XIGnZh0jGhJGEgf8AdTG7wpiInWHKhNKGtMpIzeIV24csRebgz2QvVnad+OoyosIWYDt3o+9HKLcvTvtwj9AmrmLGyt7r6+rao1KjzHt/AEjlWFptQDsdgBDAfTbf46JXdtqVHv9S0oAg1nzVXBr8jW7zm0mhnOhdLGHTq7IjaELSMJ1Sid32xqw7T4pHxJDfnzY8QRjidGGdUcU7u/zupvuYHghdG3GRh6Uj5tG/mP7wcLiy/r4gpxLXkKc5Zb1W5AlM4wjJftom155xeo/KZEH1FoTnGFH2IxbfWNV/PT+VlfedirEKslHuQs/EhFG1hCZhM8pQ5XB/xbvaDI3FMADmAOmNyHvz1fxxuvOvfB0GZ2AGe3qjMVOHtiMMkF3oTCFMIrCuqrYSCmllsyTI+sZKivOAwGRkl35AIQDvhJybC2u+wI0CafGjV3RZBvqsLw71/CVdAmG09YUAdb59byYC7M5w60e+vG8CDmu8S2oHYn4mLnDPbddklOQ9pBXRWxCCDdGhRz802k7dpHLU51I34yLqW3p0r8F67u4OkIcdh59ZpYxmhekpPaSIT9YkNdV67fEd/r83MYtExoZpKBd3fKXeavZDM5ix+CkTDIzkoC9KJSWdI3n1d3PojoPLHYMItsO/uTQWXbVwofmdaM+izV3lN9m/ogv4d25+/zpzOfD0wNz+C8Ti1uLW+DJvoOK7sQFKigNoyAJSiOsfQwQrTyjepuA3t78YHkK5eNPRL4HxxsEAm4UXbXVEwwk1uz5gSKAdezx+dwXqFY7tJ7t+jYJDEDhAvyArxq/IwltmODJ3ZkI9GsOeNm2BNVUGEB10Hr169uqmePdsFmUiHw6oPCPWEKWUA9PLlhuI3KaH3nIWtv5RK7eBfSYZldasMSboTU7aUnKZd3cYK2ZjxQ8OGL3jy+SE+SGmSXwZu33NUIZg39642njxv13MMB5eBMP+lRJY8plzA1xFtdys2PFoZkUAsbcWPQ7SuL/fDVIuskPJsXqW0qa6tCL3yedhKaEzHF/N7vx2p19r9koUA32PYlzhVmYhlLvPf0ve085zTG85tXeRGp2zYDjMQhN/oIiG8tbiT4UvXkMim69Y72N/XDbRfnQKYNaD2O+0uDqr7YQ2k8qjBpYSwuTV6UjE5cfTJXofawvEpm0gvh1n0Vzn28e2z7GPoh2CwM+wq+lvIBgUny6ssxSn04WNWLHk0hHJJ6jagnE1TsyowEK6lOsUijPFlWOXRKzYJu14NgpsNufAcfF7aSBgGalTqa7NDX0HdZBeDYwA64AGiDog9d8iEYCmCEpbcn6iUWi1YznTUAuhtwyGMuDPb5ouhQambhs0Xpcm7qydRY9y/pxjSSNw0zS7iqpEygVFj9XfAM5AAqSliAaFOfPDWZi7Vxnjwf8HPRZ3BDgNE4X/8UlsbkXKLl8VwYPUnrfry5O+sTZUGGD1i9pVCD01B758zcg4ILzx0R3+fGUDhkB4aMsdWqCDuvyfdgU5vzSfh5S0eeRDAeGbxen+hJZZOpvtIZrlYs8RWrzqLeDvYYAuD3vIC2T75Kyx11ye7cnKFx26135gXSYRx+oTGb9niQnocNQabkOz0Z4D8h7EhN2sVY0wRr6A2Dyh1xgQ0laOjTV25wP9CzC5neeRYw+clapiyUkzs0r63ct5c5Il/eNralHyV+5RItdZKlFkf1cOQzmmizO+4z2aeeiF5gywKAu8NT8HHD0kS0xgD9wdPv4jdHJ67lV7q4pAAfJhMMu5IH7lhpVpKhBMpRO9x/6iKz7/C6iccBCVxlYk+5ap5CcqSfJw6L/z0FqbJ+6l9dnW+gVwCr89CaFAJJXhkaU5eHmQaIEfJY7z/MyRXpIuD8y2qXFZI9psZrxVSu2ixxBXwCJbQivtHhirvoLBTEsujnMjNVs/AQJxNr6ccSKsqR8eMN+vIhat6HnlQ+rjWOcYS9n4N1K7Ve0QekBuWL8RS9wC+8b3ZTmz9JMO5wFcCCzkQoHzm1ukF8FJFrI+pvzq934Od8MzSwiLMxzJs5hWGrcs7V7rRPMQbixYQHpgSMCJ63fN5zhG/v3RX1qlGr/xZQR5bfkxugnw7OEnAeOcyVDCOe5eOynmg+KvkqEGHSucMmfjfFeNB0fxjWutonnRQg4Ut5jGKEPRjZbxfSLe7BQktIIXTgqp9EFncrDBklMSewPNpeuGgJzpvVFtkAaSZoGbQwuS6p1XlCnrx0ljScu3rIS7SmW/ePJjbN7wPpFTepr5AfWFADxSuEo242kiGSl+VSZcAHGY/VuwmQYZed05Jyx8cjZGMHfFGRG5BXeam051x7lGIkahhKSqIxTwek2EJKUPc/Jy0e+S1iBFT+ApRR9wnW/GSGiCyuIIZPn+fmnhtL8MxZ7eyK6Em46K7LyWxw/E5Wys5YTTKgvcA50+3630ORHNgAI6g7VrTfFPlgcpx7X1E2dz7FZ7t31fHzlrf9AjROPd+4Dylt9LRihHpJ+5++DT2E3pgC4zMVCwIqG6/8NwI4bVGgr5sLgrhJSIQ/xng24ezwhlzldfKpQHnTNRZszF6WiiNGGA+tUvDQhLd73E0Ub0pJOcT/axsEWEpjssABPCmP4b/owqEFqFAaihr6bZZ2WByESWsyxh6BWApYIiJLakbQc/7vc46m+iSNxmTXfg98z+71YYVdYwgKe941iXIYI4f2ADejrZc/lBUo+7ZXSS7uD6gQ6jyRHfRvaTLEHYOJiOUtS1T5XKpsEw2M0czdvl4hDSmiUKvarO5Wn09DgVo5hoX8GondSe1J58oZYvo6idyOBB4p3jNpe1KPVoUfft6/vo5Rg+gksuo7yhSBGA5RtAG6AV6621iD7L1F/dzMGWxngHlty0070aRt8cFCwA7RSxrEM7sEQ+hFT9ORCxwn1iZfoPmi/6Q1nLTSXLjY0y+lE0q0yqFBcLJYXXt081b39IT//bMMK6Zm1IHZCJem/SHQqVsw+j64tMC0vA3NiO7UQYgy4m0MTW1TCRWTnkrC/Jgs9QX1rZlQ8QNeTM4LIiCK/oj/QJXZIOkkii7VKgFIe7IIFldhBO73xxdJfvtUm9gngsmZ/BMBx20B+c/jZM8ltIFB+lKsM0SD7bsuAfotnHXUMVas1yqIEuhV5Smsaq4Eos2h/dIqUETntu8e3S0OlqBdhXMDw6dCABH9eRG8Jwf1yCQEy325XSlFBmrIHkzcJ4rB+hl58y+/+k17uf6VxnEGCcHDGwPuw+aoUAVdpkvywz+Cxc0Kv1827MyTNF7yQes9O42NEfQLQD6qALSi5WfuvGRPSuo5VRUGEKyK3egPf/7lkLdcYIFARRGk6TkBTfSUOP7Hx2DzUJVeTzkY7t5X+2Jp0xZahfh/uBQU01bQ768fN8bpSFEbRow08BbwW3+MOsPWlQejNzMwYPhSnROpYfJdLxPSaTIMRAPQM/50HGDVbQ1HtoNyJ27bGs7/IMSxdLJqL0zqcHBPEt/cuekvkwjvzTxty6jQ+tjd/aymZ4IzZnmraMMCCnC/rtGHZV1ZVnnPxlG7OMBNHA1UmziX1fkbhfdyQ6/6JTMlsz52hItYqv/8vg6mf9I1IrxA3iY/VP4YbFXwnd5lHpOSyFbnYj245j/8KhfoXv6NE9hiHHsnWWoPhpRnzV70oj0Z+NCL75yNP/D+FHpUrWSUNZbpPINNvBmJYUaXdJiXf5FdKEWq7H2HWd76Xs3k0z7p3it/JD1WQlog9vFv/vVhP0yK9By1Mj13C6zDtZRxy4sgTBU0kUN0AKEKShEKBvv+K188iWSS8lR9HaRKNuPJjf1AZddV+CSfgLvUAIJOclGzaU8QDlsUKdbuBDwbxmOxAehrhN0yQ/UvLFhA66osL7eOhjGZaCJviFeo3czZPFWYP+h/pHpYItQeOxsr2R0yaagKxPyp9Dm/I7o+NM8MyB9t4QYkwLo2XrC4r0HIdDcJ8vOexsJtKz5X8Dxq8F6Q6C4yL8jpiAbs3UXU/QEGqN+ehH9zS6genxy61lKO/MqjDzIqMjpQ0QZtPS9y/vVnUCG9SpeFpvP5R/OSHqfbpIGY3RrUMkQa/P82d7wy5+9hU9b7QTUkETPzWYBA5Qpe2RMDcwrnhUemFwFCksX9SmtzDse2k1jNyN1bSEoAR1CFYg8OrRMSzqgGGsBasToefNrQJHnIxNDgG1JvGg6KzWOWrdgZs4IJGRDBDmSW/9LGlpK+5WAsj/yu/joNpV4UcIWQMro5Ktp6IKOz9Mpiy6H3wpUCOyCZMOlOB414YOf0umIDj+FgzYa9KAQ4SXRDmcZ13jAUI5dCA8yeMfwid7WTspvYwb3J4OyU6fxTWtOwTrhDsAn9ukU601ldKZOAzxYOLUTHBgDilcRm4Gw56DrEFZ1IURs4Okyk1kO7XntPUknSXCe4jGJua9uFs4VEhaXPgdaCM6eBD616q+fTRGoALJ2fI3LJ23LGQaHoVlEVBo528MtYgHYvjDB+cwx2z4wrR5LeQIr6+DIim3BaeFIjsoHzkisP1NEku16yb7J1ae+5afv9PhVoNSdetPPOTXxP5i8YJ1MHiV4zS4xuue0nB2oeTABqJLaQHeHRsgbIJe08/gHqpIQNS4IXWFCpqARAi/9VjqAMpdG/+xHxITyuGbpg6S1Q7o3XYPhH7IIjRkUAcaQlhj4GIKyAAidCquzTO4EVCIbH8/9P8FFPd9XHpIYh/rShrk7Mr0qZPzqMMaVR9zvEUTXRQUY9bjptS39NWLLhrTHnTF9C+OVZ7qfjdlD3vWO7cHE7/6dHQ/3gdcjcn26PSDaZLxo9qwqDCgqUzuS0fdrx09k+OBzFZXhRIDMGql7JT/jxXy1QXoGsvwLyIA7clGq6JPddJ1+8+GcjMhxVOUi4kvpULSH4W7QwJySentVdGQ/ROn7I/9E8einLT/G1tIb2LDQW2qQNJ4080u9uSRWUiw94cTbf4Yn1h4zCJbfzAQ/Rrk/3GnLH4O/vHfqLCdTvgJj5PdaAS80KyaMso9Q3iD0IgBy2kkK1VKOv5wfKISrfg8bTnLqjHrRLoJ418Q555UzMalABfQr/zG6H9y6XkCYhYqAacKMCNF+FtMNydC7oEjRAZCAUwB7wXzMiK4BArxCWZtu/zepGWpI3NiCWCKr0s5J8aF2/pZ2v76zpZJMYbiHWaf20M/uxjxSTlNbY8ZFUSNq9OEWa5HP1X+Nd3fHgH/VFuI/Nnf2tG9VYJqo6iUd9l7BsQXPq7vvaO3IRNCf5SjD41zkujIIeS7JeSK0I/ZAe/4kreTIuBYhkj2jEoHqPzBLOzBM2188Y+Qtc9X4rm+wDflX1kt9vv7j3Ue4qgmMjSOe7bNLbbYHPlkvv3azl9uJFHTeOErnqJ3IvP6XWcFq6PKdw9l8GqTC2ojp8FymjJKaMSbtWmLw22LGj8rQOKv9vYNAEkZgXKqocQudj1wzxNfWrDrTGcLy0ikAOSpj3LTj5HLJ7Zlyt4vvjS0CG+tymW25vGnCOavD3qk1pArStwKwSynAK2wrhZM40sPipfsyyrh9tXHJUQcPj13a/lLDtupnWR+YKcovYAd86C6sI7K7tH+dZu6OsApSjx/lmFwpdpni7o7F4watK61QVtaTuFbyzuG614MAGgvPLQvifMokdeas37hEhymEA2AVuKE+duIchDkaCxNUtBI4grpqRkla9yUmvbxgeklapnC0qSH+kOvaNUzKCA1tXPBdrUaQSow34zcOBmXsUOJ3a6AL2AwvKBiszX8zR4XBpOhMH2IEvRTaGDMyZQ1wYMPWcQ9ddxZIs+q5oHXReJy3s1VaTDb3/jnsFUxgF9zQtsoLeI3OgANp4RwZuEEec8F7/NFAdUVeZ2JKE0vo8j23zg6unxj3y1M2LkjNXLmwV7CH/eHhR4PbtfYa0gglgDLmTPY6VyZYibx2vjUtg2n+9EznHBUylSCyN932gP72BQaNzHTvv10Y9p9GTayIyilMpg8HfSbZuHAYVLkV9GoBhJnEHpT5067kIQ7OmAjhbNlqg+cCoSOOhw3sDNPTnhJLLybcGXjdBzjLv7ykKS6RuZQxG4UBQTPOyV7fpMxOuprrBj2kDkeAApNE61PzD/im2zeEavcsbm/LCGJmHO+x2+v4thlmzut9Wo+12bzo7Ezy+AqENJy9PuZPFwBk0UPil+VZ78PMoPk5ojZqsr+nogzLZZRA1zjs6fDOAgzjRdp3E2dEV0IgTpYZMb2ALYS41Jv0zmLN1J3ee7GZ0/+/eBf8dP3WKJjKnHj01zFABmwx5tToowcm6WzZiTIUhco7Hul0aHUOOQgou3R03f7OR2NFaXOG2fcJNEq8jY/sf/zx/bVT9iNEnD4zTynmb+FJjjZZAwwo1BWD0voxS/lUbcVS9DAlgl7HyA8sMqx6mq/N2wWhtF8ycFrEkW1cqXcwvWL0Bgp/wzSEehNR8RI8Ev2ldclwzTG/EZ6uaHhLRs86CAdzfccfIPQlDAFtJKcxqWe11zEYS53xlxBXSZSE++WYNdxdEwgXn/682km5GXGF5UJDGhjpeUwy6OmR2lQS/osWm1z9XIOrjck3YSWJOVNzB57OaWPhwhyZpnnjnZ8x/KtWLPq+z8xPL6GcthLJhSuQlBdkPCoGAL1LASlBgvDRAeaGsXZeqpZVw2wVWmUbNomw+DctrUZhviFjcNYUjIGVFPxLYCwJmOyzPl4+xi/MNPi+xicxEKZyWcaerbEDZ4UqHLiDnipTLFl1kkbV479/AsSf3A9wU5+Erjh3hYeO/NpCCqXM0nnhfwsYgFtvqIQFvQdf8c/8s5iaRsbrLHTnjaOe04KO5Sc4w/b8XBNqxZVx7CjDSbTs5UEU2oBZGzNU14u545+xo+R+pf4FFErmpe9Zcp5L4rh2YuOji107MlLEkZVMgNjo7Xtv0Mg1EM+RVcmER+KwbHWVsSfi5ac6MTcK/9ulLhRpxPc9TFZ3WwNucx+DX89ogk5yI9IHJy3cK5DoB+7PHJA7n8gcQ84VCp8D4hg2D8aK+NKvB0opG3dqwtts5MQoE+9NkCWpLF2Jz4EuhPWlqtfNd21XO+dC1DYNu75TIS7uogky2v2OSZPlSSxjUmbWv9wnjOxmSR55pFzf3MBf10FDP/ylTWwN4Hs+jco7hFSxke10J+ZpYu6kx515YQO70OImCanoNgjmFpUtOODrcsCjGciv27BjyaPR33RYu2wB4VAmubFjTgUxY8QN63gfPgi9TkwrFxcXQdhIQxAzK9x2Ag9mQxWBltNgZ6KZaaODAa4L2Fxsae61pV71LOwK0SGDT4eSkAAb04QQwmYdVzFPHX2sj5X6rgjVHJIPv/SD6rqXsUv9jfHl2EzyubymfVuMZbQrFgVZisJu//wkpwBQAeYj3yekWtIJxif0/tSErMMyOnKxNu05eBkNcRPW+pCLEQlaMp6vjuV16ugB4FxUh6G37i3hqt+d0T17yN5T+4yzUvzONBMSKSlmfCE3A0rNx+HM7cwM+MmrO/7z8pDLGr/U6HQA0yDA6qjamuAk1pz6o3h0a7iPT+nfIDgiQoKCUF4KwB9DcLdFwrLPZO0RlB52ykEIK4KRTQL4mlmnksAUuXXFgBvFF4aj+vOa4ER9N2I9nldPkOpRiKrvUDWW3V8zZEsEgUyDTvEnDkQ0/plunkb2O+hdHTDYI/53cwEAGhgpEhUZNJJOAZCVm5PnubnkE4RJK2VnM9jfsV4vhiULeNqeUDtUO6WD7uL4QmT5qR6B0LrBSJEpR+7g+qzuwB2BBmnHx7j6AqKTJ1K1BPjoHB6OdXSnz5gA37jD3CXZt0ZceIzUjAFO8bd44269qzut5IiUWTMvYpe8IkKSgAtSz8PjSr3syFXciTguPs4N5acpXakxhZvDGv0xMXmQxsS7mw3dWs8neY4SwbaAqpeo1ltLsNDnXrtwD9p62ErbsCesyk5kp9Z9wb/A6utdJDcIgm0iRUHDtilYVZVlUi8zImB/cTs2r2K9qfRPbzwjraAT1wjC/XqaJ9ilFa/i2h4C1zIyOwbkaF2nHKckMln/c4R/v3S3SNtODEjS3cpEdkO9Ir4/V6wl6beI9NameR1MNlyGxUxtrZo0sIQ1ohHRvrSOpyh2RCqJ6Mqg9kFdYKjr63OhUyTbgexIz9p4JxaXMcpyg2BHye/8cKdyfJfKPoqu5bbfatKJ4W2DMtJB9wxL+zYWHyYPjBBhGthYg36Ek1snr1zc+usqWtA5chNzmIxFjXYcxs4qZLc49NYjSnZs1hzGRDqXWFgWT5gVKLRnGjK6C/dlI9Pj01CXwQv1YZecXHQcAxcARFESK3Ul7C8GBzf/eoF6AAoFv4V1fL+HIeN/+yQG6RhRh/NmE+pmtE7C8QDawsQMwYXI3DY5PbbIc60E0LMTzG5Wj5yPme+/NJ3WdHHkPVti1DNK5sEy8dchmNF+IjDPJM6A3hJUCsle6wE1N2WKAb4moDKuSH5O2BUK6OJ0XuShkwq2VRQFxGUoRmRkip9Mu11gB/S/BMaCU6OniijxyEF0gG7fgep4xEmiiJAQevVYH/k/BM6TwBCyueFX7/vVMY2mAUeypQY+Ey9zLoOXj5oGB8sdy+0YD2OhQeiJMPVOK+NuyIKQ5ICgfya5QNtw0OeNoJ5fknjI41bhf+WbN7FDKEzSRSQgltjzuwQ/j1eOSRGYz7HTobw2rwmLopDLcvUgW6ApJZPrZspODPT4cJ34ONVyWMorpH6GXbAfG0IofH59Pmgv+JQxzi82l7TU4xCwNhKVLfLpC/YUaTZtTkATKY1UabkiXYGHEPcZE9oPjMF0np/UbIuKBNNGKKXcfhpmxJ7eL6rr7ZreAcGMYOfzT4uIlMAoGbIUhu0FeGugFMKv/S2HWa5FkwxJ4mgIH7yqg6gtbXXMf1sIR7/jePqUNbZfAKo4DMwuVjCKfylw3rQZWOZQUKsDifovlHYSAdzxeNxJLKS1x3mSyGK7qiu2PlD6h6tDUr7rY+D3BTMkzW5KlWE+0LcnXZWM/sqkffqYH8a7uO2ydBTWjJU9WztAuwlODHfBKk7ATBQRFR3YxSIL8nPztvA9/XKezNUz2mcP0KQephqQvHGmheuiuzvai3myWvqhD0Y6JQFSOz4hYBryDr32eGNGVvTmP2R9Kx4aPjTzg+R1wyfVb53w3P9P7z3wm1PDjh8Shn6O7eA7AtjenClZodaKlZbA5yYAPOD12CSde5XpLXqL4NJBD+7aIVXKmelOwFL2trlo3bQTUgzwcCm5ykUiudt2e/bxU3tpN/xbC9WwmdQWgmiUPVmK6TlNjQJ4iwesE6Vg3YhtPQkeLS1qg2Jfo3ycPrL0Fu2TiPn+7XaaLnYMdH2uIujx3eEdsOvNPy6GrkDj+Gzj9UUKjQqJBk2kXT9B13lL9jvpaTRzfHOlHr9Dh8hiLqx4K6Z1e4Wp/9buZVpW4m113tdqx+LaFRZo1V8C7aossAzH58SJLZjp+MJ59KlJT0fczes6hBv21z/M73gvf0FqhBhgp6z7KQgTIDHqOoaSfnWHf2y3Lys/Bjdjf35GJc6dEDM6ALiJCPMM1IaZSMIwYXgP+CGtlB9+wsEZ4ZaaWoFdwLbp05kveQ4hGubdyUPdCjOnfyBkW3oOQvMg/kAzK+D9e0BTjFTfT6Ar1oIwL4+UEYS9Nmt7VVkMCHZ9wXzhQuqibOmqgzF2hFhKZaZqK3Ce4KlMcvR7x9X8upfFIaGkSpKvmFMRqE9dxATobNaQ3IRnhQ8R58vzHs6Loy5dsFW+dBs9yO51e809W8JhZ/ikIx3TqHgYiq6sZ8PmGXAwqiBUKK4Apiu2Tcacfgy5aHB6NSnjGrYBUM4wmKoFU1RiiFgYJJBdePL65Tu5T/PCTOUmSCBU9IMcKtGRW2hfBY6xge3j5H2e1xIcpn0ZbJKFjIwcYuGwWqAPckymUOQibSWJcxjw+Ll85kHCVwnl/juQLPQap6cYEpSp/quiH/yJkeFUIVYD9XA2DiJv/pigjwTDJzH8zA5tJzHWIO4TVGpaT//w28nO5IqPgLCOwmNpaoL5e5xXYIPPlgkvN3OybqJqx7FosomwMQobmHJ970j3AiAATEovVJcarBCmJ+ZlUK385bN5AMW55/GZJMGqvg83uRrOhIJHHu3Tlp5q6QGXLWf38Y99QL8veirD6eyGBV6KhhzKDEh+ipMbbldAwHbdZNBFrOHeBpB6OYr7h+BMwp2Hi8qNBME2/1j5bY/6G+KGmilneGZt+CuKM9bg5vEhWkl5KPpQNBs+mSzrd9RUUaJ1+4e+lPh8PUDHkL3saik3i5xgtfzk3+z9xgmf3OfIE3m7YpM6+EORK4qCCRWVQUQ49fir3CiO39SC62qMpMI2XzYwYQXDOhEqHQ3BtUb+gctyD0o6mYpqReOZwk5klo6lS8+KnjOuAeVCGVom6cPa2S76p9cJM8XE0Sb36sNEAieEJsOkYjlakU23KU9EesEzETlPGdQpO2660zweoFZlqcN5NnJHJ/N5Is5hZTa6z2uuO6dVz6k8lsT8tfv+trq2P3oc4uXpYpk6KnmmVTWX4wPb2TVxlqpnchR8iw4WnS9UnTJ6OP5uVB8fKrgTlohXyrN0vmpfOCBRZOK0y9Mt/8E1kgne46zbNE/Kv6nHYW9WmCakgPJ65UwwTHVoEa1SCIdhC2ukoAltSr4MAhPQHsgsWIS+RwHV4wEBi5MwSUGsKv8+q4qEP9vbX6CoGYv7x0LXVHCGJCRa1180qsXrEu+iDkj++C5pfGosMBfOdjmHDzjELIv1kDJ5vVe+sUv9s/MHmsh2h43h9DRVGKm/GZHUGvIunqD60LQ+hfZr1dpsqhnKn0zOOYLjDlc6Y647kJLH63b8AQsOAnEFK6QH8kHPaq/Sl/hji+gEjIdcKFIxIW0UHYZVObMibNOEs8cqhAoX6VzR2No0hjlCePhk30st3wQ5uWFXok9dKxp7WXdkiKR6p/IuBgzKVCRgGc2YF7OBKZomQF4Q9DAJotsigPTz8zS8eJIGh2ESCGfXvlk0ecE6wUsSaHXCpApq6Qquj9L8QyBrhFfvAPAAHFKa4laV2GspTpC504WOzlXFLlLhADyY8DhkxBwpYhuh7N4thudOw5ZqoLR6VVup2IWpgbmUAPd0GCZNcjYg3Awf3EJ2/YbWucvvkC3PQsloK3pizpitvF5Pk6Zg4XyUITnvmYu28zG0LNSGB6rJltTk8TXmL0cLI279oGBGp7gnw2WzXA6/9nRUuvK53kMdetQV3oj9FHJJFie8K0BapmdD9AjfZKFfwBUvwpAzTcTY9fMANmoTvcJC+lRVVUkPeA/lBrS3SAZsc4N9OHrFxY2EAmXqDtzOkHMUlo9P2832WpbSk3HGfyJk4TWzkW+edCvfIx0Rhee53usDjRswSF6zNq1zkPgNjRgNA+gtuUziiRVluGK724JReDRMOmZ3oJetMmwxlOqRhAytWT56s4QMcjpHIz7dvRLTd3vVGGMpH1TkaFwC+VRjlZfobGoTe+pvHcK8PnO9Yf9gnEJ2/o/71PsZ7pNJI8cLCiuCINYu801f4iQJE875BbudPtzAIcFnhwv1159Ns/7AcHkUNoXGszmHi8qVDRZ19MTwDq9lb//HGXNnvu1hc8k6udSDtMUoe+WJr1eeZEsZOa7/gp/MJm7a6nzZzkiQO2HUPMFXxp/XKW5j2MZX8TjpUTJaZLSMQERYDIvMb2+KjNKE0kBv0WL4ACyQEFH/IZ4xC54Zs8txNjh+9+XfRgmlWT3mBKYijkdby7fjx9Lue2kNz6xJ7zdKZKJ52vRW+yj0sOcrb2a/9uDdx3DQyW86f6c0CUgbxJNOM0D/mUFdrxTTd732VHg+OnzsHmF5D7oudk66BkcstzRmQlTUJrmV0vGCbzno7jgwojyjKObiG0gYyhaEoRHw6AI/WAlT/jtOlyMOBU+1ecCKpoErcATuPhhx4uIIIHw9wRUGaAU7Xhf9AAktjwXTX5OhgwNmnOHkqbRVWdcPzJY4iuLIrOa2CVTH7wvy6cvYjhgRR2moii5/RYi82WBI9ZHUyvqNkjHoE9wBie1zgMrmbT7Hm1RXN/LVehH4t1cz8kwHdsVkx5dwW9A6ql3Bk7Xf/YIk2DntmLXOmZ0ma+0Zhj3QQjqxOsrkyEmMjZ0BFN+ai/lhVE/esmXDDH+PuDcAPcmZcoZ8G9FxDXAYzCXWEaLsantTQatI3JglnMXxcUmqXidJOxMEM+EwKdgKhWFRT2IP+QeBNlKbUcoDK5hbvSws15Q3pylU6Wyt0uE2prolVgyXK0VcJh79B1RFCD1zp2OC/usUUiHhR4wEBuyuXcM5O6L2JneAvbn9cNzMBm6ACNhgoU5ouir+/deZB9N/dHXvvOtGria9RxnKQqr3Eeyo3wmWee3+XEv7UdI8GTb6WUcoU4NIQKCmPfkIQ+DPrWyq0mZ0KOxyTkqrP8TswgVNbwAPdb7/u60jr5wDcrzKtZSFxefv+orku1Fq1YSh6FrQJ0vLsS5zcZ58bRQ+r5u1ff28R35eXfsdw8ypDDDxX7se+5Ax/Ukva/YU38aCMLpG/mU40LfyNPTZI86Q6FWztlk3cLpRky9ciLiYQJs45NMMXtz+WEN57Nct68AjHoO6mB/EfNTCy5+W4lfMffABBO9aOMLhYXrE3FqYIJWdMRy3T/MByYWf7bxpF7CS3ng19eeeoXIKECJSZwkuhIVvy4RSyUCpuPQ/dels8y4h2bSvE10QOzD1tDNmlbahdijg2YHXf8ZpHTpnTejoUcT3Z1OPYyS4vVmDbKbuhB6TRGNhNLxpxNhZiJjekNaz8FkwLFXa2kWqyHG30HWtcxCZu0DO6igeQrfQng3uEa4fO8KsRPAVwQekju5lxuDN6D7iHiwfP3KhlpTMHeRLhqiuzngmG27hBy9owGLvYjzTHN3ry8K30GLrNYJZlBT1glfunq1o3HvvglQ/K+4rQJByQ84vm9rItZDsVEQHsS0EAM36TITEMeCq1ho9qs5ksDNuLdRW1JxOioDztgG408jxfMCksLF/hxZBeEDLX/03bKsYlu/D4izeMcboNCExBoeKgShCOoEaJOFldPwF8iZJ0HI56IYTJFJSu+HREoRFZ3IDf1YDhn4S3FNdEtRnfhMkJ7nK0d4XdDUaMIVCYPoNUEoo/6v59z7EsKtPZ2Xr+NSAkztCWJG1FVHCBj+7XnrrKhr3h04Uh2CipJWQS57f0xuK45PVpukcpllvd1apwXxa1zrZoqzpLGqSFCfh1uVfvM0uiuftJNTQkM6byMjrUOmjmQKUWjZ83igP82WwlvfeJB1nzBhN62AelrXtFLL8qd4DusKBuNxfM66yBeucKzc83t9rXG+rBZlKyt7sIaiXOiNPUt2oTUv1f5CDK3b6YdVJwWkld+4oL/P76ypgfpe3yxoUPECNzaJaKI7K+leD+wLwG5q9YQSBD6yAzNyvWm/jTQpZwSUhU/CENLr5MRtMU3AxDQ3JQH9xmegv15x9NAOlCTYHXyEb1TC9bhQZd5MVhu2Tnu/fuQryMkQwRjJ0OFrI6n2e3QD1BRp2dYDV72o9HWtP8Ele2Pt83Z4Twui+nHKdbMt5CoTkDeiuCNT2TiD/LZt/AvAv9A7eu10T5T4MG8TLQ0uhH/u1D++m1n2frrho0IrRzqajH1muQf9QTzFJxzYI9aGHGJTarslWYwmhLrvPtAh4grwBbCov2l7I0fBiWWIgKYeKAhVgfzYdvkq9Etpwld4mcWeixdrLYRnpXy3MgpY6VpuMfJ0RTIERy7lYRt88J90wgkP2981UTghb/HJJCSv2kSurUtj+Qitaml5gmEcST05njmVnbNBm+vVXM1dsLW5PW5rjsRZL2muBazvFDRtDl9UOvTLim91fdRLr9g4jsZXG5qIsQzgp90g4JRlslNAv4Rbvk0MlJqZf16xfMvNbbLlVinRCrauS6P6WMvlzF8id4RLe0lSL2ea2WzTvHFyponQM1rxugtO8eSxwp1lj2fN+OkWpOPKAi6tDM8umSvDAtx9vLnKNrMm9RXSZvGZkiZQLRnPUOOXEKSQGAB3h7kAzdhGsHf4DG/C0IdZ4TCGt8QInvB4Ht/grVXpKT81LoJYklhpOWhklcpC/m20T5dG57MO7vzWVbE7428qUtkr0G9KLcjfNA7CwIr/xtjFT90PzEfqNdo7ZHWzsCi/bikYJsWdxKWcoXtQ05fjCBLd6MYI06M7p9GpoLm7m3h+rt4kYIz6uJ3QTWlWbidMxz19OoIKtrYlQlrkFnUKLN1wvf8r0ixEMI0pBWRcIIbqMOwOVERAYbTXzus9JEao+bbFzPbtNxbibhBjS1tzarmS9g3uVMciKt6cKPF5DhV/mmHQ0FsS4T1h/YNgwa2yjrF9+zaWo5bHcad+1niEH8emRrq6W1hhpYanbJdzWaAcb5+RNhJudTwKTgM8Orkddrw5lCQdL/3neQ1ryn2RBM/8HT0uVxz8t5inTJnzYQPuMsgPI5Jx30VryyW4veVerLZqduFxB92ELAg/7ga6qPHoZ82ZQVkcUe3xeJblrCayUio4w3IVe+R8tlbclJpprx4xzUqj2bzsDYD3rZyVx52a2s9+qzu3+7JzZgJ5WBaadyzRAaZDWggNPVR1gqkygmHfK63KrJUD9NGBpLxmSSypxF7TuDSLfMQstOU888o+gKB7wWp2yVaNyql2tQOUbyt5mXCTfGDMibYqHtn78gsNUy9M6fvxFMhfySYys9qUFBWnVBk2ui+7H/43CX80wJ/WK7Pi18u3DBMXPgGwyklZppGUOCVxdKkl5l9tSZFS2Boau4MUY1BTCV0ZaTJHdPbT0W0VKjokmJf5MoPz5uFjeaICZTIv2Zh2S7ajYN524s6mpeul53zTE9mxHvN48QrIXR76kG4q/5Bc7YobqMIgP5BLQKv2R3xejIWfeEwaTpGPBI6gExU+Ka0hoSTGj1brDggYc9361fKwuAMP9N4BhGThvbaDxl8M/NFAFzb3R/Rws6T0VDpczQN53dMADabUlsfmrSGUUT3d31VOZEYHzSvLCj3FAKWxNNLFFx+Q5LNru6WL6ZStVSCCLn/VNvFQfGGqD0xKLKpqgBCDN40YI7TbgN4vLjQW82/Im8dO7uPwkvaiAmroD+Ji8TLOQjKQOMQ98ln7GDu8H2J9wwtk/EUHbDF0VyEzJgZSZlenX5JW4vqXUy3PlI8MCLvrslsPLg5dRcfv1JwEYxGTV8MtYl1ytcl8GHVr0xFLw/FJziQmo78QijTNNUS4c53DyPuCt3tPJcMYKQysHHPBwzNqN1tKZ6MVqaCuunGsUqhaJEHyzmgpdepPUA1AW0sVThHUfPFUF/DshqAea9iMfloNc4r33o/7BVMFLfO4AYtl0NJGRhuX30/kGmvy1FS1EL1JDw5xrPUTicyPJTJvbUNPkXuQEqh3oAtBwq5FWXY+0qBdYb8RhU4NXSJ3OXQGwS+X5TP9n77LvayofwlHMjRpZ3Z4uGGnIalZEjj2TocqwkMZUm9C38cKJI+WeHMbHvuSTPPbkgVDp0B5qcvshnSFtDYsyGKxCpWhzAxmDjTnNBQzGQzfkdhiWNZXuFFGT1yjMHj4PbVTMIJb8inAER4XnoEU3TrSkCN/Es1qpR52cmlvG3IjLTXzzWoQ/FVs4jX04Rbil4/0rcC/BrLBC+3q/rKgiOTAdhuS896xrDJfpyGiLyxCjDYo4GQZipmRYu/HY6q8uMswihb7MPPXbG9eJwWMRVPSo61ToLT52Jp47cXAwbxqvxhEIqGn+BlGt2aVEmNcSKR2Or9GrnzNq0ZCVCV8J8Z/8XIAr4d9NghGWk8gXmiOVNqavGt1X5zlFa/lGI4df/w4fIxstUmiJTR3j2w+G1lwZK5R5zMt0PSN/+vxyj0jWrQPhDdSMn32aZvQ1VpXLTXbiMy2SUEHjOeLjzAOCKJoqPCKthZjTVZ0/Me7svoPS1tdI3s2xUbmKQV0ZtmXa1CxoYriKUgC9XQQCOLYilPGc2ALaPqTHbgPz+SGvVn8/LtYq98j/BdN8ppVx+ntxEMHBk/zImoW2kOMHTia4KJ5lAydAkF/fAdFBeAKuN4QWvCZ+8Hb6udJl7vBseu7MiR58oN1rUew48t3UDqYX9EI49Yt4MLeVl+teQ9O7mJ02eQMxBZ0G9swnqg3GYAzvEYPlaGPS2zlGz5dTv0NaQzYBj+8nXeHjTcHHLVRyPrq/pFGl7yd+e27GSkNX9+BV0Vme0AbKgcEOhlJ7UGCgI7dSa588Uz/o6cqLiaaMShNUSh7TOpAePFdc8suJeVHz43c/eqaYS1xAAkZAkMLkjGbHxinKjLOat+G+Jws7E/oUVXzjgahLP9YiGG9vCUKB2vgfTaEYTHTFIHQl7B//hwwohIXuf33jTvv+omhp9SBsMytfmOGHHD418VpO9SS3QtnApThYzFjtYaX9YXgE0MbhlZKeGAcJIo21lhabsluiRLVBrPgCnUbnxJ4i7lzjIXqjGWQexVnUoT8/Gj1NQSHbTGJjzurWt+4PtphQKR9j3GU1gph/q4Cu0BhygKt8cA5CVZG+C8UCLRqsi5p+6kSoaeFTr8y5QW3Ed8IP6c6XiWFetnx4gWxKPTOU2Mws6K/adJ9Lm77qjmjZQ9jThV9MWQ2TskrZq9/5NLcjL+k9BOd9XBmiPBZ2WMNzAeGiadN7N0m2oUlY/1joi3Nx70EUmbaTgkecv/zkhsBDN5IoWdXiZ6S9rK/FiZxe1QZRUFyZYwt5RGCyGExCvmG5xPW7Hir25fzXN+y4+7uO3AoJTsEE7lSp4rXclnFggy8Lr3fRj8TbnqOrCkMbfKVDEesobYgVEkCgjPgy0XKA1v9aWNxEfHP8gVrSIwPdWRESuo5XhkwoqN+rEeFRH5o8G4e4k2ycV06fgMbB+GoU+QIT9DtpTViFnXLInEBr/0bYx5Jql3mVjYmAeEcrrC9wYPdH9+BRVMb1PFK7bwpuNrYp/yGGSWOZbd0cW4JeCNiGY4jKtrLvu+iynRsD+Y8TP/pwmCbJi/9/aJYRO0FhKYhnGGLsAcs5mVNGuIuFSktP65SNUEt6jh2KSNi/hgFl11AQkcRT0T603qJNalV1ux6AwiRL/CBSA4DYhDTTfeeZ20/rgDDzt6ymk7pRs+TXTsy4GQWwbeAaLwEhFEB+2/ho+sKFyLeo6WV44uo9KOgm7S+I2vgrw3mY0bdx0JVeMCeDG3Uy1QTlmsldtRYjGi+DvEaob7A38KDJfZYGceFAzUQlTd0MbJBay/YRmZa3qCF4vnXtMPL4XCYfQjq8umAUcyPrMRf3Rx1Bd95UWGSU3yMYmkdPlULDpHiTzcCk3c7Rz3zkUuf9V2zFUdUOgAlMuk1+e6KJdrJiudkvAq7767XEj0X+5RuEiPaBMoD6zKfAuUAMN7g/c4uJbTuvq7TexS8WLfXydqgG3VKj4n8/9tm7kkQB3MATbyir0oT1TqLaQ0b49ExM4Oq0krAiLrn7UqAwNbt8WfN9Ai5WNkEjEmKQsjef65SvqfMKUFcyB/ucMgAbBbUaIM9pW/BYJ0ak08s9cFhVMv7+6ffpfKvZA9atu9soDF26eZYzUQh8MxjXD9k4PvPlZVBlWRhpaf8cEXf+nDQE1IG5g+rJU1R/Vy0XPyUD07QwNWl0mGWeKMx0rRoPNjhUsisMH7GGVPTdK3QEV5pz+AqCK2LjIxDEtUG0/r7RWFKekNThChvRYsW6aiJJtfdUfz+CdfYolPoT+2N2lgIEhhp/yFbMVWq7NYMxIsAfmvuFu2MmH89AwBODLcml5TOntbO+F0WEirBS5VXugerRQOnB8G+eGxBRsjRzUOV6IoqVOH2huy4YAeswyVK34huCz+DPZOsP2x3HhLN/9JBbUc6HICjMwBgi1H0/IZlj3NaAsqTBPN5za5i5H53n5hY9KG5z20+EJkqrqBVLyt0Ic26xQ1bF4IgLAcj4eAPChBfdSOttUO9b7WToEAablmO2ukJ7iC2FIS+3eHYlmMLIZKbZuepbrgYVK4iffIukzY/ILcAfSa/uNflTjeWjrbGrZenX1oSW/7qf7KK28j3UQi68QVMEgqOdXGgjZG2BUUinmxr6pgbpgMPYtFZSILn6xFg1maC53uT4rZW0PfrSphF70o1zbl2fMyxijh8vsroDkov55/XQ+/nwGHyy1yVjMFaOnjTkYltWyyGlzT88RIQ3X7yLMPpEn1ks3kq9/WlBX5NXDJXs8X8nzW5jStmDoe2tWenNUaKGW1TNHaaQ+fQDUqc+U0UIJXyz6gsAtZTRsqbhPJkToR8c/iovaCo6l66WkpdkJKlJVSkxLPd8IM0V4PlLlSCFzKN8gil9ai/n3e4o93p4oXPHqcFwdVj/borBCYZq6N/vF/O7G5G2ExIM1l/9wAM8pa2W8knXWnsgASdXeH4AxfTqROj8Ujw9JMD/BPHx3VqjI4dIO2pOLfEA0089fgrNUhg/w8+dc4tUc25Cqn27Pxn5d4UEGD0Q68ayqS+65lxkdHib37UXouRJtKrFm8DuhpNq5joX8wmPudo+mQmFoa01/2POxdk/xsFxcl3Fkqn6/7QhcsAS4rYuiT+9FDTLTmIOZLEROykPsiKrCtTuvzD44NC3aqb+PnwmYtjLOFWgLm9xgNdUo3nLsy2NXBCa0W0e5mUHhdK0lDcwdvM+gg6wZeYINbXIL3w7v7Jgwj3Igh9QfSAwNsEu13dLAeYMuCcFkKTXpbYj2WqmxzqQAcJuYGByuFe5AqHPTUSglqnKeQsoMZyADkuSDODjNJA5+u/uj4R+t0jl464j1GynOyFPNLXtZJAuRjnUDzOgTzZZT9pKRXkTx1D7Kck/T4SiJcF3Nd+t4CTGJxYAUf1zx1p1hB03pnUgpCrfTDwJun1bedxLb3E9IOtOGprcLl9cg9sj6PeEQqA4q5OHWywm8W7FtCRApGk5rWMWpE/h4md3uIY376ebhS21pdjDCtVrmfKsGl655N6zc5XXScTGgqTz7AiPoEMu0jH3ke7lwZRKBmjlhMtTvJ9A0A6mWB02RNSpkYs63In65iT0rqNNdTBRlp6JB284RZP/uFMRRS/uUpA7EIgKqxrZZmNfH0qu0rpfPOuEB/MFqobmCNPEDw+14LtEa6J6xLyMX73AVpyc0ok+mcXLBJ/jAp12y+DMZi0FbXDN7hWFkg/b018A6UwKD7RZA1qrPWFgxc3KYBLsmL+TVK3TfmHp00LE2/0wFkzXipDpvwqHt8zJxD4cMsUPgAFFX17U6TyHBdr8BmUJoPoTlf2PX1jpmmkp42MupSKy/IPwZG0VcAFU3W28LL6UGDJYmMlIEBzdodHIVC92KqabZ7cukTmzxSGiehFHCPgFP7gC9XYGRXIAgV7snJAs0jDmafd364adjLkzom15sXJ6k3d4lNaphoZWeNEwpVDbgJSFrBfdmB0Pnqgx9PCICuyMb1e1AVutM0dMY8lxJ3QUj/UmY2ncfGLjomW5IdPr0nsBI1vshqxjax1UKHwtbY8WYQXAu0XRkzqo2lhbTX+0NPPAHmer4v8ZwOqiJ4db97pivsjf/9ikMTtO1NEmzkPUdZL2uRlRctM8VGMIfyvDgQ4a0xVyJHuALsIP/BYZsiSPXayy5Av6nmOugUObvyYWILn0rRpGVgQe6Zj/cFBn/YVMYaTHUvTO2oSiiRbzECW0qx8pb8YeZz3Og5GaYe+adg7rVobbu0hALdrU2ttZAE+Db2F2X5q/Uk/tSV2mq1rHEV6G3zt3I/Itf/Hq6y61tCtlv+ANKqoipw/aISYeHp19b2nsjSCNsbbDoltWCqvuq+b49oOpIBeJoxee+WSWg7v2Jiksw3gu39V4aNhds8y22HdguMt0tA8V4LKTRI3N4en2MB5u7AMmHnzRA1Pc3PM1+Y17JvoDWSk56IHD7X7k/GDIyqJOiQDvryUge5NnbOaBKMFgtfnE9nADPkw3Ix0YMTiSgL1anOPLxF+BHA5Gc9YoLsf9sBax6rYIwvouPa8oEOzXBxH2ZvNNNlk7zNgNMaJMKJZJZXhviZaYNF8rDJk5+uih48QM2nTruUeXAJURl+gdA6VpovlZ/L8QpqrFjXq+Vnvua0IkkKf4Y+q8Ch3RkkKsWXwqrN6Mg+0dw0if++xpCQdsckoSEZCjZ34VvasnDbWHu0jeY33p7Qkep1l+DUG9zba0whERSZEccDrce833dn1a2TGsCxdur4caHfEaVH23f+TL9LZXlJrZx1o63Ns7Qc0SaSedeXqIyRXjJxeuqbyUxYdxQYGfPvXPZdt3sK7kJo3CoPOKPwRS0L7Gjkq6d16F/U5wlL4s6rrOFGDurzWQS6tslVwFvsaWdtt7FjZZGdlDk9jpxaVwMQ5Fgph3Ni/j+eEBpdd8lPtPyZURLsqPLJGsqcxIy+SPGatpoASReuornqVKSXUouoUxqGNb4ZXUTh0wJXm9Mv801fgZhfz9Q+aiEkac++xkB8R/1wrtgI+vzGtQhxx8JF3NS26NyFxhUi8tCxobPEvfKSA6xgkY4G9pFYHV+98tPqA5mFaMh9tMmRL76p5ug96EAKj3XomQFeQA2vUpKB+ZOCnR3D8kbGE/3cBmuFStxvFC++PpFT6lyihY8y0/SLqcJlV2J3FicSgbH8rvIWAkYDOkZsUIGuLx9nOl2Gg986mfWF8YcXF8RSLaDK7X1+yIdg2zPTGCQZp0J7kx6Fi74a5Q6UIfW0lt+wdsRdRe9kGiGzx2Luhz9j32HEjNt5N29y1HgBI7Q3VT0FQxvy5UwLgXwbJDS0lFXCSYqSt4oxfvU16Wp7p5MJ+kq7sBIYRaLME+a+u/9P/oPG/HvVV1amPicnVl7Jx0MfKOh6Eb62TOqWgs3eCaISh+v6HMNAiDod/orTYHMm6v105dT/STf+aIVF0zV9UCCT1zCmNT2e7Lr8gFRwoZYUJ6QAPmCeCDdJMZ3aGPAlshIzz2FcmYTameRdjWhj+6p16iC574+7gY7kpNZNgazS26JA+01vZG+Fk1Wu0dcicT+5W8MlW7Da68kiLO2eY2IXuMsUytguvHPG6Y7FRuCPM5C3HwUxv8igmgo8IFKllmFWvxB+zcICEkF6Qc8OPPZzjpco+waEQpJJXINWs0bv+xHb6PW/35siDBQtXbhiHiG7PF3wAHPJ3aRlFHGdmJDmP+zQiZEqAhsKyyLhqOnye4wnLUGb1ojdEB9lGZaVILQaX7+TWYb6K9H1ekwdD7jH2MiRFMRqPFg3xrg51caDgeFnruJdRUk/YF7BFUi61FLEB299Cipqzo0bDVTXtPPybGix89yOci2UaufJEap1Hz56PloLNrheM1WYax21SZj/Bfwb98I9r7TrFoJmQpBcEYaOBhviuKIBur59p4BanOjdWWKfDX6Y7L1dwUP1V82wucPsoYOlbbb7mmJ28vXywP6avSRv7fxTsbbjr9e1qQ3Gr2DHPqdxvd2EpDUOpwXjBka3cAbn7PKhIdxRvCQYTc+EaHDybi9RMTe8tvuzYlOHXhXRmsIxH+Jsv1zvW6O39g/br5pLdbpOVOrG2qIu5Gft8zoJq9hpMiaomNVyFPta5hoBZQJStJpg/UMQgMKB7WbBc5TF8WZp9HN9Q0JCdLmuCK9XCShGTRyHz4E7gmpYRLu/chsWuPJvUZyHB9niKKcBTaNWSRH7TKXmc0scoSRGkmuWasnqeVyzhnnT4oxhXalV11AgKyqV2wDFNVuoBoCzuq7kO2wEV2vxRzTbVAsThLF6LpLfFh+o18UC+bedvjZZXTPsO9mFVLWvCi9Age6mo89C9OwWz3CTQOrN59xZrmz/RqaMnbeZ1OV72UmpWIodS5UuK9MPeyOM2q5MhyNrY8zYHFJkZCbTw23L/m468ZgmIxklN37APntbbfIu5/k5XcrkO0lS6BIE8qhUiLYgv9+Oi11Cep/cVHIpTjj09Kso4oi3uFUcotS0gFhu/H9uNfxzvzi8NHyE0aQM/arJ2i8KF50U42DSWX1mEbJ51EUxVd0/C09gaTFbIsOeLjMVxJ59U98FfsZ+piqR2onOpMi1ahi6z7S2kM0w4lhCAtPra6QqDl2kxfx58zeCXos1CSh1U1zlgdgb1sP4PcP6DX2dnEFXe+dzqNq9m1li8mzz1AwuxEVZrsDxsYj157y5CBbCaueuDpMWmN89mFSZeirsjiJDkGRcEJUBNZwWZE6k66qXyZH9otYrAhe9faH1Mygy4aRf1uQyFaODmaTt/NAYTCD1pUUvbuQNnrxeldV69DCSn/JhXb9Ws24dWrsGNr1+PD61RhyWRstJL5U6hPGx2CktZ6fAh29aMwjihBU+BqFesPkodqTx4y8u0r0THht3gaW5M2rGKx2lEM+sF5wEOf6h4QJrNFFs8BHQFlgWqqYR+STqlxaFERW9jg/fAbKh6hPJEN/kpl4Dl14KNJ6dreY7OIGYH4BAzs308Ll3N3pD2akPPeIYGPXvHi91NWgwVxN1ChPNYM4GlC+STVR7oHpI8pEeXT/0s++VihAZcpG8TuklwX3nwfzudQZNKIGNenVDs8hU5UIZP30tnkAlMuETLD++/ik7ksS7QPue6OYAcy6nzIGiH96RMMv7ARnQBvydVeHFKYmn3w1LSaC0erbuWYgNkoWlh40S/hhFuuTQTaEPOKwOrG/2oS/hmS6iAjFXiaY60NaTuHF0jho3RWG9VxwLO0FeZnXEAVmRGktYeKB+uSM5mrevIBCBH/gJGXa//99EjqAaB/e/rhdR8bMHOyTDrjPvTUCuTiJ0dOAMeuB023X/aNJ9gqYWNmrlcQr9npVTtdX/FxiRS+ow7Rws/uHoD+Ge3ohKajbhCKwaF4Vt5f6ror/ES3opxsmm8aTvEWhKa41yOOAzrIyg4QIF8e7uW7WaZODIAWb4sEb4zM7GnpRcuMz3levaMLW8tuNBBeGhWytKN2Icgu+wh4w8MNj64rHkz2rYcCpMWegVnZlU6xp/iJACI7EPPWKiHuEDk61tHn2RoB4E6lkvCFMQTvVDfmAg0rokUe0jnPXvGBRjjny4qPqhYpJ6trFMp3hVWmOA6iNqbv/KHCOayLW2b4kglP4mo1B7wdIMKdvsacWFakMHA1AXuw5UHvpSXrx7vnTkoskglQg9sSLneVsPYQcy1Mt0PPuIIGMD1dxJYg/+4b/tLh4cZoUZ0xsgJ5nW4G70ti82dZogzIRJCAvTFg6P8fJcozXr1w6Ld4bhY4lY7F9nwWnfONXL6ygJ299bm50YW6OvoD+5TaXH5cz6xMJ9CmEFXtdfev+Mtk6MgYY0S2q5vStv9K4vGVwN9/w4zmU7JqNrACcZ80ZMe6QzOjogwR6ACXBSjZ4LAU3mqHXqCjq+UKuLI1LkBrCwDc7DJVwk0P39N7WGY9yi/tSJ13DM1cCobIZt7FvUsmHdoMFszD5NJ+79sqoSiO5DBO5SHf11rLv1KtoufQBhPxhS15aSsiYAfWJkDtzdtkJz9We2pwUnaHVRrINbvd5ZDr/s2a4pWIyjowIL5s0s9l4S3z/sfH/SZFsT4BftxSmUU1dbtkXQnKm86Kl4S5ffhuraPeqIKwbFxYp78hdn94PsE0i2fRADVDTZmpBCrWVwUVbPt1srvQCqS5quoWrMCF928PgN7D15ldWouRsPFBbF1cc6tIsalzAsJjDBtka9NEcr/APyUwm1uVdBhowE2AWLbFfCwSbsDHr+XOr0C5DhVjJZ9JJ7cq+coC/xbosbyI+eejRd+A1xfYppRKS1H56mNECN2yBie5cscet4cmEcSMVV5Jx3NxRq6uu7hj8UmMiZnP2/ZnQs1bfrWCQaoD6+CIh1/yXP8PsK/GekaYgxgl6L7bZxElGpMuRhNsABM1W2XTaTUz2fByGS8+aD0/PkEFD5RNwpIEOWZwjw/Qr+BeqNKcH4PLh5+zo56y3G6RRmjxZ9moqmTZqBuSBm2bCetI2goNZFQpjZmXsxlyPYMfatBKJ/Z1ei+Nmmo2ToFzcc90xmSn6V+0DB2LvUONiRezpUxXf9X54W4fIjWe69BiEYD5Dn7k0M7dErr6SHkAscOkDqQEm97NIYCSDEQCAXfGl10QmutoSErLqDTQl7IDcyqMSAniNfcmNABOPCTPihR1yN5+UgjSpspxXfVwsUkoC9v7BuuC5o1oVO0e8snsqYQ+1o5iX0CmdZrUkrdKEQtktm9lxLXcXMND7v8tb4SL59CR4+MlQlJaSZgJ9pcR+RPSLjRGEkUTorMGshVAV4yFdbMANKmMD+AWCa9BsOxBpD90iDl4BwO0fKDtlmOgF1fjjygGwoMknV5bWc1HebQo0qbCpS54HYDbkRZMRvfNQEvRI2JP8Z8zNSomdGwV1q6Ds0UiLp1NJMlThJ2mPN3SPSWeCfPdt8BdJdhMCWBTxdy/y/CwtY3bPQ+fCrfftrEg3zXDaaN5ajVHg/HLbNqIpNw0fq40nwx9dpcWb4Q+486NWD3HK22JRDDV1nhHVZJVNvvis1heZ4JObcEVcuSpf4mw6yT8gQ/6UCe+4WBYwAYODqHDBQYnSY2HUY//QvqDC1X/m8bKge22w+Szp950V5hVp8CU2oVAWYjiw/8NT2dQYAngWzqf2VPDmvGCPfp4QQ0fEjGQpOit7Zlgb/rDGOQ09SfyPKEyQmIZtM5btaE62GNfz74hY2LQHO/jH6syovEJg1MqsCTlqrGXWymxaDPoNblkHpop/1UWzWvS6i8x8lskPynQaCZHXYUTbmm6rcLGlNswre2DlgX4Hm5ubvdxkbQHJ2uN20Va4WvW2iqtvQtyXjNtJz9Fra+qqxBQH3urwn33ou2Ke++AZZ7G5SD9ImunUqjeCt0u6oO1phnhrzShnRJEpyRraeFd03foCpKR0zImcMqMU1QyzdCit5PqziUmreBQfjsc3j6FnLpaUorNN/34TfU3Xu7e5VGqGtE6tlc4lU2ZusIa5BnUGqBDeiflnNmq7fHHJg9n9aI418eol8yxQHOK7SohuV2AVeYmPyYqSPwwHhjKWMOz1BVn6XGZd25zb8d2ubjjsmcZJbxja2AD8CyeyHZK8B5dKvcVom23k0HVYDxT1dxxmdkgIwEqsAfPRuWhf7Lfy8iy//i7b36+FL9kZW/bxp0xlCbe0mHPaipa0nVQS13yhOy8u/91WqAwYOlf39xoxfkmeYQg6oWMz+xLMJ58XsRyEY/kF9CxHSn2lVir2cYZAAscueKDSRtqq7hvHrVlHHe8Bf+P/5wI5h6jBG/pVqH2vF293v3UQUC49Y4II+uhimACDu6GI2lArDHyUQ6NdNBAlhRtbuTSVXVJlnDJxRRNuo7vGqmcAqMk753z73yrzXKwobV0zvnGIBBrmIyQcLhFv9KxSSk/z+Au5czA/x1rxc7v9ckqi6g9pnuDV6KMcueMSqKVfZ3o8Mzp9Wx2FRg1eqtqDgUpCmGe/imzbFKb2pI8EerQA1L90BEWPm8msuaxf4gIzVVKxYm9EbcQVzecXR+Z46TW1OVl8ZdHsyyyBuLSoFrhZ6kWuitTob6gTp87VbEyUHz+NG/I9bmq9H3Yt3nmYG6YxV4FkALpPFkrpZR8r/Wul4g0XAlzUO0s+UzaaicCJU5EikEPNXU7cTe4U0L7WFVRHJ++ISnsMlFGfZfal2GH642aLKqlCZlnZQfwtVUGmVPUILgh/lJN4gSQGJ7UwfdM4KQ8VhVdtyjOBlYdhjoGN5+aQsopexyDnbLTahO3Qko8OWolH3uTXRgYWnI4IGuqZtMtoPZvCVFFxjO0O8OKuzatUsaOw5Uc6G9U5DGk/esJSss1gG85EDIJfz0OrV5l6XlNMr+PbWClKQQ4ytwsuAWwusGw4gItFb+k3CDxyiJRvFRmVK8Z97kQKESoomUelH4pL+nKDO2OWAhnJWHm+02yM7cv/fGQ98wcMTS5pgnqlxW1Xxz5feORYuHjOcNDMvG3hxCbPI4nDdVsVNZBac1sesroCf8NrT18VwcES7r6mA862qrOrMcrLuZadDsR6HEP+yRH/eylPlE8PqJxlO9zAldQd2oQAO0QVuV2upOVaJQk5V1I5WS+KGyWZmAdPiWodXYS8TEJ6g+nJiZxcc4zSIBo46PWGB9BijrKQ7QacLXOzpyTlvOxOCz8gwRRqP4dJ7xeoekleJP7we195s36mFRje288aPVYqY6DW2p7UnVEIiHgFovV2cBOUtdTx42UC/69a7fFgLiHmme7sP/LgwtijeSEazKBtB94mC+TX52kyhqfx3Hoih22P8JwmjLmbMCfv2HJ03HmkbOzfzrFeFky+gZe4LGRynG7FfJKKmdNnJDjRMsydCzTQS2xzMkuZO7l3Gi10H/qTB5zMjetg/evndpERUKwA8Oh37wtVNC357/5jttiCytXCcHzSnPwrxj8ivUFesUc8I0RM7REz460Wj4X/21gRfG4qHm7AIdA1UFaOLvCrTsOXfwgR/R0xLrn/cz/GB3YYJtQtr9rh0kP4OxVfHeqeLtyzh7ctELziysjwE67HVSqQ+6Ey4ISsNtngTc0bODsN545lE5ChwGWlNmPT9T5AD+S2/gx698WVXEHjkK++d0dTs4u5jCRC5hlrbgknsPOBElGmeNHJYoLJXrOblPouoEIQnXdlku9JGTTKsz2teuCLoH24rTkoc27XA2VwjbD3WNJsJgWkzRgbDedD5RfzjU9uVpI3M4EqmJgoP4j9GBlb7sbAton1Vi31Jy6tMbWg+3crI+Vv4nFbCctEpltBfFIsdlPDR9eDspupHMxheXbiYAjwAzNnqEuX8aIiMCoULE1Yj5CLw+IJ6W9PeXE0eQ9msDcw0WETSub2G4xLITtkL4aTvMc+Lfy/QSKKWWvZyekvVUkEWT5ujMknD+kTOA7VwEBs3Xpz5GhG814ql/39b3NMg3zSdS1NvgWAl72dTJql1E4R/WoHKHuRRWF32Xgx6Ab4kh536CxU0JtuM3zfQXzDx/s/c34xjPlqr8XsvYmCMmOwIppNjfU8xWcEPjbzT3H8XWzjgVdgYiUG8HwWhNeYzd6uITjns5EvU03iWxC25ATFt5Nvn9GlsFvqmOJavOQtVkPUDSX4RgYQIinvYeT9tUnNJpSyCMt7mnGxpXCLx2vjwC5fRTPyk6Ue76j4i59P3TXYbhDzP0gQkdPQ86/Qr0SQbtsUA4b+/Edo7bbT4wzPHtxjZXLCNzumvY3XxsE641wrRM6KthRZo9Cqi45nHeqk0Lbb8oZoINZ9q5HqWNiG/jHDV6hYbilbwmHWKd8kwqFt3Pyr5Q2rAoOsWOWRAcUd2dOumyq6i02KUI4fNYId2Je+XMM9acqyQRR+wReLvlzh9TUHdXAu+b/WuC5Q+AwqrzYC5FztbLRjCukeCuD1sbxz04WP5PpHBZ+eHNCreLytVstx+BzLrQ6pEqcw1aGKonGA503H3sL/QCyiByFq3fgDXlhJJG0hVkqqXneb5z5riqYmeUdkk4mnsuk6z+gRoi5SHO2uU/gCZrgtt7f004/8qzwThHgvdEqsjc7e7JRdaAmf4V5J7AF/JdeOPHJ42U6hmkwEK1n9mLTRXpfeRtliv9wm3m8xx3x3bmMqzAklXAj6tCqOrW0jZbnQhLK/aHjnFB5P63v8KeiqfGTo5lXQ7kH4AQCYqbTDYdUMm4dH6js/zzpI8BkEpdERSKh8brLEzR7jukzR76IeTfmcBvjCRthSZscj014E9h74cnFQl/RmlH9IKGswlUtyHOVzxGT6kqub7tcttxB0nF21CkTFr7OSskfqjivU9a6srPvQg6R7iGMb3HUeaqBZnlZnBuO/Yleq2j1Q/z/j3jgq/jB1FjTWyU0BF/ZwGX6KObUH3ySQB/Q4MgISen+v4NVOM2KikRoJtwzJevxrrze3K+lGSnxALrPWNQi/DdRYqtCZJ12xDb6iN+SdRMSGvhZiVUYtnDuOCCOIcp0989URxP6ex3IyeU8rV0yavkwTWQkEXcwFV44vd2yvrqlAFaKwTXoGEJC5LVdwLycnkPI5JpPE7909yR5/KKzXsJsy8F1HEUH+USe9/HL34NbhLHCqoCe66BW2BKVWtgQJMi66wquzHGCx1co90sI63Hap6/x36VTqQnHyIP2YEiitS2wvlLKz9ihzbR+tKJ9vUsx5a3KZ0OkDtcpkNFqefJzGvcmFsxOMaS3POivTzr3d3/FyKv172mMK+sZs4qqyhRdBrpB/KUOmx/itVMCXZmo+90MpA0tYKgpIfKXGmTpwQ5g6oWdrAOkWQpl+GM4qG9w0pNKjuOBS5J5hVEHCeReDS9KPV0quxDHPGvxHo7UQ/JOC6/mNSU4dGQfPJb4RcEDquUTiZhOJXNE5gdqLaR+H7KROCZHRTYpuOUiuwV/R40vmGzMSsGEVpZ9pwbkIr40PhXd+sO98l+44vdTZFqmPJwcQt37a4trwT85RlrkGc+WnqiOPgnu2Xu5Urp0NWeE51NEjnqo8ZD1XkbMBcLQIx6Aifhh3duWhGuZP9lggaXyKCAXzKYv4yAKNSJC4UVmmbkAG1vQBaSR6B18QaOhg482Soc7jfl6EI7nzP8O00F0vT0j9SpPQ6/0CgmMM0IPEXDJ0dw/tgG/d2xRPU0A8ue3gRXFS8Exp4L4Ef8XW06WBDTp1w3GuBLiRi0rA2RhkzoKqHBuuxnDzmzYT4JLWEBhFk5gaCYXjE3zyUAQbKHeKWnlbaPXnuFLb8lbCT/KOxxUnR344u3a0wTF9MsL0K1T9Mi/MCcgjuObDqSe3vP8emHxe3QOIokRErsVOy36Aivr7e/n0IsQDIlK9QTSVEXvxX9T31usqjSX7C6au5AHAdZIoJ6IiQmQ1/3yujbFSIPShQqJKGqQEVr2kgAQwrLhhO1Ff7RNAeWb2yy0O3fygZ9aDC1lWaht8kNuKpt9A51a3MNa2zv5zgR4/nUD+SumqqNOpCpaIwL3XFXBXhIhnj9tok7MbrciVr4wKH0HwqVBznnfLzUekGzHgZxI0oHcm9IhD/LHllcwXHEUEFiI1JGTbIe/XscL9odyBnWTnSBImL4ZXIXTF7TMWK0R169mfdoAA7cBqntTOJWUV3IFMb2rBOI7oV9NKFpPVWVqt6zLrGoBjbLuHgRjqFd/FIuH3TI6KdBZFvX0LlMMTuGyMkbtQ0GvRwIdjWR3f+PA4+mWWcc/5I6p+P+Hu0AvoFR8AtihFHbij4PwDIgvEe3s8p2BmuDdZ/i+i9OFkZ/U5a7lUhu/NlpIRt00Cs0jT+UctV7Fw6sRSgnMNFa0uTAKHOZpMl0oHQ1TlIIcUHXqG9L35oM/+EHHoaJ+B5sRmnWyS8UiwmhpOmy3sLZknlgC9HfqotAAdjGa0fQf5zIRPfq9SUggtYVGeBQDlSg74Zm6gaBqNfhMc3Uw9ydz40ZZg2TCbWXqYpXVbHksAPlGsWsHTXr4DvcWR7rUrVlwJqmnX323xc2vfZLaFRwkr9THhg0lWEhq3jO6MuwVNnQbNnh2DGsVfqp2JI/cC/RFb2uXUkTzK3nFUHJt+H8aQv1+EkKJF6tPAunJw7FiIG5HJCntmihlpPAIVTWe0LFg1aWCZIoUz7rWM7E9YFQE2sbDvpsvBrHcMgEqSsD0pw6xCMI5jWF5T5z5+ttGkOLdCZ2S+ENgLp0hjXTV96v6KA0dwnfEXjq36ageHgNIu0HzWt5fxTSsnA0HmcS6JRb0625mZ9ohnuj2NJFDz/MbKgE+mVgvp8b4v9Y1j7NitFpSs5VGl5gdPLfD6/CcNRnijE6cy5/osDozVjCJ4hWgPoq/euvCaJGBptz7o8IhnWV76Mu42CKFbUr6Z9e7DKnjAoCjR8QMslqxb2pR6hEa6LJBFhMeC/ze68VIw3FbIl8PcXXLwHE6MP+9heRCSeIJD34b1HSwq0yTZVeriyA4cinHWheTb/szIKhEVBnZI31u2Oi6xusq5Q6w///RjHnbOR/cWCMxNZzv6vU/9rNmKLKAetkKWUQiQtpr+/vGh7/WZr1ibdSnuQWWj+SkBO+++4iudV1CPOcKoV5eq6vhpxepJP3cG2Vc48M5N5cI9wsLVRVj8NRKigOXp9JokcrNLv7LnR0Zt+hlvTpxY6jycnPE8YSt84tae89fAhAij4nj3uWJXorcat8GQ/5hPeAaSCaCEUrNKPzNRc7+Y0NvX8+c+sECvEiZWcvd2/2T8up49h8N7xX387l0XwYC1dGD71g8t0sA6TdDJfxWenhxDyLUIRd8bEiNeYM1x0HTSfSdNyE8Dq+du2hbk/VTeXyORz9aAvHnWMVkDme4RkC4cxvYZoLmP6tmCzeSACCl+LQXraUJTmafeP0/vpUv7TKksgCkldRFaOxjeB74D8+Qy1ZpiaB8gzaOM3zheZDmACYzrApeiLuWcEGhd82fC+SHC5bK+JAX/MrWYEiNTTXOttbQFHWNNjJOaiX2s4JBqXCJVSlGCFPf5be4K4TnSnsaZjRMrrcF1HKcfOAlEY/ezFShVRMLV8EWlL38JyhHun81zyiIl9A4UvGMITtQWrb9zxtEV0DRpT4PxEnAmTmmcqSGOc+V/oNgoiLEfBpIEARa0pxqf7MApVsA1h7gNKUfxDqIKFwUn5FsOE8VQTo64wB4cLzR2k4v2fARJ/RxJ6p1yCv1uIQiORB/xCewI5CRWfqHWFUDmvyUWM25UvMN7l+Oc8MSteUOL/ERTtT1pwkpvqZgxKCQc9R9/EVyhZfPX9MJnSHs67ADsxYscPB+b4xipgjxoP6J39dmZ8Sl+2oBG51t8gyGW1Dd/c6d/3qG1Um7pOZlS8bhpjChWxifz01lw/AGDaKljCibWPInUhQ8xWSDWFgVtBBLIcubynDpGrPxgezlBckwn+AKklJ/0M6XkcazCT3k3Amt51P5d2OTm6gIDPzFWNSLliHTxx4u3dEOnWV9pgE/ARl1+nbNe8LJCJHBMqMJsfHU+hnziUSYJqa8rKTvROYKJB+Kl2fwRmDQMTXwLB3Tb3z4lp8uYraBFrKChPEu1sXOj86vNLykOhPN19zAvc2eBX0TpyqylppR6vU2D/HrUnpyc4DQMdWpB1ylcB9RtE0JG/U3z/ZfmqCbwKA1dtbiEQ6enmiwdBRy+y81S07aHwpiX21yLYEiazG0aJ34veM/4N39WgEBq3KOmcFf2tM2Z6qZoC3ooPoeOT4E/G9TpkgRife7myEAgsxXFMczwqyn83xdL11LZEo4Fso7InsJc0SEHm81RlvzJSBrwpV6wRUzRU0PelR1aYePLxcQxXTgix95iqNPiZXwnHm8ZkMeLlhoJ4OqA5s0QPsdN6FsijpwJlH5WylYZmSgITA6d5NiFS8DwFB2ohhVyi1PjJ/hTjFO0U2yjQTVPFH33N1lBnpI+rAi4C6tAhW1O8mtGSE6xfkA9nB8LgVzeXOq7cniLUK0rDCWyBqk4fJLA+gn6+WQGJk6nFvKZ8SWkHkubRu+io61s9oro5kHSi1UXBDzTUI5hWOfgSD0uL6i8+NAwlBQhExiOhQaiZHk5l5JXX7BAIubhxu9HN3tpAFeV+irjCoFxqgOxjD9Ge2IeZM+jVzi8j4nyZBYZLMIPUTaP3XeLbHtmMaHMWybqSOFbKOX4Fs3blN1DHCDFzHYW8Aq+qzb9B9Nw/ABUn6MW9F48H1NNSTcadjVrNiNbdOiVQzoZYqaYNTzqEngpD++chYOTD4zV6kkwhg7yToDNQQR5ZacqreFh/xoNQlHx29c9owXT+Q8+Mx7WkeFtyHIzDig8m8pj3VmbXYsE7rGe8k3mnR9lCuhbnPE9auf7gAqQUY2miM+GPZ0xGWSKAAMfk5811LyRqgMxP1DLDuDOJ5tuC7V0DXzS6LhaXIfjfiYpME9R88MHl0fdkCdqA4le/D3s2jpaflUqDFItd2ptjQUdBxxTCVH4fKmVgGlck4Yprcg5drWMzoXdEFrLjnVF1S2JmAkk2tpWWpGhR5U10kdnKSKy9SCoq/EFYskiQ3FUOQnEnJvi1oLRdAOLHECYC3riPT5yV0oYXrem41Z3IdFemk4hlAnq83xi7d9c88kItfRiq8nMQ52+Sq5AOtWt40GQHvCbiGb8UbyxsPiljifbABEqHMgJr8tMxMI47Ef9RMJWAwPyiq7LmCGtOQZHkNm0IQU25SO5Lbmq4xjyNMUUH+kHeXq0bsUj7Nm9lLakkL+dePxyfzIaccHyWhqEqnIzsetKtgiEsMbeZ+mYDWDGcBnwob7wSIHNgXIwOxz9nY8imwkP2Fgk4n2e6Jnlw9jHCAtgNYlPGckmOorwe7FpELgKgYvGOMEw1uNjCiF4hmgVgNHO974K33u4yqeICrJrWFzek6dM/ZQnK0Mc4hhMq+Yljp3YquVX+CgEUKtnddtbckf7YHA2uWDRjXAtj12prL4HjCC7SKtTP6dQt8sg/HTBLHGk66UW9RRy1pktFl7a7Qa4pzbvVlSSQet3Fii3v7VJeljHAShdG1i/JZ8cUvs0cV2BatoH2O7I7LFO/jVwGuUrS3hTPc8Nhw7GQFQubeY0gk60NQvb3vPejdxPeWM3viUUll++mcCvPQE0p14rUkv9CTGQh96VpY/5K4ltz9DJh2Blr4o5UjCyZCd5PxvCDLYxl/24m1PHl4bXchJH/ToJiKv9BzjLf+c4tRwri/YRs8H9o+uDcfPgI/zLfRboUrNnQ5/XLZ8bAgeAWYiyQ9e5kERduoYTVkDw9YzjgRB+AzPUG8ho7RvYcL9HMQ96Qs5JDncGLWHLurYs+kBveVyQGOr/TmJd+By6ck9ZHkKF4rNBNxcJDhD9FRa5bwVoyBXvGD6fLLjpoJwx4H9cDHx/znJI4CgBVZvvErLUZc6VtmtXGgQMCOsgGLPzOTYqR0jyyu9u4enTehN8LtnP0yggBsI0RilvCQ9zA0tv48OWz0Vmei6LcGsmc1Oses7ne8W0dfzig3JZNiwKA6g98jaybez7dbAqJ8QG3cm2ko1cME/ZqyNPk8RylDVMyiWnki8mOSIALcVZzuOEw9lmm4xwaXMc4LL9D8GskgEiFA8MwENWXp/MY82xX3Fy4++kbNqiFiuqVo/oT8g98BUymfuGcePvlrCJc/A1IL2sCX1+kGSwE3VE57mM9pTlGAPAe4LGZoEY7bwLUsFNCzBwXsNs9bBTHkiJG/N9Aq15EQd7SgsYEt+U1BXyc+MpMy63MeeF7vUFW21gymIgpApyQjasH+6yQ0ElbMyK7e/ym+S1BFZ6oYl1QnTfkch5KZgdvyTmqlWvw7OaPUjKFFqyM1jX2CHFCkD5qOaU2ZO1sG27KSydtOr7B9k22ZWMvbaNcj2em+ELPYR1Htg+7396/vD3MG0D2Esv9/BXmmf1xguKiT0SseZu9Bh8kAYNm6enjuKDjssrseJfu1wHv9lUd8qWYiDDwHxwj91lQGb8RFG86HEEu0JjafXYygn16SEgdCPOtS/gdlsyRF7BSW33OQlBpBRdS8AmFI3uJSTqVPJ8V3IynUame1Xa+ptduxYzvLzRKduAj5JKjfuzch8yDEs2ow5HLGNgxqk7HKiLqtU8PGIm3oMBfB6cQoSqHd6Iuv5RuIAE4fi1jXrmIoD2yqfQ/V9lhhTAEi54Gf8/bPFjYZmfQRUu2PD/fWWYCJIqFlQO97ie6sT6fTClxND9s/tz59l+YmM07Adw+eaqja2VNYzClkaGPvcHRD9wICZhnIsz86eRFnCaHjILhqRlKgYvqtqlkI1xTcEoPEgJuSuxUhnvqmZb2uTdlyd0f7BNmuMv6nAqB65AE+C0iZT8rmCG9TIrOGcV4COnb58ANpO7c023tkuKIkwcYg61OoL2TddHMRPmNd/xfZA2chTqSO5aDQ/lFTVL1ZCLWrGVF9jsGmho3cxJ3rltIUngwInLuO55kY4PM1RTpvAJQLnqIg0zuvLxm512zjjYOFdxu1g8UVtKFa99qoAVAAXRD5sn9RsljkDM42IsYZs0Z+I+r3Iyr58PfUhdsEe7ZTC+p/yQobXCtITYLE06/6GgNXLFnkmZUivV8vRZthxgk3PcGmLenhxeix+FCRf15Xmn3ja2rcabHClyc3iuoc7nH5cMuOnsgNAdiICEBxGsiDSFw8LV7m7gzZwd6c0j+Z7CPIhinosVR4aVQNvblVSozLleS/lyX5SwIs+4wCplzj2OxLC2DFfvBbZ6yPoN6tUeruFOoEYK/FXhPErppW1LkaQfBFq0hXxYG3+hX/99VA/+UqMzYWT7XnZnPkD1bVZkw+0ZLzK3NPY1m788gwcaTFAS4meLszxSG6/WV9HpwMJnzUB0fCscZy03H7XTin8ndaavlqcXeuD3gpiBwxvhMZbTZobdsofTWYGf2mUN5xxiUCzp0bsBYez+4/sylx1Sa6AnSGfN/XTxzRf3Yv27VLZOxZzouN1qP4nl7ng6AgMl1BZf/g+TOtZi6mN2QlZToPSkEhE5DeCH9JpR2iGIalIlE+xPXGABuep5trFnXyb+xjPXVI/anU9tSMvtMxYsxkLqJKGbRipTiLeUiTPWjuR3iQ2xnXBOysR2gSn52sOQNKCrsjgjrdsituaNQNhpOKc8XiOurH2oD6eUD8CFZNrWep2zLnxxeMvM6nunsHS/bMKwS9WCHWY4udh3n5vv5emBeoGUbwrKNA95tHcaTdi+xdPF3BPB7w3gngjkgYmx/y9RTugaY97AXXEY6Rej0ChTI/qqXZc5K0bTPdCT98LXnkOMdqMO3xs5cP0VrjVWrTiQc4R5wMG1U+tjQOIYxn/I8vpzoWI0f4nGfFa1Bmjza15nAARcSFvULfCUWquTc8wnuX2bsdQlKxLqNS0ltweMB5xdcwKqTre1DQUBDOeYRwxIdWLa/RYWjcpclLkFXtNymDiOXkNGpAQSA3C/orgZewv/o/up0iUJRaO/z/UEvdus0hKVZM6t2izxFq/WNl6JwRAmoXhmvf3dN27uZ36vg0NTVjJ9fPbWXCu5d5uQ2RrqFsnudXJl/n+xv5ytkdbudnZA1wKn9Zab4Rh3Jt68VONEi3OeHTEKJnJADbACP3HKPPERbn6YsEooyPKPBFkVFn+CnxQUsBdVFYThQgJvr5P4cuIX9UqKBtQ9ElBaeZjEI6rqxNyk4kBFrywNqBqJBQkFER2SQ5yTKyfFyp5rXo7D+LdqYCJNRkPLbxCRrIAysXAQfE8afBc4ozYW+evXhgGTdGQ5uKjSbChuIJpUigCMhr3lvhw/fXp5kHDemU4fztZWK65Sue8/wHDcQK5/BMp3GPc0yjUzNRlimDqk9HmTcQEl9tEo/RPpBgPIrmOtFmyK0L6kPJKwCMwBxvOEe6sZakbPmFUKa4Go3/vgoumkY15PLy37NHEuqgHcE0tHWxIzSZSrV8n+89M+Jzce60SQ/ciqf1F2EYMyff75CeA9IQYYPdtMMnNV0E/8gYC+uUCRToIQMKSBgUNXHiHmW8gvxiHnkW+JfRSIgccFJ/9KAQt/ZW99iGL3CFO+Ur0UZJiG/IUer5qQ2fSce22snjocC78kPa2D3AviP10Z+4xFEjjDBqn+1PKgHBk7+NA0fxR96S3Rh/h7ROgJ4CHQ75hWIDphnWWHxSq2jTmLLa5wTr53dbFNtFS9vDabNKS1EfBubt3XgG7mIx/oPOgIq77dzNhw3dQd77n+TYrpr64RJd5VhF2u7hFiBW4eiYcs3Ruxh/1EyftJsOoAaU/0wEuST0fcIRZYwhQepVttgjBTWx0Qbh9geKfGaA1F6LM2hG2g/eLQXZGcPJRwDegn4U6Jj86Z8GvtM1jBs6rDXohQivspGMrdgPGr+5GwSz5WggqQXX4NAC/EnL1QsVCN+C9zvTv2UO2A1Wtr4Fy9h46n2nexQu3/5MkjMP9jOTEI7xQ+rhLF+RKTESBhGxY3Ds6jLjnVco43xyJxMZXNQ+voF3sLa3/zQpyEVRQSbsRx+Zry6/7BIayi+qXWNq6I5+6LXIeFdCSW4K3vScfEOTiXrD/w0EL9TYjkje733I6Tgmyj5vUulgWjEtI2CFhZFzGyGQAV/TE2VRSPaH7yqMhwp2Xdb2XIQBGgaEbxwMOOsksFqXk5Etm5R7voyThf6P5uP5K4GaymrS2VkCzMCrrZjU35zxYZUNaDN0mEyDzVCTHF47GJNeaDBuA0iJ7k/Xz3S2+FFCds1ECx+NI8x29ZEnFmplFcSq/guQCzavTt/qIXfeTzq3SUyO1tFf+zaOUKvguBPnQqyEA0Yzzx4XNttN9DqhHZhLKREqxh95sDS3YNuEH0rAA95et2uUYbOc+J32Pye2qjB+BeRt+UCKeFo/diHmO5T/+P1Ut5IcNbyr6yN2zL+lohTbYm65piXXXKtXLQRipPp/CGt72u75SbMFb1MUWVzpkRF42rAKWDtbZrN6ciLs1m7tVtAPuAw0mSSOtu+cSBcg17WvW0DXUX8fYs1Xedr83DRn4WZjvosXVBk8lUcaaegQCWXAIE1DO5RZYcbVXCWMVTuF2a4UYAC95TtNe2Jlyz25u6C51yCxz7c8o6gFwrY+tYfd5RVo6xVt+2o6f5251190PyYJIefh/T1sd0zzqZP7zrQLD0tGqpfzK5L+LdxqDMc1LGj2gl4kl8xdwPUmkfryDtPytKc7BoM4xKc8OYeozv1Esah0DPiThjVKpROg2CXlL+PQ1dg+FRW7evkAJU6SXAdu0qCxLoYf0SfNbN0A/MV0RgzXyB4K+sVboz8eMDtpZm2LQA/IpsNUJOYKNZ02gvxPq6fPnqvrTilHdLLIBpiEvUre+MIsnOeLdLXeVYhwM+c+YYTmX1slnKMFamhkdWsF85Po0whs/4pH+w9tm0o12t+h6P222svEMhNnik0jZLouOZsF2KqKd3FIyZzvAEEwuhzstF2CvBni+KUkfx2xb2rGw8pxKs1lCkzhHJEuTFB4jNxLw9NUYKshXlIJ49VqHC+g/5tG/Ta2vY73b07wttsN0+EDDaS7tgFqv19KX36Z4reVs2+3SL/JH7sEmLr++zmaB3HWtaQEZRYDjcdnMMVQrxZy/8EaQkku1cP6uKUKgJhikc6RDea8KxB9XUH+4NdOo1SZcKvrAeXLtfiMsWFWqwwILtYtjUaR3gOmO9rggoRWRZYKN4c/xbcaNohpk5XDPzja8iIAs7ewFIDiaL6Ew+qfp2PBz/4S+k5lQZKjLVoP1T0eMWIvITOCDIiblsTFIenWD1ty8T9w8g389jgL/fgKottD2xns3xxCQTb//J60mg2LGNxK+0/TdX6/R+ZgJ7AWrWXca25DD0JidjIsvOjdzTvynf2PJRasN4Jyd0GjX0n5tuk9NmbD0jJkF+4HY4GDCfIfb2Fvb7aRuXThHsCWF298pFpHmaA2bhIUGV1uMyQwxIBuRVqk3gh2LBkazRv0Ccd6uIJ2GRYD9t8E0xrvIERsrsXxabPcijNZvdBbNqvWe725tjXMMLCBbny+Y9A26Q3jV7xBfVlv1L4isiB01U25duYpg2W7wc/ezOCiNva+r/b/QA7PO9qDY1CC5GAYaTAhL9kGjcVCICM28tGYkS7IZRfoXeSnBdr0KJrISaZLAkc2nOpm9zitmPA56F5/0bgOzURxPbjHb3dtEpCeV/002/GiI0rN5e4H0O6XKOYH0+Tkftqv42hSPtZmKr6MXVHU+iguAddrt4GzFq5lxF1HozDC3XehuBzc1a1LGPIGYbRHJQp0+6FynV2lScZupy6A6WWV/n8cBvd7XY39hP3dVDunKpK7vabdWhcUaYkXJpEkEl2fcvSqNFOhi2FulpyPdOyTzdzBQPkSpMAZQC4uPGOKE2HlwyaA2n0zaaalU80ahBJvwbu8q18bxyU5+P+UaPDyboCsnmu0FfMrMQsEJ3dyuK4CEBBtHr3xUWj7IWfPof16jd+Kce4xAJGgltZuokgRt0gtUQqQul46Aa4cvQdB6Fn/DgcZkNmBiKIWospL56R68euK4Mos/UsmyrMrRtqYtnRWrvdIvuR5ON8HjoB8z2NfUYSq/aIEVdrXi22rXq3qC4XBWTLjkbTRjWEiYnJlI4iKJAc8vK5VW99611hIBn1urZTSjPGyCxLUOH/7SyKpYdEHlt7Xo/DBcJBJxItSVRQEi1bMO+hGSKBLp96trL5SeBUFYb0Md4s4hUWHC6saFku7o7Wy5/wJpd2pA0QbKq4JMDuYixEwltqsatYvmqnKOxGQfur1bMUGnSiTFVik2Wuo9Z8qfsvK4hvq980aMoXjfzDppTssh5ZVPrwvYD/DVk8jdXHnYELTOPHx9fJsL5VgoJcrP+mYtuTo2e3leqrsN/40x+wYOYyPooU39IpisJuJ1VmTuWN81fWgxRLssaoN705rjQt9FauZJMHsSSUQTDk6YB4rwI8UvhQQXNxOuGHdUKDqXR0roEyE2AAg0I82dfgAQAlEn1aenw8bE9SyQdnnXgDuKSasPKfVJGBqt3glg2HFj6EddBb25tyBf+Dt2SZZADQekloY5F/RS6rKupXZ+F53x5tPWC4Ux2WwSv2WhS53sDu+dRNH4qsH+h6bllWlKawdZPs7qzfJZunNn6ILmBsB69WcW6aRosdTLHRmgYrLVC0Qjp42EHuSJApMIqWPeIubvs2ekLy5tZc7eVQAHRyeXJ9TIGvYzjuk2pk4/Omz1h6aee7ZFS78vh/5VBJQDXgdwPjhzJJm6iwBrhjaz4BUnl/9USqW1yeFaILTW16dwwiiSmjixukWARxUsL9gVitSgkBL48/TMFfj5cbfz6vyublzkLyQXo+h3UlLjIbLIBTriDllyYH9G9ehAyhTMOCi3Ak5yfoQAs3a6+r5q7FniQhfRWrEAgIw3quTeHiqvvpy2iIYSZenbwFfBVP/HairVh6kGDFUPAp2RMn8nA61qESCcdxYd+Ho9fJU/xFVj9sqid/BcL4ZumbGVPBczwjW4wNKKxQzP7q+PkB9KrkMTPdKO95wXKQ9C2nJq/fI+/kRY7EElCt3fczRnvD3Q3TX3nhfPkvtf6dKxbvRwrgFKtkJC/YZzuA3WwshSXWvvuiSkiEUR5B3mT6J7aovSe8JgTUrzFgf1V839MOuxG7OoVshViyDpjqWqI5FmJGNWHM+WQYfC3WH+viFuN7KKMgvfeouFQohTiPHbRsUgaJAdJQqh/KMfLahgnruQSOxtcFYS0tZpm/kSG0sblccZ6cY6ukVpQHsbWm1ZUTrYWgchJFAO464rUHhYSp3muvE9cfq4RSFdfdPKana3ld6s3Bhz9GE2jZEuoqZauTv1KF1ccEFkXZLXaDtII2ydISLfJtPowDch+bf/WqicV6LGmgbkDSzZheVmU/YIUk2xCsGiDSCCv06N2zeNuEhomZ7FdBBor2qdr0WMfHaNJbhYxYoJJymtAeDEUNce0dvKQIpSiCC7QL4puB17gL3FUMugrmfGD9MDUSl/7wz17Dr9hrRqN6FbzrSRmTma0pQKdq2e/kMv/jh2Adkwpjy/4AX+lZkE47M47RaCvqzEe1GIlrEl9+lN9G89YB4R4A5hQ+KnZkc246nigCAyDpgQwy9PQjTUYRR0LRTVINPjNyg96weckhRSWqjBN8vowkZ9j0+u5hdbMm1Nrq9KV0SgSDHGoscTcVf0oDrR8SdQeZiX+1LIpdPzM3l2bUdJ2G57+nY1N9vHUPAXAbT37390ftCrSFwne6+gyMGEDsT9CHfKMC5Z54W0o2X110kbCYGGIsG3mIhUsTCMJ5F/QIrYwlzOoYIPNEWU9+rKdNz+GWvTMqRyv9ZCMobT58wodnadBq4fR1N+Rl2RmH86nchSO8pCMcdNhfp5xTRcAl/HnqOgJNWxp4HnZm2MNpIZV19SV1Inwqz171vs/pV/h5/Fk5I5/gS+D5RNKcI14EPyX7zHIPZTMCuHTK1aTSLFVU3KNVx0Qcl2PVVd6du3Kiv1Sy5NYF2rWta0YuJspuTVErgApbsZuot1sZywa5sVnO9p3zuMnKYwup5H5nObvE/5HgUs/adAPQLDx8LaY/HVJ85psTUvbYz7yD0kNKELS2CveeRHjoVNJSroxVuOyYjjkx1sN+gWaqin6T8GmYZAs6abftKQB74170o1QBGeYmD14FlPhqjTMr9lHS44qbmWWKTf8k3h7yr/y/WTlwvUXU4LXJ66riCGH3MOChuhZ9X4pAV+kheHu7rAALswWyl0YgBlbiM1GEvZ3IAHzl52s4+xh3qdliFkG6iBCzSish3nZSxQbed6R1S/cLSZiaY3Ghv0C+Nf1YY3R4j8SVV3dmrrr3PkKBpGxhTHlCi8OP80m/VZNLiszvuu3UAInJ4JptNBoKUGOXkpCI8DWDS4uMGHnCe23qp93Y5NUT/Wm+wtlV9VsmSToiy92ClboUxPB/gKI/8twOx7bRU2uMVzScY6Fxz26zt5yTArQign795CUVR6aJYWdevS3num951W8c9CqVB2i2Es0t3OhP//DMxDCBwyJh0el9GcYsNHyEKQ+GSs04zAa3iQZhm2SVf4UCJb4OA6BqjbWOzAhboFyEY2VL/pu7mUbugpJe3xP52YYv8Tx93zEw1OiIJMRNn9IbOzMUD9guuEmFok1EPVuo+ZapNGTGNpj/ZdONaIHHuWxyL8yRg4cpPQHC8/9S2aa5sb62U+IaEgo9F5fZRXEraOxODAovthI5CN7oz+Ko/xp2DlbreMgrVlyvd2XS0FyqggnzrjWyHzXSV+n7Ids40l83Xdig6gg3nkRcPsuAHrS/IZDsNoIoyK/aUSd0E9T1OtjTfFozPoUd1LcdEtRJ/2nT4VdeCtg6EGvtFDP+gxp53TZWIK7lcPjHS4ojhoz847waZC92x+hq92VzOu4CPyuHg8eYLU4Hpdh1NRZMiuScbY2wGf5jwfoLGhmTXPdDhTfbNk8XLiK1JcE4l9IYbnlo8eOrKLA7XiNcwvbfp4okXVahJ2d/nbeDGdEwIM2Xc9bZNbjDAPbg9eRrRZjgwHvlwxPwAQKdkTruLw2ealj8BZHMOUp9NScncVrqaCE89n7g7R9XgtQokGI0cQbUlXvN3AeZ+A2Dfm926thtVay/dSRtfVv8Y8E69EnMIjPDx7t7gy0YDRgQbOrxmlFibiCn+NU+vlpWUd3JkK5CL/42JwxIDBkhd/VfTB6GQJsoYSQje+v5LR5KUK4FG8jKSX29WWWgZpW2aHSFxLOyIQu7oZg8M9N3Nkys5SjvYBZOSGOwKFLvpCcPN8zkumxN2PD47UIt6/7EiSPIZsvRPCETjs7ItQ9GIisWpWBp2h3xSVCulM3ypCbrzBA4UqEQfUO5FWSW6h2cFW7UBNPDghuMRq2mIi2MdMJkO9+7SyUNZVCG54yWbTjZAdpUtrr1tYN2MntL0OvhQCMlS7cVR0egCl0qCL9l6G+PZS5ud9BY+Cb06bR8EUGsDFz/h7mTEgiG2zt+BEnc1ivR+/Z80FimtGz5PaiLiQLAbE1C8HAdZNSTsHBygiJiVYB7/wCPiO3w4Pb8svQifJdpoQ5hfkpyIunqXMG+m8xVZl5uQXqxXQ62yRazc2q0LK4SfcS+r2GUJfH8sTbgcpWt9G8u2XMyNLYEPn1arUByx7JLX2InbSZvnhNmSjv5rbP4CZHhw0aVx7HPdPY907dYofZgu1WBYjVNR0Gvf+zqcxkrBx6yd5OddBZeRWv4QI12sUKl7TQXWzAfKpZjq6IJko5KcHXDFRrltB26bZlWOLFuzEVf2kkvsghIz7U57b3QrIjXxT1eJIssbV5/Fcg8relocVT38NaAFA+NpYl2T0Sez1P8VzVltrbuIsXNpTso/Du52D0ESU/rvu2CznQ7WLCzvngat+hSYYWPm+W++RKinVRGa1xw5AYAYutwRus7E4dpSgvLNF0LRZOT65W6y+2RkU8f0Gh8jkB0P27aNGojzpthg8CYNr1mxjC1oNUzgWt5qvo9EXh/uKMP265Vugk0rRCnry/hKVPMAG9N7eqxWcVy0zllriHi1TanoG2wNzTyCNNvg/C+GIeY4pxWZcCLtiFVWVwhpO/4CCg4AmgLoQJvP0DkO0f9k4vX4KUzvNz4QNpcqG7yCHSIv9V5GsQNr2gmYrevj33ak/PjhBEZjQqyOA3fWyf3oHbrv5DLEf+J6GlXjPO4AgJAX6SD52nhYhAPbfWxRUYOIe9zQYqXrxI/JOD74/OF1kAJfcIFx2ubD/9droeeybJZUfqiRW75RPbeSlX5xC/HUCMXElzbzpN7d2+Lymnj0v1GTAvKGciXIR3grVOl/GGbLaqg/KC/KtIecBrh9rxV0AakHe1Z/Hvd3VNsA1XL3Z/J6PLrAcuoYpafXmW4pqjOAYFo3mrneU2SpRfhv0wWVUscvv/mP266ay9Wj22Mxcp5TZHT3J2AGZcreVxwh2IOwyiHI34uJwcTTx0fNn0hvk/xnYmhYMQ4Prla7+OOVkuwGdO8SlwuDe1/IjGTn2mJei7Y0znG1rdCgA1v2UAm0y2V4l36lpZ54NAu8XcXwIo74StpqRY7p11rEGUlW1hbfJ0SHIy2JdeYTrfWSLKnXb8768PmsLnlh5uJUKdBedKOw7sPG3J3MddLZzZif26b94Raa0Rp8ZU+zqSCjMcYus3SOgfBHwi3gbYDuOKeZ0902UADVfRgkiK60dtVVSbqpZ2JXPDvNB25hAT5/E8YiW1PSe9hLa7FnGgVRizgmdiZlXflYvngsCmWBv/DXOkSE5YjWMnmD3OZHijph8Lg5VXVVyakdwvVn7Ntd/gwP6EEbBF/tT6cdhM4MghbHWG2Mh6z/fKYwb9xgr5n5bp5H9M1m+w6vWyWyJwojWFuKdDtYqWJZ51KfzQqwEiWEGzOHvkghDCDztiMj3r3+pA8/KGT63/YN+TM9QGRhn2yiOIvD0Nc2JhY1s7inMqijtGBouUIDgTzZCoPbZhVaO2vg4/9X0FV3JolpEJXS813f/oYz/gmYNq6TuwNQgFN0b7GbyqCSbtcyi2/rB7t6M2zzFpdlcafDxg2pPXq/bsroF39B4f8+prVuyFO6oZKPYm1QDhjjubrZzs5y4EatTvma7fZwlRYzgr2HT13JrWuneC6y8N5X0VyE2FNp6hyxNzZ+WhfTzW5Gg2y5B5jz9/dkw8R69Jgo6a1Inuq8rflkgqv2yuxD4A/z5dS7AO3AC9884pa8ExYBPv3akHS6fUx6qLiVwmsu38Pck8QWkRqapXwgIisyOxg9BsZtqCQ/K1VPgNM+liJGEQl0tiblCCL+RmTzuCP9BWUPW21N7TVOo25dKFY1G4x5Lf0i9tL6OkZeW9UC6Lj10iIk66olE8sYyWftTPE24YOZDFQ536Vwk8uD/Z5xI9j30F7wF2NSRnfCeaAFWqkb11ZUb8083yRkBB3qPkS8VBUbq46OYT9TPkHdQyeU1jvxJZ2VRUd/ibstOa3R1M9gxhdHR9cnoWjwRtQhVjpWm/MXG28oi/qdeiNoLirQHQzt7VPGp/0CdMcaA9OefUt/ZwH2WJGR2v1Pf3SwsbQ+GAtq/RUMFvP9QPWugftMZton8merTFHP3QCXHA5E+ii356xIID93U5PF2b60ECAlczWEy774iNtSFpcAKIGxx5EMs+s9/tKricqj2EJh1zSjy3jWy1LzqoTjW3W0ARtBe6FC+LkwMW+aINIZnph1+2PnwpvYTve8qBynnTnjL8sPeq+GeOg0UFPRnXPv9iQGM98WSKDFRhzgzwV7w+9aT5BC9QuBed3oariUDNN0IeEn0JvZYtQwPn4FriwuMnq1/MjCDajMWSbSoLSqZ/88w/NeRCFkXn2PjusZSX/+1d7qHY7uErktTGCvRscSNnNJY1sOw4ofRMgt0UTFCToe/01EYaUUoqsx8S+dhhQXCJVITNIo1O+jctCAsqjbao6ZmKbUCjYnXwgGK3oDTaGPBEjIkjHjBeGCGDig2g0rBAqH5GUNC8cAKlnhZZvrV8IdfFwBBlm2foUjIXspBVEKhkVgCI1mof8nESC0fM90S0q1unQzRBx7gA99E9k6zdY6m0JDvDYc49hAdaUFXd+qeJ3eZN75SwqyoAdNFGBVZ0z3u7kSr6E0e4Q+5ET+qR9ggsZ74AFfFw28Fr1/mVLXEFePR6Ofhw+7vsPYpd/W4IfC1KXcAxQkQgOP6HoRao6IN0dEajJOW9sH9p3AjJHcCmz7El3/BovmZ5BGxgYZD21CaJyKSIiYlhqVIgWCc1sP2xmmlxARDHSnAhr8Oei9vC6aX93W/rzYuK1qhTB68/+bfw6VRquObGyn9EpFpNC76U2RSFiZuTvB+brCrboIXZP2GTm+NAzmY7kBgyBmIKOb8DgGejC49Q7v1qltKiiRTFUQUXWzu0D33dpY5nAvml7mlLYfRrEtHiPvv8pNmh4EIs8I9O7sXlLsNFXlN/JZgkHbH7DZQPOMQNl4pYhM5sYmwK/TCa5ypNxe0nk5y7DoaHCy9f6qj7pKakXUMglsXxu+s7XEXj37i6DwQsguYfKHlbmCzcjUqZS4R3epOsAd+dimRDNiDuYTReh04ube72b7n8W+B1if03CnrcFcKxJ9cf77fMMkvfx67FT36hY00P7RaFuxXI1xDaMsoLADz9UwCooK6LintYOeMQvcGhlVfIBG3RP1QdcYDyla32Rrik7XtvUxJmjHzEegjGmExXa6yhUpauXEU2f50v8ml16twAWLULZFdpWiuHVgB/KP/ffcdG7ytOupVFl9ETQsFROu72pYvpY0WlFOwUhXGr171/JYTEs2N1502PScUl3PzBZS0OOhpsdAJGeQl/LEQdw/JRW9ebsoo0anMjvryBR9yZfA+41zE0HX3j2PkKDLv+a+ZpV6N7sRhskTbmgO7247Oa1venccUdKXZ4ZXs3k/tCTnezE1qCumq1SHAhma1MofZ0irpPtb4pW0yUdbWx4pGOA7PbFU2K8dirh0iKnzGGS6yFWWihSMlA6ESC1iIcnYVokDNDkba4J/acy3/RU20nOMWqwlxy31xUda4qB7cbdaVyVWEcM84acCYs+BHl0n09izrTXD4o30yt6tUjTJ0tCVTR1Lk+dXlgHueQCN18YM8J9QjzgVahqfSqcMX2m0unTYun9F1NK+dDD0gl+rWcF3jg8zSGSeTeRMgsW4McU4nex/Ut56HjwxoWc7O1tXYuxjk6wR3sxJpOQN4w8BmUM5a6baEaL1sTsktJPXaeHJb/tX7WiVZ/vmRvWak1xSzwjmCGbHHYm1dVOy7U8tnNPEOKhd56stTkBfZvqEqU3dXjIupLmxr8LcbJNLA7OFArLV4GVhuahnF5dJT3P8QsMlLD4vzJzjbikDMh0PAmW4kfCMDKEhCM2pvH096EQlLnmLmPqXAVYxZV9pZjtytNRMkOlVFCd7Fe7l+QA4xkmsoAyGr7bubpTltoSLlouVvCsEFqDMSItolodXKBlOaVZYvAIISMla/iYAuY4tsqz3/HjsQcMkbYmUMtlA9KDtPxj65iltE/Xqg2musfiZM9xY/miDdATLbiWJJgLvuuEqPJq3aXTyJd4L5coNKIrLgDmT5WyFjrFlfhRZN3SeveefElXDhJxlqbKvlezfhDlcL7fOrU6wGP1FrcbQL3TXQ4EKPDpQZlNy7J+e9i9Etjsbp2LmWRZ1PYJHjli91dXYVvuM0+hpr9F2kUYVJzAa61ZyDjYO28RbDRNtaTakYccEJACw7gcCdldNQ1VT0Da2U4NCgSXXDYmJ0BLEUU7kWs8nyom5cVwnth8Mi9ZjDurJsUOE5WLTDZ9loKYsUc7Tw/u4OSwoClEYLcfOKuirD88G7pxoMnSVzJQpgdU8SJwnpMiKqKWQYcTJX5QeR1b6UZNzvyr1anuz9y0fLltvbPYM/XI9W3nGkszPtlGK23aSiuuFZhhCPjDlq2621d9mjkVytXNNFHSxwn6MA3wwMkMoh67LGO1oO+2bGdfB0iBb2HoDEMfg2S7x/JKkI9SfF/KdPBSlCh4wViBVLUsODr235705KT6P6lijYHb+fFa2Pftc3z959r6tkS6bLx7JGh03f3q/gaC4agKpwJi3wQoIVS4BemIJCBBi0uVdxcjzRZ8qNc3hVhVEUTVmm7bJ+ST5Tri93H5c1bMULmtpRCFwVCEPSWZdcDNFizLAloUeWKovxemVetPN5zaXYwb0skc6BMm4jpEUvGtlMmhi3uR6PKosYT7w/6nLnNL0t/clsrxP3zEBaNedTTovGLC21ZJ+cuk8X7gkQplva/xNOHPGYvXwQ21AQmfifTOzUVcPBTRbOj4GjqnCuFELfwhzCKuHQ4TFHYzqa+slryXpvN2OypsXqxVSGq9SPqVmTBtmDJm1Uw06mTff1q6XAT6ch+4pqXwUaOsW/yzom12X1bVKUtwKNI1sLJB6DyDBCQeA5e//ptoUA9U5XjwoU+4xzlyru8b3cFp16eBLI0lG+d6yS/ibUq5Q53EEPXTSN/XDuOjY82TjCvm+drkb4yHOqgoeBf9KuPaODA/OQVL+HQADX3j4igHqnc9hFewwCQZJ/IhEshTOdiw8HMIYppeKp4FpVgoVikI4aJuB4bA7sa2m69uoTCjvR1FmmSk7+bkwlqu/kOccQYy2WwgL/Mcggic43pvE14mgobPWDkI0Y16j+EYCZnyycghApnhsDvrwIYFyzZ+FJJVoG6tvyTYFADYXel6edXQDi98lI3fRpR6FwYdTuPM47czDhHxqpiPe+oTtJ5VXXS1A7QdnwJ4I8LYI9t+s3zfc9EsopdXFach+5tUzcfrUXPfBhmGKiCEVS9KPsYJvHuDnSBCehPNiISiaHSZMve4RXpIDYFPsqs+2z08ZUUCH+VlmfPLde8PGzSUjtuXfmlQAsYhEichT+Vwy7732ilOgFyxHo1T75bvb4MSvL02//6o1h8V6EcmIBbRXc1cQI0O0x2kUVD/OUl2SSMwdj+/BxkMr5p7wIoKex8iXQKcKvolUCfBQHlSMYRQXykVR1fZ6vVh+VAheBs2i2w3xTnLY+AeBm/sPTzRrgmmIL51iHq3qvtAHtaVQIu/Y5qz0YxswBmOiefAKg9C9drns2d84qdKDfDCl8yeJvtNm6Tb3IhRHzEIialLCc43yclut94JRlP8EHdWFPhqv8+WaF/f0AM5xLr1igxlsZuek4FepZHoIHpIta1XxkGJDwzJprWUKRDGeTMV7NAzu5ipZ4DWcZi5V4cCzRPbZR2UMfQBusgcohDhnJEbrLudXmctabTKtxsO8SdUokhdCFXKAKUfxkk8IcMfEw+WPQNIl68ffahSsBDY/Z82XKNVmp7PyTZCyGbcV8p/5pR1o8wRsbGFaHsp90XxgC13oMoepn164rr0bWcGBwina4OCFmi6lpdARCPpIXfmxCVaetLfUGpvgQfucngXUj5iPz/+lWhrCPds6D0uYXg8bVOUYcqM/N4Sm33X/8N2BO3aXCKczJnW5Sv0nh+DxyYSRIHGAs6uWFh0hv+OuRPuBobmxcF9f4FpEvTm0cNfTRZRy02He68rHTuVyK3HLNGY6yfX9ALcrnAHxCcNPA2tRPjSTnX43Tr8dhIMgtlAA7jiFMx9KkutExGjSYpN5VDGcHPaDhyl0v0+EuPj74okYHDxBmnGrVfWb8D5JkbKH+PNLF5uH5ilL1tNjV/7Q+mQTD2A2SB7MMbhR478ScmwP857asFDup3I2L2VkeIpiUitoDzcqOyDysvzZ9UqUq+XBxuqK42WQrjNi651j5aao2okFa/yTlSue1jd1ymijLPhY8b0dTokMnaJhjcjzJhf0fLPZh4F2J0OjFOQxlGWFae1fTgqW3vBLFCn5Gww1dmesg54z0cEo+vpFiGKCo4VN++Ipj9MJ4iWkgCniKjrkjNqsS1oxcyIEE5kS3jVcxaTMEEwfBAJSrNw0lutQcZKgt5NvZKxvErkzpNm0DL2FCp73113lIN1JSarUXpR8RQCBP8eq7GZvkaxxVGkB6yazk6hLiYOdz+mt44I7fjtK2rmg7RqD2J8Gyc7DUHxJ1Fb1HJVJYtDWAFk+Qdq4LY5AC4OiMX6n9IN+sRrMFi2n3ZGRUcT+X744jDWzI0HmsEa0Rl1UUz6IMRtJQVDK+cSJZOSfZ0HiJ2eOBAn/3b4DpiADL2NUBBPP9gr0GMS7XOKqPMsYzPrDwVXuQyVM8HX7U0zdRSApBJagDJPD4xOwh/KcvP2HjGvHwzLpNbOueQtTx93piUJCZIYYIKb7WMTvsyJhVG2AJ951yM0CcztDBm1qdvHPtn+ZkiPWbXRMmLHteBfBWefjcDgQvfSsBpm/KrO/vnooR0D0CMEemZNfVGsAw/oTYiGRpVt2cOd2mtm1C0DnhDq2Tt5Hjo/L3c4xthIDobQb4oKmKgJxpAmtFgG1nZ6OwTZkUXfUeCo4y5HqdSME2gVL81qBz+7WTEDRxMfjTKhenPNm2fQ347hj5wZEZZ5uKEXM8QqUNooi2/PEyjz1WOFksTmqtWWVRO/v8Rd90ZKYzx9ayqdkUkpUn1F98mImpauFmpxqGujsO3U5vkmlCXJYLrg79Nb+rkokRYfhbqykZB0HqOBdDFpKbPZV+sPwHyfIZchE4BymWH+hoAcDNcaEkD02N/d+QaG04hcrciX/uBCQ3HHL52dCkXCXATrgKxmekm/mXpPAKIf/sEvV1xiixtFt9T7FDJPftVxjygQ6KkeUrZeiadrjqHZCG13Qu+6pMsGNYPT8MtrrRHGvUecG7AadnG9Z1R8ZVZkyMCFOakGMNqcz4YEc9Zu/HpIQP/493l77vHiiFRQ6R+dfNIJQC7bcgSy34yq7JuJjO39/nYKjygbeNsBQ5ca37wuHpgUv1DUi105BYyE50TlhaTXHWiiOiRG/x7DA3YK95yLHs+NvwprycbaRiy/z0BpkYITuZWu3r1aqbKCqKLEbpScGhzjJdhJWy52oqOVk8kVmDeIhIzZtHJVI2bT/b6j+UjqlEdD0xFLxtvo3Wf9XuRO/gl8XVSFu/XODdfgs7Gbk4TVzwZyYyqf0FHKl9Cwfz6bAVt/hqZJ6rafSLUfi4s4+7dwBYq+LX1BW6YtpMyb6j7WgMu+MxJSTqzcGP8q35f5GlCg3O7VSaGu4oP6PyLv1GsPnlvnchNlfSHOyY0G+OOdWQDC/dTCX0HDG211wZHpOK4yIpTqqsXE53g4iM6o73VteTaZlZyexAVwA9QhYt5rGkYHqNvFJku9OGjaI+NNFqoxjbqtkD/UXQa9FwBjq7fzxmJeucwPm/+wquORmC4PbKfxZBFTGItz25EAM5e1ApyyfE+0lgGZlh5h8qBI/7cEqvw+PJFHBlz5z95fkMPXBhED+lfVpIp6uNEFidjxOmMUMeoz2Ae3GOZJMAMGi75/7KOVnFvfOuovvl54fHHEp8HYeUoxn6Ty12NbCfGs1a863jlv2NPYL71Iv6w0ay+4Svi62zU299fwAjD654oR4SNYABTnQCmkq/xplLrFGKyPXK8caOfZACjBFGSv9OixMV8BfO7RwKDWOUeSG0755lbXQZZEYWaq2+JC7B7Va5zWf83LKfUJFM7jmhZu8RdYDfLo3BEzBvlfzeJmXU4QTlQLPLt8sjdfCrJ2jnmjKZ6cncRZHo3/m/KhFBJRv7QKvHnaepfICEyCx9wG/7rDBN6K8n90XVXM/ufaZinUpeKnG3syX/Orl91vDoru+zV0HQ6yzjNRCuFGBqU4YfqSmKpxgnV24OFnNoQRGNj1tIvAXe7YaBM6IuKL4+zPd3Fk9IpSsjqnopcxhqgVZodXj8heq8rfyM7Xg4bqtVe4D/i2L9J0dfpLXoo953P58vp/SHDVwRYn0XkbHcJivDxbznB10J9OimPdcaoMe/Xp2GsnoTzvWDrla6RhkEv/RWxibTsNf1Y7++rIeqxGPnhpvGTp2a20fTgOSWu+dnAGSnENXtRkGxtsJYmkTQ2yGREi0oSP9q7UTGmdCBPua4z5ntoxcT71Pc6PNWS0csaw58XMy5qPgB3UOKXLg5rWPr6Z1S5oGraz/E2NDHOmYhSO1yVqohwNrnhuIh02m5jJMP18kIcryW0JyfJcWJ8NkvZ15AXIEAdj5EjUUe4IzNoEIQGR89qThPz9ZYDf/u/FJ3JbNWaNXLwy0O9lzT5yUZP73IODtNc6JIR73BP4dIPmqdPgrAX9m8CcYK2ddw0K+I16ESg9PA+uR1FCk92wK6adx1WJp7l8E8nohk09XcPLKQv89njuLT3jje0K+DWhxdk1CxC+4ZaUseintqAwPoWa2AJr0Kx0AW4UTjPXwULC+rKZmRDHxSkkYKkZ5HT6bELPENnkCqxQn0T5hPTmr2mUzOzQbIJZLfy+JC5hp7rTT+kdnVF6HAxfEET8oXGPd8Yr43W2olillAlFccdJbmd8HOwqcSvdnAzBfvPJVfJLhzvB7KSF8cvGfheNpxDMCGUvzK60wby3eGEodHRaqf5clgKl2T0e1BJiOxnCTqAXnNU/E7P+sKyeJr8+A7LBOlVJiWL8/mKN6Y1sJ6cdiM6Z6fQ5Ts3B7EGfydhvcBux2XC3zafkrk0cF9p/EbU25F1pFm3rCKHUVXY2CR0Fmr91/xAVhUZj6/RbQ9qtc1jgv3ayWbbO4dSrDq3AoSWRpw2KhKT2evodN6Cy9RB1UBoD7lK8ycI4TyBKq2WEMTv0HZT7QcvRw2PXE6EtQSOta8zH+S7S9XhXNPZ7EMPNY8ibmXBOQ4+kFwq3q6WNWnyOSa50a4gann3lfKLVXM4Ky7fxpj+uMc1j9A1aCP9YeCNmrlt0VfYkdAFTWbjvNt4WtQduUOZqYOBMISo7ee373mm6J+JlmTG4PYQJx5d2oD4XhiGwC9u0fxCkX5wWXJ2PMZOCypJAEi2WdnYUFM3ZSgZ4dLnWDeZNziOeA1TQl7qhlaDhGjm7P0F6jrW9nXFi6IxnG/CuaRQ1l1PUN75V6sepXwMExrv5DVU89ts4ixykZVstNrbNv1azYpOJAZPT6hOsWadQ6erF/VGQ7g8F5tErNqHPmQsQlVUJYQI4Pjupipj6uAef/uvOo3Sckk0ddD/cvVGNJZc0cFkxGOdET/KYQ58ydVE//fDZb3UK8bRVl9Yi9vPMQekwW+ITUkmG3f3ZZjXwHK2eDOv+0Vq/Ogz/YFwleCkfq5yL7oevh5dyEOTw05xB6d+cOCYoVjovzc8U0o3iSooVXQMk5cwzeuaSIMxU/xbpTjAhQ7ACmhR63p81HEfOy4+Jrm0uLi4Sg+B1lf5DuweT322woYbaHxVSVWSZIsZTLkJiqTldgFE7d9REwmq09MXCWmige8l01nBeYwaletc4b0cnxO6VNpSDSwzuFbI4Bg1ZlSEWhnld2QPgwUA3TLwrjcZHQFVUsZDrCX63YkHDOMKhAOhRrwSEoMImN0q9ffsWlXOu7InZUy50da8W7px5Ne1fibBjyexQnTYyv+DZeUPY9MBiduL+kw7k23m5X+BCpXwi+ht4U6ZVM9azaxIS2rQo1ffPgwwJfn+g8hH2PwS4Atsab+ik29hkPmqZ26eeeUP54i25b7IznsyPlPqYyDwIlJrEHAPY2a4S0ze8buHluwQFhDRxnkjgLx0E8/XDuXT4/3Gh4fDxTeXvFdvaoM+ryMcZ48y01ne7UmtEpPpO20ZRBRhbuv0VmVNINDCJE1XenSUAfnB4TjaeV3RnrlTZ8n6ScjlNWbcZANK/i1Dtllayy9tBH14kN7H20aCS1g0mM+yCBZcFAxF1v+E9O6VrfGuEENjyLD0JO5Luto3dvSntFAEd6Ezmyh2BJBKhG2FwKz2S5zYX4eEZIy+W2mlsrEx6ZGsTtQNYfUWrW621kRlOPzGmRpVQ8KrbHJLmQggOSsnzzj4mNq4ntg4PdzNPfoqfi7q8jBS35CnzQyPzTMJmSM7pRW85wABjJuCMEGXHJ3xhanlte2UmjdPFhG4sXfgZfY47+uB+pqUPbbWeAVNF4k6FNEzDepdBX5qBViS4QtnWbLu/ae3oP2j/W8GF4Vck2sUnJPp9MN0dnxmmIMV8TuJ8tatn+oHkVdKNrrfPe2rfRLRJwF9Oacrh1fK3T+oSqqEAfdx8P0btEX0rSjF4MylSP3jqhE++/hHYx4YZCQ3Y70jksBzcgccoC5O6Anf5XoLFIBXmf0cGGODGS28nJXugJw21lgIEHGxj03Zen544oitzoNhNfziAuHg9rSwCpDjT3nra84t5r/dgfzl3nFvUIvg6vxlY+q1wHWvRhllvkH2jadWn7TKm+TvL+0Cc9N1cGWzuPWNdfg8tGl1qv5AcUx5LPKHB1BpRrcJ2Dgy8Tn0O5h220VjNq2vnQphCDeLxlwfmNmyF6KbdJDKRCuQ2jUZ87WoLqMX9Q0STr1DmdQ7bWn5DWGTXEK348dZDHybrU2xr4+mYB4C1KOTdAe9uqe7TVZ8+ce4MqPNkTo8nWY0ww13vVGJuJECGWwAm75tunI+Ljp9i6Sb7anGP9VV337VHd/M2/8M1tI4oAzR9QJlO004n4S27krmz+UvTOpd9C86hIeVJYZk1yOH22fwoLe4P6K9QNJ7i4zZnFPCaBWuoyLR3kg/pDstxJ3Wp//8lbMJqfHJj2NnVC1j7jUIt640XYPypwUNB34EJKbsJLd+G9DuIq/YWvgt5ehqshhyHC7h2YMhjfCZ3QcHHZDlgH/9si8hnw4gmgKdu7LrWkMDd+L5jg+YsZ8YQaw3Orln+neldmD56RVpoXdAY5VhSRCF5v94VebvjAAUDQ/C0M4m67rmj+Za+ewYcBOI9pLUzThl8pjA5ESiXywWPa7KsLHkVCEBCgxCw6HY8udVSJ7ElFAsGFaoPtx2BITvR3+krfoYkzd8cuHba1ARZhpw/JdjvCXHMMGNrQUozymEwPGFkiNiDqq2NGzRk0GMwz8pbQNzDjCn+JQHP070V3V1MhhXNe6lLB92wRlbajgbrijrBX3ZD3y3jPXCkjrN+fT9T7+/NAUp2IS11BU4zxOz74rl1RYniISRbBY3ODA5+8jKm8xWfEFnFqxow1i66MeoLaq98paexd1NBn/9KVqYf5RhpX898PcyV6RINIwV2woLI2er6J1JtNtcLemmI9ZeugfuART80BYgHIzGBIvpNc1kk9NhbO4CHUZBopfvjqwflXr09M5AUCpgoQXX1tOIt1RYdTnGQ1p3XmVMxmEAPaYspoiowRkLT8vaB0eko5/aA8UCqPX6feECD+p4RDko6VheKlHQxKWVGhzGX7DGESyb4lOxOMVKMtxOIdYrW5jMbubQZREKYB8Hj9K1tjrlhXwv7+Qb/MKOWMSD7b7iGE8rQCWKUzZtdqoZR6oNvvySuGcqTt8cCNYLsyw7FlovxarEF0Z6sHegLtvhUIAq42BUh8srleE5hSM/7jnZZWiLSRfaKxeeoQOIu6SAU09UE+4z9Ttorf0ezzNjHPKdLKIqzadW3vTgJgQ6QwGv0xUivZ0sPNAOu2hZTcWEv2rM4qnqu/j95Vz63T+r8GeQmYhuDAyydsBLQ6IsJThXeu4uQ8qHmym770CRQdbIZuGXUDjNTmpeD5CfQv/ab6Z2okG4mLYUB6XWniAiW/YTAhkyVxz6EDaCneSwJxNlejuV8ruIfLaoSwZAFYcB3gFzH1TbC8PBPED6ZIlpptSe5nG6kbezQ1hndo9R8WiDWsPkqTGO5q7SMocYy/mhiWd9peG0SEMB6UJ3qju4y88BDbyi2zUUf4gXpFn/qqnTrjKrMv/mUXxbYNuzaTtDLvKP7jxQ+5iNE5JuZ418Yp/El1EXJ5jyPER6AeLk+cFHXn2YmV+gY2mZTyGTsW1WozCEeg+ADtQwTSenl0e4rhwOVg2Z3WZT4vArWBLzB9hMnc+QHuhN2ORK2HV8WvFTMN4EmOumiPPsWWE6fRQI8J87gyqcHS2a69pR8WVoYLRzLKRk2Asfdd9fBGolrKRkq491P9tOu5mvFXbFniUUvKK6BJRsH79VlafePRlmHYArbJqUvh8Qm5tMeqPH4hT2Pq7pjLJteMEDc4mMWBiHG6YSI9vWV00dPK5JUtT15TKDsGSvPf/8accwCeWcxOBi/m9pcyyyuvAj6YyrUrYQWuprtPKKcq5GtAPCEkqfBxHl8M369IXGykA+mrxq6JT2tMXAkm5FDxGN796EGP1hw6hRRrlqDLWQuXRunNxtpK0X/chHSxDXN+sJBH7yedOazlG/3DdFrOzp2OkxxAUxLvW/z2cDdF2xiapM55idHPJ7kFhd6kLK3oSfl4zxAaOFlsu9M6hBYCOkm+6eL/S0kynXwh498ysUl3VCyRhbHhLVodfw+mNGwVUhsMjKFtLKyq9rzdTzl3gj8HPpVySd+HPpjKoxj+UkJ4LJsmd16golaiefokuHMb1aXM9wKslSBmeTTINwT/XJlvyQLsA9WBrAkQRv005omwYEkP5qZpIaFjurGoCILn/QurlhEfEhxG37INjgUXzLpudIsnfXQ0J/iGjFrWYScgW+GV4xKpXr0D0WXJKS4yKVd8eCTx569y1vW8C1plQii9F632e6PldpEJXUcqfSmVe82DduvNNyRBaU70QLf7kyC6imqnkeEvyUFdzQMLzFRr5D5nS0PsfBIQkz4bUMpz8ZNg9bfGWWmgt9lJ/pGWZTy5sLkW39CWWc7r/0biC940uzKE1139bqLcE7WqN/K+pGuKuwlpGMr7cu/7f8dQ8tJC5z2jRuppvG+qDqBSLeQl0pAcUbrubMV+f27HcsSyH90M4I61PoTldbwJZvWEGQiC8s7Jj4txJHiC9D/DMbO09pu3XWA0gPZZkMkiVL4b9bDS6vL0vGN6wLVSfY7Du88g3+xYoDyFw2K41fvol7q+K7vgfTKHK4bukHD2s9alC+QIub1WmsPq3JqE3p8g3ALUkEHtpim7e+I23ZMOjzKMbiCZkoDVu70TV1AfEJhXwXGMZl16mqQnspGdLg3spA5eONWahrM48SQn6cXRO7ec/BnhmzXdaeGlUAIPuqCXN8ReKQOSC6dX9nNQDZFDR02He0Z0hRquQqhATZ2GnZHPJ6u54+g6UxJdaMAjkMeieXeo4UbF0abD4677o+sSIlmrWhOCC950E59uumGjU031P9zgkE4x17T1gjSf5TdWWQPlSJqslGEVkIdTbpb6+lH7jRq1fjWv1QOUYHygUrWXrPFNcjVJIQLOLaZxy4BRro8oTjhPnGQG5aAIidpoKhDL9os3TQxj4+uSMjZFq5nlCByQ0j5OLankY+cnA4zDQOSWNfXYFYgL+NgQbhoCmYqSsZTpZfB7ZssalOQJk5Z4kN/yc7U25y23ypNzTE+C+uiH30FudqV3A7uc+XLTXxOY769RGH67kosDEETfDNij44uPnb3FWVcmMn05ueSFsKlKYdlArNIPMKBVbUl+8lLu8Ie2bb04QB6Q9PRlhnfn25RVeIK+6GQsFnpperAEihKaiW+69yxRAsbF2xLeReFi2MULQOGdVaImtICpwhSyFaJ8SRikEq/keHKsfRdulEd+q71OSkFcmh3CYVz2mjyDyoZdh0bieFW7zQmXjwCWkCiIkAD14siYrNk1k1cR807S0fGtQPSvP7mgw1RfiufxcOWkZ+F13WWQgiYsHL+CgnonQTWb4OSFqxC5U48SjFJSN5/N/AC4RkdOM+OvLZEDN/CwK7MvhDMXXG0JpfKBqfVvvOb6e6+zbcpCGPPbuyIxSf0nZPrlMi3rPrOk9iEJDOV3e97+jdeoQgjVZlYmjqvfG5W3dgdl0Z5XSmy3uHTqvIQcdJP2AIEBbSAcxYqpZ01yxiN65pzn3jX0MG04Zk0gE3OKVdF6pjWjypKp8HQOlNNjPl9YArUiZ6uTpi3ZaUaev4L47ALrc6O2KTMBYNx+UJM2sZQLup/D5Mn4X8W9+WcgO5gNcGFL0zJyLjYGS37vKPhl0V7AmukjIRqUO/ATWMoBYRRM5MVx6lo2dhouZO+UgZ4O4WNrUOSRnoSUPri/oA2TBHGF6mIDO/I53ULZjeMznwR61nTQQLnHHT3QK7ngt9oRHPWB2ElqOi81iDiE++NkjA+w2K/0zoUxma5vdBi7WRhRL3SMTvQBp98p76qiYbn1pSV3nL56q+PmbvLoDaANUrgxUn09OgmXFF2SxQoiPg8if7iHk2CF5PVFsHOLFiii3vGFcYUowYS6ezph49gq97LwsOHfuQWzSsVIAXq6GR9aYfzNG3yoCQsk2wMqEvJ47r6BnUo71PgQiQdpZ+8p88eyGgnH6hXEEWVNeArY8JTwc8EthkXEKpqQtcMtLvsyspBqNSJl3em13t2fyroQZ8iRdFjVbn5XzKADwo4/2Gipzx4tXkaw7NQHYONtqaLoq/QXEinKrKyDmKvGWC9yyXk3W6xgmCFLHeRakNc1DphoXg6Ymi83L0uHNhuzlkf1jDZ77iu9pjIp8UCypHEtuKkFxey2bcxOCE7s9STb3LHaBM3DhCXJpjyKink9ynigVxi3iJvev+cdYh6q6rPe7QPu7qw0Od7a5rmyWg78fnRqqMlJZA444PL4p3g2A/WR/fMCzste7Rjvoj2m5A9GUpRQNTFYFs1w3mNGd/Na/3SIe3XkgovTsO5g0h9VDM2OwovCMWm9V25YL8SwWlmSrMdHCnSSz+GYyD3SH6XrHmuK7jOJHvBgYQ+WoLrrN7uacmJc0jRRCJbrd3kL5lwsCRfyoY+2/HX/GgRAY198kKv+U0NtGYMK1w3Xf8Ym2pVspThcGrc+6LJN+1Ym98XND6dxr+afzt8LQH3n3C3ERQX96QJHO9MreR2dCx1pUFnAh5P0d/zAqVkAMSJ0VDD3Y28EOPD7TZwB7oTETRLqYq3TqSuxGQRijyG7xUrUdPkA5AjTCtBBWEm4R7OUsq7XTCRVcTC5yO4sklf9jU1InARmDVoWRjGsYMS+6HuKEjjzGsJb3WRS9ui9HC0BWntmdOpsudVRBjvs+OQA1RaRuVCpSU+XNTR1bde0+JRUdnVtELym1eqJBJnEkNkSF8ngZTJEysqdeEoi3fbU19KiKLsooGMsTHaWQr7iOW7tPadzE4b+E/Pk5MtXTgCSaE5AT502e+G1kKXXyRa0c5BigXpd8GapX+8i3HjInOgL4avNx08u3xeGN9CS05HuEhJBuqgWfSEodh8sXj3JTa69i6wk2Ut6a6EjDJLFO0ZVHcOIRCyxJ1SxLNm5Z+B3kvKSyaJs+PtOqjYUsOI1qiftNz56Fw2ZhBDIY8L44QezBlpVmwyZyzjKBuXKiAUyYH4hRDGnKmMFT45p86TbmDvmDFEBzNF25MNo0J5JrNiorVvzgtWQZLAsIME1y0sb/IwetcdNNiLfbqbXDSsoiD5BDQKcvgTqCH6ncrXaUVohXFnMg5ewwf1MTVf8CDBT16RVYp48KSxF4vwKoIWJcrEkOVajYwAUWm9Z6cvzl3aOAcvUVeLtsQCgWR9rQ0/S7YPqijj8vDsXNLRZPZlw7aul+yU60ZqyWrVwf0711ULt3p7wMiI+IAYf8yCFK6B4wi8LPQNExZFSPm9hRb6j2T2PH68ALcpbL2cF6qZg2xmjCji21KNRlK58C4EeUjIk6ntW1Ty++J7ooeP+K7KxgxG7VZjeEr6P+05Lqt/ZxyKoGgb8sKJbwOdrWR065vzsZdKSCcxnImZECYNb/5hs47S2kPVzAsqsM/kiTbZxj1q6eBY42bLs6A4SAC2j/a7js6VmzwHuNb+uFZ5ZNbnWuV+4jcPLQGwSFbrVePBS4uCTcWAkHG7thp1eiuSqvBkPIczevM8jkROOvboM1RGzc9WT6dXAZYyXMRkhkET5MOAQSUAAQqcqrEVy4ope4HWDs/BocLycUuaS9Dk6h26T0mVAy41a7Yu8KdP7uJC3NVUV1Fbko7cCWBFIB8Jxdu6ufVC1O/Be6+OnG3F+irBkYaNyVoC0de2/tXm9+mXsiX5+LqlJJvLxi50NPUjcUpmirnZRh2lzLzgy1hMCoOqNlRWWF1BoF/ZcMqTnw8oD0mpZNme1U3FNj80WSrjUIYgGsViHyjVGLVXfSCNszOyuiPyHpzEH8vf0shO6zYZGY+U5kRb+CtkH21ZLYoplF5Cyb8vt0CtgVSAnr8EvzkVpiYsRc1r8jUmnkBYEcvSKyA4kzZO0iBh5t0Lul76oGU3MmMhKQ+oSVUT3wZKYQJGqYFdJNzgzZ/ghwyYQdJ4fbTzgk7RX1fq2+REIXzvfUNRmtcJ4//NxpYKlKyHhSNsF1TiUOds+Hux7Uw06guJi8AC0QcFHEBs+i4WP9worxEtpN3UBpCvJihs+9revJECsPiy0poo3kUqhxmhcOZdIgN7gsZGdPY3fD2dNjKB86WT4O8zuyEGnxljq2tNH1lFSr3lZNP3BKVrLJsiZbDamkgv65YbuH/gOwH6IpPZhpSRWQPmsLErdcCnCPbl/O3Cm1zICO6v5wNqPOSmZ+e5mKvigWvX7cQ1BZj/FILD9xXbQqbd7XAU+oMpJYXkIpLj/fKyAMaXdyspFoUXxGxsRfMwR8GgudAjxfrJ74/xDUQwhlozrKogUtZdP+gGi1HLlCXEgnr0ytNCoJrNc4pq3Sd9yA0hp8D/7W5NEExax0/Qf25AF7cpsFjdkzAmLOVI2kc4XatlQ8VX4LTXSpgxUKgeY0B4LoIK6akSODhtK3+eph52u85GbBFRxFe8tR3ppGBMrvqwngc6xW5JF7xxfTrfAEHrzMJTkuqtbA/pDEsPVlPb8i7Cs/qY1lqjiG4aqMvjEpfc81IiX8ipcesDBxUX9PzI+rsRqRNvCdDDIyHo2Ca4Nbdh3TM6a+OJoRaqgHlW2nbenZODcmAuuW82c6ruIEV+U5TlXrJknqdZaeZgnVTQ/K8EPgoWUXLZounMBpHhGywp/yyA8Q0l9xQwdWewoagLAr+gLyyUqRvMsAPwmq2D7gRmeDbzDB0Bkioh2iQzqO3c4gdol/O6oHZddMivIc5ttXf2VEV6fk6p2KXgS09rAX8O8gaV4iip2q0IZu1jMuaTIlgAyxxC08XntRmOEtc1LZ4IUy28bkA5ZXSWVGgMznYmXRWFi6JGR8GdBdGTCdRrwTKm0pb6XDBJLj7MSCLRYu91ZTzSlgVZ6yK5P7WwsOkHyVthFAGkDGCwB/2OsVbggTYI8LeWHsOk4uw2Jg8zu7wlirJ9nBIpeLPV9loeLOt7r/8ifVJrDs+L78chQ+UMzbD5LtP+QqDv+Ogi63y3iLEbtXz7yD9jlvJhRYfe/6A1jCJOsIUlmy48hT7XJbnKeKtwX0TYbc5QDfBynNNGQwbC3SAWoCK4w65mOeOq4dS6KVC+EJ36FcANqJ/yB8+7ELmUS5u3fzezuuJT67P4kO6wydmLusTWzxB+k1FDfjGyUc6Zqg4RSCiVjHNjRvQgPqb6u3EIT9Ix2nBT2dDZcGkRmrxUXNL4PwKmnDJy7DLhM9QTiWwzdJ9AbaGx5MTCPn1GPm1lr6akS2XwGQ5ol23qkObYELGcTvFH76AtgK/lbkNQz8XrZ1SjA8u6ntLhgBf5uBhn71P3nBQ6HwSxFs9UX/gaEH3sxDUhFrZi5l6OJv2opoRD8Ym1rkdL15znxtXKm++4VHqF0qy1kxB8dJhwv7tToVMy6siY8LK5rYhc8BgN0j4rmKAIN+ocf5udECE2GEfXSypZMBmFcuivRmNy8J4/wP7UPfNr4Gw2kMFnN6YsxoUcHfnsVdtW+1cXHq/FIQB2ckgBubSEDVOK4BPGVK5Sd8J1GWbCzfWDuwBUZCTdpV/XICzoCaWbIBBaYDpG7vtWi/eCM3EM+ipcOQD9XSU1Zwr4OJnBcB/C4FJGvSyrs0MSAIveAEBRB7U2gaZUuUJDPhK9RTh5WgSIM3OC7aR+E/ykJv5FHhCrHEWo3VH5bYW1tiLBRuyMy9uy2n1Zq89M+eLqTaFcoNfx0OTcNYaPi3rESxLabHtO0kLlZMVbJ4sXUAyOtEcrtZqthnJ+yJ/W0J68PConlIAjQk/aPV26g8K3xXYmbbJt7XYZc3wnoRm4R1wFlk6dZBr24nN7ZIaIMLKZHrk4e2W2eMQ+Rwn6LmpEEdLfmNH2hwa4JzUwc4EyDiXQErwPB93u2ZUN2HLyt9+b/EeEuN+rA+8xG7zQOoY6WPJV1IWoTz9g/n054+DUCbZ6r356V2aQVhdO/k1WPqp/TKfvbO+hP35hYbZBie9JQqBMfH8yvqnn2jfgtUHWL9/VbnvN2WjjPyMfHANIS8QTvlyI10q72WP6VSI0kJb2uGKBStrp0WrlCwxb/YoqSDuebkutk8jVzgIbTfSkJLg7bl6Y7UFloaQgmhtcmSjpAOjsMRNdkFy687fLlk4z4fuPJ9/K0vp9PaBnMPVktQwDqJeXS0aoV7syyCbzIdr2HRZpJo3OHTEnAJPj/n/aOP3mCBzhIhIzsfvf0+65lfVuiXcMQcE4CF1iNrmH0inhZU+T25lh2a7kKPcu0cZQTsiuGCT5JbUdphn97PRd7N/3Ps4nhQnHnnQTG632Uqyhko6W9FuQVohNUAfQX6GDZlV+63K2XXdBe0g8svdivHnsGOk39E63dGuo0pFWkNpjjuP8A6F+oNURO1bn6wSIb9Hvz9nRcW8+jACV6D4yO8dIbf2uXL+Zn08nVUJjamQjUx2U+ioiFLMCn1Wcefh19Q3TXRH4FnPXW9ryfaEUUnqFPAEBCA4tcbfbnk1BxCrc0Xm5fzneHm+fyR809mC71rmLtVvagn8yjDvOwvUd+AZr0qjZ8p8GK1InWjLV7Hye80CqwlLMNpIf7ad/xO0hbPaR9iB9omGMWqwZ6mIVzTDcbEb+vX2SjYOBwd5QMNJXpoTwm7EPp1URJAHNGh3bCbAdqvkMXH6j12ykF4iZjpGGn6PlFOi23/alcyI6+yGRdv1sNFAaXDLbqJjNLtKBSX3Br4wDiVnag3hQ59m39em6v4Dj7q6volYfqkzQ8L/cxQeJUIkgyP2FnTdCLqTiiWVE4NGaU0HhX4EOOT39yLNA9hGIq/GugTAkKX2v7VPTT8l4lrslC2xH+htvH6vjvFbVZyyidTX6l6Dg0bUNFh/H5PpCuF5+Zvz/73WOveEetT3+DFFk/CY8lI2uCsF28SnoQyxtQL43KRdzORZuu3w+YBd1+e155iJuXmFKoKJLGBtPi4DEEEgAu5oM5MGdL3yzgv8WwdDMPZTDIHeG0D04Wp1P5DlT/BlY7sxqKGq9Ep1U8+C7h6Z5T2CV4gTxlGeQJ9R5Ic5m4okzbiw+u5JULuPwbp0m/zhY2Cx9PxS/LeHUORDfx4HWDTu229B1ArGGRdsDh1SAA62P3DqJyGI3IN2a5U/8QkLc3gcyvF3YwFwMHrm5i9yM/AR04FTnEh+GGEbXWu7JiGhVf01CCJH5W9U+OL4Yi39M1ZkR0KjWEzxvKxyvZjCiFD8GiEigXQXb5c9FKaQBDatarq4rz7NHEmJCxZ3HY5HJ92/98nG696eWXFn/g0gyJy+V/vr6UeEmaYhv4PB0SzoX7aV3Scxop+DuvxRNzaCNPG8W30iGYEPwqdor3WsTKEeBS3YA3npZ5856k/Udb3q3b1SXvkM0IsSF3f6td6jctL3lH1NFKzEODj/dgwLx82nrj1NDHeHjk5AExYEfbTDy+zdpSh9xAu+sdsVE9TCkl+1odko9ftytVqvre/zRPgid6fMdTJtCYy9ix/tRs7JeSZoc4VivpzGS6q2TKL6lqU46KiXHXSqZYnJYP1QggJRMGaDOLEkHRe+G4F5YR/HvFYwy6GJCtib5vnNchCx5ueVxzl7ftB0Tpq6aQXKobCW/dWEzZJAlxo8FH9C8pMgV5ie1y/+5/GXzNmENeaeAF9tSPBzaH18v6evrmogSq/0X2HisxioasH98eHO9UCI08Y+apmeMxBJJs+DS1deDhKEH6RZQ7tyt4QMWG2MzqzPfKkAsRr91oqYE8AmMFeiRdIznIJKALkXuP8EXW3sv9fRmTWC5lza1uKdrITm+07Vi3j8ATLGyULA93kfA/isQBxQPRe1zNsAthxhokBUWl/WxRmYI81sDcAywHKFW3THth6qt+Ij1r2aclToIF/rLxDbtgoGSqKT1qNkE622DQ7yCUCqhh5F3ig6eAsWmaDLbemk4E0lYGS8cwwi2NFr2Ow6ZzMJanaLQ5gfPZTItySuO8Npz3Bc5stF9SEW7L1pPDVf7HnzptxQKZV5/vndqP/fGpZeHoaGkCVbyMb4dlQ9T+fnHSACE3fAlrFmX5pDu1Uzpxc5z2E8Cx61qw5KsY3i8rDbwqkTenENyqmOJfz+fX55RMKml/kJqHGaL7Qn5ByTJBw84qYHQqBjv5PszCLeVrcyRjn335W+ZAwZuWKvQNCbuulq/GebN81mj1hBOaOpr1xSHIOrvgM1C2OcR0BdVpdJo960br3Wtn9QWxgb6xlZeuJeV0ftXFk1D/z/CvENzYb/HAxFdAIt8e7hzzoLtDYFmj7eaxt2UdSDa8vfs9nlHqC1+e7qg/sYOlUu1VuBwBjLU24xBNhDW0QxSdlsBUVqVrdi38VaxHlD6QMyVvlPBDrE+fns46hUJB25OITzJRqsUT9cDTxPok0CfGoatViGaOjGINl1OMdjVfuR+YH5LaCiOHKOSJM3YzkBCURaB0ABBWl95sLWR8WpEtngdOicl/Sae1rRMYk3ji5lgaQr24TMDyq2yQStqN2CLl8X/Y1OUkswOfOkB8kmh/SwmIT8NDm6gSgNZ/Fkdm2ARkmCnlMsURQkmW8zcplmdI05qvtofAMpBYu7btkO5jp5VgN0Ue5eH2cier5Jtl+UMpmPjQ4mNpJoJDXlP6qQiAy4DjdMu3YoW7Q2FsL47+LHt/sIs7uVJXKlq1Hs95r5Y6Q+wN5FL8VaeIZqCyhHI8QssXTffkrAZWYHX+CQX4rH/ocLt6PWmS515U5D7kZY+ruvXbcUAzTLQwzQgg1sRMlFia1ZCSglNwdRZX1WZnAnWNjjWw2giEGnYVaR8/ck3ogTKejRTzRZCkFaQ7wAuj+Ax6H2Qf0Mb1bLzYup+zh4rI0bkmVkirOt69R1oe2Lvl5gmLqn6sk0JqSyr8NcNGm3U7aDJj1zPZ4xjQcnsHNFkFAX5DfD9lEQo4/OHPsdIwUQmclQMqVFZ8WgnhEHduXRnK3gixq5MJ9gQWgNnZq1w0NsQgwibWXZnZE20zJMcWh/2Rz3zvqmu9Y7YFhpTcZgO7h2iruCIDfAU1RPcyFacdktiJv0ICTcCOtaeCn/SawY2U7fnnQvYApvM5XVtzhdBJTblv2DbiEHpiziC7XBw998Lnt3wFnEbNWprylkQmIg/lh+W3DJ6KJf0oXr1WxV7RTJ+e2BqgJU0VmW1lY6up4jZsLFy0GIkcx2YC6Okv4ei+V8EM24pQuh+qrRB0UG2yde3s9B52Bday8cflwGfkA+0hPvgn75exioeGoxI6NrNjHmtcYPZbVDmBv/GPH7pnXFdOBLRUXYCZcPl1gaejHDtZa8czljzfZKelEM3QJAkNXro/tqDGZemAEi0KN9ErwBgod3JcWyUPUkuGWR9qeGVi4Z1epxCZGglPLr+8biuDMXl5ASSjUz7EK77tGeCDArh/j6F4hE4trWM2kxNf9ixi7HHjLL3i4+SW2u5PEeMwCvld4xhv9cGZhRxDiWwB5OX1l6Tvw4pNUWvEdOnbX9MXEXrZjTj3Krn3/eVJs12wFR9Qpg5K4Mm3MfscOuMsBT+toSZIbiuYVuFR5xXD4ozw4GQu7QNU6cqXlg++/STiMuvjBEYMsIDJLV9/CDKYQLAujT/jGEx66R9LyA1DF6769BE3/+mAdUOtV1ow30CQUfTXd7sgq4TW8S3eTEznvGRsHGGcen2N2pDRj8OJMEPrUOr7ddSdiEmr/b42Ozn+irtSzPztVW4MHvQlapniTtltAIS8lYh2WlPu5xZbqtSalX7ofOUqeR+n5fozEf8T9JcRasN6fV9I9guQwvZIvl196dDFJp3jFhAb9kQ9DWZp3LGFiuuc9zbgLGgd67+UzvBgV67xYn/rh1Xyrf8837TJH0dko0/p6R4FrEZs9gz1k7NF2aTp5oTBsrMKzzE4JvsBRkpRJuWHX9QbQmsz5/x1KkFkub/IQ7nvDjYGA51sFJbSqugnQf8zOSxWIXOSq0UHlQsIqc+lq4m5yr7wLoFedJqeyVckK99MmQQHJzI/J2xHED2gV4saVfiFxTnQu4PXcUoSrUq4Qqe4jLlNNiaeBkM0h6UsGfyf1mh/NKWC/0DAw/jLpXxtPaa5Oht326+NVOZPDTrvNM+zyepmrZ1gA2bgzD1hYvxUcQI0pK+CW4e4mSNTccsJmKC5gs68HVD7FT7abqjGcUcMus5V3u5H0P8qsJqwIKMWROtq0Gh5i1zHQh4oPUGkNWZo4vnlrQkxDo9kweuYcK5e6TWc/s5rautbXKR5wmHEeKehxAINmYjU7fcPycCjv6g4IHaeHr90/VojWeWGfwAx5xKfFoHafdlsFL1crnT0jRPJt6vBY4KTe6qxAREKlVHGQom03KE5snuvnaROjn4lZffI9Xs8R6ItdtJpoXQWL5X++YqveY4ZfrfmxtGlBFsMZ/60Fmv3ggWxos+rvUQ+jaHr/1mjZzKrDKY7IEaBGvHQWmuT6dYZjXA31qYsPsObg98ak0gVE+61SgceCaM5o/pUWn3phHQHGDQH9t+m2exbuyMA0qGiDQ4xqUtTHcdneFKS++/LgMxTo0skUqlrugQ/6pZfgPzeFttYjauq4kqAYl5nrN+pUBgbxJhwp4s45srVswi8o3ka2zP7bBD19xxPkPWW4hLnLGereR3lTqpNwwgDFqdiLN7xsz3DRtVDAJUIdMBGmt0c2tjVhcElzHyFsdvgDSXGn2CjVp4RT/xRfiLVC53gR3CB4dM8X1eUEegbNhikvr65ETL5eycilspBB/9yVooxaZy95U6sF+hAexsvXHpF7wyq4EPIf9XadzGOE4ydP3o05/GmewY1jpfdPuRPJQ/KQRyNHsIgaCY/1SIuYNQvR4GeEsd8n8+mhAOQjxUEMXt/4G2/6RAFuRH6bjlmlM8i5uCOzZjW7YS/R0Ne/NAUM5AwHXhR1sXsg9BPo+MevFCvX4VAUEzH6Xs9oT+vGlO6aUf9aG90O4oe5K71OPCLj/tHfazRUFi5H1MzDKX3fz1JRmO53PrviB8FzXlnsiGaq3ZCU+9sN/KVZfr2ChDAXht4Ch94+IeuvzQkafiE/uSyz8V9w9rSKJvzxyjryb5qa1w3zqLvYduvRf2L4jCmTuwjoQ9mrBeCSxbdr+syv58xgF6Ce3WnJfdW6T9BgqbE84ZsI5vzdCSslNUxsWlrgu0+2A+BjTxjWNdRQAe9Jk8VnRw9rCCctSzmFiolPPym1lCsRhnUdFZrBq7V+wNui126rakTI4TRglPyIP3yzMTXs5zSIUZ4IrycK7mhV/HSTcs3O6XAux1vPsqYabbIgkhOFdu8Ue/4t/faee/Xj0qmZg2CFu+SZ4OWI9YUJHDWY8OEzIkYHe7lb7nYh4kzjXRzsgRMkmXpJTC44SExAknkNgFlAtIIqKjjJ4+MODPzxruW+Y4XZce4KA/rRLh+TxkVwNiXNjGOiYJVX0X9wWerStzg2vd7fypWfw/ZN17wf+ighCS+OQrEObqBO++8be//+8yuUHqJGGuYXJe7AxoBhM6io9EJ5ePLXJvKYuy1LxEZK0oGoaByVM0PWGkN0qQBrKC1wTaFnYm+sEufLb+D4s8AhLaMgJQ9qpmUjVKH9p8VCT1KRjz40w/236HvwAEGvPQGiFdIOHpG7VG3VnfVJRpR1pJM9WdQxzQq8/yVnwu4/n5DnGghO40M7B81Mbw97R5hrzwse5IPpGwkV0vrBH7yXGFMfjCkRboqdVK4vtzAk0LRFoEGVbrWRutOv8rwatskSMvjEeFztvRQdctA89uLTFZdujYFej3G3QGLOJmuQewJLcNUuGiBRWPdFWtS33+kNKvZOXPIxl3JwakAQqdVNRrsQ072JnsymEfNP7J8XPnFRjqwX3NOBDORbRm5bDLPKizJ+tBrINZcf/fZK37eCjfDM9YgCTYot1qJniNgHZ08oimn/jAwLSgDrGhJrccWLXhZLe8aT+mbb2t4+cDen0Cmh+ZD57KIFUy+lTuDrp6rW0nmXYm3qit92cIvvI6LzrCR+ZzMEoFPbIFX4ees4kDg5c8qV7X7mYZ5CpiFS93kEjdBYsT0UCw6NByHlrnROWkfONzppi8xM+4SxY9I1N+cAqzDFwZWI54UT8iXDMMPrubbPkWnEC6YKrMYQ0ShAMvElH1bTak8WtlD55z6deKfdWGJI9ZGVAFrZBQV9Qv4em4FmSQRJWCXUQMXj4gx6V6aE6v5pnGYK/G7fV1HZC2cX7somUrHzsbCaT/XDQ3GVUdB5dTHSQENWvk+x6bcmXRlm6fMf2i6vDx0KFxKp2UgDQnjPSk8hmmrKKzzh1jNK/Rtujpa0blFA9FF6VsJVEji1+opRJD94TxuqX+pU735IoIbZEpoNkIS4wd3mzUQVoe5SLOkZWaMHVqj0WJaePni4aCywSLbNCvTz56t8MnPVPws5QWJs9RELI4HkZDGsfNMNe9NjBUefND2LCvchMEn952EMlnZLj6gFTiQtbDhs29vDw8ONHs6q1ixxuyriRBy2pRVhzt13hED5WVt2xoi5EwkalPGvdi7DcGkJDa2TSRxDAv7T3xKMYfypktD18XtY15WKH403IcqXXUHmt1zlJGvy01MT7EdVtFvYCG/yvliQC07mSMLah/Dn0gd00VyxX5KKGVOmN/COd3SDb5QfziXtCpCLUp25ru3R9mumP0qw562Wm8lLoCs3O5etPgi0ZurkdSogxkYZmUuv1tefktAvYddd9VbzllQQBWia1M8tLZhEczcQn+IqVdV0Ft4rbu0WlUFdbVgTWNM/97X/eTfBpLUENBdlEXV7aeCsMmTRodVCv+enAEtB39S5S0jm1jFqlApoelBvf6vALlKwKK0ny4Bxs8RkTLpPyhl7Mfnhitb92O54XbmjRhWIBJo/PxcmR4qwXNPJ2CeGtKiVNQw5g5+PQPZE3d4xC8lPoWg6HvTG5ODoWu41GOHkTxQfgCY+tU/AcbaV5+NGpPJ3hUG98MEIV60DDkvsXBXeeYE2PbKSfX4m7g0cCIkHpdRPtt8ygGnQ7nhOKwonYu32TAy0uZbNgXkY/iMzOxzZTl0UR41p52+SvSogjPg4C/Zv/Cdm9x/XTSS6pKwk0gCieR9onXTQOOa0M+00cvaT9tlC8C2jGXtFdzLAaaP7XKy3i1w3xwxc+QLr7JQ0sLkgP7BTnJSVW2cmWG3pW4hIhdGAP12hFc10VU8n5MJxNN6Ku4wXW6uYUQKTWnDuCzebUFO5F8Xv8Hau1Ve8Ds9SrNAPYvlSNPjRcK6ktfsPYio+aIH/qeGwzaD2Hqwl7wCRp38cwJ1GST0Y4p6dlafeO7/Dvhj7o5PfQnxAFphhate1T5BaWF2XbLodkawHmyjQddzDHNKsAab/PwIo9u3VMUn7CRjWLMz+QUL6gMSnxqm+KkMnt8wD7oSXWzdDNoaXfhkz9DTMc+4N3IYFb+JFdAD3mCwd4lpnf9LoKZIp40LaD7rDDDmzWuI9KmaZJjoQuAkmdTJdf/0+MRZxIrtSMO2+/sJedaszvr4RWS8Kp6z51Dvy2OwMRZx7QR2EfkijybrHJx4AqzXoUKgPsSzSDxPCN/dbG2fgCYccCGqvfR4CKla9NXvNJzE09uA8TecUkw5KNbygs1Oo79s1SaDQuZJEI0eELWrIq4nH6ebgMeo5ogCHA42KEdMJBoOG4mviLuOxCg1B+rIXcLw5pPHl5J1x+KW6TtbCSsXbjRMRDLoQMtNyuN38NVjsbojaJcXp7AVwwDGRzZwc5ur9yEXEtRSTl5XLukt/Tunud1ODyg8YTI50M8k/PfRHb+D0UN+wG0014Y8alFCKLzEH1tJSKCDR7XM+25k16ksf8tQgFHnClu+1OcOCiccWhWZ9Y6ra29e9P0q0KrT+7dbnRZPVLOba7iN8ADg0NaA6uCzkmTsAJTXPlotit80OzFaticA6RhPOBoTqaOMa9ZT0xCrfqFBu8sULsXaXpcPQLMqhh6HZeYsU6oUbmc+2NVwZqRZtpWtT5/Mn1+iRdEgS406Ixm1vTO9eKjpMx3blq9QsnxAn8nDNu+8bnL+UoxiTb/mIM7TTJLXt6VfsTDiS0w8Nclw7ZkqO0iB9z2XWDp0y02FD4Q+ubg+/v1VsCoirt0ca8ZSY5sf6DHrYrDg5fQd8gss7I3yiRio25j3LnjTi/2ZhLlAoOPWPyowxpH6OZsA7awXbLjfq8To5oqY1xPbjUck+bYybhSsPEhAWd3F2rmMMAoLC81iKJVdJscl0BGYywuZTIIZmMyyjCy1sWtC8De7xzN3gRQuxP6u7qNIFDQG0qVKlPh0cJhy6IFgalXuQXQyDNEFEPPoo6I/skzpHJek5Lr2Y5kCBdz7Na0lTal6+Wj8+OSfdXH69byRuc6Sey4BO7FaYs3VWBBeZkKOcJgTDQpb//d98sOGKU6s5/6xr0937NJ1td1pKagzSVx/TU9/+L5RuxgWE5A0EqI3enijTr9OMOybDrBctfjjnOH6/y7kIGoBAvSxjd0lTertDy2GE2YOY09+aAb7gIfEG5R8DT37RI1qzh8eewaakJ4NDRp1b8DVQFQqlXFN0JWSE5mpN8AnWQnfi8rbsTeoEdkaoc/S7D87kiZkF2YObhFQ4m3K+IQrfFgS0k5LQeDkuFSOzbtRv50r+XlnnlWo4x2TgbIJNqroxTlVJuy52CxZ1mdCE961RLmgQvv3lMocX20+e8u2Nv7FHyBet/diIEUT+Dj7g1YyxDTFPloUzIdPb33j0cwGPWEesuZPxz0WHqr6vVwQElqQZuhZu40ryOoOB2m3dN4m0xT2HFfDO1bg2/4IxrOgQ/Z9E9Ggx6zYFb3cyjiK9vRWv4/xkHBNo1LiKiqoQw70qbqXQL1CY8YhcjHmdTPSxw97YDLIahv31XC/mXKgpg87wcd7vGp7LoQYm9PCFkgUxQsmy47NjG69vZCTRrSM4m6e2+sBXi+8c+axG9600nUeDWC/eC0TD9sbAxy8DIOW3lEiPeyFftYt1wWh/Ss3CDTjJpJnFtOWxpMBQ4tAIAlUqCdcZ3P/5fzYxqHNXKexWJyzGmnRzCrsIW1eoaOqrMHhFoACPGwZ3I82MJdCJgqdyyI3iLyQMg5ZonJW9RgA6VlmTrHYtFiQAmQcFp7tRxdPG1GcnaNpqK7D9WQgMC/K06dtfG5Vl6ThvJp2as/H5QsPYcb1bexV3e9antUVXn3PxCMO2bXbWe5hCMWpzmVScSyqpkZXzab3Y7EZV/6n/fTRKiGf/QJMFD/uGh71Ohbr9ZttPlAZEZtupE6RQHwjyuNpqsoO04yVvigqoUtxFYuSSPOvAZ0yZePOeasOE+eLZKMo/L36sbrLtVUkJwiBDQ999DojpLLMo3nsBOmBMic2aJNQwXj4psC+9Sh57XyYTwx41lzP26ohezBfMs7t/aA7gHuTanZ79z7/JDkALmn1SwEg6EubgkAJrQiej86FkZIV337QtwNFcjptot/Z1LK2Tdug/7wdRlsEn1BqvI5l66EAw2MShGfoh3/qwSpYzu4Jp/dsGMoXqmwdtrQMN7MvMSCFbD3Bh7njmvI6J9r5j7sxU46Z6F4rWU2ELk3E85uYFKeUyn2SDhWWpZgg4eAyqzVOBazXCmpwIfPxqRDRzBtFOM3+vqYrR62hsp7k9SynX54Oze/f5dfQ4g3vjrAY7jW9ZQAFedjFXP14TX0vOMIe7RZxVTySW0XvkSzTE3rfmehH1mdpc9byq04xj1vaall7J7Q0hT0B24Q+/A7StOtX1InEEV3NNLuap8trcvtZNiT98vIlVeoIasbevh1gcb0U8yirIgBGbjKbziBCa+vObazp085yV4h3Mc8IH8TNsCGpP4NYOZNM9gVfTNkALFJEinyJpv3mGKWCvedkOa29ndjHKfPYQMXIIDTZZ5B0G38qoZCjkAiVhfMBKQCkviXC0aJ65OrkoCeMmO9ZfdaKrr7PFk9mOxG3rX7wzdhFn9hSZumRSKZQV9QxbBWSRDyUwjVgBVuR0wz1KvuMHACU+jPWS1RpNf81N+vvhbcc4XMkb/p0JVo74tW/cEmBH4SZCEsBMAjEmS8LU7xvkD1L1fKw/We5Sgz6WTR4vXUeVxHpsheQUalchLLXr9OxigqDku2zPsGdYNeSOoqNRUNU8ynoiLmVTYKdRMmEMZyMQ1UEO84tlgo42f23QbYvaoeA4YFqib/KFkG3lRonc5ErR9UNz6Abyh+ezUr6HpnIIqSENMpbyF9TKkjoZSYoC8Q3yvW1tJFECww2TOhZFg0IUzE3BfAITe/0NFZSjz3Oco9aVpZs0+BOVbSNeHebtqA+L02oUUqfnuSEMyoC9ooAX5AhoDK7sQGmq4wvvrzw6+MDHR0hoYGo4s6bSL9/RoQQ7JMPyfgpYcap8mmbByov85DrartpDUL8L5mkCaAstKESIOOhfNfHlw2oqs2hzZnJgPMzL8V8DTSIandCmvrtJndp5GVq6skXpzTQJy4AAhM4uhTZOSpVSCtoOW464d7IGTRwxgFFS8+wvqQzDdRRu/i/tusNz84ehP8BvxIS6+dNd/AShu+KeRUepiMFVPV7NAg8DG366n8Pe+IqiG9DDI8DUFuh8NyrEIoywKpovY6JihuMfhOVmqSSL6PXVEesiJE718ZgEeO0qpM86U3c8TrrqnguHA8Irohvjd0f5RahsCt3rnAlHdOlu8Fjo1JMtrcCo06YYb08S888mOixXpg/NOXFTvoGMP3Ruz/SqLur5C0+WCOV+bs0eRvNKsV9Rbilblal6iOzB8h0lJ441LHFbmncAx8bnNG9vlhj2kfP7xMgesjbDRcr2cWTHF9KZvDjgsqysHPZsxgGZKONkiP0+qvtstpEwWJFmZuZr8e/FXno6iCcTH7TqtNgsxCU19malB/3AJpZyeyMoY/Fe5KcKpXbQuxJRPLc/MwP39brEiPv8Y43vlhAHeRV6X5Zc98u7dfPOsSSfjKuuhbqYgxVZXLVXQGj249CSvfk0pG8Cn4ZRbggmCJ6+5miVOoy8BkvGnM+Fb+gn56I5DGDnWlHddb/nMhsuIfl3Xl62bIgOGn0IJz+4l5qPgFPP6gXZ85EDaK/2xVmvJzgext6xycwbHlYQlE8uCMRNtI3QCDW9rON8oZ8ZbUYmwdrOvqN/6UE8pttSrpQGDWMsswAKwRkMnmR7ZANlG6Mo58BaYulPe16BVjtfTOTzGSAiPjh/lc6Cxg1FeiZYrbxMGvI45pIqKkxGSg+2gL2SRJb0qBLN3NGIkp1ZD76W7nRa6EQL6nizoQYVl3wEaZMfOZc7Y8fQjjKtxi8i2kwwGN3h2CIeAFoiVhUoWcnEnFrxeLHPX3ORPr1kfHdfv1Qx9zhLzqyqgqYdThpQtkkWt38jYrUeZqSthklnnU51RuSBNANvy1kLsi9PFZTfGmZ0qq04oUaGKXZN911+ckwiyL9S+6x6cqyfwsqbETdDF0FA+M7vNFvOcUBdWCiVQ4RrNvdDufkUVxJ7Y6W/UkM6sFQekKLXTOI1DTD0UTQBxGmCENSMFJUva1e5uDWSBoMibXie/UALynyLXNGmfxg+jv0bG3GudYV5kfBuCyS2cEKNrYSsImFlhzyMMN9wf/VethrVP1WRTHIuwht26Cz5zDPbJQ/SuxuvVOeDScAoGHEgnPRFL9JACg8+61SZJ6PL21Fw03f92ZFh0sm3qW1T2BCVrbw84uvvHnnSwI9CyBijx+QAOumwl54G8pA08SE3GlVrOYkCoe5wKEuY831HM0eerLrqbawKZxF+7BQCCXiGaFrIyrr2ngW21vCTX3KpxWKyQ/iL0EP2jVcfK7skRnJcji6jm9lzMLBqRiKDsSzNmIDfJcjJyXola3M25G8ik0sXraivdfJJUOSOveBkvxZvqTd6JD8Ci06bLoYBLxIAbwiaLc85uyzFsxpmU4m10DT4f72SiO4H9SLLjhCKNP7H6/Y3i2lKEkRqz3u1+FIijK7uelvzAnPCHB/DmcqWMnWF5MYhFBNLnuZLVupoEE3OEHdxk2E+QG7TqZR9xaV6pUx1e5aX1Gn2NK9efBneBcui8uWJ7yWxfLnil0lUoGwyIVOTtSeCJw0DDQIwnmBjXk3f2zBo5UHlMaQv0Z8WR20ZUJtIwStO60M2gwY1zNH4XWFOMeeJvz4rGyiTv9Xm5fUyuD3oEGOfehb29iwV4ZMW8DnWBjKX7yGkt0RIooPTZFWdoRhKacY1qNSDOOhqizKP5pbnW4rs5rB9Z0DLadxECyO77/pxW1cflMisToXbtbJanzSrrh/ssDfLl6/DLbHWcMPS7vWPhmj9HoRj1AsLC5XEYarCpiEJnf9p8n4zNmICAZtJhJNCSUgFQ0u4U5KfcDOomJK0FiCc7yjlMLIRR8/qWXaZAvCGGU+cm2MPsUsdoY9YuStX0RFLiOS4KRHYmaEATZGm6ZJM4Sn2gKH4tYkVGdhgeC+ck82uM1ji1U+KKrJ2uogwv8IzckYFD1PUWDtczI7CNvCWBeiAL6aP15Gl0aJm6iwUofIhqMqJpEBgOFvI+8DJHd132/AgX7zJbljw749wv5MjlCLIYCkt+5LdDhLbSHt10MFFy2iruNLOA9Tok5LNuosaBLfhDSz6q+L/RvkcFWewhnfTt/snrYLcXkEcnnqlyBkK1shGzVYtx78U/ZqKiUC1AU/nybGUHjgxpSn3l0A4tP1AXJchfa7CvNhtf8twf7/DxEX+OjCEE6tNRH6sceerMtjwVDy3TjWouf2zeSpr1f2fVA6JXxXdql02V67ZS0k8plJmP9MCqgGM4pP3dLAyxb3On2FTec7+ETMwIdUT5+cDfGz8825iN4z88zjskzRRMFzQHyNL6yEekvIi3O6OTinxXNV3/uVR11YYia2bwkum1V63Z/tTTzRg80jP6x552E//2T11ZXC9ieiXEmaRuzcbHJ7V05wlKRnTG4ReF8CAjEZj49bqiMa+CBmVu8BcgAf+NGw+DqPKEkoi9Q6Qmm0AEE1ZOkPwo5N3QltXgQog30gK0uyiuqcUpAxmn9UILYyqRyqDJJce0B7zoyKEDCnHj360TjilrJaKYvUvjJqImV2O5jC+RBvrEZdcQoT1BVw1cqw7jYm1EyETuwhkHD60prPzdrXWjXcPGBOCXi56TGbjYgLKdPPs/eRZevrc9EYoBpm3nhwFY5UJWLjV8kfTbLspKJRRyXmN/xYb3RhVlwC9OFTiX5pzRWard2wbJbt7rGQT7QDwhA7oJkx8S4nIA9QNrK2i/49i6P/om23EP+qpp3rd8Y1ZfaZlcyrN1VxRrYGO4soaaDp9AWUJ4cgykIFAmriEzoczyDvuaVf3Xv20mFwvPf9odYFjFbx4nSvHTIzh70nvUlZdmcwnZhySETmPpxq92XLabwx+OR3k7x2Pn+gdHE+g7rs1437tkglNGGvWMF4gOtifFYW3KJ6TnHB3EnJa8mEDdXrHN76TcJIVS2IqqjHyoF/1UtlgGt7cfMG0PORFaZcGgLCredp9RhkrsmSio+w6J7zAnA7FMdFZGQAv0J30z620E3ddoovAFby/0m9kRYW64Nbl6Fyj6mzCTA20yDFmu+dAk1O8ym3oBDsW2LFKZVUQ3Jp0Q1GhWnOVgL67Bstx3T+7Q6eX4xUXhpSv++rCLZrARtvARDt3fAXFg6UFg+DHfuCC6sB1PJsuHIFBvJdwZHzotV+v6bDKPTVsrhVTh88+wlEJ+bF+nODaY9JBTp16ZuVBNpv1nFw4jPvJPsbY/69aJ5JuiZMQxBi2h+16nIdCcewMQMbuTBak1Tj+kdgn/4o8XVF6+FbayjDaH7Aq3HE4SAAORve7bZg0o+OzOruwyQv7pM6tJ0Hukz1xK5yxfrOpwaWQ4CkrKQtnK6M3C2pZVyVYI4d5tfPAS4kG2CAlVAaDPw01jhcxZoDiWlO0NCcbaWDUgXEuyJRz61jGfpcX4fPuVL7QFldPy11sIz8Xt7rFkmvj/mHBxsIGY2hvXGVtVJ2cGQ0olDtbn0PudfdOEG7Ulof/OvK/WMrbzd//1kXfcI2w7RK9VcNhLpZYQOVyZ9ynqWFd48c/Ntctrw5bfoR5uf+nHF5I91MrZylQTtDmnkjTlj30bkQtplYt2PMFdRkkCDNZ0l5UVpb+8UCLb3teTX9u7wvLVjMXEKnyho+8k0yHOUjTXIlWz0sIUTqKnN8rjo6kdiiYfCphDvzJHO79zlRU6XKgcoianeixW/J9EfGkAchCH4I804GksLufZalZgiaHaL89/fVd5BXnR5wyyOkCFD/lEsgy6YVrW5XeFZq714ZQ+UmOdqTo0FRgZUL+5aWxAWq4MdzcpNp/pMVCUSbbr15SaHRb839qFJJeA4AcCJ1EaSL9h/ZPLBkxQzNJLXXlLKt0FuI8khleMLgeVfhXukN2hVL3DeHFJMmxPVCZhrp1hOLVEmEkdp5W3AYqlrpir4m0x4qytonXBfIpwiPMR4GLnkPIv0bcNxqL+zh63wvh4Td1N1nsXAwlPpoPYmSSOY8fkg77mXDo/oex5ANtLSZU+DBm+jNlAuHUmqQCJwPqOZSMaelcEfL4WslLjPk4NSoVF/dVcugktJCH+MdPjtNO+u0q5PSwljAXeSwK+Ft3+wBb37C7RR0lbmOUR3tLAglaihCqA8NshoBuG3PkQTa5E0Q9ca5Hfvpww5hKzOpdsl9mjLIHxe0sqQON1DlakmaWHU0USGDJAx5gdSMsjjkOPNxvvBG7LK6W1Jrv6WfjrF1M8iTwg6CM0rw6Pjvb+4eGORPpx2ym9Zo34Wod8y+xwBSF967NCSaLpwXl0LL1RDcZadrar2zY3U7rXtdD9w8Iqu9Hcoi2aH2/RKEKe0GS2XXOxq21/2yOY7hgT0M6dg+yggUqgup9qD5V9Rm0gmFoxTMkUddJXufsFknVtLDa6Mf4XoI2k6HBYeHJVDqgzXxqpxlaZx3fpjXfyEOUC3rgXWkquHm5eNBN6SHv18xS0pB/a3txePvn8kCsTSFQnH3IMuxJNN9jdxmLGchni4Owlq612fl+Ut2ek0ILtxLL2B1kn3SRWDP8iePmGz1YTeH1ehQjE8v7ErccaqgvyEkFxXL6SFf0D5SNORdYGu8wHXC8WqKEU7cqYOFaWwu8JfQgCgFrW1vt0mkDhCHB6b53g3Ju56oN3ATKxCpJUImGf5z7QM0XkDaz1kkTCEbIwbWfCwSVtXwEAZwgqB8EUSCi0cVAzXi/5gWZNzOs7LHeL62k8hyd3Q8KRHCRHSVhxFcJ/eqFgyH22ZmOtrPnoQqbNO5U160+TKW/Q/FphJBucQDEdQguM4zyYXsiOEdUqdxcVuA9PYgAhJ8qcQVee8FOXhoMaxCkbGt3lXrDyWmLeOkcuZI4aelb1J5npPXkG32UR+JeZHQHtUtgldAmt+ix6bljaftnIFGLxL7Xp06rEuXatVv/Z0syG2XcL0pxAfZF8ois6wYsXaUwNlp7oZkD7WaLXHZZhIOCM6xPinA24CmvIstCoA8T/YOhvZlH4gu+eY75nF6i6sr04UWGnhC6K8aHGfjCWEAE4I0CY1icdU09hq9VIeo1fUzK8DjkzjejYFUtEPJO7oJMWTMEVjTAorP2dlrUY4vpNBESj6L6n8SovNJpk2w6OPg0YfJTSaVAsO4eCtmDGxlRIt6Wy5UfUEAfBuK7hjx/4vjgvgLkL/yJkSZC3R1iLp17u5IZtUzhJv+ChLoXnW1LiEz6TF4c5VWIRaF0Aa97VdGGgH9BQjvCZAAzx8uCcUsP+vTlHcNSAeQPJ9kXG/ozXs8zt+Off4dSLQL5zmPttXObtx8gzSvT6W6AyFSDmDEsXLEeYYvZ3wSAcI+4CUIjVZbnSfA9QXy8NZOoVq1BHOu5YrOrWpZusWvd5s+YsxAC2pp4ayQWY4XIvUF8CkAXSqsM7CgU8z5Wx1IKVln/NOuMc9KYIMLL+Ww5EVsl5FQhCUr0wEdcXqkA/T4fkxpxgvNMy3+2njwrpSD8zI8e7sUW4rYNjrSUYa18cTGaLzAdCBMb46FutGqbfN3n2ilWQg5d/G1td3UmBBfjOji7W5Rsh7rRoBeqIE1mjgbCS4iKpHgtnEMlqF3PIK1hVdOPPcz1m8FkqzSSl8zvIQpv+lLZHbMwehMIE2D/3Z3M5wU72eeNTDqFzhW5O9t8iN3KGR7ZfA2nBX4Vx6nWRrQmWJeBuSSQniWX2vdP6w+VeLvjrk/QDF4CjOygvk+WX6ZDe7EVoBHwMotde+Mq0aK4OFvhHam6pngGEAS6VsTXFWRzFNW3DobrylFnK/vmzArshKXIk3b/GOKOxzUfKDhFCarlirQO9kRFpWJXaRaV2bJqU0aS/EWO7IcJJR0FtA3No8s+gV7jY8sdrpwGeoKVrrEqzKoKlWZ9uj/tnewDAoiV3c5QwEYJ73gPkNaaKp2pn/EmC99IEt40R4OnCnmlyXsJ/PfrGB7XWa4Aa9cthC9dW1By5h0sigJkPGTZpSX7aCKrvoe/yRTchAx+0nCc5+jBeITtoi9SBGBouhj0ZrEEMXAdZsUnvXIsJBGFVW3CPty/TB/VxblFYAWyPK3EEHNWEXfl5TAu9ooULuP6+YXu7nekVUubRdNLZgrRausJHSVCrcofWaXDz79beyMWECxR0UWk3jmiQ1DSUiEtVYwJAeRUJij51DRebqQBqhlVaY4wSa8cfidnNCDwGv6gGGkLTSYUp9yP5ileiyDS9SVZ6IOJa+IMTaYFasSh6uuHFCHjdJ/Nim5PKYjl6/g4Fvbk4Jtm+OiA/o2G+/Z9ksHz07PN0p5Gr0KiYyYT8i7r2AzkQqadmDoFUW35+3UWbWloE2TFbrN52qzPbVeJCf9FVhc6yujTQ2sbFQoP5Ua4M+SPJy4pYVCDbrq+R1rtT/L/sDBYCn2UJOppAo5Sy6LgEOhBKEIz3Oe+6pSz4Af7LH3l1vbA71sQ49FX9DJvjrlf1FOMUdsNKMYkrh85eu41k/Ft0SqYe5MUOy/YIAlNrjm3i2rSodyTVFjI/fQLEhPuaWpEjV45xRSImqhJ7/0Cf1kSRKJrq/JQlrhK0TeO7DqvBZLARQ8pTGTZqRvpPU5LqZspY12rjD7yYWQyuCHx6f7l5CCH+MMnDnrE/QJclEQALeMZPYAVHU7ypoOsf0Rd4BbWZMZa0HektelJtgqRD1cS00k+9+PFQWznSn7YueB4cihg1dqQI05MnbB9AFQjpoCHynFf9Qq0UWOJ2WE+scu/C7oF7Fx/qRVLiXkVAMxizwYi3D4Ccq7BZPO6OpFhiwWZBtSTYTzKcQgiPa++bsh+lcDkixrtRK73R+EkiOdAQ+Adw82G1N45l0jneZg8TQdiUeC7qB0+6FKvdOiRU/ID4coawMVIlIyIDRzJVe9Xnq3HmCrDLQC8ySoUnW+Vxh8Jw5Vw0kukxMkxDtp2xvQBSXRnnGbpqTmS1iD3yXHi6fkyFAZpovC9cef6lpP8efH/Thn5+d9nsTEXOTy666jsY2ybq1JPNjOdig+6u1fZoHSIzAl8gQmXO8qoCh2MyynMBhvJRx4aTvs/9HeJZmF/0o0YqT4gHlRyeD/k7OpySo8YUguD7LRgG9k6UmiVl8eyvPdh9aBbA6MVYLCV9Pjys8jYvRFj3dY4LTGfWkclM9XV7D39/sT1LhLpn6A5CLUo3675O2Kp0ynOEVHcBE5uUccuF5jVoGMdON/z9ZMdW9wF10mJM4Ns4gADmRDguoNjPC2Ggv0e9LqNRnQRnBl5rXuNDZ2Po9l2cQlJK4ttpfRwaNBQsW1NUFBq1E+6jPnpxgYvZRpViZljuutlClPmiHfA9/oexbY2CaB3PxNuwUzkKD0VqzDTol0hWZ2GL/xrnsED8UPhkwI+WasItWHmaW/p/a24HFcmlQK3FnS0awIdjlzpv269koXiCAVYKEBMC1I81MIy2c74ZsqIYN0k6AG9Wsdo5LwNBpI3IFWgihpEgw+qQclWyKgfA24prkvWgbzKtn2yRk49mydfuOMOBvYw5eGd2xWQtJl78kAxUrOXcFYojaBYpm5srO3e+k7ZTLI1sZo0w4i1By7xvNRq7zZxhz1fodjPp5r64k7uU7VF0g28NnVOIQw3lARmUbRE749VQzNpiV6aZNTpZW2nAboZ29Tsv3VDrUQcUJ8tbipHmxKX1ZxXzs9RbJI6jWeJKSngyadVre4I8j7ypO8tZQ+g+HT0xzz4e0r3JF4x9yrouibIt2ZZLWUt762NI/VJIRHL3wf2zqq3HeYXlafUdp2+u/tZbhicOZG6/KP7DbnnLEWgKzjYAP7Y+tF+dozSdA6iqRJQPDmCqLjZINLU/kNw2z26fu/evZ7duYdmnmZtZJ0iMMiRdIW71A/xXq+1Ic+p5P+ZRBJXcJafEp8iT/ZNzvyjCK5qS3xRB7vIOSWX8m93m0M1wzdLflUNFz5nN2VGxnOX/IPdmGsn89Aw9ZUxSgo1qCnjclCSNTT1yWAdPsaOq5U8AKN2WwSI5EFOgzDS7tG0AyEWhjRmc4aAWQTfMbKdgaBN9hELRPFdFEH95cesFXkYQwtZTJqE3Q48lKvI1o+SPlEPZClsS4VuyqCgVYVvUenxSZoHWbLD+Gr7nJkL1VdYbMdi8ynL/pgO3pw+ld1bZ/Xiibmy+LU4hjY9h2c7lmlcuuWrRMrMjVDiBr5ljbWwraaryUgdzArtaeVV0BL0NZzk+sGZkZ6I+ohOcfHzAHHM31m6oZfX1TkyW74CM5Fr/a/+bflsdLNnwHpmmv2ypymLk/T8Q24/Po0P094RmIzO2z8RTm+Ju+uBiiKO+4Bz4klXhAeNFh0pV8TQoY35LoxIWsci6AwF8xYiyh0St9X0rZ96YKBtA4s+junMlU9LGbuMEuilqa6uiUyaK+PWqzCaOjJhWAE+6WNQVbGXlCH28055ZrFOODV4WPaHVnQ9lOylWQ452e9UwXUsAxwIb1kr0ZF3835VcTAZa+FhFZnNWGbAag8LJGohQKPlLOpwqnfjcfLGZd7ROfZ0W9wPqaIST4658v1Ndx5N4dvjAODbjFBEmxIBP9oyzWaR/4JpHHvavO85NAdL2kbFfeFipSmrILbq45ksjqo92a7yuedsBinYWx5lNjgBy58FsASxqvtrCB95LVfqG/tFav2pK9IBnm+ulYeo3PRdBtb7c3JScuTW0oJcKiCDow80yCbCV2PFHBheIAr5jtspQFD2nFhodk0eQ/CBUodTME+HXBC58PN6Zp0PlcQCOcuuBORj5e6o0o+HHSv6OA940NdQV3yPd3Lmec0dyeghUlvh2fY33L9+HCuVBENKYzdu56KjsAS5gLSBrLelh4aO5xI+7oDIbqiMzVZfunux4K4X7ywfRwUlytaeoLvHar+qzoFWDA1xXIxeCLtrDcCnH5eZYZA7i608FFInBC7IgUaATABR3bLEHl/EkECfN4Hfu/k02/glb+nrqb+c4yLJ2jGhaXoYYeKGS1TyFM2dalr2pL5/cvGA96RnmORHdJJ6JrEbxYTyHBv68F+w84SX22iDDbLYe9tb6mINz+1cqqPAgmDjtITuqYoxL8KNlLKeyLccgACgUz0NThMnSsh/ito2pFhIksGX+sIWHp9NkpRIh3GntXMli7YmMXdsSmPBZykbkk2boFqA44G1+WeQSBzMqhpy39NbHWG3tEB8WqUThXngOXRgIpnpVIPuEue2+n43/nTMaS51RJGei3BRBrA2DunS1MTFIVjKQyVQ4rIY3DDhdVQTUUkTyMS4s9LN4wg7zovQFsNa9oGYDLlv4ODR8EmeO7RQg6Ru3aDiiAqQPVp/V57ZGJD3zu4d5lItDDOQFghSNaFSFbFbvCB1XESgqCb2bhzSn9Xko3V79RfDRWC8TKGEVTkcAUXRGHg69FqKZ3loPuq0RYdycwR6ZWufJZlewH+93yqqdr44hjz0qC+fjNq0Z8dZnNqolOuTA5ruehJCUO0i7McdNnDV7FS8b7zdzQOoALuPAteh84PML6xsSzcoNQ30gFm8W75CkCDTuQa/SMdgTLnIhqi9Efaubesw8oPeE3ieTO/h+n+2Eoziu7uUX1tN6SIUz56zHjhqBJFTuNjiZo+VPINJ+aTlquHoeqgSr0K0aOgFChNxzMoGyLl2KE21rw0dBYSBddF8yqhvhpdtEDOP9FRjvLt43oIX8MCrgCzQAgFrQKI28V4ll3NEqOb1PNTZxhwwzh4wUDa30soSVf2TnscVURhVWXtpu25UvDAvfnRh4qD6aOKZ3NbfyQ7NvtWBPSFfY65CP1wHaveb91ZHR1EeoobY8TdIRt7on/t/Bh86C/M8gtwZqYhAL2u9Anh4N71HPxvrF9FusaE7a5fIRBbNTPYyhFohp4T/v0YlC/RYVYpVEzC++nqQKEmAdDVrVfsrFslfb1BmbJN+L8lbshnCkt+yNon0lvqpExdDuf/P1wYJQ1s9is4QKb57kSOV2vKajy/ScTcFUMA53BHDP6noSRP0lSv0oB4Vcm7RRbotrB511iapBqjZ6Muufw0yd+JzmvHXFkzg6CwY3hRznqk/KSDSeoEJ6IHEjIn0q0dQsctToAZK+YaBNKUcvXtzRWJ7swm+KHETdn2s/RErzaoawSEgbQXqnhx7j8tLrvr67qf8ZG/1RxoegqdrY/6a/dDvdYk8o/4CRvk56w9M68qTChbqj7H4uyHIuKT+RrGTAWZVMwqZ0FvHJ36rib+brZFfRM+r7FS+4ucdK+AOZq/0kQj4NFSucsNuRbMS3NjbH20C7mlofzis182nMWKzQ2X5yClMyob1b+p8APSih+MXsVmBmif7KIUclXTT7RPMXeV2wElkC1yE26CxXZu9oqJvPIDjP4mFJGB2dOLqpHt2h3MgkhJzSG7to0ms4mFQ2Wu9xOWR14+91B96BWyfrRCssBS2c2U9fdXLRAmO8GcwWuyfveDv9fF/z9eUNF2DygG1m0FSEJ7vBQDdkdDHui+WCYxokx5kvRku/2exNLjDnGfFZY8GMGGFNFdz8siL8zTiIkqPEQWP7obvO0+NIg7pQd583Dh93B0XbRpWMPOMHNkuWlLpLkqWDP874VGgIMHMgErhIP8aLJu69tlgqPTOG40x0J8feF8P+o2zpGX5SLHi8zTDyYDpqNjgZB1UA5iBqIa8emLMpKlc0iGbaV84VFRTlrQ2lgMaqu+neII98kz8fdzquvWMA4GTfyAyuof4G8bZCwrreo+UyAHfpeHYzZS4Zk2SY6bcy7pZxhOLG7z0n1u8/CZDOMfmQUd2rJfUbBFDKnPhnLMBgfHdeHN3DalPpugeXuCpphiPEeP11dMr4Enru7JHJalrDt1jvSiCYNTel2WkC+Q3fPwTRMIY/vyjZFom9RqnXXE9OAPjQ1H813j3MrXGZCcmdxQjD3u5z7YNZ37Bqz/Ghe+aJ2PRvG7yRkdBuk2CcqAvRd/TK7FtcQfYwuKwfLa61Td8uH6cNg/AaY6HB0H29eD4pVV7Bv/XSqjP4NeEsgqo6YZRrIyuR5mB41B1a/PdPg/bw3l8TY07OobjACVKNv3dCdb+o4YAyPCHzIUZtdGKH44TtH7XjXEmbs35cx9w4G1tr8iE6plN4r2XPPz3VcYPc40koBbL3kynz7mATtf/6bv4aqcNUKZGvRebt9Q52dpM35G3cJeB/j7FtGwBtGnUck5MYn5vl32mQekrkdNerUPce9moGroy3M9ddnI6yTb43KNsq+oDNo0N1i5j3i2cH2gKliAQW5u7z/x2IQQtAzLxRkfGvS3bHPdMf75vdnVVXQyals2Oxn4vJcS3B0Pi8/updoMnYu9O2FX+EaA9vIMhj5/yyI766++3PJ8unA8+pvVLoS9XwT2NQBm3cNkoM9hEGqFtQmtUjsZvEJ1a4YvEHfS/iQs4H5+4BSCaj4i6W/cv2UT7LJn/SmUWfLYcE5c7Mrawkx+kmN9OzqlSf1QkgfywKs1qdb3krK7XfgDCw2hOVcK0lzadmBOU87NHHJCIjz4M639icSzrXJtqwpgDyHLh8SPlV7RqPGAd0ZV+ezEexqT6bt3twLUIRSN5EU2PvqAKNogFt3X3YNz1s64xOOoqExXO2Nfo40ZZJeRi0YXHgXmlRoB02I5UeqquVVkVQJ9PK3P3MbaAz++UMW6ImXsBmwLtPma4sJkY5g5T23KwkVvEv6p1+2P95y/bWx+7gls61VvgD5GZICCs72pnjNh21ZF2GKm43yZuigNj3fGto1R0UnsY16V3G42w3cwzAffgLwwU4v9mpTS/0+3Q5KAcMIwdzoUA6sHnApAo+eiuc5dnozqRwg9LytYwfx+hy0s7PaCqpyQ+qLJ4vlPkO4QPmDxkPL0a36or9J3lzSfoGxQOgBFWQmqYd8Q9nOM1ZH1/lbw1YjMBIGnqBo3OfKhckEBHD3iruN33oN8JC/+EpjRHNgXNQ7fnNrDan+CuAehsuG1ILmL6QUH5ZB8i4cAuqS1nbTsmSq5b3mvYXkPM4VCBXe7vX9nDsMOdXoNW+dawmP+W5LK7CBiW9vNXmKeP8X2MaFE7lOL63fFw9FaGjmu4gwJPdf734RzvJ3UxwDIMDgUVKI0gvQL2lGfvacnCp4Vn9Nik08ChdB1i2ht4qqgT3CzVtc/9zN7xqxODpLMOhKmj14sWUfYydsuKvtPBmQH8kqZJtQW9oD9hYTKmvjep5uvDfDXZBAe/raZ/zhVRa2TZEZmmdcMRqJ7Q+oFuLsEi2KvVR5gzYJp9pBQdF95t7q3qlm+71i2NxM/IuAO75lXXF1L/h5BryK/jl6nd379g2AKTKdb3JnPYMDnbgksOPiXQY7HRdeLrb1+d2YupA1TWFCY1cRL5aBuUOS0uYOIGiC2HqSYjXWiTTijS2TUz8ZoP1ULkuaWX8QkqTlpUz4U4Q7ln2rX35lOnlrvSJHmeTfDPGgFRyU+8XHxg8ZqG7DAXZ8DTP5iLXxwsK2tdK8ZTHcDW73pt6+mAsemRQpKxynYJMi/ZpsQcKDtAfwc4hxxFBMNtLt+rg+NYD4GAxO3uCdrjSESplxlEQKzZk5nT0x+A7ZsAKeYbjdErIxEFBy9TAFThTGwRr9xoBSM1pPriJtec45uJr9xEC8elDoOA2Ps2D3ldpXGC6eLSn1/BjFzzY/qQZP9y4NoKJ0DoYtI8Ck/5X7YTU9GyY0iUSW42zdiU2S/RIoWQHyqSeBaylis1ehopXcrPLm3UcWGfw6IDXwpo3zHCsc7bHCz8VYd6OdSWswYVgKLYemacNPp3nQYJ5xoQ0tJbI62voMEJQ+YavK7B6/fgwbOBgqbxz4SKBONVogqUGgtFP1R41+P6h0Aya4VrIYKrs7681olmTrhiYeIzuzKw7R+ST9I03hImS+LfZqNZsTeWDYlxaOcYdS24aucitzH7nXU3+x6jYaPIgoDD7Y6ZUHpGI84f5zGDCfXixrg/GW588gIq/CLozdr6/WavHdfpri6lmd7gelZGISkK77QjCJGM7dp5XNleNu+x6OzJjkYhGJUM8mkKEu2lRGpEPVzxmRqcgjFcAG1fPWWtE6ERTUeHT3rLQDoaqU1C80csVjSKf3QoPGiY2bZzs2dkUczSQd1DEFxUznA+XCht3AWpKRpTDGjGiGZF2ObS7tFPbmm0u49NiuupnQOrBGpyPeUJPC0oTL9x+u9+8XHz2uq9f6XmP/iWZk8ab7Lz/u4Pubta30Gjn0+UQjJYhcigFHWl2c9jrIXiQ8OQkLzn65Klo9C5CsIy8uqT6FcNKGtNsoJb5bccyv8HN9/Ze6qG1EJ4RHHWdwEgUol3qKu0u77z2RLdg/pKFL7+IzavZMG1xHN/1zJ+pASM0s1X0zj1L7ZOY6u4q32Fhk0wv6u8jZYw5CjOpNLaIShkUeIlSHysI5OjkmwV0PDTJtAkxDZEwmHHeVP6VA0JmbawSroUIp3QA05+8i71aNxDzx0AcYmWv/djBEv91H4J8gKqzrtk3PYVGSlhS+kg1NH3pcInUdTjCKENvBj0BrlKdWuij5c3qreUBsLFr9azXFn2ITwYoWlTgNjpMVN76yvsKEqJmsG7Ys+0vMg6NrzWaexiQ0uPEvx+L7bsGGN+/eltNByRa6Bn6Pvveby3jqZHPqoLeXoYAzhav0HB71CUS6JrmxTTLAe/kRnw9ynF9D5DAu5ixXatnw8axufodb66u75z6dL31Tkga6z5kq4EnpkurSfdkcqLBBh3GHZ8MSIdPaGBACKS8L//XBk+buzBOm/iIX5WcJl9eti8zChgx+RdDbs2el6YF5bc8m3ppI3RlyTP4WW7jJu1mmrG1zJelAwFNzW41k2QvB+ezzLFWCun0dTGtu42GQHy6ZLixVpjz/S9Mkx3QWfYZOQ1BRJ3/RXsIM2M5KCq92OCLz6pZKAh598yhNDBFRlwDPB0xkwDcO3XqTUDMjUfOKuKFMTewYmctg+4HgJjB2Z8w2iGvSmVP3DyKZC0pDLj0uu5vwdpWGmdE04na1n/cO7wbqL7O485SDl0bdjLvLYJTFI1YvIWChXyrBWkh2M+88yr5nRYngGIaHmEortMpLQZEaMvvbIDs3w5A+sFOU6lOHV6l33rEhFwdMjMj0WZbkAxx/PGeYYG55nCz+rad97KJe5uwLsQB01LX6/SM0FBZGRZjzlM1Fx3X8+rxgZzX/T1hjAjRNVBYblBSvDXb/d25Z/R2s+bcAHTq7F+Jl9cIGuxKZTFDQkKMDv3T6k2p8Epdm0hwRdcxGI0SaUak1cCv8D93L7g1AOPdFSeTbFK4zAvkL/7aHYJZ5LVv0jyGg0hitGqpqN8Rf/Uz6VISt7Fe7e/bJ4lDO51F3nCbBPswqjEpXceqvGxZwh4NDyKCP3qoH1wQlKGHWrzKeJzCbsWJX/ceGLFmsr10ikoAWKQxu1N1h1PcpRDNNTfRkdJgCxpi8gr3FzIlRWSwgnBmU/sDAYsCfuXsyNDge4cm3OPy+JdHGikrvG812olVFGyAaAC4LnbpfKuzzgLGDdUOSGZdYs4oyAX4/rg+ylOERnnlCH0l0e9fBOZuciWkENr26WabRmbGnoV2Xz1zYML+2l0VM6oG7OXXNUUUuzMqPj3/LOh0mcJejQ2L+gsdnQ+fONnL84xZuvpL5T+TrTDJ7Ew2l6F6PvvEarZfmnJlweRgRCpwIjDSTC392/Wdansi9Avk9Jbwv7EB1vtBSIT1rUiY1wBRBzGmhvvRs2H/X9rAv4hAojj9vrNbJScAflcNFKjwgBnGDBPu9Ntj5xhUwbwngJIADcnaywa0P6+Pst/AiA25NWCOOe9So823qiGWMrp4+Sbx5wrdyGV5vDJbEEwwkhFo3XO8Ff6T3EdM2po5rQo1qwqn4RXu0PMBxPgSdD+qBao0NFXs0tytfDpfGUTM/oWRU2mU6RG+XQkTTVLl6ltbRacduoK1uF0qaFeJeM47pQkzmORu+xw1ATcn7MGcr00ockYu56H/oXkiMjKuxr0c5pNn7Ji1uu1ITc1luvlSX+zkWlZHiP7JqnyVqPcvRiQCqQaFFBy2pAdIDd0kNDX4EP6BhGJSFpEer5IzL1RBC+G4LHrChdbsLR2VlNhOaVUqN217tUlwcRdxSVcb4ySDqzgwTmsT9MJSn/uMXAFUVdTNtmwCpbudKQgo1210hoTB9LCoU/gwvn2OUiIR34+wNjWgFS+mfGjCMHp5Q4GS3vDZ2TtQdtGKVES66KvVYbyvnvOMeC97H1Ehre0rVQKOAdaLFzwB3iRuvxvii+hgJMtsPeNeiEFBhv9wWCF0/RpiGoO2CgdLRX8xI5OMJzjEefUb81CA9WZf4WQ9VNp1BdhDkjDgauKGoiOM+CHPhNG/VorAECpelsr7dPQACKsYngSrtFQtquBHe0q4w4++h2T7ojvEgG733KwIda53uWNdqXF0M12PkMtIca9UJ1aywuzSzZpTVIki96axOUAUxnS2xa1qzpkaCjEhRtxB8q6J1jY7zNBmZ4xk85pfFRkzsQmPTgyMr1VqTxWKP7UdlTMGIOwmxPsL99pgFjzk5UISjFgtPUJ2vc4g4CLcEVuH251FnecPYfsSf8oXC9TC5zGqiqn68rMidntp2CBYDonGkArHhIi2dmLsk9IKK6DnrFQ1Kf3vdjpl6yD/xF+1iMZW/XzOaQXcqKCPIdCAxXViZLvUcELBEfQYIGaPmoMrDAMsT3BaN6vQWj88r/H2OOjHF6i/Y6NkldJ2D0mtJ2fyndxidBoJ3bTaZl+0CvxosSQ5ZxTT9HOYuiQg37XZ8d5cF7D/SLyoQBdZy5AuwrwqnUdCqmaZ1OJ9E6FQwpLTM+yyDYHTDESCKQj4bFhYNQhv7lhyoncej3AJGgsidrDh6M/30X12/tRqQKX6Df37RAym2Hid5+9g581q0T7pIh9ViT/fozChmcOQlbMd/ysIjGt3M652YO95GATymt8ZOm8siZn7hWAJkf6d+DnkOXxGE7pQh8OP8UtWBebh/0BvkLeEdZMdiXRcjhgbgI1WMU8Fu324Uirn0WbnYj05WeoCNEJe5/aA5kV9rFnJk/CAJ45d9vhEeMsrER+WBCYz6anlsHIjMcdCowLOSKn+i0Y/Kz9Czpk01oLxj+kIG4tN5ZFaURsW7VUNbunWHPZsAnpah+ubVrm5FoNFtMZTmKX9GWvp4dGNnHKlKHy7zxO1z0YtSneb4qoMj3Ops22v/Mz7ergvHeeX95rXpv3LIIag9oK1W+l4pbz/YKF5hRK01DRE5ybyadaTfdpdqvDGDVreigW9bdSUL7ED+9ECXBaAGLDXoK8q7CFLy+RXeDdChtsjjfcu5f+viRuZeHPxGJclOcBLCtMmwXEZVEG+gcVdFCQLRqkKMhXHl56gmucNw47KF9jjVcqbUugIqHOzw7k/kt8bN7BYd4l4m+usZF4bvhtBUSAXK44PFZJzJYjuBQuTM9VAT0TyUpDC3TqcwbAQXIMoNpMCOpbVHc9JqCYgSYh/vZqrUUE1w7qpvbKpqhBziNm9LviIAcShMDES96G26ZBbgZQ+O7CuRMw/SRUoS3KmdLUGPGmWeEmhxCp4XMxGvOvm6D3ZaSy/3h1aocBlib1J+HrJEK/NaCjVzAfuaCKOL+y2tOgm/WY6qxs5i4DigGnHk4/PlrCxdVMcdxnkFrSYZeBiph4ry4D7a/OxAdOAOOMKNhWJhVeJRd5gHWTexGJZ/epGsIxbA1F905uvt+SjGnEqylJB28apwnDxd7y2nGs30vqBnezwSYFQxMMMBd/nw67+I38qOfcNUJLutqucqXIUfPaUAbXZSBAcK8a0Ebar5puen/+/7s7a0t57FoWYZC+HiNgg/5TVsbgT6vbkE9dv4WRbFW5BmPGjSyCggA7kiYssprs8vndUwKAXPgbEOr2TVml8u+NK2ByedUOy33YAnWzxwxV/3Rq9BKwaWMKYj0Ra5IzjOh2fJ7A+TLIeGeDHo+FjLdrx39rKzhQJZJJk1wz4Lm8kc0KAqb8gKDLL5e95r6pQGJFXrujdXeglDwpBQdn1X2WltFEnhAuhwnxccRpj4UljlcAPyCuE1vz/gsha1+C4qzEMrVkG3Yc6WcE8bIi6cTinI4GM12P9quLych8x6Tqn2x5gsAFVPMkYmGiR6G5N3FjjdVmZu0Hm4/cdzJpdF7ZstkdNV6pLXUeEeC5WvJav17hLlb13IHcWovV66gFlfkPY2TxMOMUYmfTaGIvmK2iY3mNb5ftMfOc7ftZ3M8RjSGiLhldax63OATHFDQTcDF2ptC8kQWRJmqgoO86WI3KRMjwk6Vub3cy+puWfU6FcLKV83B2CWH+xE5Kak1SqHFk3fBM8IuBzxsn1iUaxAaffCxfpnuMMwY8sr9dBtzWYmwc5YrCrGOjoAmhPdOeRZJ0kdAtTv1rfiUAk2lpKX6kCOn19GeaGQI5812wLzmCB490B4eskkE3KB0iYR7AYPU7izH7iANfmcoRHlOHkEheyGloyjwzURnElqjBJt0sUVYf5G+KXDk3qADpBHVm1rH28IU7p6FxS9Ojr1yC/H8svyTpesT2ZYFPASsEAAy/j7LSJ4gL5Ic9MTWyl9b0WOz/J84vnRFMmgemjK+U8Ph2pYyUgrV1PmoFizaGGNzJa4m5cf0uT1eYOfJYupY3CzWsTqcX9dsbGDYrjU1jheHfc+FG09kjjg/DVLZYZO7NGpgn6RprQJMozNA8Dl++vcugnQZzOGKfMEqCEeNnufFmrw7sWlTNbKUEHx4alSh2SfdM1gUE7o1VBoJGp8zh3IuYiovcZBLmlI/8l/LqnKMxXl+15e/9O13x2yMMPBNQMXFPbQfA7aFEGfnN9xosI6nW2vVwsVnIUq9iPK0V2h/cvPoHY/STudSDyZMbym8xyBMhWVxVgzu/b1JSQlW+BzsVMcdJTq4+os8f0WKpWoMVPZ+uQOhfHkduxbRzDfEyBVKErw6y7Q34GgGRW30aiF0cdhUnKHsHg7JImbGFAtokwDrGmszYbSxZk0yo9oxL2Zg89i5VgQdUbussx0T2ckmQX0Sq/uvEYG3pAYDBU9ufA7WFV9ajLN0soZ9F0bZF1axAzViUp0P9S3y8zD8/BZ7mba1rEuGuc/QR8htXNMML/PbRIcG9VJj/P51kyUE7fgiTn1FOi/VbY/B/eDGwxsgGU/ahS8+wKKX6DpUiXWqb33dKNdDl8yE0laUC8aV47fNiSmYTUHfE2McEKhgZ9KV83W4TxRoMkOB0sBTwkvEPn5RNRLZ1AaboeFflczMcYcoVeOr0StxPR0zqe3hjgQjlDFVx6vjjopGPEFSsUZHAL88YJ9UGCmrMCsYYXLXxfExlTVugzY03fv+6uk0Uc9SNppUrpk/397J/i48hvgOrNGakgS/Tu2RZ20sRDp/IIKEVpqTR3II89Igia0FK4v6kGbz/Ai0Sedb3AFqYRcgVE+JydYDzWNLnS3wg0opsJVDg+50WtN99LgiPz/F6frXPXVGRpYLndxC6ASq4JJmToH7/objhSIZTaTXIXSimvH+o9mcrQS8pWs0Yza4aox5p1Tdhv6tepDaSljrth+JmrzTHDoFWcwqbnJQ1xPyZtCl/+sDD371TfJOUvxSSdyNOcmPBacvG8Rcg1thfn7kRmNlkRoiTbIsVEO7vzKwp/66uRHWXXOaQzn8JNOoJ/Opeb5pHRRoD55yi5oXOWK7rvrWHsoBb9sEk5T9yMBZ2HqX1zy1BVfTttBk/c1aocdQg9HF5f9Sj0JBnxrQ7iZca9jJ7uVm5z4CzR+09OXrlDHBZUAodPOqG2BcsNkdfCg/8sj4wfjiJfnCMvA3awJEu/nxMz3nq2w1MrwcPG5RzqI4/OB3Rzbzi5MugiFHWlavFayuqDngFyeXgmfMUZmmevWXFUgZKRwfnqbeD9Xspz/oVjWw4xC8oWl0tZyA68chK5irIvXn68qSOlzea9xKwaqpNzGFtt9K9y/e+7AKARKAbLZReCEnFV3cKvcgEZW4GsoVSpwBJwggwQG/QLvUrIDykMa3Y0Y/rLVfmbyW3xdTlY4F+hoDo1YeT1VL33gjbWaliJg2MCpUaQQKevS8OcHhF1ZY9PmJsTd+oPYv+W3iGTszs1ZBjJptThb/BRQ5KxZ54TElthaGWbdtuNhPm69BFb9kCR2ZlLjaNP3+hjhacjnaxQZIAf2bXqcYhca67r6dPqwqEU/WWlBzDC8F1jXYJLUA5uy6qgO8+TOfVnFl5o0RsoNWa5XNuBuzoiRqmdEY9pfUdptS4YfHISfajP1VXtNW3grh4fKD5skpSUIhdq7KczeGl1BIaSn+MznRgz6Jn9ns+Ci6JTzCvyZ5EeGNx1SzIhUTFb1LbWnCeS97Z6BcZU8fu/0m8KMp05rGvPvHrUi3P9qKd/aEpRbVVAvuWzObp3HjzQCz5qMw9JPO9Z0IAPV0Lc7BdI4l9Ik5PGI2vlCdLJd4RwVZG1EWhASyMFJWWX3EuqEuz9kStnHfNW49vJGtdjtylvn7w/Navc9Gza2NEt0pg9bG0LAHo0heqGeVD5zWLvhqGSTSh3809z8LgMEvPJjz+hk8cHW5x9pbcettJ+3/YK+PtRZh/sYRpUCrIJy3PBvgEN2XyvYvSP8ZdDzfFhWwrntA1+CPjowpyR3XJVWWlPMAWdA7z9GZ/05/6oB8BUtPcF1MQJqjyW0E+0xLC96gEeMTZr9cQtRuX6r4cg8C9UoFMNEeEFHCQ1E3ufdA+oSGUhS/CjSxk3D48a9tQPW8d47PAtrYwDN8A57SmCd4WwpdMxXWJ/s8D495FcAUERDARPSeB3pPFqayxH9F4ltxx8eltM/IBmJJGOWfvt5CsdxwipfVk+Pj3U7fouccsmqQzW1WrO/LGrdH+Yc6W7klEVGuerNBYgTvPjiDT1pdnUeCssqal245wn1gFD218Vt7I/ogn7QJd2BPIVa51DLLmGgTGXCzwmH2Ux3WC4tdbI/YyKWTT+odMeKJHlEgJhI47LSeSS0fZ5Vm/bwNmPTINpfv+XElkddYOk+Zg49X08LbXnWpSKcXSF+IY5sW4Pa2+Ca3a2+8yQ2OXbQPCQ3m8wn1zkQUm9AGVANQA3dMiYKt4NeJi2biu+fJ5dyDAKfsWtIycU8zDjCYsWWFT42AFnbn1H4uCGAuUtdrjIJvlIF6qv82HTgOfYV92swu+Fu+0gGar/T5rZf59BUeyi8QRhQO77U0h98gIlGBfeWEwPL18VgbK3UAHsBdNizse7hOoL635CPxZ+s2KvNyQ5+kPhZTIJzcq9dSf3Ipjrviw8c+kOGcQ0TvFA3P2VHBukcIVmiTMH+Yf8T9BC9ZBUBkZm/JYWOGqZ08V5gxaKb8+g8SIUsO5lWPPfDMFuKXAVrlT7YxX61zjfaLL9HQxxsG31u4YumbnsBpbYEyaM2lXT0gBcJhcs/n1d40WlbuECsxXQwVwxnRhO8U55Y/LDlS1lEGRN3rQdNLNI9JY1LgYVDhXZjz2rijpfNewe4OO1/H4bJY4krtBse1mokHNAA/dUSBrx2/G98tksTxF6gG2P7yY4N8wVLQFEo0ExfwV/RWjWRMvEfCAF/coecXoonFmMdx3mCvlZ2/aPqN8/VIMemuTtIVPVV42bBWzsJkr70ldvo1zbhOOyyveKgo7QomGnvViW/pIwANUOjOHHE1+UuGpoAeDtBr9qb6HeErNSAdjMhxu9VPm6levIQW5HVEVATLLmh5Q8/zc6COJyqsxV1BwbyNo4xEce/jekgl+oiwwwvK7cw9MilUQ6UQvSM84t0GSA+OPAT6xxZxdvw+A0oenpq8+fmcJGe3FDVRJRfwCBTLOvIVZRLrrJd3L2BYWMKgKTpcAR5YM6oI+R0gw9ORNoolee+x3NfMuQidMz2jR+mZu8GzVZZfh1jF/2S27yI2NgzakZBW8GHbJR39iwZ1jStY01d/vSw+HaJrSh5NiDcWQfNMIZNzAyj120RhV+QKoPa9Y9LN1ONKcQgGVf8KLZcszrpMvz/V1Au6opgNHWfw6SYOf6CQTCStw+w9m7L3/8EnhDi8aTRNtewcr74uzvlyoJNgRYXFi2L4cXBn2+EpB3+immY/7nyUg5PQ71woiYsz9OPSrZvcfNXVAvcztDu8FcuiMDTLosdbwqYbDdGZt60gHYCt7RI2MFcek7XGgmLIKOZ2a6406Xx6JVilYcuHwWNtU5iYUu6q7fFKtNkAlWwZ/i0bu8p4YOxSmH+RDZ9kbZy7a1vuaHwMG+gZCRhiiWZsiA44WjzOyKM7zHSBljNCGuxFgY1L+iPdJNpg51xI23J6GMDlK6PMgzn6UA5LUDiTLTVku5G9H/wmdxXOjV3TUDVItTHRaGKj39Te8tj/fyOsiQfKhNojml3W1gZ1rQ74dtXtPTd5lX3Vff8C80REGWiK15+otgAgZH0dNypsVc26OGFCaf+HET10EzM9mC5CkXteBcdhiv5sfj+6VhZt70mOxUQwgpMFeI3qTNe3L7SQ1SL+BsXxe6WUWZvzY6s4WKRzpgJV8cKCKKNG+9kNChzwMLlLEg1NopOdHVhtrSOTFx8LmfFIdy1n98cMiXoTKRCyJ1S4mfJ5N3/I9askfOgj2ke5+5N/yNJAzpB98Y0Npskf1Ul5NW+0IhaHUdpq+sRtDtaoM3Xe0qvg+XYKkDA/8HbJAHMuWSeibqdnxqFLo/9YqyDs8FkifIxqMvZiAISJ9PweAHJ1l8GZ4/czNxbGdHAIrJ3ljYQN508utuZv/DhUeiRulX27AFPHiLo7F0YOrmRPMvs7YZO8zw50PMp8kOxPVar2h8QrSNdJ2pAfrxpnlWwIKO2KVhvavv8nk/s3PaWvZt0QdVlhkTGd9lu76GtOP9LM7dCQg9kDVTv+il88XHcujRFUNOWwFQ0quiBA74Kb6tcg1cycyI8kEJb3Fqa4wMDQ7w97/p1mg4m93JctZYkYOC91H6R8L6vBWjyksTjpftp5Xn6QANmoJAdqc7hc3hK9WKtBMPGoyIRneW5IbUvwGUzMgdinPu45Y7pHPXPXdTh/5LVbj9f5o2WkGf47AFUoDxjkG/nd2l8l2dj/uny//fZT387Cu3edqepEJCGr8rKzi9lTwyhCR9l4BWBVjMSxS+IjljdOnLlwdvxEENVj/KNosZ1O7pE91wGN2LaKwBIha0FI4DLON4dmEzZ/ApKyWtPcZm9RWmBgrUjam0jcJmia6Vh4ry/uLDEdvjj8ITvKL5WErIhUloZBB917WFYWlQS0DmRaaVJDsPPJ4pChWayG9tOoCKmFeZ/vraMID0Gr6z4+EzWQDjRdWMnjrYZriVzmeOvkvpUX+MGgu3Ey1/SdN1ikKNbj4IbJux3voUnMluZsuG9o7td0G35sCHlxbjVswVY9WHQjmvbie2szMclbiT+iW8SavNtx5M+BZIanZ30aRlzRdq55ceICaEaDgTzK1rhbfTR/RQeS9BUoIifBY536u6JxJ7uBOIMV/WsBoPtq9BLHLk/ICggnIe1mH3r5LOQkGIKznCd+eqmQ6djBdqTtyG3rR8HYU67OwpX0Yhd9q5pslYjYyanLrwdkk0mEo2hAyZdzRqnMYamxM/hjElsgSTzqVcxlGG5U50bPHNj6+unHtimusAEzehU+KegkFYjdoFxGFxnhwSGL9V7XrQwur3mlGFOJsRzpZjJUFWb0lfUPJep1ci+aodQFFcSaiNlb0Ms7yUmui7jFr+xSZaQYI7PDSdIKq+PXrkPsQNxCN90TfAG+xqYlba1axGwNev+QNN2LHTriICWXE7FxmYX6XOqzt5RuuOOue/c2kYbxOsmZgK1soV3ltLXutG6rshUn/XzCJUzwpKZqumKMBLV/OQYL+7WiOIV+Pebi5GMKSSR+i9OUpFa9wNiucEgSbkXhAWXSxy86V7FDxEU2t6w3QgWvltBlP0N6BNrT9vZ/TYicMXj29ua9DxYBpkV2Cted36RYiM31qhj/TP9vcdORw4gB1DXtVS8LgaGY2dqwD89F/iXHzfcY2wRX/Osf5IkD+DXrTA6JjV7SLzRwfi3RRjHuOAjsySUnaViHY97crvWEKncscYTfMepCPZ03DHEbmCgCFspNUwcro43lzzMwIJHSWOpnOsYPfPk9Rh9h1MX2BMZbTDtBKxJx6+82HJW3yAjXrBuJ6njx6zFjsJ+qL9LkRjGAdlA2vonltSPsXKl1vAUfaugqE950UDzyTWj4q7MXeAgwSeaAgQ6igTZocPgPK5LYxwrpBnpe0PGKRF+F3MuP0ZcwTp0dWLlRohs+QZc1oTP1ENoFal0sNAGd8cI+pY6E15BdeJo5Q8dvfbJ19WP4oW6LJWVqXTCgf8C7K6OgeqEV0z0tjGrUtET3eOQRMydc/0GzZq68K4SIoBNFfnrGAwPbQpgF4czTLmYtE126JQtu57EzNb/wnza6nrSM03xkmckK8XgTOwpee55aFMNSGP5lbJjgFOWF78RDz9WCqi1aa1xg+pmF4M8Bx8I9qv2loXBBGwl1C083AL28BZjTCWp5/PuxpGbqzx52lwIZg/CXHWnmDR+GtEQY83D5uzH2f0zQIvmUDAyAltxOYA64uBIR8bGQzsfARTESvy8FLcWfUv7lpC1PmHhGJgVoxjrkNy7f/a9yMANh+OJnzquDfoJv0AIyup/UW0GHGRSFkH4FyG7lhJQcGt7W6ctDp1fzuxHOP+7otBRXeG/3H19yMpTAocgQrGtS3I6OYujgsE9p56qIKi39JVXjidrTl+hj8774AZjBQ/dJyZ6OMoWHIZYDqpuAZPaXNhLriI0qrdyqzG3rh66Yx1DkVnprhP17PCBu+NNDLqlSehDyg9F2hGMtC7XtHF5Mz4w9hrz2ye+w5iEcJsJD6n2NQAKy+F2Omm2nVB5Uv51HF47+PQrUKnI43olY5x45FtNkbUjw2paS/tqM3ehk6DVYo/CUNz9g09ZgEuhoYGI/bFxe8CcNTZtk6s7PAeT8jEhX3E9C7QoN+jUVcajurlAfyL2/8BCWOlv1bNALDdcasx79mx1kYANS0ZE9wlZ5fB6KOiGSgb9CWt6fB8M+qAwHa1zu06b1GRUpI0J4uT6z/BTKU3gK7LhradtSmA2qp96ALc8woUigBqpBIVMrpptN2RyvHZcK4dg2w/NW9ONllOcozE7aFjSwGU5bScULaLGGlunVdbC1NdsXXhCuzsZ0E5VZwjFbBUgkb9fiUjunWvayKYzFGPSLUZF3Ucg3dvfR+SpxBkQ7nmjsv/2ACkjaOEoNz1Qk7Yjwqh9c2/NDPpNQGHis59FU1C2TmnJtE3Wqpx+EhPl7YhZQ+rR7mwB9Y7cuGnh4QP2YbXmcbr8gR225ZPYUL99UvKaiACScDlAwBLkW+CGBuxBE2rXU2PRJhmSy+FUhgFEpEphzcojVjbDGKZJbpON8xp+JFeUYQpkZ7JZdfqn+v2LmsGdzALa6qDt3VD1SfnwG8O4Cj72+EOYsdZparogym7penfjfSMvv3fo3zTomAmkCMoWqYQWVCSkNJyLTO1f5o6zuIDDJULckrig1cBN9UYzfd24ZzjI5r4ReHjUVFIfzxjNkw0g9M5ZGSSRevkymVcRP4U3Q1xq53OSd0yt3glq08kU9HznZHRKgMOkMg4vKcyPwsBwVLeu/LXMbJQ8UewuqslyDeezNfCC+vGXCcPeIdYAfk8PBS/GAl0bWAMPNzX5WnwwJphqmqchRsxhbxKsXdIog7hrElsDDWlSEBLw9lL0OTosrLpxFgyCNnWJm0W5QDkDA6m7NibR8xuLawmH9uHI+1AZelmRc57B5dEL74bX6A/ww2cK4uiIWPWMC8Cgcd1QoTEjiAOL05ZkFCajzb1AM6sJBW2/BZWRQz1+qwMOOKfLeK+Xactp2TUjZPi17/mobysdF8sKuS2zCm1ASCK1siF+WbwKL/G/96HP2fx0rWJtweGzwm5f+/BshnISIp1ixWPuQ/ZyVtGHAbo98BZF1CZwLq7wAfkv0zfPL3T/urmzwsl0c4LKEhTy6drnPF+yNmZhEZMB6ro83UH8oqgsIM/uL+/RimP5pJ3iwmWGEJvPxzQKVZyQzISC06gj+3SB8KGjSSt580H1wTPrCGAFBQoMSGQ8akzRpDHJ6nrhTn7zbwstpR7OM07S/fe6kC/po7WJZ4mPOu5BWnbdtZ4ZAxGgTzKL205enIAzRuPshiwGDjWNzI0Zf+jHIcQj1NZZphJuxygkQQ/MUoZTfGhtNCjIV584XhOkqXdLBE2mOC63ETnXY9ehcjzmzVqsROmosxfczotOOuiZieTE5AcSAoAUAAEs0NbQrho5qne98KxlNhzoyAlfdY80xU9PQoRZ7ETKE6XR98FEkSG0xiMcyA+yGWLHqVjPVozzFchJ9U8w91h5E8Po6w8AiaSpGuofWsPgniCiI407CZRxRfgZzZMjrwb71czaKQX1ZC9tE3Vaxy72ZA/okkZ3mhyg89du/79U4ZMZSrUjbp1cMJYhHcOUhbVOBuvG0l3DB0n6/yoaQqOZjtcQz9g6uc5t79IM0vLeQXwQjrn8+mi44UvuPWV6o/jKb3Nxe1dDXCzIxLNJ3j05pI97ITsmADk5XkiDYkIn33gxGKfrL8yd3kII8UA/NPP2e2cJYz3MyhXnsBzIJAZtz/G7KQsDLW+m5oRXtLJQLAkWYzZW2xbTyEw9bA3+6V64pkrh04hqiN5zUtVrhQULWiL0aVD9dQGGmb1DoyY7KYccmkf1wXx9BhnudGG5Ong3dVVtFqGo6BTZadika8EnIzMkgjHUBxy1Vb3b34faddATblk8K0J9EA64bvS6n1EginlibEGH4Bq+T3lQIzrIbhHkKGV4B6ybrP2Rw+sAr/NcL1gUTEMERVyTM4wdFY97DCkY90Ip1wrxlTxR5I1OTjmULlOQQZ3iOZdTmx7DTqe14EQ3T0XguOlOZeZFj+dED21veRFBE826c5rGgnoikPREQ/RpkpPKABHy7nKYKIi9175GnaNT/n34CecSoiGQabkQdYZBhAOgEEWPrnNQoHwxTR4UPwGv/Hcrsf8134kLPJ2ovIj8dLBILILzqPBHnfKXTq0tdOEHgjd0nUcPl9Vrrk0D5UQY1i78QTnYIxK3NteTPk8XodnmBkyUxAkRO/W4urs/6zE9U8N18VunhC+GiDr+efZh9cDlEbZga0KR18uNfGIkbYh9vELMqSBZPKf0jWDbnY1TOignbQDhA4Bdv0fG9oO25824cQkiw9MJS0AoJs5KEIn/wn9S2FTn8wLlQ1vJqVqcc5u8QwrwbRgtszTF7UAxgSif7piOuuCOEa/L6RrXVENgS0EzoOId7O1UEot5Vr0fxlQZ1dTSO3m5p/JkbbDumtfwZRhvlDgmt7xfFKeDk/bAIN6mnkRb1marYbgCrlK5uNgD+BRnNYx9yApcvvfLQ72gPkwU2th844lQaH4xcdwl6ti39wyw9lE7jDEn+q+ypQYWHivxybzYmY+zk/0JfTYmDzrT2Elx741uAoIMOtvlW35NdrBK5wWAFwdzDcsC9tKv8YRoS4hLvjeuiyhxfiL+rzfoACX6uqAQxeSiOp7V3efbAO1aflYThrwevzYtAXa7d67agyJ+9bZ/eYpkdM6I2li/+tIiw+nFWcYKC0dtyCKIvMkbFHqYn5Qxr5rQPuGkXv6Oq1otfm+4QOq7+bKVTWI1/ufef2YJ4gzeIg4QEIyqN6NCCOrbQyWZhZk/o/7bQEbbZvZK6+WbrNnp2IF4lEhogqtwPJwQcdFPNIkObA+IuAwY8QdKtBuvvd/xPpQz/9ZGjEKe2y4UVm9EWJs5svG62r/fCQUCemKFE2flYytW4p+gfdKGJuJHybmu6kl3ImKh6jUdjp98FXkPsRs9xKYZ+dYcLLNUEshBQxs+ElfLLGeea2A9/mwkm4ZyGjt05Vy06rU7asuCWFy4xpitefeTeLJslj+XuQHJol0TsA5fGiSFiBFbaWx+ZmkrPeb5Q6VanXZvDxoKn4nf14Z+H704V1zJJmgaIkyBRRHT3iNpBjzf46x4XUMG+L3GLrSjl60RNecosVmOThEy5yQKQiwUGwzCOgyEGHr5wGL80gDkfPV8jqAARfcb4hHemGJsxtHR2zg7AQP52nWFgyG5Ven+qqX50pIdyQmZ9lkFutETbqC8ftiWcCDfyoH6+LuiAy2q61avYAPCo+z0w3Xuy7vOTOR4wJXq9W29bEDpJB71kiK/O6Pz/nqQ/JYD+AxfW3WWJSNiaupW5zuQKjtA/Gvx2H1apVCskGILPuEamFOFBRD2A6ywXZ1YT8wx7KX+JdHfgfe4KfyfYF0upQs6ull3M9YCEVESdX/5HGZ3QGOgr1sMp01W9uKI97CKw/r+SW5gfedY93lBcj8dCSwm6nco+6+27Z7EnA9+wEf4n3/8cOkqsRuccxkiEDK6/EElS8vp/kzKgXUrbm+xNY/7G3tD2guL98HIjDGDlen+uu33l4gcrJ9sHpRrEglHDJzAo2zv5VW4Nb0nUXbBwYByEAFR5S3fa4GCxvI6iUKc09mh1gLxDvZO9nae3BfD2P3Q+/kGmvmqfbW3Cx9ObPYAvNDjvGpG89lfce52o3ryV38z05wubEjdjWTbFszsyGezFcLzRuPA1Y/W2sobFdlLpC2PjGXvmWg3kb5BwyWHdXwP0N5T5ryRXkpsWWub0hUirXGU8WptbsA0TdxZ70fOarG9TJdIwT26oLvLdnzZwUWQPoF9377jB64urwfXiL67S5nC5/gKDLvwE18P5b5ZVf+uwDZdC0tJNH6VtThMMCynZHQLiLsuxJh+eqRHWe2un7x569UIJjJeJsh2xcpdGwerL0/7ecPVRI7RwYVjwaB+sDBimXoK/q8h5GjRKHDRZ/zYJQbBgHl38GR9PGTlNdCOLDfsMT/UNU+fHGktEV361mBOwgoWEMJ20OD9ChzcOl4MrpetE8FZ/PTnEFdghtIGkYv0JunTksGJINQWmluwb3HxDgI3izdVBJ5MiZ+33QtdDLvbonSsdCiPzW4ga0PNuaP3mw831Pho2CM1AikV7NRl5JFt8Wh+0a6rtHF6bkiNI/z2HCUeAPqaF6JyjM2+ASEDeSzdkfMt2l1oVGSlYM0GtTKGDbv/ogMwdgIy8Dte9xuh5adS+G7GPJxhjteHPqHg67MgK3btX2efz+LVP6Im16ToUZD+zU3+je69Cg+5GHBkhp03hMdz5vBP8OLckRfro6ny++s8fxpXvEe7OHDoLC3a4mIesnAA8BMRd4Fd6HqrhFEvELqBLMkVRHnxG/5V8DlLIinxppWdFlJigcgifzAJueqTQCuoHntW3YP5BtB3iqS+HRr4fD+b2yaMGJ4RxKFJqmWnoaJxxjlIp1v7m5MOJO6V0WAoQlq4yyf55Zy2bDbbl6DreaVe+eGdOxVDzOKhkPYj2ZgyYd+6YUAoh4waNQkwPjU+A3TG9LIUW1j2xZ4EC2YYsUxBAmxR7+7IdMrPRbo9aJvBp2FYDoVQM2+ESmb0B1NR1iWBHxC8CRemrTTKtLNzxt3ToClOiPqbL97ArgIPoWvF8HQkFnXWZO86k9FPYvWSRHwQ9MuMK/2qo5zXZIrHgbpfis1ZdqiMi/2UFvdb3Z8H5crGNvuh+iTuokLm6E3uEDF61NNDcilNj0gVqS5YHWVkAPcU8pojbOh3BgwALnAIdQTRTEPQ0Bc3ZeJ7nHoRbizZG7AVlVpgSf8W+UoqHUs8lcE+/DtsXnl5D39+qk720Tyxy8gAeyyLzQUz6G/qrwORNczvfmfumvb55lCIzLAgrZKw+lxINqOYIC3ZFSzdpl++SFVQLNgoUoJZXy9FOmVai6kHNksYkC/ke9K0goOZGm/K6h0c2DVOQEkqJfEpLIDT9zvzXsPUsdJZaoU58s0pydGWCaVowWKVanmhK57OCgxPZJ8e87jzEGYyKGD/RxpkFGtuhbGtoTrSsJ4NSkV609PTjynci1hTL+PmLvx1rEEt6ZTQH5WPrAY25RSdYh+bWo/3VDu//0vQoTFypt9Y7Fp1IKbxOoQ39S5S6hIYdlwdHsrAt+R4wUNlpnvNG/wCu07au9AQ7ubQvZstzcqLl/2V+k4KWZ7GuiXHihXcmZjr9Gs48iTCOhXH+gdnc3HwsmCbIkfH00cM1Oe7y39f4urptsHkpSV0SB6PiEpfEVk51OALtS2yvj9TrI6cKhLPsWfCrXx55XG09ccVfvqSycUe2krA95DFmA8jrMFmt/4zK7uH5kACgxkgtqDHYnjLsgnOZpaAjhB39/UCTep3UL6uDnTXh660BAGOCRWWIsXyTizW51B29GojmdqCMPlldfwaRlZ3SFOtmdlEWCU/9ACX43jyVgScbGQ+CYdVGQylJFHGAEJv9TFuZrFsPD1Ovs/aOHkqFluSC/puoS67gc2iu/32IUsbBX40cGmuwM1ITMg0MMH/FHj4EHuxAprQ+lSEtCc1eGMEZ7hRfj6dYmtuqJAaYNEHSDTBmA6IPv7u4Xpdqq/FMTL/PmZeKwCTk2VSUPRSsJPUmv/C+VWOHayEJ4qAotbg6To2Zto3yM0vry4HyDCsqHOx6+mMfMc00okGZ+6RX7dieFrn2Mqy6NSsLDrUBF4sN86CyxdEtomV3VSGhWjsUs7NoyL2SrLpRUQyJVM9AcIGouAs2VX0prZ26/IpAamenBgJbifLpEAC12gyzzw7YxzXknf0V/Yx+d6Gn6qwJTvmDQpJlYZZZDRZvHVqrByu+8gO2YFe8gB9Jv6/ANW6xxyuniSDipJsVurtzDOIccrzhWjRND8HuTXwklrCYcJuc1tA0d3l1HoAMU68LN/rrFnDqJIIU06W9sRCqFNm4f5YKj4ON7Je/waCgAaX1TTjr4g6IU4jqLt6WHGlFVDZtiNCUExBBPjA7N9k4hg51lUyQKh27WrEc7pKZD+A08Fbp6Ul6FCNpfeLp/krT0xD5NC48KZH1VC7SMhaC1uBUqI5L5J3a5UTMl+aN5DbKkOHD1QvAMYxuf18u/TB6LbjcCnYY3Ms8h+DU77DzV5E0x9mU7iwdapVSPSZ8T5RrK8i3NLHaiCl+VWCVviV18JgHzSag5bq22ndARBTLFw4vxtBF+oaZtdHtThW/9Qp6NpP/bTWew1GJWaPvUHzTokRPBPsrYgHqy6vnAe3aDGcJ6MtSjfbOWLPy8BY9kTV7A1MxakzVaSTr8SyqSOKvNaacrMyk+3vENrO00dsZwsaOZeHYjkQlueCj57qS294gZABHsWFdOj5/+VE0ZecFAmpHKT+mK8O2vn5Wf5xmJmhwKPzyaz6QjWmfNR3DQ8ry0gzekZy8a1e9gmFV4BOBJvVG4fR5Z1fsFLUjQ6eTeOsKaUbFLWgvdqEm8l6lNhoQahYNpI4tCbOBaj1K8wyMuN0f+9lJXQMFPF65s5ws+wyEhOu2bFMWRKvfRk3YZ+PKx0t2FeIonWbKnQOh3zWkkp5CBofX4IoBfWpz5QP0VtZWsdspWYGS3zvCf5J8cljuEStOHYiQkI403exkLFgEpTgafceX2zaNC284F6hezOHvEAShHj07wLvD295tVik9fE8lRjj5XjizzEH7+LUR2NF9wEeddQDZQMf2fanBILEYZ2i8G9jsHYVk7nnqZvShpxlvfhPsVqv2tbGGR8nIcfbJy7hAj/zf2CqAHbmgU4jF4xOnFSA91SSlm+hG0OWoUB97IuQgK95Z2agjCF24feyZR5ipQVg7xxUjEfCpcKyzvscmvO26tRHMiB6WKoOp+OpdJGkvRmz1P1lNuHwCQXGd24Qcd7oIE1BMRPT2xKff2gM65eyj/koAir83M4JzGBVxHoandzJvHOUwrt5xfRZmvrD53phRfFDU9wmjTOZ82KOKhh0bxKiQGOTHHHHNq9J1QZUwumpKfNXoI4JcP1l+oRKoPvYlvj2bAuV+SO0axR8L7exmcLTgGcKZ0swM2nYVT5hbuqjzwzfNxQiXf0y8yZsDosRe8qRUS/q2qalO3c62WZfWERfC4NehcPzLwm8KBSfhTdYrxCQj2q2ZCw/dFxIzklEYMXlFcA6shgXZvHxxSC7XJLgmC2a5oEkxrKS238pRbI49xTCdNXJhzxuI0UGqV1YnCaxnFeFmtubzIS0R8uyw4blBBxLYzOW6RwhT11jRJ19jNTB0CytFEdLy3kU+2u7z7DcUKtxpoCRy2LwrrwClyGQv8ctCeICyJH6/gF41QFcoWJNf1Ltjakuis9IRfTY/QzZdWHK4jS8Mn1DN1/XsTx9WC2RhzWaBdyiCCo/o1Z7bQgJexQEji4/y0JjxeFibIQXJQpho/AJRcKVJO2i1Qey+nm87fC1EfbsH3IBSFIY7K+IqosSNxMiQ6AdGE+Mt/dOY297QpJzq9V7he/MddmE/x7L4PviJi5gwAHMMvZ3K8UzjjmUMzVaWfAZPVvg5CYOsNoUlD8IzS+82IYFkv1zAB0tJPtWnPil/jsG7Iu7rv+7Tve8szij3EnMzNRWsTqoCLc2DSf6sQufhHB8xOJXs2SidK23ls6dolL2k3S+Rl8AoJy+8TAe9caX11UYyQ1cFZWm5kayjXvT1TQedJ/ffZ/fRItKNBEr4V8q7SlODTjqqelU0ZhsfMzjKWVezDHkyY2guAPaRzsApUCyDY7BSGaxkHmCn+1iWmO3VxaEHtr8rhtLRHDhGlaMRZAITucNP6QhZZ0e6Wg/9iiLp8nTntu9Z6Wjxs0yPTuax0B/dDPcwLGXe38FQjl/g2q5Yg0xLHca4E8SWerXRCrqpo0QOACvl36hPb8BLmRas3y8sFoCIoY6YuP54e3VkjWA9kKWCi2jmH6of4G7B92VJD+tbEOjiDWw5BJUiOZikmdRySUV1dmSvudNTsVGwI59gu+tI7Ms6pecIe3OnO6S+jYAo51ZTn16xFil+fizCJ0BpomDydonFvvla4a97y107VTY+tawH4SlfqMpzx6j8SDOWg7k0lQZvqKzgBztqhZXnZh+gt35XzGmeLoJ8sdIjq/Uo4kZwm/FEXTlGIlF6yf9V1f/MjOENCk2nho1l7SxJVC4rUsGhLDPsLouvg+kYl1N6XLnkFYnuCR1OXGdNnp+h+8YNsk/FQe4GHAD3UC94XU8C+/BYaXFZgTz6mjohGstpebNgooaejovpVAu9HcimbwIOB5pV5hgNAmAP5hQWyxqwc9/EdDhRPBpF8nS3womcs9FqISu1iKtuiYymDczK12spUaAJ50bIlG5utcFjvaj0fddsCaVv5IOfc3A67WXlqWWz9XND3iQyzhAswckpFBs2hgMYYIdQVrUz0KIR9V3lHW3KlQOiAqMXE/FzQU099kLtm2eQS3am4hCH45+DSvot6XUQ5UbQ6VVEWQ+Gut23tlSNjSsEMIXC34rU3okVqIVFrWzbGN6RVTdQNrdavrfZMd/0Vcg1+c3wTpKhjJniWP5RhzyPwK1oKVJPQ402q9g3e9Z2fhv/eIRX1MH+od+wS1RhFWMFYUIBZK/qZjCKNrtsc/ez60Pxck8tQxPlajAhBbPdiRQyGVTxqyKFMBcFJU/u9Ui26INeOihZ+qoU5W3VjkrvXLqgQjO+YcjKv8s7Zg/BBm0R2+y3Ms5XVruB2yTCk7NV2ou+M07+ci601KdkJa6HsFZbyGYPt8MNuxACg1noqs4HmF0W+LuBsBHg4zPu2GhATYOXGn8uj9oi3OdhAc/vmKb9EZgstv6JqUXNVWdDx0A2jt+huW1fjGEZaFehKBRiDaqNLOAx71Rfjaaspw2JcWA2E1gVreXNg2RmtWAenVIz+D6EI/3e7NPE76dHPV/tbu4OgqjkumPzUnVXewOq57A4+pjN8qNWcS5HERNVfebPrnI2OnaCnoyfRe54S5jZrtKA/oA1YN5+h30DdTsjbZTR3e29Kk77ysRvioCMrgLzZOGZeUni4qVYUoJhmt4Jpfh2X7x9A7h93bAajKUnlGRCvASHKmUjjV/Yh9f75r5Mryf07/CRUNx3ke7i+k+PaEnTj91cyedY/W2FrmyE5SGXj9ioDsCOsFiAj9aOJnXveBRqM0sI3EIjOCYmbzU+q9sZCSGBDD4vmUrxN6oQ5gI7Z223KuFCku8MtVmzk7mtCUV5kRE6eUFGq8xY1mD0/i00WGy6cslEj4h9xAnl08RuaheCZZODvaJy9EU7LLiw4MN+flZHKZkxgM/KubLACwxnkCxG5KYum2VBFJyxAMnh47xUlicuJ+7VYrD3B00sHhFR58JiKqCWgGo4No7LuGCDaLdGNEt6RpUhSmAybDdn73H8zuG2Em8cl/AWJ388skLqEwwTy9RggG01/ys4DO2EO4ajjDPW72VM5AVyL1rVKcQTRZdjelCilbCHswq8kgsYxKhK+gzveYNNWYnj19hVnYzQnu9F1QAIN/0WIqOVHRvGQGjVUbv1k4/gCz68/vZEjvKsT8Aq1D3UWpoofjl0WVEXE3hr6irYDpRXR7Jrp1ON2kpWyifoVcr7gwCXtgVeSdYo5NDdznV+xy3tNkW2C227VPd6sIlwYCuIGS+VWkYRANQDSxMwlE++isrotVYLASx4XU8SmbpeQ+oFVyPrQb9vLs+HWxs3bIvPP+sW7m4aCewYvqQ/0LcOwLXz7z04E6cTUx2gs8Pr341YHjgSkH9TH/xlQBGeP+MOEL7CIvlI5DHE2jmBpwcM168GAc0BNhCPC0vD0LbxaRUEPjUPy94wau9y+dLiE2JnCjZfrV8+1q7lzXe8sKvycRImEA+lEUhdUb1hUD16tIprA9JC2wkQr8QKDEK8TWERnQovsgIXCizhDxAGtGBcimPMU3UnDyeyeRaqtyjL4+B9cYU4zLu5L2/r6q7O5pNaUGmroep2VZK/neREaSXlqHeAelaY+gcB+vCupk+8wwEBClPVuuiVYK1jORS5hHi0YG61KJk0KiKaZJOaaUzML89EpYeVR9gfUJB2nu2dm/WChNpURonmenaQDiHZjiemxIy/32ILDbz/KjikjYEELjZnsYwla0N4fdww3+IikcGkqx5LCuKSwmSroUmiF4wd4ki8j3xCqZBFBddK0dJBLstR0D4MqnI4GlACOk2AMxpSo1HaDvZSa/Eb5A4glLq+UsM/bDKKAXSLXqrNf12dlRzfh2OG6YffzncgkaQ6lXmWxcgNix0rTfc6gOpLxahuxre1LveZITsPXR3e0yx3pSr9dQL435ZcInu48ReavV46qQhfnp1LORAz6CdYvk2GWKi++uskoq1T/I26da5cP73Xt43YWS5gFT9RC3HgZX/4+EVXdELhjbPhNmCjNtAU9hhi00rOGtC/nOxfY2HRY7IcHJZi49D9CKj+KNtwHiUB3Q2cMfa7bqSKXs/KH1gxY6Zs5Wavb0zFXfVYabbbn6X0da9u+bXjpEN9bxVBSMioy2i3pHKWHKSe7BXEuXx4Oi8hoULOaGM28W/atz57B7oVT3C1z8GVPkrleeZWbkaNIECYFtcxL6E5ZYGXinG5VzeYWRUvnmN9/FIKvB2lEK3Ms5dN7B3oNzYjuxd6ppw6OMfEe+6RUxe5/GTHn6zPa5+jFY+dEoGaaASHYT56ot8drsxcu1al13gOEY7JmkMnbHVzSlCnTCeNrEnV8dNEDB0muAt31wgrK0i/fBUEGzncBNBZ75aY0QM7Q8YM4PPf7pGa0GmFA2OeEggd1w4M1kzGYDwJfXx/CwFW10B9sPW8Uq0UUGiU88PVVtZbfIzxstV8IIfNje8g9EWaox1o9d2PYUFx2K+3k+S6tn3blvTPFQ7OY+9JhEd1AHIXa5U5tELT5PCXVmWuS8AJo3B33zmDlAJxFto3C9F1OS7l7x9rHaHeg7R3dYbFXaPWE3w3vs2O4FCdUoQdN8XEycaKIunT2IBhg/7CBRugpWCbg+rvPszqXZth3RRq7VnbeiPTbJlmOHSKopQxzW6I59coJW4nWpRQh6aUZ3xspeuWM9oINJxQQre/1jBN2rN76E4+FOSAjcsL45jJ0s6tRySH4ti3NE+ZYfN08i9gY0P86AJj4rB7NVaNirjGV5hD9tW2vERpx4Kq+bWU5lhWRIfd4Zj97dlqYGWRYOMAm+cHC61soaIEGPgQg5IWfdMqljiTCtTItumD5BbdYIdRETqCSEPHr51DZ0XrGH1HL6czy8VjloQ/j8BMf9R5iJOd7p+m6w4OBTKrTVhoQUC804x+5ZVZZ9tLzH6e3XNyFxnksKyNVIcAIFZfM/Iquiintwun2G8vFDYi5tGAO8EudDjfhrswVZVcbxvHznTlzAnMD+JpvsgzJ9gyEJWAubwUy3+UGz6MYVGNk//fATtKSPeI3EBtAIk1AMzzvUZmyfsIlrTEU/6TkvrTIrn5BbF5+F4gsAhhMXpk40v2gNMrXEpk/NzfP3Ddkc87nH/60LvWVCj701Ln2Az8leEv0/vW5r4Q5fiJYwNnEN0Q4hTKKm0cW2T9aME65CH3NBgbSKnbz25sVnbHBBEydPkwQbx7dkL8fkW8fNd725fzko3kNpYZ0yfSdl6+Yk6cOXKydBV4heXAx3e0GILv/gbjQP+RdnR9ODxm/kuy+qP/Jae0ZEijTxrOEk90XCc2xhDEBppzDIEiPA4oOnygTfnioZDi2ouj0c1ka/2dMHpFbZ+qCkVfrPFPIH6lM+qJFOIKL1r5WR5fVBu4d8HBr1CT/yUeUMbRnshaz8Ncap+jaGeP6yHJSHg9Q+ISQRUwZna/RwJN6mnG7JJ0nate7Gx/Bg4P9m6PMnnyTRezYJtGp4mP+S36WrODbgtKd77OOZQdFlopiA+rh1dY1EovD/EOa6crPo5ELcHpmRr2Dkr0rbxJuIwHtGfFYf18ceDA/djwsYj6QmTKxtg3MGVya+SnOUUJQ3PRR2NtNI9/51Q+WL3SejZ4MYiT6o9OYLM3fStt6UWaBZDDbjLz8kWaJ/KoHAoFLEs0UoBDQf5B3SLgDVH5V4+atF+AMT35hsoVZWE4YVwELg6SMrQZgDoYgqV54jJK0YMJwWvu436fniWHNcOVheR+V+pCdKvitwuBpkVISj40OKa4dAHq2dMETQ1olaviPACH/36vAIwspkOLJXXx1SC6xIHTsHkEDzVIaApHQPEVTaldFRjNjnt6jk/lEIQZxJ0wJePfk8CAjRKSj2Ep+SKAskmbDKJ7CQm8s/2sZAtpiISYKzDc3nrTPL7xh36F6k3z3EcG9tnQ9n9xzrmFP9JOwaqHN+Bqdqp7vth9AHn5wiFgUVIQGn3PIu4kE8ZXz9pvLIiwJyhnH4N0MmmMhzdCa4u2xo4sD2EkoDrVnMtraBbQCxp6AeZmdw0jxmuy4Eb6IUqCiYxlvgBpLnWzy7ulcdqZMcpIwUHWOfgl64IxmV+IqhavtY2q+XAmIoDXR48Ftgtp3x0Dw/ug+Xyya9eNjtZghAd0Oti74BS0DveMUqCSL9CtL27cr99gy7qBrJY2Z6vkEN/08aPt3RqKlLM0/1OxFaoxHYzGvjooReQT6aLG4EufKtjrM/IPI9RRF4eHtcNWa9UPxUaXflvTNFR7HKIlGEXg0Fo0SN/RSFoO8byUQWBzUiv9MiSBk7N5bta2KOjWpQzqn1gXtjPWTDsctXdxIe4a8oaftr+fxJL5AUGSRw3Z6qPJ++0YSprOWMXPLUmNLnEOwbldj108fnak76Vr70jev9kKZeB69hr8V1Et8X9w2FhYyrr8HlYn4fFkyalwII97LDiCeIXPov8inNkOQe3J9oOYIEiKnaXJjaiqJ2h194/okr4e3TvqZscOU6aPVaZy34hc/AuLeIDKa0NPVJfjAHoBTVJ0Av4VeT0CVSqbYl17ooDJ3OWTWchb6PWX5nCXfgjfvJocv6/xX7z5uA3skJMPhqlFJbzK/RmH8lG60WsdGL3cXeS5FeB2zit7QCv1CVPzk/qMGz61SZ2bCq0KacdPTx72c70e2KbP6kzKhukAq49hv8cErAx2bPbwn1zB3KS4WwWfb1datoUNVILwxrzE5NPyZP3fxEj5Z3K9EeumJMcBZCRIX0q3p++1VuMQzii93wWBdFZALOGSlNvqZHhy9RjsH537TDNOyLYgcKDubeSMsMcHN7/Ggz5jlpwp0Wxftzo3DQmqLYxKf/N73OxbOJNir2gA2Znjkkoz8wYIpvKp57D+p73f9QJ8xbjS2jtVmDfAT8eVKnA6NThO2NMKPl2pBNAJ8C/++C0WEizVtQjPNoSk5tU/zOgWnen9nqPbcLcOF9k+a+X3I3qg1eP2W3Z3lqCq2ryMDvJ7Xcc2IvxoLEVeuIpHrePuD0XFYQq6tF7TgJ4E/m0TWdwkLGbWJfWmJqn16O2G1TpmeJOK9+LOLVkKT48uOMPZgtJF+s6C1dZyHTRDjXeewlv+ErWZvVfIaaDI3g6vLBysVOCkshjRObQfUbki29xn8eJVDpTGgo2W92jFW/a1KAhqY0sfGMSMUjA01hsgTeEKGy2298t3a18ol0UePLyIEPGJYTzEgCXHfrLzVotP1A4JsZsTVxIg6EtHHIqdiUiTdLuK7eXPktzEswXQKvYJWg1Cyal9lnfF4YNuPmjpoMdeEUGU1vnPnmtehp6zyqnp15O8tDn4ofXrrzCOhkMUZjgW0PJNH4ump93krpWbjnMZBg9fc5q6h+qq+rFhH2JNz0/e466ueXmL9NUd4xg8glp26K+5anzdma3fwK1Nlw47sNYBwQHFpobRC82OcnlX7isX4JmF4IoH2oqq0GCfMc8fJazc71TdGdAX9omDd8BzTs1pPApK2Tl5cYDfrxWWb82NhgRgTaNJSgBusP83iDX6bYp9n+AfeF2sOv7VW35kPjEoit95OqJj3ksWB3OWTrNhnvaBe84Fk1Hy64bg2oRxGkZ3cdZ+2BPfPSF5cyoUSlKXHl1gJH5Q96tivPVGuDBncFBZvc5J7t/WbLaaNn2m/Ob+kZ7CW7bycbJVQL/WqpiWYWndRzao1nBBqCzrdKYU/y+R0v6iPUOcXvzXvHKeiMxk0z4PCPhrQT26bLyU92HVXDBKM2gRUrLGu4BLlZaAQrvNJTiamFY93TdxE4XKVo32VDKLZkyekXQBXFXI50m0PSaulP2+7zlNDhsjzGMSromnU3Ye7jfs7t9Jl80ZB/Jh6lUAFW3jrOxCCeohC5k2LlnZO7o4Nanm+vuJAHlPjEIMr5oTNyPgATFiHG7jGIScmzHEPPvqW7nRMyCQSFcxSaQLU8r58VUqfutdLz2ikh7iMMj7cmmH9FrwoyqTRWf2UJNsPQ9vpO6rgZZZn2HgI0yAnbv9jaRwjLpILvBy+AHxh8Yll52roaMQ4u4zeeVdpRh+nCbNVw8DwzpOMx8jrg24qfkf1nl0hLN/fJDflnk09EA0xcSdcWP9Q2uWsGmrIOs8F8OQnyvRRe/7RqfF3WRebsAcMslKC2zkuHkHe0MzDa4yubulH7Z/9P/7WlFigQGxUmzD7Vclhz0CUm/9DAp8obhknDm7sfuewBiqkPh8nJn5XT21ksI4L6LLWTfhdbn1IyV9c5jXwpPCqYBdlFtBG4b/8pl8x6V+SqeFadpGSCwsgc7bZtT9zbTo5BC+zOdzKQBmXT/+ZlmWvwWLmQvlD30aszRivDXQhZ7n+FmsIKAcZ7D5mn6SPnp8divRHR2tdUgEEiUSfSLyBqU+0IYYkO7MU0LlYfjfgyLHy3hoGvyefCsi6SNUNbUBmHgXhptSNZ2oqxxbNCSQCp8RfcP+nBg5SUUPkqw6yttkUFnTIHgZZxFnqfl5l8lHAzAfc9ZQ0oB0iEOcXWF6ARlKSHld7/i3I4z4NLXaTNeiF6Iebb0KMv4FAcVpQvVXXmfilxqBXt178Gnsbg+FG5ZysKyxn7Cy0Neop9pe5pXjek0voN0Vy1bUU4Xa7pgp2mZvvgerjYwU9QD6wz3whcnRudTmaO5xEjXKAhkLegCEHE0S/vWp2idaDlkTIwI56+1Cn/3M9uyZ2YvLjlIhDH62iBUTlLSDot9oM+sJ0MVeP+4pu1GFtpaKJzIQ3+vKxVt6RKghQzaAcap6qfXMfjeGrm93/BMgMcm7Oadf+CTs6EKnpt30w3yvqrE57O761ThPvEqYS+EcZeM7cQ1mL95pG3fbE2Mz0WPprk+mQG2CdNJbE4BAfuk2aec/9szIqRiOsiwinWY6PSZz1bhqRT1ALtm6Rwg1xxTbu8bk3yQZcU5uajcOESIYQyG8h4Qk8ult0+CmlHZDyDKmMLFZ4PAeqQF8MNiMkf/68DELlpfU71Kn7SLhYTaHimYma+8W7Zq1HTVfMBjlP/xmwnc5046oF6+B1HLE9wW7WTgrt05Wmx3b0UQUmhU74O9CI+tpSr3RgOar0HO4J3s50wVl5KGaZRgfaYQxyHB6UPganIcccWi8E7M/dGbl/6Jh/e2M8FIg1vGYmem/lPQjFZ1Ml7l/GQLgrFaqGP1xY7yhsTnOtvCrpV0nDT13XbcWyH23BJlzxQ1ogoxo1K7HnK4B3T3UviHZfo9UmWCWPFsZiLLjR8SW0D7iSEi4ZIxe2hpFsiBhE67yXu6p4bNsqPvrbULMKAhPXN/Enn8XdDex5xxjn37w5qbXXhKcs08n/p/9QbYJ/OZxJ7jvl4NinImZw6N8o9TzrLQKhqI6A+gLmNxryd8qb2RaKXmFdfrhV5RxWL5UFk2mRI+Ae2rDylX4NneXxP3qQWDZNTmXX7AeLsBhVXMGa30VCSKSb5u3IviTzYtTJyuZ36jRAaxUbQtZkhy0Axj+tOlky+RdHOOSWojPQLRXRXGZhUegTF4d+feqBqKuNOmGIh3gz7Rqk/HW3SroiKFhZFqSP7LN3CHlPOLnrJWamn7TF1sYpNQAm+BYrxZYOI25w/hy3p7ode2hE2xB9dOTVSHjpB7+eHJCmB1C6F/udOIbmU9e+jlWPInuryos/XC0SAZfdulOLoPS6mKZxbzaghpwqO5X2ejn/LAvNdi21cOWYTcUJvGYNaIbpay/wA+yMGJh4ldsuJ9ATlH6/yIafegNTJFOki5lcSb9hQZg8PdAevL0d0UdXUgBMt4AonBF29qrEGr5A8DNKjDzz2XgBhd+6lGF6JYD2qgRVzTyOK7NHsbZA/S20Cla2CNUyAJfC864aIzN/2uRWPQnEK2Ccm9SiM41+Pky5IFHosvRWH+Gwttz5rnjwhxELL5sKpOXEnyiffvTGOw2KFni5XMCjdwPBwas52pjPe82tThGMK79tAriklTLW+XUeEHej7UAM0JtcpWeU4pTKyBZcKEUbHN5tFl9C0/XidoTYKBhxiUSivXNY49o+rMLgqOA1t3qvW5N2aN8F86MkdVnWZQLPq6e90/+XMhOCmHlLkK0IS9FyEUT8+SbW7EAY2E7b6o1dtbnqESlMNUwI1UG4JhMI8RhX/y5kJ8VAfNwle1SCwzpOvZLJOV2VvPBrnO02XagUtU08460D7+0+vv/BRac0moZy4dJvbhsRnqDpP4WpJHEJgoIaKssFB0JlfceoBm2CqRB4AZXDgv8WjiKDuaWA2B9pUJlIyc0QvkfANbJWfANu/FPGXZZwnLkKIZDReh/eOviYP2h5Jrd8z/r8Q95oL0TZEBBpHCohnedgO9G9v+K9x/gIVlvYw1ec9VPKjlx18bEOQ69KbOHrihhv7RpdFolNhrJv459Md/THyKQ2nKM0tMmRKiWMATSHwGrygBGk/wY3qMnxoEOpb6GHyTA6FjKUkcpzFeq5gqlXYYIcZ0T+B3prPK7p8imfj77C0MuvH0WFgX64AKc0cBEAGPxXqoqCWpy61fw0IPeBLfbe65NopPO712J4e0757PVtaVWcXiwnG4tYVoiiqdLZa2elvB6UwW/GdKMaPMPMHhEW2d4WlQuwclf5Kv4hhUZs8s546Pi8RiRkR7MXnmkW0pPOcusxmhm/lSmWQk9cxPlIX1iBNW/hReQlPYZPUkpMGznvSiNWipw4CHlWigCgzshJLdPq5A3KPVi0wspBxZrtCe9oSPrM9dAfeu7WwTPgLKoqEL2T2ggPfBjHiVfQSJEQHPE4zyjz7IKdF1dxs3l9d5PXR8/FMnX3KKzzK0+WSoz49xlGQVL8xtE8PWLpXf6i+Ktl43SKjrO/qV6KYiZ1gDszZlZjWWYq1fZT1lXV/5ommzXRv5UANhWxRnwJKAk+0qaLbZE3D9OUA26o1MdE/9rj0JDmQzbQ4kanER/OcvgpZjchdRLRmu0NnDVzJw8di95Uy4bXFb4P0eEOiAQiA59E7/7s+5knmPdEWtE3hN3lr3sTTjh5T3PZ3nEEfMfSub7xYfpbeXNN6v0U+KQRURKsvAa9KfGMP9K+M6E7m3MFbjJAqjbomV8Bwhj3GJkRbgPzYfVdiz0KtGAPhgyRL8Pl8bHkb/TCu5ExaVA6xMKr9cACYs8fB98xWZzFAq9IQuiWy+8OewhqZV+y/ThwLXkW293YJhUtg0LdYEY4wcOyXqeaDgv/GcjWSHNLyTSD6Io+3wjiBrLu4BF/VvOpuc2YLGIiAy1Ll0CMTsC35HwNPxcV5vCPbkPeeq1QUue131ohLasvw8v1xHTEnwEtI30UtWkCqj73RPlwWScwxH4H8pzkEe9WQrtLZ0vjNWI7dgrO22wNOhiQghNIxpwKmqp3hMYcStp+GkJg8IiUAlOg8cuyfq14Dec2YB4j01DGr692Skx0METI3A3t3xJ2U4szvXu1ghZUKSmKvl3Y2f7skWBBftCVJWeGdzy3b10ZHzQ83fToBGw9l/wLK0k4xwVRkvDRgdsfV162iQQA4KQ0UfOuHIpPVQVeegJZMJyLvtVjWTvYeZQrTnAAu6W8fuSbfalkLlzGuaSfslpRIA3haQYiE5hEUKTPeNC6YFMEJIGUdTwueRDLZv/bqq63kvufyhYg7cDVAOeLwFv9km0xU/vqR0aQj6HagdYCPFa2pU1myQfE8bce0us9EtEEZlfNrbMQz1K79gL/VcParl1u//suNzR7jCqtBtL7T83UDHB5wPEulhbAXySb1yztZCnCANuKNx032V9MkFwgzcac6UgDjuj88lmgY2GEfUD0Xpst3lG0ddpPbkao0f/07XKwGvEusHboFwvFUZDFePe7SZhFhUUvNdPSQ/E5QNHcJbuMFuoFQAKohD0UCS2h54YjP+hkLjvYNiWOyXKuRdspxKv100hTTthWYwGGJAp9Tk4SAzNVWGKWOc/bLot6DQl00uVNSKnsB24iI0wrIFwJAo/26f11rzrXtzWtn55tKXg15nIiOnJgWBy5L3LBg+hUxTUqau2IF7E9jtDa2KSHFeNfGcYN1V818W/pgns29xGNHxi+L4IwniwY8dAdGVofkSQ/hgZljTN7esvG9WKHon6LvUtlm7dkl8h2dDK9qDwcQT4xmK0rYOQE6oYM/q3mmcAP7oo2/s/zujm5Yt3ALYBgxycUv6DjIkWZj6KmoDWyZdjd+R8QZ1tmCfU7nvqfmTqdMpB6HO+JTlyUvOockSNlTS5w4E0pk8ocY5WYMgE0nMKHxV20KNmC6AvH8plhD4ynRsGGEOg19U6Mikh21f/tja3QBfNEYzbtSBDh1wlzzZPypgGO5Rq3yQRWqq/l0G9yIhFjS8opj5+pfADYJhXw2ExzNRBi/qAW8TZmtXVyi6zAQAhiQtTOBhHzds1KxNKAtiBU0Eq6ShYZO+x8W2rC0kxHPL8sEXzwxQJlTVIzjvCdvT7NJICwtHoH7WFqUv7Wb+21xpEcZPco7nBuKcaEw3x3I/3x/6R2F8H9N++n1zr4U69M47XOzX7o/2ftU5/GIJVjP2va1Qj01VTJerU3Z/sxDSLCPtnpZSxBq3YeJFDh6uVa+3kMbc8aNxQJqzFKpwgwqLhwLHLdIYttrpSQI7bIsg0fF3Xq1EkXjehNZPI+CkbVSofkCTzyYYkvB2TnwfUqpLpd8vctI95GXxJRQYjhBMDXksiwRwnnbTK1qsHNsZDQ0jyfvmqLqUye5kF6MwaN9525gDnMRBROSSFEpJN1UxFVge5AbeRM9MOZXiAgs9zDW2b8nhK96eex3dv6lnQbvKLtxo1WTG0/OgXl32KuTQfIU31jnRXLXPTkDq/qOP512TSFrLxb9XIlQjVOuq+Q88QNmAO7v6xSofEYlUeO6DJBh+mBrKty1NuGh/gAv4L6nPYTgM95+sS5vHF+PPljRZaQgAphkXwUL+h18s7x9qJHFjfWATryiRwHc7w1moTadivwLpcmSWH5KoRSGxiB6/A6V8i81DA85QH76ZWKgeAz8kB+WL+csW5Qbvghon9Ga52fXf+bbD5bxxqKiJ2QKAHTNzddqmlwxUUiJM1jj+K66URoziqzJ7Yi8rikVAxORK4RCrUE1MTOVCFV09hjJIraB7aUawpZ8DTP4y1IpzYIGT01A0wOqqqDM/AGFgnWbfilJUlj2G5ebfaig3woj5TFro1bBgZc9pp20sL4TsHQq2xG+X3dKOV4QIImxggKxtr8/OiFdwFGQhHocNzXnevKRgPY/Q+rCDNzg/Luy2yq1+uDy5j+t6QRL955O1cax2NsjbNve+GcI2iyENfcWoe0tPKqiLbb01iXyKa1vxQmei6yF7KCKz27f2a6tSISrST5+7/Oh0Y+ySc3tyGyz6uViw/Z78WP+WcI/usx0noBrtyIyPG8bmqdOv0mhjLPMbtuekNNebuQig9iJ46CDlBH63HDP3cmPyOBBVNxpfzo2d/oh/W2CYTKJj084UTIpnE45HQkWk7Yh9KBUlDxIKrHr+fmnFQoCBVsReRQuuKp6iL21CrkzAHeTSdRPTff7GcJLtNyB3LDVuF1PnMEHhFF4WQ2YsL7EZ/3bD7rGapNj9ARMxr3LVHWo71+a3+7st8kEoAyWbs56QQAHNQwvaFpTJeXmheLYo4lz6xHSvpXyCgvgmNcbsBXkqZwn7C08ROMaP8ssRhjOhYZFAJjPI6au8kcHRLwPs7bdJaHXAmqCZ4c6xLdpbwL+onIaYd0Ao1wKGC/lPxwuP5IKcg8R5VMgIlPXzTplVfCwV9oOzMsPam/PhM9f/v53EsJSSBQZXa+0ZKoh9Us4r+g3090j+sRIzKXjOAMIGc2LxySC8fAdiLu2XpUIIIlh/Cb8FqewUJYkebEB/ac0j91m0MzVFkR4a2vmdJJGzGEnKPTzswB3pzDkle8pvgU83Km6bfAC8MGLrPNvGUCMCWqBk3Jb/q2qtSDQP3GB5zdeAqhp/Le3Y3f7GyF2jJj/GcbpiXoGw4Gl4eW19AmryYuenkapGbNcIW/Luf/eKftGE4RLlLhCicJukrkLYkeMh2PJ3D1ME0be9kCe0D+a3xrmY1r/hoU0mYYSD+HpS5NUtNKWHQt4I/fMcEu5/LbPpLwBDxAWclYtz7eATbDTRdJvccBZ7N3GN4D+YIcFso7Boz6C4saXQDomhzn4u6OySvgh9Uy1u/u2s5ljPOsfdulBXI2nnXFN0yPo6Pe1D0hP+WRs3/OLsUkvZ4FIxNgjP3EobJI4U+nZHu4K17gE2pFjd1beXwNoelI0ZX6wxmGmy4iS8iSYbmY77zO47n+ayjfSWon5IBlRogkTTJ/Gz3FrpbPPnoJc86r4hWsdeSbmUMkhFISkljJ5NhPCiONIUwWj1ley7XWbWNZFfrtP5TbLC52P5G+r/JTyt5/2RRcH5tQjKugcelrP3KV6O41e8UnV0BFH2uiPxQelXMmgq9F0DE8RqSWSZZPe9KZ9Gse8KN0oEiK5uTGCTQve970aDtV0KZcokDtJvbvnpmlt/KH3R4ohx8bjYDBq6Xm8KgAK9IGz8UDwF/WUZssNmNueXejG7FhH9miDAXtxHOAkt8m2oIO9uwj5MTYdEbfj/JkQkigtePIJd4DMW51sNpAlkirh3GLdI1dO6pMrhhAHRrzWD4zLYdxjr+GpX4lYkqdwt/GcE9IMtuqOf0AAB3nTVYH4jYnqYnuyRKzlrAg0qG9h5TIrjEiKMQFCWKXhWYpNFjn7AtBrYeeiZwesovJ2G7rR7Ts5dCEruIqKJ2NwKagiPCIGAb18vpiYp9SdGOpCNtdD2+Fe7oLdLagPp2LB+LWDTF4+RX5MOOb/aYBzSYsQ35eDFlff6tVUnyhYs29AhL8IAEnG6pFM5zO0hvlsrEouC67N+XjWWgPvJCdR5myRh4LBoozV8G5QwHTSlXN5310gwaBeYlrQr0eQTDzr+4wL6yzPhZTcS1cZ9PlxzFbDWgq/cRjX11AGbLXydstHw5tNOKY7gfHwl+BaXk2BYjCsd8pl/DOK+35ese7ce6C6Pn4MNDQz4pV7wHfhYsNz0Kq9XB+KwutkMGixcnclFM6Ki9rbXONsllQx70mJhx0N/OVIXXmO/M/8N1nxclIeIxIgE/OVn4uNR3Jq4ArUaSXH7RCE1cmU5kBVXm4wImglklx0GAyoNkEvnGkkLxNaf13o7fu7NauwG7cn+yz5m80U/yyyPzrkZ/kcWdfb788mjyhvXMI8esfnTVena4tkfPf/KFig0c4MdMrWjuhueA9iDiTig6sUamAAtlB9DvO1EZ63ri5lx+UFjhrKi2lUjt1CK7bMrKztVvSdVV5e6isdJfhLEMJCeoDacyYpuJggcIVcUz4kkrD7Wnx6hrAeSeqSDItHhfTcwihdmZfiHBiiB1e5lOMDpoAgFWbx7RWf24S8E4/oJ79NbZenXVdpjZnL1tafqBQSXLf1ia+zltFZslVeN7NQoq04OjqUhXwZoWYOKWfO5rPursIoR5CURuSS54GoHDxcjOMw3y9hgDucjWtC7epY4T/3suHyg9SLXcjUstHvgV5qVLwih/M96d8GT7XDmryjbiG6aB5DfAZ6mWjsjNhUGtTWsVvRKH/QNGJAks/04tmdPAxfedQMWxL8sfei3wZZJRaOosyioJpWQ+IUHyyLIMhNic7tKsYMIUdif/UbSfGWqN4SvPqIm1QQbM41lBsngvA/+JtNAixnamyzaKZDBItv8mGmPH27sMYoDfzWVXhIaHde9qX6EUh9jnmlkJGKiht3OWlPnnnw0bxG3Ec5IR0QzB41aFarNpAoRenAtUCT6sb4OvuTYiTqd6hUkVU9qSKXiLhvH/JPTiMIovRBlqs30ERFM1yn2kEpVpIQv8x+nHlKztv29IMqcq7maQiUFdGErKk9t1ORQxKmbYcaVFA/SjFfkNq0GQRk3FBItm4sT70WAiT+DcW6GVdcHiVAd+hBxxaHXXYgweUFt3LRkTqFPpWr4/jCvEZRkNcRMc2PcYmog0MgLbz3ZXAkvMUx/RZgVlacx1JftG6LvYPwzdkuAwfOG1ROb9KfJ+hqPLnx3JtPaZi39odJzAlq+h6UmJn00LF7NQYwevh5EOCIMArDw1CDtTBcoqFrSxqogKm3YM/ZJVYUfjGxCzKhw82i6DiH5fji3Tb69yvKRueVmDvGexLlW5WSiTGgIgiUo5Vxozg/rgHJ2wwOEvtFnkqDR0PMmdKHFZ0Ck0zJLUfCR7U/ERAWlc6OC92aiADwqmoD+G9RClnovhmaOHbi+fxV6mgS/IqBxnf3pQ/K3Lg9SfDRdItLVOzbKlXrP21nIePcIHshWQjq0zqDTNqKbfvvpuTjZiRB2RwV5apkqFqmJvNrzoXkyRfMFe53fa/xzil/AuaD2OU5ksumQlw7Qjg7E9UO+Y1mWabQ9kCij8Pj4vBKeMne5YI9L3dLYMOTr/nE2sAZuA1PoQitjBy2UT4iMumimJV1JoykgvoaeO+852eLM19VKp4qjt8C3zkOUCse5N11t0uf0znADzWfFihT2uFC7ZcX4mhB+UAGw2lU1Oeytj1uLsyDaf4377jB+rjR4GEwP3LW9RmSoNZNqugH7CCF0MchFSfH/TnWpm8/EFLMzAAkmDhjm6IfTnv2qb6HiW2azj9SiSKM7v//H3c1iL/DnvStwyPBmWhfLPoFLmpXurHBL/ehFaZ7A2+yvsxrgrv0StsybOlWHzAYpzLZukJSeKlPHvTKl7SV9hGL2xYJVn7wHBP6vCcDrdPypW5kfyDkajeQIzf08pQKa4JzLosHZTVEfzH3RC/vonyWszewYqojl4+Ykodi0cKYdFxdHPBa4RZfwa14B4O4XhY2rwtKLC7HdZnUbxtATSxiLUWp4eogCXZqjVn7kCCbTnSns+e14bQ1ZpAZZlkbdlnwYwYUlWbJ3fuJOzVE5kOA3+O1vdNCXvcUrnFXLKy8QPIfeW52cJFhc/OlYauj735tAs99wPRoNCjhAzD9UEytVF5BH0Kf2zqOE4Hp1f2lZ055LOeJbPDxFRrtx4DR3PZ1Y7nY1grk4LhfPjB24eocCkC7CeDmK0QWXxkTKHgp/K98ysPY8ysAoMumyLWD4A1zo3Ix3Cpir3jGXipYL+TVHXKjSRzNf3Ne1Wgb+m1MG6lpusw4RqBXg1hjGlNvtyMqzIzKq3yj88cJ7IGq4HL6VypEa+ER2s2sdZwUokoQovccLxoDjY9LhmzP+kqTmnyNo8/6pthw8eAxh0xTmqFN8x2v8rFR4rlOr9CLvIqohVF+PQOuZv0EpGvTAnfD3lEOfaP3SUWbxzb3KsPS33lSd8OMaGiMr16b43idlZsx3lOGonxWLiDRN0t9tjgQoPMSFt8RP6CjqnrbJx7eugwdhSEnyPBjnjDqIbkAJL+ji4Ezrd+Qe71mkKJYJL5UKXDTfiwq7zETnzMQ1AU53HT3Yb1lDn49aegjkDTueqjLMSqHYC5nJRK5N6Ob1i8HMJfU79hfJytcVegoDf18Fe+4yJq6Ki3c5H7RevRNQ/sJv4c7S9Vxqy4rpO4uFLRddNOhXbUXFqexqElef9bDDGde9s+O0yV1+KuKFv+JUG8deoLB8GRjLjiSRXP59PSX3qwZJZwioYlm6tmqhoPLrlnS8VhI7ppDEW3C4hDD809wmgtSKiWRhlOoGVzPqUOXWtf3WaYp0WGGKrKEUVEhcsEY9l8p+iRNlPsk63Eay2vbLMp1+t/HvMRwqQz6jwt+i3xBl2ZwgfmPUL0xqprEaAOtPpLMdLVGVR4YptvZZlzNTWB8feVMOVckR90HYvYIsNQMdO5OsjOX16q+eGIOulhFBi79VatVX+dUi0e4mmLmqEvfZ4r+uyBRnLxeGuwrVSzfl726ftrWtpXI8/Zvg+3AYERFgaZb5Y5zYHevis3zfrazmJ/Y5t2cO2MWW2B6GyItvJaHVbMfFfYnUYmPpSi/ZevQYWR0q2WsOnvCppQoPBJNDUycn2KlvqiqpTwrDMlWd0RuGQNX0gqGfCfqaIo95JByxCAfGjvavRHe6GvSRKYfR4pK7Q1VZDvCz7uyrlyqIa25jBmsVt1tlPtp0qdivJimJg22vRqqGTOKwo2unZ7QDmuN1OEA+P3y6XtJYbGfvMMXA5TKnAlLUq9Folh3ttVqew6ZHQ2vWHB8wxoPdIaxLK2/1o2sFjs6KJi8ZZ0WWN+UYR8yREvspmhYEyhrNksSSLzkLWUuH/jS7pft5SjR/Cgqi+TSODj1UJoXNMy118Gh2oi8PsWrf6hjnPaCoPOrvKAvZYdlfkOLw05y5UXWPVCpOlTS4vpInPZSxD6QIhB9tPSaHgFg4wK9schZYvR8L6qFM5Ym9+7Z2KnsV4QQjUuo0xUogcMJzSvGWy/JSV8TMNT4BeWxQswcVJiiP6Pql0lr26MDYpLMLH3kHT0s+dTZuATpY+GSlsD2spJBWQos1S6sqtqAJqFLuLyYjM473leS1FMuYH5h7CvfHSNcBrFQN8itUNjvTpcp/VbcIdrn1aVcspfK1d/CsTumLr/QbT3AiLyYX8jAZ2MC4R+Lrm+qqs8vtWMSf9hE5xa/54c/Tj8siOh0NqZt2IPACW2Y0JVtvPsHL17viG6RM1SWGqFOFKPkn6VEDfikZTQZzVLEMK7TbvTloHOc5b4pC8c+l1OK2Meoiul5Az3Es9DX8mE6JVBwFx5547lCFsANAsnUKDVWrT7OnywxgoeGpTVkfgn0h2QF+gU2accXDEY1R4TJyrT9+0WUBMXLYgNPHP709rO3iLjxCQ56qoZ2soguE+8GrGpgDNofPTYfpMy795ay2YwKeKeMaKPvwqwLrLTvCUxzCljjeqNAr9m2tCkrrRhOGM1CEvQMN+pYsXLffeWRGg9PXgG+5ofECybpmeQhLhpqwfSoZMBJOwO2VntTFFQyw0L4/Wn8vVwiwwj2sIzOvI4EoE6TPPDSjGrDGfr4mEbA+n6w8fNhJ4J9I97E0w5Uy7r6olRMkC3rEuS6GEnr3uFLW0U3ZZQeldzf0P+vIPeC0Q4/GeN+sAfWTuTXMGyFt73U/qmFJd3VnFdYsflzlOje6pLQ9J0xWSvyye/44EddfROgcUR5LiootDKf2jYFt9M2crjDSSvwICyRrzdrfk+K6hrAZYIpGWyeYXKdsIculTy8Jw27YXAjqiAPNM47Jg+wP/5k7S+oOcg8gXCis93s9Zx+Ywa6PnkjBFQJWQv6n6tvzlvIbFBGyj7dnxczZpTepW3n/WqIFRJ3ZQcP0i+kiRW5A1im41/w5PW35s+WO1ldDQMAgKkpa1UXpL0HsILbKbSy4s+fjz3csY+qW274DIJEu/oFzBsAJAcMBaDRcAFmNgl1reoGFPLPdn6qglD0AMwPgVb16wozuUmBNiXrGdsAO/PfR7Vtx+fUPZbfLE618qso1/jxRyH7TzMF6AmcnOAS/zmp3sVg0chGBBTIn0bZFdhoQNAwPLbFVo3uRHpMQ/ZD19SagmzdFWhLNoAeQYGiA8A0B4Jy84kjfZHqEypmYzUmkvOG+h/EgStiA9MyRpyT0JmNYhqOdYNvLHGWa23/tSmvL8XNJWqU0eYWXaxo0rOkS8OmbqfIpBKd4GnR2+jr/2LXZp7ocqafUbxlSco3KDuybYABmGEhCYLl7ZsQEFEOK22vttpsKpNbxCSaZ0c56jsQYmp7aosWPLuELKu5LLFTxHZgSMz43r5r9wyYX64f4r3qDiwTCHAMGiPGaORsiUxA2K8HMzObpu2TH1j77wbogSjnTl3XJqDdxn9Zoza3/FUfbCxHPKexsq7re0B7xjsHIDaWDJjkYq/XU9dIXKaNRv0hZLL78mesJm4lxiJQ/8efy9osXihf29SJGrOV5zj2icvZ1lPClClekVItScIeIyix+ICfG4/hhdQWa5PylgWmxrqjvG0azsW5ewG0Ii2qdrsDbjR9WDh0eWui/zWZ6a5qVYasbH4mAsi0+m8rtQKfBtut9YxjGF9uUoVQfAnu6U7m8xUOlspEAek3QASeJ49frc+dTInmHATaJ1gVGA6PitsnUVmEShE8FQLXK3rNXZpLOhbY1d0Cwpc2gBxuz1T2JCUBOlwsrgMNXGzeaufXlq/FQG26kMjU49gsSwK6GF3NeB5F/noWHzPn5bkiYGF47L26BddJoQJ+78QH/1HAcJ5Svns9oMnZoEPaaXI1hyJl8phRPsvRkH5zxI4aBs7CQPdcm2T9dpOyiiE56QTCOA799EhjHNeRiLSFkazAkXX7I8jRjH73/2/y0c0JCJiiJTWpndbHa6+gza9UoniQEn24MycGGmv1+E+pALlmwWatVzUnkOlZqN4cu5Urupo6CW8JtRVeE5KxWhVmKkE353Dv6nMUiO4SO75ODVu/EHwoY0pATAuD0zxJFRIPCXCkcEzt2eMGOWnVNkkcYDnKS/WQ9x2bgMgh/0dyC4j5b3F8T8Ijx52nEVRT3ghQX9ozTPqLXyKv2CV2ULaX1pN/wng/znuWlXIcqalioW2Ne/NWjnJ1X8yU+hB2197MeqMbLE6NAtnQr82jexjIGfLZNq57KWUGEWb7CV0WYAkJkVlTUsnSoNfHxOLrKN5/LIVGi6YF5iwqQnhd3CCcarhTZ5OGQOsIkBWtBzSEAiAuh+tS2p8Qo6lWC+Ut/G4nPWtrprF938Ai7ZJFOkMVDA2ezxQN/ME51DAmWXvQ8+J9MBXXzWgc9Cq7rGIFIVJnLv/a/DIbm3psFaWHk/lrgvuCmq3KJCYldJnGcncY+JzsBpi5QMJNpq1QrzIl4MrVn9legXy1fktzqt+Odm92hH8nlq7MJDiWEJvTJXtt0zD2M+4C3R+saVaZcjNidN8ZctTO0shrr0HEnSNM2+KlrXgZt+GLd1org0UoNm+HBGZ6ibqKbWGtZx+47E4du6RJrJh1JwvdaagxXUVLG/3f6E5mEkSSbPhvJg7TmOseLadJyStOnaz1bs7lsqKe0Xm5UxQQ34M82lP2tTtivjrLIKuJctHNmCGSnZKkMkiu8vQGRiiNjiJqUvBsMpx+ebBWfQIe0wVDcUTvpbc/nPMuxBHBnjrW9kUU/kp1XVb3935ZBPMkA0bxxVGBG58DmKuNIcUsWK0GIQmhr4q0lrH/b4Y47Z3m/h7XMXa6DKQfE6Yagd+nWtSGucza2JO5Tc9P5avXZYughL9kSKjthCXbfmC3I0mcu/xmSUuyirmn2/DBBgH1EYxxyCT+OPf6EE7JuU6iVp8F8AOL9Zhvbz9ZLwvBROBM1d5rZ09QBrPdUUk/tJZYYtc39qS4LDA2PmxnstGYnmt3TtPcp9Z8ZJ1qygjyEd1YNnAy5Jr6zUXfpDMXmIQllKxrL3ABDhk88omIeoD8D5wYR654diS+ubiOhsfRnbWi0d7Xk7e7iUbsxKEz5V9PBcuhM9RtZZo97d8ldgJW3SmBr2+255CZAmjp97JUu/V7QE91bySNl67pSpBQKCkBZMVL5m1Uq5Xhhmhu4qJ3d7/HZ45suce1np5Gadt3WqI3sHIucHnzizhvKXa8dqjcmirlk4RDemcjc2XO5eHodQHo2AD2hBk+lS9mT7Dd/IO1y7TahcXHe2FtKseAyW5Rvwq3Q8EIZSQqmyIJiOC6v198A3KijsjqEDmWYRkCnwP+EI/cK/W/8flny6zpSQDoX1/MrQJD2zmzlkjm++ify2RazVrRT68vADgn8RLO+l5zvyinFTGYMCyE3f+yxsDS3bL70YX4nzy7txXt6+uwYWTAs3nxiyei9R17ntp/8tV8kaJV2ahVw+gM2vtlACEiEJbcmiyOD9EX/CcYm3oBj3vLPbo29QXFFF/nvOp59RsAvck/P5Fdrk6AmyWIuMGycWjd+Gw3TRkslp2RTwHiD4A0VBht/7Bd7idm9O0S3rf02IPZudlteO/zINMpbH1WHgvcrRmyRGJZDpMMYqn26ZrtzXXSGYyG9NLhQPgvxFxPZFS06dVOxE0i4vzU5Uso/S7q+dE7R3MkdSMGg7HgbwmkjPHuRfTHntKhngUztN3AoU09/IIhBVGV5PO2aNy44iKDaPvY59dbhr7xdXcp8uNK+TvRrDjFMXD+0cJpCzsydb8VYNeXFLsp166HdZkAr5kxXO0iFSZ3zKEM6zTLeaovwv1nmN5cwdShbx3RgXGaRUE6/mjGDlnjpMzDMJWLUf9RNA/JNcO1X2bM8vWL+OFBeihcyAI3Tbg+QuZBi56Kxi/gh332BRBh7a7o839ACDyHtTup0kwJeKkdSoOCWAQb5n3Qq3gE7emysuK/1mIOTN0XSj2so4kzEi+0k3a+cbxZshs38Kyg0Fnkk8+GcH3PRima4mtiKq4/CX8cmMdVIHUzwGNDsau9MaIHJpda1gSPZC0KJet+oeKltI+NZm1oazINT1lIz0AW4N4lYvbGCYQHEH2C5ECA5S+ZxR0W7WerulLvQ40DxEKldGCssKtfYYeXue+tvvBb743TYHTntA8NDaSlkWuNGWSvnq+UYgggdX274Qer6VETuDzWWxnbesrsiSOAV+62tq5mCsoKwBEjebLs/osnoU3vS3T0ODWJsoCrNJBB7cGPV5R9m6+qrJiP1nsFuZ4J/mUrNDpNSgJHWdGET9so1FKAJ/jQmEdsqQgsZSkKuHIXm4XWoVs6Pf8l1rkYPUZBvl9vlvsaYCm80fx/COyQ98ZRgKEBRRMPMsHv8BABBmK6zmwa+CsX68Hi86hiJE8f0IhULY+ux+7X4dCLpRUu2Gn4U993jeLe3vYE88KvT6maaly3hQvlE73ntY6I+vhtzZZ5PmzEfM+rUxkVShrNQTKdniR+vDGcLPFzoOLQ2fsAa0Zv6wF5RnEmSHReRvRcdeiUAGPRFTAz/tf/ltzl2ZI5gNs5Vc8hseBUk+rrcLGpN62+O6xB31DoBuI48wIMW76kD446xMUY8JP+G2dJNbFRyApqpAqxuF3zWeAmwxOi+CmGKtK6NNHy++2fK5GBn8EqlHUFJdSKXodFRGKbiKiqjPgU/50fIoKUuPRIiSgZuEvvG/luqy6NqD/tTddO7+zZDtN5LaNzLcExm/5IgDoBLPG9x4Ut6GB8HKAWE2/AKZniR3QTCaZyWwQxfY48fmZp6aMqOf/wPAfd7u1qnPzpcnX0WHP4zFajMELmI/DFG/1Ox2Lc0hdVJYnHE2c7BApDOH8W4nkfj1SwT+YUBV0nKDdSuujEsE3qOmIamY2LlUa4XXJ1m6v3fBDIK85R0QNehMDw3//EfTDfxrvNW6rlE9dbujMXHF2WNFePOBwVm8VoOW//9O5tZnw2GZUykDKoEv3HFM5uo2ynd3YVRzA4QQpRBfpGsyNr0aLyxd2ygF0BfsbzKASwRPj2Dkv4IGWFhzl3ra7EW1ITkB1pgOkM4QjuzDdmhPFn8yB66wZH7ZMbywwkOuIdzDJAQ9pqqTzUyS77/ffrSBiglb7zV83v1wYUpdFdTLWQSvcEKsfgtOgAIrvyH+ERA40aIccLH5jy/BroRwuVna7YO7blMzp89XCKs7Y5oNyGzSGhkLFNG32qZyqHG7dVvejd6oTrn7BrizzG422yl21/+rcHkuY8ymiJhqsNp15WLWuXH2KqAvYFE//Tz/w0BLHAspxjVCsGjx5D3rDaWcKSzFL6tEwK3vD1so4DXQ4n0PgXbxji54mt3kSBOWB/2NDH8WzARO7jaB9tvfRUOSFSJLXCbCKKzA2SpwxVX8PlXy+0ECb9/RvFespgY2wjIEcg5zdXxLuDpjPDTxzyZdv7uVY0KNPb/cL7TWo1CD/u7qglOYTFJwWaTG0iCH9e995mVfH51lwSc0/qm91OK3b2rvJvxo+jcHwzDLxEM5lBM/ruaVe86dzpBB3AJMLZEYIoN70J9+pW92/RdJqUnSjyehfx2ipEV9ropet85nVtXyg8IuVhU3LMW5hnTUYzUTc9CgR52dWtmVL1B9EVRItVTyQtRiPbRTZaLqOmRIbiihQRLisxKElwqcyebDJskhFOnL5W1Cmfz2/qi6RK2gvmqwXsv7FIyhPzucIrSHAeLawp8wMo5dnqh9o4ApASKhQlYV4AN7zriv8F47mm2wviSH9k/5s+2bjR/sDH0xzZ+t5Lj/aHTAKrVfXRLpkg0aLUa59mz8b7C5CnC3Ha1H12eGI7v//Gn9L8PxmFVsfi+gMZTqSCe8/Iqmgu6vH7EWSG1yNscheWg1+qRHkQg3FHoMKbYb7lMDO6akKsHwVij8KtnoEoksP8VgCgbQkTooRCmdm7Mu013DzFJraBSR1tyafGRGS/184EOs30sou5VBzJVcA1fWRc2YUk141O6NVWTJDpQtlj8K7V8UYfn7nqZj9ekuU1Bft4CJC/ZpCtFBYWtfBCnDscxIIHIF+WXGQu8sWQG/mqzLeUV6tYxQbaIIC+yG8Ie4y5WByuWPCvpNNSpNz09XpJvmmP22ysU+9rbED48Ebji+I4RXUKzKO+QJFBBhmXJcqgkDZy8ljI4Af/iPORGbB5wGu3XrtAatEc4ZyGJaEh6nhTMgJGKIuRVCNvBRKfriJoCWRxUbKrhlu+KnXuLFMlpIZ08zua6wlvvfxBvAuzdAVAZKcXJK3QWwjg6Fkikn18XNATimoS9rDki33OGOe0aLI3TBkq6FXlr92eUW14dIxIANS0onbkIQWbEbiztMNbe828lBijSU0hUpGMjdOo7p7h7dsPEQBZR9P4HD88fdRgu0+SxVWQ+bsBC0yQ4ZYVzYR1wFrF5ZM8fE/nULe11W8v99WkHqRbDmC7TdKEVDSRQMri3dPe4b7rW/r4rGbxpRVUtJGsoc8PRkS14sT2HmCRLwvcW2xt4dKFxA2EL1IIAP8qCWLjr8qcn5qnNIFg4iCgmNqwGbmF3Od/43LpAimjhBGa51baNgeuPC3tF+9uZ1IgWTzHm0+sYAus4GoF6DGRTA9caUegWMYlEd1V0hsbSFPfIF1muhSGb6p18pr2+U6FMKgslshHZFCvnrPsM5LQ9vyUb5NH/tOs6FlGjAbWyu9R8jOTs+W0fYKJsCdXqf/In6lGyAt19OeDU0SWsBbplPBA2gMKd4kxLED4n++JeI009V7KG8v04GqixTEu250XXoSMHTro9wEbX+MZnBKKKRAv4kzl+20S25kWM8b0wlOzz/bh4RotB4OQ4rTFUGcPONY9qa/VGi7wYiPSP2xDWTZqQbsnH2nVGu0d9HRwwQMSVVbu5kKYJqdLRMCqLBAekDs8QGfOSTVwbYM6c+YdAODzXk7LLF8g/KpOBzLzM/cwVQUKYJm2CxTIMcC19abppODrsLVsZ4MEY3ZWW/ftQ3nQ08qBMoaVo7vqs4IY/Gr5b2SZqKdt/5gKWnoUuwyp/4zF13NL/zNlEH13pysJeXyO92QSRgD7GwlA1L0SYoXhHZ3SEQdemGmHbQiVdQP394cHRST4Lmls5AwJqzb90u/OskVQv2DQljS5J43Ngo00TcHB07+VAMxejG/KBDgq4bdY+HMis6Z4OwObrZ9IomEQP1tysmLhjBZzab22AnUKavjKOdRaZsXkPyKBYC4cwrurPh0HBngOMQRA2zSezfxW6qKrUT8gbT2HE8snugjtySES/JaTLtZXx2nu2j3f+PIbXiDvW7jzvUX0pf67wbD8ic5/pVx26/rtWAxL3Ndcybrj/7PWFVvymKEPJWoPuQinYeI3oFCIvkM9qmYpUoyWDGJUCoV58DIvY9ImPY9tgxShNSJb4ks6XQu26sOVnMhqCb9KxKgekiwROtxXxJ1NZ9eOU0SYHD+Rf6zOZWXxgMzT2ZDLs9c675pYhraO0/HeDOIvBLqHOAdfWZREMtosiJ5ebY8d7w0d1CT8WMZ9fqCkwv35RT46C8BifeX0Kwz9kG62dMxc2xmQWHtiR9V+JEQW4ApihDHoS0oPBKxDpBKKgWF+hcO/nHaub4w8fm0y/lXlG9VU+knskoXPfsyJk9qpp2a4H5gH+ImFvmpEPF5iSBDP3PMgHsGgeRcHBjlP8/hl3p/vFI/e6ye3u2FBAG9nSCYqjDsw+gPOw08ZnOi1pWYXHOkzTNaAJOoUz3w1s2NKQvem4agSQQzjQs2DtRs7tLjwVNU8Fzl6UQLlVayZEpKPcN0gdCeK9b4CGgaj+UKXI4YHUX/oxWSMkXypIlraM/EWkx/PC92R88VIE7mzP9dEoVh2eT9tjwRwccwTIp/3lLKzE3KAGBDtKL6ZyBRY1BigiSJ/VxQ50xqZjjo6kq7UEhA8mi6p7ZuyEs68O502jYn+hrTo62895Fu01qDppf0yulf1d8mji0qiCdHzeatJjOcELU4H1+RWjVBHsU7qLmCynEM67wB8T7nspfAt+0YhTrVuw/qZqGGqUCLsdREw9HABJ6oOnUZo8FsJR47dJziKe61IYRrD+PPnan4RozVQpa5MqoYBFpofOUwCy8vQZBbpy/jFRwhSq9ThATJy8XkvPk8UfzPwlIgxNEe28dXMnwHQrTLxbLnvEdwhqWfKzDIDcvKWAbr90kIzoEyGxika5n9HnTj50i4C2nGULjhK8MT4+yxYqLrj4hse0M6VW0ZIw3621o7znkrIuefZwdOsoCDr+aEz2C63xetRIrMKnpFX9BYOU3WlI1Zky4yXcVtfjBgDcJeIWX7eqG4O0KKZwPeoFg/NvYzBRhZE7h39QmxTr9nTHVV2hvmspTAhm45+rhoakxSY1UVVVPQ8unHUcKXrseBxBGxCRAUWX18uyRFo41q6tGuVnahCOKlCPdOxAgCXznD8Es1JVh6xo/ysD3TUCpYyqirY21TrpfxhbTT/++/LN9VmYpoEixx28LIKln3kj1mFR5e6GEgBevTxDTvnQwchSm27z097314b4ZqMWBv9FCo3VBt/Wqchsk0XXxB953VfXS/1ytslmOVDxPSGAo5tXiXFN8aa4BU8KR2R1WO8Tm6faf4bt9GGEq097xyY4TjYdOwWPyUUDhF481PPLuChNXwR1LpW6ZaTAs0+TFtyYFMCNNvpK2ZZssABI7f5Mt/yIEqeihPyMpG5UUrSFx65Nq4gm4jNSMQiObG0DSN5hmq7Qvcq7Sx58ywtT/BcIVsjED6a/Q/fDSGcLokJzAgUYGjMZ0tlmt6GAJwgOnJo+9t7Sv7oEPjOeShCsYlPA0SAJZPB2kIU93ZCXW5jFXodKOsRms7XDBezcGDMitguLTVlefmEiw7JXsSMng+ipZqd3QDPBEGQ0/zyXkbNtLU0rG47lD+pj+BNIHexEgl17Zoby6/iscmFoPic32SKnfJMCwbQ3laK6Y6tvRIUfgp7dzxdc6JRFWUmMp02QB5UDgjSXJqdBpQ+3mprDj6I9FL0nyAZPD9eGsaHAuu/NgXVdvFQhvKA0QUWa+yMCNOgk1UGST7MIfDOAue9L0Au5Z7H/fuI9O42NbY5+vVMwgEnfK6MU1maSYTGRg9ZrlCjeaF473sB9Sl+hezuebZXAWj/YQRwVB9vokM3B0llHpe4HAAbjtTaxf6kc/R8RzsFzYJCjfq8EpQ9e0SJpAo3Gv6BKuwrqu5KnudWnu1oCXtaW7x2KqHAHq+hftJ+tdj3/ZdSw/79zZU9AZ1505TY9UjVC+m5j6i7lRKIAMlm38xb53kCiZl/SwFdvckZMCaxNHul+hfKjrdmrMiDLITq6bD5YXFp4Lwz29wLLDM8g4gcBUSiP33h6YrVASHQG+WONZueRa1WbdOlnO2n3aLhNmqrd2jrXFriazDrXVUo8Ttfv3RtUkfVw/R6i93WzylQ8UQmWzX77ebt6avCuGc3hJy8fIvYhodp4d4lXS7m7fNW+e7yAtIuXdOLMuLeccVg0b3oLF2ifUrV2WgbQsmIY1O6LRsR9XUDtnvjuFk+RHpYNghtuP1RTpL5iHjwej5pOXIZp17NHRqKx9JnYDwwbf699wxp2DMCqv1CkLp8id1qb39lpjpHU8vWxKj0ZL0zlcUcF4QPv/5Pg6ppYoj6PwF/b1Yg0TJYPV8DWfInmMruMIp1w/A7L6DBK5G+m4R+wV62W8+ZNSb/Ovxz7MzVnJ1Bk+nGLflVDO1sGrMZ8g9ZCP7eASpiNFHsw+DXkmRIysmqMhIXER+HJv64WcKZYzG0uzkUGDGNhoDhL/9lukCU6pOTvJNUy5xJd0CDKDPbw3O6Y0Re0zjDIWMVAJOsEImaIpts6Cf9vr895nwLLcklEsAbIcH0+C3oShwSk0A3n1CJyLbLOm4M2DI+LPqoVDKfQmtbXeI3D+pSj+Xp2OuLDXBG4VEC+IZALQ2TE+4tSWiRgUDcz8SypT0ESvqZiCemx6isr+QR+RbXob1y+AYL7mo5xlKR4DMSvPWUFKe7fKNdiAeDZFu/4OthL7xA1adO0lim2dEGXUR+x/8FMwF/YENQw5dthmMbswepm3c+9f3srzjKsCO6JQyjgETqKeG8pUrwztRa16LbQS7BUccGEvnO9Hzw8Ts+uSKdXOMbYamDrYHVdgCPYg314hc8JOKsaOiz/+C8ttZhJK0e3g0rioHayja/ztfoezc+QViaGf6jewgToEzgyT+80+ntd/vSv1yXnDCw5uzYOri994Wot8jlKMYo4UIITiqiSc0s7FOWNjd9irDFfjrWyXA0CTAklWN1Amu/5axfreV63JVeQ19xtilj2bpkS2boL9RY31ToQn9iDlROEc4eKBuUfiP8N+t74nm1IhE2y+B1EBvqB6x9d3Zm/5UYEmwtaiKXMNI5yaTiWHfd0I3lvxquUNZQCd2HRZ8ncDaSUNrTt+cT1XzhyPPPo+mOO3DwdxVP2IViBqubTm1evI/ZBv+kl9zenyCYOv2OIvWLfXOCbd9RqJQqTZu+I+gNZeIzbvVjpBITywW0cVOyraVWD4KAFjHRx6/sw55T8qXKEQHhevusCApRPG68VK8Nm2tcc8VhCoXakX+uOO1x+YwQ7kAlVa3aZrn0Y1LSIP8Np1r3nDY0rgxCIXpnQPOsTtuuMv2h9vZm7v4uTChWFd7m1yI+EZ+1q1wY5sI2ocW8tYospjoPG6XCaDySAvSvpk2xekHfWT7RFvH90+6RZSY+6TqNsADKaXN25clnjmxSV+RYf9x+dXfG5xDbjm2QrLcs5HRMZJWUJyW9vHnhiWr3O74jnt0niyl8IvdX3KRSTYmK/lsdoEPkMS3Am5ehgpXc3j+gPTCF9dWqGNfersO4xAzLiBvkGi0PjmlM80+gO6Z0pyffYWBIfCdxcUrudAOgHac7UPvbKzKrEar5rD/TF1uZegPrOIPI/UbWxwXut2DaldgMUOU4x+gEvBhC6X6SgJYMlRyhor/dYQ0seLcXNk9AyVORXcGT36t4bfnu0FxyIs+JrtMOdLbymz2cF8LsBIA7l/br2F68J29PwdVQRFkzz8tlGqFq52skg0w9F6ONtTvIeeMOHbASGWmrPYpUBaGWYFOf+9u4+IytJqluxQgTUYCwTw0xLiq4Q143w2P0siQ5sIJR0VZN9MbeiCB5c01VhnuPQo4HwNwqRKoiMM1a8UF94Ca+HcuSVhRU0j+DYcORvOZ3OnVQiGmSuu2HEMuucPQGWKbBQyb9A2XrCMABhcS5Mi9f264/Pl2ON5Rp3dDbl3fodNjTagPk0SGdTcBI8xjpHhtErOpDBJcHyr3/aHwb4XS/npr8hYDKXL5qQ+xMlXtVFzQdSi59SXSG97hmh4P2aInKZZU1OsPWo1vZzWlHPbFCzswifzt0IZ+6tV/0l/4qYUfhX/szV13EycGt5WvT/5lczW1riN6oCBXkxxiIiPf/uDEO1fJO8GrUzx2l1H5ZbFFsP/DNlTw/iSm6QMpJVcsJbVyUFG5YwaLPF5Qm0JkXkaDhIek1OdsPK863LKYQulAPQx9DnnG+fRvV0VjnnUMLlZvhW85FwAPkdnu6lBY9rG0S+ZiAWFKxtXTOjgwgvioPHgJ4Xws7rWpSrM+hcWt0A+gxMSQJA4aef5epmA7pfRe6jT0orLaoIEoPh+wxOK/JrRr8GbqOlNJO75VFrz6Pvzd/5iP5PqXOV0sUlFog0JMLqUR/DM0k9GkgL02vOgkDMKu4GX0KFn6chpRwuUBaCXuqFoxFObTxZBVo7ldeA4syA7lKuC7rlqMJ6e7dqUtaSakw5Uw2OUCBdqngbYavLVSbUtGMQ/7mjBn6/Ej0nT92g1oC55YmN1Hh/2b8Lt8OUwXrKPL4bRnMLGNxRIOqdIiDoq7rcD5a+qLl9vRv1GTBiK8T2U74r68ysrdOY7oFVU7R7DlO/HKgqu23xwdCgY0aBKDgFn2IAYU60r4NUOT5fUXDg5wxMRuBk9VwqUJZXnaji1a3IGPT36c/1CaJYOepAUdn5BTN+yXAtUQfqmN9nidprw3wNp2rKTaHSZzdbnRIWl4H0rMGF/xK4hntGsUQylgEXd9a26FVdCUm4NDEnw3IRdqS5WjGpFbVWHmY00tx8TjeQxqrRUAKxcl1pLudz+G5rqEcM/51jXN3QK9QqMfAW1K6mEZiNMx+iu3NNZB3zYQcAdgM5tiFydi+J7POvO0VdJfOVmrDatRnx2O6kOU+ecR9Ud+2bA4z/wVfTu3jwfEGIAXhSqr516vL/9LBjwzlB3JB4v3+QEWkaVYozO/eo2iqkZKPy1EdB1tM38TJ9n/EAxbFTDIV3Eu1IRD+lAl+9xXcDvQiejCJ5AN80wadG4wujIAPFSyaZc2aXgpBAsYlAa+27vzr9VbAJaDC6tqmrPRmqBdhPd9c+tfLqVZjQwWUFBnQdBmFQ5/eVooFxnqBZ/SjyPe047SdGCD3Ghwr8QCBx3IECnFyZwBBexBCqhIG25PvgYDxH2eXuEkfLer6Avm9GHTiZFgLnOUCe90FtRQaa7qhZIZ03wymVePUI+3X8WamoqvEBEUbxUCb3FBNpi3hK2KnYKOo7srkb2umBQ1PIPjtkB+6Z6l8v7Mbnhb0YFg+EQcjWqT4j4pRGV2wv9xFOiKEUUQEe7YXQ4zPti62dOE4Iy4IexGEcAsbO8NJKab8AO83qHtfnCa/Ru4J52qR1gKymUz7bJGjFTxXoJIiIAq6aRv5iVBtN3nvcZ9oziJQlD8EI00ti02E1alnUrlzkzdmvrGv0NWgu+HCORlBYfudCxpZUTADF1XVsF9EivbI513ZaPK7N3l+Md0KSnJmzx1p1ZKZQKOZopixx7bezk1QynPWax2KVIRmzAPL9Ri0v23WTyNSHYamKnwqej4Z9Q60ftbf72QVoZ80o4787jlWqqoHLAXpVPcqIhewh4BMjhQ6frME6hS6JwDLIAIJny62upzYbm0FNfzcdG0Gggz694h6mn98ftn1OShEB+eZdNbcplwoGLw8+dpO4FBqFrZX05GD8ba5Se7iBnS7o2P0yfnruCn5nCMgkr6m5Limb1afafPwV4eZ5zHIkFJqu2VLJ1noB7b6xG541HYoyGDIx+MurQFpjp/l/8eeb66ZKTaZ3WA7u8nghu6DsBaqPEtPQB504imZXWvC3i0//nkAwn7EDxX4BoxwTi1mS/hdBa/XUvmvwtsG0BFgZpL8VexOvuK+xMsC7BIWOfSa5L03hPJp/dyFc0sQw2HjGpWNNhNayREqx/fbraYKRn2hUE+7oUIc99M+TiZQlsUqm8uWxl0wMXFdUtC6hxBhmpjEtaunV7X4GFxkwsa/CZau4dCd+90+zqKUnS4+mqvlD4fUJ+If8ScNhUoJqd1AiRK1dmVAosFWQk8pqZOi5+ICNWrF6cwWIQ0ULZD7W29S2QbweOgxf+zD/sEaDEwM6W+Lu49mEYrmUyye/3lSNwVLYJCCOLRXbK81Q0oZl4R6wrxBEqVniKFUxyYub+hgyqAImfDd5/ODLK97FlEb023YKlHNxQrf5Fu2QpA+1SHr510++3VapSn2ubotW7135oBYOIEo7Q1uG3khIpzz4JjoakvQJzCg4WexLQpDmy+ayDPpgf3B8cHvNk4RvDSE8XV/KxN8aVJUl04/JzGfhlpwQEEsa+iVr9EbOv29tUX0ZEmRV1ifd52EM3aGAKkMXyg2T5JXDBZbJgL2dnRaFIsZvZWZ9Senn+IBW01eHFqIzPWhobpSaLmAq4FqeNhpQLv53dDj7taraH0pP2ipoyFMBt+X1p+NB4SOHu4e2yRGaLEvA5UdrsQhzKm2uzkTbDizUKhoKSjOsn/gOm6ogK9e4I20i2CPYEuchM1EAJ0Vh+Zyx1Qr1eRSHPm+xwPf+aJmZ8Q7Rm/GBxDuMeHB3bSok+Mj4C+21WF6Fc09LX9vzRK3KMM2ie9HkrlwHxQfcLBcy/j7SZNs/kyobXNjsGVEWhgindvU3dDRMyzDSE/9QDGnlUwpI+/Ncf+YbB7Qv7UeImrW6kLJQyzuLURhjr6wLwyroVGAfa4Oo0oRXsqVRjtgrGHBCDaxlbTv7xxy58kxRjA4FountMGt+VC82aQpIBXY9MLpZfJ5V+YxZoI5iV6DYRJ2tc76+NkWzToj1KVixUYmXxs7bMw0/L+QUQTfYaJL3KGeAz3Y1ntmSFm1sdrM2Dum81bOop9sgpTU/ScxyNnHK5xe4aK5Xb7La96nyGWnMQSBv3+CGx/RuoKGfW8+QIJ4+NXAKf2+7L0EFQTPFXqCyHe3K5KjKHaJsrI8tuISpku8FyOIdTFnTRzqkS5IKPvaDoz/fcNxVWOGiqhJhewC3SGU2Mvy3pBNVmeeIdNHipzOK1rR2xp7RYcgBgoHz8posPpUTE8dX4OOS2+Dw4K7xNik3A2p4m0cEwYc4UxpHmj/ZS0qJTD690hRGGFV2fUYMMasBS1sSN2clK61t3/7KZEje/LU0JpVUX4d3i7ST44xfYsOJ7tuAPftQdoWtB3hzCYWCkDe9xNL4V16AbR4EHikULpqnEyOIjxzy1CqSmhxOFMl1SsxAcAwWpHfKw//h6fmfCwHxw9Ugh43daDIDXl/lZtPqPOKu7+sPFvsKXRleF3RJFkO4FfjPEXoPCXjmK6Hy1thSAduzkN72NjqEHlJgtqCiDZi8WkLqerbCVjjLh0BkBNpf4QdBeeE0VrF6lAKliUc6VPw/Ed9UdbAYruhhBg/kZuOalXyExAyHG4w1CzsslOEmBPo4lCx9E7CQk6kOIi9VhQs/+MU4KG9IddtltRixnHy12bgqiehljSYa6jU3R24GTqO1LxXgE/yE262nKWGNCZdCu8CqQW72K1U0Z16vUGdIGYyyrzd42IMMbOtmCCm3f/bJ6/QlHO0UuD1bmWkwZo5+z0IUStDG8X5b7sPVyEowsaMvE1tFV6NfRLKTPwYX7E3k6F9ZBQodivmsUxRw4YPh9QeJUPI2RR/DXnzhFwXUkzXAimPE89oVVUkUTn1RUHGIXTyOygDnCbABaOnS8bo4Or1uT+tbjOfJgEbhM6xjpPJhDJnHXfZL8k5Vu8n9Fk7Q71EnhrD8Y0Gziz6sgzAEmvRjfuf3bn8blryTSE0oPPstk8OwwCF7K9lOjuz2hf4sqtbwZ6xYk6E4AvVyhT2Rm01m945Lrb/hF711/Zmr6J/XvQu9OlgMVHjGz83zZmRgEhfaR1VY2Dek5sdFAU181fFfWQrQzCpXAa0hCD1dVRwErVt+YRWWLzyaYVnA7IX5Mq4t3/jNDOCkNn3pKGFsy+gmm468XBIYjOV00hpsiMRhU15HdPoNqklhZ/twLrnO/Pvlq4BtAgeF4g3zc8PqGdfG7eElLk2hqVZTZbj050oXuBN1L4iSfiWjCQv5AadXQl0efEAhuGd/azlKNlnsgMtxrAQHgAx6PzYj7IrU2hxYvkILuF2CoeNg8BDRYJio6yuLm6G8deHK1mhlcA2EEnoZXh085VfmG/o8v1YIPu6TAnP1fl5HLcKMUhzwI/h8uj/3EVa4Sw9VSEwHX7u5c+s1hBiifIsoZOwhGc2yfmka/Y7dFJwpQ4SJVjSB5leHrzXhJ68KWnLnNeplxOfujlWCTwEuWi1CiBxTP9qKbFLPJqQaQVTHUWYwEwapZB7gCmbUBcwvfXo4v0cWdHkf1XH7iEhegAQHiX2LY0hHUTC8PJmjJGqLZgWbINrV91adewlvkuHdOEF4X8yMHgazOg1Kp1JvAjh1MY861c4u4qKauYnXBqn9jiBe4qcLxBBdm2U/m6d87g6Twk5odMsXl6u7PdbyRi9EpPEyUL77ckYdVrGEFotSXmZGIZyCKUh6YKxYg0OtLZ3yiNdTY1FfqhztlC5Hsg1ix06oYOz1XMFd2i01vhOO/qFOErJylYammfBIc2PmU+l1hP3XLtH57XHeIkAignNzVns36qPTNoIlA4ru4q9flUHBqH4gJ4XV8iFE9QZp4VvpjgelXYDC0Q4bcDTja4yEhVKsGA5yfkSnd7pCi+gqYpAG4OLuZlWSUDdYkF5r7V+dD5Ir/23vxuL/Lu9ry6Q4Jp1GpkpEgvzpUNx9XTvQuywhAmtoWoMmOitA7fDUgFtX/tHMslienV1nFdjSN1TZCbSkCPfJOj+FYEdn1GBi5WYw9lSueBhZFwFKjkK17flJ6Pqkpl0zW9029hIjVvS+rL4CDW8pgwQLle9HnMMmzDdgDh7O6mYN3agKqfWLiPPRdijdBy/inKnpLLh+oTej8woN/a8eQWcbk9SS5oN8DDs9QjFXRbooNHRFgDxDVvHSjUyzNxfnGTZG9QkTOMdii4KJqHca9cLnOAfuyMwgjOuGSdwm2Yhcapy9EV4GKbNZAAxT3kzn5lAplc2KQOi5ZVLqDxnPTvHS+8jp74BydonL5r9+tZFrWZ4W6hj9GhzMGjF8bmv+uFhKn9X7hxo3Wqqz85f0MLOKhp3WNREEzEKTmJO6Wm7onxnwBDmScaM4yN667geuzf4IcBLnYMFCR4NUjScGx8ve9pakjG7cVbgdM8HqCm36mcwfS9hjZ7ubcSdOl5tmnWbcyJVArci+zVJV6FUcAN8uksVm2ciPzxQxYSnh9B4w6o01sCyFUFGGTcFbJKyxJ7GsPCxQ3bAdABw1hYymoxDqoL2n+xlHGcTMIn15oknbCUxPb/CQ27H3pLFC4a5FhJidn/xRGFe3Me5V/jBqFfs+9EinQLvJ6qZ/yPsKLOCOok1bWxz/Eazsjh/cjMMH7G8DAUv9LAf5Bsvi/mTzDRo25nB2BBM+zNGaP7gZ8rfJoxWLy5tLE2vqaMB5pQ8KmP7pf2MhzoxnhsYwS7KeJ0Ca9g54cx/AaFlcd3m28YADtBMR1N3J2XuTW6qKtVXZkSyBmolDD2T8gH9GNO6DGqdtvcZe7TR1hWSVa8RDHDlAz5Zp9rtv4PUTgN4iSp2uaNu2sKLDC2K+ctQ/DAH7P3INJi8bgS5P1hJ+FPy3O1pmLvj/ckr3uzgQg1gZCmo8Bes+2TBINvnBMCXZcrf6ie5TYEcEs8btdB7mEOBiLNd8wlmidk+Mr2WrOiEU8IZirCVNwJ9dHLizHjhCvCL/QHNAwchJt6e52c45iSk0WMBm/PHlDxa8+0/Ry/vTCp3TIoYtmaevieLpR0Tja2NLmZmKVvZ3cGw6+6Ig3aSSLIrhGkqgNNcdrz2p3zNPNFjXvK+NWHk/g1xepelA7cWuCE233E/yyH4oooo0phZZQBxpCTovm8iPBIwSdZ3TYlbcPkBWWi1KCy8XBr06EHAcn5KCojBx80URtvOMiGEj6MFWfzDhQTOuknF8wy9ErS5/wDAQdgCQ0Xslyr7sqSK0GKenWKWaE3RaXdjryiw3qxvzTEFfzom71vPfAJSd7jkOz+zVE5ixMIOXFt57V82gLRsg4aSb5QnO9hG0tsKMadkW7hMziOA26h/5T1L55x2JN+VBnQju2a/AFUmrkl1ozEkwj1HtKDqfepWkJGwkVE+X9xR3J/scALlsEcQy8N3bzKqeFM84xHDhD0IpMMx2i3Nu2sjZvjT9NfXFy4VFklndH1xM6NXhtiAtlEXed3YvmP3mK4u4tew6g0arH1vY4Ejddw69OKwkawGhKMjOz7a2/zgs7Bqv23JNq5/ZN2tY9/DQu6mnG8IoIgueeHK6OHR2o8Yp4hOt3eH+tC9Dh0vMvjnG/RSwkUXB6WkiAwvr9UxgUflYH6cpRvfJBjjDwfZhvqMZpsmQCgO54QLidKvmfuo8jq2b4/QVNZ7wW3JsLaGb+D1iWYttGneelGXgT/7hnn+sQdhrcI/kdFH8Kjg9nvIBiA2oysdnJmb34RwTEnxF9+1YIc4uxBKbiya6fi+1Vz/zNN3AjdGASaZmNAX5bWozKyKi1xpjCFhar/z4gZ0s8Wtb5fqvxHvO8oQvDyCNJ9hJ66mBpe14fS6DgFToGBLAbtN2t6wToSH6rXMQoLwwNZ6b4/zUg8uv9F6/Xdh60los1YEV6FiZ95rEaXGmdCXil7lhhWXy03GrJWXKhL7dYBiWCKO+Iqh1SOZ251vhkNi/K26EbhyPkfrDDxY77qzTHzliolLHD2zLybP+9z2NtSPZoJ4uew9V8sYX/OxW4Kh8y1MtEfNp93BNqWJ1hCy1gBqS3CVmCUNq69uTA3gEj/ABUDsGw+fISsgYUwykibOwIhiPNLfIg0DUO6BV2RQoHgLisQnIFQDIKmeZFmNTI/0bH7xmsxMkLz51V0FqN1tHldWWF3Foloo4yWUHRhIGvYQ+lZswniHPuOBnwHjs3nWWa3UMCkGe3rZ0UiLQItN2QZjEahIWnv3PhDUrkgpFHaB+uQf82aHb4hueFwLcCrk1q5Uct1Zf2Q7lOmcG7mwAdvO2Tcutlxrh8o5fXaDRY928U0guvWY9+ugE6I/vKn8c26yHpoN8k9IslDyhz9XeJ+qV+WT/gd92Jf2zY7of7qeqQpgW2KxZLWZWyB4QSWhYaTG4OXOQr4R7TSmyj8XEoCwmvZdGQGwRd77yXYF172svLwDB6G91z6BJfX5pXtb7ePmUaAERFGX4ykcF1i/aB6rxeaZwZ9Qw3inLrGqD3qtHdn9vsOiKIait93VvquQ6m4zjjJx/MtMv7VERmlZPHjfqcaR7rCbObo7qWhOhOK4lyZLojZOQAD7FcsCHG7Bq9cEQjCy1/MnL5XG/FphSrlJMdMrjPKzOAb1sFkLRplH3UA2qMoutj4SCUCsXFcecg2/Csy0qFGrFF1dWi3f34OVFWUXiUQgUPxxuBVxEtMdMCUK7IYiu4Vbt7Lkb2Z1y8eoOZyz5nM2WAxMUBfUl6KK2Ztya01LDHQMyMGnJRdUlQ4A7o5M3umzdRfV7sSURKpmDWgOugXCwfcqYuaATihXQA4gcgw6gPCoXH/DiH13RhWcHciifi9V8bRnx/NkwZ+8WcKx657Zyc58fmI/cWflCmtjoEg/ANkXtAB/wjIvCcEhVOijYnBzRShlTEnCzKObFBQd8nqMMRIiDYHle98efkr+EhCcvf+K9GDIGB8vvBcJDZCya85dEaSPDdOJpcMYmUK9+LXdhGkOPZtL4cNJBlTTdO2mAS1RRse4RYq0RMzR6n/buRXA+lahGqAgRJnKlXhOJCZuI0rIDmC0DT/RGVJrNf68VdeO8ItKAaaOQ0hWi8gKXCu6uP/DAsih99h0nZ78vMjhXpkVOO9bi1QA6AbkPNd3F0blwjF+GQog1OrGP9zkHpih2zmEqCqIrgv+abYyBHsAuP3llygJUPTzixOAl0pxtDbMbbwVXOwpgCKbel7hwLPGngyl7yt9eo85sp9ilJ0zaJBgXP9JcBwKUlxmXCcrzGNMZcFdSUkHbtQXFJN4EA03nH8eGSc/QlgkM6Mh2ibZptcmOk/LYYW6Ktf2OKhppjhBCfLaXz3n5W23UstlGLICrlhVBt6KY6oF/xPUf9n3BUEfB5/PVvm6ABhIfWyfR8xV7m5x+8A7kdextIR9TG7aPW/xrs3bUGcd3nlAP6emmsXy2yHqPKOHnOScqQC6XqqoAVUWyvtOUieojFCbxXB4ctSUwA/sqQFNaPFuGBuER6wRjlYGL5JzBqFMU3M73CrmaPb+SYJm1MxdNbr3RooOg/TMj8d3yL8rw9iVLtZn3XJKMAhwuMwt7Wb4lMB6UD+2uF+39P8m1Hdrlh/lTB+kBmcIR8Bsv7QKoUSsZMdv+blFmJMpUScdPMhf5rN0qFExCWVRWVSNYdRMKSAX1Ijc131zESN+JdvxZusJs176OSfgVcBySJND7n66/5tLZagulvZ8OlUKcaquRuxTnLW9RbFmER9+CJ4/0Pm3gtxC0Y9X37WycKB18btxR2XhibxZ4EdkYk6yu3rS/tuslOPV/XSZW6ZiQhfTGuvZdoiWuew0OHx9CkN+ah3y2QYMoIPILUMIhFPH5Na2JCCQFDrKMAMBxx2qOcrOcWOAxNngqyidThj/n+OMC+N6dpyeRvXscYNFwvcl8GdEwQ54qWrvTBZw3K2BsSxR3/QSlGbKiu/a+GGs0HJ+FJ2+R1v4yCz23H2fi2oZ/pIVbBF+ZEelv1ANOfMM/+4T3pRruAEvI8XE/r6EsSbbxoXbc45ZQFlVWj91Esy3fe26hy4iKVAIMToyqAiRXmMKUVwPQL3F+Q+oARggNBcahyore20cQhcos0eofPmAN98SJZFSOHdAML6AG6H4FMlLfEHYAcZMo6wPX49O1dYhcCUIZti62CyUBvmolH/tnjracOJk2twkePRPbWSBAF4sclisjjZXJzmRgVPEvrM8EJ0aDEWsPmpp9asU7ok84sclEzJxbp6nv05xnHFdsgbps4u5DXKVB5eIeKvLgp3bK1byPU8XjbtXyrSo7emwPC9GfgtvTslQOvjpY4ZVjfDtppGcg7oU4DTjA3XnY8PpETksQiQgQO3VedwSNZe6OaVZd5lCT9y85wy+sArkd/lFZKPRt8gU0y3ixMaHvedgzK5AAfmfx0u+ACw/XHdISvo6Km2mG17ADmc7CJqyppDV2hJotX5osCrhnHTymmVGUT8WoIP0fbqatOu/fDSDy7UJMchAN1ldPjNKzbHJh9zdQ4XUSTRQio2PaUHyROBe9QVJtX34JC0FajXMt4Q+TJgd0bQ25IqkVCyHsD/xGGRJE9u6LELTSwM9ClGNS1dPTqKBiTxTdF7aht9baNhtga918B/wBDPl5mRUuTHJ1JocWGGzd8vO3tD1X+9+1JFISrQJwq6ZKrpdeCmLisb0PlTSDf1E9Qqe68KdDdQARktrtG/vJpo/Qs8PRjJvJy49AyxsYqLdI6xjEukyebwTvhlapY3jg0FZOiMWovqQbbpY8Z6D0iDxKT5mRTLWmId7Z2hdz96SsnG/m8oVV1fHwAtv5qmjkw9J+S45ikGu5KlGpFUaUZnxF4E3IArFtOMWsE6sFDIGJl0S0gYKJ9XtBdAJf5rQvzwD1hTFA9+BE4cYpwJ+AsmK1FJCPYcRmsbACVOfrfyclWETIS0OGFkOjmR0WLc7939XkuVJ7weZLtQD76AKB6ylEScwuebajvvXSLgjonogo9corxYFSQ9g35ebASYAqG+OORNp/BrKgI5JCf7NOHLmTcl0PVcbfDVYd8gFx/h08LEc66p/EM3SAXjBBGox2HUhIBPtl68E8fZd5iv9q9itXmsx3lePZXRLaoHya2YFXv3a3Ltgn5WtaKeZWLvM9hdB3Mswlaqbx9QlehKHHLYGvz6KyO4FOuzRhRtCCgTpRNp2gTYbwxsVFpIIQUMvn9moM6dU7f3+3b8kF5YXCoXhMbrzxV2UfdDsHK9Pw/pxwLXgG2A5M0WI6gwuH0oG66IOU/Jf7fZHcxV/32aQwgyxKSDj6Atmv8WjDPRKyDT3plpNtS90GYyTISYCAAX5cPE6+84byONyAK7yS/y8C9LMRSyZ8h+b7YUQ2+SduuwkvX5oChBbvpnvLNM/5tM+zMqTEfgwgqEoPdjT7SSrWkA1IWOhZJfERruC0ofPb1Uc6KmLZ2uyVzmN9SG0lc92Quz/Wu3l784JDhU/TucRBlPljtwvlQ0u88/6zTrdPSgsNI4CbcsV8lM8TwM8QoDhPNJiw/j0dmtreNpBlkFKv4e53gs0ic++ggCBOtvmhaLoOyFuMSbDZFkmvwrVckESuuEezUrZ+HpLXA7jY9K0fusqRXBBpPBl1KbfQtJi5vRK4LN9sYhuAuWqy+dSiyX/0DJaB+YLsUSCUFN/4ybtxcflT5KXEyDIlkFs65U7amYyGoWP40fg23FOU3CLcpgb4JabsG8cVKMqVJS0KEH80HemubLYL1FOhwjLwfstRDjcN4YzBsSc0nGtvr4osOx5E1wIQA5kS4oPIltOA/ouxyYU7YmNkjWbYckmq2sE953L3uAIqbEf9ZWHtfJCkDzAwpiZS1uuoDFHtlLnpGgG8zscP1PVIi9fRY9iJ7HGtZaU7gqq4Q9w1dgz2ySA9OYxjhrpo2R2ZqsnKzBpeWekTlMCkWiJlxsXxvotJKPOluJVPNsdCR9GbqM4GpB+U5Iz5xcCjBEFavMtyIruCS5hJFIJuamCPSrt1JCRpTFSzT+ni2JiMUMGUNX37Kr3SSvM5AUvS5iqEdUY2osCrJH3XHD/Ka5KCEOJnbHgau1Gfyg0Esw1U859czPKxpXO/urYU93sCige+p0bguNDVCw1g7TMb2YD2gJhAsZM1Zh7u164L8josyuYCUIDiWmYosKUgjLURWz48zJLCgjibxOFGdEwOqhJgBWrpF29/WLtTxyWj9sVh3cSLcjO1tLJlQSOVsStsX5xOZ1SUDqrrdvf/orCWlfRn8M3CF5ftr5ttU0IWSS5nJ0TlJRUVyoM0lBqiRRyZ+tthL7WWl7I5ZoQ1rhBb8nqo73dkOmdanKpxlpPktzNEDKumEnI207w+gnV/yCH5ZjQt1zxxV3O3atPqDkCUgTY0PsEdCBFnKK7G6F6SCRra9t52Q/VTJnBh2WFV6w4AKrl16kiHZVUVIbDXzxfBnFZ36IPHgTzXX99HVSl3kpXHeo2pJwJBlw9UeBy7dFp+yNv+zvl1GbFY3CS4kXln6wfrJeVDd15WPubB2iExM9fXSjOMZoVOroWFB6xiZDi3VSSoEO/sHcgrWXjYvxtXaduSeYf9XYcUGmIS6XjS+Z9K0xR2QXAE22QJcOf/IRak7i9beviOxN+UvjWdTeZyv1WtH/eNqX00ZCIbkMGosxQa+BnZyz0J7ZKV+Dfj796R5wTjdmnUEES0KaQWKkhUP8r1qEcJeKfyLAdgFMEndPwieU3Mjh7KFfHZvtdxo4qhrQPA22DZLW1waY1IjB1Nq/mseOvcVvGI+4OnG7F4cTaXSe5lXXAhz4KwuawA+rPpVbrquuItVETHzyRXssM2z8oMgwOqy27XTqrkIWCfMcX0oEIbBN+ZQvA7JNPzzC1Px4unoey36+NikJfykA0lVfD1nDmQv0j7akayoWpbYb+WHzyg4zJGWvlEG47wgADgnVLJZWIZ6Ou8Hxum7slWBPtvJrWrSJVS7hwpNj7lFQ0NKNfDCFZBPWsYXJumTXX3Qz/Se7cBlj0LTlG2pcZ+3sSZ9JwligvhGuVWl4ouvbQzFEh2ssxx8EQy+bitOJa2EkWX0m49aS7lsZy//wbueB8lj0BRHd4t3QxzeI2Lqc5TOjzjhgzY/uNnz6C88RLyWnIhahZWzeYzGPQJNdngoXPfKDGQXgl+MGQK85i5QB5X0cTcQMraL2JUv4so5mFa0Xl5Z/Mx0+ZL5R9RzI+6U+sOr7WZpO1ZOHIdtezWY7m8v0+3PoX19LnZLcEvGXgaWPmQtv4Fgp5IDrE73YedUDaHr2fnwXsfmJ+SFnz6UhaTm10gBp2YPmzJrVXZ8sRPzEMHpXyn23P6uj04ionnNpcdHS3Tl4VdSYBqRJHcI2+CJPXKUCSqwQBkzkkLvAKlJuULkzZWleSxZKWmgJttMEcr3Zau8QuiqEqZKL+azvY5hsNHrscdPn2wKsnJDCEpgk3yZEJbY7Sp1hAfXhhGPOFsklEwi6T62Pu7P8pn1zcHhnI+l5+4BtIYf0SJ/OZwNAq8Y6PlqgcSBM0sMVGR0VA+0d31VFXYhTGckUX0nEOXnf5f/1OO2VYlEfhxPTfcO6VKU/QHwLRP4jXV/5gZ5mfibmi/pJ6iQPVRFB4o8hF9OR23jz9NLDTxyprs5aw6SaO704Mv4mAARHRSRM56VWMMNnRWZOEqlRx2ur2Wkf9hrUhCxHtDGTQ4KBCl2mkPCNYtx4KlvRvi0B8163gtnNK2+6Q8CCAfhDOk6w481RnnYpQAbk87R8DdKDStVIQG7ablaJU04yfkvictBD6bZaumYN/gF0zMUa7UbzBsQe4h39gwF/ottPJQKvCT/ezmKl8yMJevZ9HgjteTkwKn7RHGnURBDpqz/AJ4DRTDjWbgkVNGeIpvJ5s8of64eL7OZlMplkq3Dkehdz8kWtw0m1Rp8Vkmq2n6wP6FYzNs9ue6B4kXehlH38qaXawijI3GVu/6XvE8WJfQ6IbIaf+G2Q5lpEaLVkbJik7NqRYhgjRLhELLFHkgkpprff59ICViX15sY/YC3IztKoT5j+nj77tdKUVjN9Zk74zDETCH7iSOF+/uy5wfff5wCtSifOlnEEbfvOu5ybKh7ZrVuKaiXqVaguP3ZwIiV0P0okyy3F2qGPBDQ1IbBsnmy8d/Gn9Xbq9cQQwc1mpZgU9PZJM2p7St6bboO61wkGQrL/q2EHUbrmXeqaIWy2T9uytsyw2oTD1IPH0/9UL5gnr88azk5GwkYl4Fbux6Hy5MhVVX++xzLjOj3ssky+3Q6xjDNoEiLbEmYYq01CdaXS/hXU7BVuTeU1BTbIuZo6CT09ZBz5JQ0/Fr3hf7JoSDBqL1miWHi9Yh8a4T2AP4tqbD7YUigFujilNGun2TOYyPAqUzwWMf2TLlE6w/Src46V9OcfuTqU/rJ96HqCUx8y6TJ7yiGijB4nSQ2piCT8fABe+nXwbxA5V2IZvcMPUPuRKBo4Y9RHaBVdLarFuuv6CqXJC1TPBmPwqzj0fxqVRkNnpDPXJ3l6OjAEBV4MCUeubYS8Umj1KDYANlzCP8EDxHLAkkRyOS68iVdGXw4ZljWWYj+ujLQ7VK7viZZpCCmCiRJ0pPB8Dh635oAdFl0d7PHK44QSiue4F2zFPKd6tyA7diWkv9I7ATjSAIRQtFD/KPIupk8YZI7ryycCaaDHAclXUOE5fhRXQGHUFAUuqr5qxqXdiWJBqlgv/hp5FxGtnD+rBiTyVbfbRtcr7bYXpCv6dQqSXyv/q7RBVqTOboHlTESk0A+nvLzgpMw+Vdt2J3dG+Re5mk3NA7uhE/mUvfdj/iKZboEL9XoAS5xybrJbBnE684iQucE2+WCeDvd886L9HaUCD6E+TsX1qnMLI0N87CmNh7xYr0GKQgwG0KV2V8+UfAxe4FZTItEdCmtX5NTrpuMYQfOI8PQ3GZskueHMoE/sJpaUXYkqlf0upzroq4tPD9jaRYq8EZpHr2HkuKYgkvw3L83pZE12I1a6ubDqK+Q4nWtGDpqEhkO1zeY+Vwfq7x+Olyqi7L/XSqERbUnelOhUQYf5diDW/Kh3tEI330GCynGpgxZRhxpmjgfmkCkf3HXB65DKBk4k4VK7NsGr60NbPAFCHgysxBSC2xLfOdaDD9drejg341zJ3kD4oi0FG8KGlBqqY1r0TP0Gp2bqVITt70PL4FIHsk2zLZkbBXDoErZj8vkCqQ/vBY5A19sphApSSX6CsQYlkpcumfu7U7czS+ne3qqPwC8RQ1K/n4rtWOoWgavoOHcGQ2vg29zS64ZDnkKjTONlHOdCIDhs8ey61fJrwROI+yRL5pycoMWZX0yh6vBB44Rp4DfgW3+M8jqZcsQlvY6ApbmY1nzoOz0Xuoxp7Fhey0LKjAJyvx/KkAM0zUpcX40mZgPrIrlfT3fNrzyhBg3g4Ix5ic93/xJwmnSJNfaXQwhh/UNyTlZK2EA005xg6i94OwL0Z6GyO5GTyGEneytBOiafGvc23WtQ3MyoidXUSgyimKdTwSLOZttkHWZQE/jwyD9wn1OAR4ngqEIsJOFII9snEYKe0DylSXJEZMMtss9CrbqOIAstkjGNfxjdy9xKYsw7emf8oe+lhx800iadM2J1zTmDfJGRUn4abZ9V0jbYQgW8fgrUAfJQs9JqMdRCqVx6UhFJQ0Ldv6UK8qLa83GRJaRCpP4fjcxUKghH3wVn8UL5+2D6VYbzqo4JuCs+sHxmbv3xjSeIH960AiQcy0K9uI3lGlCTVjZ48t9VWL/03kheYa/zK3boGCHlUBQX/TIVj9OMtty4YPcAy/s3sBIEoX3bLf0aJHo1m47e+SrEYT4PvDy9Q2qy1bVr9z7k1bYfmirY9/ZKtrQW3fVfIuL4C48Oe8YxSHquSJZMvqTgmzwi097SK7AUsi0LGV5xWh07iAsj2hvBjjflzKYSQga2gFncTtJFk7ct4tXwDrOZCXB81lQ+RG0cjFr/dCfcZT95Og4cnsN0IrExU0j5HbcR5YzTrH5/ysKBAjSGwiSJuRy1R7gpW0ebKb8luAzJLEfgeA/owT/qZ51WA/SOTF/s2BBWhAbv1zHPhmOCMtCial242uNa7fUv/1LYnw2gE5QAcoxuO1l5wUGHalz0zj7jLXf0jnHXv8XqmJu9LUFUjlLVdRdSsWHlByLEACqv2shc63JtYnyHVoXoSupGVKXmBUc0H7SE+8D4U82wlU6F8n2onshmOp41nAAYm7XpOjC4DCxGbZXDJt31pUBgT7pdaBGWCTPjhGN+lZ+3VMFWAZFL9eV/uIt+nu5K58BbhC/PrAVmV5EmeHMtgyGnFLwL3NksZjQUg6dv93wAfW5pU1chmWvIVG7LWM3iRJXFi+u6ozQBVqbFeWbKUFHyRe7Euf7RDHNCmmpDPhlMWXVbsNMWAaQDIyTz8kagpjtjiNTP5+VUXUMwvpKwj9vhYYyW/Pd0VndMrKT/RfBy3eQh5K+r57k/1aJK2tsBKF7XZO2NRAxeBXA065/Sp6LkYqIxuPp12dVgKy6vwebGzSHwW5lYY2DPYtBxRN4wpxQAhPcBtIlhvOHCLtafuekJ/CR4RccI55ul8j52l+xkcMaMKmpbVs++WJ3ftmvpGUuWmuoDXy9UKr3IDnzQOmjbt/HiGKMpCAqHt5U6CDpJ8fsllTm+ULYnQish7/11zleQM19Q5fwlo6uw9qVCtSDnKdB3CAJwS3+CYU4PPRTcO1vmR8P3aDTUrjteyHrF2Gb6AfVFG5VSpyIh1hPdd9MqbIxfvC3/lNorXkt1jD7yw0nwWFWgJNCLmkz6mELOO8FGv7m9xVcGze1sG0w1WLK/Krl9GaOinTjsDK5zBVnsgK0CSP9BhGemkEI7AUMBCTt+VFLm6ytmhAYuikZqXCssu3ZrXk5bZNC/6BvkRmVgdpYnPoNahAwiarCs49eIJ0oCOs65mD8Nj+zJxrlNA9uxmrfu/mv7YI17fgoFrV/vv838EyXX5huApWlmStMGX9ujr8RjejtC57TDYzUHkVwdPJ2MlovB3vYRGJWOYKo3vQtyujg+A8nf/HCXIkDKSs7RGwmdcgMsIYeMNjfplCJaFSVXmYXOXa5p3y33+iWnLMGara/dyFseIwlWiF2dd7VM8+5kW9FKpg2hstaDimsgcsoO3tncsFxhunWfrDk4dfYqciDdQs4D5iVLrmwFTtv7Ra5CoYq0oVh4pK5sLcVHPVyKQPgYPxDD/mbVRgkpsJsFDbF5cXfE6Qbn5cRaY7sKgk24J/6hW4A2kunFVQjAwI846DvPImvLSXaIlfzltcHSTXmwv79QYTwT9K/7vPjqO1z0IY7q7d10uPYjHc4NsvBtdUm2VokmjPddEiEhF16xihjTQjRpHRJDsh3Xey/eZC97KcpPt3vvgxyGSfucolLGiaeCO96c8BwXujznNarA8yUeoZGL47eYdRsCvMXtVvQrNii8aexDXq/toFNvB51P2oIt/ANKlSRW9Pk77DlLBSh/zaoLznoJMCMUFTn2xLEMpM/2pBLpujYAGTtnK2L/ZXaPj7czkzanZ07DCuwvNLshHDAu/eTlcQXYfn76dnc9EopjeBQQrr0HKPfw18IR2Qe9ZqzlW36I8oG2K2gVMnWyYA7TMLJMoD6ZFES3czZ4Z+Yq47YUIYCdaGYBH0nw0qQn83OiJHII0NQMuFRAQAZniF1ZBHQXSUbjPgnIQGi9p6UeGcZcba6fHQLFMmVBg8y98f2ieRXuF8h7bOQJ+PVnlj0Uz0Xh0oMfMJVy5SKMBMj5Wok4ylWKVYg0QZuKbVIg2w8vVHST0MjZqv2VMJaJlMaCbOB1Sj6n1t8Pa6mL5XAo5wvGf0TVdu4hGrTo0bssVCo7EEbJ2mhKhtk5SCNkhjHx9lhFOg3/RWC9ZXxCndMCMQGyZ2r0GAXJ1Z8j+4Q2ViYxWUFHMaw0WRlEgS9hfkEzDM8upNXFhQY2jzdTfF7nMAS9TD1UPM1BsC2G+5wSBwKwHgbRNPWDu3shun1LOjM4hgjnBhrnv7DLtuPRcQLjne/OMzVYerG5I2vZPvgX2wHgz2VMQAy6Aa90it6YN4KVJEg+ng13HG76PBWEnBjbflYxoGcI4zgSSwVgwScob8B9rU/TUfMo13I2wsJ6zf1CDjS1by2JU9Nk6tZsFFa5cPxpckD4Xi6KQpbD67X9Nk27x33ofaOxOolFUaX+UrCmBbDfoVYy536jmLUy0XuN3hhr9gnCOWNeHLDqMGo8BbKEFNiMeJQMR2rpRNWfjOwsS/GIkMnqIjiCW4Zt7P+NwS2ZCEeZr+xG4xI//CqrsLOe0LjaKNUmkilc3ysPJrrcDmY8eu0CRSHUKEKhA4ciADhq84jDzEDqct1DRsCemTM08nji4O2FuQDRhZq437rSQWGfHzRo7AwDs94R0gZxbGWpqcehNIxbEPwkyO5OuexomLYJV2Ky52+xfUbknbryQaLrypwAlgUPFcUonGWbirEmINZfaEaaVt43DGTfN4xPOrTwIzM94gQCJzrDHmKeFpZJCwiLvxZmqXoOs3tSzVaszV9cmWP0ElYHw9GSyUSJQ/dzxdLtLYk+pVB/hKHTILgxymUckExU+PoMkcZXnCZbew4WDWEbAtizFN2tScUJOUN3Bs7FOMSSGdDyB+jy5LG+keaWArW2eCwxoEnEumlOkctoh2p4ED1JCE4QvvAy/qlIZNAWJff2etdWngFcwsPmVWUkaXzllZV10G1ujssZQF2j8gFpsIGcl5zQFvA7Kmu/M5G0aDH3DlmJHW2U1+oL1m9D1dgLU45RAzmmUO+2JdpXIaD1UMUfaLM0EU/cj8X+71OHedgBEZD45iO5zFbX31Ig3pzahCej/Ly8Fk0qalrFAiErEYjw1GD0mN1B07en2ks4gEc888SRm9x/tOk78/Vq9FBunXoJYMqrZGoaNNC4eCesnxHklvxwAim5BNh1zPRALg9MyqR6dxrRRZ8GrXxDJVVH+iYALjPS/BSU821RRLEW7NgDbQjG9nuBetjKsiVrgO5WMeZiAQnwStZA17PqPWQBUe4DsJ/uBpSC42sYa/nf2sVP2XvRY1Wp/uu0YmDbg7MvBueFLn4tUOnyoAxUzgYVStBx9Jwc1TJKuBD1+rVLBDKwz1vUfC5CDP73jamm6dT0+P2wiqxZaxHjk7Qb++H0CU3irk2NZJTfuWL6LdfJeaJC3/J/5QmNBrh9DL9nQJ+zUw5fe/U0RgrMC6LpgQ+V2po728fl3jdwYczTC5Xe7HFFuoDeQNp7+3Vl2SjskGSGuzQBd/U7QPv+tYwY801mktHpEjF03VRnAqNrYPcIaHOTezKCfBYIMCqYcpA69kjFp/3tGnLIAedmbQM8L+L6F6NMtg3KG0+xarpo9FFhfQecae5Gdif8FvP0CmmirQb5COOBxHMeW6EKCLix35FGPMTBVUAQm/QGK1oNPKX6J842TW7SOhMorj1FWpwCfp4PO6fH3lOJGjrBCXgcJ8Pltm0wsoFOadfcyDBLsUDsbQw7zC5q2tihA8S742RXFURIGSSDpHaI1gc35swTZw7/G6PFtDcMMFPGjmIzrtmPrSu//eutmtGvrCCcKbLTRuf5jlFn6ELTRqOqTWj+Rmr9guvc+W8xMHw5Ii6hcW8kY6JAsEQqqAOzRu0XYmD7j6dZDZGEkxXFF16SBtGl/1nrlvq1uDYDYmayN2sLWnhDeRcm8FaeDiOu4jRgebi+skQnEMlZ1/7XQBmls32MbO5MP7Et+1C4sHmPZTJPyw+iDfXKmNYHTAQrXApJCv9SCzpvWJaSFEJdCRY+xqoRVVlRINPKHkP/X6lRM9cmtNeMk/yk9KhFvrFpbOALsP/EWMpzjJYxaFDupPGe3shceN5kGEybfN/YHiUTE9JR0lAeGNRTih+4O07riXH3iS0qcl7LVjBdRWBwunux/qHdM7YzVlHR2xo6V1bp9zXEzNGyGzXHiWN0IDecxDqIktX35T3ig3VutMCiiX077epptrZaliJTCtonJM1Q561nOR6z2t0D/RjoMuXrK27kL1wkZzo+LZDPvfBQZKgHqVcVakpZ5t1/YUHd40vZZKiCWce+6fi0o/UCFIueKKC23uDDPgDTDqDuSRhwSFub51Gk7miqAv6uHk9VBCV6Bf9iqxD/FgYU2vyxRofWDcqZJj5CnHUSwoZgJhL+asllOIixoGUqxIuVvwpYml48G2DvhcDLjReX0bOTWu3tDdYFKvjllRe0ZooxwAenuXub9uNpmxuiXlpAYT4K2l071OSznJPpI05W8F+epkgpQyCKBAih8lVAJ9lyichG6w5jU25LnC1GRC+mPzlzhN9czs5pjOugDDktIS/0u5P6l0+ohJz7zjM3Sziips6vYiRKYn7NhFVQH/0slbglEN0jauXjwsQaI9g2po9A5CAbzzG5ATmVM0aM8biZwW+ukQdQco8AY8Y72tghGYrSoV658cU/i7/pk/cQv1KSQa6naFvvhgcdKjK3kaICYp0A4j/oSlNC5UCFmEALQOapaCmzvUAl6EjrpJW4jOSE5ZL/x9g9WQBjS7koRaACMRZJ/Y9FTqq2V1KExUwwLSDucWGZbT0C/OOhs9RcJfBTQNFBwijtEgXaG/fRaEWUZluZfBLUOoZF17s5yQj9edRE0Kt7cBeYlWqsfvVZZAfty1ktaMDdwqaRzF7nhpxFPdrOHRu9ui6zSsPjVyFfRQT4laZvr3xaBty6g7wL9Hsdm+ShJPXxkFi+Ky+dnywSGy2wSSZ2b4C+rXd3Fs962agi+ITpE3IIE+xJ5HlE1C19bhAyxE0B6o4o6rHg4AVzWCdaILVI9Z8hG52r68kQ4NOyHDeHcWMoyRfRg19Lm9yGA+svzjM3+z5rwNNFCkhGT9tykRKRuELj36fj8tji2Uy8BJThYVH7CU85TI/05UHcjRk2iKa3g6vmofs3R1LyU6dzZidStl7ttUVARAD2uOMcK03Yt5oY1d8uFdKH2GNVrok0uetuWcDDvwcz54jFjwECeB0W1V2bbCJzz4lPgox5i3KmD0mex6wezHyBcjAPoKPJ4t3rhOA5frMfi+OIzf6afgWzvtuZDoa+YcR+rloImTh0hye4aii/CZom9i+IsIQcQh8gdjbGQSL2BMaQqKsuUyYlTEykiiq0MsaWp2TgskEGLeOG9fgoySRq/IXAo9kilfMni36m5r3kcJIjheXOktERmps2IKsCIsbbFVB/Alw/KrHpUlkbCyMEww8+3tR6pRiBl4FUF+n60DAvi1rS52rabx7nigOgIF2/aNL1AByqgu1mzKTbUHNEtBdf7XJZGfdoxf7Y/zfVylNoUOOZokmWtjRoXy3h2j4fs42ADoLWwhDMPEjXzIvCxNsq5iz2ep5B/gbNHHVKz4jOpBwjh1jcRGoMz2MU878NPM3uqVxieM3EUp6rJ0DOhjJijuZsYLfBQaHj+miAAKBIX+Zwt/XjGGgKnvZ0wqCvHJycqIGCXMBr4G4n/Js4HF/Y85y/GrtcCkVNtphF/OjVmrZDTcjNECQWIucsMD629pWhGzQCvw7Py4HyYjGwR4qVjeNGyLoCSFE+QZpeE9w9bs3pymuPGMWNf/70WrvsW54fWMfwddYlP+KTWfhod9W5nIBe568LZzPbEOFda/ZvXkGA7EZEIL25nw9HXPOH2mGnpeVFyzMeHeaGKxWBf5Qsq9eifLV3W2c9HGFKuKeaoeZjXXVMcB8yRUjlh3bdmAs/tw91qVsTRUhAoTJ752u6DRSg8mILmlMnFtFK03wDediM2gKdX9BSElXs+lTu+IHlGJHH3wjf+FxjiMFmVgSFdi9WudSvc+7nTH9wMRF1Fjx/4zbetCVzCtvUlhYOtWKnofB79Z9jH7nUh77qAIoAbUGVJyDPOK2Ff8Wy7UJazafLwpgfhGqAWApx8/x/6hSt2hdUWRtA8J3r24wlS3GzajuevGGh7FqlWqlCvRVp9XX5Ds7Qwnr8W8XCNgOqJDinsCq7h8+Mc5l7bsHdTsxc/wOeMwNhubjkUqa2bje2GR2otCvex0l4Tc1DCLLzpgeOn0t+xL2w99v1oPANGUOUwfZ6Vy2KNaJJnwzpCkRbbZJTXmtguBwi3if9KMfwf9u3XFs7K38wykTDxCCqMJbQ2jsmApk1QeZGeM+X6rv8Oqy05Bpk3FU8fXMUZ+yMYG6uXfhbovMUCNhd/MS2BZr3avomoZEZncishV4ipXC0I0+jfu7X7Z/ZVP+abOdBxtXfyKOCW0yumeUvPRqtoNPy6H9z2c2kgknDdrgqUfIaqYlJ2AnXfUzP9RRrflY7hlHFMwLRYMmzaplqlkdzFQLc8QeD6KjVsKDGVmZ5U6wL4ZuycKhbpz5uXy7gCwdv3ayHkveT1QMiHOO2FFDZ3mjsll54OVleJ6alwNn5SSlD3FEGMA3YN2DeaoUz6wUfKHaEW6XFlpbTAhkMtQrHTiU0sW1vp6TvL4YvZOYb+4HoK7rJ2IrWPwoDtw2W0Yt2TnfETk3ll10GFbMryrJ4QeJ2xsN/sLMHkYMAw+ONXS9D3rSqoz6CMOQT7lhiWlouFVAaVzlF45nc82ebhrzY1YmLOxuHwyqqzIt5cAHpT3K3sSloYWni5iwzP+bdDoLAsAGYcW3DKA25XSza4W5CUWXXv/DFE3gxekD7XJTirZ9foVbP8piICLeYZt+/97Ky/N/qF1R0qi6Ofa/bLuyDJfJsH3pflAGp03kWK18wXTl3zADzemuXemN5C2ughlufvEOKr0iZVBxq2J41VA1BHbGUqdRS65/VNVxnt1NlEZnSfAhYJV3rY1AhmDhEOXkQnsYNKhVmX/4pQbiu8j/X7BKxXAPrXWhfFedJpgUEUEVX+pbcDSKs5ny5xIfMtIvEFmNqMjx3nqk6VQ4UnT8oLj9LLGtZZ7v8v9ntu1TV4w2lsz5V3M3KXtcQRi9LUijjAzhr0lK0nkuAKQ+wvbjXkPBFHjB2fWD6C8DgLaFLA5H/oJWymcj4now39HYQmogK70e6Lvr/LlhvwW5nwWwdis9fWFvq7z80LxKrpAlecnMc7vSP8iNKGVLkt6WpY3eR6WcqY1xBE9yoKgd+0s5STSCfTKb5qLBy2RyQo9bUeps3Wl1kYUcoBqiVdFGtoHwxiuMEZR2AP/KnWd5x0jLfFqYcp0aX+yuOflUNWhoJxLU3UOvPvDA1BSjZ1h/g6/mFQwuTqxGa9zxwB9xyb9je5HUYqtbj8R/zDo5Ki1xA3XBFaCz0tqONEgFWjLi/ynWMRm1d7uFu2CJfgjDVitrv9T9WgPXoxqjMHak1yaKW44o5nPR02iUZLjsfK5/7oGR01iqpS41NIgdFJjSbE35BDB/M41MMcsx2RthMXug1FPj5oH32DSoBjfDr5/fg0yeRUHeMHaXE/L2vj240sgnasIpQqiO7R7qpMOpMSubcyopoZknnpluJaIXzbMruH5LSmGgmspv1Qb7XgEeCUv9XinfubAdeht4ZeDuLF79bsJGc8tMa1MUoOHarttsziN3UyyDJ8VlGGUnLxLArqUBz2xHdz+CgkrPosPrD0itGSPu9NC247KuoVM1pUGnpsSPpg3Eq8N6QhD7OHGHq/licqA+Wt/uhZU8M3lzt/R4T3SRoUfqqBkZK+tEjrfKD8u+O/cb3QW/OQgSo76GSVxEJE/K14oKcPUmxNROOwvvEfTfFTvUyz6EcYOcZZ/80N/F6vNiaoC1WxpQtCjiIpTPBjtBBUewQ/ViASxRba2Qvr5p3fQgINASEBxA8bccdJYBENsj6NzDlcxxE2NWv3oBkSF8ta4y9A7zvP7itm8JGgmQ0EoJdPwoQP+uyiZsbd6MDoD5l2/S/y77Ia4WjIGvL7iuazLAFr0KH2DOZR1WKkZZVX+5hTa6gfjGMz5RYLA7opIbbt6sZKThBeIiL4kGfIgwDJz2v0k+eB7aSiblba4SYINudOZMnUrCb7GObP78DLVNKWTvawj1jmyLl8MQZVt66MrQsyYBLK9D77uc6+895KTY1h7O0yOEjW5YmSl9OvjBkM8bI153adnnkOfSHjXtA7SvED7zpNO3S/YF+juAOMm79Fx4j2d8RYAfl8ZKE7OW24jn3odonZvg0z7IH1XAJEWnnEF1EHC9iLtEzjwPZ+8M9N+vwfh+lolW9xDwhUG75dSvhdBM3J81kRxD+mGDvmj9yyPV/4pMq3nDVo2H5OtLMI60cgknfFIW1lWtGR7EDmw8Qasi+lAmvr5/cwodWdCBpnNdS02WpnO9p2Mtmp4xwu6YiVHlDX/QU4qPTIs6zW33DbtZ8qsobtEzh3tC5P1SBrlOQU1/0nl2Vn3QLrPKBlrswqMm+r7tZssgJXrpSZWJqqlaozArPAaBPCm8q/IBA7t8bpaggARCDEKBdYpu768aOwTR6/fgAj4UpTEDhT3apeEPCUwReH65bOqVDYDAjukdMbjBXiutUtO6KrvEJAcWMIT7OZ1/YfimiN9u06zl3UJWZvRTWoWXocyJL8/fvBV1ynmxqj8YJAL5dBTmuJmqTcUrm4RY0cDzWswZmJ5eK3aFoL8qptK4EB8p0IONn2vCtLIo1YvbA+SzEZABRzc6binbPPt47h4LiOz/JM4D6gLNxTEuBgb4tEFiPLcRZKKzH78pEpVS9NX9S6PDgHkx7D5ILpb9RQRXniiOVnS+LtWkut7sS61JMz8PI3y8JP7ESJ9iNeTFWOgFIZEu7Rw23KdJKT++seeN4JodSofFWyy5kqAd94wXjXE0i8bhelR6IESmZPa6zDHVFpDBHOy0wZti8225XntlF16RjWblWvas8+K1r5tP/evCfoesLGEeFYNeRF++qkCHrsKCouRWrMBoBgQqj/1QDTC+wJaiU3GlweabsFOA0+aIXHQEUQ05cr+XznCbxev584/GA0taJiVOA0ASn71vMVz9zvknBnf+5do6wC4jv2K92MmE7EqVAmxrOhShfte3hhWSfr3dcRnFYhhNwJvuBnsEijnxUOJUS0mt1q5MhbjV/RHZt9i5C5AfN2esYxgjwvgEB+W2R7zY1OIlVEEyzCsoPLh+ucTcv3+cm0Kw/11cBQbjnyFPc0qwjDGnEHRtiNjwooOl66fb4m34+YgwhwN6l1cZPLZaZUD26SrVgziGmlvRNTDsXJK1zmzQF0NhFRifpiGblkQRSZgFO20H9L7AW2LjF60w/1dWNb6jxJr5vxdgOHTcScda5o68dEpX5AVPqY66ChdorKILI8FpUDdqMwZK/+icDEj5ZwuUybH+YJd62HVfJ4BoAhVLgHbXM/5BIXPlXrdqSDEKg2B7Jn4REx69BAZa0GNgRVLRJk+YJHPYJfsXIyrvdBuPWvr4HWJIgBjGbYFDvk6E16h7Fpv4J1HTVpNTun2lvy51KR873gRYn/3mJJsC+3HE/LAHHWbCMvifMixSx5UnMAVb71wO0hL/FnbtoZfqtI2FkzyamsTg2KkUU2E2okjUpnXH9jhDg4B0Aml9JokiMboPn42az0SueemlD09GPTUY5K9Cjy4nw0UKJCbUKKoytv9vp/Wa5rABhUzSiSxqaNZoWNbYul0sD419u8JpY4AjS9zEG+XgjkC71tGwDeeINnz25A5hhsP/5cJsUf9z3ODkJuKmMDv1gjhnjkVUiJXaQLkeyFT6MQW3zMQjY7XUDrkZw1kCbJNWXyfilFieK01VuZP6RALypNs+bSAPE2RBfhx5m8xjP2f4J2ScKsz0gYpj9dwE2Ix7PZZ9yPdA5ypan+RIF9wq/jBcI94qzGx4aYKuIAEJaCY36Y2YXLG9LOAcQxS0pQHOd4AZSoy0alnLu+1qtInUT0v/K1rg80CpS+D+W9hJ548ECkkh/O0BAB7BL9EEOPs4Wm5C4JNdSoOwUrH1Uluq400wyREaS94mdYn3O6tVwPScsftrBesm1ld9Pwsexoy9MU7tjBXRpzsX2lxCec4a8Ej58iIA0yMTd0YxiKK0xIow81BirS3HzGMvUDqwERSB4rMGYM1DK/oPJeGC8gQ+V5Zas5QZb7m+e/R5g+utrmA+4ptWVCaQLMpf1FJCG2omn/dy0Im2rtyx10uxyWt3DQJdR5Z0SQrmT+gJt5H1NWPVrpg1pQ/Mjoq+lbIdROYbbI+Jh5t/WjrUzkIg6HK5BUFs09OlMiKhINZccglaKsikaJ3IKBgMoZnAm6X7y9HVj4z5Sb9SiERSt3FzLy2DIgN9MABjDeDvRkjKXOZjQO+XEgCg89P/4yKbit35JgWDbR/YE3STxr+PmYB5G22EnThH2sIh4Gj7KWro6xH8zoYa1iD97O33HdxzFCbR49nRNUtCS0ScXZTTiVsmu5rIeMHOmV4qLcXveS5xMFhmW8C4wA5rhPPJ7bQKl/4P2FX6iOH/8wsF+JUVKuX3OvxUhFJu+/03d4nnxX/IjdNnUMCeXSckPpleyQZ+fQlhw4MbchVIOHsjnL6nYBu2io1OU2xce/fcFQl9WHmIExtgJVPbaKy5oUpYhv37WuKzIGXXxW17aHbir2AzULFbjWJ1Vut3OOEiP9nmZmDvg2uXYvPAVYw/Xo+FkNqgUhHJnQIKwlEV1cxaEaZrjP/otSZ/O1CUsRFAJ4WrShTwb1xD9i5ucjgclxmedl9MBbg0dhgQFESHAoj9aTwHQnMACpXC7/XuGCXJlSgYeVxZ/T01eMRC2OXmmnlGQt0deS13+Z6mE2NolVKj+KLe5L07asqeufUroH/oFHPGb3hiQ68XoIhpnEz64vgbpNl8HJAS/cGQ2nSd+1IOfcEUtgJquWFuYeoz8LBNblGyo3ujgVEueDcctdAjNtC9MQo0HkzkS9cU63isF3Y08b+8cXYqptlXINGDp/sYnbULjKNUtXG2lk46bKRnbVlDyF0PsMHSuLzbQrnc26vQO2Pf+m0/UtCuE5OhpBFV7ANPjv/ZnovXoPzaZEBR5vl6VaviNFFEwYl1n/UhQvv/xeGhD/CJ/VD/09iX9coU6X69DsxeiShiMsZQ0cZ/rsabwRaskG2l9mz3v/SB3yd6u+0GUW2yXfB4kkc62FHYDavhqXlh+9rXU4NPURbGoIIF9mOdQVT7RMju/EvKQOQPgqDrsbBRHCl5Y10w7SjO98LTenAVg4c8SP3nVGpzjcSxt1Xwz+PKZbTZSNZhoVJz2MzSg8AsOIE//KqG6TvRN7oUqg29E1HcfWkAxHz4PD5tscod5unYOdAi3FeRny+MZaJrBqnZ9exwCpkZZEMx7StBRYwYPzCSxpWOq/HN6ANP1ZnJX5FT7RavPnMH3BxRVtBO7AXIVMfZZCEkQpBmVDXHxH54bmC3HWgUB5YU8bq1cHGJ3wc4qAQD/Zdj/fBMdPLzKa4y6O+kIwYKa2Dzz1I8HP/QabLW9PwRCrtSKX1DbD42vLaRUnN/GyOMNwm+g0OAAXtFTOqPdnZsEIBrUvM6XkSBZ8/EZLf+5TTpKRsUI0fRSPgjQAWNbRe2zD0e9WT204g7Xrr5uw8DZavhxx4thmBQjUuwWS9Dws3tihH2nivWIlsf5gLGSf3bEurebOQNrsSUYK6AzX4z5lhJFE8Ifzp71nYgx3C6pK5Ti7+9ENZFh2vkHvjvicHLc5rSkktM5CmfBa35Ampo2vvzH/SfgiBGocP+D+Pg3BM0E8yufZCkRG+PCx2ldnqq4ElKXRhV9Eyn93oKMWsbls2qCpUazwwIH3hG8dBdPtbE2Y115siShHru3ohjcz3ZLd3d20iNkEgfZZBpCMalTZn+/4zr45KDbRZcST6RvuasC6ZCnJSiC5mvFzTZ59z298XfuWbl3hevUQ8s5/WutT7Qh6oYRAojhVgviTDcryxccPNSC2UiN5UnvMbX5ggZcq0OOMG9st5qOOrWPnYCRLP8CtR4JpA2B3dgOyh5hXwRLVh5x4BKBh5Hi0l63M1vHK/6MBgpJiAR6iSijTMlFULIRLBJxR+wI+7TH+bL06AQ8tl2hfyJmiz55vVUwTUrzOaH4LNu2CX3GxCNgWJwXaUr10H3wda7H2pbUZJCQi7plMeJoyDa61w9glKtrULWafi/+hRYNTl3qQujbmJV2ND8EDZkBKOL8+0GCBTFHycykqR567C6tRIk/3wEIexw9JqHcy7+MLFfnjXBcrA0OQp8Vadtj27hArSPjg3jlPXpxWH4Mnl2h1LBX7b7nqRDYdiIQ5VENCnPwa+XDBF0kPXDuodEssvrDsMOPUDwJKGl1Wa7y249bZA8JI3uAk+XFo10CsOt45Ijn2aE/2dy5eh7sowhvshYjII/OEiQm432y62WFUMNRKevjsxeqf6thwrCFYkkVOIZrXJAjm6b6+s7qydQMjhL+KynqS7+DNcxSF5JcULBpXIqiONVyhCmMa6Z6YA89gN8BT6GfEWRTFZoi8gJSuX1BFVaTdeZ1pp/G63JUPewq4mOlomacHIIVJbm43RMEsle1yldPGeZRLj0AUcDcinTiZYJ81CeWh2EIeb3K13auomdK4Gzvdh8LFX6iqOSdQ6TBGLhSRhrAQkLZ2145YiYLNmsm7ctvKjIKB6uzJtXQ3R2RAf+UL9XzY58ebdy194/raxyyARb8NSWVZUdqviYTaeQhlY6v4j6wudT5acsqZVzo/CTgPd3PfMjA+T5yE72HNxjXzLG2uHjMv8uzj3Lw7UTiCwVUCSjAegWkAdv0ClerUGPzU9Ai28OzlMzH8+n225Zo1VXnEjQV4g9MxPZFZimgS08bE3VUkHdk97A3XWI3hPGQhE9vs4Zfli+Qm274Ht+HtAQlfL7mkNXBx7mF2hEfxJhB2ov6COAxsZkPEqBs1EecY9WWavfxif3OwADXG1H8wU2Xlscc1jpDgJ0/X1ENpsPMxgwxR6au1bbrtvvs85DKGfGQ2PyLACSGTBnHM2e+KSqccq+/xQJ3vt0OZyg378uzl2XIEVR5gUVAA1DUtNb9NmFeQUGBm2GHlTrFIJn+rMcLorfuH39zZr+pye9AZrZRgFBDi3nGF/C8DH1fZRRjvkG0Mt+Y/dcV92EsaFB+pNXVdll8J/pSUq02P/53MQp9+7If9mrKmLsKMssLXoYCCr58Q6ZGs0eENcpGkb0z5CSzWd9AVaIPmsFgoulqcqJSdqXsmd8D0XtddDIh9PHQKZNAEqKP/f5N16k5QwLVcoeWtnwCbflc+ozPR69/MklwWYwFaGUcD/qaKL/okyTQxo333i0ELefoon/DtgJpD6Vp4vfkBRhz0AX6VyVO/W38mTTwDgEATrYjhSAPDZ/2hK5XcxJqCl3uQJKZc49pgijxDFZKLF6wnj8hgM9045L7AY7AY0IFkUihtBGyCYKCdwg7gV6aE8ku2jy5YQmYDq2QSX7DtPbGW4s38BFAfjEowJWkc7mlJuUez+Mf06xU5sJnPJqrm0YjU0wqYEZJVEjUpU+8J5d7/XYEwE12mSbUkQEYmG6J10gRfwL2Anazyez71c/oQ3pww6l/vItPS/ppZD3hOKHo10l7WTsiPsmiaTWp6Dx+BrsAZGfqtNCC+3PA4FVPqYojlYmsQE49cXzwHBKuKCMrTS80Hx3Ayyvf+Oir2SXzXHXkY2VZd/BkisQigmf6rh6nkkceQ9jvG5vriIde4/AMqSXKnH+fdAZ7nu2IDk2Bu4+A/Cw0yX8OCgl2CaXgfsltDr+oFi9yp3Yg4qQffJHZ1sryne1pydSVTpAYiQDBAHOOZq8yDnBI+7GCTkDXpLiuhCfMflQmWT4DSxsoirHyWfXDzrv+71HEcpNQlZXBmhoxpdokrJTyJUjL+HFUKBb5rPFEe7g42WolwGwEkCS+bWwVJZ+20Zaqu6YvGYfz4GwDlo0AI7vkkFynB9MvqoiGSkwVOIgyaTE5WICtC0oI7YGx51RvhUiNH5797RGeotPv71zF0Awz/yRuThLKiGAxzu5P5FSy6tOdx4ZYzqfKSgs+2umu2SMCZ3B8ole2402x+cGCbN6p+PCVldG0MAVznmmPtAm04yvhe2yu2rSU8vZsKFpnHjjElrj0hL2FJ7ciwKXH/OWfOS60AEC2Nwe/khk4gsZ+nqgFYW7+uNw3irnrjnXmiNHO2sGNscmfoZKissbQKMVzZXPn5zi3nE4wrn+G0feciEXCB7lmwiRLDh6t2SA2+AJ5mACJpF2gRlWK4AW3fQXBrIKca/OGBvZo7+4rM6gz0dOpHz9yOm8sMO04VP5BqC0Y3YEUf02sEIAGbjFabIjP2o4DzTZfMyG5IQU3wLE9th5lmJtu8iGmLCOf7SyCjVxLofroiJ+af9F/+LMGL5lPxLjHShCPm+50T5hRiy2L1WYo6VPUpGID18LKwvmsah5HgBxeSQoxylMNNM0lUn6QCX+aqRk2gXQQf4y7ArUjdGFlAiyeu1dAnwyNWFzLIuiGVIAwWj1yBsqT7LZZTnjniwtJcn2o8J7fZQWBjxXapTGdjbiYAwWPQlRaxW5uqpDu7N15HGwut3TacmYKN4DQ4pAqvhzmw9euhRlOO0K9AREVaHy4HKWS/85Ds+692HSW14UAG7HaAFxcEd7xVZQLrCSaJy+f/7JoaFEEC0U8GvJKGw6rkBI9YUb0HPDRDuDLCHDFKfAe1SF3NV8hX3Mb9x6QLB/yLiSugld/MavwEShFvjAmb9BNmBLV1WAre5k+2BoUyrQ2xzAlJFYicJzKmANpH7WG3RgMWb3seuu6Nyke5OXNNz1Cfw0JvzspTJqGiPGAhwgRa5zPMWTfJ17xo12uNNcFADYdLfm9qaEcQktOOZKkuHz5N3ByVF6OncYJf2tUcxLQ7RGpktW1Nhwmx0NMpaNh3vcsodENkRAb2UnRzL0TOPJ3mvF+qN6fR4A9/wPEKGwHEAwmemQRksVjfBDfc3XKxz36Kjp3CYXeVXimF+J7toVk1NLataj/6IEswf9SvCsI8wCZOM8OFH33xuRhJsUVG522MooHinCmLuOKDftj7AEqjy5/u6kkVFc4fLdH7fze6r+srX8mls/azKN4awuWt0vMzyzi9z2X52yp9dDBTHppfaGP5KWa5bHffO3c4AFIzndwoV2MUcuQnQwTTuFQFn96Kw3vGpTNkZChNIs0Yz3ynNHzw75FYruLUVcEkY+DotpteV6e/3SVUrDPcu+HoaFl54A4tQoAJZfwGruQ8E5tI0wSeHGe22hL1pZSNnIvkw8QKKyAHI4UrtinqugeZIBGKW2Oi7uGGMJ0dzH7XYAn2w/vNA6k0SZFVuyjgb8H62jUfPxKJXughaQ8XBHKQW9SQE1SOKmy+CutUihrpmCj3nsR/SxQUYHx97mAeE8jXrts49SDiJEbWcc2DgPOuy05PcP6/h7z1dFPa6kCHPC7p1RUjvnkmiMOfC/a3W0hTXm1XjQreM8sqU8jgBPKvBQ24vjxYzTOUNCyLiOR578atdV4hJwHhwbEPyfjjnI6k78hNOUd7iMYvrsY0WxED12Bh+5p6tbZ/EeClZL/BgfVgOcpkF5NjWJebCAnsf1s29mjURAz+N7P69lhEOleFt2QaO+bBTPAQekR7PJuaqF8Ez+QpI33J+EmBMeyiHZ/3KiSAfTb1ejHZoZ3yQy4EIQiDUh9QvF31KdHhIn0P5uvbZ/gghwL6Kqj68B7DafPmFZ5/9ADcekZ10c8K+BTzbfv6J8BzKVIfNd8eRTPM2bfFTIDutesBfDhr/1ZPeRTdG1/V6iA3cczm6ld4J3S3NoIvKQ0OE8xaYKYOOkfQxkgp3/gj5M1Ehz3P1IMbfVAe+Qi1k2ad0iSs8FayA6jY+BjNSKMcTrbSRpBTGXQy1PacWsBxqTX+hH/S3nkdO7gxIhOSf7mpgUF/O7dB6Cs76J3MkMHiy6BHJ/jcWRCP0GXO2SRN2MzlsyYe9tXjySFpSSdGKh4XX1AarFImd2Kz5/WExAcPfCDzWlrJoEurkvdjhLs1/mNfnrS/FjtKBq+LBMnlRSxmqNNEzuF4rFOBZFKcAlo10WyOUoLmhag0mOP3NhCxtP8MNJIKvSjZGW8e5wEMe1ju5HYXf8Qb92DamSfGX6epAxXrSdkCTSZU2cVuD5eoOJetyvnWdBeOyandnQiOaogF/jdbVNd5Lpa+memzjtmFtFYYwGtyuxADdj1LCe6Qp5pcD5c5IlyaXKqM4iFMRb5/++072dwJmYFLcnIWY9vZbPF188RXSrWQ0zOvigxS/+JR/aFBP4VW7NDYldqlD39S6q82n01gJLHnIiqpXqH4G2N7WlYgZ3Hug1b++o+oLyIXHghMitBFpUSTpghz5HisOj5Rh6qZg7MDkBTa/hVjJATfQdO2UuU436EJI5/NgUoD/Pcw5kCo5aowDqI0pAuulcvWJ/HgCqpz3yHMegQUW1lF5cFmtcpyCy4ea8bz66YWhr8kjBh8QIu0yARakFqWyQZg+0h0a+r6e22eCCA3oaJEtlLfI0BVc1boSJns/TvdhwVn+eRwOvQsnafOM5dmZrZhywnt1maZAAS4cxeBbM8Gw9kuooH0dOP3CJ3a7sS4PvsMtZf7SmVTgC5JXRyH6kCZH0MqQ7uhNeJbX4JEzP1zH/cXjlcI2XyeSYJBmVATaIH2K9svRU7BNWvyYKmd1cuJJAsEPGmKrzdyOygTOTGKhBwLeyiJNGOBNn38dwIMQ0gLv0lKdfY25bDkMUY19H8bJPT7cqjuDcTkwjpfSBNCP/TztcwKOIbBC2ojOypu5Q24F4OnG6dBwW58NCvJIIMasrPF/Mi18yn8xwrN7wP6c00YaaQ3l4QoDsd5nqh0OjERbOZqiyMDXJi4ZmlXK9sN7BgvEv+V3W1z3ENgPrmrfzAJlJwJeSsrPzw4O7+2Vow+7a6hV1Z+6BgxnaxPr6xVIliijQXtLr343C38skiz4UPLE4svcXarUbtI7evhPMNgXyQH7+Vwvi6g08z0P157GJTOtTfmyMwtdlAql4xtQd7C6CdHLoRl8SIMXxR0parPkk7nClV5SpD57jmqxPyRXR6+ENYwNgCQOjw6c6Wy9He2/Yifmaa41vgXi7gpzrLUAW5Nr1bYHJZzbYRBrxRFisY6S+EdweMJSdAnM1C7uD9OxgxdjqJZEYdWHRJxdNzlzkJG5wcXR568XAG06GXLS0CUbnTMSZGJj2Vu/NpCscy606JRvGwEsmkwE3F1nJoq+NTO4cVwx678dKxERUhUORm90iOBwBDO+N6j5+FI7bdjLzKMGIpjJYJmvJjx/iETQrE5v6zVk9Hc0148F10kBZwxpDWTP5ZlQF331Zwm9T/iA5gnRZFqw+NkAeMjXE8pF4Gd4Q6h+NYDt42MBVvkju+JXFJQhozs39Am2QdXvwqz/4QNiPzRDi1QAsTQax7uuXlbloht0lcfNZFMcOoWFBWxIIKRR5rpLlfcB3Qiek209+mr8QcRs024zZJzY1RfDPvMSqnuX7dHn1SG3lYA9GBSvZEuEn2iSAJWHchefFBRAlOHwL45QPjFd0KrCXqBSiPTtiv/N7Ar0z3h9qnHSYSgJqymx7oGG+2jQa6ZokqE9oc6ZHOqWNyHaJjfv57cDzk9I0Yiz3PmfYUipCvc5tWpHcHm8UMPdivgCO0qU7rXqaFjwKAUeH0A14WAf0Piy2iJmDisgpEcClJiuhN7L9pkx/266nGbG/lDjDwIsFYCWHFO5nBSpqi/z/870NiYb/jKQ932n5A7GM6W+TcKubW7ENwrzmeFlNtBsbMvivkwC2Ia5Gn6ZksOPkCILTFedz5pn1U8qteIm4rJxRa19hA2a2KzpxiQ24iED86lPrRRJuM/dHCDT/UalkxhPGCxcebfqrm0y+oo4ozb4Vk5xORNEQRELXtDsWNBU+RgoWC6+dFdeNGQYKYJPM6/ujMMyyzlSeesfnU/YTwW9s7xDma0X62VrdjpdjbOjoehbEb/7t5kw0Y/a8ff0VBaFlBm7P4j+MCK8hpAYd3sa+a+mMmoD0mAH8k0QkTZAMmna/Froa920ImB+xoNSNb3smu/rO/ZVytAJ63Yh/3PHzy+h5bAQaw5/mfaLbTmb1uxlrwgmCkfQ3yj+D1ttuLEM8bO3pPCfBDGIyJZ4QLqnGn/1Sb4yTUNc18K0xUMFaITZn2WhjaKVWZT5ey6eLTJS1cEdj09i1PNy4GvZiGGQWWdTtKSQsg7dM/k4pziXDtqw7rm0Jp9XqRTitjj5TFii4XEx0jnRxdNkVWgYM+UWAIVyYaAgmXXvAVfRtjEKzf8AX2wLGn9vJnftQrSPt1XXZhv7/HI76XBFL0ng69Rk5a5g78YKMIASTPCVn+oAR27/BzThqvZnszStftV33DJzNRoyN7yhpTuE/jh2SNA9959kCn8+sRJIS50iunS/2W2terw0kC4c/4DghMjTFGSo+ZANapIzdyoisVfHL3z6BrS0/JHU49BB+0/Bl14Pm7nScTHMGRz6DD2P4O23G08uXhWgYLP0D8wf0q+0X1asezALqDB0xegGQccvC0pPJM8PUqInuFPrN4RfBEfuQrA8Q1m6X5s9c//XaTAZoiZjMsNr6Fc7jMaKRtw/WeB6hfVvS1ofJkyyOy0mxZbnqGuCvx8VxKc+8wrttJnIGpaLtnrtQf+/ZRI84wPKZL8kXbopI9ltl8K5m1jdEPZ49tu6i0BOXr7l75DP1cVc0rjpvHdCjne+o1kehHh89bgPicu84UmeoKaFJct+G33qUIBEMx+GlMKaNtvN7Etx7A3cQK5471Es3JSFnIsKd9+w99EdpP7sot2F5wM/xc2Gx/ufP1bIljMY4KLeEcZTp87MzOmCmTdJb/mIE5ApCS+H65p0t6IYJFvZMXZnRW8WcQKDHqL8NqUU6WHPFhvZESNvZ3xo42UACblKqlz7ELTCcEGoT1WQZbuzYnN1JjCyCn/LYTs/t4IiH0MWfU2zQPlBYNNp12qqrsouFEYFONlLpdrG+WMB8/uaKwgLFmIze12BBoq3w57fgOdB0BKXktOSBUdIWsIsOQOtaD0CV6To5d8Uz6gOQnLdbAgXk9HWJaJdPZ0teEiQT5e0sjxHODeGkGhfDDsOWw4LBeTE7jfImJxRIHLTzF4HiAyrhVWJMv9JPXiNEKAiaS0ZRXGwuNBUB4MnFzZTtjYRlJRmoEyMuzUpSZsmaCAshjwz/PATGITPJ0D0KLgj5ZrA9ujy/2YTI0NFJlb2niG/G8qFvp4QRmZYEq81WngmyJNWFYE6GxV5tfpJoZoyJPSh+s6+78QU8qPFWtV7ViBGl7mkjB5uHGQhUgAHz+m/d7Ac8gzqFtDF3htOqkLNNGwWOM0ZjYyBKGIaOf/S0ktrPUTGcSTf91Jah0T7M+o2SV8fRQ7FSATS7XR0WvHISTdb6+fb+OTwSlU/GP/V5BHABATjq6268h3wZrmviWQ+pnye5WqDw0d2Tmf+CucEhPt2iBAHrFnRPg+Hej3B3Adxa/suBGRB+XugZjoa6U8IoW3/oPdFRLke0FGqVEwRpDBHnFzBddtGydSVbHlMX1NZ258gAhcNNuMNK0hjjeS6kbo/vYGQpWcuaRQkLehrqFNgLBbE2mRNIhjMbSfiXM6yTObDbZFjyV7OpSYZ5zABnbCbn+pg1sEVufZOkW0moMxhm+aPgt5ZL67AUWPQIvA79lsOzXgex5EaYZyrQuLOe+IbVpKOs7r6ZvkFZCqE4JbgXTyX9QN+YZWH7MrNep1O44j0qucYGEdnSVP9y+zpKyW/UzP9+peHxU1aDbyp9W8Pxydr82HzqwUtkHgiDbDBsI6Z1bTEQW1KwqpKoJR4sWP8j9JZTZgCfXMCh+Hh84DrExv9ihqDr4VeVoJtI6AV40BBeR+r5blol7GiPLs45pW/WBhCa1LOeFYfTGpvT1V8d3i094wzcPnB9Yqic7MmHosVENnZLZL76ilmCbY4thPh33cvdAg2qhDpZd7eHFj5IoF3MMixDEDFGxTfEtWUnfCsK+XJINrMqRCbk0nP9W0JhOVBRMomXEEohjz6TacjlOnKG9w+t1QSgHRNob9cKakSvZWJ6oMGHu2uxzDJ+sxFQvcc+Bir/6+Oz5NsWkrg1RBncO1TmI+62e+5RQbuQ+EGHAck/yFD6cRHqIxIhg8mNREBBFh9Kqj+xjJJtur1WEeXEG3/dgptAUqGX5Fs80PmZ8kgWOSGeFQfUQf5MwLIHd904oHU4+y2TveAEX7JOYGrKTCjfv51C8su3NXVszpaJ5+YZYui+j9x2tWXfGnay61Wkuc6ipWybm1W6rNZPK2I/DNqntQb6q4OtABI0clF/z4mVXGBV5FVJxrLd+tTpr3VM45/o3nO3BBJhgrh/2GUStGSk1WTGjx2rruC/u0vjPv89cGY88/zuJjtXjghMUqz/Tf2WCQfhBve2a0R3ZVK/GKmTcwdTwaDtg5Uozx3mVV8Dsf+p+X895gAVZB9DiMppuHvcsimK0k45MYHYNISaI0FUxVd1wlLWQziqSubYK+ZYVv2hBsOuXWqGib27Cu6FnXDpSyoPNxTp5ZG45wY6x0a65jb/oX7rs7nRd3SNnOwqWihUdjecpiCWGZTHdfqe9/WjW6EcvIx6GPS4+ISsv5H/tWneL/xpI0pPWKdWOB+C5LH+qAki4VIQAq5VJqgqzoOh6r98IrjIu6emsw1qY9rutSzDbtf5Q+EYi4Ze3ctwvgbHu8aAt2xZKCpmViWr97RoLkUSC8VGC3JfjKDq1ybzuKXCGbl5PaZruG5rK2Qh574OzirZYZfc8w1TV0HX3PJcofVuU4V3AZIsD4rRTcHOFztSewyla1rh3aN+/Ad5HokmNNLSZ6lRUngwfL/A+NMhOL3aQn6CERTOTwyrkP+gOHQDyP5bCCnC/bY+NLLYhiPpCK05qX/v/gqWXn9les6z84Qjnvg2qeQeY1ecjUTwdAgIo0c6uVhgWOU2tslllrX1NaDAwwVCSbnj0xAnl1hkXh77K8Kn7r85V2bni6grC8fVWcCNXFUJOlFt2AkRnXj+znZOGJbairK/QPrz6YyC+Q6PvQlz0qJ0kKQYRHnT95HqP6079ublA+vGS1qk4Wzw/Cxihp9yO37R5IHCDc3R3SI9KCzwNo3C9vKb4T68PMdj9VDyCjLzMcj+23l7Vedde6hGFdszr6UKJHMTHsa7V3RGcKU+GSNAnhO01L8KRcnlz0VVXx6iOvwL8Jg3Q30452Vj1MI0acFI+0cMKhiSMeAXbcHJYiZ/pGmGb5WeO9K5EzPTJVwWLIjdEtkh6lRs928hXS55gW5sAxeH6+3pvnvBoExTv/yhg7dWo2qxw+AJjOKd/mv7IkEeaeIF5IVhWPbXK7Jn9qiRxXKDy0Jx8AXQDWXS7JrH+/LeHV73LGcwS+vEiu6OmLm+skO+i0BeJ69WMxMj6t2ztvBFig1cmNdgLged1m20q9uqW2mQzXCBZluZE2XwZAXS9U9WYkDkDv2l9aZsGXvYO9N/KS8pk+kwhDZdyhu9fEsbOduoZuZOJsv062eFdaLoHExPbZ34QzrR2Y0ocRLNYEY0sTTLtL5NdG8Vgnkn79GlGDD45upH5jMcyqGj/17X8uOyJhDnJRodnUew0+QGj2600iMFxLrksCYFqfaIXU+Im1efJ7JCp4pcxOgcvGYWh3+1Ajw9/nLos2jcw3Y/r5SeYoYH7JB53GWjsxw7Dkwr7PJ06l3BL+ZtNcFYzxHS0/Fp8Ovo19T4wXZJ2qyFvk1u/RyTEQeNE36sCJ1olU+mokLYcuRiPzZ6xp12GMTVhUwcA9+bKx+aTJgTpUuiNsNddUj/pLcI6H7CRuH6dl8V2KDEJaemJ4irHsTH7jinlGfWkF6BTOXF5KCju0Yh8QQSSAz9P8Zh6rFYqFIdcHGTpTP19u/ws3RyDWHjQB+9caFTEZZLOefesAaV3hd380lqDZDHSchPZZR3ADJlkILFVXBnOE5IgyRLFF8sUrLQ+evtSUl/xmlfaXr4rGKCROANg1LGkDfWSHpSZNGT5yv+KLWzkGhPEcuMt7R51FB8wfiXeFi/Nindc9G87/xnUbdA5iGwcUlJmoGXjM9yhhUX/Id7SFF9zZj68RjG2rRJRHvNPMVucmavMF4Sbfnr59+xxCQmC0/QLS5oqbIoUlQrFzFXSF6tYH4v01yw55NoUydydMtJYDro+vchMrBDaXKLpgjhsQ/mpy9UHglSxvpensGZxGCHW3aLnP4oPe3hPvESiU6Ea6jYWY2zjeEf2iyeQaGmqd879O8sr3f5nlrc1gEPoH9Yix6FZ5INVHdkodX7ci/f572bgqJpbo3Cpnk1IYMikfROir9se/yKMpGd7WLIUksgV5l15/yqMIICkntIET2HuH7bYCiVFFpa4nefFlfcbrm7GPBdIxn5qM18l/dEIJuxZjBpzBzetkBYXPStmUwyQNI2aL5hoxttt8m+1IPYQOkz7GfNgAqjdoQi49EVpNNFcOcKWHPqLzWHkUE1C89bdsk0cU+UjDO+iUmtZ6IXw5nFJFzXWcVVXiziOIFL8c7/AewM/q1GU18uQeyVDYUfUekzH6eBDcW3TOEDnVvu3UGkivVchcB9osY/jE3z5VQqyyq0eeXhhWbbyK4AGoUb4LD2OkMiczVEk2b39ECOXBjFtvTyHorG3PyBYY1MJ1arW2+/P8UZpz7fioGiZqFbN1UnS5nFyysWWb5jBIciyFg1rkgO6oV0FvaWgoPDWr3cd3g3voeHhaGbIy9bEkr9SdjD1CFLglK7hPVRk6R3scP91V7/NfVZ8ROm8vY3hdrD4QbkSzzkEe8qyZ+8gJ5uHgTw2lQa022zYEoqnJ3n9LuSKkMyq2N0fwz64wLXBTNXHpdXGA3bMOBxoiAGhv+tGSDVmOk4/wHsyX8qA75l8tMf6Gf5h2jLJg0AjMZq9Bd5fKgUF9n31n3L/i+chtIb1b+zsfmtoTKlgkh7ePsg8dhddebxNCQhg0cw/tsQSeDdk6b3vTCn5rM5mcxjwRfMMxgKnWqRZDxCEQFoqy6B1A6Cn4yIfsPCVVEB4J5aAhOC+WzZ6xSLS2XmadKpbCblW80U3iNALf6DqV5G6Y375NivE2HJgNHDFwMlq4Re9wXxMneLCGybvJPHXUj1enxCbkz8XsLHI7KofRr1PqSnJQZUBEogIvwz1SYtIDKDWbHuaaEROfZtAghf0BiKy+S87qmqiinpNPHbTHAKTnd3QzWZqY6s4mQ+Ucs8VWM6FAkGTEHeltYue9xw50lIaGE3FHTEUc/UYuCdqgrbuElvavtUNo92gBwZcJ+9IzAQr/GJEe22UHZ4O9QV0FTiGInvSIPIAl85yqgbeElA8D0uBDP8KRNC/tbpzZFdAUYp+jssbZoAbbB7mdnMzTGkFmTRpWt8t5VKX5Zl/jW3VNPHQ9xn8mPojMdEseRs3B/bn0gbUHcvaPchpmvgrA9XIpP9X5nMjrhlwX48bTx6TNdg71i+8Vm4Es2Shf2z39IJkgZuiO7sMqJlHkPNKjDTW7Ys1AUDzLhybfqwozHb5D2ttQlw2QFVlWSSJQYhCaNVFWTzF8FsIMD2yG/fBvDt3qDplv0LPP0Fu4cye3hRCkVDIfeznipzuyh+/0WMs3Mv5Bl3vG4ypGWHCGaDe9QQ82v813I5ik3dqU0SMMmDVPgvjXsF8Hr/7Nxxe59xl/O+a552q7hWcwKWVFOvEknxIlOVcn6NGL6Ns34KZCt3p3Yskco/g2FbP5i9tmFi5utT5yVTitvY9Qauxr8SDEugmb0mzUtEb7dI0E6pHq/aO4jOaXspC5KfuHKCOYQ6J1LrfAzkii7/XiZeRrvPdJmOkNuC25QLEt+wZ+0PWcq1TgvugLNz2OPas79rgxnUjmLqtNsimKB4QT3YN/iaTU0h4WqP+nu3q3VjN3APQVkV9vUfcGDKMp2CwdA269KVSRbGxzqg/v3kTdmlJwfz7Ow0QuSM5FjXKokT2jiXxCdDAgc/dteznWBmrHQNoGq6XqltVNfSC7BhBt5rD/jyEFn4GjEc7m5VuNh0hJ7bZXnGkY+Hyc0Hwj10ZgWWbdypmmBFh+iuGWYWCbVi0Vpk4NhGsesENAzHKUo5x1G7XC462LaeHKA3TLCZOWwiYQo2YFNjNqVRsHoxWyXgyL0co+S+sd039pRyQeIoIXgn5LdAg5wabcnFOUe9PC2TPWDC6dv4eilK8m6ipNZZpMgd69VRuATB8wgwe/aFBtP388FyD8Npfgvm4vzOqpE84vdjwW6cjFLy+svjT4P5OtuB8do2+UYRmC2KgXrhcVu2Rw1EwWzUdtiCoBUZ7jAYkDEXQ46cCxe6n2eMXkZSK8Q5EbRoZDSPZj1WXm/AtpF43p48BcJzHlnxCICb3k8iiPFeCkiTr9B1/sxywXyHKzkSmGh2ZYkVCdJN4Jk0df3iyfmNF05DxCzncH0llruhiZdz/JcW5zLBOO44cRMfyXWLEPzU+gX3LT9tbfctzNsxC7Fyt3T660+h/+WKQ/d+7Rfb43xtCEoujw/oL5dnIf43ECrUY4KOBlATTpRUlkY+bDoOD5Ke8dGAZ/52BgbOXcMnTDBp/QoCRM/ZU8eUecscHgVcB8igoVfHpRYjyBUnm8kc5tM6AEcQRqzJL0SmkClXhMhP15TirKCY4ZIfkIM949qYC2nHFbDootho2XPsr9d0rdWSEvvDHV3fJ11uY+TKYEqx2cilDtt+T8quNdXYRqkcEVaZAjdB1pOf9DHBx0kyx35clqXSdDR0DMsIQlgTjMC9jg6me7t/qGrOlICh/egUqoCV114U/MmZDKEYYYqXHxWOhIjVUVbw9PQ9v2cQTVvyUsd8mF00gybL2Nx9kBenmex9DkY+QqiYwvmij1kyv4U0FWu+tXQRKPmmjY7LT+Cn/gT58W6GEjjieLDdDTIDl2M8IHkGdiGg8u4L3lmHCEG+6KoSIXu3vYtT6YjC0fdBT10BbVFdWrjaFCpWhktTM3Vsd2nd1sXlQO0dddiDoTEZSZToxPHJGno9onMaS75zuzuUHMjhOk/n2+ZVE01WIF+zRzbRJnB5C4JiPAZXXiGaQFPg7ptTOZPOpVnG13VuwOlDRan5pBNRvS7EiEsTdARTy902piJWv/XEy4un8y0Uv8Mf8pHnr/Tm14WUHNLC2k1TZgFfgcJrEaqwl3kFhAGQTL07Ucv654PeAzKrnsj7FwV0f7hW4AKzty4PiurhfuPKt+bPtCOfNSI/JqRcmH3B0aHRj18txa7Qqpt89S2g78q4s81jBRdKI+1TThO8vwXw6ykENmAe3iPjwfT7XBlSmxqn5ZlvXG26HrRlEFoNokpqFgQweelcgdspjM7YqlZ0W8SaFRRlwDotXGnD4yu1Rf+HR5bA10ujaP2crcGg/Ymvdde/EU70c1UniHdbc6HOZwEWM3Lpt8m9i2GXhNxnFnLPECcyv/cEnIRZP+Ei8sDH2wYB6tnJvRbmuAnTpXExQIGQpiKEq/3CzwoyEAIGlFAOcYnFYzbxGsWswgheEnbh9+/slDi7VTqQvfLPWuthNE/4R2eZg+29uoSWMgbM0XfrIR8zl7TuEpmNEm9Gd/2VsRu7XFlT4FquhfPu+4oDyRbGMUVBT2uTHDqZGDCYYLWGyphpYbHdjqZTJ2kLnpCODPHXFxaw3VKsNCa6MIELQ82rvV2KZ8cnYo4chUN4IrKfurLMFndId8xLz+rxYjooMWOHcZ3KME3C0fMrMIeWvXolqgNrFQEM/GoIzYHX3AWNPs2MZup1V974Erfd3LS63wLk6MlowzOuRCzZEs6/ugi7rMwSh4kMNrblPYORPbhxC8ekRTBlQK08Zmi/gbLJOBOXv/qzhTFgs0rtrkU+VMrMlbIHWtSighvu8Yk62+PK/m1KHh9Nvnv8yjT5pBg7prre0ZEZPLponQFpIk2xHe0PiEQxNYrvmJ0S0XsegJurRJR+OFE/6FtTzVhog2XEia4KtwqlQEO48Bvf4mCYMvFEaMOgMg8IRqBc4ltKK1E+xcR5EAmP2smKm+zzRj1Z89nhDV7Li/ATj3CEz6Of0aBZ0I6LtQWTwRUfDYzuFbc5TjKRez1gAu4+qIaoY6tk7CgqyUel4HmINcPIsx8KAE0mc+9wMuUqBURR6LCmvVUlqjV4D/LxrEMC1xGMxp8PNfuCNFrY2WHcEFPE8uZcELOSpMeN254BaIQkSKe6plwqDbQxMludiDkkWIunBUhL8R9lWa6JvCeMzOYLolpsETHkfPLQLp5NPfpKzpb7ycKdWq+XWQMAy7khQgMqLyM2kZBPfQwmVfqMRySqiZZHRlDCihr24XPQU4ytHWKZw5EoWlnXh/CdRroj3uyuMWsPlYMFOk89eSIA4lA6aVSKBBZMb0HlYOTQ/TYNYvht+knPj/LDv94SQZZTwMsljVU6vYxkxVli45YUYYOOCHubmbL8///4fL38f1a96r1bUzC5n4MJnlrbmGkzaxtMclUqiXzIbHODAG+limetSHq7CnRx1xZNR+XvFZS85vTM9YyjZiWxET7hPKeQrIJyGm/BNF1pLxidEaq1gk0ZMoH2LSAH4Wbg1SDDPqlmA8kU8xBjU7ZLh3Z3K6xg8we5N225zcjbSV7BaQ41OWm1McRzLzuAp1NSknYYfXe6ZdJfl3T0GAlKbxQOOMnG1/gdn83Iwi8Qy8+g6KcqZiAPtoIoKZKEhbjOB+UESB/yEioUMb4WpwwI+quEkZWtstC7LdF9YlEYNq70Ac4RiNuUfnEuMbQVXsic4IgutMNgQ6mR6qRCDJkqK4mKnpy8ne6zxCJ6pO1o6jgo+c4X8MyfhxexFDPy+Oc06aJE2gDA4ZRgBGOon6QHwNKxZTqo2Atu41q1P13VQws/Dl183u3o9sUhBBkYXT6jacRahBDrv3AND29V3Xmsw6+1re8ZnSDJP/N2CPxKrmO4kEDZLTQtnqtMS0KM7e5vaGNamp0e2w9aAnziF3IglQgNuDZTsbUmvFpGSeNZCczPUXsnnpojsqi4dyspZOeS5Ez8cxZ8biSELMU/mDoKYt/PCyepVdiHHAoUwWsUXeRA5tVeIfhpwGSad/X/qmM/wPCk8qD9cw0lRGo+z6+UhBkl8ptP3aaRjIq6bmD9wUEPdjcN46iCTemSRU2HxwZA23wRuoniqdF3lNc32+sKBwhB+gTGpxiAgEfdbYiB9BptJpcBjYQ/Z4iLwHEesK4qlkO7MtaNkW7t+fw8JSjwme0e5qorUvtLx/vOxkrCjweL47vG7nv6NgW78bwkQ0/xr0wzMbfH5OjEi2rACIL04qZACETZtnGcwhhkxpG+WLGq0U10LfdOtl5CH8uX2bu8VmuG+jbua9ouvb7NrJtrYc9RD9jNKjGK0qlgeYFnTrW+Mp7fWHYoQ8WZplM7mVw0+jRfny+aLnoGzd2mP1OIFUJdr1gq85vehHh9+HvufhrJHBuUlwI92DYMWMkxc6vUscOHZAhVtZqAmk07Nusft0YEVQcwJKYmZxxAHho7yAWIt3rpdRriIYE9cpNdXMqGanYtTgJUzOHwmIko/BRvysUXUXN7fNHFk00RlzfuYY3regIEq3JYwCTD1RfafhN0utqdwuxZRDAfh2cLawh/kh8uSTNshjucn1Z2OI8zZ1701Vp6rhi5GQXQOvkQ0aPoShOFbdPxKg3DSaZBHRtzGc+LEaLZt1GTX/aHVabxezKrlAJXe7A3cLo7VsqbmlEamGZJ0WQuyQO/5jvDMVVUGPjwWDAFB5HLL4Y5pACyKDKkAhELF33HYSSVUBJtZlVd6ZvfRHQx2vjYOqtElMDa029IZ4KgV7hTo/1SYuLDwXBSsr/jKWBdCc4noENPF1L7lxFWVfGh5YoJ8RGKkL1uhSJgaq6K1qkN2X4JAsWaSZKKcGoUwMvnWxYTQZT9dW9lpNbrh4Z5CADJzjN07NtSJkUIPHwTzFqRW0h6zl64dwcQeJv0rjZxqAG7+NT7/wKJtxHjZOvdnujYEAIzCjCn9+AEYgS+3XZ8caN3pF+DC0QUTeLV15OiFTbdT5E0EUWlGOWYOgq7We2VzoJWEuRBnIwn5YPSXDRHRweHCxa2oloo2fYzooJ2/n0AelPBGuZhxUR56AEo02AtehEBdKYlP1nXkmBY+cA9A8634JX8P5OqP/4HOeralsUEMA/NIhrMBOZMQfm74lseLiAfrnj0BQb2a2br4tvpfwhMFG3U7zHS9cF2m0DnnQmCyXnEDc8f1EXAGXk03Sy/TwGu1p+/SIoRd5J1bUwxIwzR6GipbczM6m+5Rfn6Np6hk9GsmnISAFXqWi48DRfJgRhHcaVwOSYRU+hqO+QPqLaetE2hjkZ7aSnTHLi6tsDk4dc265GCjFQ7ANBIN8pQ1PvY5HB/x/E+p0Y93zLE8TBc8wGnxjoF4I9bY5sYBNdsvqMB8aVIUqUZtIkA/nWguUdy8E7LxuDOprlKzUhtS5Gr6EGB1eFe964gwmgTYepAhmkdnoUVmENCDZyq8nQZMigMV3MfzDcmScmYrc/ZySWRNGJtd7ATd2HefctJgf7ndwv8d6RAF6h1B5x+n4mYAQMgDj8X2NR2yLSX+DGv+SE9VaLJKPvJizbCI9QyYd6vWIsLY+LCgoHWGPIWynv6cgENrCDz+JME7g5ZSTizV0mqaqmaEUqlH3XwvB7/S7lGLPe2xIR8h7mZPTp4v7H15aVNh4rR+O4lI+9vdOW7Q3RVpn11wiZGgT87Q6McF5vqeGn0ats9EdJjh4NzYj/hKN438IBlF33+zl8xplqXfdhnVFLzIEb+XiMM4YLy0wUS8opmqlBnRf0oQtgFKSdIWIYEs9dfgbqrE22MeSqErJWvX+ayLFgbk7QO1gMX6rjgOBK1Dz/0PevChSF0uAtzm6mhPPMxDY+ND8RfWwdeN/Q5Xb9+KJBcKVxU4/X/4F/9sQ5ZRFtg53H2tyGLhkvEF+FXphZOv8MxOvcbwtvQUy6WWXfD6kAc9jxdNKO7PVWWI38kTXZT5KnX/d+tNZ8RdiiRvhSwAja5H/nalvMRq2bkx9orOhxnQmLB+6nke6YotVckOjMwoP0EWgcuozoJDAIGKZjsQcWrcoF9Ms8uvsZWmrIQM7mqOCKGC8APHzN88We4/WjsbIp45hQcqyG59oQTMnh28D5+qr3gkLcoX4x26FCpyYvgHN0HDgLMIWUgniHUU6dN7D7HI+PofAEAiato/SVByZ28s6pCG0BpPqoT0D0jSP9u4W62oINHa0jSlxNK2TA+qSapJELq/gF9mE0I+nU8noLVCnzfhBuygXJaT00SfEXDK85vulVQU+vFOmk1PSoGgt6BSmb9MM7qqc+fmNqQsX4appFwLIBn0pwl2yaVu0vpJdpDGMdgy6YoMNRhAlw0BpaHCK1kjuVBs2Vc7WMQFBZz053zbrLrAcwp/zxQ+XidPJMQYTn+Ayd1+lLXGFOZ1opbFdgDHszx2NdgcaZaWxut/qkfNjRphKXCW6AH4bQcE0u31aboZ+Q6YWQlpe2O49/GMwAzdu/2E+GDsXeuevaaEKDijYZUcxRNtm6jffeSAg7Mkk1L/tQttjZgspqVfzFRCF2KVf+778/eX8eSJTB8ulGyY17datebPcDGyVnHvrezLsBsGmZf35bXUrb/7lcGBGm2hOJssvedHEgNHiAXMRo+ohfKU4pi3GfR335//YmD+MqjzOwwcgiNIxzyyvZy7w+lfjDO8VydWRYZGXMvWvm4eVpzxnb93W85GXqBKrLma4gMQjwiIwNK6YzWCXHSAUr/NhSMqHq0sHlr/01FYqLH4Jn2inAqWUXXp1Vt2GIAsdi+V2QeY49yEpiT7Z/nyM/8f5TcHKKF1G/KHv4ILyJnwr2+7BXJy6bcrSf20/oWatkKo2cCdBeru1ixhcN6uJa5tmVJONgVnt4DOYhe8gyoCCpxCMmtTRrk28jeC89U3H2WixDunG7SPbZC2pMiTW/8PYukOTmwvmNl/TuxKk1OQBbMvT1q6jZYIvB8zS1CPWQus72vWYL3+2hlZm95262nq4x6jR2q+YiYGE6IrRXT5RDvBGmcV4h/7+FEjle95iupHzpddTQEbw82KmQZI4fhlFclPV20JuCbIGdHvAbIjjjLNLDwislPdCk2nUylptMW6rrD22IyCbGtyOSc8QGxfEKKInjjHUYlVbkIfl29bYA0BpyJG4bP8OhWFjl2t1v17t6+6w2cwVjKo1KU5vrzl+ren6P1bWMQIdlNfmbV5aNRgaxJutW1qkp6QkIaSn8R8L86Xze0eilVmqLCo1auqNcQF++PjRpm8kk2FZVDN7Ny5mKbCYHzJSbbYgE0frMWJ0yGqfdoYZav+cLzW9VbSghGg2pbEW7sjOUlNZdDXLGJkvtSl6jA0VdA8tt32LOTgaOKuzx/cQyPhXp9inz9SEXrdpll/P+UEaCnAeUVCogLxkn7fSXkTlvXhd7NvOz7Y7Irq99/ozwLDISY9k4Wf/ONvO0m+vHwA/Asm0RR91VUr9EyIGk9tVnMRnwNShHD9Y8M8IbuozX7IVu6LNDnaBzJuMxvGcDzWO8TzC8FedyP4kcUPVK59qyQCpXkN+AxyLlTQbTnwe2JV3raRixo90uo2u3XlqRkz9LpX81JL51QR7QrOl8l0+/wd4RD5J6uvFz7sv8aWSnja9PAL9qbYpXCN5Hr6UCOCHptu7Xvk+yZEkod1EChAcOMgHxLhNSzeDcXk2dMeQnQ745Nfr+pTS+vOYZ4obuP5mkV17odmDuV9bWK8TAR+2QMEkIxbEUt+7G4zQhq7aY4RsHZT9240oC+A3DqW5C8vzTV05gbL6tbq9tb3HdfJuaIoyfkEcPZoIOiptWJ3R0c7a7QgWoJGezAZvVqdJqqjIOnb/MjOTrW8KZDLXQ5b54d7MErrBCxKqloea9KfeOTtBuzZECBliMm7TFQX3Jy1WWscZThij1ULOD/7B6LE9rJ/TW7HdTIH0GQV4nO+65gs2t8Ws3bbIf2FfDqFSxwsKFrcwnP294nB/9MrwlS2A6Xm2qYf2DPIa0i4/sjYqC1YWQJ2cQSlmYBEdH3xX1ellZq1SelBnQRB0wXv2BGdB0dhOq2ruGZqBf2UbNYAxLjLGJakZABpjDRjRH8CBtLI6Tyj8UYYuKTkewTaXVX6gkUaY5XSr/sPjmMWcw2UJ82aFwWgUaLgqs1LppwAT63IkA5ZCg6oLq3u8+7h8HpR1OpTLP/1es/vuUt0hZnjKDRxXf3qbU5qUofoFQe22DYDKQK9AW3I5xNJKG4kSVj1Jo9vzPBUeUB48o7JziBYmfmZ2uz9tPuJx4t+Sld7km0HlKHSQIcf3ycFJtOpmWEyjzEr9r3SO0cgPfR+TO+HA7JzetvejSq6Lh/v8Z3AqypVLGDCXDdm8+N+o0jkeTPR46yRZT9KbHbYQ1w2cPq6pm1TZpbr8qikP5HMQCOYhE2TF6IybtWyEzf8faSXFiutZpYgaRiOf8nijQ0NTU345J8wZdgGTrRlYuXem5peg3CUnYvTDw3a499EsyZwtQntIcaj13wiWXwX6PWrb25HGowRvKnOrllwPjqap2DrF/5qYG773qDobWEvT08qI/w3qhju3+g0Tvh94IsqC9+abc22hHaWEDNMNiomdszEvd10vUgrUlu2Knv43cTGXaQtdcKwpSzu3CpHudfydBtNHI4zlXtp2AKIGyJCrcIzuy6PL9gl0OAkYTjrR31nrBvYSvI7lhOw31CNpItrtKwC3WIcBPZiUOk4ecyLBg9IAj+GtnbGyC4LfV5cLQYOerJYPhr+EXMLPmNZH9wechtztAvezLF+N+fuU4+VSS8BkLoTma5UlXhTPYBXD6JQ3wUjkZhAxdEgLTJoZTFAwEeFAvfM/3l4nWRp84CfzXxDzpUDB/JiHETvjb4IRWusxTYQQsfkrVbpGSBe0c0HaVU/qOI+0Ab2bZHt+W8MF0dxNDsXlupek1C3XJIDKugy9LGAB+7+ET5phBhf8IhpvZoG4obupEKEfAkupERaNhpTufl8SVkiCWxr3UGGnItGCKuPTy0FAg2T5Not/pJ7jA1S4VKZi0j7q8GL5qYKA+ddnnT1+eV1oXhmuyhTZ+ynQWM9Lvh7WHBMcVEDvnnVW5vOgf9czb2u0qvpGAzprX41vYRInmFW+yIF0Kg7xkYH5nGKFLpVq/LjutEKiUa7bTIc7ld8ndcn0O2LZGtwt8ms2cptjwEAbl/g4/HaitPFI3LM5wJA8tmEprIfKxYo3hUszwZucoE1MIGJmBWtZChfyw9cNY9jzWGjXX8tgXqmINwe+6M3Cp0ovqtpFusA+cwMI8OYBoW0u2whiuWPDEYVSwn2O9MSnrxdTwaMhLb0eksfFo0OeDPGmGJ6wHxDRhVVC6YTuhDzwL0+e2ZY5lORhKjL6PJ4QTRy+BxQTCI5zdjrH21HuZQ6QpKGpMpF463wmFctJdbVgEixKhtfSidwrZb5i4mohcOS/UAg7fQK6yOtacLKtU200cXit4WwLYuiGV5HquG3HOPkfmzCgpDFGgLs8bdgekUjbrdYCAiF8Qg86TcSK7LSE59EgIilJqbNPFvCvkega/Evyw3PPXM+wDi0mg30k16U/+Hz4Zhv/bhRDuOUxeMlIsaOZ9RPUex92mrOQNgLLNAR9/oZLSDqAJ1ii6+K0DISRM/kMq3dcPfbMXIfHhAcNHsBaL+/CzAeckrXMPCl7ykV8TYjcmpgpXnL32KTsu0h6SGaGgDH8az+yRpgF/I6rtWg80zzcNIzCOpqg640S4PKGgm5Wrvx9tw1ZyVVnN6uSFWHJHTI2NFlMb1538+fk+uOISjPkftCUQB4NyGYaWXF9xN3R+XvEX8cd+9+/htfy0KHU7OBwUxtqBCd7DkVVqHcNeTJg5mwAHg+8n+0ry9PK9Y8g1rbnTamo8dqOkkuYr/3px83WLplnhJ98Xt+CQN7qkR8NzIXRfwJ4DT1uoEPoITOw91n8/LY1Wc8rei3XQWHuEUnur+yv5KlFY3BAF7LIUmtVhDM9A5RXueV/f6RlDqXxTpjFbz3RacrmZviTjuu1LCWA0pDPsPjxg8QsS6k/Bei1wvHHY4Y8DL006Dp+JScfPmaDvG0LkjU4SHsYnwtPCoPLNa0j5wB1uTFAJGzVy9KFubGbTD215DRY6/MxEhRYOgvrf0u0TsiDl3ZpHv35S/FylAEX0rPteQZGdjcF3dkOT4rhlkWaoAyBAW9F7KFaJj8lU/lWl3h01CEz27QB57iHN2e0HR69rROsan0KI2WnGxDY8tg2LDbfO4qOq8Mzd5PJ2mfVCqNRUqeYYnOsiBH/YkC/0tsV5r1F4O/wu/uzKqysEyLL/zei6PvnaV8ZP+V57WwHOcr4TYyk4NGcIqVaMorKVA53yYxWfyQ0lfstdJSsMD+6/Sa9D0bidbKft+5rAEqdkXGSWGnpweLkTQD1mILeQfQFCwuhjeF+m/F6yaSR9vpU84gYqfqZZlwVy0nL8ds/enK/6BaeL0o9meIgR4wz+wdtIICzdfOInVmuKBj6L25V0etEBOGba2e8tSc2jDIaiApjTz68PGHbrYTVorYAyi8SQCluQGKhFPxVjNHJ2UM7whU9EVjKhlii/Y++schkXp+TFQTAfQyzqVkcUxPU8M79ycW3xqSTsJ9AMCDsakxzQYSvvOo8FSOsj8DFCNhsi3kqE6v71N1wIt5QTgN4QLxL7SPZxDD+KHVwefhGUpW9onvW+jvgDksqX9zPKqvaUfoX5jZ+M7Ds3yFhit+Kjub4X8uj/exzRCL2XY3cjdolU/5/5USV3Ldpe0efl+/yNK77Ksnf6F6mXi4/2L+VO8DPUWtCcNTKgbGMePhZx1bmIxs1eIP6ImxYVd1mm8p69APSGRIjEMk94JjfqFNy6L5E+Q4mleJlfv17U6cifY6/jlA+MS2yXveLaddY6eZpJrW+VgiSutfKDoakx9lNml3XLcqz12UeNCEi1UOl7k9NomjPIyyIuLBftn4EgVQCdLnB1JCAFrvHRQ1B32jezwjnwMJfZqJaNdTcOLgvOeu/wNJXogPfaob1MFIJcHNGt4bGqbP23tE1e51CIBoZdirkOkTWvs7HwcLwOHP6MIkpFmUNYKYQ7Jpe8iJJ6HA6eUzdTKXRQ/G+OuwXA7BO8tItq7VPJ6nTyzkZzk7W1/2QHSaUtGjB8r/wcn515DKhwV3YQwYUcsMq0jFwD0JsNHDMXIQRvhgB5dj5WwZRE9AcmVL4wIHQy6QKfwLKWtrUKa0BBqUBsCyUwZrCjScbb6mq5UGAbrjAjgs21s+2UOS6o4jxygoABESDyJZMwpfXXbaQmVbfEsdLL6BdmS+x4UUj6p/gCEjpo4dWq4tXARmBKYzkt2XV4MT5syKtKlAhJ4W8MqaX0FbIjX3bBBJ+MG5yt14X4z6sD/14ajBF/lVx89oVnLvJwHqRZwRdTAsdJAL/G7FGG5P+m/a6xubqkCx2R17+Ivv9GYkXfeHVCgGrnLKUHY1eUmufGfCfmdyiQm4Hd+ZSDljWeLDGNuv7J4AW/Do4g7yzT5Zb62nzYmKeTCdO7x1jAQx/gQP2XbIvnPHKnAousbetp69+gCLGraDW02CjUeoOvQI0lGTMEAKxqkH0vFr1EURDIU35kFyA9LCpziC/TFDGC2VJOJP4wpIIPe93ergReKqEmu/Wh/H2QUod/PR2zI5gaelP2jL6Xd5jA4lRVPBYyASxnG6A6bBKk0MESQF83lz/bdTJm0Sjpma9Fxg5VJMtmImNovRQrojRWJtWGZ5JbkDMuL7bbQw3VQbxia7qaeh4Dg781FPHZcEeOZO9oeE1XeADoMsiCI3BhzW+MVCJntYUO/caDe1z84du8nzLnn9iD6ZIHWlCk430DxT5d69iSAGkaVKePKpJM1t8NLo4ilFIyTJ7WoHVkdUTfZEvMvMlaM4f4QZpRX4tiTbA3pFJlIHc0vJ+zfWV6lmABPME/rtDRflfrnbpzGD1cXntiGrqCNRapJN065gNwLP0a2mzspbhX9Zr9L6QoVPmWi0n9+PCTpU7KpOY3f0hxI3UW7dCexb7FW2huvRX79jvG9U8tBtgLfyqLUMEti60Y3Yn/K3L82NtawKBJUtaqdz7UpGkwmG5K8b+bzplL/gY5TorLXkjhKwg8mWqG4knBdeLcU09VweWAGCrp8lbHh9trQ5PoqMq0gr38deT4OABm9zIUNW6tU05YLRgPClLXR2OoI2U5j6dP7gjTgFwbLg3as31MnRFz4etJtn675vySS3TAqrwUwNiiid3zjjPvZ5U9jIUc+28eEkbwAWu+EsRZUdDDNGPkarV/M36oWpfxmb+iRuctfiVkyGUVPt3BMoj69OLbpAK9FxgAz2Aqna0J3X3efKrvCXyNhb7LfvffxyF9rxDrqKaF9UICUOgWWzR5EWkFgFSp8pBaaNKJ1lR1UdMQ734FhSpX8FOZP8JMdsXjq4UnvsfUzDC0rX/w3LOIybY2JQd5q8xLT77M6Fl2RDeMQUs8nR/jrf6wp328NOrSbpstbi89plVnWBgZ3Nz3xYdJg2g9wAKzuXa1dUVIOrZR/LyHBoIVetfOXRcktxtr21MUUEEaFMZbui+8irdLrqXWgRxJ0t9Me9hyQrXM614dkRoSXOHaKMAvQbY3gazC3p/Pc0WjL/SnOCB17G7rBl9uYi+1X9tWyFPv5V/I+PIZ9x8/uI3BaJThiQ07IhRKIKcSumutM4G2nn/0snJdluZB7ambY3nRKHjJP0AGeK/nqDIIMvAGw1Pt6eMUzUSyzBwFLPdKAgMD9mmyJu7/I+vVlIiJxganoUQ8+c9Q84Z70E9aSqgz1hrsu/E9JOsdRVzFMJLdxlJkUNYA5vr0HGG1l7VxpwBRGJxa+Q6jeNZiV09UVhOGH/F/6XCuGFLDIP+/7IMeoDQ/Xq1qvxd2Sjhn6KMfFEK/U14dtqj3G4CT+i36OxcxkuiwZHqAUpwHM33vdemH9uLB2x3rs7KuGag6eQimKkq5MiuZY6LwtS27e1QCpNbykpY067yJWOk11MIiuosBbExtlb0qLyr+yL1IoKFmyxj8pGWjDsd/g0ql7A0a1iQLNMrZQkxRBqAl9fSA2FU26EjU1mfee/9tPYez6bSotV60AQu/1HOeRdiYo9Km5B11z74MBEwJWVDznf/94VNg4Ip7Hf7JxXV/ZWwtbJ5uA4Cs9LAwIJe+TjLwAwo0rr27j3mcmYCWcGVZCBGOVOv5W3nK+ZCy9WzPSvdtQDC3czMer9zhAVGcTDlgr082agRKXTTIZxYWh5w0TNwwFD+2SZXVx5Chz4Y61SmdiysEIXm4sHkiQnwDGpJa/CT89hlFeZNW4L7cSg9h0qVFMOFI+E8/5Ur68Ao6SA/+3V2lhuWwWrFJpv4OX1m4veNiUjf5PuLfmHIOHrjm+uVkwcQKv53aJgitw9MwXOaBeN7rfQOUuq4wzGborKF+4iCI/IDlJY/l2qhylPQdxh/GfRy2xDbKZ27Cy3186anxM47dIXcs8jFv46MSqiCYI10UZMFdSC7cZF/d64NKmBau8yAng0EpOw9xt4EiBPWWrN2Deh90ijP1RHZwRiLMntN/3CKWXOla15lZNfwxYPjSSlwqlgHx09vkcld83tshD6Sjs50udiLNKKP9tlkKjamgdLrsZcYQS5kTo4ZP5BsNKYa7iyCfvZh9UTZoTGTjElFFIGqI2x2c25qN8j5YPDkZnS1i8MKpwtlQB+EGRG/OZAga+N+un0JPCFhjILKrO55jYlGA8O5dxvYlfdaY8HdJnaZ5HFzbf71QCGRrPVi2UsYcvvC8ghG1t6uS9ncaWKXomdfE+IkW3SwdwlLXL7CVHVWxXQjMK4ISOjoZxqKT3d2q2xoTIqc2P7NWQRvoP8Gdwy2fDymgfjYVMrBLjq57cI8uNMV5VT8gTyHC1L6oSh2PrUXRN1/YYPjAvJdZiD/7HIfmtgsqy2ZMXEWDaP1o7fpQ0In2V5CcYBU7ScVoPEulUdvLE4ZmM14opeY0PEE4DfUNLhzTiYD6s2U3MUDMM5QvwzrprkAGo03zBdr3NfnlhZmGhXiiMG1zJ0jbFXFMpfXxBWCntUZ6nW1elzcX93xxJki4CzV47CstuVv37+0LAbOr9m7YpvCa2mMpvleX8A+5m6U9/JWPgZoPN5PPQIwvgr6sXMcCGN39aaTSTz+2qyyS3WnaSoHuubL/Z1uDSXZp/q/F+N4x9vhEYzBBCfMRNYBVgoZq80yQq6YsgGjHVLrHIxW8U82i7VabceFObVAzBdl9qr5i2MRg2b2KiTE90tlj0f5AdbdQ+dlBrtOWT+z72pFIl/f2bdR9ehogwMFj9KjRqvw7egz89s4NseThDUOhTyHfqK4oFBPyWW6HEv4kDJBjUy/yQv0NX0xbzPVAv6WqU6uFdljMAQbhtaPxLP07qgRra2m2jGyiDzHc2UYv2/w1K5XEQ1qoSITbbBjCNL0PEv71gzB0IzbsQQMA/I1RGpKz+jsJvhFnmFduoFpiIeKgfZLFAjhIanxXKx36nrevjzdqJ2PSS58v0uLUc4C5k/4wUx9bldNoORgmVTfPM/nExHiSp5JfmXJXPoGM5kmISeu8XIteXyTOEUDxb4oEzAEek/METO9ZgzPFwJmeV8iE3GdQrWpVgNrD3Rjzi6919QVI0W2DKuddvWOW6e9/iH8KVDEG3om3oZWu3Q2sGXcxrIjh8RWf63hxZjYd2Nts6PvMidG2os/Hx/LVz0voPgN+RDKBi7AuHB5jGpB8bGqfN3907YM4unqgR/qnh5WxkrMd/RW3JQuXjmfvk7LkQsZD4yAYKZcpZAvJAgTW/KlHQJyGF1oyu8lHdWd8Lr3z1RRX6IqkpJPagl1t5IlLrQ1tSv8gS+jUGFHz0HtT8gWUa9hPd1uvdYLKTvDj8G4mHhPucOgUmwFEhN6OO9eb6OASjpYORWJYXkyrt5/t/QUKccEJqIjBWQ7YMn/asDogSXr5L9JAQIm+2TNDA3yZZSg33QpkXvIkflMMdPDoZb1Ke7R0Py4TYhXQXmGBLjhNSBOUFUrFU1buQOLjXdaHlpRGayZ7Q4xq3kmu9/qQzROS+5/gd4DyEwb5LOPiV7HERCj8U5ZW24GFiNnxHdMLzVOY37UWs/0wDGYrJ8YC1Cd17DrpaP5seyf/wrJiY9ymwX3rq20nTQMux7qZQc6qdhLl5BEBS/c/pzlOEffjRhQv04pMPYWVdFSlkUYxG9qe1ptBziHxHNI0sXPrQrLxdyQrBU0B0l9xVdrPx7GMexNVbl6ySzu0C6Sv79lRyNjqdvAqSk7JaDKE/pRa2NEYFJDbmFtAf2dzScJScU9mnHQw/zE02ptvOeV0FjcE/eXaOTpTu1sMb04sDst7PhHhpPeODa1jqTC5nGzLDad8N4b+MYWJyNtFzeiCY7goFpbVoLczJO2/mj4M8mdA0iqF+16hSWEv9IulpTt6BZmx4C1g48U+K4uDvcV4GaZ1e+BDbOZ1l7PZ5UbxBjd5Awt7EsvB3wBERvCIEAwpR2iActZ1UvOgC895Ot+Up2jEztZtn04YkLpYE5o2QAKRGti1oFjK7E0H5l1+Y+/hbPV3ssW7PGFoA0ZiGP+mjMiAUfcgif55OvQaIKWyibf8Vdp4XQ0bmy+UHLFg6c0fOXbX7EGXKrFiMYKwil0FoJI1M3KiEKwqqSmomi04OIiGv/JlBNcho0owlxz0mcf3pMEFw8a+v0wVVatjeA0kFXsbxQSMpZVOaAgAG1BQUmCiUXNU5mZW4wqcJ4Oo4psrNo5fdoAYy5O9SuxhLwphg3FlexHoroKf1O4MUIeerI0O1v5fSqvSFlEwAK+UzXf9HyAOtofh7OzKXPrJxqULI+RQ+PQaNmORe8iz8RqeqQC1miBJLW5j4vLPhpKo+98xL48vpziTpIcBnlFo08VACwSLKH9g24p0ZGOG3NPonc/wWMOkxjJPmydgV7e3B+V81FaUYe/MfmblCGnzCrJtFh4sibmL4u0P4dJVks2ZB8ceNGsJ16EANCG28uLs5dT+67I60mG4axxaobKB1yR0cnpyYyA4WtLSGnpCw5I7y+eeEhP09nAtgVlG22WiRcfYtK62nsuH4mNh1BQvH5QEYjvdn+SvfZLQZwC567eh0lFhzFocy5yUhIZ6VJWLjKGZp+jxo1V4zHVau/zMInN9TRcf0N61u0IeyxYyUIsITLND/f2c/RAbszxKMX0T7TETQgPAsBqfF/ohGU6e7y6LXP494FIF867dPikrF1IxkQ44vl5XWvn5YpIpf8uhQNACMmaQeZZG0dWvVF0vZg3ZIXzMBvFiqeI6sZquSgaaKwqf5DoE8tBD2nNG8OEvqCpFhNxSQ4wR3A3Tl99cDsWYoWSJbOjNLrFsmtC//i+a300iXsEO5Yhb2rzD2UAtlhoghirwecyh6F7ZTlCoWFfTFBDn1eMlnwWgrvyvSWNy1jXMlQrBiErx2PBDeSeVGACtbg3BuJAvrEPDGg62fQCBQ+8dJaiXTTCpbNummhwUDZVVozbWkWKB1n43kRdEHYHLV93BxJ4LRX5k11xY9j+kEmazKagHwTbqs+j3vQV+/DU5Vyo5fx5sMuS5ucnOCFJMesvsnSgvqVHwENpYJLtPAvZIqslQCSqDP811pnqzJQxJc7CgA+CpSmmzrDMhilcs09QKbeOtbFmBAu2B/3FVXXUe9vBH64HurFWnM5m+F8SMUZPwPrD/4CDOZy5kQDdw2ltrmvEzawrY32rkyfI62xyzYdPgFvPljgaOVTmr0lfVpWU8dySrHptcrDJsrJZRmhfFTji+aFy0USh/T3vIc17jckqB94Ho+GaAkPxbnUdaZbwNy0MUMY9WY5crR7mkF3w+i+6g9l41jVUpTGik2uErgB64X1TQTLsPGY+LGdAwIr9q/2N0CDL0aWoNOGaHZHA++8dq44/OCkbJYq7DP2TJXOmbEccefCj6XSzX+Nmie7EgJBoBTyI16bw6bgqr9mOvNWSER5ouzuWUgBlLNjTsnioRwu5o7eVZPOtJttxAyUajEhwPNLolSqtB9f6KogZcofo4DlsX5m/yTyPt5yLp3/rV5IDePY9ata52gTlIZU4pCPqfYS4h94nBG6jPwB0Qoi+5CWYhM2QykwxbZlKe2copngxSqh1f52/mqycbwYOyEQAG120TEXsELB7qefco7GflLwsHNy2wVIx3buMXzKbFlCo8Jig1G/c9E5YYarkm5RDDNc1TtZP7C+1bkQOVME10pBKQNWdPnA5mwRvB5hc7TnzUH0c+CqCxYu9t2Fm0gsJUJbctfubuaY7a9rBPvF/v6UCz7k3gZ8xe3qLT69hxn3wTwfl8i1JxnUjIE6TK0nwNXg2Yk2XPTuMogyjwCxLh9Whfx7Rg+PvaiGbgbVctV69TwfS5v1Y7J5O8f7perHIWAAm5ir7QNislyoKYfXDm5fucC4BtMTbxHxVE5dkHhMOxWo85cJk8Y9NeUtymUmxwIIRjdKw4ua24hGQNvZjh41Ailpj1B/vrfZe24J1PTqrGHMC/JbIAtJmElLq1HEMcOSpRumwxBjlQMGhjW9v1EX8npmwB/7wyo7dWZ0hJRtaFPv8MGEuYXvT9MGJQfpTAU/l5ElmBlGPJqwgAx9ZRSBjkjXaEQKeO41UQQ/7J5+Iz6TAcjlRnTpVk2WwQwaz9S6U52eCIgfzT9oktx8kZ6CztWDAU1glRowD4pjrjRYQbYPKxVanU4pHFatlpc7q/6VPbV2qJIhlkLEWPHCK1Bj6qM5gF1D9wPPHJ9XWJrNRwIhT86NUiyMhFlnRsehTZy4nIoLHE1AsvC3/y34MYBtOGrfDFaMKxj271Tpr0twOajUyFVhQ5inIEQnKJ3Hl+MUfIH9KnZHcvvdXcN+8dGWCu4kuJhJsoJ2VPsMtin9+mQMHqhPHBKNKggueHuERHPt3wRui+tfGRkQuz/Eo0HtU+3vFPKqWvhMyitkaG01lsLFOg4fDuqwTr6q5ZiVam0cJ9hxQ28fap+A56Fp8uJJO2m0xL+p0MZcLiaGyBqlGfreC5iOX/I+i/ZFXqiOktfTutCldFEzfty5CXaRzukfJaNJBYo92pbn1aeUM+QRIY515tMK9ZZzLLEm1ZQHQOEM4FYYCJkCzin21DUt4tGn8aUPQho/LH4UykHexTz4B0S8phFkFz8hxeobRbcXfhY7yLz+gUaEwDh0gO9Dfegyfo5rv+ZSkxjGqq5QciZDUvHPda2HN131GpgRWC7GzMGWsT0xjH2ZgUUvPOlZ9tVGOMfZVP71kD1ShxhDnBBC7mleo2orZOD0QTmIYvQt0RkQQpOnBLlJrD82SZdK4qqukGeBdzZWeN+/8quAsd9dmFskPj2g1V/kYDGVhhMbeGx0Too3f56adka5DV8uynIiqZT4AoF/3r5GyT5tmYpcfSVuVW+Q4eH3JpD91dd7OnxOaNCb5AU+Yoa10U0kP0/CK951hY5B80TtVZ8oPvcJvlBMXi7PUaJv9BPJwl3idykBUtKQdkf1pFO4Ceo1p1aEkMHtedOaeJ3yv0DLfjHmHl2ThztWHmNVj84LMunOMcCXN8kR3OVCGGKT6GAb+hBfwvwWjonyiyuIU4ruEuyiOyPfK5kHXfi+t4jWScktHAjTImhDifsSNwU17reOe7yEIthDgvD43WyBkmuQtjhSOs1T3nFTi+7ibJboVUUlR4JOWppsQHA877j50ZicUcG3/8JpwD/gD21qnoUcGICMZh3miivcfdtVZX3Z6i9tP4uDpH7nZr7FjWjeyxfLtR1KfyYkgV2tNJarsUh+tTBpUcTFxwVwV88hSyXRtbYcdHAB0NQRyttgmt0O6gUG86s/YKj30qQ60cfT8YiME78TaX31EdlKjVt/nyIpzoQNTA+CC8qzoj4gK9sEBNSXhkITAGTjbqD07/33PbBDuJTUvY3Egno2x6+acvjWlGf52qvmnrp3Y2rlBhsuokX4tl9B0TtN54bpjDuenUeyALtpwFpOUSrnG+PWHi6jp9JcsUDYAHTb8nQl/JfHpk2iWVuO6V/Ksg2t8wYIv7PQyT/mHWBkD1POxOIJu2G1rCHD5Qk59uZVgqclGsbkJenlVkpK/yQPB7UbGF9x9t9Kt8fX2fvoat25A6vy54elkgwunSJqjniVq/MewiqUfGxItPxbEhxp7fPB8cAnTT7AR4RdD5/1HzvMgZO96mtB7xAsfcmY9utJEGTk0I4p/x680YKcMyb8xGUa6HzHThlaDCs5QhOIbic4b5ebRFK87DFBBUJsQ+0pAHtB1U+8iIPdsyU/9jZM7/d6pCXMCKgAwtO8kOG466qxxPgp/12pxsZGcwIk1yWb3hzVdo/ly6NU8btOtlF3krH6ANjsSm3uyt7LtyjgWyYLAHbj8ckiVSQlTFzjbx71pLjxLCUDBR72wMhFf9uO43593TCW+anQFrzhLTgmWtAvg/aW1qMZnvD3LGmYMnRERKENJdWsWNgTsMd5MrZD1ySChXfBrLx9ebgbKmFZk78p2Bqazecvr6IUwHnsrZrftrnHCjvKGP/L1gXFtLeqrJUWbfycQuetXmJmys3D8OwKs7vfCJmBRWTogJWbb6quzsLeI3ji2OlV+w5AMJmeA1jJFrmkRMujQheKckj62KHRYUt1MwU1jjAs68ICPIDtBCdBDePM/ZAxJj0FGiC4U18ffVO77bemaXVu1DsTH3pKph/AXE3AoSeEF8tOjDgnoipr5CaRwzc9MVkZeL3Yu+xsA90OM2PnWvjWv7ec7ZzmI+0rPWIDFYHeVX3DgeKFZxYVUP6wYsVN6mn0Cy/EYaxoSMnsENce437J4geN4DGOuBoA50rZ62ggNIBaWWEj2uPI3TCv+cts+ip7i5TtBQJhtAyv+64uEjgXX2K05XvnZOYEQtdSalVsiIlT4iHeJVZT5yL3PIvloOhYRUpRnoPwhdmM2Y4xxQGRuOGrNEhaUJBacYghE875ty125hzYiUDECx3HrbcxnWJmSEUilF0WyAAxuC5aN2+v9vg2TloKNmtkSXvzhaDWEF5RbgAEdaCgyFA7hZiUT+dgidjmNCtb9STy8oQJudGvenGLvTrhDdr4srwlBVG2Hrz6bJpf7ye1dTnQNUMfciyfxrTWVKwhSw5k1LhsjmQeC+/dUVUgeEAn19peqPS9vzEx4qHR1gnKdeT09s4q/ZxNgg533QZkhsaYGVbBRCg+UVoTBUKhaIAJWsaiBOeghWPq3ckwDjOmsVnvGHAtlwQpmCON0Qih3JuK8o+wa3lksjIHdntXbJ8gWSeu3Y5aF4bWNX5gscB6BS6q/srUZoilnyncwf+QjBpwcm2HIp3tWJ4AQNdPdxgZZijMtFq1A17fS8w8eHxcinUK4ic9LSl1C0EVzJ9Of5YBGbKVlLenlail34zvZlJr6Dnw+FFRzOiYLlLKKI/y4buCc113rmEM8mz4KfyEr05iP+jwHFT2gOj5n73hYFWDBU3JwsU33M8OFlS5Th5u/PO4JIgGW+Rl+N6Bt9zQyDNwYR8Jvje1sKg0M+6Qe0CHMLU2X0w2YNSRKgRh+P1jKmfzU8beuWLmYN8g8gLjtn9pee03AxVldpaKMf14lfVcG8vnbEKoNT9DlfUw5Ppl7969nhY3ujLUlWSQD3nYcIDVsuXcUm2Xrxdmd7ww+rS+gdlukYSysJv3WJDLzsAmfOAL6rdIQRGcaQoajPnhV7Hr3Ip2+ye11bt5KTN53eyNKHt5ZHXwMKkS1qxZRBI32qWqIRZtqsJ8x+NbWZBlANI/Ue7IJ+8toEzHuChBkNF0QynKGU9cEzmxG/8oMn4W03m7gu1WpoIBt+MD9dE37UrLydk4uKaQkzr+3CrNktHJkpVDcRQtiq3TX/nEW6+3k8UEF+foG3ReMtfBLxkx59Q3ITFvKrINmmXPkg3yKhAVTRvlXblBOeShNoNx2TxmraaqGYCE7dXe+XvSzAUEfBjqmz1C5W5blyN05Hc+pS2C10aZjGPr+sXyFyUtMzjGBvkEsNihkumm3pzDMUhlUbKMaUtcFvjivex5aKWKrB5L8Q2IHs+sTfDZjIK5k11z/tbpxAlaxMxW2pNtcOC/EO61m8t4k2WfwHANWneLUEtctNQSwRFCIK+rPKA82/OjMqm0CWnsSA9ErH3B66lV5jktOT7bSU0nop7h0gIJE5EaJr3J/2LPJrId7l1J83+Kci0tfKgcN3LCtXL4gEQ/DkjsV+bOA65bwicz3jZpyJXWFbrpnlF6pNTxx6txnqdk/inDMQLrmCE5PW5FUIE6xlTIh6FrLnjE8q8uefLaOyaCxdPKyNra8ZfE0k46h62VQOD848y+qxuOZsG/jHH36A8rYKcVkPVhMItxMHlTWvGJD3RBcZNOdFmktFo4YR7ZJlImzxC1Vy6lW2vPwttL+fjmNOPBAofc41u82RI0U+hKPFvhE245Ar9+h83x7C3KuW2/pEDPZOtPeg2ez286aYIbV9gtlhFeM8xboy9KpROGxQMybjZUyBTMKxiMhaX9o894ExZTZ4rKwS9dNj8vTlJANRRp9R9Q7YkIbJVeYRYNRXaXngSLBpuAHooc3y5+l3R6bMqKB2OfWvzsDtIe9K+DJMfSDY6Ntxoze2fkUx4VR2/GB10wqGtrRAeVRyvE+mAKMJb1GXcWRg5aBQzLPh2WislGI8l4rLHMiaG8Rj7eAlFVZR+Ug3DOgTKzwmUo+3+wfCa+LuSYn1limpzbNvO/bFx6b8l3qBUE7X2S80HECcEqYUhCLEz99vb4tA3njB3h32ijURWdg61KHTncGhyAWBPsTq8ObAWJwy/5H/2a427n4hzpk64EoaXaJoC1WuZENRRrV/PrCGy3vZUe8CkGBdeeUH/hDuZ+fBlF68Tizq87hjjWflYeMSDbTGvelmDXGK/96J8i3QJJVjQHjKJGg+081IBXdL3nzglJBVBYPJ6GYgJVwWMvpQEKBeU4KA3oFpAyTZXKAn6GFsnHsLJWmYXfcMqSwWShM8UgWxARYnzdkfFT3i+2lJH7pjmcZGucMuD3u1h4GXfDh1ONVrpnBcnHHvVCgtm4GJNL0Ph43/VwKftDFlvbEh4xPy2d+hR6KFuUUOteAR0KkAihRpREQa6E5OC0OMwIUM/29ppwiLAO290XYWCyAKQbqOHc+aHR3bwbbLr1F2D/B7NwIT0RBlYeu0yg/tsz71YmAyEY+vpJguFO+1tVNKcBKecwjTNv38ufQsAavC4HNKwvlW7qJGdDZeG9ez6A0o8GujL55QSqknsi3tB5IvnGpuZm9fJKb2miTuI53sovgMVFDtiixWDIPdqpfu6Mg2ATGSRhJxMsONPlXKmThNuXskFOJeQHTrxqjCm9TsWwCHtdzt30cPSt89zxbBc0BogHUp0L+Nq8GY2WkkqbvDBqPZBCkOlmVkk0VC1AoiRwLZmf7sQ4uUIxY7VYUjiIi3xSjtRPNft5yo/136Pig4MdngSyO25zCaOA1akf5WK2Zeino4wMqr/McTrQ4RaaMhIAYS8hGoYt9NpDJNpp8Nxw04CEjT/ijkSt4yhU5CyioygOR1FKGEySdin/L/U/XvjAyB4wij+1wXGtKQ2dtgHu0RnjswufqHhpdR2hdWhb7JEpXrRTfx8llSyTRoVYFAvYFhr42n6e5m/AvsEKi7cuoaJ22DUo/FQl0kkJujz6DQgR1ZOB3VdDmhQmrH8TCAUyUhiZaOqbaM+bbIXEBj//zpAl3jspUdz66HIPS1WrVtuMOBKRZ+Y6enPUgt0H9ygcxAZJe3lidoKY4wNCg2EuqUjPKNkOEngxrt1d00r6e6AjM8iRL3oPg0Z0N0cfIazUIAixBi3An4avBQazsv9KDtFmxBOBXZr4vqYJBIJSm5oCJEXke2K2XhYr6mNvnINpERRnU7ET18iloPnEAo52dmebVQOaY3q8fxp2sd/xsUmh6sTS5wx95FuXw05UzMuBMzUZ+j5YuQRHjyySrEdBDZh3ImJZGGp4XbgP6qp4VtXE+XTE8NZwB4SMduD626NWSc0NnQsW0JgSClHsYojH1bxBtRhBC70ttzxAcS6Npj5/zh8YGpFnwWOc0OvbitjVfMhhUCHWdt0wH08ulKJX0wg+h6Pk2LHOGbUqEHq+UuUD00g+mZdO7VRadZgdgLsYjzqTS218qep188broSIJGCN81foJB3DmBI9D5myUCUVcUQbLj/u0uyeihncsv9UGXzpfc/tuZrhqrXQJExuYtWcUnySSLkQ4vNjd978v/LsJKTMGdZuhEk57bNPw2rr8xXQIRyG2wCZLdkC3AfvJ5gISCT7BQnwhaNz4vOW0RugXmT/SJLLNhlD6uCu/tWas7C8heLXNl4qvMQe2t7i+0BlhGgDE7yW09byTaWN653m6myUOKQdUmov8DaJ7UCiW/Qr3JdVFwS1I34MvYP/mcT3t/RVxIbRA2vwtT59UVHIFW7i6VsamSxdqfxjbIJ0YzdayYswZdBNX2ddm7r12Lv7w5fh2hY2Ni56S9bIR696wpu5FH3FjzdQIX88nJ8tdZYz43cAPmqDHqmdTTkBmAnA/G+qNMkYhMyv2/vbO5k7ronN/mGRNCAvbhTc6mC3vhNSObubtZ2XPzSLM/DNRrqkI8srpK8Fo5O4avDF1mpTP3yR7wRZUgssL9w7jFfGIg4gxUbmBtWpmPdTGCz6pS5dbmyDorBqtCXLK7xOM7gKoZIpIQ3a7oIGYIQr407pdmXl7C5pkAqkQ7Hm/O6tDBO77k1JR6Qb/UnMHck9gHQCnZd8IDdEmTYcYiIP2lq/eytTqytI94J/Q6/zxFEXU5kR1X4PI9/clNgZLxyRFQYXU/EV/fA3DE4DqY9+hKv8DUWGZaiMe8+qgMCCldWC9I1TKKuCyBAwfHO0MyRymfo5/PL6kLTzmmWFP4K76jHFFyikC4cl5rEY8wS63HxsyiNoqj9478fKM5nyHl5h7TJeXkb8b1AF3xpzMbzhfmgmgPH5YT4W2T+jxXlhGM447+Ip3O8jcbiwW5s4QyRemyqlo98ut7Vn1UeLSriSB74MLkw25Pv9xyb+3mGc8qOMyeBCvLz03sPkYrczrfSeycoRkfCsX8bgmDK0YhQCZQfndPsF6CPra2uA7gtvfoGXfR3EuvcoWcWn2EyE7rxX2bKtKyrVSq9RgIBHNLWB1IAMUAgYxvGLisx+d4/A6qcTNzj8uk6IS/tHcnNfbNbxEETM2VKsWobr1E/h/tVTP/o+jx+MKLSq6eXyVIWUa5xGkakqBo4RMC6n4d4lFQW4IfQ7PXTdPL36C0eEMrrisKM6bjhc82gA5qxAcfDE4ubyC8OmhgNv1ZwmY9M56s2i3FWEzZSLBcjgOZ8Uq9ZtXppZYYcHIi0wDFntrsZmB2tGMdY5/ALob7X4hyBEppiBZ8eiXywuPLLgzRvGA43GI30YDpIG0qPPv9c4hVtqkw5XbF3jN7N7ue4/YQeb6Bh5lO1/UuFgRlQjcXam5FP/ekvH7TYxtEcxmPweiZlP+VurGP2SJevzC/chuze2WVVGkYIXKZT37ymQhw6zXpHZbvw45dFkNBXJ/MJ3JJwHFRKVBw1o8/Ux36LqjIOpvTWea7cbzE+kSh0T0PatHohptVU6X2rzRFrQswmA0BMgKdLUX2P7W9PvDevdARkkorsKvfIt+xphOTZFFUWu6R0MJpoVY0psDz15XE/yV7KxMJd27PoTSglrVBQM7GM3lugVd0Wd6smKTrdFSMsIRH4UXrRYrYaqb56XRbesA9x7X8m0pWGzDZ4cv57+PESLYzkJQk7/W02EWRddz0rSLAi26V/ROUVYTmDVIrsk1/mbJ8iL1h24jyFf5IRt0Z/1/tkGo5Fvw+B6P7pryH1NAYSpIHggZxWCP9V3rbrkqzay2ENn4H8MMjUTUQPwoCdA2Vx9plb5ZV3v8ngY4XEU2nHwEt2FBNlM4BwDEPz8Gc6zPVr7ZXBUojH1BOyjGSGZa1DwDQJyeCZPLbXQ9LNSwsTrIAn8JM81Z0OKG0W3KUraWIdlB1HFdhiutnn4W8VrBeNfwP7LoG6O7qluYOu8t3FItQ3dayw45npWU259tOUhFKKGUvoszucdK/27QY7rcDtTiNQSeSTSCEyY2hpL08OM9uP0oDG91IRCoxcyLlD0iBPp3aBi3tQLjh7YcueSeGHwK2ucLgYgY3PE6ucvDzLyjoRXyLOeXiUzFeXxlI2uZQv0SoYRvJm6xOHhrZy3mCKo5tWfSOtTBAJc9CdD8T8jxRwwBajpIOhHgPRw3O90vEvCc+ay19nRz+jcFl1yyR6A/DtqwLXXvJ/B6mJc5uu99ZDXWqoGggNKtGy0O7KBBAiOWOX0yQ1b6rZATMnh4jUHD0LCovHkDV/s2/VenD27pRMCTx5US44cFqE3npBbTEJ8sPDlXyAZUfLpdBrUOFKu2naRwyv/dk9X9bGf0WZcleObD/qsYuL+ZEKpyNTiUKSmYZEzgpEjIZxz0YzQeqzGTIdVCYF3+Adv/jbTpbmoC8XuY6ZifzKk5tY2u0f727lJ8go38OxcMzMWEm5/+ZRTuW2s/8FoAsJOHi84o8Dc+WPk531wjUaCrXL5sIxIdRtOcWBwc6brC9ANyokLQ9pT/UsKY00E04c3fj31HN+4xlvONbljeMaTQ+vvuJ0RNZWKWaMXVriHszPy5xp398aReHU8ljGTVuhVxJ2mFiqYb7ENKoE3txq+C13rzc9snhVq8keiLs6nkGYfixqDhHflJ1e9EGpSgn3kmdQkIQ9YmwZy8blbfCR3GjePfJExZLTHtDqvHYVhPrpwki7PsvxOZ3v3vcPlYTvZe65ONSEMYrT+ogfMdesf1I/x+pZpu767Vcz7GlMxODQ8uDvvonpmo6iGljnuVdImC31YNkaUlbV3FffaHof/K0+4HK3fyH7wsQdDhCkewZvNqstsjKytiuWpR1KYSSM3o4hkVVPcjO9NsVFoPMug5S2/fAovGCUjSqJrFoysrktyjiCTC66re0KdacdAsbZ04OzU8cosJUlThCMdPjugM7WuboGNER72Bj/xq1vcluQ3blH7Jxu1KoBqFPYnMtnpSp/5KJ20wTC4GA6+faq/8gwA1JABG+MCyny2khweQNGhwoekUGNf6XDwuO9zCSZFq6dqUeQF9VhcoslAm2U5INTaIf8Yvne1w6LzbbRS+OncF1Shgqbz/PC9hxswazrByRHZ2ciQjH168Kt87eLHFzn6ShXqiYYo7H8DHPzMeiIkbGDpWRV6kcLnfnMTAXOBRvwRER2Uj7RXtZizriib5CAoE13RdNODKp/PHn+Tt2dSZygniXIp4LHXqkPMnybN05rFAbYwlU23w3L3tFVDU6d9svlb7ntEHjjpPqEPbVyXKQ45FnA5FHSsuQDhigdCo5XZeOJiF/pGUeETtpXNricx84jznIJOccmIVtX++WKBbzpu+jjolnsanPMAigBdDZH5nvz2NJSJztmdvuGBMcoLSt9ptlJUVhX69On8LN4gVENvzVHMVynYL58ls+yNlSVbExQ6dnWhHf19hMl1SzFEFaM54CsX8Oy647wdF4D0qXPwwTMwJTyPqt7XL9Yj8ptuq43wiPDp92kUVvE1fvQdBfXLxZVZ1rlZyba0/hiO9qtOIwlWsSMmHzZKvwAk3ADW5WgnVw9KREWYe6U+gy2T9Y1Y7+4wi/JTkc5mBV6RukreYiOaxCFxvdULJf4m1FYB4hoSeouKEwD1ryQlJpw8XesNhScqcBQ9lnGaSajmj46RQbbDfuE4Z2AEt3Nd1wHJ07qOVyifO7f3lKev8X5t8wBVuGJ8zTdbnePD3Fc60m6NLg6AUVZ+2Nxf08u4JpjtB1TGGzu7q/3DJKbOI8TfjpP0vG5HjuarTgrB2a0sbZXGXzNdcllq7sXSYhJEnxvj+R+TCgHpiMAF2gA16qAWPWxmglfWEIn37YgvWAVEbhWRzGuq6byHxGrSd6f4YKsnoZcdJ01Cfi5ktc8qj3qyp2ZqncE+gfptIfM0cqxgEyfQfAu5Z+AVA3fr4MxCQoPDslBhvGEhZXVswE1YKMHCnhJl4T2JjuLO92rlHbXI4DBURrSMNMRPeWQv0VQx4rRyH+gWCZQNSxPkW82ZSuiyyOV5ovz2q6NGhnj8aLAiso4RuNkXMh2Ephle0wOwm+sSmTVQPRkNTPswhK5OjjlcpDR+8h12nMhdR5nledDffh3L/eLPb7+Wu2xvxWZU6CtuaC0jIkNyL8r+IzZITFK7hRSbfih7GHSXzMMDg7qkO9AzwQj/dKZ+SDoTjHgQy3WZ9sMSfKRdztufy7Ylwr4EK6RIK4tTcOjhA6tsivKmXSi0c5Di3jvqMzi7hVmqb/gwYzAhhMabQXZb+hFZRKpoKbKa68T73sB0lNrXWGI7dBYF0ajy8Cc0zDmvvFQakG2J3HhGbyez0YiluqPHb+rmQeHz21wdnJbFbPK0MvX8XrZ04A5TumbSpvlaNtXoyKLEzaoC/Yhn/TfQ2RE/IlP8hgyAGePtjiQ97N86eHkzGWurXuE9YwJYaCYbXQCBReqf6HQqGNhIQF5ba+8OXZtk1rNAbCfCQ49tn3WJSjlywIjJahHweOZe6BRrwrFaa5iaScqmCKH/KPduNpxXrkiu0p9f6Xa8eDhgF3+MWEp/RfAdvdQ4ww2B5dqjhjcRnCR+xHLlVJ7Cuqge/+sOwl9JmsE9OaWec4f9diUtEF8KzU5LF/eOburO1Qd0x4EEHAB8XgdHMg5u8XpSd35I1HEci4lNn3KslbgLky8pVqqGNPResZ8/ioMA8qFeMgFaR7Lixzi6U3itlWLnVHQQadgZ8yfuMUJOfqsyYo1l5g3c+2ukvn7+2FWI0vhYjqeEo72/J+8U/cdoMh0ijm4wRkynROo3qDUOSBtyg/pteO+o+bkFqYiReiYmIzSVY6SQoN/RJXHVMsst1cgK16Dum2+4YTHXgbIqUp9Tqke34aDzNVAcETgi+mE9yx6HcBjQeQ7usmM4hOkZv12SUm2lUaYCv2PbsRl4ZMYsowyfeE3iSyMehPv51HNoLmkvtEs266AGKydVK1PMuTr7FJwGp1PwMamh2/vQBAOZ7aZjPY85Gy66BSGsMqSqIIbqqfdHGU8332GsPo7QTMrAL8GYaERiWigPF9d+QrvpwcgvB4amZ1SvCEMFoeGhZ6PZEHWJv2aMkJKyr4ZAeg2rTIdZcBI8CGtX7zXLM9emoZ/zbcUKogAu0AfjuZvk8aY25j6+5WUJcEmn35tfD9QYDM47gqw3hKNYfhPr166kVIeJcbnvi06uRRJIAHC6UdcIorWG/oRTcm6pPzQQM8BxggJYsq83PzBF1aekte/JcJ+oVhu4KgBGRdBOJ3wCAXkHymUGOnl3dmRls5OPCR9Izm/a5tuRQdJbksh/yOPMtFMqQ1kzmarADP2K6cgirk+Tb86kxVAG7M/iXRaBDQGGYphsn6yb1t8cKqvGyNmfzSm6lrMuktLgNXE1KvBJPN77uDSaLEk0WucntarDNU80b0D2OlGRVBxt9Oarqy2aBrESOXj16Dsk5344hEyR4X3RkYyH65d55zbCZ0l/nVWVYJA3tV0RwYQmZBc6x6nLdoinymQYhx4/KI6A3mr5zvVZLJO9MjEnYiaGBuBX/effHxNbbtE8vZQerQP0S2Mc4wFR+WsxDESFePjgQhG8FJzcYbm9w+SZp0ZnnC4OEv26BSklhAmEdj9U73oppqM3YYx4bSrCcmAZfandxAhJ1c0e9I9pZdUDANU8GdTtluTEvT3t2C4DD+aw8WX2DJAB/ssvD6P/gTtTkIzDU6gm1TEpyIpE7D4EEMgmJasBe3XuxHrNBmLElPTejYOnkuni8MRMpazl52alz4pL+T4XND3Br6mURLs6Eo9DNWRBCw472zPPIWGvFjcWDs4IBX9z8MbPj4/Vry+g/075FFFSnSyFQvcJ7I6/i4A3UOiF5e+5PwB6rcynNj9leOgaOlUNMLbGju+xkAKKLBvInQ/71sYmrxWVnvLyq+kRNopsU9Lns1qSlc5Vs0KfK7TPcLj03bJmW2VawJq8fiyg4KeyPpE/2nygPjQmxTJp3JQ9r79dW5laDYbrDuJhpY7lZ1oQYiKYx9xntnIhb+KRSlJH39ZMGVPpJQZo6pribBpOHbOaxz28pKuvuYB9ksqFP9PG5IMlNLEeSAmZH1Ytcq+e8WJhwyGoZW45Cl6Qr6u8u3K1Dbun1QOE63dUcbhdHt/DlNMyp2MnQ39R/W/A9y4P8tRLfKpiBBJtXFlhKzumPZZK2Mf5Z8HtZ9MSCjOYh7R6UOjJJgWNtWfqSri0j5eGNux+npnEHAEAkRC5VrUJF7xUM0P7dv8F6zU1hKk4RpWEdBJMQxyA3oL7GOtJ9+poOaIPUFSRGoHgEo5gtRQXAp66yhblGaZw+nqP7mGjW8wf69hRkThU1xE9m631CsB4f/2OSGnK50aCvUK8kTfJzC0J+UrTm9Gu2vIR2S+W1OpETX44qCbjcwMhjpEDLpZv2QA27Z02N2IdK8+UZ++C10DEXXfJz9vQmxf6a9TzxXNWDaRuL1aYVT9PqDeza83qj/Mdyaec4bnf4hyaVBL4w2uwue/5vwMiA524X/27I6AWvbLYyP7nOBD48lVWnYB2DWefUNDd7bGOTVMbmg7CBjqjua/+Tmzu4KfYjy7GczQbUNYtODayUtWAiFh2Plg6kjKXQElgOni1tCR+4olT+qLcejqZeyOM/aQdsMEr93xU+5J5l3JPHOzBk0kJ9oqnP97cmAaDF6tx3S8+nhJzJ1lx4FsoYVsGKb/RAxoE6hSXJn5b8LRHYoSQCmqKXhAzfwQCzwgRaoNeeFQ26FE/4rj2a3yC9TQQBVNUXbbxdvGzkUU4yC6GqzdWevaMwY79W00gqdgpi9kR367NLwiHSqLZYqOQc2ArnULYMDzq3Ofa4D7it8KSW9+UnBkdV1Lv2qAomGdFqcwKY+wBQsNMN5mzB4lENTkYF516j6RQGyQNDYgyt8Wf9QQkO1Gs0IAfFmS5fJkhmWBcsOgrIGbI+B1We5nn2Ofh8sSVl2oiAusIhAtaQ0oo75SlWNXp4z4wdRMoewzqAOD7Pa5VjPBf741s/xp7y9ch12HvdQfmG94jQmOwN2ije4cKVADon+pPFEaHAQs2ejsp7BkAjuhwBL1tP5Sr+UkkDlt1W2p58IZqlHG/Ze/GM1jujp+p0HkshX//cot4InpDMQQ+rMkpWOp60GbUAMDqPNoYAAAi9JnRAERarF76VQK8NqF5WlJo76mZv+9T8MiA6W251DcbjNrNel2FvdBCNrOcFHyFCzCwcPsi6gECgXus97tdrzRN3F4+OlItuFhnLr/qGOYoUofDP5fUN3YFj2C2uVRvZilehFEekpbnlub0Oz6bI8Xs5YohfXJ6tq8XmbWko9f49W82ScR9DWhuiGdkTD2iZTeK6Y6Gqle3lKKVjvWy0uJUmKYQ69xOpTq5/RFjNq3v3l7cPKj+dxKDpv7JIcnwzfzycVCBQAxPafIKmsg3zckq+3DIFEMVeEm6b2LUdnUS8eU8i2ZJ04jXcx2fT/XowZvMsiuNTYYr/yBaYwkBXYNJiTwoZj3TXFZcTSkAMfPAIfc98k5vk9LKlS9DsYQj4xmOwordoNmsdIj2p8zRwg54VsVUQQhtAeTVqeRLicOA8ZoShVL14OQw+3f8bS6/B+1jTzRLIIZfjL8WGKv4EUX1tn2iJxl4Ma4FPu42WbIqlAG35mO95kExwI6KWKhZt/l8yy8zyDqXuc4DF2BV8rP3wVayg9zBNI3QiiOHxhL/csQTkrTGJOEAgajpqMdkPhB65F5UIpLcqkHPmu5wvJutJSFQVvOfLhMdhJJ2zhvuCzQcYtPBcmF6TK31qIsaSzheVN+1vETwzkrSugDz/NRbgJe9/TPBpfItA2VvNiCihDtNgQUm/19f4la6hPpdhvxBCbTlREmpT5h94WVMkeaxshiRlheNzWAUTSkModdbns+yH06YKGNQ4KYvpbGIgNEEjGMyGcf9Zo06AnIBgGwqezJNfbWsiF7VTngTRPP4r7OOZ+4XrX+4kOL1BqvDhFqiu/Onb6W1QAM7glDSg4iSsjyQjD7ysho0Xrkh/3kocOm/hiLzd0+Z2x6fCsVl2x8ipIV44wAnFt/CXly22t89JNEJ6u0vive7AeFCreWcMNBxYgfFR8GG9/wq3QbVHFY1zMRLONUG34EK9GaAPRzQJKo6bC9JtVq98zEE1tDPClq3/CDhxjAZV70zrmzzzrnK6bnbWdUcT2QN2HA+Sam5Xln+bO5BbY4X8lCUtZWkHr0v83DCGR/BwoetNK9yozHjIQz/Ke+ljH87+hNqrQX/z0JVbV8vsF8wDzOHV3JejRUt/U56lLJJOYs8C7mX01ahV8gBMhAJD7qJnqp9fpv0Cca4VL1/om2FK4f+/Ihc3uwxC82R5JiwupbSFNrHhXUFGMLFqLhGpZcDuUKalz/2LBWM+a1vEKYyf5pcCa7IclMbj14lPjL0LSpkVRWWZwJKNJ2ASpwuYpDlBBVSSwOAn6XVhPP1KbNtQn6+FL+iVeemRqO+jsxm5lD2IansJFEn0jEJC+4R7hpN9v31SHkD2idKQr/0GqiwVL+8iiv4Xepb/8pBGcgM7uxfY0dnb1xmVCN40CGa3eWeHxvjJKtuNIKD0a6oan+FnRK1+KJd+2IzP5+BCwB2Sp2d+MksO10lRKeckoGcNljvf64M0Go7ayOhLLwinL3fnI8Zgl7cg0951dlhV31Se/8cfiayjiClSgeU3MBgrp322z0okV8mXMqZPFNLwkroLJUvmeHo8RpcUDn6pff2UXq0BiOnzzq3q3gFTxGGCKR26zC+S30xwrkYkbccMey9QaoRUPZo7tjTBg7LrhkU1IF+q7omfBe0/k4ekmANnGdaUJMTFJGokFh3VYmPQcHjwNraiPX2Xj+EyXCLe9KPh+68GbIzfe4wo80fNqvdy+1n1YUo3p2lmRePhq0Lmo/HZ009aHxWFScY7xaY+xy8rkj9Lyxs9xMHKKrBLHcPOjBnSMtBCG2JyInPTdpyI3kjUlfmU2sGpUMGysKhSrpBDsEpjAeSfmD9dZO+TGTR3QfToaE7wGGGi6afsLLtubTagljV4S/J/tMeHcjOtNR9J0AJzUC8yQBZdF7xOScnkbCk0I+k68knF7yJyC2eKsqQwH9QljRQuaHWxvn4tX913gQzz+1IqwFfIUJr26dsQnJhKJhdFQTACFAUFfwNrEhe8t6jnqURd5buWqvdchizEDfzu27CL1sK1iw376UzcZMZJX9e6GluGWFcLbVjqSyZEcvPYs3K/4JlDlvcKbxJZrpiLx5L/Cq2+/7vcPkEcEzVcaRVWoc/w7vO9GP8T4ycSiDI+t2WRfkdNr6D8DUFnBIjAIdoMcB1PwgT33f/5Y60P2YOW0JFvPowFXF3PTK+IAvw9VVTiBaCe94zatE3c8wtjlPViSgGjuKMlWAfkSC+idUQ/F1fD1O5GhkuwlS04Y/P2QdA//qRemi582U1Co2BQ3L/UCXUXZRWFBpV3/Vl0mrkzhWvv1/orTMqsMJuqpkHCozCWjZQvrN13pLKWbKNwASGCd6Hdu4cVt+4sFO2rLH9JiPfAqAU/ryvN/bmqLiTQsBrnz68hnWPTVLL8lglwiofMbTfRf1/kT5yuhaBc9VS7A/azu5qUzuHhapYSNXIbWni+HJM5g8/t+SfuQKxthHbyvpZEXEcoxpnlWBQOi1mya5wkiyCWuZSAaqzYCsqXmWSgfW2F/z+rRBK6zqnz54CLfv1PEYNbVtKB/L38tOu3lp9Hnw08Tcu9QIaThwdk3DflbkildqQ3aYZK/+TMt+wNjquRnf8Yc3SD33gV2HJrc/tfqxsl/wuRNa/68eRPxiWUJp5FJxXrhVY06F85cd026tICjcy4ccavAwghTiqMzhQ0VN7XZjH/nzXy1x+tNadkx6aXhmxInVjh/D2z9QQ8lnZacq7ODoRdm+ndJa0unGgSf/NVUny5mCY6F2+S1h7eT2871zjYNikw4Ytk2v8VAhLhK0K+Euj34x267BZAna110gzWegg5D09iSa2nXT7AWAj8zwWmLNg3jgOmyIWnAa19OaXbG28khHcJn5fv47AHEgEPpFGKWOCVJ8fK1n+BwDjjX5YyyoS8Pldxq6b5ftpUTIM/mQf6Lc1z2Q8/0Ate33xM46kMgFViLVfVikNegB6GLMqv2ELDBeYqFDsrrwvzD100jYKfJE++5Gs09kqmYEilyKy1O/tY8ViGMdhYpM4/CwPvgYLhUwBt2ubQvjCY5fUFD5Wum8ZJkDAIxh+urESPLVp/8Rcg6GxfcJlpsiwP2vFYpNdu9GQFJacV+AgYu/f2HclAzBkUhsgl4hdE0NvIDnaJRHGciKWz/MYin4EkJ2O/s3+KAAGfOrGIcWXD1WCQUR768wWXSK5e3xqCW2LjW5RVLqSkO+n9OKkvWBkuYcLFnW8aBFgnmyzQQESjlHRZ73CZaQExtweUTn4aq2MJjUKWNhpBbbNyjEns8GacqzvOVjPH7VWExB14H60ao2EZTfpCgWe+ItaU4FRFeZAy0NJmvDgT6aGRGUNZY5PHrjhKORnU0AqrQmK3P8y2LJ4y6ULv1yjkVBoB1KeFcdP8xGliKAsgIV1lNQWtqzXVGT690bZu3hK4eShXS8iY1dbsc0z+rToVc64WDxiMbGp3e6vwXiasKppaMRq81ulgCpkp/mUbQSKYBnNeuyjRTtF7JEg4KelWh6zTk3yDub7dAjpj53yAN0lOp4ge5lIsJdom02NnYMss6ykuIoYH3S2nD2YYZlbweEW6qYNupoQytqUavvUNgSBt1YB5YkLtpwwqPvYtcPmRrIxMwKLtXAq9N6rYMyvdhjq8g1TcErEnlGRt1jgtdGmQ/qhlyD4oLHUH64y1txpE06lttFiusFHgsy/q3h5avpiNS3oobEYTFit6HGFJvzGk1qnrmJZVxXL7afHB6M2kuomYWCIwqyXH4SpU7qtQP4eY//HWqg/avZD3bF9f3hRM/hvX/1WY6Mi59rvE5Le1OFpGWiWDofQOkgVIUBoa6MSS21W/PGDLoaCM7XeOEotn/Q2j9geAZ2L0wsv2W39wCil06TK99tgapDso5KgKZloMLkDNlcjDl0r3HZ4BG15SlK31l5iTwK8HZ2986lZWId2LykfgDR3X3AAnT+R3qN1out87f00hWETCg8mjhl9NSLRozqFZpq8Rn/QTwjfyFWBM85fVSp94+eSUbUpX8Mqd5WSm0RIwxBpDzQDZTb2iZoZH5BDXG0fdYbvKUNL7wfeHUJ1CFw3GdWNnSa4btfg8i8Z/+NXpOhVBvfcJnTwzMwXVCdBhETgDpnz/5/Bp1fdX7d+gXVguxNeGZM63hqfnTvHD7W69brLKouoTZ0K87HQcVKH4MVG9vK03K2cU9v3TXmcFBCR20PZ/cqzOiD7cteHUvPpRpPZDQvyT5bT+BtomeiyifO1Fv7cd1XmKj9pHJIsgGTpDOQT2+H30CnA6GRI/ydg3WfxpLnuDzpm3r3SPkgTiSB3YSjf79Rd05eNAEu5lN6QBo2eOzhtv3tLFAFhWLySgcs/NJs+VbKEEwrFpL3Ay+yNFq0FXQOiVH3kUIGFMhEa19Wywqst6muit9bQ0K3tx74Zf5fU2HbiXnzUzSskYcKqkzc6NgdWqUdSn878xM4PrhCkUun0PJKBuCB3H6hVLiUNveJKhB5wjrKFkCE4TLidQD6BBPbPG1y75kD2zUL3CmSmmLIZeZjuyBvdzmLqBA754l7Lak0ozrAa/iRj+LussqMclSktJr2ykNhzZxEtFAdWeIMD4uAiCMwsG+/JakzTHdgrSCQzi6+EBLpQ0lsUolwoqc+h7SroMunCQNRcqEBbkLxCyu2MG5Sa0hDw5IW4QJR9GimOSRORVtG17NC5T1Kz53iFoye9Xb0i6XZtyZeUEuMfhillyrb3A1JR1q4eTpEZ3JLh4W7PuJ2PX6wK9G4wUdX2SmHdmBGL192uxRRekH1/HMePfTteAzkpPJltc8jS4BjnmmRS5j6drvNnNQHFFXtLJccttPS0h+tOC6BHegW4YFR9DIl+KgYMndN3T2EeocWy5qZiBoWRPtGOO6B5XtU6CY2qlfPxpoNsb7mJowhPOF9RfyFwsJzA0kubA0/iGzdrEhLqSu9jLHY2wEc0F+3ignf25jaSrhi2Klpy2xIol33w0ZggrtBJpeoLS15LIyYLOvZoUU+60G8SNK6UGUaHfdSKsuCR/Qmy1imz544T/VMWbN6+xX3uBgazD2KPU6rNOQvjgDpbHrxiN6JFk3bqm+HzExScfTugPxSJYcLQnukBMi67ZK0qQdByQWhhEhBbYOQ80zBedzFR6Wb7GDcEY9kyTgekekTuYodK5BTIRSK/JEjo7Pl95KbFNcAOpdIYjdJt6VC2Jr3e1O/thm42owUGBjYjxX7A8Dz3Uc7Q2bGkJfKZY4rtwnryxL3na0XXenJU++agUwo8DftGi5c6WnL6ABu7SPj7YvsoSriCbQbKXb+lGrV7uLUc9/byTgKDjXRvgZpVhRKagJXjhiZ325b+sIeR5plywmNnTztNJUGxHlaZ+JFtzD/2+csY6BDcOmdRcerWhAjiV4G04hmtj/HT9iQvNPHQsc6gqxwFcYvXkXPpiXh8GGclr9t04qFRXXeMHeNop4+XkZoxcvqkdote8f5c8cLMeh3lFfjcNzJXCZeJYWJRi7DjDRnEeZzGqs0BUo3vRPlrU8iRhbBJXmXc/qMmvBSbj1eB9toJEW95oGN+4CD2FeFFJGEzde4yuhR1JWVkOR9kEA+1bOkLGzQjBALhNeTzrWcfW1+gEopOlcH86twWVGH99C6sU4zEEaYh73uxB+nOfbI0zfQG8JWOeCpIO+LNvLhX9lyC19/jEOD/AfADJQsQv3/W9HG0c6Qui5y/uJ0eU1Li3SluxpjpEB5qzAddoE8eLAESgNTEqQjb2Ld8iYojzKjakFeEk/Xyu7TF3cIVQ+q5DKZ/k+6eAUQbvs2rTXIdp+/YSMOM5XDUAhabwG9NQ2/1VL/6SCj4A9NKONYsc4f54oxW3lIIj+pWLtzF5sMw+Drb+8wsWldv+30xEwn6qDh81V8BLTfhIHnVOMgXU0N9Ji/u5YsknHE3eje8faeImM53AV7tbCnYapkd8Igcr4IQYFJlksMqy0o9NpIASwtgd4iy06L1B3VdbmQouOiX6h37piU6wZPNTu8r/r4VlZUE22FIzKZOhY79RSpLsDRFwu8cze+3oG8WJsN76G2NWkCPHprXpu8+b/DIkL6JPAW6ebJkstOrfCXqh32jxd4VByrnhFYoE9q7ZxLmVRKjH86YzNx8+z8K6Da6m5Xf3iR6pcd9TABSCn0OjOA11MuAvl1N6sYFdSMjZ//1eH7UgxPbWoUg/7V9wSiCQpQFaBxe/pUWZzRrrCbsLsHMiVJL9+49SX510OXLMF6tudy82kK9rZvkfg8ZjhNMBmZaWVJ3A5vRJwoQeNEDANykCMhS+3Xccc3qZlP3BHsF7sMvYLkhTyjRGkOQMd2/1Xeff/Qrjsf+uDRJw3CPtpr4XSB7cZSWNIWfDdaoiR19i8wxvD95M+PGOlyaL0QI647AT+9Q1qoCZJ2lecC4CKtgghjt/m2i5k44eeQ1WPms8za+LKRu9qWqQpNpRreB8NcjZadpW4vLcqmRzKe4edOF0og/8IAf7QQ/QasJ7kREpILseRmr+Tx7mLsAtkRHPpQGEAKIVZC43vfXMyhTLgsiiADFa2nIfIrdd2+Qt64PJ6Z6+aASK1w8u6YTTnoR8MZHciE8Miociui0+mv9s8EzBadYTm23qetnU2iA16Dkl+mmzm/lOtR3I4+KJxUAVTU1+k5/Aa0aI1v0VtJZy5xrEFHoiXJuxIvCdEEvkxbkpsDpKoGrZwGwGj4KpRQnvr1Y4LGCbhDwkEv8y8veaYvjFjf6H+FnFtAy8zm8Oggy/Hq/YsuVwLzVoIJUKFpJQgAEeAAHCz1L4+Kfdg6RZhDIZ0iUgNnUEf8HvR3yAOTyosOmmLvbO/cPu2nZ4ykqiQLVN0QbnEzl4AQTozmDw2tGVwwQAtOTfP/5MidbTLcnTbbOV4OxE2qx/xNgAOkLBWahp7KAzyfhKq9KZbSQf4n/hxRCzAxEHGEnFioaW/CW/uWzXu1sdkPyjFQd8SLe/yVgZVNMXCsnxIOdK6HcMZOotedSCBtWGtZYXMiRbwZ6PI7ThjDVwytTmZHG8fcFrglLbAJ2t3PHg2ycCxFTC8QBtLvJP5KQk043HcMSItBYa/JwxoE3A2I+/mRfeiuyQhSJwZ8t0BTVSJkfEdOgS+di76gRnxMe/CKjwqzHFv6MBoYrDuR5m0qIJlxJOgelQsaDh9V6ieFmbcPvGbQqDo4YibxzbwyN8Kfp+3yAGncQZTAf10ktG6CCnlsHWqDimTsbPjIGgRtqsh85y74pZJejBy2VcgB0xl/pA4lARQnQdfxPjmOXFJ4qCZtz4GCJxCNPokRO03QpvQQjYLmePScJAaRRxyIqvi0YAXS4a2HLJQMZRKvpaprIHUuV3lg8kpladLo3PIOh1eT6F/ITkT/BtjJhB3K9hrd52128I2HFSm6kuL23yiEqrM3t/0E6zRFntlAOgITh/CysigeH7+yeMmWqnzz8qkWHKPJBhPLBKKTEh8JSrRq5uMjO9r8WOACLyz4F42RijyqQGRRj8kBk/3O91uaQWK06cMoBLaqiZOFT/8JgzOn4c80+o8EdNX8EJXKigOZkpvAR4ZPJLbb9zV1yJfCooNhsQrP0INi7+RLGY+GTUe+xcZr6qCjxfHxKYh9wbXA+l/Z4oCNViU3p2roAaJqIsM2f3ZdsXbIModozURYkXmoSXXf9qvEhKYpO53SG47ui7zWQhO1h5wJeco/oR9gVqbzUbxRGy8O4V68XJfhauYJMCWnSnUBq90bdZkhoDjQegZPQ1wZspBIZcxUGPiIkcR6C1Fkok48OsEU8gBodfw0SMkKBQpFlxthm7MAMR2XP1BKWf04et1nGZehzFuX8yZuqXtup7GP2sexRp4FyCszOlC/kw6ph7dVHZ/Q0b2PFE4NGn9UCpcy3XbA5+hSPlebSfpwcKrXbN/f1HbmtRvRQ6yQnRUjFzw9rO5g9PdUrmE1nhbObgLjSjd2X6uC+rw26lMiBQJOGt7iBnfRVBFjphS/8gGJFkPqPrApBt2CsDYumA83MR9bVEXJGuild1SeqW/7qZROCpUtJ4lXRWH/qA3w8EJVb0YQ9w8nPHizb4uyV8FvDNTJDSyfqlAdFWF+RcTkUQqVrmmRk6/srUMm9uyJ4afozhnH/lJy76Yep6U4EzXTTx0yOZATrXZtXpmXwZtn/xcypACxCKAZMhfoj7heTUdqNW9KdE0izIIa3t0ehY9yjn/mDkfD0OLK0qOZYJtNUPLsOg45BJSyC+yWjmvHtQJYH792mMOvgRFIKZb00cnpHCIdXTjxmyJRHsS2xbEJxa8niEAtsSfmYEOJJALyowhBKG30OJuSZwj8iY/4zOStT35xS/Mj3YJYY+Rq4/xYiSf99W0D7H3KwEAPlol3L/6OQjTICx4Xz9Rcd5wvT6TrdHZBzXy0LQIzpO2I6pUwFa0423tIdK6ZJv0r4nklJSL+2Gwla7bxPOiQfcxLqFwYVvICH6x9kqgUDTSAUDIdSDlpKXayxVmoN10UZBRCzyLhOkPe2dueBioGn4VBGGW60yM6TwpPDayRALiK8UrPc/FjhYpJ6sdbXE/nEQOfL6rI8Nao+uZJ59dy4IN8L19dr9ePZgOiHU/oFwjAm7EYwBnUA+NEfHecIIclHY0bdfhtULAz8elze/7bo1RqQdJlYpVOurNmZfQxVLqyOjHKs9tPAiDba6z3aV/h2MWMOFTrbX1NGmR8330djNdPth7igykR0lWrz56OhkyrGg6sOcmQK4POYm0XLKuJBmUAr5YzO5A6hZ9jyRbC4FS/KM1uopSxXirLxV7BeWEzrdTCapEsvQBNN3/XdW/57Xqks6whrzu4/BAEbSnh8ykUDbtIB9Wr0fSEq5fSgvNTmHKfBYmVsUjreYeH96EdyZjUoiSVLd0IQj9W+F2eACLleDpwPHWisCu24o5j8Tokzq3YhV5uZWOSOwg2RbTQO1yU7GrIxZJET1wRkDHwxHUboN8uLSo8suqA1O+TC5uYzsxDM1a4TFpEJSoNMW3/lojARMdBfAHHPpSqGcZsGtGBPL72thkajPgSoTD/PjtHf4Dc5GMwFN0KGaBtRo+bMJ2e8sLNFYF7uSkkTRoOcrXZ24j2t7sxIachjo9/PF+Rm2QCKEaEMBfSpGQB9kWw40iZ4bdIcJgAahUK1+kpdd3gus/kXh8VEHUsFIkkhZ80GUqUJgNfi0d5GDajhQqP3Clh5McO6KUfjvCD1FAT4JnGJoDHVfJuH/NGq+8ZrCxqKjUjIFmHeo45hdFzrrhhSfr1qMQwxntsn7sTCgqtV0a5I0HrCCTp+ZOTnzwF002IZyc4vgUmEQwdZExD1ONUdqhZv/YXFZm7DprE6Y8ctzpra4GRpKg+iH7tm5G9hzlrE8uwjV9jiJU2TIilAXuGydF75Dd+BQypgj5IH6uHfvQV/cSVCNGIPc8mjGy+J2wkAEY0y4+ERaAhMO9V0Pami6UnwV8ob986ZC1zUMX6DGr1MrUGgiYj5ACxZCOi64DiZkUTTXEQXskdtNOrflK8uG47vyXYr1AvkB85krNezvD1+AGiTz0lveQs5sSFUV3QSsHUWabjlog+znLRUblIoorDUpULBe2yBFRBGelkxNDUGSNnJ//kq9blZmMtLSBYEWoZOzjMbIJhSvDjnZvAT33qyXoulV4XWVCIdVss19DYPZeX1kyBC850W2TjtqasV0Vn+vGhD8eSJKiHbTKbqbGxFLClzV9f6aov1dN2M8LPiU4KKE5ezkAlD6P3I5T8AsfkaCz25SeC6wRdPrFEMjUzNqTxDYyvtgJCvMLJCqpMCZmFN5IdMgjWxqN1lCW9Wipre2ThUHEGrLmxT45QMkpZmuUYijpqCEsOZsq8KTGo3w/6ygvEcNyBTpEUaSGNRT3Hcb6lP2Ysx0laSHOnXyik8y1oi/KDA1zyt7ttlmudy/Y2eSl+Y86dSQ/KF1tRFIBstiqRpo2g4QDyKhuWmdHvRGIhNsZeSDdqmfm9+gBI+++FaJ+3+n0F//3529eDingB+oreZTNBpMmSygHtMC37zDJ3FOGBxPRaLts4hrKf37DTWyQIzbYqjUYQFAb3KOZ88q363DRBS/q8g23vNvW7EUBJbBVvwqcfH2fRgTesqvboRYDhKPbV2DT1BNOf3H2tRSFzWBYvk/Hbodc0Sw/gTwtKgOBdYqicnu+/NaVTzfxcBItNCFyW3kKjo5y2VvfLWcjKO/d7o+IF0KaDvFu2VB5WXNDX8gc2RBU+Ce7qmu6tCVMHF+QhywaSuukpsOeFmGCrMUoH/wem0bdiP5BMnUN8H0pisAUnCaxxmAgyd6VjpMMpXDZpINjS1DBjUPHEANLMju2pSZk5VpimuTCuug83iidjUu5FGCInVZwqpqcHn9bVT97tiPKdvri4l9EMbK+lZD/U4NS4GpY0mAkrkyjpEGUJukyviZKn7j+LqCeOejNwjLphpFv1GwsRgH1Zt13L5+T3DIHfFthSiPGBf/Xq4KgInPoaby1I0BNo+EdiXcVyYTO+QLsJV01Rk+Vj9bRSo7PapjiCmeaISevwF2IPSOR4DudFlY0dLIfC79oHYDve99BbHKWDqKysjjy/18qKdatqmNxVTGeN9oepwC6MQRIvWw8hxIvBAIUAfYLE7ARtbu7R9DooxVjcuwLTgLyprkDIsm5DeuRfeWkydRU2Sbf/jqOrGzLYOBxsaZMHCZ0oT0VHgWrle1ZIA5tgFZath+a5HXoMzTpSkky1m3bwUrQR1weItKHLRgxHDNlmvoYWKqnMNKKnS6+JDOqQNpc4Dgcz3zbMEoJv673+6Bi01Wpqha3ujDWixaAs4DCaQ6g4ANtrWaYAZnzwi+xZKgSFDDlKNm6LbavJRnhoSyIgIk3PdHgG7zaBaVIsSKAr4auM+WQ8N1jMHrdhSVidV4rrYlR0sfDd1KK/da1IkUyMrzCDZCtB+XJLS417bHN2rWdyLDm25S8qG8WJp2cJFNXzHCxPX7qOv4Yf/IEJ3MnUZtF+PsxyuFdpy1r4rch4JYH94BM7RLmhYcBqcf/IRISsuu5QjuYbzMUooqmgg1mHvvNTdxxk/Kl+vGaAue0rnaXZpM4hEpDBJocqPvt5GKEMnr4Fi++WCXGFyj1EX+njOSF+LvO5tC4Xc0EjQXK2sXTL4e0p6n3fKcT0u7Wd8RYke6DM+GH/4TYrpQtORu1E3OoY+vnq/q/2dTop4WX4VUPLNXULKoFebiWZaTSRmPugVASZZKRHzWb4wD+h/RhJPRgO/+17KlZTemyi8V40Yiczh+DOeU8u87/MqBHLB3D6ZQqBiVOAr/XpW/ByRaEU4lOhlvT8mWr1hS3edPEH5J4T0CYkTmaVP+VwBkMTlmwnJi/YNz03oUoHjhZrc93BqCB0fCpciqZZ4ylln6BmGUpT9hIObAI0Iw271qhKaWqa6GO4Pjh3BHHa4oXr+EiJaBPmYZ6I5GXgzqnRa5i7ZY3PnHY27BK4cY2abG6HoT/42Zsew1w1U7hK9cJUiepdX0hqBaKu7p3hFAsFxcMY/ApZ6aZLHVO1+wcmPfPCBTFNnrQc6XmGRCdDFgAQlo0GW3BfE0erxsXEcs25B7+Y06Mei4BEByDp0EX8I0erdT/a5gRZSow8fI8hkz0w5qaI9ptXotD6Aiv3a77iK70qYQDd3XDAacqAOUQlv5cBsTFnM7n61v1pZeLzsSPbmKUawpq/CIxNNw4R7XRXwKfgi4IIdFdj26RCbz1Yb4Mes+HzHz8p3fw7LpSygjkdgr2Q2tFMh3x2IopKLJqUczwrhlb7VbFaCU/NH/K07gYNq4O6UOewp+G5sQhv9Zh4aEBN28cy6gOzQ/csEDr+kWTYoE57RHLAB2TdyzArfusmuBo9rilMutlJJQCAkLUO1mjY1cjIFiRKlr3LE6Im9KUn9ubC0DiB0Tnb3ECHV5CZVf9NLkgGSWdNRi/WLC6i/0PhzfCD32FSkXRKcMnrZu/P27RDcYjU5T9rwQjJPXuuDeLSPmQrOG8AgPVk2OzoN6y3lbgHwXxN90R7ixux5TtFZQXbUsGNWVotkj+CP1Ab0fgF1VEWN6MtsMYfEyRHFUlVEwha4O9JcVYiSA5KZGSLSZoUK9iDaGJprcCfQj7n4s5EH0Twg+4//k9Ba+SiVT/C6W4WMARQ2Yh1izQJ3MDGnW5mc18nDpEQ/k2zV8IqFxdOSrLkFT36CHAcO96gTCVxlSaVGEeY3Gbi1JiNH2LKr1fi9UgDXGqRFRZnskUT8nMfVlJ49WVihG4AZqFH9aG0AdavEJSIWSmI2KvceeOl6BDYIg9psL2frqRnCWtjg8x2aWZRv13eOw4lHQT2VPhUDcmggtL43C9k4oqjdtqs6rHJ932/O0a+jOZA6z34L6qJ06+DOXxAMqBzH30HmIOQRkaQkqpf4Rq4TKB5Gw7taGxdjWYQA94Ghj6mi65tlrSt98fKOwmZDs3euGHLQvs8dSRnW7Bsv2Zc6XhKMmAfXz298VcFb8tArWUEEJekAbNnkMqU0CuOkoWBvIrpRy+OSxvjhubC6vcCCTb4T6XD2E5K2w7Nll1EL/H4jFn+Bmk00OXGNbOrl/kN+Gpy3q+LUYG54q52yrpZN+iCg5cNNDT4xm65PRrhg9aU69B07gVfGA2yLMGrHg06RJxuJzO3AizdV7NaHOgDDHL1XScZWsd777xwrlCSTZ9VpjxsATToqqXlcJXC7mHpOD/IerjI2aYekbMyXI667kPVxl1jjx0UsG0+F8+DqfzIZOeQCx+0Bjp9rE4fu19tawI/3/FB8BA2dggfj5J1mGU1cbXSFqDDEzcx4MyuIFfhY3rZae+ER0DjpRXJpTEkC12xe4cm1sfwwP94isPSuNKgnlo18m5al6olI3C0AI+bRgE/SDcJOHjjHdm6VvyPKqj65GZk4s5Z2bP5fKiqebW3JzfVfscPMA3Jwvwb69Wjz8nBBIpON9uJkunpljjcpyxahODpVd7JM4k9J4elXa3hjqI6EapRC5dKziWG14DOhMnyYpH7A+TIlOgUBs8K01AwmPYl5xKHO/XJp3STkuyCqJ2PFv6So6dXMIy5Y7q3mVQZ5wg6LeGlvfwA47clK21z+du6gouQJ677AYZUCy0derPpRBJRWy3uo2UypHzwxeZY2cQCHQOMe5iO5VNZ0A4yS033Bhf0wP1IlVXhimaF22wVVrOScLngUH3CJ3CU59sixx/MDvQvisEb0q+vdeEmcrK0wdGyOgN0dd8I5F08LDoLWiLZ1e8XM3sz0dsV+K02Bcs66aLqcLKbcrwIPS3ZAn4C+e/k7wgAQJu29vuho7UbMVko+ZeVl6nIm/5qbukwUuebZyqoWTa/pFaQYJlQwxtIeVlpV714VZzKo68MjdhfVYs6bLEmCzmUllvTNE6RdHaq2oulqBlhEdhBSAVAYr5T5DaPlG+TCwwlv97X66v+yYuBSqIuRqtlBda18qYFNsmxb7pgGZcjiv2joN0aYFiGcit3l5nNQMVqyAqeOOa39zCTkc9eh/sTZ810m2HFS1y0BD07i1vhA4jK4jRvzRA6TK8bh910CHh0ytENLJ447tXsp9xbh47+Csy/Ra0iiKCjaDovQ0BPWGpRtdWCC9fM5Acp+7D/mOde0InZ5yGgG+6+Ve7NzJR61u9irUlqrcCR0wcaf4b31pTxrJpC+UH1kMJiVVeb9lgvwOm5/1mDmsEVTYjJIkBg55kM/wOaQjayYjoLE+1yF4kh/dqsoXAcpApe+eTLs1xISL00trS960ypEten+w3ws7Ok/Tmq5KRpsw6ZLuDMW7tb9LPl9TyyD+mE+StV/iGkCqxsxLFWxJqUUzyY8OTtgr3jiGcUorrh69p8ObIjWID6S6WHYHYlyboC3X0Y/+EZ/Q7xJBUvDOb7XdRu/d6bfS4Qp0EUMevfZsERZCYsjJ0dRpbQ7arb5n6We5Ksrbl81Hwj28/M8KtVGJlS5V2g9s+faMO2j2fw584Pl0EeKaLLwASNKowzYzwFKMLWRUiF93tYLZjvOIo1CgI4eJ2yL9ZyZv1FQ/3JlZs75lF8TTyvFSs4oNmTCLFY4JXQvlqe7vi6SdT28BvsJMrdY8tUmcufMafaun8IY3eWERjy8gev2RgulXkt6PIOjnyxF6qYeBpYTMqS6JVnPg+S7iqbtIooy+KNgZ3WCdTm+ry6QMI64/2IvYr39ebHpmGUTFvxMiRNR/4n5DA0lQVuppAkbQb9OWi2Mi6heXo79NyxDUBu2hZzrCgPSu8FebD+ulvJmN8QB7pNjBzIfeNTEKk1kxecbXNfIWmKRertyfuu4ugAFC0B/F6EYvVftiU8qI55pgQftZRb0Y6GOuMTqpT57JzqjOQfmMlMIzBFq3CUV8we/8gJ1LXN5JmJz00d2xQrB4dWH7G0+QMkPsQl+POkJRuncFmnFc//u54DSHIudsR3nUF8vz3dscB2/EjZ+8EwfxIK9ihi1cJEeObDBpHnpCw+eF1WWIvcjCfD9Wp7nE9Tma99n1P9g3WCgZ+yBdZTF+zt3oYGcQ+CA474efg/3RcgVF9v8E+yeFO+lIfQMw6aSitOMy5dgBSS2MGNX3ezsQ+rttDVswVnG92ohfx7jrnPatRcT/UpeBp80ZxsLfu/WHrh9OoP1cNH6V5tNTgwH1P0g8e1qvrV0J68rsnbqamBZqnM7vU8Q2gdrfD3jVzLdl6L5iOe8bCh5LvbM1WhIhaFdv2eC+Ivh970/U661De38fIKty+LZcTgAivbxuhLJ9DC2cMvcPdSZRE2eQ3MQ6f25NfCrCPPrh1v/187FlJ4dHT5NPwjJdREUgxvRosoQimfMLh9d6yvhnC2lJ8HbuUOABCMVWRqGAe62bvjToy1ZLPPABGHPstKqHZZIYT5S1d+x+r7xPHvawijqr79zSiVXOVhWhcYXPmS2vY0SW8XA1xsQIlOx4Q1ROdtsxIQtbc8EnIYJ+GvyDuqjDzRz7ld9IJXaFy5Q5QfhxLA4RyIyszMuS2ztv852A+659WOTUGSU1DqStxgSPVrlFExt39NH9gYM/TFllPLZ1ZM1byRjlOw4dyc3JOGj3odHcD0wpdbMJvPVfLNzcVBp1yyLNdv1km0zvQ4AmyJjINOmfp1zElfe5z9w4Aj8AaoAQvAlTsn6jEZvMnqGnSOIseXR4h6AyhAMbRf/TE/xq+i+dHHNp7+Ic7Yyhuu3MfLTNjcbs0T9GT2l0qBppQvvU9C+bHygXFAvk07j8FZjcqOKUbbPJ16VxRrLddlQnFmLkFE7LeZbcWx7iqrbp0Xz2NtZuh2buci52YC0QptgX+7O8xqewsgoa+5/AGSZdSSEy0KNdFaIpPwS7Jzi8DXIA4mk3e1ZCpNxFPVdJ8NbpeAwqIgEHTliOHhsAPG1sTWGUuV9dc1fi5QWxrjUdyfphd0Ht1YledEak5EaqeIhB2X8h/HPwy2bx0qEBXZ4Rf+yaD9NYDObV8WUjfxU/SAJubhxvdCpxRaTf7wCUxGK1mDEeMANtJ5eE9Qc4U+MR4OTWBrJy6bqspaQj/l1kh/qK8IZpITmsne4SEntov1t8BpEVxW7/jA9IPpEnsOOxT7vSNIlW4keoVKfYzN9MuqCBjt+TvfkwFYQO9wn7pN9+vq2xbOs+xl3k96rLK9SUokLx5PdvtLG567UKMtXyDwKnPEnJxfPRVntkkKUPi0wCkJrBSKUK55QPn0j6IUFBw8Op7ve350y6JUuH/eOr4REGwqQ3MxvTDmf5QJhsq8Jynqb73r3fMu8h3bpjfn0eq1jdsRq/8SCrqmeHx5j9F7AWi7liYGobnHvTKRwqmHFQWj3aZdbPb1gW+LDH+d+BbcrmoCVuPICrSYKpLAV9Kb0W36CM9coB7zuHtLcL5cQf6g0xgVTGXzvxIHTYVJDEoktL29eSGyMizL4afRnYyuyctyU40DK7ynpIHbRjpboJQGoA2lznnSuIWD144Vo5VW7rCiZnRf9ToR+9Qb7plC0mxl/gm6ZfzeE3txJ51GnymXPNSkyXZQ4sHmgvwyrcffp1Q9Ia1ID3YEZErjAyFSEZedtQ6N7Qm5p7CYEbEC8lQYkUpT/6hG95H4GBcC+mPtuhVTwNavY5C3emsrKIfHwTBwlw7q30GA6ZhkpL4dg/MfxckNmZ+6sfwvZBh1uYurbesQAsxbFFdepOB8ueaVERg5HBwdOQ/EroAhy0p0q2tnd99BVxPwhOyBMfi7GpDmmwydtrUuvt9GexTdSSE/t88DUf706euxu7mkQRtiJK+m3HY+pqkb0YPmIiCmBs/BPnhSb8CUM4B5Q3cBIypmNnt//vL3DkW5Tpv8GSOhIpNx3a+qrf3QX96zC4nibEvaTbOhSzmp4iCSIUuVvc1uItn5ewGe8SCmfqMg7GpuylJ1cW758qFlZWrrK9qcC7Q+SUwEDStGJl/weTIqB5gJZZaqwCixdpvxI4bnpl9/AbdnRiKFHg8EDEueOizrwSgCs2opyrx6bjQwk/q3nor4Squa0YW5Q8V5TrlH9ZbAFOSsNfwpL+h4tT0i+rXlsxYHVx6Y8xWNx1dhBIOmFVBqqVZBEN5TMNlQupJMFHaqaXh1qo2+YMfEJ+lUkfvOtZ5dA83ohWlfV9rtEiLJW7314ocRKl9evmuKu4f7Oavs8w+IuO3m4dQDkiInvHsEiRasKuboO9u59tzS7i17caGZ/ZLLuhyyqUcSaaFxQb29uEW8OuOAYV5NRxtzaR4Wxpfj2gpeOukLp1dKCI3gnSFP568SDzB72x1Na0EFamD3N4O6TN31CaPMvKh2dkYB//MSQ49AofSxea0n150+QPuAeZDWig08A5AD9QJCXmpC/aeH/LiGNT1/wf/e8b3MkYOehM5xMGWqLZPsSpvj99LeWpvAO6wASkZ7/PZDEmU/fXYykfb++kCF3bJn2m5tWZs2lmdbWBZX0lqKvvWkn5zyFihk+WlCh9cSzLjc/eToAQP0VxDRFgo9TjM3YgSSSkxNcVqRv1ps2vwid109ia8MdQ6a840SbZccElzi+NyD/u5/rhSqZCtosXu7T1eWTH5zo0IGejX73m3kY4KnbCUV4zlK2oav3LP5P178RBxdNguXgqd9Zm+k0j7q8p8KGvbyHCLgPi5RXA1cH9ljyQ8SXBFztlKZEtbTej88L1LnG1c0TGu3WSAdU8JFR530OanfLCtjj4S5bjih8a8uFZaaea+9+a7tUnu9AzNwt4WovQOgSwhxw75djtg85gi+iXD5At61/ykJqoynMxCN8oL7zhEWW8mGcvlQpx+M7vCrOS2Yaaad4ru2batR2PN6od4XWp9baDkoE8p46TkK3WrGOuXxram5njHoywzFSAiUIwiaAm1IMuHPCAHSjf//jkgBeDs8JlI0428fKAwkqokOtWJVz0GAWY/U4LrcwRQbXU4UCVWiRdeamsRH20HeEJdXc+ArqhVhtpVjfhuk9WhK1AwT3XxDAEUrK4WlrHzICvI/qDAiH06tIhdQ7PL01keIjU8VgFuINNjEYlsPwPmg77bTxSgX58MDShrLkj9DdQT0LZOa8bD/miNCxFgIhRVRYlkYiVg2wvr7HlB/23P+LK/51fDNmlrO1/IosVZkCer7egc0BqmOBG2i23Z8+PghseZjUCUAb/SOP0c4GWdeoFz1xigfBoI6+ypJa8MAw+UVvCZbX2yFT0IxEnBf/KUL4YmxIf2JU1M/Cbp8TjZC5tVTUS6RcfXWpSNpsF+jVJQtv3aUzpsT47aLtMKqF/MqGPdDAMuNBet1oDIO4+lbFKRDOhEgKlM0H6lHp4HTZE0tSf9bL/8n9SX6DCeBxM7fpCargEPrS2jUDm12r9ryrpBkuJXWvTqnchXB8Ao6I2RR7H+bj+DQXQ6DkTgIlsJGfuohJ+qOg/4wGPmvbmVCelLmCEaQdesyAX0nP0JY6kqj4UHqc3hEJJT3S7EkxXcXrKPNxMOmZYmGVEwsrDnLwxAk/OETHL97+flZ7ttZX8rVPxtru9z74jWEvUAENh02ieGgXeV2CyxhmFBBUqq2fljDEjUIDVfFNiT58tu3fUzXeMmZTMPxRypJP81TZsfgXsLbHCDU8cmm6hBcfL494WiByiUQfWieCqUvHJ2VSfejGBcyS3ghTWAAqF6cZPYYBiUdtdRAFbJ4h630u1enN3wzZE8EeO+YQdupNnJqv016HQawtl94QHMGzyKx16tQMpnrS6C+brtnhP4wNRYVyosdhOkid4shEEH/XVekONehjBEpDyUmYwGOJj5+C9qB1/VShyfetXQ6KMd506YiEfH/PNP+0jaYnRzljjM5cKPI/VSJFNh5rqXBwv2otWhvNVgvfCtTq5+ThrmqQYUQPFSZkjKTDpx6VO+hJbIbOUo3eLHI/O6TnwL+RJgCy25YzYcQVp6fsOcKDevHEU7MGOAnKHdw4o143fuv0wlxhnX/kdHMxxUrX+Id8MBB3h0kJU2NU/t1JKxg8OQieSEOWNyDG7aBvrsebdLtwcWy8OIXzFTtFhHTYu30P0TSTkVTBRJ8gxXnHv6OKmYtzzZjpbEkdQ2dl6/bXuEO/Bz68dFIOPn2fQPUXKRkwzhhGrIblC8qxqyqSuX+UUWEKN7eSU6g3+ydSOE0tH6YLFOI5I91oCmRqbVBwTj/snmv4pAj3CtVfh8z0HUzIZ4qLld9bB8CSH+RVOgk2xAgHerYQnDB2vPpIsX13/vWMZnDVrkPxpV6YRqmywaMg6rf/B3lZ06g0mwkZD3ze5I2B3dBTYvHjnANJuZ7EPAhSDwYDFuYKi+kk7yGoQkSTHyx9kf1Z9k3zJjxbU2ZnajLjTW6386O2hpTpDIzGx5vps7Am5JZdGyYokBPEi9H6WKLOA0wA3u0kdDoMqzdhJYY416rQn7kkxgcm3RWQJb5uQ8EbpaXmvI2hINwbRpthdXU7yAhLl5qW5Cd0GegqlDz0Z/kqpYUnOmx4fHMvhKSiH9Lir0LWf0FIo6JGgUxupSzI9bOoMHP0K4+bIvmMf1LMAZ/QnxE1Chdb8dYVPXN+mVZUvJP2HRqln/mOEObH5UvymyNbCaU8XU/GFybxOzrSASXRz2tXVhDDF2ehO0KLbiqn0xdOgmA4721ru5Qrv5vjPsJRg8+HZ4ge8cyVFZS1vsB3tMdNb2cGuf3ze4m7rUsIXXh5gcZKffamkrIwq3iz9Uq2bAORLZnS0tDVvx9ajz0+9UhTOXF4m5KoFLOVWkhAaSuERry+xHTd9qRwB8LxQ0PDncmSC3jtBVOozmGBxnZprYsJqctXJw/rqGVKz7n6Qmzm1VFsQ2n1t0tWu7JsjN+F5u8SiRIXHT2BnrLtS817QWwzBIhm2vs8BO3dzhpP+Zg4zMsgnLp23fIyHg3M0bDpQDDYNRDuyD/WHtyjsHkQBrgqWwP9uLuKb4XvZ/4/16rr7Bhg8k4iwBvUkicUkG24fC3k/1+r61JmaO+Ta/irMhjitbnNdbtGHhz8ERzDx0q0GIbhUUKDtpMN3a5DiJg7405yXye6GocJ0P3RvJjROBZM1nrR+u6fHSxUTqW7HxnQFxH/WtXjxfzEL95KH6Q2dHZgpbYQkLIaqI9jtZnVoEF3KU2bV0KsrOYM2vuMkKfiuufnGGoVvWEnWKmjnrBnGAY0CzESl9hBdfPIBuyjC74iRs4SLhL/lyHI3xcvYacL0PVkXImeguMwzUydsIHKXeWqXBKnHOdeXubd7/Hemsl63gnr8qbQoo6RJrw0GC6Ezk/wmfNhQMnyVvk5GyWfg1BZbeA/c2gRrLET/yZ5W0rfrxcoNH0rnDRwv7+ZMq2JVMY9YcdCJdtKF7dX4CbkyJ0tDAxufkhjscv79hkzGXFcOEhWN4hd8Mmxq/DyDyMncjkBvkn35qK6n7Lc6disLUfbgOINT1OVjWgQ/rACI1Vh+q15/IdXHAdjfJoab+T+LFKp0aGLfNdu1YhljaxGCNneprRgDLOejxX4i8uuCvOoINGQZomJwXtTPoHq9SEeypgl3hHV7vaIPZ0IpGTUuea/GDnm0IcPKo/zHuxaDrvJp8w8twlcTv/MYFKExoyRqByjj+NbbOnxXfbCTh3Ys0opCNrtT98wyffRqXoOfVlDdSS0G9an2oO3gUgKh2bCE3toKRGGfqAvI9XJVhBLW9fkhN6y/T3GxmWZmJJeI1v9jv0IZ7EbzN2F88ZyEKSattm44qs4YFG7cHWjV9ssscxsQPxAGxffz1ZGQofPhhW1xhREFq3a4jbfNflkBrX4aeefS5JBYxA7aRmYva1RmCWQO2/CzfObGD2NLAFbi44gmUm4KujIT4KaOX+s30+ewer6lYHsXtnlONocLlrewLoQ8c5DJtM2P6xTAO3HEluPRlAtw+XKZOq2KrYjBKV1mrDX8dLD1FFExbl7+/4eXeZXjOdDs1VSzX5JBgthyt7z/ZnWYJs7aEmWfD2W6D2bI5TkV1ITTc5QtGPBrGly8b667WM0Gjy+FQgpp/yZv0purTsRUsdjDq6bAp2AMWy+QcMafCB8nfMlKT0uo6QjSkm/iStlB78b+Aeo/QH5r54RATEKR1BklRA69GzGrSjjiCc+u37aXs4WzTa+903Wjy51JVlf34GssLY5pemek0O7+aPucjzzICq7plknQ48fOmK6SRC8uzDGYMk8QxMC7zSgwKsLvsdKlY64wy8frB9TfiYabQea+SOIR9tlLSEbEtKlzSnfUhlkfQvlDeQP/ITxsE80Dk7M9i+s2e2W8i2tKaMT2ss+k447vft2g55KlfC/2GCxID91gQE4e5kv8Kz1ThybF0hnTW2wVpZmAvbt9bPaTDrLzSEmYm9NiOjE9zVCXavkX5VKcd1+wVOqqd9RvHdfdRranslEA611PnwH+N5F7VqZYzv7ik5caKPmCj8zMeY0zlIaHKHsDcfjFkRakqLqXiGTqKWI1pie0SCy+SKrFK7aVMSERktJdZK0H3O7pt+xzTvcm93sUUhH9rlSsv7TZpALVXsZk1v8QywddvRYLZeSArBRmI3An8dsp9vJU/ng7ZLkvrmJbFtHJ7A/dLwLJTTBulnM+gLO6ddz6VVYqq1xbKOavksSWOMkvk69RY+tttjhuBWGGcGe66kUuVQGhzJYousFH18C+xUtpDQBGxTaJB5cvXAhM2KFd01VB4Fdrdm5OCCZc4gGWU4c7huMRJW7xUMK6E2WtDi9FCmC8HFw/fiT0IWoXAy9z7/ybHItSqLRNMj/yD8Wr9B0VM3FI4SIRFYOwRGyjjFuMtCV+3Tbyrwq+pbdL5x47msZcGY95uayHtvHSBV62nvRf24Grm5Old5NRiSqmYmTWOYnxwjkkYy73XpQQPt3fnf/cSDevmdXenTdAwzONlNwIyrImW5X8FmHtUWhEzfJwYv4RAyLllqkvUONU6L29lRCJfw/TUCczCXBBWM837KFQsb8hMlmkoeXCUyGHoErBjF6FdBtwZXCNZaJhzcKHd/n4Dbi9TSjCydbBzoiA8lIZkZjBEhnF1OQlZmlxEQr88QFkVZS0ZcM5BY7brz74MRA98Osi/huDE2Ki/mVCaMVELImtB3jc7Sec3n+HqH5Cv1iGcaMmsDVlmtpg2UjMgNXdVW+6UjUHThSH15rybybVMrQjC88FI74A3KEYg5w8BfHyy8y9cwDrEJqGvXxVUa2vFZCr4KFyQMkHw8CzhHl9+u59P0GkwwRNWpkUDgQckP8RHyIKzZ2kac+6cLOXvuuiU/hUo4aqq2sObKuULNnhcRv6Cb69eMNmphH+krhhoyanq0PUZ0puHwdyWwNLSCw6w0RgqDkc5trAWtjJY1VxvuS73+75XRKln7VC768Icrm4UBmspu3lhzZzoNdgpTUn9RFpd/x1LrZnBVqXy8qK+JpOBQBPr2byoz18yoRBkzhdiFoeeDUvKcS1cXNlyDEEHn+xTXUwd7Hg45pVqqcDxGQ0ccFk9h5pzWBuiwrZWybVF35NdailkuF/u9jq4Yu54NuJ5vMbFBcezeuetAv+OXcF5NDwfvv8yBIdgEYn4pyS2H62vcaE5+psSCJ4qvUboDLMrg3JckHQcO5AzYZyZwqEf65JI6Z5Nq5qVrx7pMY4OrRFV8aJt93JIF2lA2tQp4FZFxngthLaNKfqSyJAXNWJmsKjHX5JQPyY9f5OoaN8+beXtkg/JEBjaglaa9yZJtlb0VcGEZ1IEC3ZeI/ZyJl3We/5+Eam3C2Ymn6IFfhsXnVAVNGnk2m0A1c4ApkbS8mXbTfQrA22ODfyXTG62Z04JK6gxnP3c92xut+qgwqQF2mn3jyVHNw+Pus1vn8jvM/Px0+vD1XiDxYXc08X0pjD7qTTmqsznBUYjepe4yPplc7z7YqfAxPdQ8K8G7PYjz1V+aTb6x8WkRrpJTv25c7hItUxjfbCSCI23/m64fQ3nTadRzd16hxMMNdhkNE+2WEJ2r3Mj4CIgpJOqmH2iq80pwfGzGYe+ha5CP3HOO1skHof1Hq1H2c7tqylOR8u2r8nFeOf02Mg144ov/9rMKeeE1g3VJsc1IxGGAtJxkOitB+nH3HiN44wV7CbPevlaOE3Rb+64SRVG3DpbDq+bE39SI5fBmuRqcR60ExLCJqllNu2ayLQrksKeMJPCtdmffkqksLJ000ICQ6XZl3v5cWZrtpg8Hby3KfmrBm10OprlRjlwtZTe5COAW/UuhQ2lN7UtzpjKMYAoqs5BBN8QNVl9TIB2fOqIV3YwfJpBgFSO9KvMu5BTdTJPNcd+dZ37aNkK7GFIoWe9hN+C/WBFg3Eh3hWZpKXCn8BDMJH9K3fVcYsRpuIZQvPifuOSla4F/8sIs3upyb5RFj3aI6kx+C7kdmeixQB4Qp6O4ieqEGtQsrfLK2z76XH6Xj0d+Z1JQAD11md/F2G5jkKupXwn/X/U3HDdpDYG1imCXyiqmFPw+nHKvHyM3morqHsBd+nNYW+v8vtGl3Cbfs91IvCa5h4FcmmXHf2HJWa3nXJ3+/8L5KxGRdtAHSUn7Xo1EpvNZ8FkJuL5OisjDZCZlNBgpmEjHy585u9XotSFwqhKuC0Y/sO5tAxfcIj00qDy5sQkJgK8evyS7vU3MobiAqzhNVOJvH+NVzh+GXsf8XSN8ZRKpXSMuqDXPUibLwN+zV1DThXMR50IsO4ViF7RyHivzoV5IrbdJoYzykFSC7GYhgi3m18x8I2Sskq4t+7N90raGBOvN912Ojcbmx9xzK3/7D2nTJ9Ko9uBJ5mdboH4q2fl9hw3zMnvhdglAYdmOvK50+6S1pG7+ObunOtgA2trLhYoOMFJC4TXZGe0YP/yn/g4VnI6BIOiMAPPPyInf8KAcgYZDHn2mU6NKoOxuIiKVoSXg4zspjnOXO3GUwBjE2/q7bHnX/3sT9PFGygIfXCLDICLDhz6eVb2OqGJH7nAPoJgR0AKWT0f0EmNu46jJzdZ0UUxQiJpx2M8DFwhqqKA6D7vRnhn83q9TZXkfhoFPPYkWms7Z1AGYBDYq9/YcK8+QOsasORXE1ELJouUC8BohmclsliJ6lXxWGY7uO4ITRGWTVFzcOr70DU03/74svPtQeFW6MKvpEl8VXVc1dKIM9ZCGMbd1HMwYb4njzR7ZcZDph898V/Q3gsn/NQr1OuQTrTeJm50zpM5PJD3QJYN7BUhr5PW1iN77qDBp8CUnvjTPcUuLlznnQ8JhwCzjxbu1ZosKDagpy53FORH36oY3dvODgoiN/HdffoeXCO8zoy9x9i6FxnmvNo7IUrzq/AS01Zkaw8GueJ/Oa2oGIHGOqEc1NfEq+gnI2mjl0yrMNJNZ/GH2InohsiryfGSawKj5lW+1SMkVNqBagmaIZLsa0JYfQf/alTKioNnT2IngImRjII/qD4/w3DO+wLuEsd0fbdOK0q7ToatcHyVtp9v9MtXnPeW9hR+lCsSgJUPN81Enr2OAh8BV3ieWbWP2H1yqwBk3RLAOgoD62dWxRd8dBEJHQv768fNfFpG0xQ4CQS3oetPZX3X/sRJIzLf8Y4GtuWcfZOgkPw670/obcaQbo2kf4r2UaKCYkS3nukefLP6YNtOgUqJTBaCeVIHBCoV26AaFQ12VTFXzJPuhPBdPngnx/AVRUwnFgaFwW0hv3WWdZRlnvQSuCgU+bMofRfs0kFwf5XEbJUfEfIdWvidcrpM0f1iU3ISga98JM6wfrIk7WzuC6kyNKQjKVrMXSjJprZoW8vgoUVaI+5xlCtuv1mj3gHQfBYC10v4AFRBl+hcDKtLmFFeReOlR8nWSaKp3AYjAZFYbGk5jVTExpacfamXvLAnoU3tLvc10qMiDJ3iwwV/iQGMqjOy7uDsY8ptTBQsFmfWyu+sAWs1SdigUd810Rh8CHtFHA6lGEqoqalFjAzmg3j52U+UfbZLNzwWbI9gOQlbOaMwvuyRjWHdT7/LdZn48vt4RpGUlDsp8eGUzA7L1jGxP6fArX8mhmJKolSfVcCWSs9SmteMcWKx7sliCkaFYbQiBnaOQtexfEgKjevClydtvCLSR3z/Dr/TEE/OobwLvHdVoP54Zvjwh5k0D9bed6uHYumC15PxhspDw0whysPciEqJ74kugFtB0CHzvmHSTCgFc/0S6MXUUEOGuH0Cb4CW/NEYZxbRiLd4F6x0v9r4V10IT/PzIH88IjAgJGMi6Twi3W0uo0N8+EzivR6v15LjnMpHqGo8nMwN+0ACzgpyWmF/hDBIpLrLBTcsq5hWLCofVAdjtiL2fO44/qtAEsyXfysHN/nbKrr3+pMylj+ItOQ8myBO3a0eHsqR7WDpxMHBKtBUDbsvS9Ok41qjdp0iMlPORsOJnpWwzOZR30sUJttQrwZVSjTHjfC5QRNyyF+GljhpjAXmHRRKPkXP1ibVZUG9niPZXnAE9Yb2LjpahRtoO/U6mjbKCwXU9PzjkVR8OgCtr+GicSxod3iM60swrhbM/dKp2PwCF0p0WIzSUXhsmPf4uWQ7VQ9PU2H10r/nz0Y/LfJ5zd6s1SVA5t5yClTWyU0M2Tq2ooB5D78hng4F7pswgUibHPlkGw3s4AYmGFmcRoBFuv5PTQorwOsUc3yqjUwXMtVrwrg2WJdHU4eGQWfPLfJ6nITyk8Gyjq4vX4c/L3vF729XKyMSaIaJzZa8fSCbNwjNtUz5Pm5vUjMAQ/TqDZlGClNDtALLhIcOdTsaR5110VeARcH1eZkn/cdXrYYYsJWc4v45M6TtE4FGvL6dAOOM6qgSN0MDoLtVbzhKM4iNMkMpCcbwYtBVVmwKRAbJhYQpmhWLE/XkTPCiD6/sf3o6MPRtfRbMfAE8qFOtx12VNyCiiQ3pnQpPMhYF8vxqrPGE5GKS3Kk4p67uB2j3Ym9GGS0IkpyZ0naJgOcuUjmQnZ5vLz6Gk//wCT6rrxVVoXPfJSf0teX8mQ0yR3Cb2Fergbiyb1+OsTjOo3pCv91i9uAJpO/FgcCvijh4IMfnllpPG43AjP0W67XRgUALe+Uivo++9m6iPI1C1Dco/8+VzYVMDiWXcmrmK8TT8rgFx83NC0/CTBoeapur/jYAX0VMBSlcs4uORmSDs4YNAdzC3bMDVJFHBJcYojggMgRWkjC+ydoD30mjBEI6qd0tLl7q6OfK0T1H5shvNoVU/wnrg+KVWyTWq3h0AwJ0MeWL+qtyMy0FoNWhFwWNgGuZsCQbahAOtnthwfWBSpLUDQe6DcBAjP1RWucjKQqxus2Zyg/XF2tnhGJLh0XcQdl7gnqieHEqDO4+dJaZ41ocI2dE8G14iPgX1aowz/Mw9/ysgaMGP2kYtjAJBIxb0Y6M79F3pajHa8cR0Jq9RsOIIhLAPghi6ThqfbvGx0xGd7qLBkZ7azEWWbg9XvjpTgnkDZ18q4YC6crExgsQ/JnCLZRC1kRJxogKneuGVQxLtDGSIuUAaeOW2vMC5OM15KRYVqTMeevdV6gJ4e0gJ2yvxAzHBSx9JTqWvfdAREglrquoo6y3TiASCBSJiriP+wo0S3VltxYzFmTsTf5PSmJOPMSkHOed6ZEJaMWIAJrwLABuqwkj8+QTiCTYGaXKQdCDdTmHk1EX0trJqglGdiwBI45StGkikzIxNVukV/F1lbVWAXQ011XFmVQYaAdjjYYEZoIvG/UDY3VewjjtmfQGXQIX4yqU06zC/2CXk4SALZ0F8dCt+ox2satmWM5Id3nALoE7CxjxoT65a/7xm6mAzkbspzvaerSQtUtcHwb28CCpfmvI0Nd9vvZSCxlMWAXD8/X93V5mLqBahQPNJyWq0nQG5zB+U2oRzfRKSgbOoOtUgYwtnuofF+MKDrOLC2VoIgVo3olvAt8BcCpsmb0rrIxoz/RFmq4kSkk8ulP36CZVeBjjytQSyi8RJsouJwDfCLQ9Ygri1QgsUZws3gvHadBqmm53StcdkdaNBKoqP3fZKHLmWhC0XagHAUEBA6XB/sBArF0vCG5n9pTGRFdjOtFugXBKtpWhSg3fP3tnNrRd9QampD8Y811BelDz0GemJR3rZ9B2CKiJxfeR202KD2/wF3B91Vt9sDVZzY8ZCdaYaWyDcByVd3qAG0PVZ1WOnf17T5sWpfgXKKlYatP3pATdr6QAlwrv/VLmyue7Tj6wO7mVe1kGXNz1z9H6AzjoKVquO8VXEGnLXZa+sQnEIN7qLm8g9tgwiT7tZ79+zv0Mbk+q8aXXPib42uORIJ/Gy698eDER9SI94RBM23AlrbFG2PF2DqwzGpICUEU6TILeSVf/Hmk9okp3wWIt1a8f0hOTqVUFxah1J5riAfycUYT7dro6yDWSmtIp14jbOjUUEpPYh7cU9a0mmG+47WAiRD5y6psHmP3BZcJBktH8hRDZUuZ5U9/CBnzTLswm7S7qZjQI0dDyraYgMFypjsOnMIucq28wcZjwsg2MRBBpyn65ktcQfuTJOLwE73DEUzqUPmlno4+nv2+YiM1XWpRnesb48vh277YbZPwJdM8k/bV+Sc3WTgsgAfXT9emXa0jDP8VquYE0GBoz1vMdO1qlbg8ISvFBRTEaj8dmw1NbDh9lGfoZrDgwdaAGhrJLSTgcmpuANpvEBd3Myo/FvgoGBIsxlnqLCc94mdCQBftyXmleLc/FnAKSKYGyUo+9xxnF0/mdagLOyGuQSmYg0WLJfERc92islXtsWkqGChAjO1ud2Q8Nn2RUIP6RsqPTkT5tKAIZJaVQA2H2uWSeazHva3+GVDBYjzCSRPuS7cVbEVOTPqpn23jFhGPgEy7TKU74/wtJ3S4agPg+RfcsEVjYfD4bB/URkO3orcFxMLtwMOAbVjA4J4wmwLKPhm26WbhA8wKBoYtPHwLGn4CAk1GzacMCzp3oW522QhXIxRwNPwXzibhsFpQtsIx/e2L5XrF+BR+TaaXdnPOiukaBN92X2/W3DBE9HQEEsEwtWshFVDvvD5bPc7YHGw3O1rRr2e3drOhrxY/Flu/UnSC+EUU4iaXg0etU/FzJNzo//VT7XcAbtmb6VSpZ8UOEhOyUafDVpi2z3Hz6urY6a6Ah0hm35Ma+Ga78J9z5mxuKeT5m095X8MCK9xyzjKA+82omqlgAFjelPFSAkDWBLcwMhdpsQ10rUTbWdeVH543WsI6UXpf7iHInEb6vaOKIwI4LFT8qF87wZbW2lJKMtA9p+/CXtBI4Rqf0s8JSH8UAeJ4weM3vMNTzHS56FM1MrjXrVbjkxA2GvV4VF1IZUHpkRooRRgabSUjEUe4HOgbcortH9zuaQLbJOxSa/NBJVqN3LqPgTDs5ieBZvgP6HwoUmUubAEMLCsWhr/5LOAu6+4uHV6SetAFv0pDl8zkea7IO9BE8SwI4cb95u9isjCCA2+5Do9vECx/rQga7T3/BPg+Zk4AaQMZwxdVQrUSZgIt5lojjkx+WMiszC6U+YXn+WtgyHOy5+o4x3ltd5Sy3mMfIPHN23TEgQeOBPPVlFx02yhBca+Bpjxag1uzVdv39tlxjiwZReIhgGXzRMf48wY8kXyBonn5JL5a3qq2fO63hOstCLVw0q24YcA0oqQsfq5Ram2Ci+gXUsOV1GznqvXd3lDJFiRJuaXvWXY/dzu1/eO6vb49cRea8oQkZ1CgifuSZwlgOq6WY6a/jn2oLhrl29ecYAf4+J8PtLjKfd1f2i1+pj5g08+lLsuGAn2BtKXJYIRO3oqGVm5jfNI3m1V+DJd6CNYMiI6EPal1MFsPOOXXkzlswEJmq1rRxrwM6Z3W9wpYrdwjY7HBALuln+n6SKXGzkI2ROkB+MDShQ/u2mTAe3wdLcy/yHLbg6MP+wvTxGA+vJmsydNoSKBHv6xjhrY1sJMy1Ql681/Q+wF7foihI9jUhXRkPRjxBI8a4UO0w0HzA8xMTfHaFAd1hENPJ7TArvNQivgpHk4dv/SlwjFwzLG16JfHHocwuF9BaMgdw1ZqdCxxmngWEeVIzKeXFQeN0ApIQ4fuaELl45WDaGLlSdJmzn9hQT6qEaJxy4zMbp+X8OM6JgE+OH+RfVZD8o//h0ZCEGZyibfTeLZ1sFe/hCn709cLpvsfkhLl4mehcRnWv9pIW/YstWeTY3bcFyN0hTIbu05bM1f4oFUjPc5uZg/sjcNLMKNSw3zo8mSOOfjdDcCkFNUqtIPHgJgS0H6JBbBrDducvt7t39Czv4Cib79S22qiaNmYJj+IyxFIRG1N+DUbjyVf/MwVG1lo/ZGVI+/BLNb2XRZDpSm/u5EZE670Nclzs77u7U2jzKCdQQnf//jauD8B2tiXh1ynGeRCXfBzGZgWEGDpNyuSs1W4eY/fB6fUEEcz8whw9RtiCNXaP+p5xEAdxfq8hy3M9Mm/IqoXBnz6HvVizUL4vevUbpmEJ27zQxKhv0y9iVUDgmGhzyGGFyvqPkiJmx49chVLBs9O1lPMG4VXxcqySGiF3VHRNi349/nYTxXuTcDRBwfVSJPX2YXCmERe6E31wHKfc5UKXl8nkTLFQiCQepsNsJTdllCjTRHZOrJKxBelhW/rWkS8oTXFXhKQThnBxp6Uc/JDFINIH3OFZhe3UPezTaEb/6r+7AD+cA4eAHvOk7QltANpmg+p/+fiV+aEAE4enyY9JuB+Ypvf2+xpcrcnSqBGoFKyRWLgQX6ESqZJ7B8NuPe6PdUZFxbGgOq8A28zlxbcLqY/8QNjRKMmC9fi7Xj+K0Pn1j7bAh1z1JKi3vkrnlFlU0E5KdfFaOLbP6wOTbFQ5qyjHaAoWn0PoH2MytGnuo241jPOUmtm/n3CvYEiRhvAybGODWZZVLwdUOstpnzgeIebpa1nLCocp6o7HS2tus+SOuP3qTCbh750mFTT0XL+aDdtXZK/dKPD8Yar3FMIEx5pi7dwKxlBYnTFjuu6Vn5S2NI8pHdqTed9PuqR3h+bO6aHqbvD+uzOmWXzJaryIIokSDoxwKB+84khHbILxvtFOIfFc+65HAUWXoCn5feuAo1QoO6IPcPlYu/e/kL2HuOwMz05zkChwQOin+m89IJicaVkT1nbWfXZpPGFlBzqJNV0+ZI20SokE51X18BGHkQO1MZvuJd4oAKC7t7vQAJ5dAAafR60DAvTQdFAGPh5NUDFVTMLI7JSO7lUQ8ZXtNahpmj1mJlkUP/Oqz/op1N6fa4xHVPwQSY4imEueAngKHMt3nqAd6UlegyOf2H77aRXvWkw6NYZWQQRf8m562MfHoayRSX2OsLX48p1fWfMEZXMSkbWgsHpBFfaiBgQ6b45UEACR9sQTk7LAD9/8Vx9MVhxSV3DU/jDn1WrY9OKw/2YMq2dNZPBPd5YJyrxGGVfnGZ/EEmVG/7BgvfIRgU9B6Gl29gsgb0FAJa9a0zMOBWvbrOoL0k8llmbohRk+knEACOq2w3p04jrUXVpuA8zK8/pwQZ4CFsGmCebvMD7Y/FhVriJsj7sjq/R6//zWUsDcIEG/bi3kVIiCz2SyGOTBJHc6c+3nuUrbsCQacAyCqMVkT4ku0juqc4qA0CW76N1s55smbhGorD4JTI1Vk1djtM7hF5Bd1mT/kgTttegSQJnbVmBhb0v/yfhsxPdNwS3bPOcxHoBqjCWfpjKwoEJtCJREnhgljtANAmsVZx1/WdR+WOEh9gmKoR3SGUTWUu78sSiT+EpcXdQHmEeGf2jUHXXTd7twVkddbNXyvQhfFckkqgTIm8TqpSFlLCyqMgGUvFGB8RCUeg9tiprnsR8FCTE1tdfLEkJCz6PTdW7Hw4KA3M1TfWVKUDRvASxYeYDzsZVNwYECR2rpFC36bN7AZMv6Bop0SGeaxDv480tf1O6XwgkaU2m6n/1t6QBL5mNgJz77qYwipudixnNFTcqGvpKpfvX1d/1NZhp6F1ZDTFsibCf8K2/Yh1jYN68b0nTrjdQEYFETRVowrx/oCwnLzC9lB4PdCfEQOkoFaiVePc+/1z0DIhc+vwOsvr5+xT7VcybrZGphVw4uN2MBoqSC9rJTfN8kYcWwHAHID+hhQs5jPcBi36q1EwZx96rgk1vx1DDxbJb476NoMwCkooi/8sV1lE++mEOa425Vdy3/u1rIqZcWgPy0D2n5MTjmsJRzb1bPvYlhkcO5Gj+sPSiav6KJyfsftT0fdGhlJA3jYgKQrddapWYKt8VNrbvXKcHi0/v7Ic7OC9UWe6SpUPyU0aWHRu0AqcgIwNBUmx5qTg9tt36cwv14KzFX0pW7O3p1lOgwmsbrZGKD8D7Pvrgr1pvutciqOj7Nls/iDX3LYGopLd5VORVOaW7nXxVvpMAyHCAWl18S2zJShUnCiwxWm1w0o9QT+kojuFM0ZiSUlM/f7kxlnloJHKNaY30I5HUdvxhvNwcb7CMm9oHerSJ7UHr+/gLwlxYEgv8HFqojcFM6kh42oIgqq0k43eDmTQXz2rZNERTjshodTglUkPTTr9q67MVXk0WFJBqyf+dxQC2q1rOyHAlk9mICQttOdXp2NZrt4fajeARj3rLrnJa9fAKgyKOAm/5w1v/g3CqDxo3RRfucUVxY8Brhul9LbaGGtWNmOv1EEx/3lZDona6Tb6zZwZFo84V9ocndRRviFPe1vJBAmKyuLoEOco3mKeDtSvLf0q20L96dYN+yZk1oUmJGI42lesIDkNSNHtjks/puUXr10Z8LJwbNQMvZiYXOAxjTx4MTb8ql1Eo0OL8G4lbifdpCLJdQklok7k5Rcg2zJBxzV/HpueC29VeGp8AIGJHxpzlnqxTi4/fxr3JGuhyb2Z3NbJxSMHLTu9BbD9YkNwpk9Kb1/ZpQjzlWDQE29MyioANvMgU4aUfKX8mrQXmxfRwB2+dM5nqtb3G0SKdbla/zxtphWRMslGQ218gynwHcjmxE2QK1966KVNqcVKH8geCZpnYpeK0zevb+wBH5na3wTs+S/yD39WgxNNmVIQltIiIgwDdNsrz1X/W1+A6XrCNOzwAQBTya/HHSWeEmlo9bOs847DaWDBNhkZp3NpMLQwDFvcr5KVQphTIh5YsY+8ne3rIGqMTvl3NbJzQJKZM4rSQhmOcLLEUlUdbd7lEg4QG2fsBqEegjWuuGF3Qn5RcCFGNnv3jbxBP7+s6O+TE16Ex8xX2Rt3mlWQj+K2n49ANKDQp9ErJHaMN3xbcEbK5ci9STU2m3hO2LJYADoOX+uYjF7bu/urflAyzMfdaTMNHdrTiY/wD/WInQMBGgvnCNxr3isu3+wTnMRQewLlnLXi/pO1CMMCfG02cIJ//GQ7m44Gz6abJb/2ps2uU5k5oB4zAFzIAsJVqoU85TBuOYbtwZNBoYMUjVnGctsKAu4R8tsY3UYn91sqa5uIRiFSwUntJfoAhRgN2wQgdA3AbnlbrMSInOKC1uf8nUZ7MkLLdJKCCxrnSwpOpUPBkPvq47g2z5AhkoDGz0BTKtQO/slRcer0ILJknsXBQ6TRKpl/q0yWzqYvxpk/VTQfji2QcnD95IG6DMhRi7euk96AkTV3ymzVarNyzf4exwjt5UCn4WOzGOs/0WN3gF7++FibksuRD83Nyg11he8B7RCU1zNaBnJx/ot2O8vyylYTNThyEdQWai2JzztqZ6QbjGdjzFuwxMZbLZ8nbct9b8qapK+RiO6V+ho2aHtK0+mrVcZNKomqAobE5zTC+ZW0TtyXM2ADGJpmGWVl9jDC6DmaJWLVXc5nnPW7vhRUsa/a0I2rOt9fQ0s72S11UarPIgRTK1Kf/z1XsakTPboSV8gDOzOmYuU1GtstoT9Afgwtd/SYoqgMG3ZWsay3NVC78w06LzjH2Hia2ugOnVNns4Fk5u0R8+iuTvT5OXXTYIEiL4JgmlYDq+tyhzssLuf6ZVupwyWyOaMtuOUNDpmgsXyJ8CP3bv2gk4Y5Rt/qUloD5Q2wSASoBzzp6vUa5dhZI4JTJ9McfDDIIbl4EugEqiQQSoQnoU18eouE20hkmVc0YruPwOVVo0GlvKrTaGJZ4H5cHO4X4HqUhoZXtlAHt1vkXi5vvLcrbyoUbR6ltYoQUHHBodiKPj71STXMb6KiZgByzre5FVLZIIfQ8b1bw0eZYndB6y5jlfmjCMvw6VDB1o30tP5NeAQozrVU7Wt0mhypv/OawCpGyACY8u/Kk8O5+UaFLzRihbt7yGoD8Kktghw/n800AX3imIJR7om8EDrCVKlRp5+QG8LBpng8Kk82maDQxZj401wMCg54pdxB8qjKCXsD3oNvjhnU/Y7hIy7EZx3Z6QuCCy8XH+12TCzGLrYn0WXDSXP60bEhMp8LSWsPh5I3b5zqxnyQLkxho/aX70bwo9CPQ/YUh0mCUqLAXWvLUn+rBTz9qW+yEILDiaJbtsJXK5yQCfzfjV1ShV6TUVQRqiScAX4BtlRX9bbDoC/c8mCdklogCZREq40kRuCp5ILVQZMWVmIYSRftIyGT9cHoNaOWDglPT9Hn4SRljygUTT3Z8f3AVmwkHn2fdj1Grm3R7ogMNE5C3R9vXJJNZHw4/8X5vFbDljCU15l20u2gl9p0AHex4dJex740YGpz0aJg4soHBjoGr4gYXFKO33CCpndFqWiWYUfeeRB6mwNgOn8hrWLarjCAMlQYkvo4/mBDyHBtNqKzArbYAd5UbpOi+MA706CkR0JfG6BaFyOJgMMJjs/gru2K5SSapyDG0atoB+WCajY/sSB6xzdS5MgFDg9ej0C9jt0fhDupjXAjVr+JEe14bhboLpS54beSxjqu2GCqrSC1PDCxcAidh9m+xyhJdKwdsmdDfmH/w8BaSpFSOV48ox9JzEYuH37+fayTAVbQSgIQ8zCpCvG87V5qI/uNpCbA5LGSd7ua76z2whKaOU3HvLaJm8JXzFi28x861gfc2+hC+bwve8MEf1uPsW/9llLdo/RJI2Vv7eHlIiuI1dEOkghK2aPmN4BrjGqzL1JjhMWT9s5S6JPTjIXHbBljJKtxffMnLtMgoWqVo/QXsnIXYEC0w23LgPvhaTGW+P6Jyh2PZs3UHgRga6mfBu9xMR/wjIJEf4zvK2SOrLONEei8dca2AqJSCUn1cuid0tdlupjyhNLkYev6ZgIu/Nc1xjwHVXFJ577ZnK9fQSmjCweZFJTAIyYCVo8K7VvPqw+tB64/wLnDD5n5Yha6IP4qSqsJbPb35YIGwpNUrkXFy3CRZqpsCzzYQpCW7qwP+ScVwI67UnnJOALz8jS0yeCfqk766m5FPS5BAYLRfNtpwh7oJ4C7AMfjsc1bGLFPsmpHXx/iBTIMxo3DK5MBV9+Ht1nrl1T7I1nIun5HcSyZ7foN2vLWIqsuPuqWzaYASQL8HmoziSStwPhwy1P0P0jbcmrR3JipTl2XWpkKENtsWPESClM6Z/ss1dCAoWmnBWjYdOyHHwoY+skKqKDEkNZQaomL1os2ZQdnT3yzQloMaqB8oUvAqTJI0sydFH2EzM/EIglOCpSjsXxtG7x9YF9SamjUgXf6XAcf5BcSFiRh2nXDHfBdd2XYj3NzwKTflRKQ0BhAcBS6ljJ6iH3hCkNXa+l2gCtbgUF0jykfwX3Uy1k+AJ+eR6J+JUaA9dq6PoxY6Nyer6PjHYlDD9NbU6Qwdb9j6p/7u28a8Kd1K0v0nStyVR+WJDae6y24m5ieoQTbiqqkNv/s9cKHyOsj2smTZ+VvIobU8m9/ivnWrWJ87y+0KJcqdLLLmrtQ+uKW05B0mJ6wRubZPZg3oxIYmjdIVs3LJr72qNx63N0mN+CV3ZPo4jimee6i5+TbEK8vuupWXmt5aAVOV8YOd+9q9Vvsv93FjnCrknBl7tm0eDC0i6MugSsXr+JxlpJE2g1NNqEjs6sjuxGCydanJHc9PIYO1zKuZR5j/aeY1Sp09p0ltoe5c+ZCyj1mVkwmHEFOSTT7XVPi3irkKB8XtJdDZQaOs+V7Aa9AVydopdFfHr1o2q8B7Rkg9tGClnSz7WfY49QmINiX+Gjs79+CGcUiiPo9VKyB5bPA1t0un2+EZ3yOm+vCNR5npvfRc8B0Nksaa1WhfWWNqmNqvlrHGeRIQsPW5fIop3ezCakoUZFd8WZk30HXoSTKfFf8Ol8MRGWxiUlBQLMCnQ/2fvI3ajreqg5nSQqqGBIOiD87C9R9H+V8O5YJQOmmPsTxCRAnUVXFs9F1aIe8FbrBMAQJ0dCxzk5wCpVCgX6Bh5FiOyKOSc3HfpUEBkvbIJtpxxN1PRMIpZsIPBbn1gSRNr1GGGiRQ2tkUKc1H8Hv523gm9KRh0CfB1pV6e1LmR0MAVmzVMJqlVl+IWbHdSQMk755TfokdcuAitF+vOOEk+pS5jR4BAaBqyYaBSEqFpTTou8tQ9fuE7OAK08lmyRbxPGvoMHnk7XyyZpLEz1u4K7GwBx/94nZk5IuTk5jo1cVk7NjbqHwAUNXbG1fWOhmyDZNktns1Vel5Uz76ws1UUKzzJS0TynmC8eRYoQtP1Di1gCZDF1y7mZ+0gFzVLDbA4mIOJdpBBuSxLY+Haa5bxibJC7vhA99RUBt6q/dmWZDtq5ZRVmkNFSAXX6KeCXb9UPvyTcp6quhfUOLUMabZDMfJF2RW759I052SlcE/6FvLXr3lXxx7cGFi/CgUtOJtzUVaMtl8puZ4JGLGLxLrBpPFZDntqiKsqi3ZHmOqUCGnoemoq48snqnY/WiUKj/EyZCU1JNu8rk/yaaQmlp22Q2hwmWBn7j8yyrW4NbHjfexx4xT4ph++s8kQwvuAQHCgJr9BGObRlgsfvbm3NVgbzxwtErxAiLuXuboY/De9catVCSkbmX2fd2HBCdhXkFHJVuzgqVh20GIYIqVst4y1ZgQxKowOqwJnrcfhKl52DSd4DIuIjkGXk+l+7ostmhECGft5057unwPgcaujWrPM4iY2ntwlDEPfDJStETTsw1A+yTFlNqgHdWwz56S1fGv06XApGpIl9FeeTXcEll7mzR9XHauHFAGRiY8WCzpuANIGsu8X5pxr5IurjQ8HNajKvNBLaTSqQ1ggdsPmvM9AE+SirqHKWmaKpggUP8MpsjMhzZDg4ml6qzHdnxMghL1j4khU5lZPsu7so8r33k4BmxzLZuBEYC/N47J7aq6kwyzEFW1QbuQ3GYj9bTZRZqcwrh/vZq/caYs+OtLS9nvUACwDBEKI4fu8rFbCAbYZApjFepzDIsWUYo+h/smraB8nnijg5V9SJMdpVad1EoXca+6mNeLDpKe1Rza6vFt5BGPuF6IOZv9oIE+baMe2k3V5kkPB/KvlfGs/3ok6ZyjJtt6URUIYvfxr9lGDri2FzNCOAlmxtoH5aBXfqKNf/JxDSW/Te5giUWFFRM8uAOTzw9ubVCFYh8QszRKnKTpOuSmVoj7vtpMCOCSE/Mf8zRmiDwxi1idC6IFc45e3JzpYjIJDKyxKwmPGEZHPYlxkB/l7BIYz5Azv3RPDOy19bydfNP6qvfnJaO7F1TkODtnHJa5Ymgig6xcQd90kw2+nfv9cb/NGPzucs123kXd47JJKwFw+cEniYvYaJmmvTPw3dVBGQ+D2eukni+7JI83Dxkx6uIPmGIioX+5R66mcYsO9xGnPISGRP3Du5tgkJyTDcSZDt7r7fmKoBsn8B4dp704R8je/wqPlwYeCUQQU0wj8x7FHhc8N3WY331wsREH87D1xVB4TPDkvULcnSzCXx9nPpRWBDb5nBXyPhmlF7twFO6DUoq0WEkzTprEB6xW1fd5a81rQyxLB74qObKPEmdCK+BTXfxvafLprcucqSgnOHi+b4VQx8ZUUk3WJduF6E/yBHjItaYp/fJn+KBmA7Rk5Rvw95WN4lQaf45C41G7V4AI63vXfZ1/9kudwAs6rL6CeUdkp2r9j/FL8bOFwkiJPh/pwRy8Vl16qon1+tRNGyWCx/PfjpOaaaxZlzID1i3VJyA45aSmh0dulmkv6HP+E4aFalw5/cfHNw2V9xV2hvNuSQn5NSycADFfWQKXPjQnenLCXuR7VOitDZ3Pt5ezzZCMy1wXVWHxR/Yxz66yZfQTk55TzPV8TzBq47TI43O43tyn9qiCk2+j/+j4KbcvOW/OwszjCzK0SURXoQJye1w08/ktuXdaLyoZq+I/EAanNtyeTtjoxrZ94B3XJZRO1Tid0zX/WBRTyG6QMox1Fmt7pjj2tw+2DnAo9QDQl9pkj9OcB2ihv8IUNg+uKdpP9Ihav1n/q3QltjhFZiNW8h6j8uw5xMf1EZm4hMYgWawmeMgWcKsdd5rvMaFMvWVUjMGMakoRdWyWQx7+ICGoHtTPfea6WtaWVyywhX/AfndkAi6S9WnBxSy1yaaBxllny0asEHsvtljrCAHTM4SiMcCjKZedA2tV+RTFNDDmg8Ga1fLpnNysRY68ZfCiGFuoy9kgnWqvwZ3OpU4Q0+aHjzxaNha47qdcjAp69s6ec/qJlu9bKWwKlMLSkZ2tt6Czd+Byi9vaZdHT4astuXduNC8njAfhUhTof46T8k/PSOyQadTr1F2Gej/PZqgmjI9+s8/bQSb29G/woIm5eKwu8PQzgnywowwjDvxNg5QFyBcpco+NKngYNqCcU8FBoNXsxCuglsvXMa3Y1t3FMKQ5P1YpeaEqWJauKdF7UANd9CZdGX/19fOMZ9SDhUezY+WA0n4ciNRIAQyReFJKXR9SkIwG9Os1NKIshMKgxujCi7TFki1o3aSa3UISmXjPf4aLIRFM6Zh7P4po5cwW1NorRZDwi5zDc53ne/Yc0vWaGmUNHGHbFv4idV8+UhUygg2oryLIbRt4B6bBYIj8dzCgsOMhooL2aZFvKgEQoMxeAMAkKLouuVEvZLyXMWFIYxlW2u+MjxGqjyPAd7/B4wH1FAl7eD8k34WBtuVUV4+G5jsdDqb2BL/Si70TulKOTVb6ZbuWboqC6I/siDkvXgCmkASM/NHmGGESwZxSfaG1bQUbhpNQ6vtxspEXQCyQroMj80L57VnD/IOa8/zXXA0wq8zHG+/690t/LDTaxOTlFrVdn1Y7QjZTvCnmMuZnNGOB9HZ8FSJucoUQpgROcAYfRnhxYq0rYvhR0AibRw7oLKzBmuo8SA7lqecIs5zrEy5L4QbOs9bFPmlX7CM3J6YYziWKNCjkwjzqNihotn/HnhDM/CMI1nZtEwC6JqvCjaZXcQmbYP/cgFFUfdHjmVcebPbdS6oFSYouBrTR/gNn6urbTv5+clU3GPHVeDT6SkV9M+dN7gCUgWCcBCmV2GYImZRSh8GeBMAVdoaXfoZ88Wzurc1d4LXj3t3Pvcrz6kt8fItoAzbGJvuezsCfTGkc9kjcQhYvugtEHIL7evmsMaCmsg/qhWixq8GfNr/+40z9oMJwGWVa2AxYHF9oTq8J/LfLuChpScRK4/eNOBpoXEy1E3XMyTdzmgPVFV+6tq2r+SMd2n1BcPNbc11UJM+NG18Dt84DBNDTPF/deQHEXUwD7KCv6DGgGXNSImd8/456ZRg59pEW7chG2IcwXomT+sk6egCzBGcl0cRelpgJ0CY/9AZmYRLQh3qET1mPrqVvEHPLvOk6US3dg5xSI6imZv2X1NcrefjbfPRge9J0S2i8pMJx7T3lqOjm6LdmR730rF5obMOTPMRCK1xSD7Hx1/WDsGDT54F+pEO5CDru1KDO78W7F2RZXWx4TzN1X/ZrCEH/DjGkquQ5v1yjZLMpZOQzGNe5jopX5wDOdOOKu7hsAHohuPcdxfKwb9UE47gQAYB9yOO/uROdaFNLF4HMSATA0rj7fVlazlX0gTpi7tgIDg2lMvbOTrxJjz3wJ9rh9M6etfprTXNz6FynNCQZeVelKMPBZa5blaYSG7QFlwyIOxtwssfj2unPpCq3kkGZDr88AhqdUMV9cZbIQLvpswcDZeLvprddGD1ZX3iB/TZ/HUuK4pe7segKYQijtDlsiKU3BE5muHs0o8VjHSkeEJvS6pT3apIeso7J8oHjPOp78ONNAozZRyiADBUmPeH94vUWzbL1WKy2bpFb8/M0Rj43isGAJlbOuE/cu3VKrz+Qh8h7jXK7HFNoLQR58h+84YmdrL7Gw2NsQlxZM6EmVaaAV0QF/ztOpwhXXCM1R61k8GNFlrcSN42Ose2T/WotQpataPCs3zodJjJ5SL27k2CeOUbEr+yChegAuj06YXzsZadrCQ06MSJpyikG60k/rzeb8iPUvEkdhswPaO9G17a4WAgNMpee3RmYFJvzpZ0Dml4T82xWuhITIQX1Yfw+fQxrfrsuL6NWCpCEREHPPhSYfWJ8ugOv937zt1yT/d5sX2s8XkpNGUzLePGbZOrXsS0w21g6Eij2m0Ch7mPb3RPYnGRxj9kaBLAn36Ffkv4YvwLOeOqf0UVu2fJ+KLtWZISEbd8q+uOV0diH0dJHKpC74o3lIyPJA07kz9oq21TR1Yw/qmcDGyF3Q7SwhJyAwpQDl05m+XV/gQ3/4eLHOlJ/fwCryzuWdXNZe4zJw5jQiyOQ3muvk3+dcOHGd/aVuJQvCrDznCoqr8Fqs1XhwYNFHzEMR9XPCgxfAWkyOzrxWf7O0iplhjD5jUYbcAAnTpFw/1XkTcLlvaD+zsMjDr5jTOCSWLsh+mFPgo2gAZT3/ynkasIYxOWzCxntHLvwKA0+vDj36UAKktV+tF7pc3Og5FPozPVSqqheagl/zy2iR5fy/EIaxKOJSyQYDPPO+Yhjw9oXkQjxCoQt4TybZ4TXU6spaoPDoiJPFBg753qpOoja8Ba3kWa/7NacxvJi4sGP/N68N4NxmjbwPjzGt0Gn+BBJsKJraDtNtE4LMoCGt504qDEP+Vz11lr092DTxaH05nrDS4RewTWdVeeBm/3YozmpCLW3mfj8zln9E2wuC2dZlXEbk1MhZhzH+UQ+0+Lvuws3KbM6TU04IwacvUNq0GhsqeQVChYg0TrZ5gBiwGL+PXht+RaQenw1bEHsRCuIj3L8Os4phtZfD9rCJ6Px3VXhPXSe/gKtwoKO3YaIksPooBYb0Jdez5gXu0nGT7tG8WBHaZ+v7Mkxzi0R2BBgxioplZG/ReRKMlVX3GlRZLweXct999HUC0/CV/YQPq2hgWFF+DhvIJPWnCHVFaz67N8SJIpsqYrxMIr2l6MoF/vhQG4PRGNFkegytEluznj4z/a361SJ3XeCJqbCG13kPHF8FtMjA5bFpvP/QtU020xxGpem/QLF5w5BjCXupmP7qNfuOBGUc4LOO/gxnRgdmkwMX2cxyLhpJ2o7uwLmiw1jDm3DMVPquVInJdwQGopTtPylYlmHhCbzmLurQi1iGH4N7emZjtn/kpPWoAX+LkmGTFzFFjxfiuNnJjvRhtCkk5hQexYwRhdQ58KD+hxh0m9bGrSZGEEULMtG0mw6nb9KiRWvP2VKz5D7gpIq4UqXSErQZLdCf2ghLeSBujqCrYrKZZagIaOC7Ij9AbmT4I6jwcP+h5+kF+HkwnwKy/yp+QXruGNMB9xKsoZEa81CUz7/QYLvpqd/XqTeCatvJnJuI1hPpvqYmySpXmpRaCUOna2+bAMCtAhXoJxa6eMjxqKJ5qafA0GFmHAxfJJVQ4SN7z3wVsaaIeVJvAaCsYHd71fZLqastdfYw2qCBdW0xh6D8wNAU8Z94sza42BmUNDW4r5riFcfmRBEeJEMJHBQ2gWfQrnnjoruAoQ2DNA0555zhmxDXtWDHFCOl6YnXXi4Ai2+cgWAIWOBAKgKKX6/y9Z0tqe2FIEHp1sipnRFyFwDXl18ZEFzB/bBoQ6I4eGyFfwp96XJiWujmNjqnLWAuy1aV10IKLQNU1cboLaJGb6UzMdoGUJOpSE1VsQIWvPlLsV9TqB+kYwprwYTpOHwLMv/AfbVjaPv55nH7J9x82BT4EU0WG8CloWWb9Zg1Vh6PiWsMzundA2nkUKa4ALa5p+1mhTwVa93aKlZ/yWTQkGYPWAHsU18jDENHdTPXL7rKENMSzyiVt4T84JNoTd82kGOzadovNr5UWzwvSYVN49HMQ3bvJMSkeDCREvDOSgcml+PyQ+zKJWyOVnriXt3T07zgdULYsqRMAj8bEEqFl6qlUJSsukRWGlEjMEf7b2UTpXyhvnfGrlsBAT2/MkoWK+8N8PlYpeFNOjAz4bfbv7PUOlf3rYOpLXMQML2lRqWFK2dWjyNdv1PYXu7A/bESOHS4q4jZx9ZqY4kOkfZeA82UOnz/9542LVyf9jDQKNaFT6qGonpIDYP7jHTG4c/ShNRVxIDNTmbVf6t9gUSHtQIcFubEgdn3BpqOq/Vgt0HU20fiYJ1ihDitNw8rOx4b2G64PzHMptG+1xdm40RpNMdMY2hmxBEMNn6/5y8xbLBD42v53x1EQ0MNoCaV5LKa827Ys1RB/Gcy5F5U6LEzPgFl65Q/3yv0bmn7emnSNmXs7/GKNzSWE9XSeY0zqJ1cz3F/RVHfztt63OypOhIJzj/UDfqcluvyKdWBGoIVegNIVXbWjFeUDhkFbRxWUGh42zLAMmf0u8teZDZfFhsBabSK+xdH1PsbaZ/6jM3eNBHIQQmKdTXkNnl6N5/T6PYiP9dvsdwzR7pQuCvER0N8Zx8DPEA2mapvv3qtTDsTmSx34MOOzYS4pNc+iUR7kgrVtSJTaJBOcytJdOVHvApZclPXjYLkiEcNZn5LxoxFiZEm4CFhI15kcpe5zfPJ+Z/nPyUccp1sMyVAu79smNKUXFX9Rk1JI4sGtEUzQZ5yYs7t7lXkwwjDJBilmAGLAqC16aZ0MKYvEh8Zy0qg1SxgkQOQAO5sCeN1vidFICB3GyyVoqAy593wBLenS5FYjK5LgBjghqvzCK7oOms0xauaF9AeeDJQ1ogNpYhV4rh2zio1hjHA6CdNjR2qz6RdkHuaeJsW+vr8ziz5NxPU0NsNlnD3mBl16kNavWnAshCKV7TsvD3bbX1HJSSyXjgf3vps07g5XBuZ/yAdlWQAj3gykX/+eu0e/uyGJIB5e5XaIwyc/LcpdJ1xYX/ND1jIruRSlSTCCCvBDf2xPZGVXX2BjnWBQi3+PNJJ8dgLz5bxmNhpbsSc1giXQHW49tt3nwBtXjV6B8zMjxoQqA4ioXJ6zsOXNdZW29CyM0W7Pi1ZRTx45sUSoxD97tlSVSg+QO0vBc5YtFh3CyileJh2+ZgwcysyMQMNucExKmgmMr2nXYsmJbfws9OIt9oVglmgknYt5DMkZefkxCuBZVJ1THfOmtdvn3VjSEv/KRwRGtJSfZr0Rt6pnhqi8YEAQp8coejhBdAOkvwom1ogA6yPljKsHOUk+GEQN8NrzamMe9NZO99eXqRpgobUiKH6k6EJiwJiJFWY2XNCSqNVLXEm1Nc/2VNYjbeuwERsO3Nz7NxOI6/+MOrVuVCl3ET4WJXy2HwVTFUFR/44uY2iusV94T1vpJY4JnIoYAWE62WsgqWdEArSAY83UqxBnQbtxwj//vBQFIYUBPBohbxrQrTK+Fc8Km8Aty/RZMxIpZ2ZiW4JOZ0WlqPb4Zg+PncxCX7wQ8iNcAfXSA6RcOWo8M80WAl6ijVIvK+5ny3UiGOZZPoOQf/qDZgVRnJZp+yk3SpTzgDiXa5j+lkSx3Z2A6F/gjB+stPMwuQ5ggwAJO7DBGG75BFXXrctPrZ2EYjdYFf+MFr+QusOe/p3jdbQAEVn1/OMZnyQTRxgU0R7E6/4eUJWSNwFbpYta+MnPMC8omXdhVXSat3P7CFgOvooSzIwvhc8ESPZq729A9/DY3sRrMGM3rfevdkT4ZS121JdindnUrR3YDdG7dHG9KsjH1WixpB4hxPPzE/Wc1X/HHQbMeyE/N2zs1NTpk6SiUReReZoWZWeTFytvE4cYsH1uhjL7Z1COxka0qlqJIzsaXuu3uRubKFAfGeB/N7MVKm4AmhltIF4JMaOcWzbs2w5mWHwulwbZ+2OHlRqJIiLIX/HXqW7o3rbahkpsf/iiKKYCtjFFh4qQRlF9jXnQymq9Mmwkvu1WMavN5uu10pJUTfVPCpVoBYKWEdhfObSRL5ZCqCckWbZ/IIW0OhJO3k7ocUmQeQqRiIAlDr/cnvIHxHMvjWumFwRwbHpCgo7XHhKCk4dYFHfpDAfbotNzP9CQB+W76BTOUrn5Jty8Uf4RK5dQC98VaK4L3JyJi0Sx+DGujMVPAsBcsvK+g6pXR1ACxw2Yzx59jPQHejFoImOtxno4lWL/q572KCtnu+HHTBnhe5+zEXEDWAjemAIoNi68kGgx2mmNZj1yYk5W+RwmWnPIpiAC1x2PIA9CJoZTPMbpHE6C9E0V+t5ozgn511TRmmzvqJhjPs+SM/U85THW2hjocpYGqGMaE4V6ufncqz0r4a55rhvjPM4jpzKdBADbmZWraBTHT+pUvEAWOk66zZrBAlkaM/PcsJ51McVhFAZGzniHHSP0LOHIfhPxzC16cQfAL+wmDnd9yPCIHQ+JtkZoQpPVfABzSmnjhTu7AHQ090bYBgN7qVVeBuxHZgZ6w1a0zSSs77rC32bCiqcHT7D3rpf7WWhUnZGdhlQUGRM+tidDDRqqFAOUZrSRfW3GRmS6G/YzcuPMy44u6Tn8RANgnCOfstM+r2DV/K8yV9wWCRXwCgyaFKzYGxa+hJkmbG+X2D8NaOVDIUOepdrjNfjwsMxT8Us/jsE4Ld2i6VXYrOH8rG7QjHiDl9yjb+UotkvW53OjIldJfGAtpn4ZeKbNHT+cBsuMue91WCbEwuOihe9Ma9ewh2DpG0NcdLIsak2NQSk0KoaTmHMOfT3cttLcNfqDI5RMLSoZ/bZpiWeWuyfYkQiJ9FP2SpTZfwl7XcKdCJUUVRNpFwaoAO3lnOVena8dtNHBD6Or0pn0wwU3xokphPIc9T0zL6za/30DkQiKZrZIBf3pAIGanP6SmikB2lhgNAr8GHTmH1yUQDpQSq265chxeiZaBoJJceJdyFyH86ykFpeA6KXym2N164ZmkPDURJkvMMvkmeEuArBmoXBbnhFiPh+mBOqX5jArB0/0OeKcrEbFVf4+2al2Y+OMhy75v90Y6o3FIGbN1kdPyjtl1l7Jmz4CE4R1+vSZJElWPACowcAHNSvPzQX6vkP+w+FRiS4tjWMhJhDom3ZNJEu5OO6JUBUvAsxOj5eCqOHrJYD3O3mST4pYkQtZEl6hFAk+Y6tajZT8iqDrcSAp4NMWxstAt6phpLAGg0GbrsFqp3f3n9qQLbkWJmJaUcvU+rS3yE5iRNXkAl6Ha9jUQ+J9cXhtX5IEHfjvBeodfYDQABm6HmI1DsbnmDzUngKCK8Dtc6+H4YQSZEdf2XG+vbE4f0LNsdZf+XBrNhnVoShSsGz1QfZqinLY+gs8ewkCDc8Wq6nizYVWdjfh+T6GVo/RxS8O6rQDLNRHxmw6AswnYAmC2DlxJWsCAfDQXWVJQSyBkCUO0Nhay2WoiDbT12XmilLU8S39dtLJrnQdRVb+w4pTuASXmSJq+7bbKr0Sw/qrA8lmL62VQEyrG6ZgV5wbOOmRc54dQd/OZnPG9gGGsvC9jvpx9uzP6inTuDJhtvBnsozXNHKZt5sFSdmhoz5Bza6nLIXAHQuxBThhnon6og2owDqUiDcrnupVhMgM1lsK1qDVMiY6PiZsxGkQwQorIciv483TRFCyZYJzt7/DU0F3f7F9/XOSsTeH2Idp28NKYeMZq1IqBKKwkNgW3APe859dckLaAsXSBAbShbgz/MBFvAUOZiQ3BFC+nLijBmkzrQaCayL3f0rR2+TaNbs0HtKhiUXjgd7DXN3KX44Ht3iYL42cR1P3Z6o7CR6f42ao1dWz0d6lkC/I7hhj+N5s/oPMzfWfo+CrGsoEg/mgE9N3pcxI8oaSJ7mCRUoHGjRgO99OIjRt3OuL8mNXF4GfiIeGfK7mYQpHuRawcMKC6Uwgp2utTgnnl/GHJSvfU/V3+XK01bi4A7rivusH2C/E3Psec7NB5dEQQZSL3/0VNm4KnPYBECQNNN6eOslD+aQGJ4kNcBt64r7OcNpLbDF+9i7AG4c+ie9hY8NqOTZz+GfybJdy0vfVgmRhm654SmVgY/rr//F9pojswH75w79HdQJuQTCo/wRJyRmQsrmXpz+Tr+Wg5oDW6hdR4bzXG5fuGF8PMO9XjKb+zG5rG6B9OiVibWYgTC7UJIJObnNPzMZZgjeAMkCZu9YZmlqxvref3CgcHaGwOlgR9FI8JRsMoi47U+xtqnbnDiObGvMEol8c42UZxLfBpo5fwz42SW3XyZsJMVuFgYUmCDIh8j2k96Mc4C0+eDSBanySpXpJ7RNtWfxccLjQi12donqn0kmudM+LVrR762vjsf+XSP8LbAFb9+X0iVfAdv9zUuwxwlY0DaxrBBhtAIi6drpNv5dVxyxOuH4lyLdbzatKEpjX5jV4JsuZTaXIIMwZCQ0pmHqjNT/ppD+WXLAVxi9HIB7OWGO26zxIPNnNBtboWylUnf8DXiGIIYtnsfKCA5APvSQwvXoOGUYeuiYeu5hdWRg57VaQbxd20pMkEJXCveXY6JOamPftylPMQeP46j7Ek+2scfQqlazh330bR0AYno74Nri5/rIjJIum+YSBNwomDgK+XQPtbaY13/bDhHf5ParqFVHGB88yGXCCpANfh6YLJ9r/zxPP7iifeG9QyzJ02RnSxTlyf1viF+Q7967lAzaWitkl/qKFPAcFCqpFWoNMxF5UGb6NJ1TCCBW4e703HJfZztQ9k4O6yWl+NDC19p3kcFJxYfQuv3J11oxRVcgHBUeQCZ23N89ChS7vmgw6hnv+RRUH99KpQ57WGNjxspKeTHUYY9jAfTF9SV1TFzx0VBuCxcgdHNkH6Fme8H9qTVU6m917Rn5SZQNyjYOXExmaA65EJS29HYGf8iDMidTNgtKbE1kooDRWyzGyTnlZPZq2vDGQNhpBjg//8+RHWSc8pwzB24OvkLzIwD3wtjNn30nb4TxFN5oQE/RAiYahuavuemi7QFDkD1uVf/shakPrYXLEU3VoG8i2VK6SKS5WsGhFLII0Kwn6J/kT4AF7SST6Lb6XgG0Sj0sk5vwIia/gdAli5pIHnygwnJCRP+5c/PHKymSOzy9l8ehhSRJguXIwLjXI3hsKmIZB0/kgTFNg2+CJAKAzV7naKDtft9r4FumDuWUuBV2VARMBqv412G/MqQ7d3+MBbbTRSPMLIes/5+4L4FijoRJZIQght5Gb8SoRX1szSWP4nnKM3q3LwnjtVG42prrDH/pspFC1eac2LLNBF1fuDaVWj50Tc+iIb9/qJiJy2VlbesgigXvrXSjEzF8uyk/Z6RuehEuW2o7ycuXcU35+Ibb2EtN7Gjux5COIYUR/vOIiD9KIcJolDXBrKy7vfcT3QJymojwQtXpwAbJ/bZCuDfuPW7ul2fz0XJ0xisGAmW6TN+DivgtG624Xp+OMb2M1w28MVUHJBrMovr7KnN+sRJJOlOE391PN3j02p8WrnpvDd5EUQTI/T3AwN5J4e0W4GXrbK/VkCfpN4ICBwhbgsCL/MtcmxMW9WQ3uc3LUwX7tx0aX2d57mtDuKTkmYjWwoLAD2vHCT49jFIAD9WFr72DgMRUfBUWfMEzU+wH4cobMbApIAIUWaTLyk5pKl0pGATM2/HCrSu4QKJZSn+45dyXd9ur65tNpZNNaPfpUcQvZwtUhwrF2s1LombJAIoJbPoFcthqdQmjpPLxAb16e+e1aE7HScojvdos2Yv+SIpYD0WwjtohuKKZVnv7rhYCMt5qLniVPTElM+UNX8kvwJl382cPPPMgzy1UDDT3aP4O75DC4pzJsN6cim81HSyooKYNgxWHgehiOtWUQExmi8UkOF2WIejy20arRyRDj42QnbmpY1e1z8FUceOIZaWMR2V4uhe/0bKHtytxTpgZBgLO3zzf89oC3dozKsjoWXF7ASl/Mr81j9u1/9H6iOkHiusxqZDYR1H6mNI4FqD2RCd7TYvLqt0UtF1FRwxO0eQtGcYiHM2XaIGyjiBnwkpMW0xu2em0T19nxcV7ILXpg7TXpI4wNnSUBBtkmB2kvK+94QPzwDN6zrc9kz11vtXHBrQtR5QQH5bcu1ljA9IC4Vm0P82jnXFFJ0ykQL55hCRWfIonF+TS27RA0r3PrxFVNygRGo6YEjH4xe7C5oomtknIyna2ST8jI4nRtKIR3rE5Xrh9ytUNT0EASaBa1PSe0eftMNy/s3IENc8wv8DoX2qnTHhc6s0pwPjwuIcVauXME0ztYR7BBIrdrgXlwHwwRSbFFi0uFrIYlWplGBeoKLjc5NQL/22P9Cfmi3mCrIycALrGMFbGfb6LynsGGAQ4HPub9I8gE8kBLE2SEXFBRfrV2s6fpFz7TyWOfpbfy/HqdOILUvztdYQGbjTfh3xB9EgmPCyy6TC8WXXtKz54EW58/BWArPahP6ZHP1fPQPQ+U349SwufxLqdoKZOgnff39ZbZFfoyV+khkyafMpyyOzUuaf9ZHzJ4GyQ/hicV5G62+d1p2Q3LtiuqpdadyWM5UFKU7/t/BHqf0wDahRAPIpp293RZIfrrXA3tEK7tyCjgAsZgtyAxnicFdobCK4/nd2f7zklkT68EsjtmGmedB9tdrmaHE45ORHyvCOLSWuHpNbM86uC7qIZKKy0tEJ4hrHmYoVjTqjLAlwGwwL1q3u7q5t159Z/pKdOEVrsrk/a6MzO6ZDNwNfiJJWeo5iGrrWaPNwH5922IDFnLbZrP81SvZvLgIVS6Avs2wWU8wA69YPuFNu6o6tt6oQ10vNXVZw2IEwmn2eZdYkYBG9rpfj8piFkdJIpbsQAtatuQMF2ooGrKgHltHYFaii2HyXX+MbIo0Mi/kn3PKcmikDeWfsBsP+zUBP7SF3BMP6ZEhGcYC6jbiXm+At38r/NWXkszPNlJwQ27Td66JOxPDZD9iDRusey8bcfIIBCprBU2erR87YUkTRjePtZb3/Z1fswjQC1oJJSMxCPoT+wo0An2vQnx2xUlFCm+GfOgxMaqgY55TWksKJN6eWAlAmENauF5s8NXguz6ZDCGKCZ2gC2duepYfbZjLv6uftYcC/8vLOF3QYThMEDQ/XRu1pK3ZJ+nw8MzJ30Hd/5X5YmaHGXCS/845BYW/iLKvwcEOmr/iShxB0eBf19I+QzpNOHpZmgL7yXKYIcJd22P7NuikO8Ub6TQOPyCqVovcAoAO2YgdqyVPxG5/kwcLF4tz4pN9tOsH274xKZc9RL9YCm2cF04pZ7yuj3HCOcDT8bQnPvqkYIZIh+MA8R10ZVffTVRdzyChwkGnrtGVOtZkJ4XxsluoBFNkPMrNDMSUxO425UMdA7ezgN9fN0SIzKaIJEme6NBUScdP5p0RkxhpD4fsxfNOhzCgXizG2R+EFalPsTVBhctTBgcGUYEZmSheOQ1EFyOdGZ4++jvA/Odu2rkcMcvvb6wPAtJa6oIIwclbiGPOMx4u1Pa879glBjqdivR9Igr+hRExiUJQKc9FU7LcVMcldX/JFX1ZDmdT/256MMvrAMdR7AL6D0TKrXGHHys5T0hsTcIBWrVu8Acv3rpQiszFufaMczL8bxM8bmvj7YmgWmgM8ffszHOe1XrW/m8Cw2tjx7l/vuB8qKI9WGPLvq2TYuSjDdeC/4YkkxOJAuDR6+woHwWAaAbEfB41F9+7GFE3wHqoghUJ/+fHniGSFIxJMrDBJt5raJC+zh4QDcJ+TbvUnOQIDA3k1vpKusJhFejPDgbCsAOSEILvQNC84LbbFh9yQ5PHhayjtPfbiyaEzsWeG/6A3hjCKfP/cERA8PY1PApDebqBzSdUqQ2ZnpbdhsGw5wfw/tfy2DjWP+b5b3vNORtgRdWuIAcoOsNaeS9jtgl6/0e7lP8SomTqcMyZ4rHa/OlBKcMLDvkoffvExyuJp9AbMUuxtdhPH66cs5djAP1idwSyLlG+Hg6/ZyfYUsUyXNvfs5FemeBZXdXiv1Vw20kehkcseL8dvVes9mnRIWay2fIjTSL1bBsIRkWafln/7vF8+vQyJdilycAFEhehKyRCxkTHGKFAKrkGzSy/xPUqu8o6u57lVQG4thtse+iLr1HxaVfLwQ1rL6ul3yQ4ACy4qfqUz9f7L4008vAx3kRMTXKNyx469dYZUFJAwnQDcYCOvRaoKb6q+w8vDO2TxhomIh4HRsU4xi4YaXi5JXlRH47TSyA8R2RQTfCCpYbv37qYwusx+n+UZpPJJoHXSj2lEcLBIct0cx/7k+Lht3i+LJLoc4tYhAgKuIruaXa16w8HxZG01At5vlPn5iuuwr7CeTJrqFiWAGbtdzvKPpZXIb3vbBnUVYZh44gJkm8kz3T2g82WsylinGlqzr03ZBVIjU08RAG/Fi3eAizcrY9hXYYMxT3XIteEcvJI2VEoDFrlcCklMYGlbHQtyN5h4JB8323HdJ/vIk+SbQ0jH1FY8080XSadVz92IQnX+Qaz+58nKoITeIbsQwDCB7Q43kxm5u4n8/Y6uMk4KZ5PsWakVB+c57ETFddrU8lzco4a3dZUxxV7rJLXs3b1C6awBBR+nluLLWvPBWRY2Up4URugRLXm6vccIRN0Ke4DcoqeiFNaES/wMl6hEpzLDt7pSNDU4e/loZsrzaB/tYH23OJu8NburjK0G2C0vp2xl8UKtatLOfFzOcAcJ4F4YIeoGbE+yJ2kmst4dmu/XVTlM2H9ODyrHmMqa4rWJLry6+VYnBDAHAJAjct8JAFgSL+YKGGeBy12GQCx2317NpPguiXQYJhMxBgJmFVV0HgLrYI5jCmQmkjzrgxRNGI2yymWWu2CprYgERIAZSWs/60skykPNVsLVYtiO0biks2xVYlNIdVFssctqlXSKK9NYZUaBW92BczPtZWq6smAD9cmmo4dwOoVt8IkEQsiWP8eZtCPPhyWRYI22CkZVbgqXvYp1OF7a6nm5iuzLOHjuKpfkhbHc4tFUy0xQw3krvFmEcLTj+5jomZueZaukZTeUci1Q5PEmCmPnbex7h3w+k6j4p3ZNJYllIOMa+lHlyfYQxS7lcwcVOCt33ZQeYbuMLLgrMJuE011J1bNey5eiqDVRSbX4siBvUGiISJf7geUYJJRiXXPJ3kxHY/LDs7V6ugKlEDkoQEO1KL8Ta+EBWsHCEwSMKm051+PhRVOcOIx55SYFUchwDuVrLbQhGIXD10fnuFTMq/DuUTiJ2ulIQy3R4b9R5fCg/70NbB7tnIwjLZeh7MMdA8b4FMLF73INaFunCgFCdi6YWqPMne8qnGrXf7+ZNfQY1gBt277r1AApSjZI0R6CLNegwmmNnSsaZcqsUEo7paY6LogZJIAJytYhAn/fHteCE4N2qCLvjQuSn9FVSahvT3/KIjrmx8gEd3kIllpK75VLx+Gffd9qmpxeWpfFBLDJEs9aPMSCMnCIo5C3FHTJc8jNASugrx0oKydkTqEorfyTfG2Lm2QyEfpFhpiwK9mn8b/s1PEidAYqSCgKbnQAPOdd+qSRM0oBmAprOOaw5uCPKfcbKTFKjnV6S3j015J33B1dD48goM1piNE8dByBMp8012lzCBPaxPFO8NjNtsfrzzN84FH/UXbthtTMu72myJLQNT2n0E8E5q+V9hBO2TjOJn34Pr+sBnzpXQBGXKr/x3VwlKnivpEgczqTE/1NLBL79yqh28vCyu3lYvTs/btmOYhUpcMjEGx8vxWQTBixeqqJ7G/YuGpD2NeWyDCjKgPJ3e9F1zBnM/rmCaVSSCm6XSmqAzXrZjrtyZ7p+8lkAg82XPuH4fW6gt4pZbvHoB+pEdbzFUUyTfTro7E8aNa/Wmbepef06MPBrYjVeY8JLjPiZQKpPuDDKCXjQ7XG5L1fjFlQnCBlgNphJ+OqAgaIkmmPm3bAgUDZV4t8FnMbs5HDGBQqtEYqRkGeXJorYBPc/JZ+R5rJfDGs9mN2e0/e94QfwaBY9J2fm7Tvef2a0AwWzG/9i6qvugBJnztCPHNcRdSzJ5AtIvilTb8X73XDh4itNjWxgUHzI4xvrqRJksO7BFOdnIlMkDNKK5CpdmWHtWpenSNxfp5psmW1wKutV/VPdflG7kpu55phPxTDANphfur4cr4Lo/6RW1RTTC/cZsb+EoKRs+VqJnqalrsL8AbxA81aursYALzspOn79eOMdKYMpmMEDNZPLKUvheMT9LrzrE7BOxWHeNugHUP9J7mJ8y3HMedXRTTllJwp6zybKOBfZrd11hpraIqAJlpa7Y/uLfrK6dlOZj29+wvHK3OOPOnosdDId4ZdGLp9RORzIlgr8YjsB5T630Vj1nVNKAVzJmUN3fTV7t9bhVSOCyP+OkyJcmHhZImbZMNHW9wfQXbapO9xTRreAXkl/S31svFZF5rlxZ88sNRdFGMx/fYEmwZKpfBDqJTijc1tM8TrqrWy7E8G0PW5qEKLbwcwusdIcFfpWmuFySXFrNc4HtAr4HGiIdWJrC9RofXgZjIP/ig2o0YPbHTwhbUvKsmBmjEDoSXzCVNtGn5H+nhpXxzLsFOa495csfkts5gSeSpyJ/Z3nFMAGsdvSh7N77l18zULJ6y9v6LzBGFJD0jlyGzodkOICLOgls2QMVKQQ8gi9PfUmDfLl95Z1Qo7NPtctZehykRxZDDQB+tc2DauiJ5KLqxghSvmG2QGjQIzADaXn8T2I8mTgd6xHp1+0fdb6508Je6+Jws2+AQEPxiTau1S+MhtHUqGnLG5bq8xMoKFPHIWP779mFN1Zqazc/9tPj6uJnX/PLQMu7UjBCqfONk9zZCTZR8ujo36CbzhzNyrAaWETd79LFdU642zgaoXJaFdaVqOuXSBXG81jquDMQ2VBMI2WKuLpTshFaGfGW0djvnyjHH8iq7/hSQv+R8njOBScmQBl/9uO+Dw1SxyfBGOinjMaBGaF4R1Zm/fVsJFqgNUKzt5xN0agP1kELQ0PJ5VbPHVSHTDG71z6PGPfUukkYg96deYUBCJwQLpGQBryvNFQFVxTNeE4oLRR7o8AWAv5sZrrZjhBjGbyNsMC5cfZvW+P0JS0v/KEDyINcotg8b0zE3Od85x+TkvHLZCtbGyMa5TDUEFZPN5a73EANRusXD2t0SqkpPNFKxHBK2uOa9fkF+j4/Zn+LlvHnheTz8e0wbqh0chR3AV9DkOb5+QE8iH+F7DhBS0k5X42sJLreCIq5HQDyZsUqvEduTmRamK9NzQiexmmARazxnTh9Jm9v6slZsd0MiflX80htdJB7sfm0+fNxalfa6icAojuRq5dnUZrzNqcaRrSPmNxjysq3c1m3zuoP7YspCCr4XKVsegn16iQmBd2dHgwkytO7REJaT7t3gDxCtB69E5Dmww/ryReTuffiVhLZ6DtBbxaM5Ztf2IGQ+Qx4EhMcHfsXZoLxMSf+x/I/Q3QZ0P85SPhhKKI/4/YJ+uve6SE9yn0fyur8lw8IqA/GvWhztxJTsqyXMO1X5aWq0tCD2b10sCXGsZ4DVMHvYcIqcBX8ufhm5f1/CgLHBMNtcTgkJXepmuTjpbaZybeCECk0Vjo50e/knWj1fHIHb9EloahUI5nauVp1E/ZyGGalEW9x5ZUQeQRNivILaod4iwGKVeVy10tnsuQ0c4jtoa0Zt1l7aYVnVZirKMsdzSGk8OrMNpjs6AOxH0S3FFsH8wn2fhHZpBVJPgg3N0sM05zNbbnRAJGJV9AoJ/LYmHLsLWK49dQMBIhpdV6o6rDCzzFovMiZ5duDEiRyuwLImYBs9cWxyk2Ol/bXUdimnMhGyROYIPo/aUetq9nO/OeYrx7PvBnfzF9iDzXGUI6dhMebmiAJd1YejW51qNddSqlcpcOy8eKH2ZKQwk0sXuzxdSV3Qb1Qnxzi7TG/a5GTNvxB+jZnv53nXdY0knhIPL/YTS9WJEBRURxtiUSZaV15RIKTCZjH10fCPnOg8hfH8JeZKJ7dgMAk8nRMH5f8FFCf4SKFCpzBiiCjhv+IosZmXN37ts0X47p9tzEAGSi6ikke0tDI7qAecWlJgjyjTiOA65X89psKdWtwNQG0f0ULx6QRY+tTYfX8Yq6GNXKN8oDcyL1sEHjyfQCCZJCcvHOQqeBenjszHmkdG3RFzyg8VlcZCSw8hCZsgyqHzHKdiE6zYxPgjjfSgVOwyV98PJUru6pQhKrjlmFx6sZpWatIAVCDkFKtYtKbb41GXXSYIKNKF3DxTlMbvlhnnP34k+DHE+eKogr63nOnzTePZxRA0hwd9SgVafQa91DLJm1vDvQQiRgXM4e5zxFD6viIZ11exfHuY5EWccQ5sZfdHGkGrxo2pPuM30m+IkOfnG0kimCN2SkWl+oS+Abiq3X3b8Uv27R48HeDUomAQUrevRUzhM7n6Cphadzyu2EQYKPIgFDWb+p+qDtJE0DTF9gczPR95K1POG2u0Z0/KVzly7zFOtkqQeTCEf4gmetaU4oreMxFs/NC+aTOt9bVCBcXcSOiD5JOD8J8t69RNxj2tfqvh0ZrYYpik1UU3RfY5itd+5w/XUxSvRLZ6Mn02ENREfw/+nE412YQgK8ZWwELyEVDsaS5JyF26Wyq/f6aiYovV+7517F7NatqLVtgZM4yOj/AuRSOgkqI63h1nTksZN/pyJwZXolluffTe7PM4BXga8YV4xpEgETJOzhW0ysQX7jBG1/5eRVnFR0tGe6bEvy+H2GKWKDN5+HEn3gNiHdEkA8WEwYcHhMPkLV7yG+H8SibgwsbBZTs7tKzvWwdGIy7e8SKFw+zyGeiWSGn6xm1qDVC2dRpvyAx8b/Vt+rSqy0uPsToo3S2y6pK7hz/ZKOfnEJdC0NQ2M6ELURr9ezDdpN1VHVQz8wWMJOrvmVF8HzSB/oyNBclpokfTda87LduCYvAiCAl5bm24B3pAm+yaR6dIkAiiFoVeepRXgHBN+VYIgyFzOFpQRLpCO4W8e35g4ripeLGIXY8pgRMkd9M/HZEcjV2BGhzI936LZG4TF5bUtvA59682lKh8p5EJM4VT7o3r6dGXELFSfHLVUfo7ORkE7lbj2ff9yhVae0N6V8to4WvNVRtXzvTg1qDR2WOvRdoSORKoIubKlMe7VVIonf2ynRyg1XTxCxP3VpJVmLcnHoICsrPv+ST5XVwvk/+TooU1KU3xrZ4DgnflV1NXd3YLZqp9AAAZ7QsRWiM1kesVqBD6MBxV4ML7VXDg2jSOsg8jlPYs3F4yKJOTPbn71cwugspyEGfZfpfRs08YnrL1Or/6F/ixn9Bx8/pnNPgLn+RUHrPJuxGbQRNUIFmeOqzsJuBKVJWZb8QCAVPE2TMsBHmCTyBK5ELn+fJ4dOV0DLBo5I4q/ME4mmd5/lzD69cAtQoncp/hbx7Fbd3EIRrM9E87xtiU6OD9ivehHeapLq0xez8C2j9iXdbll1e09QfIVqc+goN6F9EJy1DLDjQs6Oy8/jtDpKc+LjWkH0oUhIqxGMoqJxlo1QWERaMVkoyQMrYoa7xYaU+DRpBE0PEgrsbPzYEugXx6ZoezbwEcZ/O/uPlC5DCshanfj7RQQKp92da/tiHxSgqltNTMGRHLpstM5gIr65uvFxEC1tR7o4cw/Ej0l14EiFkMIW1/zb7Qb5f07cgrMLGnc6L+pf8FoVO8YMG4z/tutKbalN0HiXeqW7Yo54eUJBJXV3RuOyXKTy5BfEAb88hwBV7virPfN5aaYT6XSBnOMyXY82NXNP6rC2MuPDMGVqifYLfC7oy5jaK5YKEIm98smeZzlOVfBCKOdXh/VN1IUIHVd3yRZwTvUj/K6t4M2LPLeZ/1KR5quA4NJcyVh01WKvbbeyrLEEkzqBsiLejJUeTOR+MX4cKDhtSDnU9Mg9uFD0ekpXlQ3+litY8MQXecJSFdYLdkQdcVZh9ZQ3hsQLeJ33xSKEpoBSAFSs0n3jg1uPdttK5sGupml4kHlWPhTYw0Yd2jhkQv/wE4H3QvifePvPW2khcw7y9ZQecEBZ16oAoxSuu1UXbRgYYRtuEhP+25NvJb/+OJRTpGtKRsqVLzIDXdnRCuaHBfuybrUsyvDDGPWvrUQqxv2a5HX9MRn3dhYsI2ru9dpsVToovGvaJTSsT8GKrZdxmuR4Goq3re71lGrl2CfXUcYFlTo1v0Ep7Mc+CVRtRT/twvZBqU2zpogl4iEbswFepikzrnnN9fkUOhhzlUXtRId+pRc+TXw1r0qo1PTfrWVEI4V/VNg3nkbSiHBu8/MsN3aSVEmGZw4Rw7qmdy3xugDb97E9yhPJ5kwmZ4emw+PZDDpKR5Zwt91y/lT1JABJ+9p6dus4iUXO9scOALNmQa+tx7xpAiLKPvUsHPqS24+qzPzv1Fm+fufXIm99CWeF1Z++h8utRFygGD+IDLvWrzDmqVy44QO4fPHm5GMMfn8l1G/z7POu54c8BoJboy664FnIBVDlIGbco5zcN6DJvGL5vIDLrBf5TdA7TlRj/FC37znBPbgEdOUwmS3sxmtB9MNXIHRcpFE0tM8BCWLGZ/cC+q5VGrXgF0vDI6W/yp26gKgp4xYupDDgqkmGGu07ol+AOpsgt9Lj/R6ZCcG31xZp0S8ChAKGYAEeGPzTIx5iAmYmLf4UXa09g20EP7cNWay1uCxR8nS+sQ572x53AhAJOkqM2xqqxeLyyObyfQmbowwWRWETt4x9lf11LgBJcSgy4CmkP5Gzd5viNd6ZnUQGnc85jG1dibmBOR6W8byAOAiMemp54c3LEE1xUBK3LNseufIdtVvJEZFfe0DtVQDCH6cQGowjTlGZMnZdxQNSlAddzUX1CMhWeAmWoOOCsnDtNiQDmfqA2rOEXDONXdDZ9jtkj0smA2nKASy0qja4i99EO5554Ym7zLIbLAFcGXQa4muf6PmwctfGcwmjRs1rjii4GYSkYzSThKvmYEUOZqSI9affiAMW1RBlgKHcSIuf5X4TwTrLjF3vTC2XVy9Mg8+kMSD3qrc4ccEl8el+981oADpTfL/fuRGyPHhJy3+pD19QZv4vchKWiOoDu41A66PbkErV9s0q4VJlyaSZWBkptjwfXci464OiEK6V5iTsD0yHAfAkA/KBMAU9hCM83XE/h3bqsHxuM0nq46wT84kmmOiOOAjtpPSHo9ipAncLMISeNgrlir6Y1gvdFJmAvFbkJu+nhm/1uKX162Fm7ngFsKXU7DhQoE/M/gyENe4klIq3LwTzEGIYnlQnuX4SoJnFLASsiYAWp6bStIfpSKb80Mk1QmzF7qwQ/28hM/PYujLVr3VYWMq6izTApELrqFN6hM6Lx96/IHZi6iVSEeIVe9/O2IX8ZXOqB38FoAw9ZNRx+oO7SqEh3dRE47lp8qsasRmmb0jm2/dJyoLibZ5RxszI6sD9tVazfx2k65IoB6FoNXvHFzhEYuaeV5/lllhRnKvfF7kWthCeS3A3SxhFeHHstP7gU7qU+qaE2LEPR7gddZXqt0FFptt4DHTjz7JLXu/rjN+68uDJTcH7v5ivp2g01+ux0lNOlHhwl+reUVTx1p3oJBO2zuDNheI1nHTpl9lJsO3wtkcq5SX66ra5B26ku/NurF8pvu7MDjEv/mrC0u8OGlmUtqAG2KtV+GO0C4bfUJ+xXFDB7x/yI002ifB9t/gCy7JFJslIb3g8vNRyudhjNjlgzJvoG54BPLtjqhsC46Sj9S0/hmg5k14OJSB0suVeE7KNWwZSPRtlNJx67s8aypZ6ps4xAxM7wpDvDYRtFzRKKbwhbSciAcZ/bpK/8wzcUVXbcEcLlb1XgUKcqOkMuxs4KD4rPHnSjeoNOo3vN7YqRKeURSgol+IWq1I7+xQWmUgItPnv1onQCEZbXjygCbtlUDJQz0y1toWfhIhOwYvRNVfemfMo8rPeQbn1pLwKg9rT30Sdt3cGqBaH3daLSDWsoQ/Zslk6+ZE4yIi9gz0iFh8XyJkpG04ZJ1cGSlJjaYndHg9L4DftiTY1ksZMKa4HWuv51y2nS0g7yrgmYnRJHFhIRyvgt/aKTxSaAr690UXoduWTf0989tQxglBsAm7bo/B47qTEhJjgWQMetIcZ+ceSnYGet9w/OByHuXRM0p4cx/zgl6woYKP0OHV3qJxK9YIs2fkQYokud88dTHcFBrbFeLFiN13rAM0U/XIWazsgCsB3VYxik1kXsIYj1eQI1ECMnOMr4mv+IMpInbKxvJYsNu6cfgQzcqrgXgirjQsZ1By5deCMNkrq9Du9cgXxWlas1D9/cEbwWKUo0tUCFi3YYmQZI0NW+hwI7RXvD9An5oFP3mlzAQn4xIrNJRAj3iLVWNGPXrXZOZoPq2RQuOv444+JZ0KaLuzPzYxSDB2ynFMvpTq70WeopEfndBghWrt1elRSRFxiOUvOwNWXCiFIrVvPd8kEKS0rqUtMy03poy1/GH37qwp94SqNxcoeJatDorrzOpdL/AVDss15LOqwSQUc3TlNUYOcef3y0ZV1fina9beDTSc95H7rpka2HOtKDGJ2sB8HD80NKezddQJYvmBrpK/2mhNRN6W8dapDwMN6ZSgWYubSTaXbe2yRZChBOH55TF5jwdTv43nEsF7ZrCpM4yZnMB7nKpAq9zkkLUKzqcOQMXonPpU9d0178yTiQ1kK/koYBYwGsCooN9waJxwjn2KNqa5cm+ZjplRt2qf4XJmmid0EdSEn7ThqVdnfERbJawuW6jYU648BvOP6n6/xofSvwqBoRjZ+OqHi/HoDxDbSD6dEVNCIeXtbgKxjAPX4BPAIXkf0kuyLeaohFxPAMkkgU5FCkwAXXcRYZJx43cTFHrV99zcfMj+PjpuAgShMueRoJA2Q1V5y0mBcSUcOYOVrhRGj72Cp0NhnX15iqHBMfKX5hDFllQdsHcDrkqip0dSu+49ZWw9QfuymsGURCxpUX2Gq87V+ZbG0VePlyJsBDyMuxYbVKnyesN1z3oJJBnzQBDlbysXG/gOZl1pI6QccHCWPydLM+7wZr6/VPVftLaXaAPpllAeGV+OXEwt/o5eaBt/fTvBtnOreikdmRCtAfO/qEi8hFwLEtTYemwAnXwTc0lzBIPr1rat56wiy9nnbIXAhJJ1NtxMVTIHkDUMpf3FzDIdDU4Z/nPcFSpCXLpW3sgyVMz52pC1Dh+BLEcD8Mb2Uzje3saldf2poYnrMsik1YknpO9sIVv4JGLuWTVMPuxy7mUOm5liE7fmTx4dBCxCKDm30NyBrQv/ee0GJgReYOdAAxZ55Ieiiioxu2WSyp0cG+DAm+7S45M0xr75Uz9AeIQzTvwlmHWS769nhP17ncK/O+gsAeZkbU/U7ehnb3l+ngR3eJc6f5coC8iwKIDuE+HNyw767MQyuOaAzpQbNjDRUAWOgpADfaZxHDkhBE0ZScNqvnQlFRtnSB8XYE8g3bUIgmYEPUz+sr+gnh9O+THWHt+v41k/xdB7LUqr+g9zmNpKe+o7LzNFyY6MhoXlyD99V+LvzTBAFmNOam6R96bn8E6sWukOv6KQFlqCwiABz4tNc6nJI8xwt1sCN7OB3fjjIJijK+clnqfB4sqtmMr5h36zTBwTu7Smp2dKIIftu8hgAvwOB0j4GjIRyXUHfvc7oIYELMzWRrevy5cCNY3wsi9jWzBgdScR3WxaEYSD2aDoWyiWyUvuD7fka3OP/Ht2WNx861TWAvkFf7XZZc8IILIfqu547OxG0o0kLO3Jtp63hogZe6S3R1R66wFKR8oBhXM5BzHO3tLsSXH9Yz9eh8nyUjXo07Lq+VQDieeTvlRTHiu5HpuqndzoT8rTQEqxgS134+xafyiEN1jEyoeLlp+ab07GBuRSKVfMYApBDQ8cUZMgi+WEbVqdwYuwWzILm/dVDzCLYnH2BXF1WZL6qaA2mSpyYEkz+Q9wS8U6iH6aDkbYxhwmZM5qS+zDGrOw8bJD77ZW772sxyKm8k+nwSVLrARQDkQVlr8ZVl8zFNZiJHor4JGR+T3jnFJUfodCcAOVTQ6fF5JGQ2qGuURbAFXxe06ykKydXD1quU6FF1YBARqwdqTomJIqs6+GbPmrSWUHXFhCCHgqQ9JFcSn+vT6Wz74EkRFF7sboTdLgKdiIvMX9/aO92gGNRlleUZ3iz72bQEq2bFBj6yofkQQ4+kFLsMYsQey0riKjPOG+esrW+5TulCeywC1Snzup/i74MOXvL8Gvo0YyW0MUn8OZAdUnZHmtWeHp/BQ/IjceXPN1XFGx6Bb6O7VaudY4ldC4R8t/IBuOWx8ohsOjCU8uT9jqROLNEyq4HPqxk+yA8rH8yOwn9IKRLtYmICSdJTDILjXqYyX8fv3LOg10enVaeCqmqKg9F0uRkl9vLWC4mC0bHY1E5PUVcU78kFPt/kTstUZOzZGoYEPdXvs7S7NGWzwer6+NvswX4KmLqrMcJiMgvALG6j7lLBh0MzveJ5qPs8vyr3DBP8ULidCNoXpigA76OXgEeQq2qTg3mTpzPI8cF96lL90A/X4k1qJy4l8aON/bGNCvVyNDHicD9xaLdkSXZJaCYG2JU2F88MiME383HRrc2GCP1a5Ktnb75gLj4mF55N6fA4w7mX55d4jwYl7ret/Q22YB55kC8lQsGHWbipY4KPhxynwrd+pWzB16mc1u7DKUB4zJVMpE0elME53kcySKt3ek6eaDfuGB7OauK0CozqBg8iJaBWlZRsGJTf7Cg7BMTx2Z9ZqTRf8VNa7SUIHAs9GcL8LDKdfOOolBQmTGgC2EYqf1rsx77bN4izNlEUg0qv2g9FNuBmeci9Yf1OjKB7VcFTJI2xdpUpDnM3ef73/AV3m3P8NHQGvF69gDf2x2MkUtqyqRTT5rfj55Xmi/WZfiNw+G51wj2jSl/cjyRy7aIjC9TCDFP7hFjtsV1cNWwXlJGVy2QUJnp5nkh7r0O5JMcuo4RQYmTiAVPo/Adc0LGSCfprfVsGLZlAv4KCH5PtHopMsut4Rz4YcfeSy2X+ArkvMVM8J36xDy5XP3y4m1o/0JLtDKxZN7M9NqqYTbTUxJY/cEoZ8QmCVEh4nvsU4rGi70IVRXGt1N1znuvVpNuF5ZWLx62KhgdNnmUyigEDyG0bfZCdQD9krAVC/Vi6xcJv20FRPRsHp8Va3oAWcM1DsRqe3bwWIHO6A588Xd1tSjWyt91nzLfNbVfmeWBFq7slo8ox22HplV6/xq0Kx60N9HWTufs+m3TRg8HjLtdJk4FQRLMVVNtXZG7pQYwYaQUTw3y3wem0Sc6np/heCONDeAANPNo7U6af0uNL9MLX0Mg6xogoaeQGsDNyUMLQgJf9BXaumGefMGYB6EJG+n+VnIskmNEdo5+e9HI9X7kjLwbMpQSCQFlZI8xJN9fsfw+NkxmNz6YZHmcP14nuLRgQa75hr+/dMBoCx4jxtNJR55e4JYB1KNef165yFE7vpIs1UqzhPGfI4MN+m/T0Gevj2x0x+RxRirEWdYof7hdxb4MW1wGOez9VstXI7LAG46q5zrtQUzSOWgVHfeMCN+BpjYEqBrT9rK4VAcWzXObF1VWHoLEyNt9GJmoWXEZVZZ8y2BAQkgX/o4GZFcvh4sQavEtMdB6oNv+TWDOCuPX/x9CngT5oXwOn6c6nps112VHaDzagE3ronBsh2TlP+i4iQrEjNH9m0kdhvjA/1LDA/XaSdRAUKsswlU5e2XxQI1RmB1wNcGA8F8NTsv1TLVOwOHDoRBq853niqkkD4O0qZPumv2JfExe9AnVQnaK1SFC++6ixYwFijsvsTwuV7PbQglO2Ga5d6qRPxAcaD+YK0V2Mk/Djw9+dP8bck5jcQXvV6tpHIvy+n9cVaFDwWcQWzWMAVAD7DOD4SR+Gw2YNI+KD1XenWUb43PZgjlAgZnpuR/EspYFmqCfX0z+4q94bug08KQhE+gaquZvgp3KN/HpMvA/KKKMBErDStu5YzSAKAKsQU8vZNALS/q7LB6pmzbvrzUwySs0Q9pLFss3ui2X5NDTn4P2gcSc7958ESTRW+MafHb+eQtwoIFAChKOaw3iM2gWpPl4hTPmtf5OLoG4d/AMg0UGzk0VTmXakrh60AOEGkON7AQ2qO0Cjgz+obQiEk7ALnbDsG8VpGM/9JRklphxRbmDNvuadaCCWQalUnHFGof9MVEVvdPYAc7FiNez8pWGfwZhfEDOLQOhxYFJs0qZCh1l6XRtdIZo4+u1hQor0vWgcigNRBEu6EA8yU6SGMlUwnEdht35HM+jXDUt0vYIJV8sIiZSPPFUwmF5NgiXQK0KbA8dCr8CR59d+o6E/Z/ze8thUeW8+hVCsio4KBlEW6wVoCgC3DnIakFfwH6RSNZHFotKcGDcW5RRj4iOoT9Hifw2UmqQnsUSH7wS41pn2pXoCWS52vtZAl8y9gTI/jHG//+/YvD4ZPprCNk/wdvWdHTCuRpWqPM68KqhVsMPmYCQHUWAwrE2QwShYMGzvMXfJ+IWU6e9nJk1VqcG2WSSTljpt3e7EnBRyfEm5fW2zZOkkBxAA2cp9icb+i3IZ0ocgbNaxnEkBwYvlZ8Jg8V6qM53cTmOYz43RckDwLD4iQsNPmc/0wJH/xa6HFw0toSWcIPTvdTiZmcDgiLAsXWoHaO/jP8587G4lYhvsw/3byqeXbL/AGFkGwi8r1Ic7cttmRCUd7eoRnf6VRlXHFeZEiAPmYMHiOPr8Jpdyn68rfIXW/pmXE9KGTozdkOJWZcBAGPXIWuNkjVoSu+Tuh226mn/Ik3x2W6HA5X0HBSsXIkdTqSh7YLsDdx4NAO/YpMtt1Wq5IM+gPjHxaI5eE66DW54gUmyHYzGzL6W796RI/hZD633iK01WGte7969ZJHkv8FEORi2tRDCm3MA340SBlD0Ln9s3DqUuK+BkRpUDhj4hVRX7peVmwY2IzGbvHBBdDEbtl1fgN5gUk7Pq77QvxOGWFFn7nsLGpYcTNu9UkZnVm5vRbfhIf3NHT4sp9CoWUa9XGwyqi7sdB2IqtDva255WtwkcKvxVvcZEAG8wqyPFyIddb36QbDMqz26+Ax/jXMwBKUqUftQL4i1AEpf18MIM82pBwNOYTvaIEOoB69Aklf1dPd3TWUDZc3891o/LQg9m86AS3+KChpMdVJS2C5zh6LM7zhMk1eDZzaSohKgiY92myzHJMGlLof2oeKhtcnTXFLEchhrcCi/HMrpbqequv1xQrtHUh9njZ0EWiCLyGIONkH3xV04uMDF1A6QRKf70lJlRndS4+YV+lhOX6lAhLob4owZbL3Xa7Bkx6bN7JqSvm9pBIs+aEE5B0opy6QQn76KzVljaz2b+OHH5Dj6pZjK4yHGZrxoXUVI16etXWggumKPzbdew2pr47zHhLnwj8jv+pS/GrnPBDHOE4iLkso4XvXk7qDjVdZHOTX0i7qWjpuZ3qMt5ZWXgKQKFeauR54ktYZrdvJqooII+PrRgdXbIhtqWQbLYEVcegxpHEKrg/oSapBxBMOQFxedndEMj9biQibNJUUy5LIvKV4kFw8QNVeycQDgvqMsfXf2Kfiu5/066ZXJnZUTVm3e75B7ETunsGQWgMWkDEri/nAF24BD3u0azbazwIXsztyVaw68H0zoYGcDeZDl4zNj0knbur8BBAksEscaBTmAIef1mY3ioVaQvd7tMXWVyLlQ/0nCJyyeQkMNV1ZQSh8WHYnKymylImZQ/uVInauc+ZArW1qiZdDUU8Du91hpgYZP5iSSEH0iboVeZbhH4I9uWcaDAnVQg1u7BogppfNCbr5i9M+Sa11dBVaUzfw3mwRy4xcPAVb3zI+hBBBNEYR0eEFjdJV7x/V/ju2Z1s5K6QSGws+6qglloBQ2f157zWi6ve+Q9uczkL4AObrSN6rFdplc/BpPlOlvkj4Vv2LeIJL63GizztkUvMq8xCJK4veUdydABc+q2mcUsppyNwQUsXYdIdDjSC/Kq/zlsDuvkASTt0tN150u/R+iIRlVs8L4Im9NW5Rky3viiEcYmDU72rD/dIkqsDVT/5PRtAo5iHAk1c1lzgOl1fVgDBUaITvw2kYXTC0C1yWcorEiiK+Nr8oUSwu04WwaV7dBCh63dQUF8HD0M9w9cwTzZ2ZVN2ylk07JjVoSOq8gpzLF3QcpQ8tqvT93Lxju1coVGSh4BUn8P+871j/DZkl8mAZ0MNnLPVZrlOx6k1CqL16GjY/taW+Fz9/0g3xpXxj4jRjFMLKAfOIjzjfZsTopr4xwqDPwVo+XlT0BfE67pKAjwi2EnaOZBH7pWEv5Cuu6uMyb1/oUgfAhNb0godcIihJEOJFgsHVLeIsp34KCKEMxDzje09uE7uCnR3PB+3RQvxzV6ana6CIYX1t93KhkF5b0PG/uPFjnbRPhuCGfaPHLDyaxGL4sPSpRRpSk/iKwRp9GyXaTYqN5HWckMvyN64pNTQ4gZf4F2cm1NDCWlP5ibKh+CkIcxvMVnHES8itknVC/B5CIXM1bGgqxs4OxEdYFcfGZFHwoC7cF2+leGNNhspsNJw20UIMIUr7qpqSSHUYJVPMKlkn4c6pwvZCojhaNozRQSkgVWqmmg/bRY2y9/QKQB8UBaT4gYAcA1d5vrEJyV2oZaXdlFJznbZZA19xEkX9VOb2/buVB8KVNsYHUdlLkBkauNihz2ARJv60P7zg+C/1VVc/ju+3s3Ybl05LCNB2kfSUbf4BdTYUouBL/aKbpYv0tWz526gWTZXW7jiPMyJSaEK6NQwbr28h4/blTEeChOZbF6g5+6bZ6kQiQnoIdRqbZPBmbYJYtmM5kvDoMlcq52j+k9FZezg19qBIM2jEqZpf8BC5OSnWtX5hWiwJfzXQadxmG3oC4eA1G0GOm6N8anGhL7StFVkb2FMKnUH/GW73t7/bNAjOGvG+rA96/rPfoby2nuaHO9tqDfc/iT1A6ReIMRmE0POj8lCyy9zkf1SStTKRw41vavw60pKMMv/qIQgz1nkYR224HJhnfDfXLbT39M4jl6X8+GMTBduhQbrjKWVFLIjrnHieeKBGbs0HN8uN5KaR9p0/6kXkj+cmA0l37nZHa18CK+gGX4OoNm6eYnuCICVUr0vRA8eK0Ke4RCwnjPRyIfChnN0gk8saQRCAGoo3TH9gJQmLHRD1ib7Wsym0g4It7nHfEbHs/DLneebEcLrNT7/NETs8MnUSk4dTdD9jXpOCoC2yS0Wr3vuA0jEKgOGPPLs7L1g26zFdEgMLOUIZvTFxljqp5VFshdOInMlTy66Vm+IJw+78JWr7z4Vgllfdt+c3FPRIpe+a8970cHCf4hMlKbAkRhGmwrryqizTrpJi+g3MVpZIe2UulI+99q4D5jeXtt3l43UVhtzqxUJgraOmWdXk+E0j6Nam4S29Ulft2PO+8Mt58c/adGs4nm9v3YOzvkEkMVY0YUzX8SAt0zWngZMUImZ2oQYXfC8mwMnTd3i2j4gzVun/ZAIx94+BrGhvkJus+Hj/PSSm5bpCpmL+V2T+PFJ2uSi2KMByFnwLyze7P6Fgdrt/QXY7vAiymJQ9rTvoFj0T98ho0x/YTWRRjJOG/cNkUx1tQxmRzSvcYIqRBpfTitF9Kvb7nupbeVSD9yJqUhDR02AkSE+h6r1sJ+2YGyPPNbrlN99SDtOAfbxzJUwssMbvXR1suCxHehOcDpt5on8IL/6Y6l0S8rAYduf0x413xFeVDHachf+rv7mvRmHA/zf5hhA3hxZAJ2z/huXXgMz3ecZfNTVBv30nfBeAGuz2sNof2m+wWFlJyIn2rJQcotMCbk8C+sYFxBOOwnCH5vD9iKA2yBf6Odlc3LuklK3zHMI1OgI4GLRu7yVlWDnvVejUP+XGYRVcxiMwxekHa68FRWNqPrI3zWUDRUznChAbJxKaDvBeWSuW2wwOYrFlc/QHx9ePDJEzU44vk/si1PKNjfGHbD3EcsTY9K/VvZWB1u4aogizCeNeMhXuwQYWmGA+LIgOUaGPZveynH9r9Bi2WE3Nf70cc9qk1sCwUiE9UgGvB3RVw2cY0cQR3ORGMcrr0LusGyvsAZE2hY2h0jghFTianP/HC1kX7ToIQwpaWLzDoErAZ4q/bvHMlV9dYlyrIMCleAZhBX3B88EesucT0Npgh+MQ6C3rdz+hn52whVkaJ10IWJE0iauATRMw4y8dDkfUKoiI1MQOo0KUjZLhtESD1UM1b5PuRbGkbhk0ltbfGq20zxbHGJvNLbb6Kc6qmlqcukyU904+OdAg2+q8MQK2vS9UH63yDi9kXCq5ZdQeUfvY7GuPmkB4jQTb70hSTkmcH9HWOlgyrjHozkcLNFYYDd6utvEEsBL5HIme16aXFD0/7un3IK61W4LeF1BzdfqjKnOUhbZTyb6jTqqiwp6c14xFKXXtHs8Py0Z2u74yt46VLHTrDSj7qap5Y9b/RdYk2R0UEwwgU4J/qQSmsA7IL1EmMDaypTirT0PMYq/QnBLWJzkO3vD5GDW1DAMVxFdkk61GpO1t+D+CYSZ/O2GFo0QRWxR2LUfIHWZdh6Kk8/EiO/5/rzkqr00J13HNM2Q0slu6QN/dvkObub2/5huYB8r6cejxEpz5n+B/MjPqpopfNc4PktbwDQ1w5bSTzvqddYI2/fJMw+JtzgrJYL4XU2bLEUm+MQauD1rH1wSXhTGjD87ZSyJMT7UQZIQPFfYwwEq1cOqSI9nRUiYyhP+1dQQ7o8EFvFc30xFRTX7Th4G7+6IHNF5ZkExM7VlM4YnBEMXUfCPNjWjhfr6H/eNIJJ1sDDGnCocmEvDHxIFXfz4obBd4qrUXk88J8z8VVTWGU5euOosS5G+vHFMxKzhPiBcpzHEUK0qF0krw6OLfqt7Py1rTOlAveO7P5cuirb8UzsPH9bx9UAwzGiINBAjIW+a9I+SYds5/qRC1WAgTHrB8uXkGKg8u+lCxHNXa9Yy1Pm5iaICWiRnomWeyodfso1015Eq6FLB+VtpkVQ3XTAJhru75FTt81xLKywcff3N9mGD/4dxtEngRaMWVcZhydy9MK/vF6rTZfHvOF9foTHxJzgTAPsQ4Wzv5E4CZXGo6qbhD0wE4a+jqWElpokSFsHRPaDLvgzjPaiD/UhqDtXlwE9/8YXUdQO1+ryl+iabO35qN/rRkM3/KKMoAUTIMyN6AGozEyrfIOpt0DkY/XJURElTY/Jblfbanvj00sCJQ2dmHSwVCxoFijHd7V/sd8h0uj28ppOSHDzm0ueW1BtLEQEbmljIepiwR6rYwvVxIbXGCX5EhA9SHI3YgkVrQhcOJHq2Q5Uop73tByCMHcPqu3PLAVtL08J+onHh4VStc3QjlIZbC92aMH4sl6ZDxF1x9HJhjnqJ8pqPbiMS2hFkY4CFSAtEq6VDLLsiT+VAYq2nXgdwfTAHOXHl8iTRFIgtFZx6Gm8E4SzQyKabznGaBtajP1s9myWKgysTA/FeDoI+dZYVSrVPFrRvIZYS9Rky0wKg0v64QtI1TvEnhHCN36+N8cHO2p5ALWlaMAXp/9hooz2HGi5b9g0OI4Pliyq52etxOm79aPOApLiXU/8fUYFM/SE5oS7n4UDPx2L1fF47W4aDirgdV8Z8j3ab3hch/97820EgDd9zrGxqmMCH7bz0yys+0G3rIlkBFQGeLJC+rSjFLbUBqYWXUZKzYQIc9Yi/WYWMyu3ZywkxxluMqxKoV1s/CbLgy3FVyn+ViYeVLm0PszNR5uLSo0tMvGVWLgc8TBwBVh4I8uRcMYDJPssWoRJKrKYVq+xlxaN0yKNHoLcFmwC37lqexY5VjqPJAAsc/ymTUVG3TfRsmYG9Xsmp3+W0zjCQOJOVrzzIxUSkvLWba7VHaKR7aPKUXnL/4wcQkQK7sIahfuXlk+dLmfLTTVTnFrRwsFppqv2FmcMR8WmpPAQUKPerYEvl5878U/3hVWjwbSOQ4pnd2PSexrSymrjWpMcJDrn2XwAr/kCsCRNIRGlvpjMgvCXaN+N1Q7zKPTaVfAxxWQ4hDckGcDlYoCufEY1mtvanqHwBoqNVFkrIKO0OWyKmExT6sZxzywqFoFA0RsevOvnJ2y+sRKC3RhPHROrWRP0z+PFNoIE0xn5rFQVU7cifRMb38H62EtR707bHGaHuzKyaFU2pSK0EkT6lv2w5ChZVLW4IAz+M8CmE8LOe+LbRof/3+x1wkEOvSLKEUvTu5mHe19ysZWQ23a/c0/s54Ef3YRWuCJrTnxN334TLQ3ZrAFVk81RFSQ5o8ptoNcc20/QXt0+w/ZldRQz0FEYzQi7omG/uQNAS4wwquW+WARgHRChnBi3iPo0NEK2EZIa7uImv6O3gRszrgwNfx8ADRf8nCqnLW+nTQEJGdAxiSfQwzfsvPmjOcms8e/mvz4NxAnT/PdERs6aYacqdONRnLuvKTZ+Q2+ySE8knJD4Ma+BcWgqDQkZy6rOkkcp4qKyU38TD9iMk4WxyX4B4Isq1LUf1jCBwKIh6c5x3/pNuDj0j6s0ttJyUtaZUdjvZKINAUqCosoxpIup/XX+S6Mmlm4JJysXp7JXco7s3foB7fdDUZunra5sSOL7J+/CHkkpv+/iiZpkbw65QZ22U15gSszIYuRn03kNxy6PJFs5wPfhqiigl8meGPfFGql3sIZHAAQ6ZCJtXOHGs/TV8k09kdB8AynfUjdP9Io5fq4tbow3bkHxsa+asmelc1ermd6Vn3oKLVTvlPNhs57lyHZ6FR+YsE7Vj0c06ZZL5bFzii7M1fQRBk5MTxePQe2SJSzMZYajci/i0ARqNGxN2pvHPfSauvXwXCy2zg7XXOkcyS9na9CXjtN7sdLxZ2NhIJTSJAbLRInMqMUXkw+1do7MolOCgsatz9lTg7xVQRRhJ7gG12Dhhek9CdQNQJheSn7L+qGDIzzGQb+Fq1xmnWMIbU8ial8+cFV09Ub6kz/JqNrR1Whek1R0TMBBz4my7lqWOS4F7+30LIOyt5GjHTyN2WKSAQHna/y/lXhtBmT9l6GjGekVQrU3ZkYOt+7BUYK7FbFJT4BYFWRBEm22ca40khPy1W0mxkpmOV4KN7Cy6CW2dU/4zSYTCQCx9PcjzAkeD8xePcrhvU1nVTHH8EyAwbaCIcOkM02G2lfjv2aLYXOw5ARVb2ti0kl1PsNUb4y1gFj3ECztda63dz6JjTu1H0PNYqWXLiXIINXkMt6irpZ0o1Jli9ut690pGFAUzTw649arXWlAEIxGksbegxSSKTIRhH1AlXJO+edioNS6r+OJkZTyq2SqiTvKCraMN1mcA1IxHXHIeQS7gLpdUbDWEszHjV8Sx2umXN4NSKrDrqC3yIzgrUkbOLgtBqvcdpA6T04oZBjSVh6A3Bbxj44GqgU9/ztNatISjF3zrO/EyCybwhs0XShbLLMA3XLiYGM7lVAau9e5fdrc1ZWAULU280n50QStBbUOLIbvpP9wCeksnvrWA/+tPG8lOBNw1x6FN7cdd83qIH9mseecUSc9s7fmHaXReomx0wp+etYA2KiE9VUKoHNqQAvQGcpWm9pBx5ZRgB+LlIprbFtxLA73BpqRLA7WsN3el8Uf1wyC/6q9dvtM53b3TQFW4qHYxUUwFQkUE+wR/JDHivfpaamUh5sfZxItFl6rtxHFxxtHA+lHva5U2qLqymU/a6w0YrcKqxZBjeyZUgm+AonN7/tD987qXxnjJExAuolrorSxhoe+p8Yzgw3o37Ngtdd1PG+62dgyBMeGoMpdpfQljsSxfxvxvCOBuLo+rqIzLq45aAJaJ/8ZQ/JWeMy8F6L/jlGLvnN23rRG70nyJ9aoQ4C9dLSrx9gMIXhGg82oqYk7U7OVYLR2Uf+gccTTpMx+BuBUQDggcdfowip+yGDGrnsEVld0+brC0r5YqzAagHk2kB3aesFj5opPcRSJWLAnOyfwlkbIizXQ7EzZ5QBvumml1DKy1LST280IjngpZUYo+Li+d0yBrWsFC6GwSVq9ehlpe5JIF4gYshRISpq1FTETgDaqkxHbg43IRZupG9vBmMMXbGECoJm1ZKShNHdgCO9VUCAEee2mUk8PCdFnS0vDWaA29u/z665tflah362uzobFhPEoqTcQmWRCv553bWFUxD6oHW5uE36uwbo7ZJn2Btz/p3cozGlSlsO8qo4UEcuBWUXNen9bJXRZxsEnQ90Uukdc2DkWTB3kK00lcox380efjpJI5PDXAvJtOOp4ur52/IAKqV5ilZmiZJ2jGPykEGSkrUtBqrFjb2yLp0DfynWXq7DpJOK5HI9HGSO3PjJue/JWp11M9FTiAaKiAENoMzpai+CvwiwE8PHSJtKbK7ybC8DshdhOxfevTVIsvHcq/fZrnFBmiz9Ep/fVIn+bzaJ62isTstUKVolP6jqyRs0wXnweEAs3edChSdHcnfwSSfiV7qsJZcinpjICIlTGiCTBzgRCCtjF88WjQP5vmNYgaWC4bHhjbXJS8QeDcH/g1mHCYUB5M6fQq8cTCg2Rr7OtWprtQU+TQNDOGqMLOq5gfd9QgTe1w+SSF3gLB7Bcw0759TM1/xJ6TEYgAolnLnuhfia2vKKgxrxitxN5yWh2var9AAjF/f7fkIg7qLuHWdtoNGRBM9yliWoNLT1ECi0AO5V3gL8S9BF6UpCou/xqbmxhBoy1BYKoM1e8ZUU+7PAraZgvX9vmkHauxAzfQO7rFygevH7BQcEePDGm6eLT9RkxR3JoJvKBm4/w/KPX6H/jt7hdgCJOgNjt39YdRHONK67jTmiOFbiWzu1ozybygYzIazV5WI4QZz4HAUnrKa9d5X00GuvA3C3lZuMZ2Dt20U+VQBqSSlzC25Z7H0EEfNFf0sZU5q9ZiAsb6wJ2EpyDFPLDZgEw/GcQ11i6AIXzO4y1SoMVr2jTVYWuIJUF5Uz5tPD0Uv6DJguGluj9ddgrDm0Es57knc0lXEH07wotuBISGMt7LDDLoC6tTIUHzShrVGS4Zfw/GllFJRZxtMtdo1u2fIJiG16cNVAvT9EG7NyH6NQpJjR5dXrOgtsQZceOnne4omXRMV19zVYjS3pZx0+4SbBWRPvhECXe1v3ZdB407tO0lqG9HWRRYd9cGaPILmuzqEKmuQ7Spnjbzj55RusDYiSpVvsFA1W8Gg/UBr26DzK6vlakk1q3OK3Lq2PIgsyhGBkrgcyaxhpCZrw6NRJmzQntDRz9wV4wiotHOsBXSYoXyH77Os261KktqIuK/94k9Y6Fl1tdeqorvLJAXVo+sml8abrhIbi+MzuCmDUyJpPCkkWJSrRMl710C+yyXfFQavzsgUGP6+BYLnxjtitHhQ+BKg5tTINpLws10YqkhkfCkf3lfrcd3vIlg/YvWqas/GN4+8KDILmkLe4kKpfv9TstPaZU2xi9E0ntrv9ftx/RibSHx8LoAUBLxDzopWeV5awT6408dkHZZS5WMKwJyntEdRiDtTjbgPu7b+9nycHyOvpvy5CcHAi5Bi+vQHGY6jCKGS38AuH4FFHox0MIx49H99cgmDKumXs4QhUOgOjjxZlBr2WmtxCSAzgkUS4YY8pNCJ/Ds8QiGJUITMV9IDAg8f070E8HoMdxjIlK+6xV2s+RS97TtlJDlDZ8gUG1qzaAz4DhKuftf2x5HeZKavKEF9WDdLQ3KdBJ0Qd9yNMdeWU5cA5TiXIWtbvz3bGKWaZNDlKO1j2uPcvIYNR/Jk0ARE3MMdgd7PFOONIKLsO8hbjgjcW/jgEppljMdwwiboiywwzkYnrsFE+PYFCBb+SBWkic8b1xAaEuR4+6/uwA9+rgouc+96Y3dMI7QHEkHJEv+vsnCMq6uJ9Nj5lz3lLLsZeJoeyOl1HBV5XIsjwwpmhDy9JGiWtIgBLshwceAQ7z3iRMjz18gOhbk5b+TY7Kas4n/35JH9G1Cs0A4mz2CIAwbPgnLSafvGnsNQgQFfDJccA/9rrg2DpWjBLAP7Y5nKuOEayqxeTqxj/48C9GKGkFS6gf73YNDPsPTA3E48HH9mrci0TVfkHGF2+8xbBwGpolPJJxdINR5JcKrm1dDuh2+0tWFape0W728uJGfk/RORun+SEZ90/Q/9XAdflMR+0bm5uqr2qdhF1IcoCeVtEPld5HGZmHKjV9yw/vTypq7V2zOlhAczPdWc1sbvVmMu1T2E7+IpP7suzqIHaCC35TMSJAvJB4wEnu0UUmH3LERWMdoVjT8CQ7T9XPp0cV2M+jn735mXmpXtYw09bjudRqH8PP6W98loa86qf29I7/I2QRTKjQ8MEiurx+R1NyVra+tLQs95grZTK1x6R31Z4HSQH6lNaOYuXd8KgqrkAmn0JeFxVikHofU43S8oh3trbDDw8Rt9d1iDyBPPAkxPrAiLTNCcr4LMl6U3s9SD6y9ZX8YBKwg6i+FDfeh3MTXp+6wsupaJUtwrTNF+wJbGptIKCrdRcP96VwnhhGY2lMUz89Pjo+WrIpampI36toJlBbM9iVT6Ocq+K7+w5WdFAOKESliHPkxQQOIb+f+Jg7fwsLgS0hG4WFkbDL7i+RMQrmQVFV3iiJhiX/3lZz3DTueJ0WLaqyykT2CmfkdD+DHv0aWkVClEyF0M3k/Mnu1fB2hkzDeTyzMZ+41qaUh7x16DBpbjtRT6gZYp6WjQw9vCTzG49IUPtRQlrA7ody7JHaJuZ2GD+q/xoghLsGJlXpVh8Gv73BfU1fj5w28wiIky5Qn3hDePxGH+5c/8emvrSjLhibhbIz23EXOEQOJh3Kg8DYWjHfnTe8lMe1MY8XzFkTtaNgzN/5+VWPYyKvU3H5S5ujL/GTdB0ENdo4ljWEQbkUPb7KF5MsIqIOV8ktco6VXS9aaW/Ny9//00hDDO1VAWQLyXYN2+YVkIyVwv70jhH+KQ12YwHzLle9YMKP+T4yr4bxFkOkPVIS/Q3E9TytyY9KEORFKUTcRUSQOXiBloRL5ZAHhAtwgqIwWoxIzVEN6OOMt/bGj/AlKXZe2ro2is8E3zE2YN5ULhcKXNK1ZYwsqiQDeW/6dV2LKwmgOa4fIxgR43VL6klAzA8L2zd7P8ij2hHzrttYDsEbVqVfydZDHLQVINGG2wdo03PKTODycPlt9QvxLUwL/qC0mXAT+2b1TiX3QyJIC9LjnDAW/vy7lNIUe1jVUKKf3+1T1obUbLFSLrYOIMQ4AK7go73M0vZJujBZ6Ns+WTs2wJdy6mnsWB0JBCpdHddDSUDCo2Kte0yhg5+zfRof0kW/WuAJkDbEI8pNtKKXdzRdvs4D6uBuMkMhXNw/Xyq+2Zs03oEX1cWYDeb7PzjJuPjUdyMNDrYsb3eDvfcnW3mJ8OArSbPRtH2PaY5L5Gc1lufUur+RAcFREYui336CKxNBYOAKbG2i4QTBIlsFbWSD9HxQ9mfhVN9NpTBn7qztNotCcu/mi+I0Y69k/ZiPaPmquhxaHWxrZqKMqhVXEplcSkZAW2zCucq828KvrkxvAqWrMFVFOVJv3m6SXC6/dBEx/eu7M57oePDfV2pn0u7Mrm7V3hdBojI8CH4JiacYWqKwExpQqZmKV1sZqlZO9mRUhf4wuFouwJPp2e4/vip6gZPvuqfHNFjxOBDUVNm6Mn7ze7apYZjz54thnjElcXz0Mb/QY777BIYHwGauyuMGqDNSEEmrOIbpxFByXbhM0QA26F841x36t1aX2Wrj6oe9OTjbIXEeoiV1yN8wtZ1FL30PvEUxevHaMoukQitqQENku+PGTk9EeELRexh2lwsaVV8dBXu5NfPpuvR+Iym7fsdF5AiVEQk0OCgWnjpTTGCQyOt883qcyU7BzVElUY8FaUW8+CyuD1KfTRvM7KfFlqKM2sqrGSU3CjT/y6MUvFZhL3zWN2zgkC+rQUtnl7qChwkpB0SC65oxqzanu5xpQcr4yOZCrMeTQONqy9ag4ZAhZkO0dJw329ahUT1Ry/sanyf++s3EiPp7634w6IbG4wO4Ikc8XH3c+L7/zp/IBqPnoMQqp6peqoGWeQOOUQnMLhdUYoRvlCIM897yTq9+dRyJhiuyrnQ01fR4CNfq5cLOXTx/yPV5SFKnYII4HY187ZSjZH64fMNYy+QqR4v5ga+r2RyB4QC9prbPyQo8DeuyYq4pWzt97tLdZX9hTuJ+BpUtGG5LqBRp43J1GJofb7npsSd55vpft5Yl9jXCl4FrAFK4tt75MqpN7wutLgXXbIY/se0wukdgiL7db5iqFFAhPbx25DNuUWL06b3D8R4oZwXsVM/huxIzIaCnnMnbjnVRxsnFsfW6qt27Ne89kOyf4ZVj6hTbuk1Kv8lz7VXQeIJd6LGkDwWwePWnQu672GwrD4GDZhleQ0VGCIcArhDuAVQ9LVD1dF3hOHuHvS9o6qCzC79PUsi3q0fVb7mPHGhrKfid9TMSY/ul/UFt8CXla1XOAkyTwv5hakEKpteY8kKyIpWTcSQuvXogCuF63NnClCSd5dhO/70l5T5jIFldEpQmpRRL/PVgegnT7AgeCxg/dUDs+ZYRQguM51G73BPlppSpFNDcIHfraQdc6RsQ34THoIsn+ay95S7uuFYbNZYLmB5JKQEvecbrviOV3ryd0HHA90Qeup570PsN5sz0IopOVWr4I5oqaUU6+7OAvp6kx2UMCsx2sRJEK+I9ZSuDxHdFZpjDiMJ/mgh/8aYz3rAqls4LcRkdc6IxqWio6jZ8mGlLZSH+5VGqlWNV7A/IbZ9tcAR1lA+EXEGouhwLeSyA6cUi8VUKa0YdKhsUCVhd5XJJM8Rb+hx4vDly8S6AnGOhwhDy1dZIczFq38znHdJg75v7fy1pSPPGky8GNf3wdlqf9ixsGkiQvuO4w715Wknw24qIGej12B51zQH832R2sWeTfrwfr3sqHnooF8gYYmTa4uNttffGfwO4SAhDgc6SfwTTQ4TuVk7eimFIRp+tijyQiP5PTc08GqkR0AtEEzWKYZZ+I1XQ45MVCmokP9iu/zfjxFaHb3zxr+QfKUBygVMruD4MDLons1K9kMwK6A8XAl7hutR1FSQGWzFOl7cAG4ezxJNRao5GAE6Vqr8ml1lhoWf1e4dkRU8AogbobGEBj9pLXYuNZ3mKc3gZgtn0f6lOYwjACkI+rA3bzHmVCo9uzNNDRkOmUo+KlIW1iIxaHOE4OniJezsjzcbTlRj0AttZ5RlRo1bzO3Ckg9jXwjOTtXUdrEPtTXsN4ivwTbEIukx99V4YOdTcVNktmqG1WbupVI8Z+yQHJh+33zulE3atn8dtU+Ve4ZUKo1a9GlGrkKHgawU5+9idA5xtQil63FQhOf2DeJEN1NNSyUCgdCTLVn0eKUwa+3j/udmnxxsQPuSR1iU3JpGAs1LnuvNZlp9S6K+Wtf8Tg8snOgnu4CjFjMyuKFlqp9HfrsiQb5rkRGu9NZATcdss847awgZtnt8SJwX4wnDhef0NCeghFjS3contH00tybDwzX7pAfiJy2e/6wzLAkazZfhXlE0IKK1rasKYr86Jddgmza7TIvrn26/XksYgmZQaq5qdfZ07hwd/qtif7vXuGzULvB3Kc7HsTjTQZh+b2i4uIHebe+0AR4RKnfzOT2x3EszBTgnbqdL6JoJo3/Dun+Sl1exyuChClr+iIwXXLLI2iptIQGZ9f6WsI66fop3N+nPHALJzlh3HpiB/cI64efmYQqJ1S8lbX6KFwofsRFiSsmwN1hitT3bk6fCJ8sgIc+ZhCByby45yVvQdFWCVeIkRbuK6SBidaRuIFEPeEoIN//goFekbHTG6zYc89eaD9YcDW2RKkrp0/wBvrbjSdOFN3zCSefoXtRt98fTviKnGIMmfkXEYwdlnIYbLe1wrFxsz/vBdzM6nrvzOfsom2VPmph/5QNGDI4eaIqA03mzfd9D5bZOFzs6s0KGx+SMXEJO0IkBLWVIYPiLTDyt3+vmq1dgi2GNsB4EYfTxcvmMYez9Ii755OtY8XZYSheL3rqN6fMMov36RFzudbiPU0HlHdSgm2P7n/3/e9trDOAdBFiE3fNFTKrO5dB4gM6KvwBw2rLE+yZkxe9W9saBi0Jt6Cij9jPIBBDkHgmqtjoP8faXHcylOixqP4qACgFxSa13e+hwA56S3WwWOYHcrRIcrM5To5C2yMMMotnafutAL89wME6yaDusJbifQyJpHUgLTtCAPcLP8C0ThMRvctuXGuF83urUPufWF4jaJ8sM5EfC0xIgNp+7TOEk2ZMYia7dsivBQb7d0FbKrk0QxSI9xFnYioJTLLQhWkaCitFm0FWw4b1wQzX3wYLMc601WI/DqGnmW5wUzOE+0Oh9Mon8TxRyeoj735ZMzQ1G9YAcJpytrPBuSaeeqdcF6hVa0PDU7qKLx7iNPOACMOVUl5MY232D59rb4yDZJx2GkLHalreZOz56uuID2VS+nszhyhBRyP83MDLmidrgTw8B9Ul7OxqXH1uzhvLrmAuDt9OsZVpYR9IQqXog5Qyuk9PRBR6Kh/dLjy467jLdH2zhuxmEj7yY8/29aZFQHtuAjJu1IGqnTlVujOrS1YtO8zDh3eaKOw7zVKwIBMjWwF5wX36udey76EZGVUttKqEI+HhOK5VyFG7YmKlXauf1UQT6rJPoShRmmP4WKoJlw3onXzeVdcOEEv2N8HCy+wuatUtsDCDtEPG+id5hWJTI8q+85kesMUTRVNi2BYnRi/nkToJHEIj3svJ8V/1IUY9Iys3TD7SY+guinIZlbkr/egrdrK1zu+PsBr0ZAL58AVuR6K02xtOqf56qUxICq3FMxktmH6eARUkuHK+rsB6Yc8ek+8kJhI9Mgfka2YGQm11khKNgcye39PeHzsq3sXrHPyeof/hB01SnlcV5L8XPuBuifrm+nmDfzuXzGmQKouV36ugzJ1LrfBQZAtcx3ihTxkZ/aBWQlgiN63CDWU/56oFWa7yfx+GOFvfUHUSIdjtFGUPbT+BEVSNoX4XY6enkhtCDP0WlATaXP7NckiYw/jEOfLyZTHz2ipvAeumbxDwdxwP+lEl/QSVuPw10rwAdNCinoB20d+K+ccgbK5tYxjJH/ZzBM2OCzyZrrAViJe6ZaPH8O+f0QlHIuSwUc+gwqBNa6MnXLhmNHdTSl1GLcu+HrfzV/2rCfBBuI0FZEFG2vHwfQpEMbwEys+q+D4okXrBTNySoPnERXThHlr5JmCwVg9mQ9J4MPTX45NcJhqum1pEcSacqK2Ye9BQOigB62V0onW7Mqk6QXR8czbVDay9NNjNBQhBbgsfTnCYY7MxO0r+bMRg4q4pK0n3GuZhIgBFHchF9kHfwDO6LcAB1hkEMx0wmsudcRzEbs1idKbCtvvSMYcP80LyTethF0Jlc463ZNi71kzhmpN00jaePtR7uHP8TlQEbN/knv9MMcyvTWHBkVVi5PwT9M6Nv6TQGu7VMr+06JiEHDmmitybFLxMkOConCAwjCDttssQWYKSMrrVqKxBy0sNQB/6W3aUGcLcEQ0t7TQkZK5yS8LjZp2A7TaJ/5wzrsc79TqMPstXkQn2CH108GxfDx6oqVLEpS6i4N39iW8zmxW/3lT7AgrNlXFOO7S+JAXjWRigibUT13R0WfqTkYpVxL4SqJQpfpOPMcmfzF82kwziad7wql8wNNnsOuC7WG2fpccKl+05RPGlvMhr/rnEli8h1C02wXNcqDqAUDzZb27kla7Xr7DopnyLb7vUXovo+di3Nj44LocOLij+Oj1CAm0UeljV2ME+6kmqLDivwLC5myWEu8cN/TQ6wvRjY+/khpUrt7DbiAERWKTBUMmvquvbrB9y3t8Gjb3Yowsk4BqHiNGMy9tIoZIXYfuAyzKHBro9b8vTmTum58bEGlScYM+9lhX2/Mz6oXhWb+Hm+jwPC4dmhVfZlwtISiVQ6ztkicObCq9L3XWYVraqYMA2AiwQPdOwvG2VvpKyEGRQi8w4d4PkQCtiNrqbrcZNwRg7C1JfdFgjwvqcitaLKVFFFYFGjP3aapbSi49KyvFqRKxAzkTMU4GR7FjIkt3V9FSmVo8BXCC8YCtg8HbWTAVb/w8pIaCJ4P2zd6XgFtenHMc7L6yvKyZZ+TH/oKPiW2DADACEsI7IQfRdD5UlSUeYa/Q6yBAcRUF5zOO2FfC0IjZ2D1asGsE8GFn1MZrBTDnR3GuvwiVNFQYRifYWzk1Lk7x41vHd/kfZuKTXi9qnawPXW2GgFeoQMv4jIFRQTNGX7qh5UgIfYViEKSNuDWDnLN894z9AUnL45cn8R52hi/aVvhRkpCS1taR0MP9YWFGlkAXUdBs1kphRMAec5STzJNjhjfYKVoEEdFPxPhFQhMxZV5/XU1xe0ctKIRzGQEONiovtzTBAFDcmcT0gkZ8J7zDAaE+/HB0tEvBH368SuHfDVDZrhs9xiolrk6m7GgWCeSioH7hgOaXhbMyqxfZJttym7mAlP3NxLPQkz2DZx4K9fbdvRassvuB2xLHz4F0lshgJuzalrsXk0F3CSprPzTumKr5gIIak7kSMa2YMmkYU982Qsu9yUnHkcJqi8VhKd9S97eRKLbITko8lTn0L9scNeIHP4/6gQkIYbLpplx7OcuxCwFNaNG66g6MziAaR8bs8L+eQHMtQjcVCcb7ZPbLm41gp+ElS+X2sHFPSRn+XR7CxvHXtDbH6suiE8GlpGD5MB7ioFECSHpKCOFoBDz23i6LH8/6z+ayUbQmZCtj1MW8BapkvlWszJFin7KkPibN1WOBZp6KWcq50B7w3Z5vdkvdHZDvfYzV8wdTwcuBg2gYRKDGUAufgCD/2yOXZpox1LA/o6ZQfbqLUr1cwACK+rbeOR5Rf8wkKIGWOhHWO0sruPO9FnL7KtKRHIOlTeDrCgbvaG+4sM0Q0m7AYAZYAcEjIpaf/X3x7pWIhA2jnskkoQsIKFtvsyXaBj7/t48S83VN9E2rHD7/erv98/Wt9gRdFAIANyerwkszOPaFfPgByN36dNh1W1oBODoTn0LCvWISH98f9JBXpTSuEd1zmnJvq2x7tF5xVbsWUDb7qCWx1HeXlcEuH+BK7+2FtS/XuegJ6uCm2IvThFknHHp2mHE1cuoFWmvdRP8BBt4qQzGBnDII4X2tKy3uu0WRZokf3SWFPV+ufJPQs/xnkbjWCqF5rqsc82Kcz8ujW2GMC7BohEw9gmO/4+XBouWcj84An+5TY0GcS99zRdyrBAdEMlH+C6fdFzdxQPi1WmdyUJUScUxuVGHytbrTuw9RIBylklA+zciaghwWfb6N9aUXj3Uv7RxW16cHcjylxR6bMhUZ6nxStWqHYI8e09Lz4x4YqFOLeF7wYFe2gIw4HUiVa2EaMFoa1i4TcirVtjkMHACawQfVKohUw+6ZeoKhuhGQ8/eRcgnbtmHqslqDbwpC9rvyRbW4MFxCOiQWgYaM93egwI1GfI3v63we04/QfHE/IfnHaaHe5Bn7HIlvGazZjKe1OcKW/FcZi3zXGbcxb5k42xbM7JhoKihIXon4w1RjV/xtup6JTe4sY07z7c+EnbkgN/qhBLr6nZyiFzjDWPuQUathqcge90v52Ntx1WvqIvY1iCEJnjPtW0hdgjdTrSXQVmScRG0qonb0tuiGIggMtUHEEQUHHVEQm4X1sJTPcUxFjv+wArrAa9s3xXsHP+i5ExYCmutoyUGkI+igkOO8l1qCfHh+96SZZBq5jOCp/Au4GMwbpIlMN8iB39pwxjhXK8yaRvQ9hBhyzHM1G/eI4xdej2cFX6zCeuBsMFm3x9a064aA44tdrRJK/yKxLahDOmVjD5jnIXBcuaLX7BF79cDL3y0r4cZRyxMIfJsLAA6K3+pzB1LwQKu239LUzCzq0Hx1mD/tdBVoxbi/P3LKCydPTXJ5PZbVOWfbl9tI8o4vARmrP0GxY3tjDNsiS8jk+xvtxg/EqqWRoNyJSIKYufDkfrgIgIOl8weHsSb5D0WXIvUWEcJJRDXwcBduZgkslcntFYRw2sXVha8+W+mJujLtC/IDLunocNQ/8OqNKw8kWK9vtn2yldvien+2scHoq38jlHPepzDCtNhhyZlM2Rscqn6EMvCUalmB4d5aQWxf25ygrHmQ16EtFaM8mGfVqqIVq2If4mtLcmHlZXmvak0N/2DytsYUzf1+JmmPhj+4GbdyqfB7rO8ZWacvoL6caATOump2OITgFBrLROQKClosaXMDrind/19+hArFi8zI1OCA1XI64SdkdjIzuC50YOoORlHH7PJVgzQjSCYyFgurwmF9QcryfBZiyzuXsj3X3jhlydF1lDGe6NyGFc+ZLMRU5gQ7f6MN4HQkChhgMVnU3BIrbd7D9PwbLMcYKHCwfV6rW9yxOy+FIVjrarNhjWB4S6MEKu5j8efMXo9eSG3FAFJ8aUT/dvow/aPBblGGrZVDQK/AQcBMB3R2fU+xvYTteru0CA4lJEYtUTv+bRkwr6t9SZPXf23ADeo5Y26QU/cHma1OhMNcs/J//HKywl0F9QQof6T0fErGjaqOBRf7J9YXI6/PSWnn+T8KkFw/o6FjJ7eb1I4ZFh5yCPHWYF+xIWbEO34s1tfiBuXmR+bW2uyOiIf2gaQ1D0E6v745RytvyXaXJ4p6TorhVKJ7OJM9DD7ILd04gjUc5nlqG8PYTduB5H2QAE0AK+EN55Dv8WkJVvtjMcV62zL0PimcIM5ZdwtPgsAsfOSwuinrVfAwuUjD4E4QDUc/6zv9j3Nc9aTvzOrdohXZ9ECaFYaz4pv0Z9cuOm1mNI7G1KqG7zYk7ECiI5ggreBOlr6nBkaIHBLlNlUgaSAdvsAiIl98wF9Nu/X5dBVazl0uN2ZJLia8fkITMUv7vrO2GjLY6ouUPXS5MBFrgWJ/Z61X5nJ0XoeywqxMrJTCP5583QQRXIrRXxpRYsaYsxx5XHv+m1+6yIs7GExcwSYQ3OGi/P0i9XE5QyTMrOFV/crjTvdgSuKVzf69qlQxD5hawDoo1qbkT4htTflavdnfJNfBvFguMgePv8bvXL25QrqrkMvILnDXYbFOZYi65WVglehylwv/uQ6QRMp8QQMHG8Vi6w2BLUhV4bs2Fcj2nJr/G5ugsYplfrXuUAM5Bdky50IgH4mTLzMNYZcUEc7tORSjDaINskat82BEvOcrJYKF28Y3mhvM6BgrV4KU9y9ZenRDT8dWYoIM6MYhSG05oXdvuAVod1WTNhfCJr/oXJb6NNOizNQjI9L02E1O+2PbsxeIfTBf83OGMx/pkqe43j9HcfnUyAI851Z3o/ggur5e5iLdkhNXNtODXARUmQEvjodyJhRwv+hALRmTjsak+6LekrvcjykwMf3grkWAo+S4Vr1zy0X4hvxlm+3FUp+7T7V0K8vA/bD6iHYwlUovJBjB4AyGrUZj+8a9wY6J+Cq08ujVnz2jtguLU5C/1HRiBlER0g1TentpM7Eymxzkh92KGiSoph84CYQm2uWwgAOw/ewOmSa3ZQWVvQueZ5kWAsn8tqVVhpR0z4C7otdlAWOb9hr1lCT9y+/8WzUd4e10b9nDhWFgq3sfBIg3doIhr3TwirgRtTXBPJOIExJudcPZc4VIweHmIbJiKvIzNeEwwof0igYl615fvl4/7gvz71r2Zva1MqPqkSgay7V229bnx4fb6LrAzfdJdlojLM6wxNH78Ue15t/hrV/OyGtuRHW5MX/MfmQOPHzSEE+z1OOW84uQAp6usZYjVtrUBzd9mmmE7ia9lrBIiq56pbFsgDDq+FGMG2w01aVaQAcNyGMCs/MqhKTU0+/B/+1HanTMsS3MpgIkGDYnVB5pqtQPZEvR/W/tbm9wfz+BvJ+C4B0zdWwyxRLLCwBhq+/tvpFQ8Eq2IM/htJPzr66ft2ddl9RvOk5gTtToBsp8BG6fOclOGjNhOwDYe3hN+G1maPiEM9rj6zWCD7Lox9RjBnoRR0PVy4nBTDYvGr0ZLLIQQrBgxz1yASMZz1CATCodgqoxFZK5kbuOy4GzM1x+rJs+L+J/AmMyhPbCvdYyvSy4RljxBNet4bD/Fjqew7uwDjB/qiwLnZ2lGQV1m7fMT2PoTOWOKjgLsoMnWuEgcVrdo7RPeAeHjzSmJ/FLSbx1QKcUyu7jBI53UaynOBRpjP/qsASFd8uTg+teKwa0Ce3EQU0gg0N9wzy2zxSBY7zJ4IFfSKB0ROiElpc/EsExOEqUS7MaSfEidWWUBPG7qMyEE7idF2hKJ+PXAlg7s5kNibE3bA8v5EBiSJTX57d2m5k1iunFw0ZRnPutww6abYfO+NRjmpysdpfHugHl1mYWjIDnBqUSefGY3hANSkos7+O1mX5HOjHS846Xs/pCo4bbpKDCN/mvCBajfOCM1GAOWObDMjUCOuNyp+OjKWG3MZgDKM0IEPlFTrxxt0YFi7UWlsVF8szqXFG3H8unmxyGB3EnV3yYnpiXqo5PvFwffUk8QYnNXNPSFxE5r48Hy5NtIbt7gUwYQ5qqkUOT8Vt1B97TEnBx3PL3SLIF1cTzzvn7FQ7JX+fcZvbo979oAGNStZGY4Knbj4d60QdbXrg5TNLMEr+2YHwu2dokHPet7bDCu2vX/oqkhukvpMIDiQF7ewyaDBvqNCXgEOXqoVHPCaVNdmV7SIJS+KtlUbIyUbrzxUa6OQbNpZPtxXcRFbi4s9xVESZ4eCmzkAxF0zI9dDGssRCYGCnpx4IakeDvJEyHNxPG9Q08/IbgZl4jVGkMigY4o/cLl37PNbhuRogj7zlDPiLNB2CWEUtpRaUM8HPUx+bJk0+b5K3DrY34kjo4NEY8TLJghTNbrKwDstQUzcJ3HkgGGNuVNkzYbn+jlmZZkfeZfTTsEyQDRAFwI4PUy+kiqUdttFNrdzOqtVl0HlmpgaTshnydICPHY3XkqvrY/HOgu+wZDiSToejcy72236jcPrwgXYH/GFsrTYGaJ6Io6wMT87A/Z0jIyR6xes1u0h/soxz/8poBc74K8yo1UfbyFw9TNLUtx/OInJ/I/M3zFDgW4vzbivn7cp4fuHoeNiovYfVVLr/9wzs5nzoXtgwB84MkyZH5N3US3uxP6/CU+AhJzduFuDNjFoMeImHgpzAguxub3pBw35SYrEJTxMajw8XnnJ1ejlxcP5B9rDqdapDIcZ4oQQK3fZlZlIO4J/28nHiWHmMWydNQoGKaeoiBHXaZOxIH7r/73u8dwU9OYAibm7F24i2AHd1RuMdej/JV28rv8h5KZCCWQY10VKsTqvZfTlTcThs6GkwrCb4n1u0dnaHgbDmcd3fqXq0Hx0pM++6ZLHY7FHTJofdQ88opwoBws0wBEwwOLPJa/LXT2gJlOloZu3+dz5jpebXihj2O9A/ZjTg0H5SK8poghCGAuSSQoyF9PZJkEqv4EdkWDfs5qwyQkj4v4E79SckqDyvVimpcGS3xeGZ5nGPKUQVcZLsJ1nPaMgbRytQUbidTMyEkWILOR8Bd77yJ4e8kx7jwJI94fuNtXVwV91DPbEtldJpv26P9y6YaMDHFEyZcgvCqceBHgJRY/7iFFq2Jkg9F2SovAWxSUEJF9d5TSYn/aL7gIqtlbNYy+EEX77Up3EITcXgw0ofxfpkucO+Km9ueh71poaYR0GpW8YtNW0bxWSJQAKP0zLDYw5nQR66T5xDAQFcC2iP213niFDI039eR+xerMMIZiJzJeCBwTww8OqVIIo8KVrdcS2L/eBjgc7NYtR0sQIbvfXMim92YOxvOkLwLkKVLVuTir+rNowWD9RdjBk/g+KHEnKb4za9WX8JFNAx6p4rLi3SHUM74nvCYB48zq0J/OEbprWFtlJOuo7m+4KrxAc/N2+1eUKh+osydnTrDZ/eTq43jbSRV68bEaldJLWZ9LWj7OsQbKvphEDA5Dd5VYHkrQ7ORz+1Nh850/VEgaQroJWctnWmIC7BfHlPwSU5qRFcTGYzyX2ybpgrzbZjiEWzeei6Cc3wsLtZm719zsdV4WuPm5d43U2WiUqkJd5SFt/FBTL7dBd9phrBxp3opWziMhK4RM4SVSJJ99juMZ7mPxyjfAYriXiAbxLOlCO2ywrd3yzUNnKR4bib6UVfMLm/+nOO+d6wBaG1s8UUC2gsb5NnY006lO3KLgiYRATvwqObvY7IxaTYPBvy7b99Y2QCakTXansCN6DX2ZWiVOpivMuNe12XhifVpAbo6puode8mXO5dN+pkBPwhx294+gqcIn1c+AR5RoTp1cxA9C2GmRAWzRdfXqwBz10aA02RFdlRj3GVbbsKc/W70PUwtBmWHrueXn82sALob8Hw71DOOdWbBQDagPUM8YiJPLDYvEsPfgmubycAm5oB2LCdTZuZYLAqxrVQMXwOwaCUX7L9c/d0j9FbncgHmXkgUyhUaVC2GvYF9pxIiNk0CAnX5x/jImw1KU3cp85x+TP1sWKIjUBzrKaHg3eKLkomfyKkugS6MFn+QJszs2s106+hmUPYmbn7MDHvE8K4a02Avlp7AZaDe6RxX0HLUrx6DpBM3N2vWxqKfeW5p5w2hKPG9cR/aLAwSsY1N0o4RVBQPW54U52Vgr0JRjYHVD3e/voTfoZnECZkMoNoNZp3A1/LIkRaW3y9OxHKifcvjRQfTJxhlZ2dJh2mzOnEMN/QEcZx4u4fN3BxVQEDTV7DUCpV4tOhMbM3MGYBtZlnOrK8svhE2KHHNGyid6nylNRbiLogB7nh5SC8e0KZ/QuHcN5Fu7/Tiid9u/1Fi89jlcUUA3zVtb7dkh4Sfu9P5DSBXdwKVg53CbyHazVi4uq6ZEnw6n1yYVW/K8GJgv1DzI+9IB0Mz+n7NushT62I3zfI6l9t49ZBuQD26eG17q3Y+9XMntlcx6x2gIMv7a23HeiXV/1mxZuv9Nm/+NnJwYsSd+FzPlz4hG14TvJVjwWWoYyp+ekM8JjT0gxe6rzUDIY0QlBAyP623TlC6wjSu1N2TyhHKICrZzKlazAVw5fOHyrmYRQG+AAAi5tAOq920hMnt6BK3mtYXgf4xrrv/0DUWZFHY/U2CGJaOwkcfQrIR3/sgzG0qK/pcRLJ28xPFNYARTbAA2pKbtijOOOdFKpBLWWJStd8URkgJlyZSQsvhoBQk1YpL3mXyLZsDuRdax4U8+8apFN9HKmrnO8yV0EmtIUqwjeVgXJRAVV1BdZSdpmy+cjiWhzzbvwtB9HZP23sOilVXeNLvRpf9h2XhtYOp4isHylf6TdMzF5+62Smp9GtBDLYsP1WXViesomeQ4Vbu5yghkYDU6/7UV7m0pQ3t80hnSnYiJc6iCgk3w8bVl6ivsFnefOeuauOSLK93c1xMv2NmVheHSb8OWReQuutwk2mfDC3nKiMQRY+gRHoB6fFDk2Gv+5kkfeW/voWyPfJKkN84h/OlyWglasL7moENdNlMfkfooDswKanf9dAS/GHtpWflD9WROt2tkGLHx6C42zTOvUYLC7qxIKIbfLv2VawUSxPqEe59J455QW/lT8UQdY53M1q96n1KHQS3I9ZvMNtq1x8nEr3mofVJ/W5h2kOiFCyP8PwHeDKJHqUpmvc0dgXPsS9cqe0XA7cnMzsxeuCkrbTKt4Wtj7eKmwbc4UIqiNVizNXByKrFwhbERYBaBFSo+Em1HWGQyOG0tXpptcENr/lCZyfTs7yF5jXySgXhNci1I62Jik83JvWfEDbIieU/8faIpG5zbSAMzKPUgOsGkOvubXoWQwMZJ0J21APyKUTUAM/8Ox7wHEqjLdms/jMP4kI6QZ4JKOu3kTiXfX0K99WZunLzZDtRmVVxKIWRdH+566ai1iXpriEZunJ748dFw401qDOzt6qc5UuwXP0FAs7sksMBOi7rQGVOfct2jV/WRgobrxwDqJBsPdlvmRnFz2Zv9Ypcg2SP0t23Y2wwP1tCp9upftFd8UNrByJt02UhCUR/D6d9dYtX2qEm2ihuWJldwO6j4Ufk76c/3FC3PSpB7Efubw2ylnhuk5Jkak9nAZPnL6w2N6gp0gL8nNr2iXvgB8FHkhaVDJPYcknc1m2fzl5VZ1jpJIUjwgm95rnUX8qSP4HRMb6ZXo9nSKHj9jcORdjpzg+WgnVAYnZ132WqB2IAZuXbBaI3gEzQ41h6wOYDYNz/Uqff/2Z54Sns+RpNl3XB6YDqDmGFkl3Mgu32ya2wEhkUyebsQ82lj/blVfCbG6NiznpNN1KbSiKM8vzYBO3yaK/KdoSM04oi7cqgQhgviAWeFF64zJIqvMSZBiEZxugkyLcJlHFPo4MQxN5Hh4n7DjicJul99yjWM0esP7strBujzLd5pBKg6IpQRB3wfFU8ftVaoOupvvxJPZhaCLbOhWtOnCJtsKqF2aWiMIIH7aiUoTX7e752SS7oCAlWX6QPpsCZVlhkadak+riBilzHO595jm1Ct7WY/AtBsEnKd6DPo0lyQXqXACSkinEMaBbv0yK5F8DFJIOYUwb9KSmjHxrCsVL9gyKImN8EvY0VBDpaVYeR4fOEJp77jiqGbRCzoLbieAaAA7RB9hCrLxTZQb0ysLAnpC2GpheAQWoE0h4KxhgO3PmqgitotYMkX0dzAPMwgCvdBuWJnzWF/TyWysWOSNnO7BDPyee1rh3kbcZtWU5q4KD5koS+E7gOgt9GWjujYEtXU8amOlhdc9AS1NxDOC2ybK+qGU7zuPjPo6awOdujqfndXV5smO3Bio9easuZk6lRJKsseXt8rm7A0rxKrUEETXXQG8oEWGgTRnUpK88pXqfpQhYvOgEMW88cNhqrAkNA07MfrHnZuRCqMa+jd2DMgf2wujToW6UznQWPzqePu4etNSNnHyxmSOZ/0yISFex8Ve+swEorDz3mcXZb1APlnXG0BbC/tBB1uzoWaP0ggeDPSjqIR5evqXbGcR9MjgbQcYGw9wL/tnDMvzGUjvybnWEO4X0sspsGLfzhav710zcIiSR7CnPpwipCE45i273f9cF/Lsr4SNiYRZO6rAfnOFrAvRFJXvba8lpprYtLGOpA3+YKowlZoEYVMLwNg38NdS6xWpjw7efiHd+1sFxcC8K84vV/m+DX+eM9yyqT3sAlOokhMr3aPzbJv0L5CHiVtVYO6E6rhyNMA5y9bSZOJh+S0iY1WdYjW7Be38IywSEoXpTNWLcqgIav2LCPWlSFlpGXelg29D6fDv0V99ECSnNTvk8WKeNnqqA8EaUFXSxfSN2wg5YI7nAgveWFZh5tVmsIQbZbUmQevxwJgVy6f0L7lmNOcX27Ojd0pYz70pr4AGw5YlyaS3hNGe6Sba+L2fPIPWdEhf2irxAiLF0yC+edKrT6OLeAW0xjB/E8OJspizL/LMe3QvNI4UTF5uHzLJr9gB0dThz4fIbqr3A+h2QnMyJmmcVZ+tjCjCmiDwchbn/Q3w6AIt7wDaduALZ1w1weFl0nUQm4KodN9ajEF88xArl8L61QW+lQfY2cr602cBk5GsKkAz5sVH5ECP6FVkxS+D7DXdE5aQ3TTf1UtG3pMOhTfm4EnD4v7U5dFYdDq17A7mmk9pXi0Sj1PnugsYkG9m6lu6IoWmN8eP4b/P+J4t5tE3I12CDyZUCZeIM+TY8SP+wCHi2qQsamCB6AwjvVdTJs8ElbRlu/KZMZJTADZYib+ndcYcjrqKB366JrHpGkNdosygkt08DRSiUJ1grEAtYiQuLUE03uxyVRGvU0wFgvgBvf3Ts9sCszmEygqB6TyFh2HVNP4TATw8SuUZ0PHSXp2AgGfO6iKbXAeOUISkCQMUALk0nhb3LVEzsEqbCGKiGURbZbQvQoPFnMNoAwM8dkWsBf++Xrssk9e92NgFra17C3WvJYoGglfr87v+kkJwNgBFGSB0DSD7ZTU+wv2e5iHH1d4T2/Oz4f0nop8OlyEh55/6DmfiSH6T6+HMkWbxS2Wk8NtO7mLU3AO3zmxqRYBszky+RWHl57jbgjHT6v2uJLzuly/ldmQ0pirXjgTsEVRVto71VecGTM4BXPmEK8u3ygJZpZhTwbCo3F/1G8AMc2E/P0qhuMjym2/XGpc6Ks+tlSSrxuJ6nPyclYP356K2PyIEtsjk9UJyhZ27du6pgwV+v5oA9CHx/w3CJZxrdy53Lu8ujIRD5P1IVb4u08UZRrL46XH+zMcesz6LPRCg8tI+vWpdOR9doLQ1Cd0DTQ/yMfJ/XAVmHwQEqEvAZIXtOk7g1sHd8d0Ob6zjr7Ibn/TqAilBEQbs5D/RZzNsd3474IqUpBbMrH57TPbdBCeRlba5P8k2VvX2uQO7oBXF5sb217pp4+066DLEHoxeCS3fVyt1LMpCMRtAli8HedEgOKVYM4ucYkAlzAFvPCDBdQ2lrQuv9hH+SofR7GJQYRzaMUApPErDVnk5pIvu3hJjMXnUFvMZ32bK4pvKyCnirTIuV9UpajGW0bNSPBXFhDQJr51q3QrnSxLsjP1TwKxWQYfP9ojeH4VGihVAlGAr8qb20SgqupLnX+M13PWFAZ/qNJQDQR7FEVtwWzbMYzPvmYBxsSkcKHcTindyCUtnexPQXmlGrpGmXYmiF+npqo8h3ONDPTL75XRx1h842g5yRAE+exAdgvinpIIcFzAYW6CisJ/ka2cLltQgLGVU1St5VKPcf72r01Q6VSIxvvleCdRMVRCN3BgNjO3fOq6XmMab7bad1lfke2eCTv+lP0YeXoJXjizLJc3LaNDDKJBrvd84y/p2uIhoQuv6ZD23gGG7CSk2Hd4bq4HgjdIa/V2c5fisSl3FRLiwZhhC7QOOBzfqfpoYq/BOuarE80nyUOpcWk2acn2Qj8vatZ3tGWxdO/pv6hcx8hzqZSgQGj+JWmZ77sWutHqG4dP3gegTBJg6uR0mDjIhLPJvfMOh8nvTkrzti7Q4A5q2N51R4Z9oTz6j6+ry6c3ISXbU08iWCbb+lwBwzoxFz0yNqUDi5x+kVseCcyCBEWiIcUSLXB9mwnFTsEcQDmSDIpYYillA45MzF1wsLsjSskpdAk/LnyFZNBGo+1gWXoFzH9QMQcFZGjSZl/hvuWv9wUYLtou+X3rShdt7nMqzqPOuozbs3zsTemm2eG6vRTEIEB8Yf6lzE+4lDy/32wrSlwUS8/9mn99IsijA8ThmJr62UcPRvYyBXabeGxwQb4VZPCLEnHSh4WtDo78FT39qQyJc35yanO/0imdiiTygOZ4+rJfcAb7YxLJF+1ZHwkIdhv1eP9rAN55o2vZMLHehkVTPT6oHSRitQvxyaX4jRFtbnA2Tei7A9N5SHN2NQsLOAADw91bQpnIt2FRO4MNEmJ5HaRkeN1du/VjrWFXx/Yc2nE1vrvulV3U3HCmVybTZVZTEFKGw6Z7PRvlXNpg99AVxwcs0HATNKgCXyjFDwc1xhDou6ajU+LbYfxCXWrTT7pToVHr3SmwGQ2cQqwj5zvmQ3hpY0YAWy4QY+iVHEKdWLxXr21Kyi01zW8chFLQnUlIFvgEQUcqWtTEFNfX41c6NpOmAyRBRf3ACxJaIvhLoX/97g47gp+/z7kxx8PaM9YZ9f07dIcS7EuZ5jGzHaEqFDPxAC+uJHIPXdB1x4V9yQHJCbx/GnkE0ZDrHLlGsX2qPzIre5S/GeVtvYOxlrtV9LJDpuY3AAhrI/t0K1rknk8Cu2PNK3mt4v8J9hx485fSgiijJiUHwdX68LZhzMR65xva5lxL/9fdi/MbKfYSOSqPgCQ2x2bzJvEwiJCp5Vcy39AK7lz/5x2iPZSxQ8rndLaozg2RyzDPz2eV/Rl2rV/GNaW/vLEAulTbC39MrzsJZNPtBJxxgOgK2LNo/PX+HhQVMLbUaCeWbhzL4Rcu1xGFiPFQnFrGYU6FRwYkoEBAaZc4kgSLFqgg8iMZ0E6nx9wyF9zvgOSviQf4hV478yoanD1yOBQ98s0g3d5tw+wB7V8ooTJsgahT3/OvL3rpt+beghITRSF+IVJC+opgU1iOkz1dP4AIwapCSCLOkOGfWFyZcnGTNuUPrwxvLzVMJ5SwA/wBsqbFVKk98g0Bqib/6Q4Lv2OB3CQcA5Yf8Y2s3E7WjD6aekwYNCZrf687on7tOZIfVe00PlqqWzSqm5BeUJyBz85cvcoGaT+G9GjYzF0nvkxKYMAfvrL5R+IgNq/XSbioflKhsY+U+Onntx+IVi1D908JDVmFPMLRtUQBhiguHeX9o26MFS1qXCrLobh8gTWrm5USoyez7hy1unItp0sgEW25nYWSFnks0Mj0LtdwhN5mP/7KClLCjuaES+/fk1I83owhCIQ+eDCXqc58gj3feT+VrGjYqAO5zj62nuW7gafZD7ilPDwmMrVbTrw1mBv06p9qLJ/M2hQ4cc+WNCiQaIjbDR+V2UgJjDlWgtu8AFWro71adDvlDRBFyHgzqdZyC6ZAdYXqUNMzvDwmqx+ncAQRsxxe43KUtCixAzEjajMAYIGUpI+u6woXfOdDkbtFNTlIgj112EXZdBE/h3kgBS8DPe+sK/RonT0Mug5kGAuliG2uo/aeCImaZI9fIuhfch2uvR4GXL5tA3EEBzN42oFXnBVSixjmhlVLhBOWW5Id+UM2B/fs6JAOFK645WVgtNCV2sX60x8zewjRLfPGb3XCKV3/IJCeBy3VzSfI4f2ih0BxZ+y6UbsqEV+Cp7G0+Xx2bh0/5zyiNolpJzdlNduIizYbTdATrak9dau2D9pVBYiiTCnsUbt8MAk2cmcNu8t6FmQ0PFbdoK1bNXyn2qYnYwAJ8oy8fTRyKYNdDV7l5j4N6yW0BtNfZ7ZYPWcMMkYwojZjBHfh2X5bClU05//HxguwsXkKETg3Y9hqYKEdF2GyqaEaAtE2voU/2BRZu5LvcODyDpVFDVpJLpuLE+1jj+tyrn7n9Z8cCWOPcWELDin8WJNDs/ScHLWfKbAAEdjtZ42mQUzhJgQzTsUcRKORbENU2Gn6e8svxXtQDPhZ2F0gM+BsdUUMfPZh6R65RterADAJ0D7sINQpTRN292jRE1FckINmAwdT/4i31lEMWzU03LosBzzi95hOdV/kViCFfuMEMRD4PmUWHvE7mxwH8yEY7xzWmqBecNg9L8vAcKh+E72kK3ZTwnWM0IbS7WOIg2vNNR+Wv2IMsZtOfhae6LxhgjhMJL2VccXhoy7VctnOYBJpt2iaWIqYEhemxPnqZlMGd/5hpvFWd9bZ5WISJ01C12n4A9hIOSfja9HtbkViZuhlncpRdZxE7srb1WwEPqdS9zgoCBhzda7oFVIUkNcLT36fT40wxTw3yrt/+RPU6pE9ysl9LTpnThCpe33cKBKksUJmiaEugqOomphmo8mwiMR/1CXT7f05u5oIB8/CXzpvU2Y2na+E9bkKDnvO/dTtqnkgZTANlMsUzgDBe0dmXk3QhJ3Bf1jM45oVEh1Z3kLt/lwIfUPLT+xkkfd1fNXix/d5vxpDeXGq8Sd1cNB4WtTVLGe9iol8UoIB9Le2B9PgzqukQAZSB/hw6kZwNl/m9m22dBYgvVvd+PCvdurS/4VkLk2EAUhzYlsLPAwTKx00JgEQUYEI9a2JFKBCHmsRzGfMrIHeKc6nvZzb2B37bDL8/2bFJeO4BfK54GaLyFzyZxeSWEnE3/1qfC4slxWdhCwn/X3qMbTKIOtFR1DmxBo+/G2JWEAuUJqJSSfIBWB9M1q+rF0k4CQXcQrUQhLFS4wFrYnpK18PLVtXZKf6OvdSbxDRAxegOJxjhlpgx+Iw9lP/j/QNIIsv8enaAmIKgixXSw1yjYq9NZZyCpzwuXl8qH6Lu9NtFuGd06F8M3h5RTDkKmJ/StHG4n6ZnJHdFyyuHfPx5RauFKrLynh+wkiPliRpek6BfmoqKHr1HhJxsU7dlJfVDf02Loq98ISrucR0FG+Ge0HO1AkeRXHgs9+260dB1/JmoCdw1HPD0Hi9FmK8ilvz9GdCHDNrBmyA63foOopVX5FKFm0l8tepOhXNOoTHqvjD9AEgvRv4j8fyNKDkH1/E2KVREB+/1nppExQf5sd6gjlbfqcgtYNKgn9koiz19KlKo5cvw1n373c4IUVugUUxodyldXCaGqhUs1Z6ShigvuchDXK012DwlCbttWkqFczGVaB/0EvBE2OKneAElUmEmuJbGGCHUNShm4iLVDauGV5Vr+qMk2ruUN8HbKhP24qnWNoFrMhXGONzu3u7HHIkRAR7OzaNWxeCXgkQclfUVD/IRwedvxWAVlxTiuJQKOIYBOaHGhUvwZs9U2vgFL/Cr4iO9jXxeulouiVx5bIeZQuPbZ6fQGJqGLLBIGI7apr8u5I6Vbp4UvNNga2VQGFfw6eZany9UGejJ39MlmD+EX0pSk7d5GSA5M0peVbRQADucncCvUT5gVOu0J1CHRghabOpjqYnY/nAPNutRdJ1cZmMhX0l5g7wd8cReL9LxDbM3FLR+Sy3ZJwJ7nur9IRMJGsQgQwRuIBKd6x5zxENEHMaXF+asXRxujN4sgk1HqzxlmlwnfUaSybnahA6mC/za1DSVJd+jQzeHjasWv9L06hD0k9hpYuGP9qgYObkaG6n/X3udNw80j3Ok9p2qRZjbrnHhTmMTT6DL7S8dcclRHJao52MwYe9CEUwevgPexAbqHIAS4i9CLhxNqbqPtp925Qjx98opoLySZrGdvXji0rTrGBKJgDMk5HR5ldqCFpPtiqvZeCWqEb4CC5zftHdJwLHKnfGEJnq7hls431pTykNiRKIVzog7QLrZL5qCCnYTdxeB+mDA8MNu17h2UzbWPpkdXIIzOjsbDjvucNHnktpBLBW4OVBQPyIV/RSEhvcfPa1b4MJd8QbskgVAXaAmjDQZI3VwIpOEPep0Cl8/IwkB49rrq5irRcnhd6syDBs5hdQ2DVEokrJxNIPXnqr/Ud7ajw33bq5fYBbIthLoe7L6Doj4jPQmSEgYIcU0E/breuBUF6Y3s3qzNOaizI/XmrRF09M1qmhSTSoW7tL55Lz9hS/GLxkIUmA/siJGayr/L51hk1h0zy0KOOds0Lwa3kGs4azvFC9Gc0lCaObmcpbcHjSIKT7zWrZNDBqrdMWEJSdn5QM7yQ/dzwf23n1ZMbuysJXvKCoiK7BmuDiv0ibPKQCS1d6fcRG7rElzyjEXkq/WS+Bysvhc4Wkrkv32cmA/IFxGCRLhCIMrSSN+GS2q4sGf6W8PVB6y3+v7L/pNAePuvKNSfGijFGc7CYmKkxlMGb729bgkRFpgbe34vry3la6cIRjtB+n3s2+lA8cNn/nYkBdXb+ybltwfObDqsd6Mz+C/YWNzulzqaPzlVTnjcnvDI6RCZnJrTZw+NbLOTi1X63VZ2H7awXc7jTpWWntRYHq3cLc4JWJH518Mb2ApZtykch2BUwbirwG0XJZ9jZURwrT/CpFF4d1zkVIns9xm3mdCeIHZWeW0ua+Y/8FOKpyowHe7fgjWIMy6Nu027l63s5zkiDZNrZxneqnABhlrjKh5qOwVEXSShybzDoGeHfIA8z12xm1+GSp3WNDJM8fSnZmW3R0QI6ERhfP4dxc6xJ4WaH4VeC35mG/jzfdRp88VJjXHpJPbvr33ewPm+1svKBRSl2MHE1i2Vnxhokc/DKwWBRnOFP0wWrGf4OyqMRljv1cy7IIPbm1ZArsOmsTKB71GUa6fyfHAgo7lP2ir2nyiKGzfEm7h/BdlMpCa8KV5+DqSnDN7rwA/r5U+7hOzTtnEQWdWI/EDcX9k/67iBjeCh0zRYmvQR0cp5NsHDbAU6su05aMgSkCVgWN2+qoSZYWlrw2XjLELZX/5d0FulNcLi+kiCNxnX6OA5BRAtuS8oaxI8s2n4vHVfJh8uxJpU8a6D8MZ4EZYx2DRhy7p0z1FUalk4xjlSFbBPUTrIWAloAHo7FuAQ2BqtYsiHDNiGzpMvgJJNHZVM/CckrOtqoeUsPHPFzDu+EzlrP1ikYPIYb3VzRQgnIdCOXiS6HMlB1fv0mxNsqvFC7pvB3G10HqIpiapt1XlIC6ip+ve76ZqD6NlnvAt8fvoHjrVdmSGOyq6ryqZWgB2+oMb1gPMXr9cN25nJFEe+ZWDSyZgKWM9BvnHqQ6O1fijJhEee1EW/Kj/wmvpOQNChuTkfOGltz+wX8G+V7Dq7t771dxBR4Sc85SkkcSSDWUGwQaXravYriLvF7eB9LtiIeVMlQkIkNqN10xXtAyvOtkUxnkv+oiJvGsNln6wk8uA3aKvi075RpOhsHz/zSu9GkjLbcwNnrTlu/fIW3vFUMOjlidXaXfozEJ4RE0qZZdz1q2bMZsAd5T7h85YwwuCsEeZdLnZo/VqT29sLgh0U2Mod9JNyBSOlESBihpDABHycPVbrLWNJzLKWZOAu9iDZqSoL5KfB5zlB9ktH9KSedMCFy8FSMT5xbTUMNtD/ibqz4aYlYzPop+rLCtLqm58daqDbWtB6XgcSpZrseqaKHumTPlaKf0LJl0/Q3/Nu1uACZx/0RnFWlHX1SBf7XJVAs2DwQdvc6NAKVQjfQeADxY9WODKcQU6515esLrEyo5arq6M9qgnYSNXuMczxfzNQpcHB94CEUAgKGPFBONK8iVidvDMujlCjflX3vNEAj9jvf8/0tVnAeWf38R6hnVrx9cn68pzpDs4mblTdLP2dQslWosvYU3EqxsE6yc3rhy9p1nZQn0hbo0nE0jyVOJzctz+GM7K2WLwPR+sqVigj0CwUUU3/12fTf3uJPs1EhqOh/u52e3+1FX0/Y9Hd+8CCOb7BzTCn34vIicH/4onsXGvX60vL20g+Qq3Q+TXZJtb72nQ7jYAF+Y5n/IqQC0eXSTB5Nc2q35iGIdfCTTCjNo5ltzUY7eJTOxp/f/XXyjP8+X2QIVe6ZDyhWdC7Wbz2lQXhKTg+GOsoL8r6SoEnbuQoRAaLQXfQ0sud8Kdjdsm0G84GYbAxU5Bfk8ocJZ/8C2SsJecFDt2cPDPcBJkw+C0xCVLbyUUK66vB1gW/mEg5Gwt6H2E/IUYU+iL+RtY1CmI/T0RKLVxobJP4l9/VCorCryp/4CVZaMcvdqdQNYc9bp5nsQZ2+yxMb++ZW+OdjQXYIkbfNFW5OE/HVLOVbbdtVi5j6Hp3yki23D3vi48tfdt+UzLL3epEjtfe0q6FHdZVtac05FOAZcIK4h+l3WmFY/o+iyXt1iKmnfdspRwIsrSWIDexoHMSKjuIuCV8tHPUl5XR7jC3bcHZAKS3N5OPy1+eZICTMzX13y3RxVxjbOQWmu4CynioeDrwMKv88gQWWFhJXcEYZmU+a1lFjc8iRC8ahH+rXwjwW24SSHLPjC+p9/vhBsFxUvIdC6uJUYfx6/TndNXINQB8LcZJi1L7ttaqmcerEBxih/iwcsYbHvURaDFcdcUDZUAj7MM80U6KoTwAQfe1lwAlIOGzZ7U3/Gi8SWJgZqsTwPzMWGZ2yb3ilsJlghtodX7vcFl9WBE4L7Vt22C+dhqFaHtnyw80/Ez+ignxQxsVkH99CP+VoByZ5YkgK+6ls5l26a7xCfAIJ9q3HU+hVHwnLsUOZl9y+epPNdQzgbb7ptQt5ME9Mpmo8JFN7LK/UybqTYAc/blPA4UMFMC74yhRHtAXQhtHOryKf+sDMOKlNpKYkDZgSGOYmMx8cj1miWrBxVkekHhGjlFnPpuoQQr8PYO1CQ6aCc7GTwg/LgTxhxrZQjC/HtFzvSWtyNQo6m+gbMSk11tQSIssdgTAabIXcBBW/wa6z1i/mX2+Zc6l0Ee8GriSbRVs9Gh57vlowiRCrsV5qrRfb/N5lBz8XJZv3F42WuCY8vIj8Ms/9w3ZR+yV9ylsr8zv+2bUvZUKQVKpcW2Uo2XnfYPWCKwjXAHdhqMH8i2jiucoTdzKCr4kQg0IBlQXo3jYp8iNabSXoQyLSigLpJwwo8BbCMrsYSPraNtfj373Y4QhrDifkILv8Iaj52FoujfPdcm4wOepGra25nNiKiHOGdnbQGDM5ztCwCGRPHs3q3FPQL3TLywZVXIrxkomwXRpHG55ExDFJLqQhypCABED3pLNfYd1JRKXRVxipKeubGgmdWirgYihy0R6AmMRy1HdpLKITvjb8WqODrAnmgz8LhlbDx+JLm1u+zzbaWRvCPS12XlscKAIYKqqFtgfbuXSGEzud7GG+2F9QjKunoM2XFd7Lt0Tqt+qbZrs5PFB/4rkwggpfKTx4v0IQu6y91ErEZVpoldUX+dysmSFYdtO89p+CMKkunqm6/Q8zhQ1Djy15jOsEgdFOYC3knsL2T2pcqb6er0qM6sJrZpwqV0agV5feuoahHr0kyN2v+2/GroUQJ1eDoGlwubE+5EnNfLREXCMudoFXPQyakjxX9XGzoxfDhnHv0bYqCQpwe+9sMHyW11iErqrz/z1NT2NjIRnBsiYLx8zil90XmXbh9gzRsV4O4iqX9OLFjCHtPu6T/Pe4qgQkDCkwQzsiIgAQ5Egyil7ucTiFKur/hfd7CXOFyVspPMA9VmrcoEjqXfXHIZGhNlkekr2kcmYQ27o9VDtLR7+YOiAW4p/iXhr51XkoZBhadT5BT/hcZtBvH4LtadzTkoh9PL99iKvh3rDhROBniL8wEFE9IwfJR82QdrBi+HdTW2oh125ifKa9WKHLdWw7GILhz55w63jRROj9D1wHaDgm+mLpr2XxquNfQP5hGrR/Pjez7hOZjAkcx59cLgMxulfzvex9k3QPsbvuHqUDydZGTentVT/KRDvLWWEU8We4sI3323a4xlXYCbQ+Q7q9tTf8kyK2BaLKjZFFUrB8WsEUYFcS8isHmfHVLZqTF34eWESVguYWznFrBIq5nlmDniuOsO6IsXUSnzVYR89CF9n+C75b3obznSxa6WRCWtNZxC5GPm9xLpMQFKHxrddjMEY7Of+zGhA5vv4pPOdcpSgY5AoTxP+VtxO3vCuE7cxeMraUxvWCa0cu5ezN7vbFIbSX78q+jKdhBWqGurlh0X/st3ITUbEngkuuIU+An8pxHLgWMYMM9AgSctmwRkH34tDuX2oM3ISxOYXNCQxkRF5omaCEcGX8vzCzLEtiZ36I4YNBhdOidvwOAjVKADqX++yGdc1c4vkVdwbCGoeFdE3SocAoNzJzh51y4umTVFIad/28RVnPHt5cW597NEQD7mOVfX0z25Zwjx0YxnIviagnOpT9zmA8tfzBe2HqxwbT5jMHp7t+78ld5K9jcqMhUhfgyeyTMPP1bYK6va+jbw57z5iVoENSPf6kHTXesvA4e8UBrVzQsnfWg4mf28/QfXseHqDof3FXxlu3JvAFvqyBl+pTKxEJqwTaqP3Noh94Dxre5OHT5Tm/I4unfLev6Mp4dBFztxhJa+LMyzOQ8KM+3MZkDCvUkjzDwQEBfXCFFfd878scG5vg9kcjmLje0qkoW/9FrR2NQbke4a9sGwLVp2uWwWvUXbzmLb2y2QuDXHiATLbnYUgVcOScIqDvHf8goYFsm3cqnoKheR4s27g7BENDcfratv7+4o3gXlkE1+RepjioxFenM3jZFS3NapMFMzxPKEWnFFwQLQhTq40jwRIRSlgo4jiHlrfpTQzq/3fLtET5Zn1CytIKOw4fz5yjVt/YaebSMnap9Ku+1S2wHjyCCcXq4zjT+IlxtSuvTjrbxrvbvsj9LoVdxVSej5IbV+03RGfa19TomSyDmi6RuOu+hBBeKWd38K9YHDFdcSR73r0XxTHmmD/28L4iqma9Wae8fRWzt0XiXP0uuFzpgS1JAAxT98UIrMGvzzV7uYsZpz7wkFNgwAALY5th7+Mo4hJzt64PZISoArhWKZSJBA5uNgaNzvFE1tqnHT1gL/mzSf9VNqkLMExhIhcQCyVbckF4VIDxIoQaDQrbY5eucO8ofYHlHdtor6Zhv+8v0n1HcLabWGq7Nt+Xej4USTde8L/6GKmkAN/hZpH8FDmhrJGXlH2y15LlvCMPVxCgSijhZTQAi/ZO7pR7wzzU1vaQWfOleyI4TL3+uTYHSyZNtHNK2Nug5Cwqi12uFy1ijHqaN5nIWc78fnx27nk8FMAJ1Gt8Ll4zPk3nJQEms3Wx5sNRNSomymivjbjJsqqcu19cw0+K0bBa3We8xoEXgl9KwqWAqnxuYgoLVKD7J0jGQmjU3+MjqvVn8nkGJvOZr2kBhdHS6MRrfYwM36u6iqeA4KchIp7ds9lGkB2LEiNJVeoarqlg4G4Qx1QLeHxion7cOv1irhU1IyhXy64751vCO2apPY3SGnKdV/RTq/vnrcbDQ3CoXWVcLtUAhAEOIb9dLXHifWdfAZmjlzZ5d4dGt18WdNou33KNh4h9kThnVnpmeWK8gGvM1irow7XQaZbvGNkkgjJMVcHCVfSE9XfCMJxw+m6S3QHz7l9ruu8kEjCTVS35GiEbWw0PzLvquWhALBvF9bIiLe3V3khooyjfkSnnPRo0iWUULeW13mw121acbx+1G88M3TFBDpJOdh1jzDhJL1206nK54WgSWoQyj0J4wjPom76ayAikZDBfEQIpwPPSJ2ZHqwj4md4MJlEZYLYntfeMpSCHdlsvFp8ogMoc1TgIJ/Yp0Mg38hcTHZ77LGRgIHs0etNppdJ0j+2ycGnfMZNwDRTarVBmEg57p3jGvgTAC85seHl4ZMxj1YTcI+i+51iDPAkP7xNzgFeNjVWdEWIyrp6BSuLFli3uiVAxJE8IpRVAMKc7mHVxoNqwJPPAksDSPMrousBNxRACf8fZaL/NGHuz6XdbqCjsLXJ4QR3fk/sclh6A8yBZaV3iNWwxdpv+cy+meRIdEtT7uJMHEXDlw2vcu3YxxFd2kLoybnGfqB2b5RxNC7OVY6Btrn/YJfOm7s5+phYQeamSX1LsnI8WvJPkFk1npvdjulhzT0hBKwghfPsikMOJVWaplWTUUYPuSOkHrRu+DlXHgJ1OJ6Hw0GYvP8yZZ1xbfyuokUSs7PnduccQCsYAj0NS3xv2Abf+954iaoS6xWVIknsgtTQz+WksHOTobNELWs6yZrHCfDX8rpOqwTT1xl1wdf61rICcDGG/BNPk08kjGf/ZLaiRol6KWSQnE1dffPsD7ODGuNI4/Kwne93cQbdyGBrwvHvqhRIY5MeUXLmGQ74NIHIX/PnPvwKsOfRHQiiMMBowO0jhi6jrt7lEG6k0x8flmHo8+dx9t9+ciLqI713ndqFcUhphcOgZQvCxjvWe/ULhi2vDMkQZVDQkINnsSfY1Z0feA8c5DCtlOyXfP8c/lziSLL2tEILrXdW5Er8PZFlRB3Jz2X7f+IA/gYW7SS6E95pT4n0n6QUces+hG6TzZXkZ4P0IUYa3DM7QYsMRmuhkqSNXKAizhBmnZ2APhJL9POozMOlzoSYJnL+t9MMQXNhSO/H8fQSUp/SyTgSbSta+lKMZVSMWM4G4HFLIii+umvHZPHX1flI8DB0opYcuOxEMtUPTxNoFBum9k1RsWcj0ghQZPt+1Lq72jaQvAUXilgUQh2y2zzKNqL1OCQZ9eDfO05dLCR3L227rqFopjuNoh1m6gH6Vwbu3FgE1ErXv9N74rApFNLcOvZh42FacRv54KVVGBUXa/gexnrg3YtWxfa0Z13LxetWO+mdFoBPsmfDxupuY5CCm5dTlH2dwXa6DwwpTf+Q7rqJ3MInwrbkwCwY91NkVAoHdV2DCpSfjUkbWChATjGI6wXZhZeEAIBblmBQRz18YUcW2FHAw2JqRP090aDyet1hjc29jevO4tw6x5OzpOqWBXPijRyfUupeZkE5G/ncWLjG2QX6HyRsm/pv3nyAucRW5yA67Cj8Pevv46e1IFT9xbE1wjwxd5Jlsza6o/nMjiw6eum+D7alMVTb/JPIMKbqJLFRJ6vkrQGxiHAXPlni3SYnuGUnRuEx07PU9TIdMWRO1R6C73RRyAb8BZiEJVG3jnb2eAAnGn5xuZ8ljDElIlir+u6volySrcLhgJhbi+eUkyx6KMui3ja4ceUBe9ZlKQ2AQtXxOx0b3NDS4iwENrYcX3kLkHZbNloneRL1dZ8CEdrC8ZT7C4SV6EdIf3/cxvAaHBWrftt3YfMRYdhSkakHkG/zj3bD+ojLiQa64ruiQwSugtNmQPPN7nf43fV9d9N8evuf/TNsj5fdXRYaqU5St2e2m7Awh4RnDpP6eHywUozIbhe2C1mnPvK0GclIYKQxS+ffGVBVjkloSCuIkiVlGS9DJzdVvBpZDT+VVGjmUmISKxHgXR5L68nKHh5mhvF2GrS0phqfx9l9z2rJUWsTO6xRR00cxGNDrh+YiCTsCaN9z1yQ3IUy+Xok4JWi3vP9MJTnbCEpiblU6nDlP8EfEI1JRPhSCvHkxejukNswW3VtpB66ImU3RSqcbv/npz4wl1uvtwnIIjxEvnz8Aw0+DE6OzIUV5SiCPTuQSNeUgKfjR9cACZ9ms6j2NVdXUqKvIouSd0lXyPH7fqHpPm5ipxms3RlDi3D15YAY18hpfN4GcG/L19IRHLMDJZ8I7aGJQdZYwT+CcYyn6wooVzw9pNdZkf0ka8Q8f5IzeotVeI8Ajpn0vJgEsIATxErkcG3dGV4Z35eXzV4Ozjyz414HzXhFb+LG9U2xuRAGTcgWVZSLYfruaMa+kcYTXqWHCAlPPigzo15raEKcwophCrU5uaVSmN7NGVffvCgPyMRvOi8gdMZldp2RoFjHkT1qLx+6tJtLucf20+Q1QYjZqQJ/IMn6oAWmLm1SJq92CjU6FSu23d82iBaYlLm6Zn11yz3KtIrNDKN6ekY07m9b92OAyc6hTV1xMOndI5S8d4WohXWrXH6E2RSgnVt+0ucc7Msg4Wm1A7RGZ7xr59Z5fJ4yLxSRiGf1L0VS5UFqHGUJZuRk/Ipus7jCoylHereFAlRokCd3vEuT2pQ0dKXjeamffTsxwDKOtvzwcDptRAAvVirrDxin4GT98IWdqHelcNnzLpOZFEfEDnLqkbwI1UXw8wLjuNg/Dj0VjT5W5QI8dBmexV+JkN1aHk8F55AFXpDQxSGG4Sje/PqU4i1k0vqouqwb0EugX0qq9/ka0a53VRRu2rmOs1lFqAdTdeZmPQRrxcsEd5gVPjQB4Z4jUkDmYNZlKH3W934QQlFevISzL2NVb/cvBKMkdGN3kMJ6VGgmYMk8WZV7xaH6s+pqXkKBtD9e/mhaBNpbPiim7uxZrgOcq5MC+y2JghgfAsYoBydC6isOm15ASlP0ajng5CmUBWk/bMXBbhZAACLepSM2NSNCQ4Fxp5Y0gnKmYD/XnImKRrYy97PXbfElgbOBOzm5jhNG/OfnpacbyeFGto/8ctEKDfO9dqTZOQoI299UPDaRqQNxGRITktp2B5O4DFw20F/+Jj0PqCYAeoM0pPaOejvTRYxBlbJSUhDGmzWBPNWZCDz8Q/isKlWTY+C/KDvve8kMFcSq7Sl9osHBgekGO+ekBx7LJun1p9mrlZ8PS4Mu4ay0e3CHzNTuR/6utY44AZIOSS7iUE8RE9B2t3slixq5RfdZjnaugZ6oot1Oqkn3pP/p0Znt8oFFteSTXVav/i5P42TBOVWDZ7f4rR/7fGY+yH1qS141RG0CTT8xc78UYu2F3feqThYAiAXnB7f3gByxpu1jbd34JuMfyqPcsWi1/K8E7RztSQic+WPcTZiWXbzi173YhJ0TAxRMeQsVhcf1wFqtDC+ltCe3obHDEkrfYq4KZOhcsqjDsyKPCjkE7B0rQegiKglXOigUztvtyGD3jCy6z+DZeBa0St1MDeGSwOozgRbxXNK4/TtrQ1g7YEgMLJtsQ2xFEIgeOJoX2KBWJvblXaNFNqvLTxAQ+mjRwtuMRBf2+vsUhmicwycaFu7bgfhLwhi/DGybGBXYVltULgasGNulcu/AV4H3j18dfPHdtaWkc78B1AitzBUkYB+wRoe5fB3xVKGnMJNglfQFrKDd/HJzHcEwl0fMuRY200vp0MojxxN4W6/CfPeUnm5y+7Qwq42gci6retufM+NrJfJYCaBP4a1S3yt6z+DPZ4Ct99gca5M46GqWWovOmEIrTkDrAPNDVxQD5kN2CLl+2MZ2fVqbiIPgY93ewkGBCUtFNCjv+AeFSemJbeVbNr/72lGS04QvcNeMxcsF8s0m1DxyRDB8Gz6G8ja0iPeBJq6Oz6DRG22vb+BxNDHM5jHRokdGKT7rH5d/f/797rZwGKL0SxSYGNZwSPHl4aHeQlxdv+0fWpQg3ZGhKzFDn9V4ywGeteW4Szc5O+yE0DpkvUFSbjBexAEf0p3/xNKbptw8EA4vIbF5Nc89npOEFKXkqn2Fm895sJ1r0nesj8IcWrw2KY/eDl8amaTAomhW+nEZvOvjE2cgsnk0kB6bvMusIYiTKZOdOT/tTd15+N9DZW21yqWuTn88O8F7f/TOPEMHSJhouln27bYV0P9nKHoGyr20Zsc3pdu6BPqYyLWvyqR3/vFZNpd3hqNVbKqRA/t0+bEzfGpRxqKB1Ti9zTf+nEQCSTx6i3MsW7XacwSDdC8IDgJM2BJGkn5JEBJfGhDQehvHPnxfuk4D4ptFfAwr6POj+r2/nqmxUZZYWCUQOsXXUifJqjLIJtdUi70r1ZzAikAzsguaymJAoTz5p6+NmQXhfWHy/h1sAcOnqzWxwOr/7GW/O0D9PcuLEg16cu6Zq2K7n90+1xndUernmXf5WyGLcm9gOvULWeoSkwGn6ME3KT2wspTR6nQfz1Tey4U0UgrbXtGtaJNZLG3SRKs5hjpFq/qG8KmsqJGzScGR8fBGatZiqCAWD5gESwG8Ar79CTIBvFKUwy/9xd1Sg0orCVzlAxC588kjKINkGkc4lE9DdWW5Pu22ofEIIubQs8zH4qTlycSxSViQUSCkwd4sMwFORF1/pByM0Nd44xO2A7I+2TFGwNLrgZBupMswut8jgtGK1qqRPCtMZsu+chJeGmJYI6RsyzRVY1apEriNUojyyiyelb51raTnxS+Mbandom6VULWwEmTv9+7LBT+6LcHvWk1IBdgRTRTclT3zL06X0fc8yNyWUAqr3MCriaAik7qDR+iDLnNqJgKroA85tFjIV6/aMJEmw5AeQB2OQIC9kz5pB6JdUu1oZjDCi1lUN4RW/CIEDfP7wcIODwlODOGFCVbW6rYS9YcHQVMX7uWKXhaWx8eBFubNQHD6B4X/1diwnf5aK+E+t1WSubzymneU+PqmdWZ7QJJ46pkR8L9P2XysAn5p04ZJ8LWjvQ+pxjt4pJiSM5EP1lDM4ALByBwA3Ez6+JJak6TtzzT8PGj4CJ4vE/0rTHyuqGUP8J1xfOMXBBL7ZhZmKRMJZotkaI9o/E4H33sDUoPNuA+ctXFe927X/D+CYGOQkuhBdK27xYOtXZppluZD77P4qm1Lc3+ppl1sgB9qZU1TZw+XGkO057zHUg6nmUCXUh7wqEnd38TRyeDxKO7LwV+qHOyjnGKPFuR6wDrpIj79DD1jxaL+fXWPnIGY2qG4+b1s9o0gT0YabHfvTvd/I9SOus0aQ+Xyv34hPMyZSJcpkMWDgcNUKozLoD4W3gI+WG8fl3MCf2NDDrajCeghEXQqju5PWAraUTraOkluYSY7yT0JLkbwZZeyEnUZKUKvC8rYFJx8EsRmSql+6mloAgNenEktw3jVs6dvWgj1xSM0UfwG3zql8I+kOpdt0vAicpBhssV81H80Q6KG2X+e6LCud3DXme+XtwhZ+UVf2oGs3qR6EJ1uIMkC5ozkJaKw02NXyhi/29EP01S/oAv6NkWBgkRRkYgVGQz5/fFAxj0kzhuw7nF5l9iTrcsg5wNQOgxdeoTP1PHKQ+IT+J6r86FAw0LGxXTLJCmJbU+ihR+5/RU+edAXBCZ8UZBPhp0SnipCEO+dakRjh4nk8ziRp8N4OvV6nUj1FTnyw6O6pfhe2oWRBeX2mm4GAAvXMBL1kLbCwpw9E77+AXpWmAb89+WpxpGGdha4tNcSS2ySgMFIHL7YCO3Jiq2voIxIzVQZEhOE/Pal0RVNSij8/2Dr6YF4+r7dyWDIWNeLoMWngpikqNdA/CJXcFCaqqK/Wl+cvgj/YFFPH8yzTt/XSobUqLRF/UI8nETGPsoT/ZNz4XeWQhYc6Eq8Bc3+QMmAHs0w8DrwCR/5l7KGdytdWCHx7bJezvkIAx23heEd8+lzEb5RSB2U5a2Hqw0FY4QkpMq26ZB+dVMAWT4bHS1XVt4Cf/zbuKelXJTKMLPkmEnM1ch9LvIEQyjD5IxtCD/mkNncK86sB7h+m7V0z5cPKi0SToiQCg8dN0+3votb1msPy4+Bu0Z7OugZ1XujQMFf/HzvvDF/80R4jSXUDz1DGTyrCNenhIsMZ4btZGcv5Rg/okvpen7rIUh31cxAyVOUgch4JlkKcy8Y5PVdxJtlsnbJoaY6U5xYh5uaD/QPaJtuANReKthWyPq9s5j80wWeTfRx3ujcYaegtf+Av+SgQR360bmbozHyO2pbhxCdxyLMcy8qRmmzypCaumyc1Wo/t1K5kLNGr4vnwFNPAvSOZLPABKuhr3AbIoJ76VQSZV2V2ZbV/PS+/sqmvSD0EB/ocClXLQwbY2N+kaMt8uAzyci3BAKvfQ+SqvN2OVm4890wHkoWBJ+zeJiR0DaHleXbagQFNR593A29N4n4zjYWhFtaf2vWemY1ZjAJMqXj9hQozfIfulV5SeuNbBtBO2GkYGpyLCrlETRFa8I+7AjRgQDcVAKoyZnUsEIhtRModSNkyPmoXON13GozQck310+28n0/VedZVAbOFqlGbaEEE3LmsthIVooPe+N53kVVYN2K1hWvP5RNcH2jYZ9Q1Em5VVvaqMfk/d3LMSG3fK6ykjYxPgKCIWHaG38/ShNYTdK6L9kmCgC3y9cyvmQghvvKIntJ+LRuSAt/kaxHtyHezsaS6zcmn0iFjRS2Jqn76zrNXRmPniwNtbo9576/4XeUWXkT7szuiIVnEZL3a2z/mVpsK675fSRdrCD2Cz8y4WqUQrbTsbg5HtpvNzdO4vD0hodgIozuhLhKV1siWsCWfHUspWkqO7lQARH7Dz9DsO6Em+vhGZ2+eTc8kDki7ZKMZ8CzOoYdNTcqyA4N3B6PCCPxaUmVBPLLE2DMyuIe09HkCYBS41goKoJUIq4w7btUDcltZtPq+C5py/itpxOYAj4bUHjrRUkhQDWWWyLO6W9u1imRO2aaC0g8F/yzYF3Z0f6TRBlhyNsvbBzGZNXoetk7emCjQQj+IsQYIpmQL8GqcE4bN92CpFOiyN+vSJjSC1FZ6MJqgy1PEYVLE9wV2f8aPc5hkvp4gUruxBvm8klTLzBSVC43PfCIxFeRotS3NzjVGSWPyCL2Xf4zZ/HfMavj9lsaO57jVczfcwsUeyw4hlUwp2fY3N7NLDkntBAAtv0GscHqEE/6RflAaJgXle/IL5ZeqJYEYx8xh0DsacKS+dIT5Cyu8z4d33fv9po9kVqZhCt5Ha6wFSSrdf6G8ZT+K6OcYlFwxa/Az3vmvvarafL/Fx1PRkDAomJwc3VPUHXUJdrnlbpRfJI+perjX+/M1Wg/VpHSwDJTTJeGYUbk89OWlJho/swIqSDp9ED5iKxIvaLuKUDhVYYMb6J1wKrmWvNFLK4Z9xDlXEv3s9w5oLmvyLwAAndx0y+aPZ9zTHRgq7dgUvZAmGKfHcXNEN56Jjioqpf8701xEXwHwwl8yzXilV7I4NIDWimDQ8UMUzRIzBddwy4co+ro4JBy0n7r+xnQhh4Sm77qMuFXsQ+ZLv7oJz3CvB4RMgL3hGZ4OcJDpH9UOgF+f0L9ndZHSVXRttV9au+J99uWeBsYnBdiZmZCntpoi78EWtP/FbW6SGAGV7c2rx6JA2xXp4fx4ga/AYJfCnU3MbMscP0ffJhLgC05zkjlnCBqf8WAXSc/FDbVXHkuP7mf6zChYjvYJ8L+COfsd1a09+eLoJNOeWNj8Xe7QQn3sWjwF5rPZss+dpe8SjJ4aPW8xF88jIM3c46mkFBrDKuQf+KkX1Tsu82A7zsepr4YQczTtdmyttiKN5t2Kxgh81jqw76Qe32MVpKvzY31KSgQ5P4O1CO3ls+/KWSJElafaykLT4ePruUXEBt9o4HhbR8LIYJNeaPNzs5bJvKa+6SZIVS39DDc3wYtda+CsVWtp/B5XOKFSrtd900Yiiqob3rhzW84eF2dtGxBsmkIvTDhbUb2XieXW25ffLpiMen0YPTI33albn2pef9vGx23AGvgHfvc0qNpz/7ei9eD8IYI4qbmQnqpzAOlrYQkYFKwrZRZoAao41jPC3OtDGLINdz9LcUYcsybKFyellNiyPy8znH8WgBy/fcn/iZoBExi1XXZKJarJpbXtTO/QR6SCDC8n2k0eA8o1UvxMQbqiwkphJAtmv85XZ5D+JOraUtVCqNbTQ4flv/9Z8MDerwvjee8bCXgKzJOxThC4dPJB17lg5uhUh46f+CRqzw8WoGNe1UZd+8KY8lz9XiSGJktJED+v5yVLIAFgSJM2DfNiLehG0W1pk+h5KXiVzhHu+ndyMqerxOe6aakwu7e4SRyh/1c89PBek6GU9KnJdXvvV+JUWZPoXW31sFkSd172XIsVLQ7oWzhe1bQr2EFwvx1+52JpQruFKsebLw4uZH1EzE/KpeNiIxUPgFCYnMWovfDI5UC89mdLG0UloA5EkuuYc41Rzr5gps8KCID5+bwWW84VR9XdoLxbJHKt8dPtm6+W0JemfKEQKX5zAakINVFuNbcKBhG+PokACkZWa8uuJh/Gw6q4AKLaeExx9cI100Qm6GxjqyhJ0YyKPS8IMuoip0XHlYcGbtd+tC0lof2A5/N/s/zog2io+lD0rbehSTNVDRcrZA7sriRUB2ml2Efpq4bAZug3h20t1VUbfFUWND8EtKVxkaZYIG8obWOb4j14Xx2olDgi8m6OBjhScqwhaNF7GTcaKvbIawi7ChU+ReZBPw58c9uVesJziOWzUTnkrIbJGZdnCoIg5ngv8CA0wwrPHgXlvhkDaOFgX67RV8or32uUBKspzJIuXc1L0UZuNKUdZCnBIgUk+SwOEwFO2ehPpxsuEF6jzHcpjAI5oydciK+KlNFKhjpUIGlCnMt6A4opM16huXSCC0kTHFDP4GJXd0MPbGKnAumO/NDxjEVZ4ZZjj+QfLXQqQykEgasVfcfJCrBejMPTMvQprKV91J464r74sV2OuwDpoPSD1xo5dkkS5f8FiY6BlJnX83Ns4tOYyNpZDkLOnRBrMm1/8LJXdaHbuKp2BTVrZM3+r/8fxsMFwQN64G2OaRj1G3P/TTWto5ZVMplESScgILjLGA3pqBHqKMFa/MsVZ7o0i2bfJvVB8x0wxUDM+sxWkUME8+0M6UIsJG1ZcPGyAvN7CDNw8JuzCD45Yf4fUWOxTDUiAWpIkGCAmUI/zn+AdNKY8dyrxuMKNw2GQJQD2Hdc6dyZuYsoHd7M89ld6HZqSNtmJDTMe/28lNZBUmX6nKlJzqG/4RF73ObbQfOLmrwmQP7BI3AsjRvRMQN+veTEwfEPzOmz14fITPfZ58oF2grelJrehrogob+h2AJU+/a81dtOIZdB3miihwQkqRzm/49ez18Ps53upxPf0BQXw/7TO9bPX7xcj5sieOnmy5aUWU80zrztOe8DOr4Cvgt3m4mcF3cLIxnY4eqdDCgG7jbBkGGMMfIJgKBytA6OQDwndZo4NdJ4ReaRjkmvG5SBAkY9sU/4iJKUKt3GhbPLj4J5zc/lb7erKatYHOnlMgDNFTc4JCVELgQtD0EdZhz8fPkBveLMtB1tQXNJbTJOZx/sUjtATO+ZZrWG8LCYji57UhsShzXzTlkehm6ItP/Ie3sWCAYCcwAnr61ahR+V2bEDPEWv+ucOsGTE2LPiG4bJ/8mJBM+Kc//IIdBONdhMC6ytHR1QPM8y0Ijj2rqrJuZj3g7xXFEQMgv53BMZbZlOSp8qZHXHhNk+RQzprUd+67Eo+OlpnK7WxeCoc35JywXiLoMG5h2KjgCoSglY0s0txp1E0ezG8kl8ngRvK72JJceXDJJTVqKb2Af4uDQJxEiAy4ne0y7cc1fpVvz/bmUSyVMISBE2ErCrNF5zul9p28AqTgc8QTv6lFXcJgU1SiQuFJD6Rl9zTJwFQgMmQPVkXOT2iPuUzwkdl5//JoWUcC8XgUkA1OxLSlL4pprdPn71KkGiWJCg4y6aN3Dva4uYlTB4mQfmeT8uCqEjpAZAoHx7vLG3okxGmeab7+PvjDHPgG0MYOtpbqHEGSJm6MkQY3kdArvc7pQltQnmOor0yJ+F4JPhBTP/J6DEritV3JnZGyLwA4PS39mOKoGbtXJF8Ivzy1ZZTuLliPDDPSpYGHtPc1eOnNkbh2zU/xOB77JAaGectqZzP2T2kIam4NEiF3heLjMN6QJlTM0Z38+plTHwEeV45B5jaxNRKQfKhjDFdVh1NMwj9pgXNV6KayncKF9pW0sFUleLUW2Z1F9JXIkdcNF4qUzLMR6pM3e5307VX3AwNYBbJKbOD8OYVV1LE9RNg3gFFWYWz0aXZI5mo6dr7x94OTeIx3sgv9oIiq65fdqinQt90kgnEOplupOPOlY/lTNspRDmm66tTSsKNmPOGBIIx+EPdNPr6ewTyN2siXoTz4m2VpcfoghrXb6USSFCbQ0P3ReJnouee1o5TOLco16fLpNPSs+io/trl8cRfbbyCprSef5xBK5sek2cgJvh00U3xZmMggmn/X2nvYQKiXC1259u/g2lffumtBs1gnqCK0lzEXuZM+0tB15OOk8/7mRDrEKp68TARxFc29tCI0oeIU4pX3KFiy+ervjN93LQ4lsaAwVCtCfsHD6MW2mWp5HiTPSParBNiULkta7N0+j0ijhgZEY7GE8iwhRegUsBpqkocuFf2rkVcbW59tbmFJn2NT9yzc4Xf93DlhmvtWOaRh99rxeSnOzA7Kx0hqjJ5FOPM62oHLB4zqXpnbFbY3iOoVxc5D6qTKUKniMFhb/lp0nsRstIq7VLxa53AgMNMT40cOkj/sNvj246vJDObWIMBrctrDP36ywa+b1cVhdGDrZp9W2KUm9M1TcTyzXbGOyWfe8GSIr7Jo/9r5iwJ5Z95f5xg2R3j2f7ZDzPn39eVoAZomuDz0elJrZGM+5nqXpchmIwntCUMT8bltoewObC6iI6Zt8+eRTe3SCm7M87plUTZspDvrblzpChp9wQdceNfIhF3MiZn7dio/OkeTWraQAeH3nCY4fnmmt4ir5yMbztnf/X9GDis1ska1nzMzaRNgjzhaOlBUcSQhYNQ8nk/kdiEqu7ZPbwo/fB0Dkn9Mbl5Dn4+KZGDlx3e9VNd3J++pJlKmPYlbUVm+Q1wTI+LfSW/+0JsFboRVIVMXRfhrSMOQ3W4nOCJ+AZq6KTSx7QA4705rg/MuJDqfMgHrfl78vZbIJe71V29UPtITBkDcS/ra6I/wCFsAUX8yvnDGIrIUsGIruwOlgSK3l/5Gx481lRi2BYyFntlhUdE3j7Z/Pnw/D02ii2+FYlhBoBIR1qisww2FhrJzSbDiMnJ86onbpSGMtlqGRWIIBNv7J1yx1mpZFnjxl2eJQ5SPnVYBGfYaFhsSRIso2NQ78R+ZAAz8qWXZXrqMKadK0nuwIuBbT0rfMsyIqvjRuNxVY+4CMOZOmuHtGqSVaZ1XXyedL0FpkeLMBqDkDVM/48JP3qepb5q2eC080flWneFluRlojQHtXq5h4jLChPzyiCUZy6K6ydCasRLkkMQOhytERx+gUhyQIRMwr57h3Ge9O/hHf1UwXGWFrl6Vt7BSxextaHmyKEnAZ/dgOA9YUvbErczB3N6391a6symcX4fEzS2g3w+UjlmdlJkMnCJep0jyK41SvmzuQUnkWL4S56TYWJI/fvrdByq5eZRz1QFAiEPyAJd2cOiyDE4WqlaHDMIWI1HmqeE8cTF0G1Hyn8T9pNqrVf1pNfJFINFvXxfAObdf733iZt+cOCLfwysITHuEeIADKLkW3gEhiLoYs0LbxeZKFoCJMIfbXNYOEqI4WYBUio12JnjtzWEmtvxOBTVzcGsMD0ylm9qPmcBchUJnpAKvD25Ivnva1U0sYztIWa63NteyhczySZxoWCsrPke2cNzuLEqYVRg/ymdqah9OrT6O5BPtx0sfu+WC9L35ynIvuI+lcxKdmYt9Zoovj11QJ1DqyxpPNf/KHF7g4ceqTpc29U2RRmX6eJvDbS3XjJIeDrW+vDWuw9O3FWO2NuhX/ihcVJOTxdxoeSZ0SfQfG5OgAXsxdDGXaSWtdUGu33SXmeX/mEXr7vBbLA2VhiKyZzbvc7RtksvJdo7t5Qx/HRYbwgmcTk7t/buF357+lkUIZfhZ3UANCyAy+Inc4m3HadoMIYizY1+IQGZ3DvNMeqgyU59BPVissRjo4aPExye7Y2RRIKFBYoOmP3FhGDAJxmoMt9zyXEynauGWde+7qlEwZcUC/jWf+cAI1y2PfTWFPnDhaLWfHmPTpGY+rHfl6PgDW5mBOF6cEAl1A7no81q7uckqO3xhJ4Jjrx3FF3M+d7N3LQNe3giky8u+cy96S/2GYXwvwwCG9KysW1UzRe7XkHCgkUKgDn2XuP+O6vc31zlIJFQ5dG/nAKLtzJDr/YBRSymfxMSr3SSq+SbTA17c6ZTxBiGSFYdadikGJFLr/YBFJXqqbdYZj3ugKTAFfairtanhfNsIhFlytu4WYKG6CqxqWuQ0TnVvMURKaOduyM08paXdro0RWbDVrospTv312nOmqzn67GGghpE8x07XKCE6oe/4pjpBJ0BukdpDFxAkcPz6fGBM/SINpWegy2S7BKYiOPuYII1UahAt5LiXsPkY9M6/6+GZDOAHfRxRJscdds1Xo+UhaFAQk9IMosqQ3rcbjK35eRAsgVCZTRhW5iMOjQ78D1likRxmf/76j8kBiruGqV0vM8BWlP14cEKxBtoF4/rwDVYt6qviiF0+Bbz5cgf2P7VLURg8gYRZ3Ipg4LIW91tpgQm0g+qbk47DycBP1EenBwRovsTeU4iQsQt7EFisd3vmQlo4Z5com8I3PiDs2d/ySs5ePV92sVJqBqomxdY+eA8onjTAnoxnlplkybatNcQ2jPo15az+qDBTWTuAarMDEYtniMMhjwif8dlnn+9ea5qldvI+ymrm+fhO+lACMNwj4Puu6C3SN5V0oY221O/GeHsyyt4IB/ozgZkwoUj1JWL4W7dFfn2WcTh5mgyfFMxzT6H+EwOqGoP2OhHLqNjaRkb2OBqhdqn5hQBvelwXwYBjqcaYHEK0ZuKN0/dsFcvFPBEEuZE+9L7kD9qwBVcRzHBfXIPB+El1FYAwisVgk3eYw0ORGsHQC3Zp3cQPQrsfGnW6iDnasM2Y5z3rQl3JA6jLKqEV3ptwQqN3vQUs5HVGADhDKwFoEG5QkefZy8IpkyssdP2acZ/L2/7leGFqYpHmF9HLaMWJAR4n2x/im60BFfwPwtn9S1CJnRAwFPKUdhRnmkltHAjEkjbm80lidNasnX53CjZm5E9p6JVHfGaiD85lw4EGZbo3GinsaESzLEig4kB2jAHJybaHplnt0FqD5TrTyUyRjrg37Tx9k329g5YghlrpDuhKtWvTB4BHgSPxszH5Yyrqj85YyWDpuHzJnNHGI7PYkt8kGrclq+l3WM4WN/YJSws3K3VR3uQ5bl84p+5D9bvYzlKvJvHVVxM4JEhZ2SKVqSKwLDbTeFdTnOBNM/Fh0YG62jslxeSCLUfM5M1QJoJt4cosWva4f0LzNvU8SupMBoHcJF5YsEAAnF7ZpTEmy/muLJII4ZTveXKm1K+fZY4hHlIm5Q4tytwQlJ1XBMiNIFI59KyJ2hgX9d2e1jmevC6I0nLxPFjeL35EwXBmZFrxgolsJMIQLA/Y6BpRXMstc5lsWwp7npATxOfbbIKAJvyFbjpGgaVGXyJpRfr1lkU6kU6ZWSTwNfFjNlJAAaFoK4LA6l/B82syAL1+0apZ9W97jGAvjAGMRXWsUOABHnlWOaA5KWwk0DYgch+2oh1ZxKnZPDrARKxS19k9DL+8bbQjV4kjxdjPWz6+Q26N1yz3WgkspuGMwkQhTTCWch0ypwCUv2uvAoQ/xl7ZGO+hxiGRXQBTXh1xmQXRtCDdBbDq7wWe7o+6cTcjKZ0ceqQU4tNqqpZbIL7PzDU0/c2GDQBxT2a814qrgqOIsx2v6WGHGp2ES5LFcT+PpRsdaWk/jvdLWJqVLiRqe6LODTpBWcIkX+dampvqtEIxjkeIv4FK7fuEB9pn/e4Ln3PMXla1ZWabWlP887pHtlSkPhLOA/UeRDH+w1bKiy6aUoMdofUdAImSJ6yeXUCwCVMp3BjwtzDv+4aoZ4i0N+AtR+3OXAPIlOFXhyy+uTN09mIwltc/Zp/mVhcJx1ylLpY//w4Uk1ZlohmMrBur/ZqUvByf5qHaHGmft2CR4fbk7Q7ci3tAz09tw0w8/6R9EXmD11LVeRR0WsxJjNGeULiRc7oKJNlOnglIBfjz6hQBmuG9F0Qjlq9gbLxtUpJyqWJbt4LUbMFt+bi2IGGymWtfG3EEHmfiyhBwfkfEW0OpKvuS1k7mmqyo0cL6Zm0suEcS02JoMzj2dKWdjiBIimqBoqpqfx2P/NC+vv/WAbGeCAM9vcByJmP2xSZwRcIisUfZaGfNwApCRm2kBpXedq5fIFMs1BRTX/cCaun5oYaGgBj6DFoSXHOg9y9ENnzyDFlilwQGXOTSoih0AZEs6e34ixJpagzItbd7BOWVUbO3jGW1KRJetClIAaPmfUtnGC0ZMFkCSWJYhvTDovUcxC4H3Od2KFFEqCVOLAmxikIrAzzHI+uDh6gMeO33JHMLgu6D8hk4+eU6zmS42PngFxLKFTzqwILF0KpHQ4m5mkuEhuqy5SYLse3B6njGEP/MNbohRSVGg7M/ztqZMQUDrzYv6dQTk3UKFpcKAaHbRMVIEHkr8XKAxqoaGOtKG31RTjv6+eT9RD925L3DsadegAVIkmmc/sOvp7o6Y3TwYAPXl1HuAja/qGBauNFAE5gpLN8N37X7V3UAqSk/2cQO1EquX5kLyh7uJVAc9BVhoZOiIMMBIXn7mZ1fNloBP3xyOp/RRCwtmORNfZh6Jv4GJlIxZ5/6ydWE9Q5m2ZIIN/ptpE1xmvHKDst6EfA2XdIwNy+5YNejyBkn5LPT1Pjq1lL4EorcQOGFRgr7941gv/hFj4jK4WqWXtBJt5vslrerMwMbYU34re8kboyzc6aKb0XUDZd91+5muVkQKlO5dIY6oJ1dzVDZM6MIJfGsItCc05hcIIvOAlcx5oqf+sExMVlJh81AuhS8xckGb6/CBf1RzUW5gakY2ETfCBr0zkfMJ27w4fF+CB7ekxcfRmazlupE84FJBaM0EL07ckMDsLzo5Oyg+DlDZoKwPNoO2Qt5wpfi1n7OfFehrAVNZDktEXR/QFM7xWGoJFux53xfrlutseMCkWMyEIOktDgIQQMwmQrJbyTYiCk6cgkiWL4lnTstb3gH1v84sB+28sbB9NBTNgSmFxbJYxIsQxNsdmj3qANNjRah3b0pT7ovIBGoR1u+JarFxU2QnxZxy9hCj1eDNR/6tse+JCFdcePhlJq3F6D6EGBVM+RjVO6nmYVqUPOvMUqVcXuLE6oV7bkcHR8Q5tXSuF6bhk8Ck2gj1jlKfQ+ImmgUR3w3p05LadAbiOEH5TppkqwkMtvaH4o/1FS/Sn9ADdsLgOgcZE3YSmg0YTUFYoW58xL0ZiE57rhL/VuS5uAUvIBgLImbZN+kn4XxG2Z7/lYl8iFufe4jCO6F2yEICLsuTRcpuBaVxA9uCPvXreZI1TdAY2FQg8wV0HWxDvlWxrIam69bbclF9+ZOUEwrkQclXgaXbuYYTkjCXFlTXyOdRMooKEyJoLZhqjBhtdjIyHvNU2P2Libec3F/bsqlEh/FZi937dgtwlgqQ8TkVRHWnaYNk2HEc+vEOU06a+5vzn0yfDuJDs27hUOgxKwqkPf20OPFnjmQZryNlg8t+gJdFHjTwWPAvx1HYs+C6C5k6epWqKS8cg92ij/tECFAWDJ0n+uVKL0X9ujDastJUTeZny81Vc7tNmLKfTFdyVw7eSHGqBv4CtRTqY+r0xGNgl3DQ3vlKXGulaFAN00pgje5VB/BzKuqZijxdjDMUVYuf3VEmJNO+r1Vx0zRIFlgOJFfcyO2F/W8yPgz0vWPxbNFjNFoZ6h+SItd6fZJZNgXc5rlc1yCc0HJZdRF/Cys3rM0ckZysxh5hrZBOHF1kU9Bv+/XyEAzj7xQeDmhrUD5rAVTn6h7Qzp0mXEmn/Ku4rwNDtf3kPlxXPQPHXo2fBOFLvQXHUG7x2gVn/3zHvVCUoU5vkMCTzTRySm8jWyPsJ8XmdNTuDJ8BHwkQRbIv6HjsLqhL4qkj9ZYs0n3tgAGOUIT3OYHKeEe2fANGSDPSzWidCtgiqNhspnRbw6e0arv9qs+qEw9dhyOxDnrVBR4qcSNwy0j5KvasjN41hyBm5N4eXo8BlvR/gWbLIU+f5mXfbq2o9sJSS3BFFQhxa0I+tgg8kEwPfJOVgSihLjyee7mG2GBRFsG9TX//wAlj+7kWFInfQkjGmCzZDstAXkO3DOUrG2PK5r0HaDptRjKR7m06GXjOPKWfoxo1NN2WUNEbD7e+Hd6z2YM1s17whiyFfO6XoF/mZXX7J+2JnyhOAmF/Zrt6DTqxohaFkHUjYrL7FzKZ78WCxQZ1lTZaWXReGjFIkH17fZUS5Em8Byryp5VY4NKtht1o54VnS5swsRYcNCNMUBrGL5vtGFg1T5xyJ4WCTF1a6eZ7HzfJll+Vcl5vBxHNy8A1P5ke31stN5jJ1C8Bpu4sx58DrSR1LBPsFC2J6EAOO8tazkB8yBmMv2/pYuU4GepIP8Gz9v5wb6uXGlbSJPTgM8usjwcORznJPQq5NeZRmQC2cIAV28jIA+sZwQFoHgKJDMW7E4bXbrK7dy75I6XclY6N3rxTohdRDtZokV8XlTELYXFkve0l/34E/jWwXHXe8o2tpgyQ16ixOw5nuucvAo7GvXzv+1QaRWmvuO6sxGuTeEBeQgO/5PPK9OmG6FY71xFI5w0df8+nqvtkz2Jm4w4rEQrrGLJURI8/fwZyTL9MhZg1Wx3ZtbqsdE4Dd7YMTN0HyzVNEPi8bhHU83lQnIU3Pxex/YeNJXDzcuUfz5q3mW3NgyxLXoiv/s2xtpHDgGjoEfYAxAVqPPsS+0Pclwzi2DT5kSZtrp5v/jPh6+WHRpn35zycFq9IJ5RenOFm1+bvIfbIkHkDa/nPtIH92Hflv37TFu2Feg8oP1Unp9ZPOYKdT07JKS9iKdXQD7IJ6u/prnZ9MVRUZLfsqdyT8FKNHnk7GTSAXfC25NjLga/gtkhO9OcxqqerMIN3fyFKphQHeEPzDyyQ7qwBZLWnW99dkbI8qb5W5U8TdQZspL7PPV9NeJ3/Q1RTwLQpSKRPafHzVWV6IXcWANFzoUH68cOMiRZX8sV1Gs3WiGMd7Qx2rig0y2IMZ12HVP8Km36epdBGRV2t3GAatHhGJ1runiFJW24fWpeb400gYASax9rB/uSDyVhupbKloO0a8Kx6D2+gz15ifI5/VlV9EF1FDOAj4tOhRi6bzPr5d/jiEV0aT1SLPNf2aHF6WcFrSwjnEpaK8jKZIsF5NfdOe+ytSqqoGPTql0JXIXacX7g7kB9kz90uQUsTJZ17EewW+ty1oAnEBvzRPJOoxgXWWQC7T0INx4aFxNo6oVrvkWC09zE2+XroIf9psXQ5hsLUCRG9erJBrPkY8QYhYZqqy9BQA1++jHPdiGosWN0PB4GfLNBhq7Sh8+VdSxHCfT38ByCQrPU70BwETzgAvbKLe5NV7q0tlTPzykYMoDqwt2YSWZhtrhTmTk7VjiNly73Aak28sTgJyGzduJcGVFOiX/7rm8J6B34LGe+oG+sKSJy+2dzh9RrzHaEkZwCxcY/SX2WMUvrYF+CFM2ork35QAPxBDcWIdBY2tA3h0w5VGHWuLsSL3GpKfPXT+6iaAATpB1jBe595voIKuQhtl8KArLQFXa8FmGbJWIMLm+c4IlNZniFsjdIhBuTGBuMbIlqzfy1YSRolU1E6KERXoTLsTyf9f2lCJIuvlra//z1Q4Yp1bD2YB04wz4fngQOoYGgM75x6f0HDHtncVvSZm80RSp8OjagTZh/RnF5wTsJyXq3IxSS7JxUI1hzr3V+Kr89tcu0Z3JpBYUD+PtkAK1AHHqtvZJrJAuHNHajU/MogWTFBEPDu9hZOSmUfAZuHgYPrTkYh0nIyxJGnJ1C/KC04XUPHqdQerNzVrm+qhnK64zYVGC2lBU+oLOj1uigHgXLYB4K/8xwmf4YlGqDeovfwJ5Zw04wu5rqwNaIJk233zthhynO7abhr32YI+FBaCwAJanNSvTFpEb9ptZQbA762efyV4mXhi01XVKCPyv16J7q796+n7mH/mpoZ/GcUIl3EDEaot8yteIL1RA2fXIZAS4WTf+KQlVZx3EYOg0ZpI3p7QwPcrdZDx1nMyIYYIr3A63vIwSRbR0pbIA/mOuyDcRI9Pi172t/lJUMQIrzzWDvtqHzYW/1pzBxGUwhy488ZU7EjDeLe+Gho7PkscbAOIx4UWaYUTfMIRvDDiyiZtXOcoq09KvvqyjUx8vGs3UTc5T72S9C0G/PeH5XtghwxOQSleWfr8o7RGk73Pql6VQzvMZbnVYevBR91dGAByZFLNXLB+5ccpLBrmVkZonq0tc90buddeUn3dsmD2jXiOPYSXcqaKAeCa1MEwRHAP8VKgJzaIJ4fGa1VooWSlFhix14UgCzpTHYUGlT8BsIgMx/7CPQ5rZDqJQsIT/Q6XGGXVxZGKh5p+K6kJm58FrEiyc3a6st1vfSksFiDaIyqrE5fw08I51dLlNNBDrLRrOf42REchz/5QauSHAZl1xlOO9i19n/SDT1tzGVOm98imF1crUXqrW5SquniB+K33ZOFspbYpXkuHwmRCw2N8HrZ1iJD4w9M9FjeVnV9I7QJ5watNVqN4tEGxAQIaZ7GRh+hZ+o5dUrjcl/i/gbkHqPq7DFvlFCL/HUaIE/tV1H2/G4wqfkQA5zb0+lw2yASaLbutHV6XhkaehNSx+WRtJZNbQXgMupYWSDakNXORJ6fhOsmJ0cM4dFCzG33CIzQVFhiLKHTCiY/vHX6vyIZalPAhhlsQVFez2H94JQ6FtIAcnlg49X8JeB5xw6WFAAXV/UahJE2RlmM8X9MIM/ZHCil3q8ddy49Q+tg5XVcwxmDWJ0lANBQnU5pOfx2EOBxuvoHZkjSzuAQFKQhfK/6wH/PCWo2YpweYNYCRR8P11STIDw20YdIsW4Tfhe8LSD3eB1/tjOszMsmtch8cFcDfT4m3oVSSq2wd//faM6mWajZ/6GwA5y7kOhQAwzqvdZZuOrDSQxi9Bh6nBE6dFeUavMobU29EAEU5sx/tjA6tkAjO6e7+N9csAGaEbkqrDoV7Z/LGE6Z8CNkuVv2akt7tmqcSKdCMMfTyyC+8U8YFOZZYGKIYes0pXazARQu6f8Qk3j95FuEgWH9P9wm8ZEdIegHmk4MNpMUbykNUHbQradOc7l1c1ZqHOSqDSUtlc0Jfkzm+vP77Iqkx4M2zh7wV4KMRo4N4RY5vBjyDaA6New2lVhLMCD9wk3ydxLDby9/NBNN6DlSF84ewKCEkWLwvLS6nysehaEywqolGg6siv9n7yRtdoT/g4YhJDEPZ9p8wNT/SyicBqTi/Q4nLMZZEKx0yPb/3fOmbx/W3+ppUtG4VibSnS9izRZYTl8VUbXo9gn06JntVPi15BSSgO7TYvnIv+2NO3yCHoLOwPvi2ZzG7MMarNk7AjfWh0f+U/Yc1D5Px+03iwCuaGwBkI6GuFyE+nTPR25/yYSnvvJRM5sbLnt/a/NiWJCNhF/eybq6m7bIvRYk1f6jAFERhIsRpP8OO8zXA3PoLkq1GVqd3wOVwQqqKIFj+7u4YTKIw2UWhVu5wWZ4eW/DdPX94suDSgP3+0eKTIpkTVBe9rhmnUxHukqyIea7o6yVQ7fvy/JDe+d/8nIOByLkH4Q6cw5mQW3F3JYG+hnDnkRcQ0WtcPSLwycFKxKm21DvMZIJuHEa6XDTQ3VUATMHdWuS2ijWZNhx/RRYnoxAferqHMBA4Fc8r1MYOHy1HdhTJ2OpREqQ0Zvnd8x4LxgUCZt6EqnA7S4TYNtmk5H4AK2/yCNXsN4jYJIpuqXVtqgSOpNvgDGx+HuJ6u/WIc8EEh3i0Itv3U310e9X/JeFqQhvblSKHxyin7AdZpSZg8L1peaIKYZHi7lzLc/L1E57599stPc8IEaJyBryJCTKPEw536Ev9bqyfILjMr5voGSqhah0OUoRTp3N7/2V+ZJeJqzy+MbXTZNL/uIXg5KxkOsUdveMkxkpa8Y5k7rSrEDC5WxvnahYbi8sAj6Gh5Va5fDGUJsVAsC5+5X66DkZgapCHbTUqcDcli/r05eSpmrfhOx6ODvR0N7p4sfdBXhWrIzoLcTQBXo0BjHE/8i/Mun8rh9FrUjLM5TuVeEpkNvPLsCn6OMBg8hqaDIpVYAmnkwSgBPgsjDAPbjWIf6pxRr7vuX8ZmL7toHSqFrPJyzXd5ADVyqXBvj6loLY7pOvvJsZDPu5Zfc3VNuyZh7uLyaEioIrt7BJOSO7CGHjd6pAOA5+x9o0xYMlPQSJWL6pm87N/+ix4jJEvdA/x3+tvs3bLn5QnKEdJwXNlcdUPvJps+taOt3k2hwIjCyxE6ofauoq7WQplI5vMOAM6jHL5hpHrizLfP3Il+ozZwh7SVyQd0+9X1ZiFb3C9RH64SwzzcOLDk2cebJoboLkNlojW+u1u7G6YEStvA1R9fIvq3VPW/LOnnmOfA/YpUXzs2+oUA5xc9yvpxZ3Ab0r7NLFtkI+p3A6TUUNv7w9+C9AT5DxvVGZIJNJ9h8jxeC/05fq8EWRjyAdL9fgdK56TFGF1xiYDKc7MZIHzAAxSoJKytCbMsPOcf9zNQb92ujor6HJvaoaDAizWJfL4Yy1Lb6AOf9Yv/vxxPOlSY2GP3CNhbMxBEb2YBh9yoCptf0h6vfUPeesiyCQUNFbiPeK8MCoB7LUn1INyOK0IZXRguz5Sc2Jnt3Cf0ve4liKQKrEhafMCzqnw2fhF99Teqp3A9bxsy8lU7wymj3/b+hndyYYloaxwOrP58MgR3CsC7qeheIIotbZNTMHqk2cNRtphNfbG+Sd4cm+pc7j3samKmDM4TLUOugXhkE5Auop8qOQGUtmWbhq4KGmJXXuoS4IAxo/VeIuXW/cG8vDFqOc+/ioSnmmTmGNpFXVpLIbUAugPwUjDOYKahE5inaR7apkEX8SFYvvrtCfZ7EDvTESv/hjHsuoq++cpZiKTMtZ5Hrmc+vEbftBEHUuUhs5xvN5E01lsDClJc0xeHATCFuUAqRpgP3cZpIev5DYqlXCxKYd9vhJyuTkgY49JGt3OInBz1oHWH3n/BK4XWOqxBmUYH+tC/aw0KEpHzf0nvg0tGNbwEhYOdOBhHgP68DXP09ctOV99M3fRukMDmqdvkh3mWyZzjDwRDfi6MQZWpeIA6Wr9LPf3VY/n94tVhbSrqBz+dFVIcvX00JwTROT70gZnBztOOfZ5pZwj/0AUDRTL9aVM48dN25XYMMu/6bLepasVeh2PBbiz1U/Y7Qe9w5CBnyBn6Ov82OZ1fcTwZweHJS14AOiuEhOfzn+zFnpNWb6cgqTprNvB6irmRneziwcDFdn3Lf6WGfotal2lePdfxrKvcgpIxTsy28Wr3iUPPqmPNpZrr0qKYmkFakfjEFRIZ5T4zqhAvuu8mYwAomI5aQr92hI8AU7FaqMFbGi5Fsb7PVsTw628rsst73L1ndMUPR139byAGXQ2aOmN9I9Ta5RNe+L1FeWh8Een/czUViyY0PVyVEU31q8/DyZjvf8uJMXM1quTmfBSrDy4bfVnJziSr/N+zpB838Qk9cq6+FbhgIdGQAbYuGJq4YmYNaOL4VBoAPli0C9ie+0KobmoSOXewUz3LwKWUfG/QZO431ov3BeHUZNuh9xuU1vIE97yd9djEcZEarTxSQGMKYO+FlOx51quBIUdrFdT8XwUPw1Rk5a5Gfw1XmNXf1uG7tlgUjmfP8m0+YqPRU2FOKICy7DFRVZYsAsiDq+EnzM24u5QQAV1AP9KXi6/xdpPeQq7YmZShfLtYADpXyjLu8IKWhiQcIBOjszEFDgHue+37Bh5sc47gxUkwXckWUx0sc+K8jqq3u6+X6jKJaUvi/S2w4/9EdLwGY2uIWkAU1rdVmQNPsLPV2/MKdVAy8PyZfkqWWN7dtEqwDsiH16giU+SaAOXcgXT2QY3vKh2CiHVDBI9DIFefLFOhCxhIe1xYvKgX6W8cOlDulrz1HJQKC7KfQCNlV2QSxF92WQexrn+rYlxsjtMWgY8qM+nXiN6foonvK8PhgIqfxwsLO4lT6Xkype+e9re5XF4zxpsB4tCX74iGwWJMF7tkgx4XMdNqvogcn1UipG5APvI4VhI+aHJzFQi1Tf+Tzig0Z5ounIJYnhO/mg+ncxDKqJ5U+1PcUtewAN1AKXE9yKqfFbH1H9iJppUiPCrqNADUt+wti5dEpfNfUvyHjZuCxen0YtEvkf1+d9264YZXnNWoGbPYqcGac0viPUq+TK/4QzgFYii99HV3pU9pE0IenYeZn/m7bwoobwYX2YZjA4pTwpq9jqQoCtLQDH5Tjie3ln6P1SfVt664/IsMCAHTCCajfHbJC6WTaeJhU2FI4+2vqiueVUVwkqF40jaVwONPq4IWYOM+A23vSDjcxnadnAIUPOoUnAxpqWDJaDasJiNx001K2b4NJydai38jZvwObuBiIru9wBemIdlPNV6KzJuaTvrWdKS+ck2H8FK2WJTGR+qpbD4a5/4pGPV5YSVFaOQqyPuLk2xsRroeYbXnRfLJye/4jiQ7gdjyhIHp7duzE4tmURDWFciAPHY6VEg5Kn/QknxlH7j2TYCCuq9cOuCHaoDTwfGl9ZbEmw+aAlBBWwVhNBkjK04qGzOoRI8FBQHy5ZMggzmZE9r4rIEwhTu9Kb+fA7xh+4mlSZ/EDhSlh91Qf9fwrzOm14+xFKnIcrAD9XZ61GMRPeivOQpn0lcejsoHd05r7TF2ElCWRGLgWyfsbRmai9WGJyPg5BwWi7EmgJGuM2FPzJuKK41ZqODiROg5dZDBlUDJMoo80ROrTdzrCcSyAGlfiBPmVME3cf/wEDgLZ3LdYab/bcQAmulKK5gy841sZoKN2ZpAydkrUdPhV+CtwZ1fk1b2bPwgPZZLfpeN6lsh15+ofMEEVAKg6qjq3Et91N5Gyurm5Yt4M+Lx7rTW46ZH9LwThFHng9lQFq9ny7Eq9hVC9SLZzUE8UTJ/p9WWPuMfiY4ztJ7rYvjSt4O/JTV5WR7WGahw0CDf5icCfG5NEtjvGqLlTonkVPKxitrt1dPOxDkel+5+TjIxbGSGP0lHo5eww+gI0nFsDJCqN4jyMwPackmSvRQnvXD4UII71Z2yc2hZzsGlSxAixf8Cp1JyWC1FcjZ+g0CUa4BbS8MKQQvbnWAlLK19dF63bLvDrngc5GU+t4RhV1vj6vpvy/b49K0hboFfDJNfbXmGma6CluVPy6Q9HSl6hIw3o0saTHYwJq5BtMM66yx/ZIRqpxX2uZNuhoUv7lQNP8dNgKWgD429sivA3utaTsKmDeFtkE2jGCiAn/rU5OobFQLkIJt7KWK2YnwfKv3D1oJj/K+epDXUIupLsHUDkezqIceiz4W1FE62yWl07JZz9KvMfZh6nuA2OFqmN+ho4QKNk9foI6cap+axailNfya1DPGXJQNjjFJ/FLO78vnuvPwF7DZTIeYRX0xQFSi0Fu2mZS3OqURrfMsU1dt4Fcbu2vl/41y2dHawbF95MNF2xYGJR/Wli+cw6nmtIs3bZ8VojV4UZ0lI35hnfz20Q0WJ+ukVKpa8BF3fRQSPSwRGw/TYkWWRC9acLWDxmH9vMh/fbUjNrDKg9jN7eExAe+nLkkwabOVvXxDc3r4Vg+6ZgjxKE6ffUN++w5jifw8bXYGgyJ3LmicfABi2Skm7tgxL04CtNYSMaU2OBYIdW1IAKo8pkr2ndqhy7D866FNza5Uq2YJ0d3FFuKdAval1T4Gk7kfGd7/yiVaZfx4hEGZJisCEz4YeRe17rXs4roqXtXLNJbji1UNXjk3UqFldf7A4OcJlCaaU2FCrWJEREm3iyeWNdggO1HEbgeilxwWssHHQowfGdgITuFVLnWlaSh8xRuanWevOFvNUM9TYBpQjWD/s/AtGV28xH9d2w9ZxTWNO60HAoxW0Qism4adtiAGAVDTJhfk5FpSIZHUyavzBBWyutzT/zof3PBTdY8gwOJ2zHsXWYIWFJ1+deRj+PeRW8Jn+NCVbJhFJqpENNGx6nU9ZoNTLRIeWTwewBdRPknnkXt86cpheL7WyB6kOuqjvBwVSzDj5v1s4nQfe/nfr03j/dq0Xwhf4wYAjJkBOzPZBtlIlsNU2Ek1YGjaErc37owQ9UwD+pL0rLhxFsTFk9QJgjJdcFj8Z7grPnEOEI6mW2fBoZ6eRVqvVWzxC1E4sVcCOeISRQY8O0gZCv+Vr0AzhDgtMkY5irDhErOFWzZBRn+hM6fQz12F6O3s0oJ2ephk6sdJQq/xXJIzEqC7hdQxUaIDkAPlmnJEuSFkEsALAPqce7eG3skDBSInT7Vd8TV6NVbI6CJpywaxppW8Y3QOwicvaY3fojX43kWhOYlWyS5ljd5KzyonVSZgirHe7Pe7gIYE+qkMYrx/CMLV+yqs1r594DJ7eu97sFDq0aQwArrjvE9CahKlyGIuA7I13pu6Hsi9+/xSm9zlVgY9vOKqEg9hBKWV3Z99sxne3kcqV4TO2FT8AE5CywkF2CW+KZMWBA2eYROhkXD85IURh6MVpb4vourFj2sUiLOWHgR/wXALc8I6/CmNJ19CcjtnUzbdB4zbD6hvoezHz7GVjyZR3i2rh/XyAtdg6A6EPf6h/EZgpy8UmK1km7feHCCdOIPtrRm0XYgiBaJKUCPAejEQsC79lls1SRpW/cVpIljAVa3weG87YKCISN1qwAd628pjU8LN7YNom6WFZQvDeKYzKtSVIaKTt8J7ds7GH9r4u8F3Z7ZahdUYm2d4k3CdTlHQS70jYJe8KzE07j5avS+pENOetcr5SbpUVfmzcGW+LRCWeOYuo4RwcxishkkSM8dPIz58NvlLU7TEvrbyGGtZZlEtHgUtmvaOZVqjTdsU3W7OkiTNIW71u8roWr5RW8wbY96a+P+z3kEXVqpWhC63FwSxEEvdmvMAnxRPE1t0tYdcQmJGbK0kszBZdPJC6tfExlCXWhT1IQK6cBr4P6meAk6vXJ8I1a4sVZyALkwHqJks/CQWEku6aB2/BVy19icGAB9uVEhkqJGUbsFJklVTnLS0AT7M0kvu02s61Vkfcbd1ELwDrZF94CeAMbGPOBTjF3xNf7wV4Il+VzatyxWPz+IfgoH8BTfPA9OxLAof3NG6YvH66vsXcPoKz52nfPcDIM3xmn74YXyaIHkrsc3k57WG55AMvzdbSiHX4naMhn0eU8oOBmcNB5jWQgV3zMTQ7NtwDAIJCL0IYJPv9c1anGouaR8KxW8ix6xxXiaAIDN6cpNmmVSTCHjOa0IaVo5Y/fKTklu8EZn4LxUTB6sbhjG5rPktwxUty2xlv7H0aFsflgHASB82Vq7Bh5xUcG2xfoiMcghZyx5Do1UXap2bBtzUXKgUX9h/FYp2/G9JvOJmNA01RK4wzqw39qujjV1Qhkt7H8e9hN6BJB3f1z0gwFDVIYhMCRELUBVs1Ffpt+N563KaRTdlRuTE5QpHYwjqAX+UViiLKk7NmCVQU7C2bMV9JUHJRVxGeDcf0/33H/nEDGnnZtRg/kwipvWJGkHbUjRPiOpg6PEEEJ+9JpZPMNRoAKGD5i/f/izeCw81pNLlnbfqjfsfugPn17FzG9upXEt2/TiA7KAuhkHD0Y1i9PR7/o0tbN0jGZ+/N9QuwxqEBEYM+kx8oUloqNRrKZp3e6f0PKdh0JFUnyQrN6JkdMwVptFcwcL36dFWddDB/GnNKhDUGvV0t61tIJ2IUWYc3Ou3+bYQYZdEeb5/CEtdQ0QTKeTMyi1U1uvF+QSMMzf97tA7BeP0M+eyus+5/aPsnm5N/b8eCYAQnCEAtFWILI1XlaqtdQ1ikde7uBi9oyYnesrFVGqT3voma3pDamjyQujjjufVfVlRlXTS7y3Ee7IX2zmvL1Cz+dGxj5DBBgfmAVj9fMIFyArE2fEY4dPkcSpreWvF8a2PnUQwJIt8uP/zZ1s8fUjzAq/vpPhI3k0GR9e5JlL1IES7M2pL+X7HUNhbkQK/DS8qVKUcH9CYmJmO10JbS5O4KyQf24AIoEIAqqLIl0A2zZCB5p8gYfY3gbv7h4CXzaNOORHaeUKL6n2AjFfTXDeJqo3bddEqcxReNhBrsrYjY7qN4NkUhwZJif7J6gxesPRPsvR2Iao3jZk1Ki48x8gRzTnn4uoZARVESCPf7sY1aSyJSrpBOVcIu1fAzqcnXNF6Ix2HogVP+SoSylIYb4lmwS+1Bd3PvWDX02MvGzSPvPkzVANz8UbzMEZF00erPMZNr4IUT3N5G8f32EC19Gcbq4KGxZsWVoTCi9U72j/uRgVScBcejWHMKM63YXj2VtbcrHzuH6dwSOtPrUBHt52INwfCab+F4ChmxLTAP7CMK74ooxBUViy10YeNmrmWVBs6vrr4yZ1L9DaVwmgPrWTpeHbL4v4/+ZbRlmnkRkIEPCv0KFuEfLJsTfcblNLL3yz0cadK0wt5MrIRQ+V+EZIm+QKV5YD7UOJk56AbVDG3HLZeFpRLEzW/649mUmUZeVzzmjnpCecnj3uYTYjoN6Kx5ZdDFlzV7J9ooxFL012KyOz5vfXW4aP7Mpg7yNH7QA9nfo6J8O+5mgxkDXAbi4a6/gBYZMeSwePhbvGMqk1RoQAeQ5PjBqbXsQnYU5UVhHSabCUKbeo4Q5gcQD2qLiV3V3RWvFRtUyNSZqR1cysMGWtd6w+r3Wgc/DJzepEuVzfDoxT+K/69DOnyWjM20zGS5IyUoBKTpiTawKqCcXWW7Uq7xpevdTzpFLg00gZ+60qaTOYeJ8IVguknhyWGAZ7gPB1fRse3ZnvZ4hHGCzVlIjh6q7+Jrf/3Y22Ep8AgAdcrJAmvpMINZILo8js/o0Yc8jygKVvM2pDGrpRyxRbOjWu/wq2jb6dQQUkbRruVabQ0uYOKi2IdIjujeciRRiF1j7WNypXlItdo3G2zFqCrPwCA/aG1Vh1EMeAegVSlvOWLZKObp5wjytm4R6CdpvE98NDQpfRdgGRfzp0n8+bTccLgr2doHsU+wy6MHERhNOcJbgLVast0ljckNTcfkjKWnrXVzv4VR6hZv2hITt18QJiuFa2oDSLKyvhjiHD2HFCA2gwWDlUw5WDU8Sq9CzqKg2dK/KcXQ5kbamM5sczy/z3MJRkHxqjbetAlTwykauMtUkThFcE9rG9SI/nQigyeea3Dyxr0hZKcN7Cvmzn6vTsxA2+BnKWqMvcEDnJpmitm0kpEHfFpiEgUXFwiwIRVeLjVpkJINEZTY8E6ZBcdr+TKWa6Y5NKJ34isYXa96JATwij6s5erfzNmi1QxHwFFPVxv3hqKqnr46Is4xu0A5X2xgjDBu8eTViiSkZhmRAmyvztc+KdD3jtoTjcSXK5rawqv2vgrmXQ5x8WWw0bm4fUnUX+PAmnf03diCHpmh6ij+Sw/y+5xfoQ4NmKGswGeBBv0lklQEXXpLncXAzIENpOl7qHrcwPaQQwSyV+2vJq2a9CY4mCgf2xO3CFiY/PEb8TJ1m3R97Ya0GITO5Di2dnJ6gerjoMWsN4tM/p41GhOUNjARm2eL2tSJiSCYXvkT7/ae4KVI/pYRU6ICy4r00ukrGeqyrT1gZOieuX8NIAW/HwadYfr4M7CsNFLbJ6uxCZgSXnlJbBIC0yONfEN4rsqXRuUsZYVnmSsX21kya9WgbABaB8P6sK09WmQPmkYdQVRkSP/1ZrSSSxj+L4GoU7ThOu/Z4j43b2RHg+tui/C2ALh2aTRSEXkY2B9WAl9YLRGccTRX2pSVoU/ZB29dER3gqSsuuspnIMFaDpj8XWrhl+UdUotlKBnJbE75N8/kljjcS4RFvGvHhlBRgrngTvikgxfBib3q6we4KaFMboHvGMoRjK+LwOo5hSCgk9ODLq4a5Gx+MRyLL12Sn1S9yqSGpNGjInXCCLi03Fc3u8IFEu5vgVmJXIU+vYtx37DiCScjgppPF5mBDJ/dlBVz+VrkLZ7JFNgDEswjl+skQ7t8ih3vTx3z3PZQPA9QL2Cs6YxH9qMgQLf+8xgzux+uoQD0jK1ZvOfhn9P41U7syFf7q4jnV/foc0ThRWBYR/y9O5zy7WgsPawB5no2DZBMUewmZWh/Txzwq+4sgJOEzdpCfS9E+IUEYK7vE/8akDcM2beZ1KKSposZ9pKs6fS6sN8Ll+V3MdtigQBiV2b2QHcvEVueFCyxsmhpSESovN2EYU1nK4mDBy7+ngwNjxIdRo03Ixl8sPBCqC7hMI+73UVMCpzKRcuvk4cYiqmMzlwDDb+U0bXpHutMU6deJlnUH1Km2LxKS7HBH/r3u0hvw4TiTI14qyoKkxFu30qnHBFLQyeBX+B3JlFcFStdP+VBo/V69I+TCA8oOkyN2vUSh6vV8SA98DQjAEjwoDPQi30O2WBQvTpoCxiyROpsR0xnZVbUgmEZXfdo0xLVmIbRwpxNqSOb/zE2iqRhRerKfTndSEJeXn5hgnBy2XApuACwoHN5NHMLuIZBBXHSfJknnxEHg+FcYQy280MCG+kAfDei9h2ELGK/hHFB4VMeqe1cCkxLYGEhCMMHxK8mtwR0VUtwDnD72IiK1D3XtDjL1mKVa1/qGRnHtbuGtaQBSv4fD5x5bGfBwuoo39qotSYX/IRWzwEn6Wdo/xdunjQ3MGxg5IoQSU/BGO9lp0qxsTjZ6o/kXprZdBQ+9f4eEXM7sQSkfXARQ3J2rBmxpQbF3zXOzGogsAGDdiYIERZbGCYIKLvQqGBr3nPExHwxnq3SkX4UhbsoTJbeQnRBGz5vVza4wgoFDiQa239g3cDireYj3nXEe95NplUv4kN3L8BFJzm+mJMZOYl1LXltWyVsXG4l6+ZjOgS2P4vibyM82wTEEQnhL4nzNkt2+waB7w7prm4y+6vAMJlKa/rdMQdzXSyP9B/tIO340M1aN4uxkZ26bX6TJ6jJqqlezE+4Fv0ZBZW5SunAyp2MUtxsSTXnKHwEh5xC5y0uDKY3rhp2/zSYtLb1U1tLqycXMH7cZIiY2bKwJdA/g//SP2haNosPY345w+wzo3cj2PhsGr1qOQ8s2kmbj/iL2dcpXzV/79bF2rqAWQC4HPua52mQA3qOASvD3EWko8SbsoWxFL+TFLz51XKmX71w8wDJP08W/eGw/TBpB4WrYGQfrp5yvgGz1XLnGYbWESQ8hCd5FOquJL2UQE5/YQVj12dj+umwvtUhXgW6hUe066uNmU0pDZIHlgEnoHf+RyIB/3WJ6TUiSCVMSzIq7Y6VFHE7wEJOjseNZDM78DUXacJpDAgwFPdxPy5BAGOKnURNodawbCcys5AgT2ra4jCTOdLWbB1uPPNcCSYg1uCcLz7ioWc7e1w/CXJsGvwLa4U9J9GfC6EQ8EIGibaHpIQYAC7xiWuSV8o/FPyyFnQ3uOgfg6VsZUO6XjeYFxBE/FPmXOPuMTcvwNBe0PdtWFnXyGILXTuHnXUP60iIm60g9Ek8234od5FisdoncyypKJJhu9Q09pPoHcF4EyY5XWGB5RdawS5OA4SrBSYHlZM++dDgd6QTEVQVxTL/69rCKnIrba2guNCSGqbC8FTOI8fxTldBUTrpDkqNam94/dG8wqJ1BDYIDthn5acx/M4yRl5whf4i7MJMvHaC8HP/e9MWVw/uHFs6Q9FBz9PigjKIrqCQlVUduCq0+2TprQMRKvPcWrho0dbEnTECC5Y9/5GWN0NzS/EDKZJaPTBnCADqnc8nLxI+mAodHgyHhqDXXEM6itVTcn8zVPCWrJzx9H25q4CkvhR+YOw4PUU8554wiK4z9C880xrcwMvnT4KR7SLqLzJXzRVFozuKG3v9cMwXgdCGRGBf1qEk/j3DkxrAtFpjWtUhomexES53CUE8yxqdv54U4gauxJKZO7WxQbtrBGS1o5PT2KzvXXXuVf9lRENQOqlZg8zvLVCtFEV41KP6jOsDINqTuTJNgqe+Z85zDrm1CwUgY6spVbnJjF7Y0ZoBeb11qoC2/PScghJRDYHvqcFyurV9C38GhujJoRXbciU4/WMs4H1II/mhD0wNeGsHxn1KPis5HgKrRMmPuqdppCWiuuyGhaSJHbv/0JOzSB5o/i61HK1y1yaeKKTdxKMUKQxiZaZYCqfD6yt8Ns06iMdKa5+P/xYqpbOKUeqhD34aoaXShuv25KNRkjEFbOokEVHBbsGo1ylqkIz31hx3yEH26rSD79ShFdZ+1bxvy5k65Tn415ERMaF91GrFlQDUyMi6lA4n6ckzbXY2QiaRhY7iArUgoIn3+geo88Y/GPY5cM2PJCami3w1KrpIHvMAKQ/+3KGp60jjqUysL5JtUvxPSquerNKCCjhDbQiFX2W4Q5AKYpNMjZ8wgsVZnm02eVK+cBZcDPAtvsoOqebQNq2yT+JUW2zAUfQcGR5CKNUvPupZCYffIX0lJVqT5Q/E7xwGE43FSNAkStEEi6p0mnw8jx/mNyEjPc7CpnokbzL0Ct14k8wKHgCz37oEg49eJbWZkvOsf3Mi37DObkrwvi0s70BuB85K69DynImN7oyz4hEiC65b91lE8Vu2G8NDlq8lbMUjwXbkJGpfqtZjKXVz/UadUkI1oMTEAcWLT6/B9pkHyQ2JXwahhKXtE5CAB5E4reOMBy5Jw/mdoxZZAzdS90Y9IYIucSjUuOGDbR4UYJUYCFCREgOhElscWnjLu/pBqtPsm/xRdSSHHIpbVWoQ+xFggLxMfzcGuBm4LW+Zyd+TpxVshUrHJHRMC0kf9WOeg4qOLrXgGYYTu11vzKxGZaPRdC1Xr4WfDgfGfy77vvqlvL33VyoMnjpILkn6Lwf3GqMktgFgDM0dqP/mCAkL1R7JtdxoC2+lPm2Ek+8B7l2Hs+tWzdu5F4LEeQFSTUKWVCppS8YH5DlQXiR3ItZAPLULlGMkAlbk34bZBbAPMTf4bYZcoFEMpQ//qixQtonTtHOfeeUohf7YfnThPovdKf2LOtVAaPt6KePSYkkxIAJrdCDbc9WQcj+b50aivlhZdNufIjUR+PJpw8qPEHQM+jsNcS4xFn+nVF5Ny3iI0aCYLwEpgQ/lTzZgxgaQhJPFLvRx++yoH8P3iCzm1gY9VUPxAVolfqX8gFSvv2Q+s3MyQfS0gCFv6l8kFH/KizAZhXMsYeWFuwHmp+EEF37WYmtbP33babuAI7iz/cstjJvRSLqw0252CmmPsP98vtFROrct0ktfYrVbXABoDasy/dUVdVTML/bYfLQnV8PycIrxUlSH688WhSPPEMjdJcBb4c6sZOkfaQh0/MLRtYbxG+AedJjBckRi0DB6S4D7bf/UAHzabGYEFCXi5WLmPOvU6TII3isAtntdSZCchokJdSiO21QbZ61u9L9TWgrbpO0/R9dxudVWEV0meVANnNiY9cxHN7syYfQGXLGl+kaP5ENN3jsrf81lraZ8xBZgMo0Sl7cVBnT7t4ch60tMhND73WFZRP2D1N7sVKh98kM3KBxeWBykQ93ocuQe0V5EvCmhgx++zf+agYzE0adavbV9bQDpbWwnNdH5jeVbrs8kOPHGncajw843Zr0t28VjZ4+EzUtJikJbMUdznmqqSivsKaHxxtLIHdmcn3/k3QlLfo4xS83lYh7Ug0LTseCulOGQi5pJTmcSPHBHcl1P2zH8Tl/X1XhYC/gZ10i4dOTe1JvcVKHU95SaSEh/5XuxRY9OhE/60jcm2fyt054aDVD3aR7Ir7YrO+5o22AloRZ23FQ4mwGIDfjj31iuL9WXPdV1woa1NxX0sC52NVH7rb+Oty6TKMIt3hlM2iUDJWepVapOsSm1donh/5E2HXqWxWqzdk8GJd4E6Mbuyz42E9ob9u/FclSOYBrSEoOn4IASy4G7qcIG2dbACAtTy/v7goGu1tHco96WECgJY2wMU97L/rMohZuDWAHs6hFhG+T1AaywmcwbfUXHlHBiuhIOGZ67cxFRY7WOitQbAe5b9chooa284k0VaOy337DrO3rITDx37hm4Lr9TVGujajdkrzldizDLFLhITX890g46Xpty7r+MZRZU4Gol5LWQJYLVJL7pDM1YVsRSgXp9u1rzWFlhSEfSUw8Hug0j/DBlhRWbml34GwVzxV7mh2xyERdJhkHK9hM/mD1LOFp6BN9clEvUFm/XWjZiqHT0UyiZw4ZhJiPR9MhWKdXjrSLLDEYoKNUqhzRn+90g8qk0jf5tLRtyJnMph1cKu65n4cgtLxD38dXsuzQ96aXedNEl9IYnwEB/b5rNBkqXs5zvqUcpreoJfQ3rjxJc0HzJki0/zeEc+nFlHVeCAK6e5xoL+7gQIKSpv6QSVO1bykWnsDj8g4Q36ZrdKeetgsOY9DLMc6Nf42mwAcPF0GFrjU1ZziCgUc2J3frwKKewZZ5k5Z8+yGSE7VctQMZcRDWZI0QvbIOiaA7MHYx3ufghnigQDOU8miXMeSwF5WW2GW+csEXRn7qMIgQ4MD3XAJM9Rt5T3I/ak+kvvog9cPn3+fud95Hab4jZufn47ZXW5zFXJvepv2lJds1Diu53ENtQaS44GYGD9wDvVvCq2PwIwbCCQB4EXk1ZC2itvLVLQUwC79KfYcyFQhPZM/c5FuSVpOJ8qH0Oi5S1qelLWywr0SV2L8eaUPJNLEl89mu6Uvp3wa94KTNm5a6bTh3PK73tzexuU6ofmOvV7qbyB88tEMQk2kaY5YW1xQtNFwmxMrK8YHo7BN04rYRNJ4s9kpYNrWaYRw1bCTfUTg+SWKIKPXcCQe7NPqS8Mx4FjefBDZ8GclfLPn77x8g7HokcDd6Urp3Ltpp34IMNTpkSA+glLDbL+6L8dL6OCCLR+4Q3pZhCNk010XnOUfXkhhvWwdCR2WTFy7bVITnPKZO6zum7aBrLPXUeXFMAwL3vPMd+9kgSIjej1nNs2e2OqHdP+v1tFpdr8+gvyg35cZy8winVRd8hGKqW8tIHlPzjeJ85/1dgF/lbpNYfPuZJ5hmx9HhjW1QH+w8OnW/L5rKBNQYtA9kWLIU3W4MaJHtLzoc9bpuFyI89XhlHngMhMoeZfAxTp7pGstP/Zp/gjVRmocHe5izsNawT2WJ7ftJAErFscUxVt2zkSnSmiurzqUBBXwZHNQQ0xTPlS/N0Lj0RA7Zzx3odAEeQXXgGcUvpWb23zFT16j966XYGzU5o0gBeJBrlNxy2MAeymVk5SPcJg/vbelUwQNDVlAnPfxS/OeHc1XSQprZsAMM7OHz50Y42Y657sQbUlxkWaKAcxBEUNwj997cEdd3hBA5Lhc2Y8mx6syqWwTeqEiGF8ZUdwNWXb3v6TIaAPHQDlcgSOULSW9GVP8EiVyhXSdwh6sQJx5yIAz4aaI5VJbhF7LgDW8DN9q+4+6ADFZBteGmJfnTsmFKXXGuwgpHFX8yLxg3/lR+7IuZJSGQwuxhzi+Mhh1RgpYynk0xgXVCE0R2ojbXLNmz+MJFljOsKseFJmxgjBRRZBpepdwLkSL8waAS4zha6SBd2WwEq9wZAQdba4qRXafCwrbOr+1CZReogluVqf+obzV4LdmGhJge7d753wx5GN5tmMvH0qLV5vjpXAwVb62bCYcUm9ISHRgtEKi8Eg0XbVMlkPaICIfYB4T637+VBHGTIRjiKPHpz9K/tWGMXsvGYgE0MqV3Ri3tZrMEUT6LoUIEhwLc5btRurWBgdhJ4ZhxDtNyztEwqWHITpbk9JFdNWtVgQEf9JZPoJpY3oJ1oWq+coyblooxavy7b3xCJHPfgfRdKBWEVfR60EZ0g4evN53J9UUIq84+xY52DuPdYUQIJPdhrz/y2/5yTblgH9aIIb9hnWSJeDT7QcbpX5cV8EIGhwKz5qY1aSZepAFIiWQi472t5lMI/dkZb5dQ4ijYj/6/dk5Vv+DextQ/WzbDHoROkkJVUnlTDt2mW+SQtoBIzgHTgWVx6uKxxTwpZFHCxCvLacJ4qhQzLzXWbDPpuE2t4ebeIUl4ltvVhe+AYHiXuWlBP6aF4VTBq3YthBfxSgDHMIrer08mLUy167tFn3LayMFbcRNORl+JoVejSbutRN6XZApgPhn18H6QWxuocL957N802aYuRqz684HZyebHxFgRm4Z2GlGw7rnC4jl52GzPRxz0kVfQyb6XDkqJpdXshAYyVAtFv/1zoMGcsYkkAbJvneQx+xNzzYGm3FPhl+QdiZOY3YhSoR/scglSHkZCPOqmm0AvQwG1ExzaNFdZofO/PVChogJ9KR4KH0w+8bZ+ZXRTUhOUd03ZHrhEj5OOSaQ7ZjyaxVFBGBKAyCxfk/eLzX7ogEAiW0/pg16WDd2Rpjbv/ZmZnCJyi+kcM2Htea2p7EiDMq8OWBAabHq5yFZu+tn5ZTOKslAbKVlQ7t2NbUqVByAwW0+RA261PfF1qgwniGOLWaE5HLk9RR/cJtkuOV61NdV5DuaN+6AOXve4IydSKVP+ZlTFBrBoGjtNg7/izB4AAursJ9YY1fn1JU8+sgldLHW7WD6DQMQ94sVcrz+CjiKJwh7T6xmeoIXBQi2Wk3ubjasymHRoz37YTo8yR5cBrxgPEM6u2l2pqsBE7xt16Pj2cuQrAQoJUG+03rASCiBGDRuetoplkhH7KpK4w2galXMXN9PTWivgxEyn5lw9hX6gUdeXwMsDNYU2toYsjwWuCT8Y2X37T9vNOjG8t3DR/w+c51GMpbqhkWBCrFgnRLZcqtrzQbgWL8FH60PVy6bCNv4Y3kGzzcCnxgaIJGceAcoR7pPvCozpm2tvtRnVvUCv4BV18qgSxvPHLNXSBu/lbnvP8j1R1TEIFA3QlvcoDnfdRcF4A1HX/LHQEbHIHySZtcTNtxfpCAplP6Q8j8SkvR407+SgTBDCPkhUrpHfz8LVafz9UQ2IqHZtW/BmtUluAtZNHGDR7XIu3wWGWh7i7plTTeLREJ+izNsXxVSpvYJvAFsm5P440bN7Pl9ZZBHnpqAxWAFnCpsA8idlI/2lEiL23NtRG/e9PEm5dOksTSp+vHfRwUoo2pH7sFHm2Uuu2J5OFILCfUpbsownJKKFpvZANJg2QGKZsso3Y/+ng7FctUXOcNNkV4Wv1BrqSP57JI1lIEih1OCBIQZSihvH+m/dG93N1k4NgkPcncJgF9sOStgET+D/2mLl6WPwcIXBe5b/1uDBOL1zo2UTC8tRgiRVkGTLyx32qAjyuD3t8HbiplJPZzVciakkTLi56OtYpLEQ2DoRQ7M38ROyi48+krt72+NjaEIVYnFPa0G/B3mKsHOr3l/H2LzpO6dIaur54gIfO1dHArHQRi+qbPJLBa8SGVX+kQKqiD0Ri0OdSCRHu88ExgDP5ZDA4jtjAL481N+Qgu2ZmS0bfzQjbjQobASHMIf4QG7UT2WqlKPc5twh2Fg/HnKgGaSHNnLkZSmRBLA0bd0ZoiuBdQlBkKPitgmxJLbql4sxr31dRiZUYgixQ0uanqp3LMM/QtLWId7MEaCNjWIo4bfQ8zXMCvLiV+OFeJhfUDT3ja3PKXk8njX6SvpH7L1IzZNs4APu8eRneBPTNW89p02UBVKxWIrjdMfKafTfmZZliHxwhtoBSeI1h3+QNaKH+Orat/YNryKEX1easwysUxxouMbI67bDFwcnKaLaXZc49ODgJMEWbinbH1NiMD++rqLH+ysVJaX30pt9HgnukBR9YSfHaCQYgtQA5BSDCJaBzmFMzlA4EK5SqiYnDTTCWTdfKjTedI6KqrwF2CxVE2b3O3O8fUkSJjQmBoFGZ/2bedIbOaGBnMLsY8UmAZKkzVEWCP4nbG3JBMSF65UKwp41mutMpwO6rBBFsvbFcnP6fDrrEhaA735YhpVjV39XmN3CmyHwhzHS3d0ZUXeCpjiBS9RJlVElarHWzXJUV8fKU63fyiyy719IXl66Cq0YuuG21eZyT5fCsy99fMMdhjjMQDr+TOd0v28wt4b6T6sUMSDQM2bSnNH8xmR5Z0NMyz6F2Or26hisRz8vj0a5xLdbgMajszlvTjPk0p7WlKHqfbabh1SFu6WobTMZTDIjZjiognmS80CkjiKzxwZe0KSIjMJJptN+yBrex0ToXO8lR2twWILnL7sY852xQw/j8tllGEb0imMrsZnxvB/Cm4kDJ6dzQWUMOh+w70PMooR4yeKaVrn6wmixN7kim9XQ2UxdYwOf4GkR+m9REOwra1xyBbmqGvm6kip+Uxq0HNw8OcX/fgc2dLlueI2yjxOJYgCw7VqoXyBJvWQuxwHA07fuM6wlEFQzMiyzSDRWlQj2WwWZXl9BfU08ELUwwHTn+g1/DsuRST5Y64mTQWTqrej0rWquckOl9JolpV3JD85JER/7uERhbltC87BgGwr46JTCuvZxhtjggCqclkAf5JOEs8KNIK2GgO6VaN3HqhiG4X//B0efE7ElBymu50qlWmgMM8egkhlP/aeqc1uCUHDlr2C+6M6k+iyTuX+Voc6yiXAkMIWK1de+dfyPHvtv/xcBeBFEfZWA0hsJzRsDlqanPffsYU2MEwn5ezr6Hag80IWLjeJsRo1Hw6yWwrfraf7hpZ2W+MNOSa/k7KhfFLxXgs2F6BVcvWetB6yyUKHtmP/cWSvO9jK2tkNCUunjJFAbHjCfsbsw7ks23V75S+bPmJNRmCXPrsIrB0eFgeF8cm374wPKKT6AIklUkMCAHdNNLvwjMW62YEUFFlRxtvHCMhglQ9kcBfFO6QGHSpdf957WL9+Ke5zqkwGU5e43+1QltfUSP3UEji3VPc9hjwb2sJHVyrz1wXBKYdazjsH1uqqfNffnYxgi0dLAWXph16mWqBACdNb+Z0lMMKVwyY3oejt4SDvRG3URZXAfrcAW194PAwYnCmgE3O4BsH8m2SKzsfvG14+bsbNzWfTwWPG05yJiZu20hCRquIub/s2HMe8mKlGP74Nd+dgAyLeZW/gQi2RvGrUYmNaN0HsbsgXsLwCjOEb8uk1hmQUPSK/HFDWH0nN0Y7BlGzj3fhzuZOQAJd2uyr/L/Vb26exOTB2RxcFCOaIRTv+7Mqf9u/RUsxa/egBy9wtH6uFZs5MzYEZkmW26VjpdG0MhoalJS4GnTzM9GnDB+NOtjgQJUrDN0Eq9L8IoTXWW3ckKwgHUOn2x7qSjvakPMlxfNKAMi8mBmIeBygLrgyewFmLY2hDvxgvZBzZH9+f2pply9/g1lbnH2zlLTPsLPixtu5VFi0JcCO94yYolIIVZSfIpns2YVALvt0AxkyDJ78geaenSimLrqYenKwwkqk1F4C1y9arQ8ATaqPt0e6qNc2MBhQumR45kzENcxNib1y9HdwiKIoqU/X39rWXpq4QFA1C0ZaD89d8nNHQ4Uln+DFlD6mgNCk8PLUhUfRpRa3wzDeZC950k3uTrPDffuyCA8sENjXSqUSI0dCBP51x8HyVwBVX/Dt/j+a9BJ3DJ5BYjvgGI1Zf2FGVwLMJw7LFN6ZcjQ1KRWNhPPRVppwwD1KJo+x/sLyuFTjjfGAGwpVvDFvwpGQp8fMkbAkAe851RohoEjZCTX0LrJDgY0kIlHNrYXip84N56QUGpfHevD7ao4hh2BZxq+KtuAL+LFS18BMU0qyz+T52dJTNIM3F0/G6AWRk0rifai5VGRJr7Cg8bq2FndaByzpqUGk94+z/LZFvMpQOjwpNlbZwz3n68vuECIoPASnPsbPWNzHimo/6Y+XJnWxR9AXLg48eIhvetbUGFOLiGz+tmO9uh+Zcp1xIp5qnwcZrMCxD5w4E1dw9T8ZKtL/drcAZZN+0Jydj6+LQ8ckwLHaAba2x6TQDsCVBaHDpkUDeIN80UmIfPWCaKbGXB+qL/Qxe2wm1WbcrdJYxkymtNRw53hfI9IhoniXeIRZZAQ1EjisfhGURVyHv9xLkt7+OfhQmB0pQZz1G5sPypuxyKzecPTTdMTqBFj9VDa8ibRnaz5JlD9PzVM2CzZ6/gNC94Nh1RaYXLY3+POiyBtbZUdRpSp09ZHiBiYwn9Gu3WRCz9TKBoQ2AsHPnNITCHHo+E0JV0Pb7GRd4yjIeJ/RFu+rZlsS5pIFvCrnxlTFPKTL7HoNNuVDLBzArQbTs02XihC1+4+VTFVLuAvJnyTZBm3rxx7b+YhDk9vCTkXxvd8gOQNXWwkBOXTORaFqouo1hCxnOw9W4mfCTL3TmfkyF8B+Fhl80Dvgwey1O8+CBGeYD+OW7tsAhh6NLu6YUpLY34zjL8B289LaoSvj4HP8qc/ox9XadUp3N7kTe2PEZgxNxVRTVsEleZd7npn/S0kE7n3mqZyAQt46oJf2pRqnm9Zo7H94LhOdtdXZo8NY7zMVZiHKUz3t2WG/y+4yCz8gRYqoQkEfkpJJA87ftsDHo3kFQRyZI6lHxu+6NImlpX3NSienpz4R62mxCS7Hdu4AZxrEig8aJ65TaJZvDmllkMkbjZ2ZYtWlyskl0MYggCF/ZzHvA1x/Cm29Tr3kTnWj+v4v3iFglPYBFJk7FcS8AbP5457RrmpRCsJriI7l5nwgb3isHwuG89E2u+8XORZV/NuevHkDLCD1mpnrkKbFUk3yEojlLT60BpBWTYJwQk6usi6MLXq8OEptxIB5vBMchNO1ZsYtHk6JGj1sRcOLC7SsXxtoxrvf/5XYfqQngJnG29WhpYzoVmiz79LY3nxy6Ta30P6/UbMzrNmyRkTYm9XIST87eZ6mP2DpJwl2duMdIEnKd0PX9kk4AZxQ2N71bE3nkv03WNtz7nPy6lSyathBRYVWOES5LpK6iFJjbKdMvCrH0PkUr5xlywDTe6s84iJhkr/M23aZ7tbGTfZTWGB1087WFtwm/XSvu4xnFM3tnhdYZanj8AqoXrLCdmYV9EzJKtQ3KpVnACStdWeQsFGTmjpGbt40exZDORhphGsQkOr4zTZ8AKb+OYNbnYk8q1lfYtuYz18oDDlJGY6rTeWKPhPKTlF10WAJ+QUnjJgZHvWQcLIuS58PAEwO4jyKxOyZSpWQoRcqeQcvlfBH0EW0qBqKgGazYheouZXcxfVbjNTSbESlJBOjkE//N3kScrA23aPmZWRR8Xv+2VOjV8Sl4h+q/syOAn9ByGo8RCDjWC0GnTo7q7rpz35iO+W5sH+Pq21JHv52j5h0WwCWbqMQW9WkwgBCKrqWj0exq350f83EyB6GlSYBOM8tD2PFxQQp8UnNXwDakv0HfDFHnyVIGO8qqXgKcMNXwZjyhJ2MlpiE03HOUeBllONwrwAGhOeMWR9sD/inIGGrzqtiW5Szpw+4bZHMaHzPd3dWVgaH6xE3jrTr5WB3n9DdTDRqPlyTVdwHq2G4ATE52OE4kaPSnE/YUowVBJKJUe5kOzmNACiWRo3fyJUnf/gUYv+3reuXCUAjXleY/BvZ0AeDid7nHfMHHicNeA4YxFEdGRLtc1eJsWhe1n1+dlmcU7oYZXstSlCpfeH1RT1iJLmTPtRqPfMoGtLaVRDZT0B73yBwEv3MeHDaDupB68aQiST/4efGlgaFe+kARV98UsBM+7y0ueL81Is6A7Y3yTsqrCAUiBBUzvpyk948P+iesmkYpRm4Kbc/C8kM1ubC+/7411EW2UfmzaVDOBG49EHTRxWvhk3YlEgwZtog9I0+IoljdlA45eSFSu4wLjGlZxQUY4jd36vO3EsS6ta81/flHVL4HEghiElyk2HSrNSUXx7VZWIPp2yiObYgnsiEjhV+ekwRPqtolW+q6kd67GU1p22kAxDzIk+MaunKziDd5RnGDSJFxDOzJ1vFPzLoUnsAnVNWuFyYwzaUWTNl5QfXU1/ZM2sv0fEaVsyh7LX0Oh6vL+J//9jkRuSNTxzuZWsIM+9s4s/UZJEAHmX7koVpIC2tQF8uNo+5yt6RD1R7W5KT0tft/Ik5khzPK4fckVu14U2OjC/Zyfq2P+7gDym9BAdmlt2XqklZ0FlZmvBoOODW8lxeZ87Xg+NFA/RpQQPdIxv6+zDkbaQJhZTgIFOAAbdB0jMEnKdKwnmZSywH2FpwkIOj1jEo0+LogieUyFYL6vBlI3DNb+ZTIOAZtZi/Q9ewtvkJIl/oaVuw06F81t2KCs9gh3rsSmqPtbtUb1AWkeO+fgD5+Qzm/60BH4BJNcd2c1KX9HqPiEZwtktoT9JC5sxuO+Hqe/iWTV33xVXdJT74mYVFdq6gYjjNGSx3KlM75+YUAs9zTLlPNaQQ5I0vrPS7oTRJ1cp/33/mxR+gXxFuINGRUYSUo82g/C3ng8PLdn48/QhDyzNr4SLlky/PuGk5KuMXSkBqiKKNbtF9YXIlgSOdIFOl8+KUVkq3ESqCR9MWo6gDifvz4byvWkZR9arzWznIV9qZstOhaB//7DoYsq3/OlfC3eGYm28nQDMSSp/oBbT/JpJJijQXmDHITxbypuvYWbfVrB0lcYMU3OxpnolFRM2FOvugQZ7fb+2OUgVyCZjoCLEavcu6XihHprSiXUx45/suPcjZVm3mvnmQVvDdMsdaN6yWL2RQ263j22Tw1N7JwCbsTAz0nCQwawEH3v8pPeSL5dGTOYXpTPGH1sah6dve8BChmLOX83zbLHVERSQXhK9GXbjgHRMqx+Fut5elIUS+fUpkCoLmCxw5lkTDEWO140XnuVrGCc/3OHxfiQECmBA6B5dIXOkpd7Phu0jEKAiafyPOF6mSMxYCukYhy/NVS8JKatSPRexWPwC3nv1876Cb7Q7Wpulkc9tngjbIVhQkJJ+ZppPBGcWWJE2au+vTK+WmpogJfgpySl+/aUDkigkC8NH6skyh07BIRQJsQjLwb4/0DuxcKPHP5Pabla2+di628pLRzBoVi7eSW7/TtM5k+qBVTQMk5K7BQU6mJ9p00ywO4V9yR8xBjTIkFbZWk/3i5NTWXqpeYL3O6MOJlOBYiXJUIi6mPkSAmAn63TtDpcVsJvSloHjtTi4754nW2pmFzzAE+mQ2PidOCvmk5GZrgQGi6nJjFgrvN+lSctvB4JhIngooLEdJ4QAB+YcDKKg9lUGo1E6p6DiF7HHE8u6tnLmNFq2A4j84GMXzHiDjWT90Fla9/y3SAmb4eoSMexTUVgX5kOXCHao9nX4GDhvC0hCvncMbsf9C1+8+qak3ZpE60RL2w5wiC+/pvt98g6JUou8x2L7GWvUTSSNCysD9HmblQM988XTBiXIhPGQOMupr5I4gYGzCEYSE06u8LzSgg9Ij1rYxyz72Iw1BZQTvVmBvf4zxgbhpLx8PrZV26f4U1YzioQBh40BTUrol2hyxzD7Mh6TJkNTEVIXQ4EV6GYso5Wq89wUU4BLkxV5FyH9YKukPz0Oy1oqCDeT3xSlN/WSYNO4cbPlFp9Imuh3x40HBC7v0ltcxtoBF4vo/7HXc92x/c15CTiOUSD+Tpwcm9USkbqCFfvmh+/oW8uBKrqUj/xqQDEME/sEQhpEx06CfFxZmA0RqOa2fLF/J4WznqdfznqgNBOb6PmpMqUIn3Y9gg7xeduzdB0tSiXY+stZsZEf68KZ8HbeWecXNiPxItQX5hg7wXst4uINjVSQ2c9JdC02q8KxbPd4hWW+W4RNypZUBBAOog9lPEW+uIyL1TRnAHkkH74wvXBjzTeDAUGq8X0TWg0X6Ufg/qrtpsf6HaNugHlLm66upanZr+oQ788p4B9cnbqoGS6MAGQzptZ7sHwWtEKuIas/nU1//7dHoiQjqEJZXqxSSnqDGcwYOdl3SNEWtQJXh6e5IHZzhuQc8Y5reWWZDlTibcCQduLQI5AJ6+NwrlvFhb/IayU/LAcl134UNWKChiqaKgb3a0l+cgy+aTXcDLtbGLmyOiwmQ1JbTLXpwcLaGl0HW0qIWguyxZ9aEvwbgwRoXJOtbpPTI1Ij7rPVobFkHlkF2O7I48WkvtilQN9NfFJ4yhEUiNArjx2GKwUcgaT3USWewjfs40c+fpUyAr1wCNuqat3KpZxJrBgNwIAS59+/ngp0YiBMZluA+R3TwPD6rUPlYvzOVBP7CBG8aQ/vHmZe7YBI9hkf/2ASnmTZAtH7KxqEUZri84SxopKP+FVK9aWqVWiOXUH9UIJ/xLAmAIa6OeA1TDaJLW+PDhYnws2IaqiI2OJzSWL3wxeeK4MRGGnRx5t0UG4nhsgHm93By6SP03cd7aDTKzRmoUjpVO0Zm5CP2fbdY2yEFtkwJfmuYVLkM4uyKjKL6TGCTa90ybBVEd52PdzaJK4A9Q7Zm9LiAEJ4tKXtiA+hfwzAJ9Ij+Ex9UgnHHJJtY4dnYFDvjNhDxzJOVdsJX3qVN37ZOXrzq2WBopqrTmm+ZOak5n9TLn2EOcMlGy2xP7UdsuY4tfCIZ8zR767N8TVZdS1STq/wfqwi2F5WBHJ9Pzsx9DQ/aNsWqgY+N5wpTXEPARzNCScxw6NnJICifFta+R/WuDDispTqvbQXA4qF+VKzVUudjCpiXON77FfM4QzBlM7EMQfgO9Exn4AUHGH9aXyu4/8/NlpyO8G2vB87JHLoGKeUd+CtnEdf3TVJ7jrY5yuQh8xilEzcLDYm6IMUhfkyFtYJbcclhrJm8IiNDX/yAwAZsXi6W7+109eJ3cMxnoxPnmEX8ZBgO9fIvlJEJiRkvIDbL2+tiMR4UkkuRPFLbV8XCeUbDNdD9qWl9/u44902JFkSEyrU6sIjhzOLqek/J5swFLERP6VgKuS1HueWCj0Z1j95fIDbEDqpJqEvx+DnqM4BB3Us7IbtIgBrsDu8ndQiaoCPzZIiTkBFDwP/VyF0EjWrFkE9SG4KbbMkWVpeFSJuxnWUADFspzTarBZC5ORu30NVHXxtr5dQRnK5dPqppXKpZwTSN4MiZLcHNXf7lEbzMLN8hoQfAXAfpZhr8bBwiayyyINQNSXRhFYdonU1FDeTJj+j9mG5CvkPg8rnVwErklJXEru4eg1BxBmBrITJciFzX9VVy0mvmHxr3fzYV3A++4iGYlHOBcoTdmzrABEk3B5G9Djq/s/fwOANkgKzTpMkA6M9iM0rSup8GhANIUp7pwL8rH192bEEXhkus7qACYw6Q4ALX1a/drHDu8D2qkipMe5h9hmtntkHD04lMefHf75KeEwGdrLFooynsUp6+6TEL2xcQUwKak4BZ+GIlaCW4CdoO4Iyp9zvYGOtE5PUoBkl4b6rgwowI9M4Orhjfr5/h5W4FqlfEqISvYBv/qkMZDuHvI+9233nYhpi7nZzvTLu4tQqTDrCgMKZMKiikulgGjbraIRyQ1K7ZAVbqF4a0GbQrGratJcax/Zqa39gHx+8CVu/HqkMDN75FXFF1zUqCdvVPAkNdQxsiFQXwEDywjkM6KjqDa+Rlip6hUGwi4HvPp1VyJrP0NjyenjoExwCub/VzcauGmxh8s3l722bx5vv9gMH3pRpLlUprM/J7o76ap+QIy4HrwhuMY8AGx4QTE53nu2jUy83q5aHpCg7JST9l6y6PuDFJi7HkKya2g0CjDe7OV2YLHwPYKWo8N7ezjTHq9CNvhbbC/EEPS1FmbpuxG+kvcRb+o1AYCbGq0AI2+o+m3JXvV+/htj2zeF9T5rmHIqlxYFvU69bw9RTtcSUyiqBdYX6xRv2z9nuTT+JH76v0N9N4wvVdnq+BMDFkdU3TgifHRY+80azYHAZAcgx9VBHqspDMa5IUoTCsUMtJ0WHYVEmiDTu2yemSaCRTtOOEXudNsWhd9gRiDDk9kkGh+SLO6DfPMtJQXAAYlsF9bid+WI7a08xbznXShLJWU1q2Cmstk2pkA+JNN1xoOzEjk7cpNFeFLR1f4+1IwlV92p/OWKFddiw08XJbLDNOnFte3rMUEuId2sUMG0ZV9trcYR/47rL5iLwIK7wM0hgXvR/IvV/+KSDJG+PPxM7sVjcvVsHkS/0c7WusgQMspoVbV8ayD4lBhy4Ez7bjvJ4AjxoIr+E+wXLP4sNf1RTO8XqIsysOMXz3X1RvTsMXS2aV4YpLJKghpd9G/7uj0TTdeF4rD95l7ilJur5uxPU6QAihW0WAW9lbKT7ymEavG5Yulu2V4iX8JlRva7sF0MVdslHmbO0dZ4n5KAph4kx3wQjDq57P6m7BbD0BulWRECfampLX/m/P5w4OiElmoC2ITiqv87bU8RM8BGkjRwMnApAHRq3tJrO4EPJznAygYp/1Q4EM93b+MIKZXJHXHlN2Zf7H11q2cPe88esgesoel/42ggRK1GDWEbokF+SUgb2Nxdaii/ZjxPeFurnwfLCJKawsD7G9NzciJ1cvXHUX6sPzp0NOswD1GJDaQ1S3SKQZbaeAdRKNQ9nUwH9X6NuX7Id+9cFoCz+TUdVTr5CbwH2UBsnznIBdoQLpc5uXYJs7DMx8DyScBd392fL/AQGlEDk7OE6ySuz0ODOoYSvRgdWu3ZYB9LmlrWJpZSC0uU8gn+RJnaUV3GYS7oF4YftW2zgkRCnubVNjmrZCpFaLFIRRTAPf5/oLGc57TsFavM8liEHZOTWrY5U5DOIlvGx1xNg385TWDz9qTrWYP61jUnRktZ8vHq0TJLP9g1GLN47qxTblnhQNGgpJKvQV1j0Xph/3s3OMvAIGkHYD6cW/6ZWbpkMSCnvbF0W0REPcnV3lugvvhnbK1YbtPK4P39q2WKBTYGDf632uIENcSVR3n7rYReL8aVJ7O7uS2d31kpIEz/pgs5DBk9UjYZ6OFjfnHCtnl3QDZR+41niaR5PNIIqn4UhgBZNbsnkBlsa9M75cuxKA9GT7a0ne99YhaH9W8J0IHJbvAYKHCOik6wsxxOND3KEVLznqgtD+QUnJ1O8aGCxw8Ap7A7YbxEn2RjEDmL0nLwA0LIuK4AO5N9mi7iN6TmCfRgoeLr7j7/haFQ1RPtdu1tUMeEpDTFui3cGeqD4GRNcSElc/p1JPXHupjfv/7ZdovYpE3J8GrHNOKMif3Tjs3DHDaUdr+lOz1btMgWFA2WKVNANE2CBsGNgwW1/gqN8bszjSwVb5nRqhMJUL7c07YZJ1UNddvTW5fHnr4PYE2o1uOV4uBx+Gn4O7EnSWdepiXBtJr1kyzKHM8ONjJuy+b5nZA5Fpt4Kn2DRc2/McdoPXF4NLBaYW6951iKxXsVlGvj7DIZUlvl3LCJ1UzQXpcST+JH3yI5KinafmRIXreOhKG27EvylSbViwYf9ol3zFOuaRhKcTxP4UlXCYj/0X6N9Mpozz0APxEwrDJBtiwJ6YTJz2JhXj5qhyltAnERxmGO+4SUhr8iBYrZqTm2EpGDrzKIk9olWsDQIrBP3HbiuSsj7rfsUWDb3iCRbkVhrI1CYGiOk9ag2xY1F4Lli0AorHF0xqoJTYe0g1FV1JRbHvjVDKlsFjc093qSCak3S5ZS5ZPUJad3PE/nd/59aUUOmf4nVxLwrno00L3FHThRWXeTbvgKLlVALsGdb55h2sVkU0Z+8vANSAfffX//04apaj/EIGaNP7ybTpyoDBO1swSb7O//w7k5PO+iutoQx7wHEwdXy/9XnfQyo0ZAI5mK0GtCPeVaouZp+xeafxGGvHdONTtcD1zOJFAxlQx/34FPWM8EF8s8aF1LPqGUXnFhBiDCVbU+xBPIMJjudyB8032q86IythfoLv0RAwR3Bdb4X31t+fbtsXs3YiWfGl3asgGn1dg2+SoiWu8ck314Brd0LMQDPtwU3m9pyUx8e49bttd6mFt7QUpoChURk6CKGPsw/lD+hUY9LS5kVznVn75vqr64sURGMbhfJ4qt5Z4PfQFlW6g2CYgmqnAJqCwrp7EGEaVeKFarlDEAucU6BpB0BHL86bY20Y64T/Clo0kg3aicoB1IhmzhMCPZYcEl8De8h2pQ5AolBqiCvuqimfDNUVF25lNs1ZOyvpk+SDRBOsPHMYiQ2OvmIkQ+Lh8CbME6qpsyKIv6r0FiqzC7hXDYOyYSKndw3tpJ5VJyMDugJV2RlHhgc7QFX+nYdt95vb4z8Gh9XzvK16KKY51m6ZlCd1ry+HwcJbImAt9Ns+HWd4Ko+dVu2DiyzFn9Ue9dPoiLLzMur0ZjPovqy2zRQPPF2SQo4lYhnBWjXInroeh4Li+CRjJ6HOQLhKZ3QNA/Gtd1FpITBiCYbfR3rADxDTjTZUW6jkAPk4YS5sBuEXtSrVBP2gfhCxp/Zxkw0uXLKwOoNB/AG1kSoxfeyzvBw0Y/m8YTUY8lZgRUxEFqdGso1KqJtz7SQ66P7QhORVbBL1f5yNyTGCm4G5Chj44p0GADzGlSJ2X+XYshoaAV25m5JwudrVx6B4c+sHwcdjO4lmkEyiJGg5e/9dSbka9KEDVS/P03rnjXbCcMX7P6shuKO+pReWnmVjADj++/LlVOsO5JtpssDif9scFN2WodAhhikVTVNMMXnjENGjYS8pDLkuQuMjbhiySAJ9K31XfkElOlEMCan126G4N3bCb/LGix7ezRFUfAonwwPsvdt2gtQrNQgZJ30q1GHwzCOB46FjI7xdCeChSArPuTZ+oQzJCgBr2SvlvdKTderaq3veQlzjJxpwjt0A62IyamrRjUKlE7pQe20Dn4fNHgnr3/wAAR3QXz+rygS3GmaFeZAbCc4FLj040eRkImQEJwTDGD/Agdax6Fz/le5JlIbu4nNwwE0XAd6ZmeoZrdTlPi+BIkMAKG3oPGdfUoHWyxAkF4ZUiva6vPOq9nsA76/63HZPNmBdLH6IOu8iwAfu7cRUM3rFIsVVe7ghc5dVWOfJTkr2PLgNDoVRanz4CphnOAuBLPFnFxMlECPHHlbQw92awZr7cn1rhhvimgWkelqBl6zcJR3YoC6zXlrgOJTGIWL7nQyrYLdiDPFbVsYUaFQ1ZOR3PflC8ATgDoSFMOHFqzpvy88SPqX7lDg59oOWXllMX3avvcwkms9XUecZjgOuxzeXr+crrMK7BGWLoKbm/xOayCkmkuYm904HJNZR1xGNiXQqN31sJzF8+XrrfBxUWx3alvbSf1z0k1bwZC45mrqPqcAU3p3ig9ESJeYes9L3YiJydxMHD4iq7sXccBP8eIx6EX4DhFaR/Szypf6lSki8RrRs7oRYOhTFTfMSWhZNX8X/Ge0DKOgZoTQabtFrilkfRu74ytIg95bDvd3oD6wGQQjL0FUHhPcp/aLF257NriZmxoas5gYVb8SVaiO28UHBHEaBfVZA3+p0JkF0zQVEP4ps34OIG6TIxL92NYjPLPaN+Zd082jLxwdz14maTPtHaAda0kGicf5jqzZu7tFATxbZSAox4wxmrsNxdSZjp3spsgAHgGhvBYmPDCgaJuvTbH1o8YMNP0KUrN3vW/6cFymkObXk4qD9Tgt1QoB0FpT0srUbE7zwXTJsPRREscwKNQ4qenrl1hEjVuHeHWZbVyfT3kL0dhvmxAOTRWfM3c9p/gsxd2dNnMeZJoQimJiYNhi37NLcTM4CuPqdUaY1R/9N80fZTMFFnklGbvBBcHvAHKl9A5QM5vp216eMsHq+a6gn02mVzFU+DDfRfEOAqiaC0eIRNkEKi5NxeKX7s7fO8g33McwETlEfLLQOekmKQqStasF9lZnl/6H+4/y65TafupdVsqgUE36GvDDiaxnwc4FXdqJi+S8aI3A0KVmG6tgZMn9w5HtqMPVMDzyZBJiYgz9nRUbUhY+8ausunMkYwm7Cli7lZIByWmOiAIwDAvofIRMVRuzBCcgAQuIMPcA5kRUjW1dsATLsKI87+f0F8ht6x0BkpKjhniKXS6HDNvX5zhN28fnaisjXf48ytQDtNEMJj1ZPz3b/Y3Zx/uK68QutyM3oVmHX5P2cUIJr1QJUdRw2f95xYYrlNYxgUQlEQCJKtSh3FrTNXj1O4t3+eniPVxrsVEMsZfT1KpNVMIt1YblHCgy3Ych24OhbM2v33/++E+UFyrOepvbdMKxNP5UBrtY9uBRwHAPyJzOVRPBAQr/VNpIrW+SJa5W30jueEa06fCdFMveSz85vR8wy34T2Hg6ZfI/oVd8YRr37nnBzIsAaQjOmzweTtvJBZp6tM24XSFvKn6DIDf5jlwgHCUj1Ju88l4VrFNm9ZVOKokA3nFY7RP+NI4lP6e/kpWd2vYWq/Z7BxgrkAxKlUPat/0KEbA79fXi3Qq5DyWbzkp3m445VwmnffTzz+1qs+CA+h2e9OwpLr4zXufLdoFf+V2xVs4Sl3Z/PemojVOt4f8tknL2PMv4c4sHXRJsvkxuOXVW1Myuw2JsrwVHLp9MpoPa/ZUYhTiMTPNcmKn9LwfQixFD4Qd6VhVZZKbnC+QI5TwNBGF11U/EZD6zOow8n+dmI9i6PCoWgMDeUkI6tRMCWcYr8uNltckkQtjlmMZRpP4tKawBWTIIRKnzkELQsNiT6l20UjhrwUiOup/bN+AYzlrvSuudVtxBiVoggQdiJjttynFd3E84ThTHz+qhu7HqVxA3gfelAgCi8hdSPYSPEBXbnstlWxBR3Zg8EWmTtkoRq0AJv1EMYu0iwjBRdEbmeKStS30kHLs/yWvoo9jvYN6Ez6Tx+Ms6FSghTlRYlmsSq4G/km35r2qjXJwsHeJe4yhLm3uNtV/ayd0xNOq2YZadVEKzhcf96umreRD5Lk1nycxJW60zPnvDfiZ0HUfFfTKilwQhQKUiionshTur2BemnHYCDh+wRBS5dfyggWIouGtYKWqBxozV25EfaV4vrmQaBIhSQaa5gs7qEqAkk9YZGdwq4D8AuZu+M8iPYe3B1+ZVe3u5JbY5sg9s5gbeZjbCujMguQzKJCGsL38ii7X4J1a00Pn5sQBxV0pIr3cb5ivS/y1sg1U4dU7iBjPXuefTLVBNjhqaC0O96A+XB9K6WuNuuLJZOd6/Lm1HLSfkya+IL/UpH6MBhMAozKYw9q/IoGlUFAdtZHICx5NNNwyM84oP12EgProL/z2PYMuP3yv4nbO56KbBt2qqAm7b4nPJLyDlj6lfa1f6KPFGopMjaqGy1AZgHYGvQwasDkngz28MhUa9nqq2TAJsW0Wfzf//OqEMmjoo1h2dSzRoLCz5lXn8dccXKLElLX8P7dM9FlB2zNu5No4PkqCemAm8Gh6WQjwqa8iqLgvdixMxGqgZpbluJ/1hmk7iBqUmqw/3OHbyNnRPjzK3xJIQZyFn8pUMDPdxC95YlwsC6b0zDlGI6MKJGGD8EGp64GcVdQYl4VuE7QMHaJ84o63td0ZPZ84PCqij/U13uByEIJ4xfutIiPp1tDvinMtoLfvhDsKXny6NK2yHGPjvQr4bQmmyhyo5JkhLYWezhpyYBUjY4NBuKlMNG6lSuxcMrIKyenrUZduRX3uLszxKfXc/kjZBYYEfBHmCuEYQ8OjTyFgXP7ZJHfrhBz/yqwhJnIunrVn9T6oeWEEbf3yKi+e0kw2/A89+MklssAekHRqEgZ+WIepwWQPt+K535JbugKpr07JRPVudN8Z5A9W8z/VWoPkpT5dCbmEoZFXlD24m/4IfML36yCCpTC/cFaFhs9H/8Y2s/Jdpx0N1Po7hqtRaK5CQZ7orkFekGTM+ded35n4TtAdWpeRkylRHLfynLkFTLTzjNbCFJn4rZyqOkwK6tGqZA47BviU75K/S1FYMpMDgCPl9CJoHyF6tFpfeOdr94Lasp95qCCyq2DoGhs+4yB1m8TkszefJahDtmy6N9/6NExuCU714ZfU8WJShfaw3/xXLC887MddfsLVRVnvak0bz+AOfVpU5OA8lq7v1WDsYalqOF8igPavUtJ2sCFDhBiDzWPImeBu+/8I7EtMklqXk8NuWwg7yR/E+e2H8YCuUxLJFefxzG6zgcaV12phdQVNFa2tMlDPnGjbcRUX1NX8TgtvOjDVzfVWK+kTPjafE46eeU55QFuPwdRkVFHePnlCj2qhHo54K1qcgCqd9R7wDbv8U5N0upU+chhiV9WVUeyW/a3Ugx+PiMW+jpcuEpvclW2+B0kGXjJ/Pb/2P05G5KEwtW6EOq6ITaDqYrvLHNUQsxS0wsEVepLiMYrw1OBkLhmh2y7Kfmcz12dieqISXMA2ed2aaze0i178am1EYg3Ddn4vSHJ5xvOO1dMUx1cL6KzPhmEW1Tc0gQvxFoUVZYy/aCZBUCo/uZqZgO0CPP7QIehyqxflILxUZwBsKVwC8puwrBDxIGqlc2vtVoMwI9w7dzFRM0OG6k7kM6QQhc2f295/jqk2l5t6Vxm1w1+DjnX/pDT1/pfWcT1M3bSJfo03X24l1Crr7wcj789N8qcUoOr8dwF88sGPh/mWSL5Q8DRcarnZIxch9Q4q7zjvgeJlE9qSLBaO2rMF7P4Z5iwg6mS3tehmHN6bpO/ta7sOBXLhnmRh1EQD4/5Z8AoA2QNbLBLO1iVQbI/7CHr4Uk4v0g/1ORJvEu3VibIStbFZqCsaGaSpcWb2m4MTpjTM85FIGiN41+sacNSpBW1om3qKrKq5ah2TJs04AmmAlldkagIYMK5rR6zscFTgCtD/Fu2ljDpM4BReDdIOlAC86dXYbP2qJq3TvYl7K9nrp0D/h/0878zUXO75DB0uxHuu+JqpfjzmHF37P/8cOOQN76NT4U3acoHeI6uAszZjhSy/SDJCson2bmVnwkmwMNkP944sTUrCnzWXKhq4pJS0YgRTOBLGwfZRe8g+NIj5lCOI4z6CW8cNkcOxlRmxexM9GVWZ4k4DhwCE3A1yUKCGPyjGDz4BcnAsW5+DByY6JRKWAapn77NKqKlnMFCjzDKUEYe7kUsQBQ0mU2dJ24u+u0XaAAujRn11krdXLSeUmY498aWei5vYcVMiCwnRolBvQeIm0SZTnXN3wMf8OPUyUHWktWiJvUr8SPUFW2hAFDLrHpn+ZLLEJ2duzmD3NnTlonlGdAjQNL1VpUDGt2gVyGzzvq3sveAcdMztPuDBiqkP9GGS3uH5nMOoOuDFqnys6kEJ24K1rdQ12laA/WztnQForAO5JoSEzAGz/fGJN11UIrRhHRR6cfU5rIx7NQh4aH/nNCrPxBg4DA403dbMbri5ej/Zu06i6LPcXdi6tCVr3sOKWYc9vA6Gb5uRijUIwRWzt5TJYwP7c5mXqBvo14v9XCDS7j+fM6uXS7P1i/XidyBf5g/nDNSh5WRdhJgjjbCrMDRqOY0FIv9QYyL9QTnYjc/Dp1H11J+A0AmV38dsiPLYRsy6vPMB9G7CcrRkpy4rmQ0eLB+ygCie4D4h0UvwjNwQUYZ6zIHJ25cYt/YcYUTd2dBw9wLTSaYHMcdvAM6F2eBRpJT/J7ANtgE4os1jBtXjA7KEvfCezB23PPbhqjxt4bTQmTHzRlMHl8fTMDDArRv+7/bD5D1VcX0T2ZIErG42DDvGJPflT+6YGcFvRtZhh8dCnC3Gtxf7EiLz2jG25Hynq/0GtoYfsn+2jiLiV14RLgSkHXYb1aO8rj6nx+rUkpxFCM6oKRhcE5T73m3Y/xPVUixErDfva2DDiAOVf4ycbJkZI8ZUnBGDrGYN7j0J0qfSXqnqHw+AnsSlTIfKxGWmbU2jPGm0y2gf5WGVET0ZD46wfjn8DNa7yOCrizIOtSNZNsiC8LE3G3t3jeftMP1Ncg4zN1swU1IMgdteFsrntp/FNmZvT1HtAeCg6ZpBiUTcMUeHrO2guR7S4QkNfEZ3w2OJEqm2uJAIz+NMjpsYSTrzIBpPgGu91JQsQ1beGWVw4MdWGQOFWdYfp8KtT4ZHeW8wjbMuoZK8BrFaVoZDte9ih/p5xakd2J4Aqe6RzcgT97KIsjBAtQ4D1MpjHMUJeZZ5MafRXWJr07orbiKS8Bd31grjShfi8P8JJ3Txa9uHh4c6E81G0EpBj7ei2PHwKy6OxWmYvBWMB3MyQsbNy5O+mmhE6gZEXrlvIGT/FNrIpgMnaHzCILrbUkf7Xj0nU0nZb/5b5V2lbwYmSFmxOG/4AuYL4cKRcSN1IrTq4Ry5/h76AP1uvX7UJANhQT1EDIGLvDrQLMWjXuSo2KOgG7pDC195RvF/Ot7DNul7GNltev+tUCs6jHjOaS+EBDDTOxH7l53giQG5WBtRvbpf7eQ/EjJqJJZAhaNuZu3aALFo+PutkFqzadFocLcoUHlBAL+lXpnxcj3qvJiglIIJKx8+LC0SG4Ua+7HCsGP7QyTkeSk9X9YhBHZPyB6vb7sqzk1ZbeAqT7ce9OBitVL6B7c1NHhEz5/CxLG0OnALQhZARz3A0Ag92gYFNmnrl6NmK4AVUYBiJYrGVFx1Kc4My1ThjrYbK714Y1y8Kgd4sQLeLIsEeOJMMexPjbDJhsBh5q+r0bf9x1tj7tx+uK93hhapRrmFr3ys4OrNvqUP1YM336s1L4rzerBZqTaBhRLo/SQ8zZsF+dmi/rGsBHPBaIhMNmJgy9lAHR1Juc6hebCAe119LcAZul8TvYMYGEGZ+D344wsFqdDA3ptsNHIgEHI5nL+uYWQlaeOgMxA/42LvqF77hKuWlwLG0rmxKJH5X7nEfWNmaIZK2DpmqYVCAJskEPoTr8zdSOUsCeIDq80nS/ioGkjVfxTzs33+Yh7s8KV+0fUsng8GC6Ii2tdF557muRiRX0FODx7P/12xEbvux9KOhSH5yVwqVefQuTeMuxkyynbY3X/CoPDKhLYnRTQdFQTtr+wZ4DGK8IdauZeLP/oBcVQQ7lw7g69FDWl09C3w0XRey2nf8SPkE5xL5qKB3a91BA57zi7aQdu/9zZB/F13eTJ/5GN+0HNdgQLgtS8x55gUdtEM80vtr/vbO5B6LFgLXSPYsg4l/MSjzUubyPDypgPUxgK+stvV4bP1FTBVh+1Mhj9/7ATZiKpzfTi59YgBgecmAJ7DLLj91+gSoQk0VfYGV5S04VIDrrKvfFLvvs03XEshX91+iGEbxq9Ba5IkP6qkBi+Io6ArbTdMkMtkvfYzpsS+DmUnWbWy9DLgs8a/8eQWd4AkPzzepeCVR0mZD/1mmxihA4ViiDL4mbKO+eiMPdsww+P9lhQwcrZ4nsOmQCGEV3UbIl1FWsxqRjNEzGBp518aTLEBWYwJs+p3Sd5oTzWMb6jZOUbpQWNC95oP5eRI98pHNNSaS1uF7b3TZrwylQaMfT5dfTeoP3vaBBPC6iODGalyQf0wYmwVmbb7YcD/bP+bgsOtzPVb4RJO2PeRqjSgVkWhQttPGBBOlxaZPmeMTDa0KkngjaE/8E5Jq9qbPpo2v1OtEh2CcN1GsVr0DvZu5Wbl7AZUmfRBpzz6WpO/EGdLu4HCWG1YJOh1i+cRzX2xSK8F8D0qcbHcSJ84Iv0WcE0LjPjEqUCUjULGSNpdac8jbtViYo4FlEL3CreedboNuhKYsRYXV/8Rz38yRCQxYMI+hUwR4sL4HioPXpYP/nrPQurNfZry6DrmLt0AGely4Fioj5MDOHssac3l17JGE0668dsFVoFV3YSjUYaCKAtXFuaUW/Zw+z2AwftF2Tbezkrf9uCNBDryuvI3M6xEyw3whzZmX7RkDWJT5i9U1h2ISncumSPEWqCXqFWJ+WqrLTGL+2y2nFpZLN3Rzds9hTiJ0KD4pUqDOMgFpMjSJKJFN20ZsbzpIR1rDcNWu22YRHs+uzFfF/JdHLyCHL9A26kBa61M5xq0Hv4BBlxiushnXbrV+Yjp+p0z5CH3Ha/iWVxE7LbfQQpNPd7x/Ht0ZVdLXgLfUjIin3GG2dq1M926tX7VT2wruEfVProQiY+PisO8ax5PmHmaNs7KZULvG+3ZhPVB5+bIDd9fjLbNQ/GLIuhxnEiBmW0p22QdkxDxtN714DWZL4cyXRpfn9Y6glmfltmQ8e2UNV2x4VYTEp1Arv6GpKcXdS6s6ymqgPlPpxU6fV3i6SOgWcq3ILq1YM8/GKrPU4zfquEZQQ3S3BL7TstYKmQ1yzaIM0tl9aSWa+hZi0xdVEwBHxeXlhN0OOCCiyk9IlSYShMpCL2NBfLL1oax+zFZ2feLsNiPjFF4+u3n7GW1VnNKFcpVXCzIKPp523qDmENLPox8TgZX6ILnDqj3T0/JIgUFEQJyCb590o737xxWe+IFznqRqP6oXvPSXLN3ai59OX4F9tt6RubOqTiqudxd6ZilIaGOyVR5afAM0GRtj38IgTGgo7P0bZ26AAcjwZRsn9ox4RSJW17eYeEiCOsA2BBQfUiYjmfW/YFNSVCs67O5mVtZSfFnlAKjKTwdvHTvn428MDleGHrFziCOUhZ0lr0K2Brw3PIT11vM68gIFau4vs0wLo9KXuupJdxcFXhP1ywXhuM9tCR8XwtkWMdz4T7DJgNK3ite9d4GMiEyH3+U/jTjswuDsmr+zEZcUdTAjkQ1ubcbb1lCMgbf3JHI4SY7W37nZUOgK0LGPZqVwYxf/P/0wxjvx3EtnFqt576JztmOqdyWHRxsnjl82XyEPgx1wfsBI6vS7L3gzLoB90LC6g99sXsXc9QUCPuthkd6fdyFgYj7Hw+qkCFl4Tc46GIxw9XAOYbfSm6qUeztV/R6F0aYI6Ty7Ka+2tg68S6Dbd8KZvZXdLe6mY7zV2ZklcpE7rqWbVh2or7TfsOmJNQMz+SsX0UPa1RQYCPlINu7Gs21qOayYCWWukvJheIS0eX1HZnK8SuFgGgviO6vDNgKkepGuuLweJ7dbiS6fsVcCklh8Obp/f+0elWwzEnBTwaL7AaqIYTZ6IWYJf0fR4ypDbbLnTie9tWeTpKTL7AAY1G/5OmveoqMhWD7QPLHavl9lhvfAj237OA9MWDv5Ow53BFkyLrLgYnwTIMViSvp3BueVYqrS+C+mSnySPMAr1Rrf7ErxcyjlivP84XRpehJCH869LNpyQ9EjRGjRL912s+y0yEE1H+noN02yqaZ7W3K+S6aES6PSORaBZLlfqu++jmFffqjLmWB4tVeZkrEhGgFk7BmgOMXn3k715euW7QmNr9tiuDvAbabe1aj+ojq1l4WtsJRZA5EEYepZVIJfZe6XiWhvXhd0eWIr3+gFsyrzbCUAelcaVGgaxjtowlls00ieE1OFy6jpJ7cGJ55gfyIrcF3R0NKy1gkUbKl2/d1pxN8QwQG164NFB5CXh9qckoVc4eqFJBBRMgvn0Qnd0NJDZszD/kHVSI+RItMbfYHrChiphCrgFiUQr2QmloBSM5TvCz3AeJw/mnukUzAgEP22+GvpHnbRLi3On+ciXtPG1urEc+6Pzo7KhzpcWWsHqr009clfH0fPJB3xadb3pG8Gtov01yZgxOHlE5ugo0bgtXEhp0zW8+iHQVUq/1rtCbnWNNbTPUqNao9iaAc9ZAaQON3AYbLJrSR8uOfxF6J7EcmQxq/uQfuSA4W87CZqbn5WarTdPJb+zcTfqBgYKabi8kTs9UFG9dCB+yVwAjjIZb4moOXqJOqG8/e+MJumm6o7Td2qHqLmRkIKX5V5Lq5k0dTO2OwuFsDevXZo48XPJhgAaBj34zLoterDT4eiyu+4E70YXixmRGBiUwcJdjHvJ4CJU928etlngmhOfAF88rK2OVJTGyV1iyNLagTke7EXJiWZKpjCFXI+Vy6djAt1Hzcm6L0o7ooivr6VWYtq/We+JhCbfLgkCywX7N6VuC2c1F1TqYFpKO97BMDvfQhGop4njTekrdpcruN67I82KS5fFw0a/mopaOitZrd3cYJknI8tWqPL5zi6YSL2w33YxKyVoRt+HSvAiMhBncUvP94l3o6SLE6fmOIG3rtOUEjFJilufShazQPfBRkK2tnBEf2ZGzEsulJefZSILZyAdckeyIaw/QuugIoyO1g1qDdJt6Qk+MWCHPuPdyJkpEbZdZg9dbTYtYUYMTPDzFMD5SznIoUgWWg6ml0JgkpajdxXUVLVjXqX16iFqt5Yx0KqFH6+fUR8laRYqkZNBvcv6I8IeDZ+PCorqAQ4nRjTUy28b2PQE/oflboAci+k8KzofDEK91VfjNYrK4htGDp3vFdsyXjmN4ggMfbADVSN8VFyw+Z8MokB8BT4B8W9PAUzBkb/HwPZ2/IyZ5RvGwfG/9TjJTXj80OqmBSzNz/zFnTkxBmhpk68LSQ0eYTnSn2S3Vr76WBXRryXJxCu5MRKAWdm+ZBVtM9CGIyd1v8noU9GGvpLmaFtK3UgpocTnHZXjKDR60AH03S39VvoPtMLtRUEfZW6Lsdfb5eSogsf5LZl7XtkhhfIPz4SxcWRPScTZO2v+0gau6GAjbi2Yb9YRWzSVeKqNlPP2UOo19de/b5LPQTi4rZ2ct3IBzR0SM6IoBJuob1JmqnY+UWeDViF9KsOytp57ToRaSmlZLhqDPU01moVmgrCfD4ZhvDmEIiT21kcOZWT+HNHkD53CaHeT5nrOT0vBHxhUpJlHwo3JGJpmL/o+jwL/GeqbS2hKe+SEmM0mutb2uq1wtgWPJXY9nr9oEJmPxHnqQ5jk9ngWPW22gQo7nExoUcxd40DlkH1tJT5j2Hz5P0ysUB7D5ICmvAoEh4jqgDAaHoGvyObk1JXEDJr+Xr9qGgdSADQttqRdqfoJatQfv8s42OF+wUlRleppTb3wowPQwDQtDgd4XIn3WGSqihKXeNdtHHARqfp5hvOLfBzl15988Yb0l8lqpV246F64KxYLKDT6Idh1Cfqfn7iLPcYcHrzaYLD66y2M1lMVWoa95xS67yCjbNGiNkWaPxZD7l3c7q0XtGPhTGH05NMcOV9/Va2H9PArmnz1tqAL2EDYnVDDyx5fmEp8TBrnbny68rF4ukjNh9EyWrY9Ax0kcwfMdLdCsAGlvmMCRwms+VuLALPKXQayTDkXMeUTHJz2cQXytLxT0E0zc6cM0VT4nFMtpLBYvKxKcs3X2pVWxBu2W5VgF3Vm748a07IdkgDHbMCWfAJ+1RVvb971CuFalAw/pHxHfr1mrytrs9By1BYKKofdfwf/eVK7VAvQCd51hvHbhCqRfv6q1d7cXE+SyfQhVhRK5Nu8cl9dFy3ZlYOOfPZvc0JZa9JK3SFdt/y71qS+1O27SMYkFX+Bgz33FWBB3qi+OxhR/6jRIPz1wuvmbDVsnhBp1VuNPpiVm1zExqbgbL0yya4nxT82/vu2lUJ2Qx7N9DbnFzeoX5Ex574DvXO+/ZAF99cH5sSbMlgbvdYtMz6BPI0IMkComonHz2WyM4KzMd8yAlxT9DEwH1P7z/ZdHrbuSdKOGSdg3hc3Ddzcc5Qj7jgBCvq5WxbydM2L5v34B8U6M82Hu7X6vkQToWvbOloes9V9Cdp8h9vP8gm2LZrObQFPVnqOA2TePl7oE34Pwu0BoV5701VFon4s1qALsNwDKS288F2YPxWv6UgO8cUMVydRUgmdZlFvtteozHuQLnjttqpvN59P9TE5uKczm62xdRJrayhH+X5r44MSB+9sKW1IOFxFAcxeRrOz2CeYsRuL8ZgU5ppAsoNGVEgaOUad+fxa2ld7smoXYiRA6zAenCqZkx6sRsx8EzLs+KIGaGek3w3K0SS2D3/abG11kOMQHU7nlWlalAgrjp7ty8Pd+G+3fGRFcaZbCYJs9NK8IzqCO1ewS/HtuFDl7S3K34L4jLT5wBwbJ/VEtJsty4CjX0iXPw57Dk3XdN9fXwNxcWrUMWds2lRFOPVJw/67EosIcJzJdlLChv73wGSGMC8E6QMj8GA7zhuU/wplA5W0l78ztAHDZ6T9QotYV3y2xLjtJtEGPbvV1R7/Q1a9ILe6WXSJvfv55tISc7XAI/JiR3iHcWbR6ETqa6QdIUTPQ1BI8BZ7cxppFR1bcKAUOqEY695L2z+Ex0MVtiirq+yd0QXbCd2zEKIqaLroi60kpj8x1o+dEWh4VptWdSmymQoewT26RXWjMIgFq7Rx8CK0ax/irwZyUDidk9ccRR5A+QdZJgLjOsJgf4X6ojKfPEFSA9Iaro9Drlb14DmpHA6ebiLBmbUjimPoiPPxvO6czLW0FBcETAsjSSHq8vbdjvUceVjPTvY0T40UA8LG7zhoRvjc/nzjgnUsPq3mUjuEZkkjyZd+ZQK6kmK6VhR1RNrdvfISYeu0yNYFoM9h5M8WzpvJfD5UPvZnFM7+e8ejUm9HZ+FkHUq/AgjEMCdpKT9NusM7AckwYIi79lrxgGDRhabeM54zRwL4mqmMim/jCp1GbSnA7NFIsXiOxOA4THA+2R4UhIzI4xfXruAFvNk+detOxUNO/myClsIZZmNI8ZLYW2awBbEUt8ac5HzYcVpTjrxxysbl3En2tYf+JLcvtxnViIz+H/gYuDaNCCQu1t/AVXRpv+hxFY3bShp69AezKyjBx0HHo9yklvGlB12nMw8+rx1zgiDKtLkWGukP///jQp+14jQCdTd/NhudfbT3Q6xV4pnpZSq8P6nmMkPXepkPgF2fvYWhAb65bA82WCVcxqYab9w1OMARu3OmysBgEwNQbvt//gBW3etY3k6fpoSWtZFvpXbIRMjgIJhq8LErQHPO7ofhBy6Lt3tIy04mkvF1/2KJBC1Ri0OeccK9BjXIw9nkR6pRnzb30/0xhhQ/krGSPSZ9pBvHVbfN3aaJmb/xH8bAawpBWrm98cT1GPFzagRPPFaWU8qC/H3/vqbQkZAMG7htyJlUFKEX8XYIcD/tpDBuHVFgdSIe3aqqoKASaGPxGYB8Vz5rBM419bFb+GTjrhrdFNQZyZH6YNA4xWZSCmDtR/dRidAQEIsovr784bv+yfddsIh2YXRWR/5b/DGEZwn0sVI0wLJW8Hb0UTOjd4BKr7wL0C2up+AEF5EX5Ah4g59ToxkpbomXC25EjLmgZZ2+VOehIC8F1Tf6YfAI+CqgZef0F6YKAdagDWj/JHmoBreqjAhN2Sg9pcXPYj0OSsCCoXVp9xUReCNfPz6/682e+uMv7ZCEz7rFip780m8P1TW8YTZ8wpb+xGkZNDcW0KSkww37h3oBiYWptafR3Is9Vi9gfgmAki5gsR2wgDOZ6jUyWBC+2rVoyMko6W4I9F6mbWxR/SLdsrkVFmLK7Dv8SF3J2OsUd+KfTN3j9uIFq8R94RwO/IS4xKEE0X4sxHzy+rezxFULAy5orV3GQW6JUgrnUNqs45+EIQPErMxYH928baVIQ+lt84+RzqeXa873D/bpr6596bc0PQtXRChBc/FbDhiuOafYvZ2IsIosC4A0TqU9+Xc/8tprGe8s//Feo7ohb2sY/TX4AnM5qR9yWyEJ28fyxyncmLLdQSmWzZasSBjHeOZUQEdfDwWgSEmcPlAZp30tXUs1f8dzOhqInGtEnlYnrYnVprMW+PFnov+lfakkXwrGviveGWT59krWbrXCwok/i8QpJSd5xUsGfBOY+oK6hAbACSqp2tOpBp1E8udfkESr3H0i2CBXAHsMGdxBEUqCMsiE9Dz8mKVzVVR+jbxkzKx6DuZNzjhNP4KkCTyMQGf2BsTzqTlz599qP7BSs4Porrlio+oaMUefGnsLbwPffSKmG46hm8XpB/CKoUNYxcwU3bnr969CSsqNsn3V9PxsrttP4EifjRJU45Z3nvXtLW5bDPU9kdQGRO3eFQiyHM6FzNEc2k2vFZoQjk3us2k6hpcP/qFfkD1Pf0v/YnCKqGUayzVQJ1D0FjwhAKPFBsMfiAq2Spmt9fRfC0bk1iJx3SY5qcYuX8RKVZ8tzui9yw8a4mzg4gcfQqJKt4YiFvjpYVtTaC+9xnhLUBXvHyU4naSG2QV3mooHPzk+wWfKYwon2H70CeaDOlvwj+77YOzV/BcKtezCcPDl7OM1r+amQmGRjAAX3jJX9st6ws5VZ7AZOXoWZdzW8cbqFbZ5sDS5zYNGKGdqf0x6ytWIWYviLoe4pw0t8V3+9TMVPIQiQqPyZfZB1/R+XHm5RvjojHB1xRzf0QKGxKMF/wok4tqRtMccxaYU4ff2OW+83iVwz+E+pBtBuPKLQouOQ+0XNkYVUT8onw7AmMtM/eEY74P4C/lm/MG07tycTfo1GHaIJRZPSQUcE5nQkrEAIH80cHwo+r1kN4FPgNarAwcEL0a0qP9BQGSwKk66OO7+fy7IzzDld6uXbWUuF/uyJi+ipjsFiZb42xEHEAS5/pI5WIJZZl4OXNZeMGiY6QE5xBrOxZ+VOAyhYEG9N5Ko5u5XtdO2YFM5l2iwhE9HFrJcT10JuT1/JwgOu5aao5CvNB3801diCe6I6glYNGREqNMwk/wpieCb4+L9WzltlGDmLY+iMY2sNi0pkH5TAglUV9IbHKtkhOo9hQ0glY3bHq7/UO3/LXt1WhZ7RJyHq6Gzz2No/+X1a2tlDoiheBBD7/CpLM6ZhLm+JgcpRyL3xhh6GAEi//nar4fULW3AiPdI5tF2iQd+K+Isdv22h6cACit+G4H8dpUiipDzPo+RIfGl9zs4JJCuqpYhYIhTDW1HnqU2wwO07U6lSSsmiHOQVeUkXX92cVqv9mfCExGMFsOrlyzvborY8TlL0IV12NjBF6X4HMBWsSy6NoEo2utA3xwjGVrQrR3NbK8Y+wG0Ikn8KdXMMsM2E2k7d/JOIpZlb8HiMkt8MREWlml74SC3KHYyVdW206XC/2vLVBhAjZx4EyJG/V99m3pv9vOOLKaJFCUPwL2AEU3rwlpAwQI5vHscLV65nQpnoFOUZFTwWdlS5pIBsPWL6ey2YELXReQdE8BRK+AlfU9C7qsSzMakZ9WlnykEXE7A3SJedpi2KzJGMYWPJE4HM5IBBAFccuJwL38x9QpVFiqCs3I30fpxLYrUzpLlnXXYYNlF6ghsrcG+jIovyKhY5Km/GaU3ZU5ntat+REbv2k8aRBGd3dXW0iFixJ0yh8PF2WWrgYH/3HsEzk5MD6VVqXDXrLkbncHOX9c8XFLTwifg8t/Qmr76PiKnbmVZT3IZ7vHQa+WexZXD8yBjYyHEThw+ogI9oOBb7BRtOsz07rwPfDyL/17cBvVmBguUcLdAx/Vn5eGMjos4YU5YaNcclRdWZ+zDmoJahye7hPKbGe10JN6YPJGVWVvBrp3NVIhne+qAuZIJaXG/EXThBCMCDest2KCKmtXotMS1btD/SjztBZfyagaTb7jRbLEzkArfYUODh8XZRPgroxmLxitRGq5kTbIlI9uR7Y/SsPXGEB0Jp7hVCuLOymRSsrrJ+8LVY5P06PS0iBS/bwej1ozPci9LIwWZVZfflsfdIXPLMQ1CUNYGW1VYwFYtJRSEt3xop+6VmZBYVdfoPo4YNH/yJgaR89X93kZQLLL7ATro6APb2UBSGv1Q0bgz8vyEk6VKuQP0Gc71hGOFm8NEkCXkBfDITJOmWw3ZQ8JSkAkn+TEWwqh2NaHfUBjWP/pwwZEFJSTcvkD0PPuWsza1Ah33Mjh9ELwDLMdmWc/zqCC8gZm2NGn3JHL0Ul7tlLqbeMtxPOUyDagf+37FmRGtbEqIfe58c5TmqZLb5ch57+9xuaKyKMhLd5hZZCpHoE+vvBNHkO7dpBrw6e9UqL9RxDWQNAol8iVZVmZFUuyzBgougFVFcU6YogDvXDJDL18A/YoKoBuf0IUysQilNXBhO6oCik9tcaPN+lzvck6rO5SXUf36LwgvFFijq+0LzOrIkgsdG1gT7WBQMW3qpEkW3lE90xDOYPTx9/+QCgLRJHQM5pSZh5tmkpaTDIN/QKsHJEKN1Gza6ixeW3Ya82A05OOmnAQD8l/l5BmCl5F1jaK38tg3wqvwi0EuDtTwWxhE01iLe8Q4oNJFx1ans2EaJGQbUN/mN38PFR8dtIFAl/XgvEKck6wjaMW+pRqhAzEbVx7w8lgOPGZ6VyU8rsbaGdxHSIcXyL9/b3+mQK3Vj8XTHg1yzMdQaSm5Yn+ZANyOt5hdvhu8GT++z/ZBfbn2HjSntI33FRvbyvwBa739eVtcO/HVg6VWZFe7IYoYJuvQGqnK7uC2NYRnJiPJ7jB4f+H7sLRXUczUsDn0z4h8bOAyEiXPJFVvDVoWAtmw6IelZb/XVpq3uhInFS40Msm9X/i+9DMSH1gM3Ezwgk8O9Ism5RiHC4/k7hH/hJWhUSWTpzD9ZBP3PhU7gwVl0a/u7SNZjX+4SeY3aybm2HyAYbaSlycsXBtk5tm7KyL76RL4OHHl9/cawQYnuy7+tghAynX6O3/JvDbUwz3fsTpFv2V61HKi15S07TqsSxlOThdfDmLhCphnQfoUu81kaBOb4LL4mZkuYDFMq8ZkejNi5LwvH+XwiQiivNo+7f0IHtI97K9SsGCpF9OrAR9RDwT6ZFNFJRILlsZdu030Cpl2FSM2h6ucoB7pu6x5OQaYmc2layRDULY3LpOXI5VCiXqm7qTxfY8VAxsn/XnIt/KDBNNvwlQMU/U8FgOJmlvezr+0VukdkeyYpMZ6MQYYtY+SftJCFEQCCFZwl2dFA958YV2QkiMCBjV4LvWtQnckuVphrH6/QiLgdA7SDBgXVom3h2d7V92FLEabt7RQp5IW8Mwkou+aaKPnu3+jXk6eaHgJMOShnMw8U1vZFy3KAy1teItCnEMLglEaAgWwe6cjYCl85mB80Pg5YmcTqS14WOKDA+lmz1P3XGZgMCEKS6Ge2QRn2TMRZxQBQ1iZgu/5h5D9Bo4+lsjDDg+NxpUQFYd/9xqRAHXdPXkBoryJYEp/U9oRlqfnkKV3AFSP3E9lblMVBvJu7BwM/15gLkuq+hNVXZGLahsAI4W9eZSWoxfqUZ2jxSZb6DgOcz7H2t+Mio7nuoTWiNPa+5r437eGtB+T6wJFKXh1IT+RWEKLCYAJ6WjrgTCrw8ii4jxgvVKfoh/MZp+jMnsJghHcqxKE9cvW5x1hsjAmeW9HQZrEWijHsTtktNypRztq66jXPSL3Ef1C4GG3+Ix346lkr8HPpHPVYQ2CKHiulC+q6y6KO/ysSmYivQ7d1QWM6wXjtrBNmyQMgJqnc4W4MUDe/NuXjFyPzo1h+MYVZJVaBXv5DsVZLzfuYHDNgLD2buGUvwVuzM+l0g5XvSoJKWPvSGD2OuMpbKDGRRGTTjpIYHVWdd6ZujjTAti9VMBKgZHHyZeXFIw0ib9Cp9OLkbcLwQhEzM1yavN/hw0MXcSYXUEZz69jda40cWlv0uZ6qy6oNtYFgrZIx2WBNJLml4WWPXx+SVMs6fOC5kV3q1B4F7i+gu9CeYPdtedlgyPda/WqzCyhUXYAB/BeELfeUc46FKukak6QyTx1Bjy8b2sVJmDMAayE3f/tdFW2OK630LUYExooPIha05RqGP0Bp1I9ZP0KnRUr5OIvx8x6NGJAP0Ouf/TU6KnfhbJ9X+kdwmEy5rm95D8Jx6cZZfRB+Wz5OOLP1j86qyDnHisKgRTPh31Pb0KOX3PRAkDng2ZrlJzIFAaunXiOgU6y3Mr9NV9Zsr7OfueiTN49ppFpbigbdryQ8SoBcnv+drL0gLtlBteENZj8kJXZaU8zz4Lh5xcYjRTdfMY9oNAu5nnr6YeLWoVuawAmbM7TapKeWkGdWsf6CY+V3nCFJWHNIr4Gov45Tu5o+57ULhzfSI9DKIwnswJ3praxLryuhWJ46v0gDBD349ErKPjBO02xkqfab8NF2YZLOcPopUdP1t6J9WKirRonVnpvllqM8i5tu3V2+4ZnLeAdL2WMnU++YMZ/4X689FnuUoxjk6CBk/pvFwFXfSg86UlfhHy+vUxc/0G1+hLr2DzklMNbs9sbfew/5OOIXYpyG1Tq1X0bwFH3Q89CHo9sfJP+61/zMkIBthK4WXvZb8SqAvcNLcoVU/pJIjyaoeD0n0QYpMIdlpR9nadExQb7fxxt2CZJYt8KxouJHF7I48KvWbCVSD3z0p/Bl1EVu3RaUvPKWanUY4+OqgS19jiljqX99qLi2mpnKaVBU33zaSes6T6sowrsuykN8jfnngH6GeNdCc9rxVpnuFw2NYSXANlWCjt+qt7YyKKz+0Wfv0d5961CnEHOpt5Uuvi5pvfYuBMWlFftPv/N8qi0N9hLtgxbqTvUkX2ub1OJb9UA1mgU9Gw28LDBmm/XRcD1pnUaWsk0HxE2JCkEak+q37bDNkmp9SF7CDIHhwWr1VNVyQHqrZsMwULpwEwKYsKn8MG8IY5nfVNewQRdB/ImbdqjCJlrYFPuDuhHhQdun8ZGMKUgCQyC5WSFnCdrLmMPFLh1sL24AWOI+/TobNVzeEhTfZj92i5eDxNVBGqCcDwOPDWHS4sjZGF+C6FBVLHMM14YlNNsbcMx2lUGX44f8/mE4OBQZ6l2fIQqEn5tv1BAzXh9jruNMmW6K7ww731+263Y4iGncATkrnm9xtpSRWoHFu7m/ifWKQfF8unakKtsuukJHl4bYf6d1gJARw5l17A/fkFTlh/iwViJ7BpLP6aEHFicyPiaxlwOzaWCtPPvOhGbJ0P9BOua/nSppMjxYO1VTcXrHqkPam7o4c4SvGWXy9hBGWVWfcS1mHW04pRi6emZcGdWDIfTZejD7ISbLH3MNeuPy1siWFH+QhEWOkzVVXLWDVxrrDZlH+NNCtZAnqNbYlMFA6IcZRiIxrtGS97meWbEinLh2sozVUozbPwbsuTtb7xfrdWgO1Vx+H+7TARinjBsHSY11WWQva5awBAu17o7cH/B8LRctofQtBxZtoak3sFuSKtIGoRWZyPLx2jubexgCfI9wrwdrBU8Mo6pWxMZczwCNi0R1QWcqGeIKkCsTQTHv8WVXGmnvZjn/7EFTMxxiB+Iunc7GhcVoUQWPLseY/M2pl7fjTH9qLk/NT1FXK0CAAMfqqwBQWkmWGrVCZD1diTmCZ726hQzo+j42Pin/Cg8gQAe0knvKz2WQTRwu0/pKg77TmDnG2aa4s7Wu7Z8TVZ5E0rUG7UJXIEbtOg2oQ3SyL1zn0ZTdYuv4D8axcq4I8YvhNzv7QxWc4B5XeR+D/L4qUtyacXzj1vDho10rH9ekcepR0ZWcxwtVy7xUwIahS/7xyQqUZtKLK8J0hKXsQp80p+O2EbEhD/BWz9O/u9q5z4tp73QdJIzbJ/eqL3u/Z183hm/CdfyeSoXLLHpJWvlui0NIFu4DO5pVK0JeAlG3cv54f30UvQDeNPWOICY1wmsHglhzhLtE62rN+iSMCEp3d4BS+VhyYUNFkBsRH18rSxkHFVblFcdbcKTOMmxswx9gyR597Thyk5kAHyRSfuU+gAj8YhqS8eUahrBkJ1UVSk0CKNQ4YurzXroJRnzMFvr7xoBf8GidqMe8VHHilh65SYgXCb/F5JhiNJBELUeEYipmy5nUW+HmPuC+2fIlwKL49+f8izxrv8TsfFxNetF6X8tyyxs0QISxP6nB9dqq42GyfnkG79IoyfCkLOLFs2NfN1K3CnbD5lcScoROfzVtnomufryZGy4vljAA1tL8oqriI/KoyoFAdrQgr7ubIlLeuKbcGRAR3UOgHdtUG29NJrvYSQVyDLVyE42McCVKhiRaX18TWox226pBzzgcpraNM02vkNpUqWAx0th9EJGrAM7ixqoRm5o5MrRhh/PrrzTisQA5YPukKosYyPuUdsVe7fE3MXbWkNrPxmInyM4zwV/TE6ko+4D6fA3IGeKj8y7ahdlBWvu35sVuZJk+q8/8jIN4JxwxK5PNg8KeBUfyVtdDvyanpbKIYFoxxnOawC/81UFYYkPUxRRRVL0W1/a+LyBuhIuTthOm4lfu5xdy5Um4ho7qkW9qqgLA5+2Ly2Wdwiq99mixKUlg0ECNwxV6iF23zbtrrypfuh6LmHx+xU+4ko51ZuA7sRgrycgnUpbZ9MGDMDGnD8ZnaxD9p2LxJW5piql+8SCcU/WqPabvX9NSK1bzPFPqQcfN/IT9zwKm1XNfGiLUzJ1XdZpo3LrRx0L2FfA94lkFaUBc6cR0Oa4OBnSWxgMJpnFw9fBriLGDI4LC4itSrJtAfXDGwkIvHaeMeTKza52e1l+NOpFJfT4tpu9cvtVM53NYSWKKYoZkDjbrDYtbgQs/7EYL97iuOekqXD3VDkMk0HYQZHQ5NrPkPTeYxSuk99a4bk9lKHmbD/lHo4rvPqhs2pLFlGS3FFwXZOoNeFHuYEu3cuHBRMr0bAL70EpCTjxM23NNZ+iL6xEIrzKb9ctHPS+/EIUTwumZEiGlt/GxPmTGId6B/puZriciGJJWoG5Dew/OVCZmr7V8MUQBJC82bMkUvitKb58SNloFOLLe92e0UWObGvZAw10LdzvodohHPIGFcQPhulBYArcvohzj+8cSEiUF7PPvse6CTQgsxb7t9ovzjNdSvOwdqveQtEc7K82iheDN/Zo8qN2MzscSUwMdJ48gvbmjUMXEG5VOtFXRem9v4/v3ePXlW1xJUTMuMA3DW3PcwHOIffftIJKHua3HLmPSB3lKg1VvvoyJd6F4xPdr+YoegLXWS2Kr2LOWB0xa8BAZA2b43nzjRruu1RC58MwOGd/eaG+FDZWIYOgER6JTgh/yQj7kGITTEmKiF9x7/bjGVhMivbjSsBUtGnsJTKUIg8vgjixDwGsoXFb82OHdCiKoECKHLsctrGvcq7/NluNdbes9pwiXY/KZZPIreMD1kPGGGwRRXABgSf+syOo32iOtTsH1ILtv+twT1HwizL4zdZ5qOs8w4y4/qWzUv+pvJc4J5vl0X9iYWiEV8JAvBKyMhDhKAeME+fGQOIsLA3kAmHbtzn0OZgj7wt9/OO1ti3J2bPNC94yD5AnouKDhbj54qG9w3rnCF95Y6JfXQa870HtGN82OPU215KfGGUB515nA+NoZrh2pDkxvCr2bYawhLtwyIlYZNVnxX6ltTUX1nu8pgYMUgu8EA9VJepTR5sBwItNuwkNWzdXzLXi+tcXb/j3bNLN9lwOOPcwx47NgbvSrK2QqZOwfZhuqU5QNOfR2Y6+DoY+hmYI9bHWVIDi0kkrgarTNsC/ZaiUutWnGpgewH/VYOCkiNo/0anPQL2NXz7bSff5ulvMqFmsjxrQyYT3vx43Ck+N1RJTXwP9pam340uaLYg+yvgANX+bWbWvBDHLhc6irGNePuE9S6n6MiwNdxTwutQsn+hu5l+RQvPTt9eRtOwjAhVuNO+GK6GkVjL7tqpYWCVpq9XnlzVTmOOquxwg5yJfJycDHyHzTiqOZ/JcRDHO4jqYkHJBzypYZ/MfFyEOlW2KMv3tzKm0j3JhdiFApILNJ/+18YVK8EVREQ247cZiWgDTATmSxmkTwHqh+xBSM/A1Qa/YbUUTmEwjPlKT8wtd2kBY41I1Iqqyr0psSNPx5E6hHTAbFyqH+r0Nui4VIByUI0pKuIkoWSuDFIvREByU9CKT60QlNztn/KDxMUWdBoxau3Bn4kaofSWyq/oodnK20UVGtT6m7/BoVKkLuVAyy9vCCIoApZTQLqT/tzGQjIcaC2LZ/JDbATuVYWogJDUqifyrLmh6oVAw0+j0SezVGzdKBEgPxXn/qH0wc5HGM28o2bZVcqiwzkm0UXVsD8Fl7kwl9wKgRYTFPiyj1xdo8P4Kfx6o6PTqO5lPM2vKNPJekMhibCnXtWARI6n0JO9sXkUrE5U3CM9TclBiVAef5hIvLPtBuYOfR3GcXKgDjCcyALa/p7k2CNgEV9z2d49vlZFjWL3oCV2kRc9IrWLdSSkjpGUgDyDPwwCpKfmZnVM44mU3O8HKV1IsUMhYZHZuJe0u1+QILv5G6Fzl84LpfwAVTpDQBmEugae+u907x4sA72fagkPSdKWtELt7XcISHO8du2mzXtyNhRa5mi3QGuzwT/F7M4etcAitggnDIoOV2UJfrxI5mWQKJGW1WEM29nSZoxtZf5eL4FGOBMINq+/2uWzaoRPkMDy8X2oIQ2c6ZKIYdPKOj6UGSyR7ezNiA55lxgk11J12TZDIzcCMOxi6IUQECnfgDwd/Mr2au7sKWTheckdo4m3cE3YqjNLyU0POycgE7nZ27vjL9mm9sWor+OetXn0IyVmcYVptOFlKJTinW1kuG3HwOu3sBfH/WBlbCcJF8piViTJgpKgNfgSk5V0Thdck2wLTUL9XqJ3YrkRIGGSBt/iZ44WrrYqwqqJBzIU+ku3jEY0euGAHymZ3IihVSBBzvSgPx+wo7TVXZUGYN4oewbduhMqTSRHHEnB1WpGWZbwEtt+hq8J3sPt2NZ92XD3i4+FgXnOdZgi2EL+I91hCmtu/01AUmp4UEIFAk2rvHUv+9EQqJpk8mup+FK8BflgcOCJksU3bd8guc64D1C2DJZF6mpbKNQD/M6hdKVNqPAeS4gPBM2k7Fy+ljuFoRggi6OyTZG1Rb4SW51Wk3sqyP9JQEay/vX6KlCZENud9Tym18sx4lEF+t4RRXiegj9JQtbnD6y7VFsMyS9ugBRN024OuayK6l3sKHCKNpco8AtucmR/JgZ5Z6g7wrzSV4RVN9sXCLAGFCFdbE+A/F+k7V674FhEfcyZi0ejLr3SB6/4FMI3hU05Vq+XzIiZ7LU67nmggVw2bTwhZ3txhSE68tNBDHZ9GpG3Q8x1ZM0KjYlEPYp8uXX9EmbRJm4BEVT/6jRvB2aI3sCNzCc91DoIHuaTlcHWS2+zpnthIZJGJAa9eG751dlAunetcHAMtEadxj/Lv2M2QjCb4lk68OOF/2amSAWyEjn7I10vVhsSqOo2DE5vwu0jqfZlX64Ilb9zWHa1RVrwbpo4jzeCEXNoOYFsFeonpXFOoeFvougrYfRZwrjztRc59/f8GdCxYS53CojhIUP09w4zHcdoiCagmH+RA7Lr9gR9QS8IYSMx5lXMFZZWUQinL1CN1trM1kyDKvxAquKFOdprwtwWn+xKvPEd6Enwg9e+Is6md0/H6u3iRznWk8XqfexaPPvpIaDvI1h/CmtGirnBD73OL/uat4NdLLmK4pdPniYOptAAauscMHuYnDwENTqV3jgwf7sdNPvjbvP06CI2ZcfW5SrP3JQycFtieFJXzlxe/qnu7BmpeVu7ABRmqN7xg6F3prznB6aCj/sqtAjcA9K4aGvlYo09zLj5BxTWjl7zeHzhP8r055cUn0sN9UorgbK9N3cCxmViFHvzWv2j4hSQLziZ1TraInZ86w1g3UxS7zXImZH3XWO43p+POVWylrBtEOdwW1x/Yp1EgZcQbdPHlQF92Cnrb2b1qQjDvqfXi7FLXLiCFoddoaOu1EsHTTPMIca95sasODwNIviRtMyWKJRCmE4lTNeX+OqRA8ltt66sAnMtACxlJ3YRC0i5Jl4HlHltb5KTucpvQHKMNgOa1KNDMSm9rRJwFzL7upcFtyUyfXSjLGFQB+Y//x4/IETnL2h8JeMvNS06KoNMeWJJ/KrY7mKZEUwFl11RTlfUigHrKG4o0oyHm+Nq2ksX5/r+oabqaldoa/f7/zRm6+tyqLqkuDNxOg/o+RbliYdFfQvuWLV1nCD61ty9hdZLEYVInn2lJBSr6PwBefp5suuT8mCfcbVuyYD8HYADW79gn5YkFmW0tNbf5uLsEUSJ2U1qtj/SI0bTZB5rKX2cZyaPerW/OM16jdZIkTU9LzdPCOAE9UxjvWuLk1cRrWYeCuBmtbn9gCtaHF7Gna5TSNMSfe8HCaLpPC9y8sxxdu11e8HsztcGD16QXAQc4My6mYJpk7MB3OuqRQC6O3jVOagFU6vtN9NVIYzVAkP8OuTMmszY605F+jqlXcYz48juRY3mZxwCTFT8cxsDKnMPayJ2PIOcsR2g7SLwk9QTmbLtZuxlajLDQZNYvom6Dn80YpMIsj+Rjxu2dFp8RAn/dWi4DVvrhxvXdrzp5vS3vyOFTyWpbtFVmvN4YI8yYTXhCzliYKhTucaPbiPsR6zvcaRtrHzTlweSmuDaf6BkELGeBrBE1w6J/FuCj5VUn5P+6vf01/asme118VGVX29wCdpYzEbICaiCaJxg+NDzhdpilH6TmbHa3tMoO3ok5xygDAtTZFaHPqJEuV+izt3/fi5QQfwdDt6E3Rd0Hvr7qDqeTcqWRJavaSlY3nawwf9fiDRNZ1iHSN7/6kC1lTUC/qPcRZ4sLQJdnmYXJlbniTzt8V1KdAlw5fl2w33urALENAz48fOXXsbsxZY3zI4gha76gMgqTlcGTkMfj/pRpdpqf6JpzDkHI3nWNU9slz1+8XipJvfWlGllwicaJX/yzqVGwhE32gMW6Lr3khIP3HI+9W+xRUeg1NDPibcUjI4xxmMM2rfP41G8sdeYejn2JtpEkoe4nwvomBO/Mapk3J7t4nzjLSMaN61eLCBqOAmqKELK+SELTzcVrR+aFYSfvhuRUbuMtHiFrceAoIhlZSLmOIy+E9bLtL0MlKU/eT4IXx+l2VLY2p6vBxxa3uoy81mn1s4r/F41OJI7w37nha28Ik/o+FTmj0YzXqFF3hCZ5N82+XbLWJDhlPLdyOJKLXPlFBS5VSDT9aBmC6Yj8RkCWnpYkzqlSTcJDYmByjAb7V9tkbO11S/gXwkeODYOBXppp9KsCB1VfLQSkpFKVt0MXbECPKeC3f8CsgQGXVOc8IGt+3vYodsl2ehYzE2vooK9ec6GD2PgbGJLQPBDlVXmaDe3iO6EOc8DW4xPLKpVvwWdSmTOJX07GnSLre/snhcA6qDcfqpk9s5VVb69DwHXuGmN8gOV2GUjPda2YGXMLxEkWmtvUU6UJdg1+Q1HDC4Hc9btbq3k0QRxZ4DWGtpfTvJ9UZQ2vPob7dEVPO08mbw/9ZsYzD9i3gQJfx8KvfRWuyUQLvx4Q6svhiQosSKY54tGufXG8FQ7RBlRiPUDNKRAU1gWMZMnlMmmZ7nf72uaBjmEXGtUE3uBKTxVAv+DWlEch+RqhZ21FxEr5EtRmO2nFvjpi/juwslVc/zzy0vcQoDUpVqR4f4algwApaYALroFTpZy3denR/5hka8k/cNNE8SZu05ZQRDXj2gMU5+nOzGbIwSDSBLtnCJREEV3uhB2LUZUWNCIgs4BpenhlloQ3JzXmQnoIGsJrVsOVdPhmeXrpi4rQXFUZISfI2TxBsv8AjWz2F8rwYpCmshWBQQMIZ9d4Lji/y4WKM1Fko29LsvEXoNuQ1eepdjT8rV2HF6aydg+P8M84Xrt2NeJXU1EbMo8wu7Tp8nJgLMaV4jQ0F9pjT5l5RIIhtSoudueVM1E1HeGQe/6m+pRAm4B71F6f5bQPbOZWeKPdOCT0cOboSASXuoArAIjWJk3mqnRlsgRs0lDjrFWBWy0m0qutpUbwQSQ+xV0UHE4VDickUSxx0s8Lyq5MdXzo/+1XWpeXQHRH74gbY2dS1Uc+EYhN7X339UxhcQCyIC4jyHxRMhzZgWXQZLy5XnXpoiQEVDOyI7u/P4HK3HzOKzFLnVA689HZf/cfF+/zj183WF+QT4Z/noTtWImbU/W43kSutFpEZ7gLdRqQQTwTfFo8s7sINdN6zluv5ocYRLrhNOOFOBa/l5NFgjM/gz/cWfdQoFxMe1/ruXrvdv5GS2SFsf2zlBfZiKC781yAnMwfJt5zBnF+N4/hjJCIiVW5q4JcZ3vGxlJSPFDOtm2IeKwrJ7ADhIYe43u/cCUVNMICawO1tkIR9o/DIcbMYl5hGoFuZzkkBo2mf/L2akaIQnojmQTJkLHq9dOEGKaJ8l7ocRMMlLDC7PELpXHYPNunT54S+otTpG44HI2yS6NUopETdknSyicibxS6a60mZzLbSmo+poEGVjMdx8UZ8cKTHDDphM4QUPmUpG3eSfDOLPT5CBH1Ujnp+aMH0gHXR1xRSvPHRckUBjZHx0wywO0+0WZ6yLf52AfR2Q5I7CCT09X1mXQaBIkzbhK0EkpQJUVxhlJGgBETnx10AP9ORUf28wahAaXMSGjCgUbjyf59GigYYJP7JvWRDDYEyfqYJfzPKAlfhAVd1EXnPpUyFB2WLTkwLoFfUUIgWo3m60TgU0Pp8r+bdpPWszL1nWvie5UL5pfNaBZ+jUBz/gOgWjEJO3q2HmQz7KgFXjlJ7hyS7kp9tuB2yjYqrSXImXtIouVRna2FfRWEuEwExwFjf6u7hJk0xcLF6xUECRM5u+PqDCZGsL9OZ5j8JXtwktArZQ6oJnZT8QON4rFe+nm6fkgLvVdNqLBZZ4lPDth9OF4kyoowaZeUlF7+95higrNY5WnNCXxT6aXxmAYryYJFYM85doZJ+j/AQuTd0TK4JLYXI3PZPyNt/7MHCK9WYiforfAECLWFvFuNgUSn2TVSfjpfELIXR7HJLPKkZEITAOTSagiOp9n/4Itk5GjjWlcgaCAq8/T6/MoCm0s3qXHGGj6ERi3RPRe8XmsJdDLEqh4NyUtobj0DygQywFrOWZ5RRyXe6QFoGJN3tkb6GxxxoETZubLWxQ7LpSxt0snqK076CMyh1xhwz11ldZ+NTg0l3jftWLvvii6dCat6k949mmWIQ+xY2jgdMynHrWMjc9ns9+r7FqYMzUtR8RnZPfAcBajjP6MUmz+wufpVvxAb/xxJ626+U1Hs5C63TxVm8l6SjiGsJbHedkdatEVHExGO0MS7LeKaFP0Iu/ZBwAJViJwOGkRHvP1Eb0ncPoAFUu3Zx4sjQQGU8vmvP3wu4ANg3gdq3CMWfp5co/E8DvtFh4NF1HFnDLm2JZD1jgtHmKucrmjPxVhbLJNk+KPPVCPbbUSZ0xqLPVf0mrx/ndvVcCaiTGOqhv3L6+1wS/0+962S1RSNrlx3yOsoijsFTKV+JQj1h7jrB1oWWLA3NRBb4eZhJ3jXiRk1YtqBTSJ+VpHhuSL3H5VT8g3OProp2+QrCan6gn1nNalPciDS2V5SiKlAq9wvLupGmymhYfqw88R+2mrs55P8nWjO6fQA1htPprkpyr2dz8bZDcu3c4KlwhTpF+C5Z6zELiIHxjmsu03Uatz0lsBS2zvpeNYCXZNzITsiDisld+dvBZzut7abWCl9COVfq5zQrRWr/OxhogtwgW9OVGs03GHX5JG1c6yQ3OkPRkgXejrkUZmkBY8iZD1fUGFHUWzHnmKZLm0JLb/IjW5kSZRq2yz9ItfmBhBQQ6A2bfpegq/JIVxSciIFiLwVg40Imo3hJNp/zP0LRC2ozlTXF4syKwnnvMnyMfkqc9SrhgRWpvb0QVb82QJrPw75NO+Ag8YwoeDEZhpkTu9UbO9fIi47sG80wz5v4PJRO5WZAcCzVniPN4PgcpIJ4oN2cUkjQGFK0qn8Jbr5vbn1z+ilzVa2BqMdONASJVL354lijIB0NYIaOfRbPGtg7ZTCZ13IGVsVOalaAiApjdRiKtm/Aasrjm5RczzMRUdg3LLrLvbtooSwU1a7DYyiDmSDaNAzJWvbKSjRE0PUmM4KcG5RFvaqtipPOvsSk+34BZiFaFIqC9Y5rTLX1GjmzbH7tJE8mfteiLef1bCYoZZ639932yxYh2RXd9hKVV1UgcB8g1of48Vvwqwz2e4DSkr7DAhF0Mw32DX5HknLB6sgrz9BbtZQRXqnm3TaKMvlr0CkAq8pdN3LlHfJYEysRRbRiSBjlnb3jnYsk9SFLVpKOc5R+uAC8zezuocfj88wOIoP+FvXfwMw7ivke6vABN2K+s8NrH7eGUfr/h/b+KHPpaX8yX2BxdE4PvOCp27PvMkmtL8DZ6HUd0DwUUCXbHnEb060htnZTmCxaYIqDQaTPpLl/dUNJKIXlfpQVCLHIv9yApfwUTaJjc4aQgqlhzqAICgUWMJnUbqu2dQS0N2e9UVSErdXk4MVwgm/nfN1crXOetnmvDdTDgo5XxgivkVT8G4SLdRLhtnUSfW/ZFG31+MsAww5eanJKHJ5BvFrQTAh6fUdvhRXfNmTFQNfvVzc48ciiRDusZGPTSr4ajqnwmc1I/+JRwPxRc3LhiR7yUvq/BBPkcTzQUiQOEWtqN+e3tUx7Q7lTEtoYFUXxm0uVa0XBq0dy3dhBG2IP8jn+kPH6gso1E1OwhVHVitKYRZArzHikhXh7NHHZe66wH5cz7IEk5UR3X5QP04rM4/g352YnQlOyFxA4FdgGYO8BkmigxlMSAzgYzT+fgMZcG9rJiP47tr9rJblsvbr33X1Bdb6MKccq+TWieujfrECzPJ18nmCtJxWYea1UzeZYM5tJbvli91+DTDoLJyprVT1dgE3evtDIOFq+zztAn5+jKIpotnEQLCZDJ7A8gj0et6GRcL9+poBZ6CgEhY8xWXrzmkyulU26irzNwiA/tX+630im5hVklCDYrxGB6SQQ2PhPrPxTrFVR/mKBWOFTHpAshmegGU+lxmqDrEVN6Ql2zsMXAYvpZHW5H5sOFRBkmOYzCA3vhJdRtuEdEfRI5wBmj23pC3y//HCKcWwgKweUOLb2MCEqcHzHAcceFfFw3SyRpBBK7lrzQhjdBqa8bcL3coiP5RkJSFU6ThWrlwu82E+7Xqe+gbdyHdL+DPg1eyqWtKvIxsPVlDLTbhrwPprkUFs/l4JWDkuni8rF8CdGZ+7ikWeUiqIrT4PsBEc9fqaWgdIUStxvyHzRnDNCxq8pkbH47AqZuaARx8WtPpTTSASvcQicReBFwO2wRzbnHDYlu4yYAnnVBqTlx35GkV18fhiVHTCkS6lAe0kqOCHit4yVFch/Ij7A4z6Y86nSx5R65fJTgHYBpqYL8JhgWZ7ewfPnCaJz5xYWQb8JN3+AXEXQuJck/zQtImEsehE/PQ1hZtI5fYUlTcOHOXk5wEkjfVlVEc9IRV64aacJ3e7UL1Roi1ODFlONRGcLYqUBD2sWLiMbwMFudxJxzHQGnMrDORs+YQ4M2nPr0+hVzXQuGTS5U29+HPWK/Xi7h+/UU5QkfKn2gQglF/TqugKlK2F/BO4TPdW3uCb4KsgahLiStoN0xQ8+XZHDJfEF8KwcFJ5FklCv8V/gkIf0p0yg5ZRUCcG0Yc0IcsWPFtVbmuJ/wVLUse2bBzZYkHKhHyXgHMEo79CdbKfehWi4AG63h9ImTnyaef5cpSLk/hgGMj8HdBibILOCZAeui75Izc/lZTgZM5CCMO28FE36hX5HbwYKMrQf5blacnyeLFd3OV/IuGf3tOIC+Y0suvRTS3G2U1ZsDvzdWsgZ9UFmptS7mIPv3DvmcvR3YZTedlQ9xCwUYsMZXSiIAt8JLUh7UvcWrZppo6DA0wPhJM5fIL+GB+/nGKD8xZTYswcG+C2ph1aMRYI8P3y86NW8O9+bwNH0bh8VyP7jkEdp8a1v7g2kFMVXPycHQWF7p9PW3T9Qbzn3l8C+jw8RoYrfKrgZkNN9IAXxTU+vF9nP8CQup6nJF8kY0wdyAGcK8DRu2rKHDS/dkq9aSx1BmG9zJC7F16w9ZjhBqO9OSZ17H1TFQUtbzkwAC1Jbw0Yy/RFQ05SG69SuFgMG9in8OWCEH/pS6mScRyrCQH0OQI8otbnVqqWch9z0Cmf3Uk6+mv1Jiy0OipwsmF58Wd1cc2xu3pLYXo7Yu5wnu+ka27V4fi7r67X+CfOM3CLjwfV/VGvXyqWwDpFfu4m9uBlLZ1tIPhBXWsMTzKRKDhY5AOga5uv2lrJc/blgd3wLeFFJF2JXNX39p4h1MqBuF/pD5AYQPp9Yw6htYD5dq0N3OMlyA2AUEda2mjjJBndV7mPf9v1dqmV6030Lfa4CR0HuSWnCX/Cw5xlML9Oe9MrnNNTbTMKTZ+PgWmMmXS3IO4uanrWjuwmhGV6U7vb8VQQ6YrOJDbNfvVA9Sv05wMjS46DHE6IStjLi/LCkR78I/7xrMXtgjGaKz04gzKm+uuYb504+xrU++gUsdViyhKrvUkFA7kfHnUrBry1c1ozRalFdjrS63Fs8EpNNQTGm+azjF1PtQVUqbV/Dgax7zaAbPFIKh8BVdL+Ru4asszHl4WyshDlWjRUdqEGOQ2Clf6Ks+ESpMHqtHlWvmEWnB0gVIkt3lxMyd4ZchTVOgmDGEA83vHBmFGyIiFDCbbPMhyAtPFfwoEk+74X6ex4g96bxdHmZ3fVs6zFtX7S0cz0dG56pQqDlf6FF/3H+OLtqSsNMk6/Mpy8OWbpLZwwk+t/PAl0DGJMmFtb//SrPvZzp/aX0VOdDA2MT4iYC1Mr3fwvs/1rKT9KbOX3eaDQfY2kbvPn3N5tEzfu3zPJOirMvGIwUFIHrMUlkoiDH/+Om5DbIeeLlJRBnSr1wxp8RPcfdMbVdxysqtDJ1SuAwWZd5KavztjBttKhl//yQiPB5H6yonGmFfYKHLVwOmTsJhqnxuvvCOsikUdwsG1qKrpQfHtCNJW4NyatidE/+E9WdS4UUV0+zHCVobB5k9HEWlcIVbLzYZySxVZ3MMGLj71+w3YuQIB4QqhBK0TuBsPmQhr4pDVlkAi9HIFq147kYCeb7o+Y8o0mVUxjF8vnIsRzXojuyFSz4Y2Wl4HnFHTfyx141rUcpWJ7nPCNxlj384NNK49MyystXwHX96fnj+nBpRaf03+ItvRwcOo76w0oAsnUuVfuxA4+XONtMTjFZq4/W0hWfU8vKxoEegeAjpuD2etp76SMHyxktqWaenNplN6vReS6WxVl08H0sNU44d40rV5CNrvhwULb4zoZFK8UHIl14CKTPpRd8l6Jo5mCdyAhTPCmx7C+GdBEhocCnxXeIVIBPk3AUDpDAiUT83Rj5c8PeBtrNfiEfH4+fccE3+XOnklazum76wDTBMgsNskCXo7lI0kv41E8FZ0bgT6OcGg8E2tk3YZynNsyYEtG0MiUXVgwr0V/M7FowJL+Nb1IJLIUEl0LsSISMIXL84VXsb2PA8Rt6IHszwOR3BqhSYjx4kQCJ69bkJKNaEnq9W7+Tv/2vMeaqg+dKfnMN+e2OnVtIMdNLjzzPAC+bgVazPiERExKkZA8Iqo8M52iRFE9ZAUBRuicyjfiQaaQGwlVksGbqKLoVhOjucXYapC5tKttrhOnfpunBkskUh94r0wICZstLjs1eHekEZedDHNPAeY39VIpfIpjhEVY35UkZMUqPFZbWYC1D4HsB5Lu++botD4fZI9L/Cu37zp3MjoQGEY7mHCX3xmNzgud7lCFWrwBcWDeSMeRVXS0zjIIuqyl885xTIzSPp96N7UavJ6M0UiRM4sv2jHAHlBhUP/KSrY5O+uex8P0D0+CRukbj8Uvzn1vJosfPcHeo8KfF5Tn3ZZwC4/ROVITCveAKaPu92CniM7EDYgnZC8/7lk8fHC3ToNH6Dy+0C45a01S120co5CH7DX9NQjNRJ3QVYv8hOmdQfzXGgiqcPV6uncEOxqWBSIS07E5hy6iBjySPwcMXD2nY4v5QuH/d5MebsT9eWK1ZHodJp1SEzRQ1EQOpjrvNJSpLSFMRj1elGzyuBRDR9BLSK/IJLoAZy3xlm+QQSVQsqwAdyJIPL0cMQnHlixsyhPxw+EfV3xs3Prx/MULV6Tr1VsRbcbKfQMSP6L8omjM+MsK38fX4Z72Aco6HPvFx1Bt5WZuIReTC01fbINevwXkrfLPGcVxDNmCqVV2kfd8eLJqjVDm0SHOHXZlBQyDaYVLJDp/SB9wmHVLSv6zqANMJS6JKO+5kcQ9VF1Pz4+C5wWorFqVO2kP3FbcqzXBCZl55qZxxxaQ5m2FCFYdIKVhsrIzwAonWLuzkxB8TdZbiz6EbeSR/cQvlINd5A6uxjbb6N0Zktju8bleOJ+/eWWG9Eg7dmFYaMM9nZuIf18ODltgOxt+lI9nDv9aOUOvmrF/+WUzJRKSGTGqH/WBp7lbTa8wX2k+itFg1NmgeGx9n7DfqL3NYwuKJ7RiSSVpoO4u8Lc/Jz2LQ/uBFPF9MkaaJce4StfYqJvZTZSXY0Loz7gdHRWu5mm9b/J8tkvqqwibYH3aEhumnYv91ceBYJG6fK+b00gI9tyiUMwzHh3dQ2yLKvhEao8Cpit5wn3HmTWOGuL5q0IzW/eq4gB4L5o5+D6bANo9kyH/uqR7iORlf+hF3EWbwuzVGcicHhTPR8ceuzV9BrNIhNMvDE6/bAY8JClLo/EJde6YH7KZSyx6DqkAWRr8gKjGGs2vPviTvIJRoV5VTfp2hJ4qEhHb01Xd1oi9Xcgr1SlErK/9Zc75yi3dw/MuyJR8taCOYz2OLA0l0WA9MAj/wcyQ68ThyZ/d5CM3nMh8fdD833ph5/l46TnOB0h0nkdUeuWYWbsXPl2APEuVN1N7vWbe8nOhLLTF70+QFqSeg28tdrJL1jHGGtwoXfpnRURDbo4EmxQjcV8DEiATtgMMcUoZMjZFsHPIOi8rdNUBBc0H8CdHMoXN8bEbG5tre9CNGu0sog2hmyU78JncFBclIbIYueGMAa/u79CJQ0XIHxHDW9odSQGmNE6TyUvf0afvxQuo4jparKKuyQBw4GKRnI6hKpqtkmAsfPfK3GpgN/g/IjJEpIPq/gpNMsgcInnxtZ52IKxFGCV5dr8P6CwA9IP4UTRji2OL4aEk+NVFXbLuFzaltFTZ83hj4iCioPVTpLLLJhy2SUeFIFit68lEvQ8xSMuCdr4QgT7K9c7b9x0uv7FHttZRFugEQ7seNvjfjoUDAdYnnmF2Q++BFLZKKlhgXChOXYDL7PIQfkE5cSV01+GM3KBDjgj4RDwuTduaSume0Hmvr6cHUKbZrkOoEy8vjQD9M5COaNHP3TH3EkAUtQhFyToPPF4evTpo6Km6tHsdE07b16RJaZ+Icb9u1az7rIwOHEx4FnkAdaG2q7ICLibpxOgwf3SZKZim9Z7rDlOzkYs4hEKWvdpRdNgNxZRE1UUwdjQIxMq/uInIUU0W46q6pM577KWb1FKdOAKwVVHSy3cXjFsM+i3Mkux/csjskqdiZaplbF3ToN/YXiz5SGG2/QnaLxlD1gBx+eXTvuoOHtYbQuU3/CoExFAjVZISsqb80wOHShelJRcjQyKINyYM2P+bATCTSZ8891uhO2C3FsKU7E7g4sCwhhi1R4HIZv8SI1a6bptSgC4CZiEnowwcFuOz3ZD84XvCtZE+J5C2CGQAevoe/R14uH3eOhnanJZW5TmCUiUADpfPukLeKjt7eelK1VRDXJHisZVClzuyNn88kD/9zbYb2Ar7Nvb3K+gxG0QtMo4PFMRZlOLUgG5fL/Jl9joah32fyL98eA/uavW6c5AEJ7yyhyZI526TF48edo1DRADw9SbYpXu6G/LyRdoWkQWn/rdDl6Eofne/idQNUvpUz++W6buyO1/gYE7rJyYpup5GcDEm3iFKjdvUjnySdniWYZx+1NZiLGf56xyp8y1NyI9UGWxtcx3UEnSb1VRrABFbuuFaQR40Pa21PnA39c0Fj55bdmXA1CN5//Y8qG6sbLXlGbNTWKlMnLkKK/aWD+UePhbENtygcLcEyGeEN6prOKC+V8G7hITSJlqF4e6XKC6mnzE2LcueCKJc7IqV9n3AvleXHxke7wLmQQYrqDlLYfLV8AkDHHDHAdf99SHLTW/V8pTu0Se5eVjOgcnswukAVclMS8pij+EqxE6NdMFjucifRqth4ezr6b05rBJGRgGl8qCMPbFI9P2QxfOOopg69TEV5Wlr9qQz7ee60R5YQT1fqMeMT/vXIVbfZO4dJEEvv2qCtynJJ71FLV5FNU0MWXBE3h+8SdZxkB1W8htPufAAKNsaYtPeydTQlNSFw0Gxx7lZr2YdFR1F6RoTmQN0GQO+jfoym3oTcjZ+tfz9v8ub/Lr/DfGAuuM9Z15P8w5MnArCUuI+odDS1AUKxJ59eGUcq8ICNdKSBRGlAQEdqQSsL63vMRl77Qk1GFXJV7x7KVH6iQ3eqdLwMWkKlXDV80OMtDUSxyDfz1z481pu+NG9Hus2ujwMsjgyHaUXRjuSn4IUIeVgdzjFTQ1v883HnG1GNgZIqlhGsZ6ojISH14ecFVa5oed2bmtxn1CcxCmoR7d8LJ6TJx0qqCdCyl1j1uvbR76W4gBKrg5YiLb7lLJyGjQ1AagdtOjfpl9UZ5d5zGXoNsO6W6Q46sF0PaBbNu+9PE+avdrx5CnuINcyPcFQYO2MIpKA7f+qUsLU+v4FYARsRFOpj8THbZy5lnChwTkBjcb5PAUawBCKScFLPSN+p7j3rokK0x0aBErFJAdVAi+OBV7ug3NpiRwm7sPbAa27jZQIzQXkS5zlIHGX0dCBT0i1anKKSa0SNnB0NvT7b2Csz6iXwVqYzP9HTXa/1dl/sSAkamu2CK9eE9+z/te8MVw2otW6qSz0CIyHjo5P6Sbpt+ZwWnNTalMIGfKrU9TSuB4TN9Hg3Njzh1kxBkjcJ8SuAfFgOpSg9s9FGpbG0+RQrMoRCjDI6JE1u+2GRkEauynVpN4kFO0IeiLWbNFN5l6hmaoK/RMf39UyDLkBW5t09faW9SZiT20M6PitcSRUa4TuVEksydxCujJ0quVI7j2pgQQ1KWc9b5chYGZo+e/iSrSTMNyvu/jZwRBE09gshhDEcQcEPmi5egTbmktzkjmGzPXM1wp/eALuHX62/ZDPEQ6xM4VBZ7uRVqoHuwDFAS9TX8qS2sPievC5rILcy5DiAOVaeAmcOVcKvYcfxyWWSD8hXCMF7EbRFsw3mt19riD17MIdL2IJlcsvAssSBTts2iZ4X+msgh8CpaXhu+r5XLYCQW6+l5MumhV8v0raVrk2DwVGAhkhLkAFKLy8uU1v14eVizFBiaF7nDf1G0NvQPOWDA7Lre0o1WZBGJCKgP1cz5TLgESdC4iXvJejhcjTJBL7zaKO0WKa7/XLUMyDvqGUWdZm1J4hIak8SZU/eo+o1zofYUbxvuktntekJL/7UwXyAzo1WETgVm+eCfkyhJ+FIOK9mUD72WF1RdtlzuGEMXcGl7hyPbHevpiNpdaanGsI8tuIMdLXOiNst0j03Xn7eNbpL9czTvxxtEaMwSgQMoX8ncZFcZBRsPdzWGaO6qpEjjvgdNYxptcZxvU7QifIK1mQjfMKLNlS3hW9JX8djnmAZJxqiBEgMqtHKe0C+Tkc9AmIYU0xiTJR/9EZI7y5ScJhVfh7vnolqhERTm29H0f5URphrNhFum7/OaQ13xbhhc8dJCcY4t5u11dXr67EvLckFfefsglyMLqlrWwDYkv/Nd2KBGKd+QvTrSu7/LfceJ6S10tM6x+ikVjibYLhUDYDanF4tybt2vmd+6x6FCBYJRGIuN4/yTTB6GUandyWv26AhCmYZGl7aqZT+noe4BpJAXks6SkcwDQG3i1tbbdeS1VuefeKV9cT9p8yxLDtVb7tGpPClSfxZgXTziO5uRBF3g+TrZdmo8UsKGbZ4gykvzjzXbfodc8QuaDG+hz5bYy1U2ececUPa85UqZDNRJp4sxI9Tw955jQpIvG7i95iicPC4ToctiTn/ROOgcCDYn8todoDPPuENaTGnt8Vg5LIvD5drnVM/Ppx10wPDU3zF2GOClul1SujnmV9ekT//EEa+r9DjirbNdzY8jd0qJk25/6kshnjKjLiZNGXgIMqpkiZLGeFaex2zazuga1rUBbiyQoOueyKh0WNLW/mPu3wRfzMq5yKThLpcOVzyV9EpSG7DkfNlmPZkZFIf4FsnT0bz9CWtZxzXf3G0plqDCGsAiz/NkxyAui+VS6Q2hI4RyJodLwt1G/LndYkWC9jg8s+38wHowlj3dBQoxvZlBSH5SO10vySSYkdu+vVMe4wk1En+RJlNPVItqaiGddesHsEXJBjMKdDTawXjrkXvpbBmSgai9xDuu13uOO4x/5Vc2xBFQ/pk7DH204YjKeB/a0+1TMo4HFB3Uwtjg+4BSgvfVCRP5RHVrBNzMtrzS+N9gEK/HQ4wLgkq43QJnOGOxOf9tgzykl0wbj0yjOJEAxKcLOd6mmX0a3My3vgwEEooyJr+WI2o5X+sXSU/p936pfs4vqQUIFf/Deh7C1ik6K2N7YJYA9EyS+4AXfM/Y3HKlS9sQ9tQFOnm1YJmviyCMM2Kq+qSnXiSSLG4cCT6T/abgfOjphtE0QQ1Ttac3gCqduCQhf9mpIkRiJjz805+ePvTXLFu0jQe9jDBflqQ8gxlYnEZb6QMGmaUofs8SXjqKa3RjeJ+6oI/0yPk8tplDeGV0Tuy6YtRKsVnK1H3NWtoU1GPVl6hnL+uD6VdRp4IH5TNgkKH+fkmu9cIoElIKXDE8Anr/+KwkHqbNEa4XPiMeLcKrmHz2WXYYgjefIyucYK7fPin5wNcEbwv566Nn5Zc+5g7WYGDKflJpx5s6+iqNJMla3MnNDhbJcCqMWcmc9YUt3HpgHia0R3lQSKHbD58Ia28QB/Pp37DIfTzbz6UDvd/+ryVbCfNFoJFCSO4z2xLRnxJRfchkxTTlkWAnTu5LfLD8ExV+3gjp/DXRooZDt4V+UrHEE2NNZYwc4elnapbmclfeIsg/yX8mRKuiXYtYCH+EZz1fEZ8MCGb/zHc6al8RHKAh/y/dfqxDyVuVVUdPb2+dHCaexMerBGDMYy4XOpGZgMwpstAu+vzrTwqWzS8bpr+yWm3DELvh5TzSjJAeYejOrdV24ce+KxFtXOGHdbpj18KfvQ2k3npLeGX/8ixT7yJiErlmiTryqUV70LLziHAsbdjFXMZU7/Ts2lWMfzFaJyOFPmv8R6vcX1cF/+nEC6rC8SfhlEbwjCfJKWBRyA32itbHjm1tUpMsfc6U4b0JrC5rluNKBWp2GzK07v4mB69JCaCyEolOfd9WH+8qNOdhIQ03Qo6MnGJpttOY32aZYOXHse44D4M1m9xuiyhHvJjAvpofZcRu4GPUCkxQMvG/OittzPu1c1aQg3WatAYYPUQV4b+Z/53stcq5ILQ/Pbm2sJxr58I5iaW2RNZAi0+JzGlayRdJpThWrdMCnBwlDVQBed2weWbiQVnT/fLwcvEPy4aEQh5Grs69KHlrRAnuN5qLS/P9ilXO/UX5EMYRYwKCZq1ZnwU7tqmgcSRiohmTu+wjK7tNYRyUGfw4O8yIJojN32AIHC/z8LcM2i987as5TxNvpw9613eaIZ6AlnGexj3smtXqS5UMEUeKvR25v9MulwCDF83Rmie7DtzqWOvFSVa1wDIvNVCr0jGL6u84+xS9THzCuHPLPGc0iyiL5sVta9FuM/0sBGdSUJ/f97A6NOYwJ9HxMmMI8VpIkTR2y5pHlGMjmXXdumDCMQ4K4/jGqe7mhpgx7/LG84eZ+4kXf6XikA68ddBQfWfblLw66SBUOUNSxrlOoUtIeGSxaBOTiDBq2UpCqM/mCg5Se6+aol/7J4vdFbbrSix4n8QkWsfTExdiSpxU0MOlJQO9RywGhJwExKpsqbXQAbQWOCqba7XZPInfKO/OLsXl/KcUEAhoeasgtIAXu4keCedeyDV01GD8gwfdSaawlcpKzOmB6Hlh/fpNJS+Kng9gB7blzUUDTlLyUFWwx2GzohL7cgZFS15QoMWwO0voi8AzbUNOBscnizUjnYE4J1aJOLYkSMHLQ6WZk4NZY782BTPCwzpnRSTY9b9GkAe8KWg9ECGfQz9ERV/uGSEd1dTXMRHzo3tHlZpqa/S6LyaOzPndBeMJLx0bZoHDs2D1M/bZnC5p/Jtww3a4u9DaOU6ZQTpb0Mg3A1GscUwhTeHHeYquhfIlYmCpKImjFZ5LGHKN9qxmQhgYqzxm3hdiFmUncXelFy5x95tugy3tnxOjkbvVMkW3zu7kMb8REvVCFF/b5VifhiYqUbSmCF0zUB93ghfJSKlrV9vxIMXSzJ/P+gjZ/BFEVxLjSbgY+FXdSywWSrpxSCXsLeJ3CTPh6DYzyLGytNgkLGYOPHurC2ddRK33pzRY01l87J16DVAU5a5fQKfpAKsy8C6myrvkPmnR7MIIqDK++TJxZHOv+aiQc/ItZ+puIEmus59AQC39hkQN7ssD59jqqXs/JuK0Pui2XUqqjqQpmJeX/gWLKnzRevFLkrwom2tf5yFyUMZjTMNCXxrsf1pvJCwwvHw5vkuoCDkfn9OEailyQSXNkC4fspG0jcKYyeKe4I7lTPKm3eSpDwwe1h9hDOK7V8iRDJGQShWBFeZhUrHzMEymVAPjutik0BxE1NJ0MWz9LvhRAXWLs5ypeUuFCjT7iHjkTf5mvf1VgO0NCKXwjAopDGZ3KWHWXgRYPJN0Wj2npfmnOIWJ0SGWJl6C3mO52YpLXLzo24U/8DpKN0N/rk9+S1NaC8HapItZfOmLQ83bsTTRWyGIv5X0VI4lo+vV1S8GI3t7LzgwGb9JPRg8kq4vuJ3XiS5aeSuHjOitZBK7lSknvkCYx5rBAEoqGAPpxmT4m5LZwnwzEuIesn9Z0zr9fhEPsJ+UMWV9Lq5v1y0a+RxXcInWVv2Ez1949dAxbKzk1SlmYxsOrKudnds1JwYGL3Kj2qrwnBu47HhsF9qCKA7CDoyaq3OMiPdhGBvA4s2ni7xVr0g6OpJOTJehQipMQjQNMGgUGfsKFrFWgVAzsqx7eAq5u+QPMuA1doORhcNc40ulYG1PbGQEsUcu/HCYlJjSQMyS2iUxCs2tQxlkj1ULaCjuzVHB5tH+AusztvYXTvTgPcP9YtsC23A0GhezqfnEDjuyTyTkeolX3uCiOYTWqcNnxr+8MuQaI1Qr63Ni+/qagnMnjrJh7bliWV8tF1cVy5Dso5c0Ar/APoBz7crvg7tvhN3toQYs8yQNQBpXD2/zUQpVZbyy9fJ+7BJuVmqtsvMujZ0XPd/Okeeu34DACgsy/QARp3N/y+ccMPELP9yydNptTHYG6Y0p1vgAd2Tn2SmysBorua2MxP69RODrHE3T/47aaHaNEGsDoydcJISgkaqtr4naUV4bqhVWSMPExPY1iIPXgRDdfauxU8u9KjqqKw8uGmDK35OyfgQFZfRUSGD6xJpu+5D+rI9wWmylpZ1IKZcr6wRwH0GgdVbAHRr3Y+TXH4cbZ2GlDSAB7Kek/lJFWSq9Ym9CpoI0TRjhPGBT6UbMDhIAR11fNtc57ERyyfcalHj7hKDU1C9I8zUSWVVLqouzJFLhy2itJfmYxglZ6YsVk4f1o3wSIOlL+SyZWQSw96c9v0wteoGmsttPTi9XTOrDUekPazCnZIGLR5vqXOkmtgi1rrW7vyJcpe4oh2hb6jBdPr21X4I67NxSeZnZ3iDVgiQN9273duz5UH73BKnplBBES8IjkAmLQ6/SxrN5vgSQiMbb5cZjy2hpbRQlgGfL00v8/nsA0fZSOf6KDi6q5a8kPfs55/2M3+lAWZTN0xueGtJf+UPYSgS/1OUs46PSXBwlHFy6FmimgjFuduUiUbE75Xwtv1h91ZQ69y2G20Bgnlaq3KwwNAWcSYPTFfTwMZ093U7C+7oWD6u5CdCbb+CUP8AbHf+2rTofjAqMH6IwuN6jbfFLdKt1yTLd44oHs6YIrjnTgnRmjo29TIp3k313XPYhLFyps5wj9NDToAm64Apv61Kdgxse3cqQscpgYUoeXtZ5rNApB116DZCklxn1akM8QJzUFEbYpV7xUKPmV1+hNwzzdCA16U1p9kEdaS5J0OgioQhP4Su2kyThcFeAFKM65qq2IJaaOSe88TqWiFtQjnFD2t8uHphdvW1sHCbkr+cp+jkZN/6bEtBzsFbYbGCQfnHnXlzL5DNG+t4OIV8jEUXZG2LQAfnqafu+x5o+tvUjauSAdrvDiGBFnncdXMARD83Kp2Gpqpzr1Tb8BsHjTAJjpSOHtmcjjopHana0Lgdohhy+jOrCG8Egk0isjCNV4MymFmD+5SqX0zRUIrVIdhss9cIfAxjJckD+bhT7SYvVfrG9SGPOBSTJend2OW/yXhmX5h3ZRcX5FhL9S3tomF0Kq9krCHLOMmzR9s8feUXBdijg3CsqOreAc0alW0CQBNcnha8/ryAY6WgpLUVghgUsBNBVEaXZMj/xVuxpBYjIcjasbY0BaB02J/fruKdxxcqdAFku3mzqY93B2kGSaqMZfWQvYG1rglviJS3dclnHbIWqD6YYfvCoQvA41WjGzdLhW75SRW4TZYL0slZaHhv9E70VQikbZk/s7CEflWhgjGtUeHhKrgpE6sN92OVt2OGmWKcjt4qtkJpAN0yqnROgF7XYUW42NQLbLxOdAQG2teB9V/SzglfWdcWXQqpMfbVtyNllPO17vnA2XwMvXO6p+rjXTxNMBYJ6Th6/rpwzM738VfyTovyXE5I5T4NWlKzJVlVoxQbEeQrpIkSgutNOwXonCceC2XNFCHUtNX50SmamvqHhwVnWBnwcdqf27ACGhviu47k4ujyjimV+C+oLlB/flPNN4GW3fz9u/fGYATQ5nBuEa4VleSQUcqIhbo4ADJusYe+vlPsq0KO/VsPTD0KSE1p6klb8avuP161mD+c481uj6C/0rvRjVW6YM0T3mIJJCXVSe5hskVapH4Fi2mCwyYz92jXm92DHCMWI0fLOVES5jD1lTvVzbn35Uc/99w6DvqTIAksHqD1WfXR/557xYKVPVSjf8ucqh6qBO9nhCdN+HuP+3tuLkLL4NxH1pDOD9mUtagtWNKE4+spqBvSDPDwv+yu35BOmHO5p5fv/rBqMD7pG7SlOKuoXzpIIkbsp7/ESLC95tBxQ/6qUIdkcJ0qCZMN6V6lCyN3bfCOpPrcoFfOUaHSE8yW3bOX/NWOMgI+GdlAXHGipVQFivf8It+uiWy/bMV2Ufao1Liy7RR8+KNt/BAHB3ivTlgZmjqnu2e63zUwzJdI5aALlQWyWxqF0Qe0Bogf/JWckc25OPPMvkt6/8ecv6HJQG6y6oVveHo9uXgfSWkiMwOg4MKo0HDfjMMVzXJ49R+BjysRWJgjuX8ilC4MREFmdOHRgmEyrM9daZ5naQ2U7FGOYp0GAh1+gvVixeHaFheqaU1BehxxfLmiZYxCQfxNTQmy9GbqU9eWsNi4Td5wUW1cJrxZou/SZW2jhjXw5ZZcpb7Aya5V7oDa4fAM5zu0NK80GAl0yJ+43P9+o5M3dcaJEcCwuu6XUbfAW8ce+hWC3WwSQ4La2HdqgOu+wq7WGoi4+KqS/XNgnPV4afwXq1r6Vp3xuhDNkdeX0RK2yzhglSXfSgQpsifynlnfvfJMsefXKO9qgTqiiblx0bUpNd0lX9ZzrNFC5UdEzaCu2MSZFDvrl0ugt3TENy+cOOwD5N7HwY6vEnN4qu1/bXhbKpEUQuNSVMYoKu5c8uwgxnm3vDYy5uHXvN4PJvSoOiER8nOOM3h+UqOTai0uT3Qzkpj8xdwvgDgVdM3CtbJndB5WrhYzT3KeKt+4IMpV94Wd1p+ngPaMPohSQjqKk/5qqZ2PE6KsB6pMZq3cC3PWgXQtDQ6C3PYmgt31TOA8Kb4uJps8pCi8hSKCMtkWtD4I4q+whfXMg/2NSMzaopCbZP0Dw+8W7kxbIboPkHFX/bmi37aI5aOKpKQLfKIBbbVOXRsuuDnZAB3vYZ66gFIexq/KtEWK6eXP74Fa6fOqALNHa0ergwf3zkCGGVuijnbKwd0M0VWqBgyJfCCPkSW6s9nr6A8A3CCG0H4ySilguOD+aTKwSbd+mxcc/XCjaM06pvfBYb4k/Mf/G9k4Mh70AiW60JK5dEUR6+tCkJ2Ra/dcf4xXItlONhk88AIysmsC1OEUQCoExKq3TTdZYlgdRsWXcxCjQFpevL7RBIj/mK7QL3RQYwJo4xPWobykrBqCjNj67Gd274u2jdQlaF+zeWHXwmZ/JKMFmBRNafnA9nUn15/+IZnf7r+DzOqYjkC/inX/na/+tNq2Rajo236EH6b57Zdb1Ak46KIAc4mzasLcl1A9UzdYFy4YjU3WR/+RfQ5N25t+j437gGEHN4xNuMMEjqwGixD/ZS/dh3pBTPqw5P9cPgFmqtf3ek3dJ7mLZvgu6Wf8X2CybsxgoU+6J0XM6XJntbgk9+jwMuVke07crPE3P+l+PO9W9QJQuSr/xXWzkLcLido73v3u3nRBmJWv2XRWcc9lDPruvYbYHXCTuRevZt3CbyBbJqa+zWfbCaRz0/wQbjAtrrlbW+HB12lHjDaHWqVFbjnnc75C8j/aClp/0onoFt25IZ6F5dA8NpVf8ddNewAYuCYxb5vxL+4Ql+3z7F7zVQIkBYWY1XMUEZbqzJJ9S2dfQmW2fW0Lc68Ziajj7zi42n+kK2Gwr/WO6HTIUHKR270fXVgwg57aOwYAcQq3h8NU9/+/TKFT1lqNZP+aMNjJhD6XxDrQ17q3ea7DGRb7pw6vVMugUuxekgfpXWuBbrnp12IPbQaSy/CRGN0USGNv13rxWHuYSiq8MONcuY1HiKChA36GPeuesrkx+XfzsFx+7xO1hbTTpR5Aj/zyDil72nky7A7yrgKMi5IRpaX4hRNwLlNXcYRQoIE3pQvrlBL4bXnl9XBerGorjahonYeLWQ4Jl6s79yNuvWv6/Gg7onP2s4WwhVT5c9UxQp1m4tZQyVK8Vweop99jUWAyGg0C/HNOb4rzDgiSZnzGL7uitg9NP9WJ5Mji/Y+4sdzuBdtOZ5iRwNpfMOj/nVkhwvSX/ESTSu9tbHj9t5FbLhVrm84ObZQbbm2rsm6ygX8W0ZTsZXR3HAlhG227Wsh+/NKdQ4DHnNp4N7fhOHMVvN7tN9rrg1ruRet/jL7DuiRTDRPlcKOp+n3BbF8Armm/di11BW+TGdxOgOGvUynVHGfFEoFUxN2FynUqrrdeRLadVre8ItxGFfPYAeEZmoCiN9mdsGM3OFldV1EYtA+Cq/S0XMoCVVrduZvzf0Gyxw4Z2bCosxk1MZP6XQuJh4A/IMBcqof6WqGbXYCp2ZQOAAFyyL6lTf97zR+Q9OGsPj29lsEhVpu/gYC62l6RIlhLEefZ/bl3efOfPrv5t6NynPbWC5vy9tFHAKNEIfWyX88yiLZ7kQ9R+enwzPr/aLu/xkxaKM8cJkeNIfw07rGxV4Ff0SIU27K4DMvTVsE/GnpeqY0qWcwwdGvNk1/gAYpbec3g9GhFQjRCifoaqo9jFddtzQhPrVpy0Y6Z3TUtcozTVTKHGhlNnh2TCGFOWkGy/IovCBGBpCJPUVRhgoJU1+CPQ41H28yhZ+GVHver+j1HYsqUiRjhiO9Tif98aC4hIbszCzSa8jEmdLW0Owt/oVWFxG4xJn3p3PulHa06c4E2p88gOnDCE/hp9BqogUp0IqDMcadQox71TVG5mPkigNMU9m0i0bskQwPcMn+V65POqG6zye61W9FUkyWudwCm2TTf1lei/x7g2mxfdzsZdw7byIXA+/thoHEde2UFxa+0ZWy5wykBZBLQ/NCW2O8mZ8l9Bmq+iP3YMciS0BNN7wGvvdHye1spo4BoKEwgTEgdjr+wTM0ZNSsPG6L+ZigRiJSdMa/AKjL6cbs2c+xwKBRuzYMkS4auswwR0xgfE9nHER/5CEu8iXZ4tH3cfzKLj/WX1yiAV5lBDDyFeve6epOkRTIE40W1l5F3e4RQJAOUmeoc73OzfBm3QFdk6L2RQGUxV+uM4Ue/YhAIgrG7Y3l1Fikpx7JZU/+w9BHSgYixObKmuVnnLDS0vDLl8BH6+DiGmljWwOcFua8ij2mvc9YdOmXscoEgVwPGvabccemOpZ620hV3295dBMUBEP8MDhfc02J/JKSDmxbZD0n243+F9mnV3UwbJbpHIUqgafFyuOkaFK8o/KXWdZD6000UO5vRhIqXf3CnefQ2kXUnJeLFEQlir1g5RsuJtR0jDgSlmK7LxY7DblLPPCFEaKg+1Z4lH12W6dVyIzTcx/Bqeppsbneruu5zNHkxj8GXbrtzHKVNzHxQf8r/J4B+QuPIFXWuI68nCWpGcLq+L+FmgoVRZTJbwBacFkP5G0Ts98RxAGVoaqYpEYACBpmoNtIqiMyWMSkrRkSiDCPcEbaBsyQ5Y5X5ct8doRyO8f9x/1UE4qA5dFSwAaYv1uNCh5a9kEOIHaDjhej04rUUL1QmZYNM+OnG2l311Qk8YcxNgw+84N2nPsn8RJ30C+ovepLbzN1GxDC5yaUiRlUvQm9wYQBwuYD3KTF1LuuM0E/0a0oz7tthCKLtd6Lo1V+Bi42cdlqZfeGdO8QbBDcboPnMWELt1uvPb0CTy21qB2uVCIyOJkkNSkc0xCSQl5/FHoVFrdn80Rv2vVQVNdpaSqLUJqJmz+Zdwor6nSmVB537KMshH/359gLHva6utc61G4+LYno2FLHH9+TY3CeXno9D7SwXHEUlASX0O8WXgCVwL/4F5G+ihByuuvDrsfDV2gfnTXZ67yR4ppZjPXjTgWdxAjgWxgrRw1qLxmp47f0h8vTfIxWeCbojM+n5xnRsmRBy/o7MTxArlHGO97mZ9FYEh2ZKZrl772tTdCZ3bY+HiyycPvU3bnuymwictw5hbtfP5EGr3Accu1CM8vY1selYTgXq2B+yX0NarrVNW1/p1HIAg3cCLErhuRzgzAYzcyU0saGtjGezOYr8lsJLN6LiTWkFbjUqWFNHkygczUOxB+wtzLb0BiBX22npfWGtjcHbuuIak2alkn/XEEGb3E/dGXFjevLCeTcSNoDUL6B9UuYlazIoJRMFY/WnQCHHPpM/c1AXGok2ivMgk4u5hw89FLovYEdDeXWWWAUMlVnncr9p17plHlHRjUiaUgGMAyPJJhiUYPfcnemFLni8swyfNUPrqhvOVfWBF3pwlkNuKwGnaoAna6ZlzLC+2CVZ4RuY6jSgWiS6IhdBMBh8XPbTrkKK50Tblgax6EJeJECeVWLfEDUZWLDJkCiryPY90KG7k/8wxr3ZCga7x28uERmHitXSLpyDAgVKP1mDlXnioou5/BM5jly5mqcVTaEgdZeS8NqwY3L+ex07N2Lr+DF7zTYaDLOXr7gWPVJo5f5ivxZ8YMAvA7BcAA0U7pjI4ivmjO3qe3PDY09oOy2KpkfgeeCIzb7G7L/N3Yof5XVO/XIJ+Fd7vwFt7SL4MvC0jiKeOZ+Bvlvgc9FdL+etfsbJVUjv83AgJSZqh1tnrOrbHZyZQAMWdVpMIcVVdEW9fagdThlZMAAl/0ncjh7A7VY2TLBpXhKfyXgPnj3C6OgMW56IgFYykDdo+mMA5M7N3ANA8qXqtTcSeffa/WqrPaH4WHlZh4xpkXUWLGqK3lWebY6cQSg9dRIEwiC/5xGQVUa9wkVsbAkSsOTDox7E3EEdH4jt4E3cZs18ZtVesTgIe4Agb7WCzLVGU5hHXD7TwM1STZzFzE52+YH5jjYq3ysZLfe/So2ewcYGwp2P80ZJ/sbO4H8HMArqf0mxmJVA3jxN0tojxwcPK0u2EIqQ2zUaILS6EqI14IZpgcYzOw8LM36d7wdE6LcykfwAzqo4SH5Dpz6z8ix2Bk3VBSz7qtsTI3ksH1a7W9R26FJB4nxaTAD8GqI1kIeWRFTuQIOjw2W0ygV8HICGBVMB+mvi6KRlbt+dhaSg0hSpdOg8ztyMCwsYzqbRRpxb++CPE8Ia9JZxgc5XQoUBnYCmG1wKkPTdwiZH+AuVSgtxlON5TU0tuTWWYO7RenCe+s3m+TtB3aimGA7pUI0+M3NTodhwm4qxNiQx5zM/DcMhNSQ+UYjZ7+xahEnbTbN3c9+5QyrUP358+XFCMfapnP701Tr7KWllBeBwhryQzgkzja5CCkOjjtKVSghGyVKCvRtdstoZv8ad9YjI1ywDAMdugC+BAG5UQZPHjHftaxI1BQxLFBTqDwurM1spgUhgdaNLnsEDxyVfhpo1/PLzv3lO9AQscLB4lsHwD1CK41LvOzEnP33ktwINPUFtsWdYdcpmTncjaMjfNPdSG78S/7lAVvq5fBrKouySI6jynklkjqZIoII1NsgBVGCm+BIfk4BadhNbp5wvzavld2JWV9lJFSHnK8tiZloOM07ScE3EvLHoVEDn9oH55CcPQ5K8U2xpkUB/9gzwubzOj9zqYQ1zBAs4wvpShYpDxogX00YLd2utINtJpakhsCUUc/Nw45sl4/alHoFqwoV/kxl8pDZpDJy9mpcl1m33mbrBwj07E2bdOa/kcoEzK28/mDwyoHHKQlxgevIP2/u/fKUddph6Y1jPybhefnUUacMWC4CIAgFacvTX/86UHdaXIcD+wZ4J8jWY5kQcBa1Ool1gZdYGKoTmJbpdZYXOWASgTbC0CspgcN3ErkG1h5Ca7WbeUlSfdfQvry1HX47qMRrjNdukr0g0F1gIHlV8ny3WD7FrCflY6h/hRnUseJl+pV0NNWzdx/rieRPHp3n5NfsVYKc75RlWs6QmotJQx5jMCJa2TYhPEj54C7z1fhDXzrL19NkKKVapDm1pJMOK+a6mA2H8WEWWDcCOOQvBf+L9KEShYXkOWJdMq4mR8LQDBHHNAe3ktkm5yc/dRV0B56HEs1+Xqow2aAYoCm1/kDF/owLeCacfQmX5pi5hmcFzsg7rcXUG3bTazNud7QFkXcXAd0hY3rQkMFrLPWS/BPVLI34/RY2VmjP6LXHo7APew40iev/OP6doQs5HQk66DS8lX83uA+xRzJzTzRPa3HxrM1rZ/uIauKHBVk0MNnAHqAmGvjXHJDyVuTx+dmuIYNha3O+/pAlhVaf8KS7ie6Qbj3ZbQg7fOImTfs+jk3EvCvUuTz0LcKBqvkR0Z4V4MTtAEQogeXMb9M9rTdhzWTeUlYKpgZ8hvspSPn22X3WXwJzGlYOFUHHT2TpHv8tlGN4eqD8dsvN2yFMw/QZp48MHUuhFXQPlqt/lQY9OhGMXrj5Smqxiz/YHgcCG86PYc86prt+XMB2IZrd2pr/6hQKwkNJrMxw99mnYGG2dRvayJvCfiSrp7b/vSVkdxo8n7jOhAfHPZjkD5e/Kf/q/ui2Pod8qh2jan/yzclCja1DHGcmFlObjDKcywwcc609eM6zactjceLyrU48VBEHE9WooNexKdFSbZQ2mWMPmZ0UEoQZ1jz9yI/I+MmGFIdwa+mkY9cTnrOBfBswtOqhMi7ULULo4ZQB3MGYXl7UH3j5MJ/+D/39ne9t4IsnaWScNlr2sg7SJ0MoNRNf5KmLA/Slp9qLOaQ2r4cOB9qJMunIFcGIU3FvqurjCG2HIfkbfzYb6JofcRiJn8f/tmuuxsNAmTpj5D31u+mZL9p6tdr3Bl5drGK4whBJcsOmtMjvAwH6iUZd5gyDcsNbRs47laObc/cPB1+JbdXVgZ9IB6qVBLK+zw3unH3HWU5xKthjEDf49a1xJ48CB7AEyvcw8Sz2Bx24s0jcWkZ+LM6i78wide038EH3WWSpWaFW6HGFQOXKQ26UQqqrAo1gNgfdqea9FJwrC0P5LOAlk8qQWyWzNbXfNKwSJKn0qDbUY4AUwHn/X4H57XwufXaBQ+Gv46wRIoX2O/DJokc21Ar5CqCuhBIaVix4Jazzz9a5jtE02Ox/O1lO7DdWTFxalUN1gVItG5jRxl/6pnXUeqQe7Sm64nY7prhQykIuuk0zxJTlxMcfwUnkWz8uyv0brhZXI4+lPp85KMC6C2MHZrmsaQ+4FbRNxFK2R8f0dPkgUzgBA0wgWGR+RIuPIF6YC7B4AA24HxVU96OHie2jcm9VDFf8CjckLv10P4sNECJ6a8rX+XOIP2aD3BrGB7aoLiqRYd5tu/fu0EobeGWA9nUWgQag5OBp1r3w5S80XrSNAWsRY2/TgfQLZmMpWyXMfPpMDYK9kIPl62ly7l7zcHjk3pJb0DnRPSdg5NZrM383ZCTtn7JxmJkRqupzODOJvS2CsVgMyiH01//kaPAt5AcS9sgCtc4rkAjMqrLajnn+iB+JKDuuIniGyR74b8L6MeUhjfTNoiF2bZ9N/5H8tgc92evQLG2a6qE0VF+WgmNh0tFicgozZP6kRKGey+4/JJnfefHzTtb2q8dzt0vBapLsb8ON7ehgVg4BC+pNcbmrTiyJASR8E1Z2amNBdG6yE1XOMf86N0ng/s8G8aOXkN4F+S30/IqzCtyRjwayfO0WURNns9iq8nrZ+GCRVSoYl/LAjVFCyqxn7SgYoW72uBqXuw+HZ0bwreRzoiX+Ent9V9wW5Z/vAczOKqDmkg4WlmVH9ZnvBrKggaP+8YEVbDJcSglmQGv4HkGeSIKZ1sVrefCwoq3+hIu3D9cBSxEeJz5g2GlI7NDNiwSszp6sg7r0Gr2pDEunhFbwxlGzmIBDHzlq/C1/Kj7yShSyCJTFlSiOHrcDb7KAvE0yaW+FnkvKVGnliBdmxZMKOLpYmoHZJ5XykccGVjct18FZoOCnWQGYx+xH4fKLDtghDmCeXkJt24nj/UHAgBRFivMgVtKzYD9ptMLwMkEW8eg4G2brZmbbbSfwmSW+LzCefj96+H8Ad34i+TPLttkBWRIYZGx4mmqKULWQKAXqXU8C2ahYTg5g5GI7uWVlJb3KIzYzpFXo4dK6yDhqU+VvE69PVUMu6JLmRECLGnStb4HKSiO3jhdmMRTAHKaG3i1u+xUjmluibeJ9ZNe8GKofDRh3f4ffYoVnA2kNP3FgeegD35EQh9w/BNa2B+TUbQa4zcumzUYd6Af/5CsuPj1Hy/nFyhR/RlJDkUrV8S/CC89FmaKX90wP2wfq9CWRshtSoKiYPspu/5Jv2N4mWHqboD+r0ceGfcxtJ3BQ1b4Fhs3+wGa86Iso6Soi/jrkaCyjwt5+/KgO9yhCPtHWG0H3VzIc9xJXv0+6u40z7MPVz7NunH5nYbCAUjehSdjQS3VRWhYL9CbzzKEWa9pKg2glk9J4EgEIZxfPDDNKyzKMqZ3ZDaK35wDu2a8Z2smuG2IfJHhYfOLAIOwELIqbBfT8JWDWZgzyEtHuTrjmlaEDYHkJsL3XDbO6D+9iFz6D10H/gkv8OmgEjaRmcuNIsSHE6FaaixLnkJbu5AR12IL8wnc7Jp7LdVtxzNO1nNEJDhsLHfcBLTqFo7MkKPFG9OvQKSZIixLdFx1EKIHp+O4wqGulHudoiCp1Uwq2mPNaxex+di2WmyOVN6qFaG8JEwkSMP2yJtCxAd07obgniVkqNah+qffZBoh33+Wmr0gD38P71K8JiJqSxNaLx9M9Phv2Wynfh4hh+lG3YL0+SycBs1yM1HptTubj5/Hj7B8EjPeHjNK0Xhf1Zm38NceGl409wIGRaBCFn+diEjHvN2hGIgDxGtuOFGPMdQNqRb1W2dSRqTE9iCphMPLuZC+YE5jOX6tADkRBnsUTI/+z59kvfUVjv9lL8ho/+1YGy53mAG4CReO93cxy6YPIz9PQEwVOG5UVdxtH0UMHkVcbg+jcs0y/382iqNplltKBGfVMJvRPzcPrHomKzxN7A8QsYZbntb8R1T7ASkTgX0+WP/5J2VyFaTDRQY219zmNtsYil6s9k/s5TE+eGp0I8C5UZP5T8bgtVloTqTzf0DRolepal+DYo3KHNhx6Q2zsVkIn6KI7RngW5vYBsqKHYya2qqQ/4CBJsgA33RQM00lhb254D+baORMVWp5vlN12RRCHHLVJmVJro/AZIopf1HIt4Oo1nGrTZ98ici7VNI/rnlN64RFZXkL1g52aRtZ9asK1+DFIAbQPSSPZCwC5SMkQQAG/hB76ZCtRZmIWo2lYp7JbUQ+JDe2FIygOzP6CrWkc04tMbCaTo9wWMIuQJygE014obySqLYzdqmMv+6QFwoyE9D+vYzY9A8wHJPdplK5lqpZR8q6Eqq/Im6PicROnVWyp2+5mXUrawD5aV7JyXCMB5Hp8+4uC44HOQoWEbsxvcwA/9Moqo4RvfU0Qx+QamqsJnWhiZJJ9fyc9bC7mmvBKhBLzeGFqjz0DfP9NnvJB4JevSIeKIF8oMzrMFQL6rEo/vLiNDAja1uOYv0/9ZDnIl9OIHQGiWvDTW75tq4lzhpi/sAlcU6re+lnBcq5gcWdhVHr8Uc/gi6zS1OkSbxxSQfZoMOtIuPKQVe9voNU7ksIcg+1aN5PKhdkPPaA8jH2hbVT4Ymo2CznLQlAJoyS/FyCmzff4Q1rxLxA+5Gutemrt7dJF3Wz8/gbDReGe0aH8IVDX1DllgJ2FXV6E2XjLslpTxHv9H2GA0CB5yHjMSCXBG++vAFwvybOlAfeO0TbJzRVBk1Ho73arvtJ1uRinLNMZ1etGcVJA30qfcYRAVaEDIc5K/eQ7UmYdgPtZagkzCbvLcaBZYDSfp8fNKFImoffF5z+VOgIxuvdyy2CLmJgxkUfpRt7/AePN9ND+wIQkvMZFblu85uoXhZJgy2RkHXmiNK9WvnggLmj+hNtLcUC10hhpfEiYsMTQmVWrl52KbUSCFcsPVNFmD/86sRhbNk0sYcY28qrNhL3ka6X0NT39Bkd1ejIMmhYduTEDN7CyaR+u6V9O3rMI5PwPnQNxBu43CKnWUElv3he87zAYejRCk7cb0z02INtPT79rEGV9RbmKbuySnFDctWHwCqv0Tt4+E37umcbFRPidlD+8xug8+aEwtVDXgno7C+KrMTqMc+rtEI0R6Wm6N4ELFQnLzpo2rZ96RDny/mNZZsbtTGuJyCfYedtARNmWazHQsIzMEItdAsAKXv9CgAFiiWEsCz0L+T+9MAA64gz8nFtf2qh+wBFhkvRXopVzUB5peefi6ilnpfLdLCFWuMGUOI8OfdGCK2WgxpEwuCm2+c48n0aSSJvTeTBSW5xIDFIQwj1Z/NSY7k2uWZM/9X6TfhU4hVmvGKAe3km11xba/tdzjS6pcknEoYKzCAwSHwOEQ23tA3TpTzYAVP96LbBhzuokp55ptpzlvwA/9x2bEi0dCOU+C/AIZHrQcC0KNYmUhM3WVHcKWcSdWHWCjsKCa/N+MqWZbry3IWRUxr7xH68XaDsJh7/4UhCv+rKblJJ/CKrF8bNoGM004jXTNpeyFHRMrx1iQIlaBaZ5679WA8LMlb8bI1BOQUd2yAl+5+CkgYxFhen2q4+E6h5Su3aFx3pS0qEEN5jqS1eHQvHrNvR2mkp79N0jPshGcvads0a43ddOfIscPFuZo9tP3xym0fC21ZDPQMnVamMgztE96lPY2EVKLwuMsDcI0KEjnrg9mzpBLJJZxX9XzKitlqA4/yfpHMsxPa78m0ilrYmwQhasOI0wAz6sNqssjRBaz1eLTO0EzFSAMps5FB/eSf05Zote9q6UZse5Nzrao0vlQMPZ9xKYtxyBx1vMrrgUppLkgWVunQX1ChWk4+A95/XR7LpPmQtmhJV1kz4naeHwOYUZfRINU91GFDaorPU5hOkYpjVDzqiqMbIrGro/jhOqrtpwM/voIp4TLJhLMcUc77zeVNqEzD+0JIy7HF3NR6E0bQKgXdnO4HRBhAu8QmpY/AkhSncGmUbBQJZs4wspWc2qN+tvnXRnfEXKIipS6Z8Z5OTRSvkbo9uran86pT53+eWmK1Jd4a1rfN7Lx6Gfqd8aX2eZnMSclCSBmrg99vaF7A9SdZj/DJYzUOjqg5YdSsm+qjYQPtEsx/oB5OUQWnsJeyuj613rOUt2iDD8/tVzIog+cCFBD2R2YP6e3iURrH1lW8yIMzNRywx1Udsnsj4ktZGoheKCD0HMrvxxCp4QpV23TrDcfqniFT78RktMaIyluxFOg0gkbh+/839xi8FObewsyf3dDty8qP5o5DTfGnaCYFsjkEOLtngqAngcpKJXffytHPeqGkqmZGg3byQy5cI+0onl/55f86Nti0RuLu7u1BGRtYhB9qgwiUbclf8p8GP+v48YQvccrWp9h5EJSRkSgBkqRtjVZfi92adl4M+R0U/c8pyAeqw5i2o2xK1Feouj9OT1jSKcBhtmsYWRW1UyHKWVC8yWBLwbpTKcF8k1rBNJ5NNyobZLyCgLrlIVn9B4+o0hQXVLc+TUFZU6+laU9uYhgkt9jphnDh161LQzSRYKKT9r5nCMHvKdLFDdQoCZWcoYEeT4QcGHaNxr7UEAPYe+o2TNgKcMZeiW+JC8qVhtTHNzGZNl2FCsRmnQb51bymapwDYYXjD24bijkW2z9SZGkX37T/5ukmbq3R9AcumlTxf543dIj3Lziiz+SOGcpXUMZ2X6kmFsLnh/DpXi3dCXgBJi5X7MPfLBnsqHMHBtmLwcIT0J4YnS6M9WaTbnNDKwC0RVuzaBfzBPLls7bJ/X5Gf6BBCHxL3hbBpiYkKXr5o7FbbsMy4ATVyo4G/h+uZWambME9ytrG+Irchl770/idOjtCQeUyp6uoGFCmQhCoh2QcgaKr3sL0Xz5AVZ4GNAKzH3/+s7w2ri2mTMiOorGUNa1O51zL84WakWZyqBgl5YeVezUT0zSDFyiC37Hu2o6f3BG5JMfsuekou/wjNSNhe+mGj+O+G/KC9yTkpSKTNrmhpztIIyh5aXi4s3T8hunQj+iRj3PEuzGuzbW+C0edWlVw3FmpgIB5tzhc1JKnss848WLJ1i6bVEyLLgCaUgR28rCAJE6MYII5udzSg/t15t56b37na+l0XT/vV2G098Hsd0vlUkUD74mMSHpFSqkz0vFWJ3vVYs9+YlnKl5T226Aty/+rC1Q0PUNK95HPToc6fRpIIZlgl5s3UT0SLx/M1ki5HT4pAUiTz5IGIVtTidlNFhVr4A9dIaloU84F6DXaa8fDPWUTwpnVRQxTAQpSmikb9GPQIIUcAiHuWC9ivvVtmtM/xBV2y0N+rJBqA7T+zU61QzO0ZMvea5tUfFZ9V1N90K7IcY4hq9M9KOJ4wEqzebdosoXeDiMIzChFJuKn9ZwIcW9CoIFkN144O8WnSqxIHJ3qB3XChPQiUYIphY3iBulwjileQs29n8EwqDTK/WbMpkWkJGTTo7daLeSRKJr6/FUIH3CtiwfZ4CH/Dp9db1ufN58QRiX2oANC+IXSxv+yB2ABfTObLmyeiitFcR1qE+AXkr3D9FiT9WPg/uAZ58PnQguDn78eUb0cbaCQg3lKipTMr/WzGjl7J1wdLy9Ym3OQQzETAerRDrJxJr5NNguqf369vJs3Ba8qRRCid+RtRDZgaSup28f/uzeUk9ZZYh49gQMrtwkeS/3HrBea9jE165nNMS3VBCT6jOQFmth3HHtmnTVZt0/X5DQ8LGSmguuZIdE61hYCLZf7IFqzLH8snRfYlE6XcKqmjqFOjuweJhZPpSkIvuBsdFAZG1ehJMXnJ9zzS2q13fxRY0yzbRNMHG59yCV2O/4VLEQlGhbE2JjA/bsL5S57vZRoVy0ff1oMu+EJZ89yP5ju5R5SJledHyOjI7H1WRzk7AC6ug3o0/6DnurRotMC1If6eGzhSjh0qisN1nQyD+0oldQdMuAM3Gp2kd32SFRQTXKb3HMk3zZ34sf4uW2Uqt60qV1IhAtANfBUbz3Z74zknzrCbU7t6rorVCUSb4AWM/zVd+3s+jG1lapMq375I+L7rSj+II5hJ1DF7ROq5AUK9qfHuuHtsPqc6tFdjUW4MRXfd3Q2YgzkQGAwysz0n07C2WDFi2/HHAr9ytsUYPx8jLLwvIsKPUnID3F19aq64KWK4ZxKM0zB1gycW1QYImg4EpMRgB+CqDehp+Jser3mRxqqj8Plnoad61MDfg8FA+Vf332qQ+05S5IhsEmEilgXybgSl+D1dQl4VMUKGIlroSbt90i3PTgd57xFqBzPN4xFxUBb7k9JVvBsn9ObEz1m9rVs9SS8xvybJ+RihTB07oqmLOBLs/8Umbr4mT4p0+BcRgBQqkRWmm/TqGJbDPqagh41fiNKjpkuFadsB3qVjj3ogOJfpafZfwYMIwaLiZ2owa0Te8tcYsKAx9p2p1on/Oi6h5Eabf7e9QEh27j3RICq4Eso9W5825YzWUdAdx7w74D61Cuj6fslofeF+hbkjOyJyioLTSUtCwJ2hcjRIQdEbJWL7DwG7N77ifwGex1joAyaZl/ZJT1n79qZiq5o9EvOmFwkpF4F2UDp+TKMXru3jV3JC6ywv11YBMNVf+Pm5jTu9gaXrzbbbKeEL70RehN/K8H8042zHGxDubulASuzZpAZSwbrHq4/NTH8X+bsUCwquxg63R6S8mtI9cHNglMp08DREa7k9twq/coRXFJXh4u0RCDgU1EH7roUArPm3tyN4Ifucdqz0MGRfFr4geii/B148p1td5HyW+C51cx0l5HwsPTLKv4BQrHVI6eeAcDnkyXat181nd1ZNkvm0pPXPwBM92GzSW/a5wEpiWhGDOJwjqBkPwMvs9weeI16zn9P3xIdapp/htzHazlUlPcWSC11Pxuhm33U4GJ/k6WEimVW0UK6CI1FYa+Hz6Hh21UM+GxJAy5kfCvmL7qJXTrT74IY8yLGCJGf67H7briiwJYX1KtZ52bXLh2+BdAM3AaEfFn2JvgwlDPagU4lu2uwuTej5wkihk6OUASuWvj6fNJUv5IA8dQWU/YYTB8U42U77JJgM9x3daZHk965vU2vcj5oKp5pzPWF7V70DbTPUcvV287O3xQnm96xjSiN21gDjqQL1f5q3hwkxHjRazjyoe/8R6J7cwlYfoNjBrWk6BAqJhhN4mbOWyZ3WD/qRXLN98esFOwmYm+Y9U20V7ZKQ5PpGp3LOBII4IXGYrVT7VA/9MlEOWhd2i+CuCAnnRROrsIb6LoNx5Kub1XU98z1ZWxLEygLC17ce0392hbhkD5rpshl3ag7Kq5F/qeIU30FfYnCOP7tHeZR7DyOLgXJAbO2OJ5l9+9N/oZRUm78P2JoOJKa3vAZgoBcG0stu3rHe9zz1NhnD+tKBYR0+Hxn/AUCCDWlx78efQjVsB0F7p3PQLhtpNusS0au3qg/pvBNCV8tmLjIOknyYMM9mDM2mxZ31eymhv7WBW6dtfSW37l6dpIdToCvMEAq+Ktt+t56jnN1CQRRLm66VEEXi09PEbha/mK0yOK+noaplSUo48+vtl7vbZXNli8sT/ZDibnkY+uwWcTJJNie6aQ1sRMVsOFfMudkIwWaZGg9gGFwgtFIZ/mN/+rmn4ho5S7RAefNL7jbDlmNWC9WCDvDf0A9zOQpguUJTqW/wJman+NjJQ57EYx0iN4LPZNF+uC3bIqETGUShaewSDn532N8i+Tgrg1C2cb12Tv6f6ZGc3YYt+dkr47DEoErv9jG60ACTAvmrgv7D+sTG576XMBaoMchYzTUrWzENupgcPRCWlj9JqXQLg5Y4UCjR9SJNA6Si6bUSj8ZRhpVzusgO2eRb2oJCHye8kKE5WUvhZE3iObyHnllGqfxHaoq7WoPVgrw5irFnFJL+FKkFWo3dg7w85YsGNFtxzWccTrQKe6fK14k7mapmINM2iXtoNG0r34eTyhx6h5VmwfKaM7oS4iFA9z5oKVocqER1pTQtENOWrcHyym/nuefDiomTjk2Ah9dwSIpiG29DROu/Nmc6j4q7988n/GPOmCUJzW8ulovhpZRi1ysIv9KgK6U9D7peBaqVRBo/h/cRsU7R46QB5z8bPuwXcXebGSZ11A4eX8HLLH+h2CSKIM6toDbEbQv6aPBvV4eucCzdkpaV+tFtAgA1AssD/kM5gdwRh9IwvTZgEHVi8TYJilt+d0xLrnmw9XOZ1Y2oEjcWfld0wMKyLyF3Wk1sDq4CYOj6SRUz4zCkYZn5WLnI+J2UrEdJhkhCTAt4rJszJNXG03V1rQ6v5E2C59JFp4b1Fd3Z79ZB0lxEqYD0NrOZjPWOSka8DGGPo3PbFGFR7QwPo4pvBoqVIjkJFlyzvDHzwC2QOEFztE4WSpLk99ISnhDvqqv+ETrjkeNba7BmxyGYIe/FJOJxq5lY47iaHCNVV0ul6sue5PiKciFCSsh1MsZzUFqLE+e97vzaaC26lBj7FhElHjB4ErVL3ZAaRVIpDve9mcL91Xj2YKs4BW4nzhONxM02uSqwxiDZ94MkqR0uCkAwVD3yaJI0MxWiMddChbiuD9JlMIqoJFCUWJGFaPUvTUFNcKhkoY+gFe/hT5Qe1lGx7YYmk6EljJ5njx69inaEYfeBiIr7RJBTLxiYK2Hp62pvBivTv9b3QNpZYh4M4IL2fyAD+a9APk1RMDaFThWFHQ4XKkFeWtR4Exe+N1JEoE0lwGoK/XFjOs3hK7nloFksxOJL+RuhzUPj/9GQ2iv4X6eKbm8XUw4oA360kIEnheq8C8BBzub4U3WIx5PlPYOWJ98YGpddBvSxbpwnGmuK6cCQFggYJP9AJQNe61RwxVCdnFBCVB7HmH22YdIrkOiTj1HEdiKXHBM1V7RHO5s18kqDMkh/bb14HS31NAJBVT15UePT+N/jyczzFJr8mLqfnW4X37rQ2esRDggksGmCZeHrF8qLPH7IxexS/8Fp/9z/+0DGXdDvhB4zZHetZbGQFUv+HHHpnisMSIWF/vPJsLZkMadweXSyAaCzvgTgQgquorToteUudpV2f5RtvPm9DTUjv81opW2hWi52zTcKagbVE6HIzlac9eGcrxjJf31ODFnjRsfUPjWqOhvXtZnjOnPvIiibs70c3laSjzoSveweX2VJVO9yTre+6611M0/ssuHk1HGnFlc7UhiRFH13WKiyPnAR8zoIPDCRq52Pt6KVy6i02GYe35HLj/oNUebhVnsl2HiM2tXXHc+1HUxZc67M3/nY3QW96lVSt7vtyzBQO0QM3BaXrA9HLuMa78qXLaXHe8ja78sUz33Ef5flz9A1FlV7qzm/2AVtN3/ksi5hiJmztW8n3bud5xhbKaSGxurkbI9PrOYVDIP71j/QehBZRSuCurKU5S+Xzx5sbtv9dv70oxMZJAnuJof0V+WRArmk8HZJvYaehOzXruM7punywV+l4fGf8h5qwZxJMNl5lN4RXcYPdVB41Kn3IVsf9B4Ddw7Ap0O4gsUlQchdUWCX+vUtERYv7O3UJ3i83E+zLf9bnL3Ya5cs2BpFnZqJN0/1TNz57b9hioGitmzujgjhrXwNNAtgF5PJb7Xe3sIJ+SFWRqmB8pNc5g8KHHr+7VV0VtERCXMhNiAoFBKB9kgOLpVwaW2f4D184EiY3Mx3HO0zwlVQyS5YfYFIfwxB8RMJIER8oek5rbmooqGOFsoyY5zR0/zkZt8BLuuHZ7HB6+RAUpfUDEeRYuJlhj2FB3RxLKLDb5B9OCgRJs7jfl+WAa0X+ohh6ScHD4uj/BOP6q+w6tIOYSKtC/P9flrit3RwqAI8Fyl2VhZD5gYzG3/sAe39HDp0foUgH3EFdshnhXwGHVzbfOuEuw7q/Hn1LkIvaxCyfiJIQ9neKD1vk+L5hLV30wagjvdFFb/6SNkHmZTltWwPL/nlJO244i+ipsRasNRBaYdkFHtDJtXDIKjseekTjJqMMDF//8t5R75cyHCZAHSOQtwYQ2mmISp7bhib39JQRef5Qs5qwrOaP3OvfpXrDXd5tAWUIPFnridkkTftghKV1XuehvWTNyGctidgeIV7Ql0efriyXesrCilLwa25lAL900n9DR0b7zzqJdKBtUid/vOL27YvTJBIdURSEd/Pt8PJrnncSCQMlJN9JzqR7WnRkpasB55gilKrDgUBZHr1Wnn60Fi/qNuokxQaKy+JL5UPrGFnrrfxI8NXYHCIt1YRIMgM+qIYW4wrmrQYE7G+EIsvxwjninoc5IFrUm+rTXsuQ+U4PpeYoZpSEUfHwr2CEsPH+dKztHXSlvVIALJQD5ah8pe3VF+I5QQgEdm+ghO7D7xIiOnnilaYEBdpx4qQE3zPJvzkjQWEolcQeE37toBaMF+iNgGfx68LGmhCStRKwemr6Gk4gA/2l04qnXjKSAbp8cKVcv/2C0IIuUYoLGWQKGT8xNDVA6ked/RO64QJY0PUx7W3SCrtIbvKEPuGbEns1lsho6npSB8IH/tVbxYUZ01RQwybkaIe5vVXQzBl8t2DegZ0QK+0saJLfghRxllq69f+JZqj0If1XX49ThxQVPd2XuUYAg4ac+JXNvajRykI/Rtb10nqAoS6kOWlnE+UySksFO9B7K2/abjpHvHPHDI9YQq/AnRQqI4EEtS8Qx8uJ2P5sKB8Zav5+7dsTkG5qFX0ivWKSMt8qACOh5/Z8jdc8BC6ptLu6O0FBMuu+tbKB6+ZQ1dAQTQlQXA26rEQr2+9cjI3cpNHijyY3mlIQCPEXCHigSldRhu82CEvhGGqXhGLZgJBTQEISxiaT+Lxenht1w2Y+sJDXOUwuMwWbVZey/Icav2zdu6bdX7JSMjKexzlbe9L50K/8WeA/HYThx/63iw+QDWpBDXeQFVi6T2iQ13Tnls9RUMfie7wGlkW1YqQTI/4awnndEosw3PvB7ZZdymdpex60TkP4YPoCOcp7SA4cIGZ6hXkQhW0RvC1E9woOIz37KALY+DrLOhO0pBvIRMc6XxgoOupX5Jx0Uckq/WdL3d/Y/uGi3ik+M3HCf/Uzfq2GfHynPCHeKdoPsN1/bv6yz+9gykIbwkUND2EQEuSFtwIokctoBlptDLoGphEEwm0vVKtcLlvRSxaK9P2GkFR4XaBv0osCPa1ZYy/oWneL2HsF1dpNcoQY4PRvOPs+IcJYZ37c5KDolhNmblp9czrw/WTlXJsKn/dWnkHCfq7Q/j/qMmUtSr0FgvBVr50gobnWHNgO+XtPFaX3c/Lg24HGERCj/wMyTzafVZz6KTwmi8NkqP0bdTZ1bPhS5PcxRXavY51rLIKmbHvHDLWyD/3wH9sQ4CVRlsoLh7ixVE9L7/QldxZr1zEr3341ZORkZQD4KjA0qKv+2sWADHG4a6UJAzP58fpsE7x+4Ze1nTatyfU9MOTemaUK2oOhL2rs7kM3riwyr1FQ+rak3mPvaCHYXaI8G/iUEl8MZzq25wegYbelkTCuIMMTdVqgCUa3VVcMKzb8Idv6VVvScJxuzfWvUz1PMLBZoG3XD2K0Y5vhCfavzeUudNx2G1t1fLoQ3Tho3UNJHryU1ZAtyca4fxkBexqD2FJ5NVdU4TFzR1sChrD9zJ4WJwWOCP6+d9CmbWc0w7XTHutuK0x88p1/ajxFeAnrrdb+HQ97gbSElXJywsL/VU3aM+dUYkiCLpHu1pekojDN3qrBgQn8ibwoO9fHD6gxn3YFd1bMc3g/15rVt7+IX9t4/h30drLvDwOqGaSC0GT8EjKFX7yxc+1NveDWQcAY6jbaVbKV9V6P+CFfKYXfgoQhyivEh0Pfxl3nqEDTbWdXxTir7uowvXArVqvqrHMwQTsAO3EnzfWnSa0TxKKRT6QfMON6p4nIuuuEaypOCXzPV/JCegTDagL4r84w4Sjc72LCUaoD0dC9cZoKUyriBgxqXWtFkSb5U0S3b2aTSZGURAX0x7ax5/thZZ11GNaLMHASpr1deYuDmg50BGMR1S7JiJpG8Lp6OWX+sHoScqHvktqlud0xQh4Y9/xFYf1J0vq7IvlCkYF0pT7vpsZsJTk41R1YVqZFqS3FbBVOWlFVXncWjexI4bMBN+jbuVNOusuQUuDmoqP0OSSStArZyQt5D1gAgwEepyyPxxURse8AsJqLrTkTogAoiQZ3mQvr/hrcxnWDW+HetQQzxeVq+E3MphYCB7L0HyBErjM/eahO6TdJKsyydyN5Oyt+TQQ8YligiNmnxcHZfws49uezBcj7m2c/asnsQpk37ur5ouuIalnQh2bITJxcnG4esQkQkH+KNfktdNCt+SpFoC5MISREkjIb8boI5qu53I5xOfEJsWjZ/oOvYoVLliguOsT0a3GAxQFgg8QxPE8AaH6wip9UuxFJWji/t5yOGj3uHRBFDe4ylGoJMM/RyJFtuE4/2VspNO8BpmnFge9H6SFa2pk0j2i3opa78x64QSx6W1QnLj2nLd+ceXv8a5qPbJboJerAnqoi8eClAWqG1yQPzs0OTbg5ZOp+bj0+ePN/q9ZVoMXP9/4U6NK6A5MhgVp9MH8Vd99+xurbUAOpYQMh2ak0IBywojkeOOO6txWeu8mX/9VPSsIheVJ2i3caAfQWyoqkHUGg5DpO+FjSL6NFg43lmu0xH5Q7+r4semTWnsDGkx8cGqXP13fA7GBqMhd+T8rTl/zt/h4KoMpfXSfO0//88/RaeGyJKeK3QkEWmXa2qBnoOrgpkSs7kG2c4wrej28X4r6emK9E7y1UR0Y31CTPnm94rRiwuxrSjcxdbkDR53F9binxlCo0uhzL3HVfDKW+asLvbwt8i5uFNACnXXuyx9OPnTO0xTIRpnGC10mrYq2e9QZwHllomF6mRTR9ORcbipUtVPL/oyZoB48HSIwS4+LO09PtdvVJHQdDg338sJXCYwtC90LPTUV9Y6g9hpyPeFnL8metFL/SYqbLLQwZCjnEKmG4SLXRFXCVhCldQL4ZiSl40Pdn2AtAiszY5JtvdlicrkLz+w0T3dUTJZgiPUu3FFBEXVZipLYFZo/alzjIAEvnR+6sZhbP6+inmD7q8cakcpBr2o/u3EniWvQvO70/mMl+/rKxw2yBnqSsALjxzdcbmF4+z6p8y4vcPA0rbcK7wSoRVF0PjoZ8m6oe0nxrDukq5yjRFzu8iJB28gbupqU/YbSr1LlyVrQSNbw8y+CmbSi2KXgPD7aHlM8UcBZE9wk6lBCB8bOzK5MYz/QW51zkdWxGGmOyJ+DipdZt3IwBjkEj0HGccO3fiwT+oBA79W4D4M9Tc51ljS3+s6PS5qmFNtt1P09CSert89a6XusVtdvVjUyVRgf391adUftqwqYUHDbnXwtNS6bvveKXt9pQB4UDCTu0N+gyilWSVvd4h04aqXbDlJt094TTVD6vS799DO61ofqlLPEm782BscLKpKbk0XlPPRO4yST087+5LAg2USzvZVnvHDXnMLvFNhiDtOz3UVdVUuZOGBAymoFCUkQVvDhi90BHYIhc8qe6v0vB2VfNH/EZpCIvS5f/9WtBg9vJVIRMoK5qtbY4QKNgTE0nF8Ki73FFpbgwUSDoWiEXIiDxrHYRWMoFqNu1XT5fSYMwQekN0I48ZULuUnBfz85uxpRloxIMUIPhmPzdp8bkDHb/JAvpclOHqSJBw0bEYXEQfSJzn/ex7rx9R3dqrb5h2l+5wW2MnYLHvlDsGRDQlkh9Ppv4PWqCI1UX7s11PsmKEg2G6ik11hacFmLdliytTqVisp5R9EzpJITJE90vt0MTuzhHL6CjzZzDhf1DDEZwpv1uvuljknYD5bZmUcRO5eZxLoCTb4dyB3WrDFZJQ9hBn6rbN4gtoZoS09ychtdsdrRfQNoT24MATVO1P7W9uhORMELZRtP4w2xXpQLsMbZ6dqTQXACDNlPAOZ8Zo2K+dO8X0XLCxpmyVnmq/+60WSW9ZYw7aoAy+vcAAL6RHWJG6uNYKZ0tzD0NV+q0wMYoaegHgGyW9uD0B1XNML/9ArWUxFJK1KB+AYdggQVpt5SrZ18IryhXwunQu4Nh1Vw3MgejWcAuREEfGO9tkr5yuJPatF9RJnA+zdMruvCoZOcckoM3t3Cj2WAVrYyGgqnbADsG6n9P9OMNpV1WgJ0Ivp4rgeU6RLyNBynUrTC4rXcDRZDzViWK4cNsQXLRInewvmjgM0OCBeycto36AAgo42BeIXFtMGW7X8BCqEWjRqDM+5gennI85tDDlfxxg/2OsVvuqEd5N+Kw4LkvlWZNVVYvDnWlEr4Tsi6qFHz0022cHQ6MIq9bhGfac3MF++q5ULUksQcXcToXjx3qIUx1Lzgf892rlmg2VkFuFqTIcq3OOHwAgeFfB+FlXzVsdaO55DKglSnFyuT6Bhh/Sw2zIRyoIEsHh3QASDiLBYNdX9fUsnYFvgZiBSU/Jcw0whLT6xTKWUSRTGrV1hh+FZZg6s+5RY1LX1K0A347q1o6++zXUHmJYDNlK2q20xVdM57/UgtDzQbmN6lwzb0bJNkCQaqCOZ2kyXshv0LPUKbbq6JjEhH7Kd6GtoBckqUSpTJ8eL/p7CkFHYTj/spfqCbDOaAYAZMk3ONhUrJcEKM+YGKBIQrwQTQc+EEhifoNQE1uV4VNHpjpDLtE6eW9ryVox3+y+8fImI2QDqs9gt/Mc8vzkfaK7gCrszGLeO2fgpVyjrsHlI6dKH+ztb1tIGV7l+/qPUduAznjlHbZ53q9S0O8gIx4T4DUhvvhhcThynfBsorzKZxBuF4gLe9MU5ghg5dVSiYhpt3GVMEOyQ9/2wb4iRPQ8E+y8W1wuXwZ2bM17dhoqsGG/zoc0ckTYLNaZZoAmKLyxmKFKo7mxgF2aLqm5eQl4wqnfe9R9FDSCMjjvIZb9fAW2cmOOzY/5uXEBpYqKLc5JOFEBpAFU9H9oZE6w9oSsUDd/aG+YXjvrAdLKtHEr89S/FKfK5hVimxElmtcNVUKv8yspiYlUzoKcop1AIBYF4tX361G1454Ac/3T9V0h0U3fpEuer61MVis4SGPzYisBqNx67hWk9QRLZTtbR4EdgyV60dB7FELyG7znvzcE22kJ9LO3v7wTeroGmW/p309H/VHkbO69WE1VPsKylg8sPUvxjdCQKkCSIyGkI6kgXW5vnz8UNjUUda3HAma8nN3q5auaBmR7U6eswpqiQYTWF+napnFCocshvjYJTtKwHXSVCJH8/AJoWIdK4CnRKIQg28BWwkG+5BpXa5yt+ERUgjIGaqr6hs+SLVC2r+j2XUIzWqSSuvLlS+WmOJ364OaVd23BSTYYkMzc9JCc6hnnHBm4dwFiN2X/DOq3ws07W1LYwBcK5L4delPsIImY0/W2+85oH7v6zEg1x2D+C2BTcCxnWxk5UneapQ29QdcuB2Mm5yXTQUPqikv0vqUm6QlrmbrLRm9X7vM6P97AkT9i92JHMaIM9iP/IfQZl04SshGJNYB/6ZtcChrxqQj4o3DMjcMM3SQxgMmYHxgjTPSF7GcmeFC+sJNO5GO/27lv3Vhf0taCS/uXXq5KtAMp/Kg3nRxuXwZp6U6FXFORChAXD4M7sTSqLyLWwL8jAFoV4oClvMNUE1drYE0vsi9JNouX68S+cYLgtXA66hZ+8yy6EgJHV/ehmFHv4p8c0Erf8iw+YWj8fCKHVgt+q1pYET+0Sxcq3AHG91fcbDY4sDK8Y1ijob9Iihnl2w3LZER0afwhsM/Q4w2ghI6a8eVHJ8/pN9dA7RUdLpN58KF65m7puhlsFm9MKYA0XeeYZ/D5SXwFk+neVKUf5J9iw1o6LoQCO7XYEQiiKSOE5yHPmscVcDkHutg78g9FzqslfBnh2BkqyQ36UiYfQZln6MUDsOhENpyDnunHmGoiW2LjnX+FuMr2/bc1ADBwOOwiIVl1n7egUBzGAYTa5o2bvN4U4eHn/oOnF1jOmfeB7IrkqD9x0greAtvSWncviP3WQ0Hlj6aORuKbhnHc9epl2XrxNENsny25AWpGmJrBq/wo6XoyKDRtYqS/smSj5lKefev6J/nwJCSvVPh3Oi6AH3JmHOnvSbvERBCejC+AqCcS19rHicF+usNy5XXJ+Roa0MpmPMUA84SqDaYC7iOUz6yFFaiVn6oXF4YMpl+1G2Je2BLciTIn9AjSGcrKzdLwe5L62KktyrAfNCM6k0B5XcLHEg02wsfrErQ2yDi0EjMR52GVqpSQ69QgqngYDfmneBwXxZflcsfygc1Lh2Bxg0xGvoT+oCVX7dPnLzrQbz/COQqngbawLC9zUsvaIOUYEI4PqWiwalkzTyCUQTF239SEi3Vv7aZBIvxSM2Raf5+sA4cU6Go5yQmug9rZ1+K8M5qUEeIBDLwKQxsttZtHvf5HSpUkrM6sGPudr+DTZ6pKzluYnpmdNpULoZ6GFxpjcItDlmdevpbHbwas2PWFXs7J8wDDZFGBIX13lg3F89tO5iYtsdJG8kKioLlk948ZiQSYnLKhAvh2DNO9x2Zvi7Ft3aHa9GpY+N/90837Y1jY73CsGy6uX4mXoNXiD6dMYswugpojzqwhPpHU8wpqyshLJVzab9cYsxuvaIifbBuRgPiFeCOMcXE2ZJeOm2EIhE1+Z/FW+NUCwAAQ6BUtD7y2sJ+yGomL8buk7Ye8jxIxyW2+TXXmRHcDwL/+oriP9xrh37lR58YQtHUjfG3OkCqW4ymvqw5lDUZ7EQj7HobfNPzN+TmvqIsvm3qN/nH1GwRWYGb0HB9pAG6wySVEF3a0yxQM2928CYxaNa9v5C42YFwamUt1Qp8FaJmfIMpWDll+3e0gwHsyMJkT0EGK6UHHwrBkQ7IBN2GE7pQs7aybspTHALlDn/z+fptyo0OQqayzwF9IXgVL+janncE9XAdKIjrY2NWTef3sPLhMsMknbt02Td5ELi+mc/mwcGkuQzIZCHaAutTr8xiS0gvpnKSWCkAZPck3wx3KBpfn9Ed/5CTOzEpdXSW/MzxC5TWMWAvyW6mLN7trpWoNkJ1w3HEQkf1wZU8uqOzmo9X8/QRgncEK7wcbXXb6FGx0KjgGNhd2qF00gKEQhIzNPTNoneoca1m/L7vUyXuFAaKx+yr0zGmszyH2iHlEsHnvraEk5OuXkFyild91hBUYZIil7u2C5udxcu2F41gI9iQGi10aunAmGlg+priiSvZ0H8lkceX0S6p1XZEXW1h3WKRiYWBh0FwVmX/2ZOHNDSHvuI3eVsLvy1AyFEwSJMRGctNg7ury1ZjyNtBi42njvV5uHwZfoJm1GKXgNiQWxLlb72GKJLrtUbZ+Qrk0c9lorf2A6gMR0Z+GP21Uqh3eDznE7IWF5eXLBsoMKSJkvaLEpg0zNxO0iMrb29NSxALJeujK5DCPPrGre3kKLRqtuwEuwgUbstsd+fKVT90XTbrLCB8Qe2AeqZlUMMgKb+0A+bPNZ3CAzYpVfBfbe+MxlEWWBuKsI7bKhf5XVcYj+Jql3v0DJJKZPMuZgbva67L0jFOucsowUHD7XeobpjjBbwUNRVtW3u5HHIz1GDl5yWpiNU8Q8ASOir3wZX3iQP+Zdgo0sE8RMYmSMOFi/b9n+9dSuHc0uc/6lSf2TZvpxkimxY+jG/IDJZyILaFOdwrGUg2kWI8/vjs+6ziej/q8/skkZ0MfiS/nslpwqIFTFI+LuV/N3bsoyExk7CMP9LUwt8K1YIOrxCG5N/9uYXvomREPKg5kt8pemo8z7XdtdnFbqfT/Y+5HkfOCAoE7H4EHhi1FSYoFq43aFScbnRkjgQ2r1tb4AcHUII4H1Uu7wtUCcBmrp/W6yqQwlJRtjx8pAtZ1Zz7LrSfUuCkZAipV1TBzQLZEty7tnGSmRvBodlFb4UVnLa8N+XaPWnXmZQcVTdkqgaUP8tOerG3QpHPU2nhmeybZro0iTyPk12RZfN4TLC1toG9fto9TGeaAn/rC+g820nhJgbmIWXHqfXpfqTe/z0BPVwQgmnPT06AvlhZg5IGZ96vDUeiAkAdOvFgDbwsa8LCkrvkNEeD1bwHh/XpY/9PYCNnQ2rRoXfWunjM1AIszQUOJjHX/DEJFMCwS9Ieknqt0Hs8BdyCEu36AdlADRqQTyiAXxZNMFtl1NudLKQgzRHAVxVTF3lW5b8KaFQ3W3QBkS8tZDqKM2yN9uJ9M+gTTpeDZhXL55z71AuZqb6zbab9I/kXxSb/ce4gIrbwIfuAA0F3YPiOK9dNsxG5Z2/sBPixYUgHM8VN9itMsuilSrbtjZufrOTkiDtUud9Ys1cEmzjyty2ltJ9GGhPIGHPz4auClzgSnO+p49j6JA93yTTks32lZFscw5omy5Y3B0671iv+44JEiTNpweXKWFGiTYIHjTL0BMAIWyrM1wg+swQeUjlbrPegbmLEzPyvQFv4l8PzShg4+k7drzmhb8bf6bKdMdbm42x8o8ANhebG2idOAbjjjaKH5x4NIcRLJtLVvkvvA7LWuqxzHOwtCD8GlxRcSNw4MLYDnQVxJ5nlfQuMVGT6TnHsidPij4AD1xkbsDeLtu78GKkl4MsOzC3xW5pCK6Nw06Jeqo9M+hRuYbJLlJcVk7yHiH2YWAFOaHHzQ5PupPHXEskm6FYY+xRsYDVoCW95xZQHnDzJ2q2cKdy+HqYwGdoEeS2nVwlUTLYQzueSwoKuFRMEJQ6cYsJIG/wh7kr/wDcr+vtKxanoHydAGMGUjIXDT1iPlgWOYrhrIwoqkk/aEC1MWg7X0jfg2QngxCf2JXmoLC5kuJDdtgghBg0gOKE392hv37SqKJozLwrMoTZlg5uXHWFeoEYCpPgBAX+8/aU4buOFjZyC544NRtDOPMjzjja54bYo2U+txYLlAx+M8cFdFLv9mdLUrdfcgJA3un1qo5HVkFxoiFchqs+NGqq5ZZ/OLUmKqd7t6wFK1VkkSj0t6tJxLQJ2i8zTIaOYjGd1JQomCVhjZdTh9oxhLhPbF9kA5vrGPPmDYR+pffk4bHai+jmR0iIyvMO7SuVpE+cCl1ouDP7uKv8neLH8jGBrceUYKyQ9I3OrDJFfe6zbrxV4GTeyZv+vfRgedDhcdYcyFzpVGpsoZEo5fRHEVwTQ97UVCIetoEYq+Cqb1jcvS3O51MsUeTX9uVvPqH1qqFiI98sBl52rFxaNBR1DacE4dPA4gY0J8/NscsfaMi9mlE/gG7XgskXIbSJeVYy8ygN7774FFksmP9MS1c0IyL53vyhtFzLFZc4sQbcBRmPWIEQfuR6wQpXyLOMvj85ZcXKeB3IOaLrYD5hjfPnoFf8d/nrauaipNnYcoeNfDxz8fdMsBVwlHlr82fkKUF5cMIWuCr4q7zBLPVGJ2HCOH4wXphzT78AcbwNMVLmLNioJw2p53p7+9uMGVU7CEtbH4c+YFHyLkkL68Pw1ON3Ngwb+Ol96v4mVmQfYKe3rnTUkX8J4xn8rXlb9uSfpX+9+abh0YNs+BfnmOhCd9fkkV4VaWwxXRDOEY0Y7MfAONJREZS4fGXmPAJoLHdEK082d15O7r6UFesbWjJg/GM2toClmIKnULmQcKuBuR1nu78dt1vUZNHKlT0LuKmx4ArduD70CkuE+/Vu67zSO1SB9nF0Q1/jhl8MAml56Lnsv2UVKCt/VMSLDyw0o9CEDVzxYzmHvB88KKU0tE7gMyYiQ+pvkfCBLt2oEBT5vpUNCNPCUWNEQ4jvHkLOYbsAMRi0BbZuWzmslAiA/KXqkZfNn4uABKwv3G8Hu/gXbvbbP0X3nXchUKs8gd6483zB48s4WhjnVPNjG9ZZWMebuWJBsNX1+J8BliFl7XE+KD+IFeN0itPUGDP4pEPlubivlJBNwKqkcqhJQ6E4v87w55q0dmvdz4KtRbXDYb2rYfUBI6qbIC8gpzvkIwTnRPNhMPmRAmAr0n26sSvo32r8Al/Z8oVyQgfkOmjkbjwGG3CY2DYh2jujuqHYqztyPSO8nHfImWO0ZFTb7leG5ZpkVSbrYP4wJf0BOjNVtT4/FcON1gpgQyOFdD10X9hff72e6qINV5YA1yUZOn36gvvbpurrUk8qlVY1EtotwADjxUZ0JlheWXDflAkr3fTDtCz4G4tzenC0c+FNqYd7soh2jrlqHx9f0NGnxealAjmDUEsW6mzHLnXD9SS+Q2z737zd+FubkfbBNnX+99rxflFIR3BKJ9VXfiatE0t5zZsDls9bZ/6PY6LofaOLgvKux+EqdicgmZEpTSjRyIouY9FAcDv/TTkY2+G8zKD9TuHMHlDOBnKIwcSDag18SDGcx9PfzfgTP7bQw+m4NRRt0dqoNEW6MmUJv9G1aGxM2NuHA7amuRS+D/flzrE7eqqbz31990eUVcVBzPtUjK1Bd3HA4C5YR6EgC6ZPiRVo2GPjnPjmpiIbx2tQIAMCTLGiSskP3KZyZDBnsrKogikEd/d7sJ1LJWe5hBHiYsj/AQOn5CHkyHq7RyLElLIKacjndmCFH/rD0RuMw0D2KpkLvqLu64yp5f3SW1Gu/2uTnDKwufbiw5RXwO26pVckQjSv2ZbyNXA96X5dcGbFEvacVdloVGB50giFKXvCrL/6ApqWGVcHRrTHWNo/1WJNqvCJjpDFzBohIeIkUM1KI0Xgun2iNcWXJYIivL3/U+XTDPChPQkS63Dk4iZAbzfmixJuyDqtxmD6GSG+QW40km0F/mtgXPU9i1CSJ3cyT4cAEUTPX5hX0NNDBm6Rogop06mPShjEOXqhavpKjjfmYNg4Tu9RLpMuTxn4Sq9yfqzuT67+5ZOMIQMH/ILhrsVII3dwdZYih5Fjv3Y2FIxgGVW2kcsRmk4vrtEVhcDKIe7kf5y8a1QUGytZKOnaDT2XY2vV0WIpUkvpXcCE/tu5Lv9tjoLyXJ6ltxZml8kOcTfOvK2GpClxT2fnofaNhYCmB3NRrnQm0bFolofD2FC5GPCr/Rj2JzqSyrBCz9j7UwWIyUYOq3R15fzUP/puTjJLWKwF7W530bWpj2vPl/tvkyjUQNNX2p5YY7XJI+JqxAFxm9ZPn0tKlpFZJI32ovsXLhxFQ67ijJDB0yBGmmeHYQwUj4605kK1+uFfvcdMop1PyZmMZzc6ikc0L7wIhHytf8a8zEwsJaTyWILJhU9STfbSWW15/12L7f49MhQ2nvARXclinjT0xTwJ5rJzEyrIwaLp1b20vlwB2HXupzWMh+5kQF9cg63kYRCEoWWE6YeCqMALgly0QO1+Khe/pwlRly2ann1VRkadOVpX0CCPh++dFxP0gUi/ql63EtbaAI+OdvjRQPtz9SXpeINBuC78ufdZfROhnqAGCAH4tMCoYJyZi4OpSdUtlMpXHGNqQzgYRXNhyVOnS1U4rWntqJNw5kMODn12rs9td/WG/+vk3/2x/agtsJLwVXrkgIHUFJ1a2FIHH6U4MKvgsTZ3dyw4xCB1P1Lcsxhtt0adFWl5pNY7Ky3NFJPkFYYGH8WjT3Z0AjpMURJIZesYYl9fHjOg0fcROHsN1StcP/n5J9FkHUMzxv2ZN5+IsHtFfE2hdcXHI6WcDnJYK9VTB6iBaqNheFxainlnSOdTpKbvmItges4xw9WG8LgLu3Xu24LPq58HGDoR0rBlRgoPGgdKyglZh7WlN2SDIn0KSWijEWEfbwxbTt6vSieeZBoILSQrEMVougge7jKK2OXJoqF2eJD8OFrs4DMQbwNN9oKW48WbAuZPPOsVO/yIEnZbA9NSIilbAK5djHI2A+2A1lKAeyMK5z8bhsPZnNqQe2gOqpHHEo8dAde3z3JHqC1pyyd51dddTJDuYHLCxz2OfJPMwkTqkTdbxaDU+OINeqhsa8rNRLvT33aainn9TqhcbuuGr/zgFTEJJp7VJtdA2nudlA8cYtex53OO1aBF2BXI1iYbrsH6Z0n0GurQ5AxfvlY7j/OFfqidbEMYwvEMs/zXyG7gmZnjQmYSc8i40HVsJEGsbCQ08yfiS3zHonTrrVao44oQ9moBBWa+XjbCn/L4oODTomKT61JcHXfTdDGlrPdKZcB0a1i5uBNsQLk1bz7jvGuZJVn6txVcoySv11zh2whCD6Ie8nAXekKmTQ4+Z3FbPpRoaNoy03Lc763f5MNGGphMuFstzNt4MmVQ7sT7LJFkP0FcZ+nV+WRdLjBThnb2RrXzwW2yhMsqdX0qKoClW4lOyIQoLLcVwtUNniVOkGM6NqyLEPASZ1d0BI28AomPtSLTW5Wq2ogCmQsQX8kZvNY6EfkHAtUdmYVVZ2dvfY25CVNDLx3YXbWlE+nRsxZHaxBy6NtgGiEkwGIKbG3N370+7EmmzrOaw2ONv1q+8TaIPWaRO3g+8wRnuvtCGbcqXn4KodFyZbrJXVMxOq+MXY6I6Gxo92uU9e9p7g1kace8K9PK7FPDCzDXkvXFApxhMGI/r11OqAJ07HBpwC3yy/ZoIGkhbhW4s4knrqiIr4+/wDUXrv9pasWu6BH00AN6WxUD2//nKdaq4t8zxxMu2RFu69J5RkTG9aK9cGrqfzXyx1lKw5tJeSq0dm5bmHxJp6BanBeZIk95LcQQ0ngkC2KiS0JpnCvWn+e9QXscHIG2CY1/LTRWled9ViNkDGPlY7f1xjEB57z2o/Bvz9JH1RQ46jrUYv4+y+ZpvZMDBFVQhqa+kNPRl0W3I4Kwodd8Z2YgjIkejdWV3YSAvzF6SsWOAPorzKk9Hab7QLSPzW89f3l6/GDJkdSyJfw/2Dk71NuDzHrGj25qirJ/igdzbPikVcIHFYMZBfZAGRsunjkeYzRQZBQZdhbxz4vprAgcaBSjLImNurRBkekOCqEYvtz4UUM7bAybpjV4JikJc1rA5aaJ+kRU22uIMPgRU4tyFTTVss5f9bCu5DSW2xlTiHkYxFY+5TH92F506RbEHpw9Et4n8ao0HhI75wxe4HLpUa8wlqOMEEsKn2guzy3QxLoPJqU1GsD6MGHuhRV7cI5088K67tkWpp06XZ6545FskE+MzyDWV3m88Tmp92faN977SeikBAqaxYsZF39LBrRL7sNQwie5banWJqpwAKskW2mm1XLkFSEpCHOzfgYJM6zA/dKQfR42k5iMKwO/RxlFj1S7HyKWHwczU/YSJl+GxXjuckqz4U72EAOWcf5fYjJy7WlgIdNQS4jutp63XQgNWdtByLhnrvU5hXIhIcbg3QvumB96bjoGVDHWaANlYLqVX4d05XtwiIl03nWRwkU2npkAPtWjqiYJjPs44mEAEFvNb4+5JX6B4fKJiVf8/SjK9NpaPpjWOICQ3gDUNI1r+6RvFRynye0XC9HKl6MNcE4cQqKfyOeTMzGFSzRxA0LJlkVcKmUNidCp/Mi+W8FJ2nrPQo4pdOnWxel7ux7C0j35ysC/Vx0OYCHm8AwOft8OEvLqcgrwfFERNFxBj6e/GoFD70crXGnWgR4zX3Int9p090zkrc3lkuzgDMnhIDlWdJ6u9Nehgop/ZA/CFqtHafEeyrKcKNGrOv2F0pF5nCKaazd6NEOlYR2WhCSN2WlrkAe09KF93+aaE4nTQTtxEsDOBxbQqWVKF388wK2zZMEP6oqjUFsO1CPoQL8c4IYlQKQvgagvnsxZFkgA4Bbae7oXirkXFpHnZsM74z8XHXiPxOzPIYoaU/KK0l/eRdar0+GvBbI7LFQ/6sKh+hxtG9GZQXCnJPvkjrks83g/IzOJpdEkKrgtWZ16b+M4bW8XaXV/f0e39eRvDlTF+6sOeP8EyhcRmUNkD/+hPv2BJTe2AG39SU6fGHWkGM1ajot0dVfZ6NElPTQeoC+QAAP+psOiM9telRg6+sg0kB4t+LbD/3NlAlqIZ5uZeY6exJdOaphQfbtgnUo5M0u3JbKef70Y1TQyb+6+vx7rlbCHFGaEmwT2nWV4OY+MxItejUSf/c0jF0oTEn/uoiypUWVvZrbLJqDHUpxyotzU6OCcBObyslSIx1qY+zepoONaLtWLqpabxRwxOkaxFVhsdfdbk1We2OvtK2lEFcMmtq67dfvJ+epxW6fvPfTvtpqQQhZrrK9S85JyqpF0uEwwMwMouok4d8bTPaEbhNgnzUIsjU23JR/p0iguCOTJkyEU11u9zEWgMFgWeQvdQnanT9Gtxy+GPhUBN7Zq3CR00dF1E10IV2BdPiehgcg7ctKQ2FNUT4tGHs1sZoXGL+zyJosPpeeV81+qTV8U9XJhmaADQK6F+zcOVlSWBIp8/BNbYopcd4MSvusaR7TpqrDucyY6dW0lPnXec4354nZtzu6a8rmGQXvLxJcyck+jdOYbASpKBr0HHyA0TpQV1JbDvuS3Uif2X/Ewcv4jmcoYqLvFk4psx8Kw8tAp8pZ/TLTmubrOyeneV5g/sEfm4DqWHs8kOa7/T4xRT9edmDNoczeL4jBq1JzEjnUQ5VfhPUVC64i0CW0n0+A1sZY6En9s9mvjqeSCrBiJpgCwI9m/wvgwb7WxGeWrRNWL1neSwxIoHIQ2PxM7jXt6sHCnSiSFaAYr+mFvW5YCL3jkiPbyLtG+s9xA9BBBR7YDT5QxWYNC+IUTeDwfRk6s0rEWKgic56MY0ZQjUqoKQ9Yik9rGWg7g1UK1Xj3rZ5vch8562uRvrEAphur17cxRV9lQY+vQV+K5jpPUBTFoXkMx/6lWowl+fXhm3kL0y08W3OequZClVBKicI/SW4WC8OiJoaF/dnRYOufLwHsrH1thPcTj2p/l0DBbZoIaAkEjtFf9xaVkX1O5uwKsvdABdiL7WAV7UcMsiyy8e77sfQAxvmMJqThsiOaWnpj/HeZAKjF8OnUYMCN4afrXJyRXRjmvslPerVltTMzx21zzHfSPGIk78gc1gKDuuYSb+jMaYI1fagbVx8iv3pccdBRQamSW3FxLH0DISMz+aLpaPi1JXQOqlNjwWqJ7bmp1s2sppp2enLxHhC0GdUnAj5CeW7U/QEGZR/SF/1fRzllHzgaivyYnP7IGQ/3wrH0jNTgKyfmsKVi9JUSAsJZ8JRXZ3zN8F80zkq2OlGXu/7ChesF/sLClmUY2VGI/WZWe+pR5huBJQ5+wQ3alnyMbSAAfWlVqBvxXCnVo/hWEV8Xd/Rd+rPI4Gn6kzrJUNKFXZ75vPk7Oz1zhGZMAK18a2gbBRZlWYFtNB3m1quWnwj2HshE55MDEeQ8xI/nlhSUbi4BXg1huB85Wm3lNUvAlqCaK1l9LVHDCCrv41sYX7yIQIQctoy4Nii6Rw/xYqDSRqmPxchVA9IMY7a9QS7KfuKffnWZVgqYmA7zplVoOdq9LMfVL3tSg24VML6DoTohGeflkFWXv1+MItRNJgUEZdgF9Dmpu1M7Gi1ycsjA5uxmv/NUha30tPtFQ/IVRRN3Nn4mvkJlEDg84GAFI3ACJuGPAfsPQujRVmzM4Yq1Eezc3Mk+Zgov6uY/tdluu3Rba3m1jz/SBQkEW1MzREbO8D0o+C/QRxiCBTwv1yIqJDEWIMHrg4oRjteDWAR6ZZYDwNcYxtdrkVR2jZ4P5BJv5hoXO0H0QeagM6PglfrVtawrGeYcHMbPrxMA8e6mJBRxtF7V6P9KxnMbj4pQblAiLx32I4G/Chz7kuroJIuYrtWdHRlssiVeuPilGCYullM0rmtgOd05HKR+qm+G6NnQAwQZsZoGtvambLXr5LOIZ8qH3piLE/vsm/dAY6Yz4WFuikFbRtffIFiVI3ubB+GdlpyGR171b4M/tSRMGVVUDVcBjM86nQVUlxkAZ4P2pIctRBBVacMxhOK0H2gREVC8IB5TWx8qc6ks/4BtHVx27k0M2GuPNRiQGZ7dypbY8N1n0aHyymkPLymec4R/0YL3A1EIBeHG+M7u6Grt5z+wEDhwqr4dKXrxg4s+/H5rT0oUq/2iFCe0qpui6BgXY0YAZEvqCQv5w3dQGMkb5bYmJpms8VEfwXHX+xRDk6lo50XVyZbUsDzLwn3dq8Zovj37g6mQXBR9dlENyyCdHnok+hep/E/BwSPAMRndOi5QQx6jvFVWsEOO0O/ILKgFouQhv/yuSHdoC0s6FLDgRQi8RqXDG9bgSZUJ9E3Pmb8ze2q+gNiJX0PrSJjUepOm9eD29rDiVkbhy26FO6ih5KJG8Nbh5uMc6onsmO7KcSHLO5IGNfkrRa7tdQbWA8EN2KpbB1HrOWUROkKqXCpfUYAtEcXVbDOfUkG5/RmcIJ8aVNG0iXmnnx60VTV12+42bpkHHzPC6FK9eLUxeCtIMLkzfE35G4AXFyUT2QC9vE4JaievQn84xdNmHV5hzWkQ9575YAdtb3kAwlqyGFUf1kBENWXqUxkrByG2Y64EAEflrQbi0+WEGu7YDTcjaOBaKrqdIoRyMfXmLjHusF1FK2s9MOEwtlpiEb9xYIu3IEeJ+uFRa1Nl2o+xFxdiLbShEKFkECB0I8YVk4HMbBXfU+wtPK/DI6uNGQj6rV67CpF7ktWXkf2BshN0aFc03gXt7Jjsq+ZrvR0kmFiqckOH+PjMSe52wNXndfMIj0qF17X8wzG5D7pibJG/cD+Wzv+iv7vN6MRpGlOJg+sJK6IFoCJ+lq2dMax0YjatES/N5G1xfdcXJBbs3WiHJPmhnVbbAqRbZ7yoWFMswsjqPQU/T6fsfGFEc+u3g0YvH9OdfZZnjrBjrM5ZCsHWMN1UUWo0HIHao8GamOdrAMSFyAngdMuvpIneeg0EphB2R8cwPapj/vFM0WwPXqggdU4z9S/SgRprHKDACw5bX+69PX00uyUD4ek88lgognNERuwnA9KpbCnwdrdeji1qR+JfQFkEs0tHcbXgTMoDykQo6t59NGdDfZ3vckCRM0TLMGwQdCLl2/ov8dLMtafjNZMI99Sn/1B4nl+EydhtAQgvSyNNDwPxeiCKc4JqN5P+Hjc9yStCl/EqXr7O00S8ADBoTGC/8swRy7SnRrO55gmhw4QLfmFMVqKVa1zIw4dB1p8Qd9tifnQoCt99+c2mQbOsxqdPbPfN9qnhjA4gxTKgsoNuHroGp3+lRQVaZKQPRaAV2QLxQVDXibsGhNAX8L08ioEx/+j83S/ZUu4exWF70Ynx/iXAiFu3ea59OMLaPCtkHn2QPdaW5DuzyaB2Nq1D7ULRpGvBKeJIZAvN1fYer8a7oWS9ixV/6nLwbR8juh3bNESQrGbql2pLiCK5mZV8XJ3dk7lMH885w/G+EI9iYoQ89kwqcP9oUwHNpKvtk/dlD8M5QrPwxP0dQJRPpvaOmq+NVRlgMS9juu8b4cHrQMQvQhyKp72rDlLyGW8WJTK/ODguIwx4laMTzd9dcCPPH10thEFvq5Tybr1L/Nw8pqwVSdjEV9lj7b+1A3aF9haM/5LH6bm7woHE2yRn3w38ozxAlhGFoNYEhYL0AO9rZwQjfYXUKlVKWlCaBxM+Yuo+1KHOw/NpwqvswYg6P8n+386ewezvJcCZnMl6sUwiz+wbWYIUBeVO5Na0a/AW4UO/TwZCIZAMOJ4Vp6yPBFf8bB4YeQu++iV6RnehMLLJWtcW56Feq++HeV4gDKbMq/VbbPwaySA8Youa5P1DZW2ZuKwtc1pTztjuwrj7g7mT8M5L2nZ2tIm/qa9sjc1vKKgee5aoLi4h3HV7u1bClaVbOyCMp1tuxY5gjAiL37PrcmwYa3bIHBLySV0QzcqjKNTQr5LR4u/y1QhSdm2/8s9W2RhU7wNJe6DW8Mx7u1BsXFFCx/+exK2iaxHm3PWyQuIiqDzsKipUeAI8SHkNgI6MQzdn6lw+vMjwvjn0UOgArts4B7UxISZ1B/4/MQO3OLDHAgXViJUD/faHRc4R3fdHW+7yKyaGuII/hMXVmV27S+szspA8KJzVK8TA+wg9bZxSArD1USSaXLyvGuMSbskFhhPms+pfKPQzT5PRI3ofKuWZHT3m4zr7xLG1tmtP5IHyjY8S3JJZXnWOF1MfDVXbEUWUYRI2sz8eI1ryBJT9WO24uFR3Ufaguo0q8tJQSRGAnq+OWyAXDa7sqKY1CkuE6VCOobYZA5oY6+8dSb4EDjd9zACxJJKVryUGSwvDw+9eTDmYLN+BuqEyk1Zx2Rnf8Ff2QQ//VvvPIBorRKNFtkuk9dgW6kWrKzwcoGddETile8ehnaN5sDxVMQpK+Dkw3neWBIFEV2g5GFTf51IOE9k1BFk5xRSQByw/onHT3hyXeDt+jAHhq3ICsXwMgmwFMMg/TjSwQoa6c7gKo2zKajtX0TYkb/6eFsVcMFnRCJUNTDv1+LvXC0GRy5ctTwCDkrBR1rUTlIYl/zCJ68Gpn+/ekKi/kdjsy22xcmzi7XtvkBR0FFI6jAt+/WZKxLkjkiQD+/vPOlo8tHSDLr1UADt+hyZN3cxoThDulyihf84F7GSZfgOZV/g3GB6vfwyRbiI5ks2wNviShB3YaivuST8ZbMTM1nJMNCqc1+YvqTsZ3ehS7ZJeHtf1XG5YA1E0JxsPjaL6EIQIFvBJw7QJs8XDTrf62cdG7rYgHe9s4B36EyZc2r0a1f5VIj6E+cSAakMmx4Lqyg6dr3Prmqpwhk5oK/hop8frNwdP6FSP7k/zHooqzKhSVRptEsljxQDEYG6RRuZqyiQ8y6oAFmEiUAVehnZdqmCdQTHRXdDxFW17Mxy2H2Hn8PhsLcBkJUr8Z8BnfQfZNhpi0GjGIFXWTKo3GgULExZSnlmQbEQXG3KMwRAZufKXVkyFFTE0GJXNDJ8RiD/01/c/3mlPj3ob+eQ3D+O9e3VmqV7/KfTPYYCp68XUbiEr3hyKzqJyEBifjVT6e0RG2Yw5DXtKOE3W/xOJqty2WbWPZ7nHUba6JG+ov4jxy2UVfIJo/T2QY6Z5zdgUJh91tX3VRjHUnWhn5z7We9biDBqh8X12UwQeVckD39DHFm7edUrxg+BRsApdE4s3UHGRM3ppLG+YvHjnFwTciDbm/Unknqi2sekmn49FGzlMfqWtXCyH+muUWnC96S6nr8hnGry/rK8ImecNq2NO/TxFPf7ukElyBi4ZVgyRZd6mB2uQkxak8oBztMTikvVX0pNRkWSdrnd3/x7/hL7ivxjTdDVwbuTEkCDnpnNt5S9pXWBbFnwf9yuf9y5otkaCY8gQZWpNIqRX0uqp2u1k39L+edTwgOgZkUcG/u/J4qKkLQQFggk2qgIkS+GF90l5LimhaUa6jP1ZaBICyo7gSOVeTz0C+1iqnS9t6GR6oQCOWCv2JUYEbXYJ89GR31Y4ehh2/jiSFeUG5m8R6xhuhBhIFB9fYO/HX2Da+7RLoJaLJv/hS24/MoIvMManhLbXPyH4ABk6X/rI+a88ubIcTV2oQ2wI14k5BK6Ad2bcQNBUJbwxHJmk2pVupEplM7tLYRtAu1dcdptwmDDTGv0obhOcwZPZJqoXGmthb5uWruttltTdor6qC8vQKMNr0fubssUBd99gRkQotk0yAs6LoYePF9uht3icRaEJYOY/SQb9Qa6GsRV3fZ2HoQSDAUovxKvFY2gwVl7ugJh2x5QMsdkeBd5G0betHWKWDkuWbHvVBWLo+jYfxzqXBZRjkg+lyXUj4s6wIq1MlMwgDY2UsvnJy3qT8KLhI9mYdZ+3Y8ZWMmVa5sXbHKFuFpbQ40FuOh9gtX/fyX6pdeQFxfxChtVgOVAaZS1RtzutpZ8xbVGBTneYvTtTrduwQEGr87tkkK1H6mHIxzEQNL8jYeD4BjW/kMZyHUat9ApNZ1YT4nrKI1L4pl6l9iDdYuPMiA9RRJzpNs//xzG3PiuictLogU4+Z1LCu4fvY6Q19EmaWVgOfVYrp7g0i4BHRglLkyRUw5Zpaorxgzq4YWA4f0M9VrtCU3rrAOXJuKYYd9eWW6TdvwXtcea1KQrGjMa8bFxTAwRzGlj4MzlbdDAy8W1aV91xkQJ5E90dW4C+NhC6b8qjwhwuNjUWinPx4s95EbbWBF1oMD3+WWSZV09cpJjje43Bb+TLdOETDPrG0KEh+HxJkF2aLbMsnAH4/1Jfq2p8hiq9eUQ6WrHJ8ukKu44x3vxNXZ/hSNZR8sd+6kzkcip0DeQqjVKM8XJnRBLbIRaAhl7ldVQ1lNHozR0LsKdVjrZIQloqsJ3VuXao9sPhOSLlv6ishaIyogKTnvxYe9mT3aSEweX28inf5MElkA2dnlNs6lc9TrUvTU0BTgP3PqVHdu4TZLJ2P+TxjrxGPZHps5sgH9sKoPHG3gbonFIj1KWMeyyn7pEBsDjEJYLSCQJPSJO9W2f12k0zLrV0u62iHVUUtFxJx+YXtzt4e2Dfjy61q/e0t0ekICf6o8NcJWU4q1SxsD9zdjb8CMcrfVBhU73oyi+aOsNUO99eBR7vaMgenTdbRM60s4y0244rHknHlioxcgO1Bp6zlPTjQZReY53azwcZRXDRz6fD8yBhMkJJGAiJkT4RxQFNHQeYpCqefbzlhp0tJtqvVY6Tg5WPXbScX7w+f+XakO1ZhosvAqNB+ylusUafFC1MTYQZEP08XD9c5LXDlL+bp9VH5w96oAwbihvXMiQyJvMzLbiKKwhZgzBQGZubtGEjLccZffaJGco0IpH9cgPT7/rC1gb7Fg6o+xLnJyPsUjXPcgQxgOOe4dU1ItBRMHlJeLkx0iyKaWQvX/Og88u+MzXFMpETkWGcbcWj0vATqB9653CiYUjqW9LGb3xh2cZzg2FC7sF6siHtkn9GFl2MWBCs68Byph6ubv6sikZR56Mvh8izc0vDLRbWB/TsKizMEQpBWuY+LT4haXuQZ5GJf3J2lwwDK/4i/H6ppf2x7E3da4k4WOsncUa2gQI2Nz46PLfOYJ7tt8ypbdrjMGwKHbSSzHHAOmfL6XxFfwCoe+RVK6qlgmZnBKxDdKu4ZyAO+kEpU+Y4UfNgpRWCGy4P82ySZSKPmXjzNFoo04vrT9wEV7SNzCgEpEZoCfT2w+PxEz34Krlv8J8TrHIP0cs/k9ReHYG6vH/vJQQY2V5lnUlyJp0dm+5M9OgiC5RUGNsLcrAR8WzcuyGl8NXwhflDiBHDHixDP0zLFbAKrC74JlIy/FlFIKZAOrvXSXlgBXG0suGPyEFaWQQDtLYpCuSG9xklJ6vmMVZTrnOJfxh6jFdDDfwFIUBaY4w7QqZtq3OVBKCuVD8clMkZEWRPZLEAk0UmX4nYQVllGrDGlFoaOVjbRKzAqcYxHg2SvDMaYpHrjVOXZRhPtGX21Hq+yua1zuS2bZKykETqQ1daSHD0olLqVBu1URmpt+sT3DTXcH/mowvBtLI+hhycKrk1RLw9WK01Az91TVtudre3w8rRX+RTqi6f2XK2ngc8hWIUIWQf4DdRA/5EpsZggvqS0/KFhg/zTGkQXEM1DJnI/lYRHGpdOkgNeEcbjGd70nrrpuXQ288rsp/INXlA8u3hhu7JedcRn8YHTLvr0PGnX+VAmSk2DRG6ofPsGKk2F1QQP3uD0+Z38InlmG9+8O1xHBHZjNSWFzIzvcy2BVC6g3U0nJZFfil5qUmGhhSuWXa6REVS4hrPxwPSiq4YI8J4W/RWSkAMQO6qcMAgaZglrfYQrha3H4YN4OU80aN6fZrHpt5jwOMcXx2PTeWuo+Zku0awyvVA4VotiXj0Lztiz2HJukkg4PtMp0p7gASx1u32ib9Ggs2Hi2P0MEX/OCNG4jutkSKzuFngnrI2ohpT796YVL1hoA1H0CKvYstlxidicarqoIZldEc1MXIO0vjwk6sMUk4goWuOZiWKhzzjHM+Vcxv7MslEtDR/LUSyzqkQJkPbrJfklsIUhUXHHHbboaKi4jRq/nOSGc0rXpMTwBC6A1m9FdM8VcdzRNbo7O8cuPAlagXiT2NFP2+FWPTdhyix+OjsbRVe6Y0sZlwEUqShgVU2SNQJWNF63vD07cDRJcE62Nbu2uc2ciqWKcUlY2NnpsZ3IcapDZ/bXBK0Vp3GC1O/QJgP1Dis0tgWBEfHWi7HkcvWrb2RICUuYewFeS30+EkkxHgFa/MoBBmc9Pu4abH+y4svbr+GBd7mCymo/fssTuK+4NdyPQoppWoJk1ctutQiLdpRDpsmZcZmGakKJ8apwHHoXLymQ64THX0CQEwDxDZ/614QOSzABdJfzCxsIQbmhreKFanAGC1hUF19IboSQPrH1ccH6UlWJPqRNyhbdcQyKMV9tXITzeWq80Pft266hdbtjhb8Pn9P0fohuIr/ZW5QzsB3xPRmdB99NEc32+OVU1nmsiC87Mi8KRPyNlpG02Hex/dLO03jm4EgdhbDhpL6vcRM88jpriX4GT1N1AL4ZtxAPZg5hsIYN0t1lr32Xov5eJUQHc92gYMgLaIIakf5OWVAu/w+SGUq+Jp+VKdeqaLBCNL1KA+BW714e9MtWIiojvWJ3S5h7cO/F7bxIe26+u0p42USm5lITqsD62k+7gfBZtQEgcRdnix8OW1WYck92YJamT4HOd4ymUxNv7ELWrMsrC80Lkrl+7wmMfE4HMX5YUClOPmVFunyKX0Rbb3JX1rIUb4Asv+W3aBa+zbEp6Jfo0AXrQ+W2rAsUQSyo8YzErmmfWharot1fwC6JvxWWMSzPG8L9XPiu6HAaMQC3z8BzQACUqAwoCXPY5Lsr0wSs8fIrWwq/dDrsYhampUIX43xP+a5mOBZ2ctcU/XoyCVGLFRYNkT46I+C82MsPENBa3TKl9fCV8fzMcBZin5ZyWy+Lle3xv5dVa8zQDCgUqVOXBWxx2H+LZx7ssn1//yD8RCpiivUxZ89hFyyoMe97xZQOrSMIeNTOY7Aa8pWrZ+B5XRUegV7aClfQYqs7JlDqnVJnoIVE3l2pGQnhZrt6R1nLyFWWECIqdaOcHeqgfWxOZFH5cfkPlWejsAkbBThIfhwRFXIh70y3eloLOVlfoSV701nSgyfI83y2CSYhjvnUnF6SrOnS4nUG2EWHQ1Ezf+zZTBb4zkxiugEcIikXvSpTD5cPidiG6/YUvDm54CHRt4RdJiHblb5Z3+MKmVuiIT/sgddzLiqh98UrYpFJlJa74EEOUghffszYo5sE6R2QxqBHZjTWCcLFHPWe1E/AcyRIZmaCi5dNC2lLi4RisdYVoAmG/TI4D3CxaA6S6+pFb9Ce1KJTDdzOdB5Qn/LLuSeKEeIE0sqt6G2/pDVZQOQArBfAUmcDYnMsmLGx7k1P7JoHGHSjGfbM9NxE84jLaeNMIyYykUCacM/AOoa4Wq2QZyMYOw2ChY7NlHbqswcTakN66tapKS/uXWd6HF7g2bjf2lZjKrEdwHvJrDURkaiFzoY+/hjkxAWAJWeDVNkLiYrZvnnCIw7GRV16n047/OsAKlqbhd8wciYQGFJwD/KXDTM7ey/heWyqctnL2kcv2bAryOk08XwU8H/xnXaPr+S1VId8qpx9D+oNma9qeiAp7JYsZmRhTK61mBGqmk6r2Gpygae91/OqKlSrekmDDolyqfRl/JSloRczycxgHs8COTED2FlcBTY77WEV8KNu+AeCaHxqdz5ni/LND++EhwzUxjil4Vu1QZmS9Dg7sP+qcvwDzlCrN6YRuKsmeS9rGALE1yfFPykENwuCJAszN5sFEXTXkoV59Y3+ecDEPckPnE03nQLZQ6LPD0d4A8Lf7KR+teYrq7PC6axO1qmRFdCWNNmElNrtb0GwSpNN6GsQHgEv83TMY3PBn+wndOvf2ePUdZXsSD2YwRnYMkiGt3B0m96Jx3zo/0v2y5lpjk5dGT7BkydS5a5qSdYgra1cdz73CiHySfuiXvWkTUVkAqoPcR117VCvmVUYwBKIwjppVNg+kSsjsTjuN7vd22N5ICVCShCZtM00eFJwgS3bMlJUNAv64E2IncyEt8Vhbb0DF92SruUAV7sUgR5NEZIiNPixXuwEAJ41SfaDlua6k6u4FAtEK4yJJCynSQIUOtaYXdl8Nyq9tH/T33n0kPjJCQbvP6YUDSiXyFo/fqgnvFsB/M30tQrnByvZcDXBzxf+jVuS+dqS3kRVeLyzurZ/gERjN2WafsPi06FkgqDwH8wA52SCZ/E4+VnV6axfdfl5LkLoVDb5i4wHtCZAQsYDQUt6LToWp8rXr/w8XgTj7VNjKvAx6Um+599EIFU40YY1Gue5YxFqEeMbswYXVYJI1UGifx4SpieYUvEFkXnWo6iiwTPsCAiU6o4DP6csb4PyPOEKLRgw0WHDbX5oMX3O6hwtFNwMlJqHC0mp1z/THnvOw3YWGicBFM0UWgdNP7CrV/9j+26onPALYAdbukgYX6XRSwP2zHOr42FM+P3As/rEUBDij0Mz/EaoXSUh7eRvhu1AgMG2jAyNbZJFSkAqE+VEIiuIrhBTvp2ASylOEB5ZkG7bzbO3KS1ebbjCQDio8zDnVgMcA41JoTfTIEfR6ych7KuTyUbcZrUeVLpItLnqW2eD0QdMiKcPK1eLs+x/hWuALHWk4ZPF63MTEsyMoAmVzrH5afcofSfCOb6hQejif0WTlO8MUBA001P7J2+XJLWIueOhWp2krYMfyt+jGYMUMvKJQVlSfoizmu4jP7D7vfOrvW0v+nuyaFG7fRZmBi4rAa8nnJFbk8nLY0xM9aJj67pPI+lRsVZnDYDi1759U8AtZ2DGVhhCP4p33dBky77jhX98MJ/HKl8j6dsb0FnVKiM97SjR3E9gij/tQ4aLNGPzwNwp2P/gA5zkv2NkjM6+Nyomn179G3XM+Rqhi90gxHh3kX7QCKTCELUL7MVWQc80SqTk0d2lpnxB1lAOA7lqoo4MuFxxN3RbriNvOBUiHSSDYOo0X2i9YldmmT0nPoX4Rzt7sePBLEfMpolKzneMMX8kE+fLEfguRrD0CqOEXQC0NJR1IW5Aeve5ut+C0StLtqYZFPGzEkucCRFyqll2xQO/WH5wjNl9DMPJnuAHZmEHywaHSXd1sneX8TxW3WnvZI+3dhUfpuyusHP18dYEGF6Xxd418oGOTlAJC63iGAXMtDqeZjvVQ0+DmBwiCoZZnMI6Vm2wc8OWUOWxJWY+woaSl3yCwVH2PJ8ZYAC40ECfU/Gml36RKwDEje8ugG3xKZ+npuQ5Y6sDJmn5UQYP9r0Cnpwhc3o/N6ouyFGhWow2J6zN9/DNs0VcNlxGqjpEfCezBtetc6zLeYb2YZQWy49/2NAvUx1nkOOVlme+LW5p+h1WfJuJxxgJROLXYsb8wROQgMsiBcgogg5FB5YK03Dt6kZM/0PR848nIWQwxY/LVwGGlKzFnaZoizhBzLbUdXIAG6h64qDKgk/bWJbFVsKkjwi8jX2pBHXR5GLbUHKI3n8wX7D37wCfcSJCJD+jQmZNXH0ZTRPZYiLYw6amkbGUYT9iHcdHyDMKm4B9fuNtjxbvg4p5Uym+lJ8PfX2b2ac7nIfCHurAA+lisFm2oXsmNL471jDM37eZpskGSt1rGiyzqeSvvYTm43o46NZCa2UnG+urws/hpD7rozS6xsAw5D0ySBqqO3Tq3FFqaASaDgQ9bszUYw67mwZaxxLDJXMGyFpi/WZGlFXCt86H1ECIBDcSZGkHIHlH6ckT1kai4HlkpzR3eus4efSm5Uf9gzSOGxN93vduVjbqgAgTy7IylwFgtwSKtW8ljYdeS7T6QQUsYViQnh5ErlXE3XPmWfRQ5Z6hIZVZYoSpAz1WP+GTQdPWw4+0XubfbLA43FSccJzgRrqcCAzY1hFOTokPYXgznhe8NLxtmm7QBi3S7uQaoHb0QvgYhTlwd57cJzd297Lct3i4VyuBJY1nAduIcn26YzGhyuquvIJltOW3aSGRIddKdl0YBFbaTtNtAAEEypvqa/4T9zEMMru5aF3FNDVtMKSs/shAbq96wz+v2wzjS7JGhFQ2xGuJz8cagvVULb4W7YwK94sWj62rZ8hEuc1Z5HRzlNnRtBrzXzODvXS++XrmYKFd1lXX7XDkXZIbvHeQgzrwldsqTFO5TB54wZz2FUA/XE1KeX9Owj0xp/FAcZX8ItGw13k5mDxwtDcGF5OCCBmgq+n4fNXVfJIDaA5VeSJyrS8WWfRyg2ycXY/hGn4/1UtZvYlZkd5YT6ELUI7ZoTkcClU9JgT6NBpoFyguxhcO6StpK7WjJ0Eq9Ne7Z0rpSHiKSv5NaioGi6Kdg6IxwAZNqFYwEFsxxYGPUXTG0U/1xbDJHevkvPg+nboZSYHwBP9mCoBL89yqiqiOJfQ2wsmsbGWRiP7KC2BHgwioDweYkTFNBd8/TuYrnB5GC6HtMUciOlRSYJto6Ett5CURGtWgxX7iRjNLVpUL9Xs4qBLHkDh5scL5pm/kTOR+w/CB6NBPw24y/HrOYaKHtQp/Q7KDhpytV0ZcGZrun8dRJ20gswiumxiGTHAO5ponip6ta6CGdkCFVKcR6TfVs1TYRf0G1E3sMO1WyHaVFPmFhFqKelv5qRX7zfcDu6eS2SOHrTKoVKbOZlM2+SWGJzbcaZqabA6+MssYt9q0F06vUh+d7+06hwNq5eYhZW4pfuoAPvKsJ52E1BiKwO1pxxBtxU4q+CmazsZzeEI4M1o3P1bIXl9q1kzrLY2n0gIKfcoBbk7oBlpiiTlCxOgVv+/WcN2Cjpe40QBmAH0aBoxa1YH/KpjjwJSH8HCSaYZMTiBkiSFoqAbWy8JrL6vaZv52gZFE40nUORuHNmjqhfbf46XgD9axJIpZwsvY2dXz1FmD1TDGAusGolWyWB8o17+Ee0ilg+OcPMdFHdH/bEWg5sRdos/CkUxyx2shNtfFTEWOqKzpESbhA632G+0UZ0Im8Oe90cx2J1N+aGMUbAJ8gxkqFxYKs0qLVgrfh6WGsM3uGPUib88OaHm8A0PLQzNZUnqR44HdE0m4E3KuC0Jy2gpOqDfT1vvwPiqhQQ67JQZUn8/Xm2INSwaul62K7/1P1hJ7q4xUKaoZP0djI5OZ5JDyaJSK3vVsDoD0ZL+AcygS3WrqDIW2X/2Fz9ayUIadNjHJQyg95A88zjqFgHjDZM8QpyU4VXMqBWpJQb6XuciPXFsjCVyKK2V5rm65p0lyQOnPnxAs2aLvfJgNJkapXdL2JlBhgO4B5t4nuXDegBQNyE+RJFKexibaXvIzqb5hfcW0sDfiMy6ia42GRVe1wTEmHXCGnhtbWYPB1po5552uxORDo8s7vD1tOUix1ARu8LC7Nnhzv5t3fHZ6KFnVV0mV4xATvsKo3hpkc2xxliVxLltxl4t9d/xm5WDpz0ikRQTZJdoB2E2xA60Td4eliLiJRKUYe2YBQI2Eirbe2ey2AhVk/EByhrIhZSEttRfy9k3BSRZ83zEqINsooVpjeFOnKo1rcwPPCBxIpKlHBdkfzeMNafdtkpOMJLVPLOD4k26AoBAXvW6srrtoDtdEwdSmnMKnPosqdaF/7HH7qPW6LiutQkYjZDzKfoDiCsXs897XjLJh4NiHwzEovU8DVdm9hq69JoDWjkqCMM8DKQQz6LG4FVpzIgxc7hy4NqIQzzOwGb4ctQxeYsKr/ZSopsK6D2wkxu5hIUSMNz3LB3cPFvw+mmqXurvK1x5RlzKSNScZar16tXmgycY8IuAHXjGMJ5gCgy/NIzXjDnZa/9ZqpRFKULuB9z3rST8rzGvKzMhe+PaNcr78Dxi8tqWoSXkYB07NAZZ7xgA4zfqhsZdkDCRrQCxANYBH6sAtnMMz+e/SAYCzosiqfnVyx+NcvOkYad5CE+fPDBhelvTdK+XzWgJ6Y0Ut3wa00cC+7Ffad4j+3h65X2S2ccMtOd87m147VbXrqdm8sOl9wtD374OZMP8MGQOpjOrJ8D/i+qcH6X8TyMwnUSKRh7x6apQiNbE4f8P6j2vSrCP3wTcCPhqHZE78DE1eUglOnQPNcrKvLu5949oAD0WfPQdNEgR/rP9hOKawfuKu+uxmJDq5IJgapNuC/V4z8RerqhB8VW5TIR1FDW2tNtSIFc8jBgNKdwo6OclR6sa3U9xlk1CkSvHhjJHKZ1GUgpavVO8MuvT9Z2FU2vjeRnRTscLnCEeK2h5mpWLu6jDH5n9RbK0C5mA+2oFwbczPKqpaW7Uzmgt1tyvggxMKUH2eVARUHrCGzI4Wotctu7ga+2uYVXsHiNJ+5QoK3SEcvcBVCLH4grtCNUkx+e1iIGDJ6j+aggh0pzVimwWuNfZ3xmT61kKACok3Zpd2+zbvADVnFfrggHrFYeSNJ/XU62yExO9u1Dm+FJ6EGfTCZYnApv7mKE4MRkBHhMJn9q9zqPgRTY70ioX/RkVAORDh0pUx59jyf5ZF2rS6NNAFqi9EwbakfDq6ZTdS+n3pdqHpQKprcegwYWdMqTP1XprjfsaJJa2ZZpJ7/TaKaXxxAeBSjPtM0wkRmZJG3yyh9AF2kocFeXj/79+iH4HzDAzF3olsbXapMZVXpAEhIutXgziqSf4rOf+XMRkU1rrveW6AZwEQSMuiSyHwzbUSfA8LB4sjbQhrcfURc30Axr31/wa9Xhaou0EIjEWJoOgXE5JOfHqQjyIpKPyitUuuQoCzOquZTXXZ2Mg3pS57Ww4B85f+xDtxzWCngHY/YIz1xbAufGFhX0I0wCCQn1mDCUSrqqStsgNPf436lpsyDs6/CPEiTDDlcLnK0zhqSouxRIfEsXruY38g8HAP1K9+/vHd6FX8aH4pKX/nOStbrL11Yjs1nIh75vkI8v3HrL1Ka6u/bGjK03/f70V7WsvRl+8t4MJmAUtUvNDGnwQ7ComUR8+g+pKMz9CEvTr+SkQcyJNPwUKzqoHqB+1H2hJ3iTzj2xF/msL1jnL4ZdOv3unfhoysgYI9LmqAXdqOHzuCG/I4vqgvM+4VNmy8TXSgfeR66yiUo4gLJby5TBR68kNHeHN5Q4usAY4zZfp+u8iVGMDCuMP7dRB1MPxT8KFVMtDSc6Nld+j1OBVj+8fd60wVYcH6hhUSETvwmDbAoEv6qwqvgUAMpaDq2B5rtzv6iqOpApYD8EM0FU0TLTNh/soAk9e6TiYDq2o0ymxKmdlC7nhpEWeYDtemfyEAyGn7EpcWZkAWkHHsWQ3UEM3nQdi5JsY2NkkVcy7rYeOvgkBIJ55+soMlEPRjg+qsVkvH95Nb0npxLGPbfTGTKkQ/XxOBlBMZSP0BqDeM3BrZG6+xzXxqz27HnvHwQHE6CssbbWqP37n3ygGJ58Vcm3KN+uaqWv2Az71gAJIMzXTHRDBwotq/6XB6cBthRzSvDJpQ87Y84D2qmuRotJdmEEYxYWi/JiVDAD7vP+ieoxMJgc1yGL2cuIFQImqL1TCGLgrteUbrWmfICMl0bg8aBJ1alC8n0P3U0fGNE5s5RsXCXOk18rYx4hp97pNU8NurmLW9hYMYyiMsNQyEn18GlOIASLeN53ReyWNaDGYVdnJEi2mej4VQkmAbxO7+d3TVIUJDELbZIH6ImIF45XEz5DJkXmU3p9M/GsdH+57hAbZmBk0GHe072c0yuLqv6ZRKB0wXlnjDD4Agjd8yMuD9aoNaegk3yOT3NuN8Zhp2oIRCw5ih5k62alPKppyPodJ5GKIantZycDmI6m6oHaz/EVjB9cvy7MPK050M0GAx+HFzD3VaVUdAbRa/CZplKzpo2WY990amKFk0OxwzXUnDXFp4SB/N9+1xWYRATUEzMEQOJ1y9qVHVsSdlHfEtjSnPNB50uj6qtO7CoNLqsVqXwNx/fMQUHIPwPCbcJFuGjVpP4nwNsIHk412qajqNm5kaqV5dWIHHGKSkKrqiRxpZ3BUjfUPuIQVQqWUeb5FHpRJypM8vOppn8xmpfS9cc2Zraj8/DqoHVt6ACZX6U+BvKMEA0qI98uZn8qXQBrFtkegNhYfuOFaukiYg04gE+7tMg0u3Zb25Qq3o4i7FZHrZNEBhixghWJggvk1ENbdgPPGt57mpSmFkWZGAU1764+kPCKL/rgu2ifaV4txNLTjUy8fYJ2yspF7+eABz/YxfNaDxCW7tB4OlWvMzfugfoovHvUfsNOtYpRDCPQroztYHkRfXC+q0HZKA0hKNqYzwfNmFj4kvc31EfGPRgDUJQbrLA8LLi/ndNoERlD+dFZRtisDgL396pFvFkzsxHN5RoFEtuBxw2xdzalyq/j9R1ce71inWR1NH7ESTh+K6eBnssPS0UTYO3tpiVLDTduin259AEiEBGgJIeqTJ0wCnViiJkzfEU6D5p0YpMoYX8m6U3sNW7zr5VxJPQKMvtHiIR1/abPv+LXuZDOGMHwojMKTxZB1DHzWGLW0qI17odHNEpOYcYs3It7nSVMAarCx63jmpOZn7GWR7cVyB7FdUbTmid6lVDYYozS3gSGDCJMToh0cY/THkvH1Ltfgi72QlZlribZHbVEYLwk6iG+r+xVYj+ZqPKk7zpmzonermoOzlFJLK9ibVkm/BhnreMocmI7W9i+ZWf9QqaO54m1TcVEwtoGp6f8k1YKxhYS0B/Q3BWtDJIh5u2VjJ1W9RvYnHyDIJdOeHMQZZbLzgn7EP9GIzBMy/21zhdkuHpCGcRprAfjkruYEju2PhB6wrj5rjlBw35jhdND44pRH3iZsYJx810vo+CPMX75NXNJR3xUhtpmFeGJ0qGq+AzE8A9cKUQj3gNoH5KSzIofTjRXu1cVApWN9oyMO+eM5XijMJSiRRw+WS2TAZWCdm+IBugEcQRn/g/V2z+zZc77TEw5neifXeAjOoeOZVAeAOCZytYUHAWreNgULa9W/P1Bq+ss+iG+Zc5ddkVmKLdlIiRMBN7IZ5QfRNRyJd8/tPonXUfBHFRkAiMye/2yhiXopS1bCjC6zpF+8Vor1iyed/GFFo9v4SlaGOMJH+7arkZhwSxgx9anGoLgUMrLxRXg73y9s9pXvGVHRSgbioTIOfbkeegq/L1+iPdDpKjnp7k3oftsRGRnuW2Sn/2AkPxtXdH93/+aJyWZdOp27BqOB9CFb5/FTciuzd7wyydX2ynZRYzW+faWNtQzCDg8eyRR+5QODbk87VvuWUGTK/OpAyT4h76r4ijEiNlhStAr+fIBqMCRyH6XSsriiQylIyDZYyL+RbemZcMEd+prJTVQ9fSALg5nOjv07hRqT3DemJvb3kUZZ8kcAbffC87Dml2QFL7AIs+rhlrVjmQUbNC8PY+P66KytXTfMM9RMhILSD2BKYZqlLoF+iTi7us1m9nc0Tr/jGXqdYRYkY53musfOVWPMe20eJlMwuYNReBGNd9uR0bwETqTTUTRDCu5oeXMoPY7/+o1ASIoG83X+SLjcts9UaSARCPCTBi9BZAlxZlrl/3u1WnyDLIuZLCEsTJZTqOyg/4Eh0mMrsB6pfyHJceqbYzQy7om6chu7aMfS3GbnT1CDISZoK6Af8Hno8Qyo7in37Fbu0RooVOqlu4LCVYq6vzugj85vyv7tTNt139/YlBs17lIpjiUeT0qvzYT8caH54ROLWe6ph1J3GuhK8Hw6xw4efreUTjQA9DvdeDUGDf0CClq7ACHYpMtECFEI3SNFADUBsFQmmMuIrkMVbiafPSj9qp8YTn4yai5WFRfyFzUg7Z1WpB1O1hY3WQws1zmnXVvg2WJmbueQH6hl1d5bnGpfhFvWxmwy4tn7SXLEkpnhwT7aAaGu1G1IqxVxUCC5FQnBlIXV0sH/FrXkRKP01JoYF/m0PeVF+vXn1AZKpjhvkZGUUamgFZ3bnHZNDXk4UJJlxJpQ61ifRpC9naqxrEpFHZLXCFg28bEsTjtSKCrL5OD5hsvh/edMC4pB/ia0GeN20JZcgz30BmdegW0yd8+pbcabRvVrN2L45vQPo2d3Sjh73mKMgAra7AQ8pXJFLsZIIsSZtmC8iYlfvaNGEpESiULisnuSUWZuE1kz8RtsDAD4o5hhvJwR8oEQyO2IaeCI54GYmdHeaw8zxJMrDeK3RLYTKoZf3q3Bna92bg+P5T9FceEAOe0rK2lH0d0C4MJWyoenYAFnN+dG7b0QgWZRPl6qxNVgk86YMesp430LcdHhKcG2f23RwMroITbnfI/IRQd7usEJllLd6ecd6WJl+GeubmNlPgg/IgwZy4XG3JR4a2GjKVo+AKfZuApfe6YkZ+yTDrWjmFT4J7ygbgj4gaQZyOBTBneqPfNA8lv7bZUJTgavlT7NyDpxY662Dmju+5w1Hvn/8v/2asuQQ+ZEM2wsBs8gz+TrwhvKffOmFp0ZRQFDTHYAbKXQXAReTTkdYhOTCHQGafchuve5qb6LJWcPK2gLEpXKtrO2MDeE8uwFsz6W3umL2HPNQFjM7hQIsGoUBRp8mPcegk8PAtT8yKVVDpL4p7UkY4GIX/3/jXipiH5mtKPpkXNDvrBGg8lQtxP5+F3HP2N3wERIGxyY8YgU7wlT8fmPVunn6lXHO3qLkBcUHiEAxnITyaWS7565hqnF6uZ97xOH2ihzj5F+H434tz2vyfMVItD+Akui14saBZaBGpEfwnm/Q3+yguQFoUSrKrEMmEkgw8K5/CPt9pTEpBMf5rHwYdDtsW2NjrX5UtglcDkRSW4IIHg6okZcHVQ2pYHkg7eCrRrHMOfpVdrcHs4jm2myMrJCOJrH5ab5mINnUiAttQDC5inIsd3InM+xRkaZ4LW5WaUgMUH0neGcBG0ZIxXCjtOlz0h90ibpSYsS04g==]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fnaturerun%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fnaturerun%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fnaturerun%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fnaturerun%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fnaturerun%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fnaturerun%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R(根据深度优先搜索的白色路径定理,R必定存在)，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode* p = nullptr; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if ((result = SerachBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.push_back(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(scankey, make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.push_back(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;; ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); current-&gt;keyptrmap.erase(current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); ptr-&gt;p = current-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = current; root-&gt;keyptrmap.push_back(make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = stackforback.top().first-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; scankey-&gt;first = q-&gt;keyptrmap.front().first; q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;keyptrmap.front().first; ptr-&gt;p = ptr-&gt;keyptrmap.front().second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(current-&gt;keyptrmap.end(), temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;keyptrmap.end() - 1; current-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则同样交换g和p,r的颜色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则同样交换g和p,r颜色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fnaturerun%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fnaturerun%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fnaturerun%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fnaturerun%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fnaturerun%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fnaturerun%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，但是仍然可以继续化简，注意到代码四第25行k==0为真时完全可以继续执行k=next[k],最后会在21行执行next[++j]==0,效果和第25行为真时执行next[++j]=0完全相同，故25-28行可统一写为k=next[k],从而得到形式最为简洁的代码五 1234567891011121314151617181920212223242526272829303132333435package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 这(代码五)就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fnaturerun%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fnaturerun%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fnaturerun%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fnaturerun%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fnaturerun%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fnaturerun%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fnaturerun%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fnaturerun%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fnaturerun%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fnaturerun%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fnaturerun%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
