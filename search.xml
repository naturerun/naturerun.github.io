<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt;* ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; else &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; else &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; const int N = 11; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
