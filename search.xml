<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
</search>
