<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt;* ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; else &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp = root-&gt;keyptrmap-&gt;begin()-&gt;second; delete root; root = temp; &#125; else &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; const int N = 11; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
