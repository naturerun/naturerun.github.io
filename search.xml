<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; if (cur_value == *cur-&gt;max) &#123; return true; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! U2FsdGVkX1+3+vx8uW4OPaSjp3jLHxSXVq+h8FQMhBDFJpvTyhGh9oeKIqBhD1edkf8AcyfRqHV3nwstThK8dvt2DAUY1SEkV+TU9pZUUvCOD61BKf7jdTaaTljtDZMqYv9kTwvsjUK6Ckn6bNJz799VVvJt8y0KoCZlJBqHV3505MLxSbOVuIil8Kmh+Z+bfJOfcI6xj7uo51fqW5aUSe11YBhxwqBeEtr9ZVdJBsYrOuAuSCqmiUTNOlOC13/8uIp2Jm/ZsB2HMPlxerL3YK4WJBxJUPXxAsLIs6CBPZ0JeHE8Z7ssCu/QPAXryfwl8ooMPYNRQ0E0xqQFf3Ab41QjYsERJZIRaPQmpsgQEifeeNfzYEeZ2sZV0/5yoiMu6/1xxOM6Mho6asfmfcrsZhsDc9j6z51D41S/oe28MxvpvlszUdHRtINUqVuKaNrAmRf1k++DqZSdjxkRMgVrGxrbgJiI2DOSxdFWV9wEvCqtu08k45yXu38ojUeeE8j9WF+TGXbQFcpCVBL7fiuTsxZDnYYGxdp8Ap5hBQYqwu0X5ABtr/7lYOWKJqgdRZ1zgu7BdWdhZuFuUj7aHlaDjdetE1ZpbIn4tpNIML0r9tBr2wL5nrq6G03ERtyxQPGrMpu/LsIDSEd1Y21zYHYLhgD+bIAWeMtV5rhnDexXmWNb1eGWREH+YssgIiYB6eHPhn3DwlKOfTkQiwn3nA7XVI6D6kyCaGlmedVswN4l75kYxvO1qtnI84NizvD3X06UC3O2Toio96HObZcXB8YTcOlqpFk55OPrQDojD/ulzGar2GkvD/iYIQW987OEHTUZGbj7k36fAUlKHuQad2E2JIpZfgAU/SBVXwXq7oGL19mTaZeRy1UiYehzJnvuCbdE9dZY7ZHTg/rpls2Wx1nZYG4G/UyRkIkMtpwaWAI7bYDAhskYeZD253yuz4nNq4qK+zHyFNwRNMNiu79aDe01Xh7K5aNhx36AQlSsbXj/s6ffa5X70fHZfnbltpsC9Uxs7TSw8bFuzf0tn3utFwwANuFpB5FG8XZ0ii21sBJ66TETmKI1pXwK/z5t+pwcXoxp/YvMNyBX54cNyLZpOYQ57gRAQgzr0GajMBEdeG49ZXpZ+MKbHj6i6CNKIopZ1NmuSXnzjf49UKT/XgYo1/LMeLEsryPUdWV32XEOZmm/7VXy1NGwseZ+K6deQ3b/dan/1VoiQr6UjrYnE4Sxa9GmitKI+d8M/Pxl/k1WCdp8YIFz6g8zYN2LsS1hyK420N+YKVDDJa8iBXy1WAixW+Z47Wx/tjJZ/DwGnWv9ovtxXAFHePCAMS1g8dYh0g3uytAyQXcKFJ++Nx9i07NDiF/VpArYrab57czIPvvtb3lN82PrgApGbZtGoQLyTXBO+PDA9lhYr0ym9ehk6cNhOWPJadBLLK8sA1frfVr+jo5XdwjADtdIOCWEH/L8L1Sl8MPOrR3lRgy9buafHwfDx4c0Oj4k3SessSI7J8jfPr+mIUzJfR6AOJb7G2+f9nOAYl2iTRNcJmDXhYwRdlBazY8TmF8dAUSJibj+WbCvXsPWi/fBW2TcFVHo9tQV8mH94ulmvIRSw54dMyAtX7htW6Xx1Qu56nT7vOdPjlPOPz4riykoV2Bpzr2gBopklvHKaqkPbUfJRAsX8B4e5YdiXg8g1hpUj2gHy+mQW5IGcNI25ifDhrcO7cSwFgjJMPBBNXlLiwlskqmt4+KgzN3fMTRIyphHjC9qSzXRtw0529Aw46ji6fUrqqAMMYCinVSfn8ZWv6p7AOKuU+riyMPTqi8BucHAeKm6CmCcCKm9zn8UnXstPfb+iPKDGmu1eusSb0SmrKlC+oKxFMRtOWxLIlUqRw/ym5YY/8KMalLiHHfTtjd4Tw5LIqyAK4ONEsNWbHnwtHbWOq2XVpDzC3aiQTxZ2gpakj4DWgumHluRiRSQFWnEIrgwyBRrkIKZZS4VScpJgyEWQ0Mo2OLrrYKY6LtDIIrtW8Dka/s5m298t7SZsXzN1A7d2yjLrELNVwfx1pJpfcff/aevKaZDkkXWbHDdKEmQ/JQirEGMrXBb763LdsKJaUiGRREOVJLQiGc6Cwp7gjFZqLxAYREtMaZ1cfAzyf1gbbbjEOuA0nAUBE0+TPxknyaZxo9yFlD2yCbhfTiTFmDJDSCaHRSPNee+i3N3qps+PHSYJtsfOlRGKV4IxSC3Bgv0O4ZS1gRRQl/duILsxX5wrYCfdWo5kszc2sWLM0b9r2ZVBG+/bOtnuKf92aTL1tvaOQhAcJhvHv3STGQqmjuSg3FI47/Cy69suhfLsPgd15L3BKn4bugogV5fhbwFD7VKZZ00sWGT+UHX8lw40gUEkwv4Zc0O/cpqcY7/g6l/cMdhvEf62aNRmgYjxJ/JkvW3Bmegqmu8AuJQssF9ZmgjFN/el3CFQu6/hU/rjK16M+deldjt3Hm+pliAXDe9mVF0IEe00bnGiltT8eeHPsZWuBzbLTjgSjBJaMtDxPRnknllQoQ0OExt6gNeaBjlp4O7ZDf0rtM0WElViCqol7GViRC0ATb8RliPaPzAa33WTmdylbPDnfr8vkVwHwyh+gVwsDse3Tv7RKeVDZqXSWdNIcWMppGGhhlQqe7UYiu7V3LBeAV5SdNgfkWt2nH8VCgDaIQsKGpEKcbYvnYMQoBvNaMiROO39jy4r6n1+gKTugPeNcG4kCAEOZQ2Ch9Fo8Oe/9nHlLqho8rH/8EgQ4g5zI62pEz+FO0xNYlYpSl7ehe3ToLuCj0fHn0Uh/1BnlyOhiY3JrsbN62xGXKNOuLo7MY01I6zVObH6w95+DrW99Dsp/HXzpMT1n5/uhLvv4ZXUHFCTJ1QRJUv4d6Kt2563qjjotW20EBil1urd+YJDJhMu6i+XdZ4W+vjuxQY91IyxUFlt8c5Sw7icJpASptiZUeWRlNstvqjPfdmBjZ9AbVVarusq9sY0U8oaEkjx7IUByhR4a/VVpdzg6IZwpSkYbJG+5lbPi6dvbBiCB7pBGakaljkxA4US92WTj74kMfumbPApb/AqCvhVhF/XoU5Uvrc9x6iUfg43RtlqZdHVd1pRoBvbQvHi5GQ1Zv67fviwLMQD36RJjHa9VFgBWu24zZGGf6UUXLVaaT2pwphiAlJb6RaCWylzyvyJ+FaDYxrYI5jca+PHqwqBOypjOfR23LqwapaTnP7fhXjyAoampsSEgpfFQQFCHSu5tDpEXY/nbUJeNgopK2RqGg9OdRUN/80AgGmJpED8jFmEbTsx3ms6smwWZSmYvCeAOSEHo8YA5uQRKg0VhA5U08bRJFZV3xUvO4SLQO2pg9eBuZZmLOewC8fcDr2lyls9QDwfABPm+iY3yjubHuSTxznH+iYNNLfu2eGIwML/PE1dxaOgt3wbP91KD6jk02h2a3DJrzeRve6T3LpL7iMHS4ftuHUKmgKWNc2GLFf8LwT6B3HezQQ0vFxhr+AixPMHgD08G/9owOEQ5CK6jU5iKCStTDBvS9fO7K+5EPvXJzYpc1ilp2taSf3FXVrU4Do+kB/z6MfUh5EVc09SpYVXV/ISM5lAG3MaD/tETX5DuOI0icfQgm8gcpcrS0ouBv0XIls0+vhRN6yCdtIFJoYCPeQfxoQ9KRwnbIqdzmWkJDDvTbINSHcjobGgftE8AZ+3aq0h0U2rNxZiSLxZEYS5qGMJspL68TCDPscoUgG4OwN+FeqT4kAer3xOrVHqs90XyzHIzTKalHzsXOwUJ+TyLqCp6hjPsfSpJmL7TRAnD/X3pS2ZgICMIqYxLg4ykLx/5KasGhOIUYA6HSHecLCUEjcqEEmlmRfnYih7xWRi6WR6ZsEcO2y6UCgpL/gbGK6nfixRjnXKxAcYNXVDh/7l1gs99FS+HhXmwR96M433wKbKUv5kV65H4GIOp9BUVg+hDvVWRHV47IbtuSWwvxJVVBe/0MMggOUAWGLOet8+TiU4HQ+vYCa9D5pwpe33LKGkHNuZh32y2qAJ26PSGTRl+e7HiryNdbY/o6u7+oPuZPrJchj0FkF3s6DvuS1PJf1Y+8z9brCBWdwYOf81O1TZ8I0P7mL7KTDBkUIujoeDtFmzFE2cMj1hKeIa71OZaITxFFIWo4r6GmZ2xFDej4j+2R9YhNcVtDBgocpxG3LcWU83xF5v3nV6xYIog15LQpI8w30UzVToc8CN+aIaA6sKWn6l2F/gE1WWT7yrwxeg0OtovqpCZHQJgYfILarFTD8fmkZRMYzis4bZDYiz9S2CrlM8GN7WsEh+WKZh0hAXTNp8GPvLxNsP3k/MncglbVlLQmZNc2HUi3CsoAxG042LNnKr0EAPcd9uckGJ3FZTZR8bmQ1mMmuVNVtv15tStKmKpT1JEWmYab1FnBmnlI6OLlyocQsAgnXXdAk54EKaQJi8C++JUrlvodtIWvo2hqDj10v4/oGugfFJ5A/U6ESASHz/0E4hqzp0m0buCMYJUoczutWfGp8xgaYdiSI2FaIPkca+1kFHMAHu+ZhPhBIdo5ueiYj4/vDWuEBy43iee2bixJdPLsUyW2qqweksh0cgptHyNNWqw88tMdfdt8E6H+FN9mikPdtBFX5r6Dczfv75cTvtiyag+rrzxA2NM9Yt7Vz5orNQjeHbjnJRKUnY94frHc6WiQpfI4xzafeSXWJeLKy1Qo/6NXSNpk6RW4gyYoOuVre9x2+ez5/Ka7QY6h7QuWEsBjf8BrBpEg9e3Ekfor9mFD5adki0GPULp7RRE/INSUuBv34a+fYWI428mi8PjGjfaBTE0xpp3Clvp4XfPgsE/RxP4sEAM/GTVZi0uBArw1bYTC0eyvgOn86JXRAalFX5vTp1Ntl3nQ4HCOjrbQ6Q07zeNAwznJ5UN1/bt5g5Bh6K/3XOy19rypnm6R5Y6GpfU2tJLEoJkTzD3psusn3CSOshNmKs4K+DGWmKekLDvAzeq+VAqrGk/vU7LpoozMnifO2qFvec8Vms46lj7a9RcQGwmozRBJdp4XRCdtDOeMemoa8+J3II1zgKRAvKP5dRfeLJpWk76IYZdThlkJhPd+/cET4I+gpSkjgfsyPDXBdztaTZa1cVKnpbfhNFlD44xGW+nnRtHsz1i8AgR9bIw2t5yTW37CMXttkVX+cc3gu6IFA0eXO84XmC3mSblrIsot545RdSZiJABIbUlKYZz1x2H20TqftA2FDIrdnkqg+hhcGgvRGI+XrzO6txdLlzCMupYDpxwKhFyDyxl7PolBDqjxSJVjGkXbhubxhfOxcS/OtSEtKPtN+O5Id8T+eF4uOElgQJIV0Jwuj91bVJ6Nrb6/Mdbv6QCsh4xrJ+9Zsbjz55e1KUeXacDXgv58hMj+aOgJ/ZJMIsWfnTaq/j7vZM5AhCUDRXMmfny+tjLsoLs1xmHHBafT8kl0Ag+eEQOY1bfFyOxVfWjQcskzGhpUcryo64PAjTQ5BI/kSBzeKjBu2etXqa+A7wc3h0J6Xvm6UGDMrHUHd7rc3Pp+V0tn7xW/4OEjsCgWZ119QJWYey6v4ZWbpiiRg84zvh0BTHJSA+d3Qmk3C8mSPqm0acucEAEQxhDF5/gQkd59r6MaKXfDWQbEl06xw8gcr83DKbHbSlyangsnq3sEsd89LOGcNjbexMxRZvmmKZuTIKGFkvVFiPdkdqLvQrX27U0Ynn+oHNZItjsCAbu5XmNVqGJtBsXwUjLZjzHNn+9CIOuoRxW6qCvwaof5kWPyh6nPTKgpwDMd+lg8gnN4LBD4G/zfb7f2Z4TEFAq/eK5Ozav0mSMpagBA13JUlZSnrlQc6cU3OtrYLeUwrSWX2/44Aj/GCZ5ZMyQQtKKb8qqshLISgeF0EdvMKJLOEJJ1ONel2okFXuQS4z3RHSaUSNYzqr5TQ82xppMp84kI9yCjfBeTXntYjpkgDevO73uMA2ktckCRHq7yqEXLDPt70HpdYmnc2y1EH3pEuVfmPtRW5YqesbigcnkwqwRzdHAcopUo3aCKxJgU2jFlC2S1CSySdQUCzh32q4nVKnsptz7I/ieXDtHSrRZra3LBlGs8M4ffqtp8726ERQohcW2DuIAM7QyuZqDD2fmGaXdGw7TBMmLsTcc9h0FNRKN8GucWt8+2SXOpH87lMWRJzj+QneCVTC8JprZtnq8D2lV2G0AnYDh+3gIPMetReQj9czmyHYVzCA87TDae2B7DgqONe8KteOT3DloRFl0vuxCJSt/5AVl8DH/v64DvOHjkBjxzYUFg/mSYmFSHZIGwNOG3raK7LOo3VpK+MXJwTi6YIkuueLf7qWdvNXDGNkeh/jLZweeTOH+hVB2k3afsVLUuF3H4uD+2msfml9e+V4d0498wJuNWYd4KEa3Y9SfTUXspnb8d/XOpU22yt9Im0tv2SZQQBO1PF79oiYy59kPI6lbfb7sqrvn94U3fcjHTL1NqDaSScHjXy3i8eSewfntQRtWxeG0o5fRa4NkRnXjBI9cc/RC86dhI69Pd85cGSftPLc2rvup/RAETnMCJnQ7jLE62/ZIeNojO6vBMwPDRI111y7IaQxPmh1bNZpy4H9bPZC5jJ08YTIhppRwUxa3UW3YN/d7hLJuuBCDAorpo955+Y/k6IORcTrxuTnDYlys8/S8FirM+ljLhZ6t4bvR1k6T7iCeT6Vdx5Dn/gMPwTtUxtRiDRJ8I69IZlOs5mWXP+q6FNIcq5H2DZVShiIDb7tmk2WgtsA9P0wBKRpPMLFItu8gdm4I+5zrnf27m0mO+fGczppPB3ImrFMI/78+xg2AfaOs+N0v++91gITl0UIPRgw9gZAgXHYVq1TI3MwMQNtGPuleTfVA/SaDR2iwcblTd7uF+fhk8hrFHdXE7QkoEV0GFNls1PU1ddxTo7lSSUHCj/uIWM2udSSoYS78mLA7APtd/+0YYJ9Tv6LG+UkmuiIpOcQWAa8rQSCOHLixO4yXzPQaNNDNDgVMZkmDVLgxRjQHp39xe5/Ir30BwfDrDGqsv1+KAHOpuVczGijqkOXHKy2GvOXTViEjb7q2Uz8UE59L76ihpHs6LSQB2bRF3K0xkdoD5wf7z73AJ/TXNS3uq0fQrO/fQ7n4MpXONtjPt2cN0gOoLiG47sv+VtFbAXPkiVHBP9pyVgruEno7pf0CZa8lMCDDklOblTjwL4PVJITgcn1LjvJxKIRrCAgaRPItbH9vqWNAbQ6qsWdHjoNDvsvoKg7jABI1AQVtwYOIJ84aSsdNuoJPDQLW+nNUdu0S2D9GfbidtPKlhBcnlpyCxtcPMEalDDPzYwhb9Xwvne7nGNXjMyhZUcM9ErkS6MF3cVr1+loJzXq9VB7i+w5CRUMA7NIzesaa9WK+Ue3c2n6Rqb3DJf+n5gITCnRaW+WdCEuOgCaoiSV921XbLpzqA5dXSdYRMhGKaSxdvSa0WohrpYSbczF+foMTClb0Wmt/C4dCRSyox+i086vgsZxnDTqVyvMooc9ZYU1qr1d2F7pmF6lrqOp7GpQETqQPBJ/QtcwtpKbAZlkc2yQp5lIvMRS+GIeVxZ9HUiVjVpwp2OGGb+k+2PpaccC9Z4HrudyIYQLRP+ISMbQ9VQ/vCVpz7Qab1NkB7ZkZ3FjztY8rjXibmCT063y/Mq5ip3dQcFkJyidfGc7zchRAV1/wJ87Ou0+qgDCBoZL8kd7UyrfMWqiCuIqdJfSMiGVf4igt56s2tT08Q5PIUjm401tgjawxN0KP9+yAek418uN+vkmvv8Is/3aP/vF3A4llBnYth725Nevb3NNbBipGeho9vyLWW3fyBJjO71YLVlRDmTrvxg8oIhg0C1uDkAm1rvH+dMNzVi8l2HExL/mXL6ovWePyhSAnwK2ywoLj753oYmombNOwJ7zF0C4dzj11gavn9Pb/eshxsgkwGgp/zlhUqBQqYUhJ5gCsLeKhqx01/ucVqSEwwtuMMD00XqUwnVp3DxwGsNubvGCcLUwXAIhxULFhFtPpY/VjoMMzjU+9Y0eTYUcLMEkV9lgUIPE2YIOZbepj3fEVPzpraOY+LAsXFNLGiQSdaIiE03e0WvA1VjmbkTYs9yeF/TnPPciE5+rKEcxAbQ88pHavsEaFLYvOZaH2+6oGw/+m0iNEAJQPYwS2xvl3uOljLI7/N+3FNBnII91YBokIe+7KXvVjTUo/719tLubSZ9SsccDZoPIizr0Y3CWHHo6v/uEQF/OImeKjY49sBfNwM4a+DUoRITyGJvboVIM4eCJVjcTYFVRR2VkI7lHsa+kOv9iqkxAtvAIvDKy/iHLFGJ3uxVu3ftgCNOPFc9sbwlZzGp6CKDcHO4hCRKdU0Pilpry4HKFIdw2AIlu/Zzi9/V/446oMVqlwARHXiTeg6Kap4+SN00whjABZ4TYAfyeJ1NfzJaikSdTpHwVwOvUHF5GY7bTwXTS7o1IkaW/ANXxvY4exRB58k+m4RMRRB4gEGNOobHaAKC8dz7hcr1RUx7FbRNSCWxsMrHiYW9zKi0q5vULzOnvJXn4q2hCsv7CLjKcjejhrlsjRaWgmX3xEhm2K/apxU5PGS8xv0W5KOZ6b5XLBa27Yh5BLeN+ze20j7FzbSArXVFE8BAgRl2Ne/ufrxskB/UUdA/EtkL8BccljAQvf+GDTQOIuJU3ygE1ZC9GNjAwtcDP4VO861vNC7ABTOSvWVdVNHvjJHr2QqTGbBh6LSAup0hjXeWCFG5hAoiDXIqv7Y6V9NMmVekvx/cVGs6IDnNvDwlp8FQWybHsbYMq74NbOgsVnkgpokFVQ9au4pTq9oCNcrxh+qRxJEh+694jHnP8fwxXsGLZqQVrp8Z/w9BKh/z9maclbL6N5vTSyOU/2yh+iVT3JenlxEfOVPUzAV5nOhAIqaj49r9Tpmt3qvfk92z0U26shs+0ZGLQTSzRsCpNrguMU83W6OtNauy/9AWbv9e9vbliL5SMjPJYHTQZu7waluDbVLfy1hmILCth2cXNRnYhf5PbtTk84YnWfjYJ5FJDQtQ8ghQ8WcV3l37YEZPgxHDMANB3QtpXijlhnKayVd5SawfH7FpltzPvOwNhYyYC3ELlwMHTwaFhFAywbYE8AMxCxTWJEBzRYmTl8jpdkCGXnW2/OjEmZoW0BuRaZBelz9GfBBNWYJOJgV0XbsAW5U08jzEGzqyBfITDpkcYgN+QyJkGTO9+436qPL3/FJViWX/NbtrB7EGShx9hvjzFk0oNTBwWhEZMKR99JBBzLBK+V1FPLHv1ePmCF23r510O9pJKlzWeIgqavgp6RoOH29sndD9/igUtHSgUR24bfIWvXQ5tK9hNB9oF+kCHnOVtcoH7X2cw+cODP0QFLjeaJoUes3STZcy8rfv2J9R2XOnRrDn/vfdUScQpO6q/w68NFk+xRfl7zAzEkx8om3Kjp1lqUyWodwRpYgYFjasVuqc9oFrOUis9qC2lSpe1kJKI+0Zaqov7JNsC1OwaGNrLer/HbpGBBjPiYcOAQ2iyxSJMsqaPH2JuIc+bgVsapQ5g41Alm8OMt7xc9J6gd2epaJ954QJbkzz9LR2q+bZoCxqdl70Z4R9VDw5uzF0FhauptxQhSY00qO9bRqRZ1ZFHb3S1pCnEkVjisvf7I5RfJ5z6sUi67kiQ2E90F7IUGtbgKo/VnwPZCKW1+0kzqEYbqpbR88otDSdxrWI0JzJbn65vUhv15nTf53+6vMQ0k10JL60mAwryW/UzBWxH4yAAiDpUtXMsdqKTq4La4rM1EZm1Plwd+vNFkI77KRM//HbLhPG8RZjjTpmih69aGj6d61/ZnBTyqI8ygUs9aTRW3vSKt4cv//18IZhHpRel7hvrJnD0aOnqDq/e41j5Dc2Nb+Pw8+3rE6LssLY4Ypj6WfRAV/WB2TZI39RjBaD595NvKhumAbRtgTsbjdBkbQOdlZuVq8lGlNaZo8dbZVqVI3Z8wOS3Lcl19Q5zDFybG8hH9s7Da33vc2HcpTLRqaB49QbZkpNsd55YoEmvZjjfrE5pvIlcYd0fA5airN9xEtDvsF5ySkFww0Iwa50M3GoIlDnIud06f82iIUaqAeVF03rpBKvCDI8dJKij4/+nCweIxrV841bhsYnSGwCcRA4ZIJO2kxaHba9CqVZJD5mRYKkP7ayGMeDHXYgOJExApfwCKRk/esSbq0gSsFwsXkgCLk0RJpRCdl1W4Ocrr8qGn75mViVi0+cRxJeFzZZNGG5ToBXpBhxhObR/wvc4xkPajsRYUiVnVnCINcNdtsD+cvY/GdMMXH3YGCK+hMHvvplkMLvaORIhVVntaNQuoE4HBLYaGWOGaS6F9g2hkCtnP9/czVhkIb/djZcgaW45B0ZtG/U2kuSVtRf0tM9TPO7Et1f0YJutGpgt2yIPQCIa8DGbZcvCWpFhw2xV+1Y/y3DEf3Z7j3PB+xxukRa8QFVWeITxt9jvRIgfzVktdt/CJZ9GRLsM3qa4VZzvebusGuYxbRPPDYoR1BYBkeSdAO4pLCZOqMOMAMN1v1vzv1iLA15/m777El4gyAxV4+yJe9MnZyxY2hQ6BOrr5EK09J+q9ModK8ZDc2QWRl3jBBwfZsJ3m9sDvCpVXad289unZTEHDq8M/SOA9/EPSVoKSjsW4y+oqhw/44iwuwZWTAvbF+E3uM7RtdU+OmnbTfFtQBubeWIKGzGmLJKZsMV5//BAlmaQ7/u8MOaEVwWER/hlBiap23iPm0MAD6zcir+9xlq1jApEA8OekYXDhZ2FfNrfBT/sIPoevb+EZzPlblENWufXSKSvJyMSEK8jfVdM4rB/Pvu5nSDgFGQVaGUgzmV441/AWmebAOGx1/dUNzlvTBj/jBIazaRGHMtAnynCDTs4U36wD07kw/DWlimZFsFhw5WfpRLnI/o9g8sQfroImL7+eo4fGJxEgU5v6LBNF6VeUMUKj0Z3cj4GBL90yN3KGiAdSWavewug9zoRaDxymSpYKHbefwMXzbiHWCwmVEQ13XSaEg1nbjgYotFL25p2ZRUey0OZs1l8wr0njomMEvrMa6WUMVWQXCSglUYBh8ECMA4s3P7a3de7eXQ7+13+4gMlwYfuy7rOpt4bnvnSIHgjLbdmn02ASgIlXoWF40YH8EcAZlhSOmQU6fDDXAFQUG3RHB7CpqShy1xf9esRaH/htWDg8lcZCHwDNFQ3LkTm49y321XGmkFETPUiyy1VBmR+2Rrq2Y9bm/Ku/5F4Qryi82p10byAZCV1iFY7XDASzLAUKC61KXfuHoTEMNE9C0JkGZuRV+KqusMuSYrcdho6FereF3pgB4kJ6G1jZ9XKnQEzhgW0QOC1xtoaGQLJkrIZidPSpRqSdiL3GXduwiQqyv+okfm756qQWcy/MQ7niSxie8Je6+2COS37634af1fBnlsFsPWpAeBtH+4tqmhfzDJmFKqqm9zNIrNGuonJuLeuAXaCPZtXSWofdGTU6Mmoh2IN3h5Z2er1fUc3gAMdOyXRF9e4z8M0vTI8LKT1dBh7E1wwF+/gAYvkdzKkswYkAxleVIwJYkFAwXKwhjYUcBbAQFZ+53Ysji5MfbAuAKeoK4xQQEce0EUSZd4dBXHTQV+wMy+kCis7TQmllGCyQFMdBKZkAGoX0j8VQaznH43mmGw/bi+yF0TLROcdaujxfKUIcnmlo0hhUO0i4Hqd9WucFYCb+2FPVG6VHglzzBRZTxmQlOhaOuPtHrFWfKiTvJIJfGzYybIvo69lf0i3vl5oNsgT5jUqNLO2PwtMn02yeXkY5t6RtFh9//BEgczysoLTYPGEH/j1jCar3rCqYXbvraY3wgwY++7pgpAruQhCY5fBda3ixAwUkLv7aPR0eqc79xuwT2j93VJ/Ncllkdz3RUQr4WMtadt0vZeCa3Fyefpxv+9SZMMa14Dt55g9gJWp0pzGsTFTMkVwQqEORmEzrkFPAHTxy66T9g0KzLfw99YKV7fj2SJ33xW1x5vbVuOtLhTKqHjqGW7Txktl91X/MJnuQGWFqqxQ78lrGA+bwir9gxQ/Kl1GFBEGWeOiQpb6b21dy6n8l2eaGSvgXE0mOsvqgDoWd5gfy5ik7DDbMJZ7p7O4pWG1GB2KMAzBV/KVsP4kTmfYTl4GjCwKChId6g1OYRRW1IjojYP5HZzMUbFiwRClB76LZkttlM5kgDzs8etRseCJmL/6PpkmqT6ucOchSsjjohAMOp0nhvbf5obKij3tc6prRu1yzKe/3mivbxgJSxTmIGlvnAcBddYRP/rIkRDy1whjG0Y36xdKCBxxMK4SS60UQ2ptgV7l5IQUFMQDDC1Oze/zGiQJ/rdXk+hNdoKK1c6wE9qhLAd5WIgYuw7M3fUEOV7ti0fvfBlaGz6ED6d9ERwvbBINoFr0EAI0UUGakNUsPKfVF4G2DTRYer/eb8TsLs7eyvHxIKcqug16fOcrFTItmW06wWJawl61KNWGyEewBhMV4sKqFrA/9HGivagGZUmn7EYDB4yux3t71mh4/G09ih/Ej+vYSuzz6UPxZ6eeYqaqlsZx++P3NRfQYj4qQ91xrQIdtvKk9tLl8bE/83gsWikDoio0cq/de621HDkpvST1ZRxgc2MYgf3Dyvr2KKWdQ6HkkOH4wlbstUvTwccmrpF+NDe8JTmfFHtMMEREwBoHK2y5hXEfSA/JD32Isgrd160x9rEF+jRk2h2IxmiC2MegD6MbShCu6EBqhcwvFSHD9g5HWKfs8DebymZ/yrLwTIgyhQ1+Ml5vXYyl2KSaXKW1yha06ZLOI7LnmdVaqaukxYBPyqRcQOzUP2O6wgNUjjtdKK5i7044wSuz1KCJsvZD60w+7qUrVpZEMZ5m6PX2z4amQubNiI0LKT89eOU1cFtBfvovgrhzR7F8CJOJYMbu3RRthPK2ctz+wnx2l4CcJ4bFJHxvUrkAeuQX0OPYQdMOZnEpaC8hW9km5ePT7ktr1wKaeQnIjvia9k7UyzUOVuRbnnp4WbyGAC3juZc4bdiw6Dxxk4MFkB2HRiO0uuJ1tb2RKIC0j3JX9Zm5/DerIrhy5d8bCG32potz2J7n8S63BQmcmHNUbeCrk646RFalYgbbSnt/mN/sbieaHekqdtfVV2nkoAj0ikbW35YDXFMabkdSqqACjcvjRXBdoInEvCedmTf06bqUHMMVZNYHymJ+JGoNtMFT0TLF2aYva1aa64kMWvRmEagrhh7qSDn1tFcw4Ks8gMuigi/DDHzl7Q0No7eTZiX5w+aQd1QY6+TUBQpwmqrhGx800J8Kl84dfc8UqC6be8ZvDeBfaY3aOPRdNFDVuFqGRlvdFgdMqmIvLPYvVD91vD+TCZySRkly0WM9brVdQwpc7TugeFPTfuZx4xz28sIRmsFc6jFMDQ+86abj4PIMzH9DqendyamlRnMGZuqWzGElxndd4VEHB9miamE69m1oXK5LIFGMHsuWGL/MWQ3QL70kyxrdLsBIC8Bwi29aDrq9Tlks6wKu3uMdrshhwMGkwnS/g/xuQdfqUA77neL+/m7f1HT/Zwv6N5v7IYTWdYQDotNJQcK3n1VMtWCEO1oVTVsQmolxJrIkahT2WJE8TyJn/jifyt/3KHH7viMj3zQGjrYrikeRnBBXch3hw9TjjVAsK3D7pnWHi6hH8etEnc7L0lzN/DGh4YxQ5QwxDyFH8Qdp5OOLfnrHLvcRF6ewqenCRx7+J7nAOMNMhxelENH9fZrfa6c2pSqvcW9pX2qCs1CRJ1hBCGQG9KkZjubGKEZXkWB6OwAvOx/xa4CL//m/zkk5PKvBRlJAWbqVy+1+hriTvtCpRXMVdZwj+5J2+34z3/Wd50ylLFeENKGLOJfboS0ZywqMLoFnENl+7JkFzO8kU1wDwr1TxsbQTHuCUU6vHEhpXGYuHUDjnRBeLZE4Rd0Qoq7sKaGqDUt35ROwK6qS4wblBNsIu3hdYKYZzM4tvCZNhUgsf0D8/pXxaWglQH+B2myMX6UsQtUOqbYhSd8NhWGasonGAIpHIe6Y3AyAFfsiugSkWrgLLprctcORzzsGIb64HEQIcrd0lzZENSQ4CqzJ/mOdnkXaJ70bCiUouB1ebBTTu79ToBb+JfrhQQHBujxOcfB/6290F7LGIuyHx33kk2UaevrmtteSuvrz3B7iKPeHRr7NJayt6faEoDqoR6t3FaqzyRY3SWdadu/OgoHiHz1EulrFSN6t28U299eR940HQ8opF7g2XhYrEiUntPm2PGmhx1oJPWLiA7drJKW9oqAVMrTRsGiJk6VCNR1vpdgcUE3cOHYu1evhqil1xJKs3rgutu6K0ltfsBw2ICPSN3EaR149OzrvZz9GxmsqqrUbpsF+UlclUrqaKF5aMXYIvFlFPARkHDAPUA8s5J1ZAkZ8rpUYq+OWmlZoLuria7b/6z0XcvbYqYRz+vWqwmWim0nEWrYhHafx32Y+dWK6RU5bmusYExqUCOz12JkZAv/uDHm8512+YIPNyEDYFtdOif9ROLF/BUzXDMY04Fi9U9PEq1TgpXbWBHGlqdDSX/4J6bky/UZ+ti86RxgkNGqZMlVSyjlgms+bHL+0iWhN8cQm7HYSBBDIVRf1KC/aQ/8GaF0GFnHrqvA2zWT24htMfdXDBSPqYviyC9RUZfkT/qpMgrqFPKrYK2siIo1B/B0iCSqLNY83nYcIGrihhysffQ/dNLFpgyc2NreBgldW5uY27SV5VQBgJNfsePy1GukeVZTJOqfmWPUO7oRzsngLEz4o6cDseILZ/xAAflor1Xtrnv+g/n0VwxxCaoOnOklhCGvYESpSier0c5nZ0QR2QzcGYBiEP91kjz/b5vTbzQLhakj33B/xUyUhFEMBvgDypFT+RDspB8lrScRxCaksaLbGpPhgStFXkEUep/JBvW1C0a8JurzDVbOLIGiqVpd5XdpPjqroDYsVZiLgQKNHVmMWYVBWwa2uMymvfyWU5+ZSRFPr4uhiMBWe8FEOMofqf+amZPjxbNed1pAQNIaSDwunEFPRT2gj1feJ8RsOlPTd0RZ8hVAR0nThtgp8zfxIj7h87FNlZawos14BpcuSRLP9vCXnpvONcVvD/1H5hxvxdduNjbAW6cYuaVY/nTWtaG9Vcom/ltXk9y5QylhjHwypJOcyO6rQvYDfv2kddk4Frbgwhs8SZft6kueukRx1G1AmJj61N/0VXVU5WFsge+ndXi67nO1bXcz9WOdCu8RW+WjExI3RGovkRE3mwTswYOYZRWeyJZ4VxBa5FzVYbzWuxOK2ci7oZIw/XasxN2cjR4Cc7jVgxLCq2GukDVH7uuI74G7tE+eV9Jp1E/rgCySxyVOdXlI2X3CQhUmnt3OQbKHO5nTYZTIQZ5Lpk2b1g0RKNmbLK7Rfy1k6NAk67Tk5kPDFEKW+1QvCDWGmiJoyLCHRGEEI6PQLmHmtNY7URoLa70Cv90TzJG0fMh8OXYajlNBz371NouAKAojoXbpCazBosbn/Sozx/gIr2C64OnXim3lz+Gqk8AL5T8xvt/fEMbJ7Pzsz1mZbeeKC2j3lqpZaka2x2ATMaQzx+I94NksF7Ud7sH9XasC0rNqh85WF9S39DKtYk2lLyVjH/Z2j25JhfIRgxCuvnxlbwvz2WaB2jfNjJSg64VlOJ8dOff7MHr531TY0ztqHXjj944o7QYXugfLRgytA09c6bCffNDldinSz8cO4Zs7qVlIpGQra/O9cGxcr5ftxA+SuwENe3w9GWs4/oklwdRTG4rnIpNXFtzkON7kodEZ8We7OToiEzD34vbBbQM5SZKyrHEH7WEehk7n+5vfOOYQ6jZuRZXdjSglGqbRYoF+Dj+86O0ua3IcseCY1MBi0/nroNUhyda2JsonnPIqBg/1qqSjmkmZqFBTeV15elHSwTg3su0IEQyqKNxS9tCMxhQOfoUxGJjghMbhPG2T4WtOi7i/TnpAlG7aUU9UaNPmRCpu8OzH0BVQmomwk+ozDzilqcksm3iWG/81u0ZuyLawy4sckb+apzeAmPAt0hk1QHIw1ryjuYiHe3pEKulUz9V4SVn9o89BXcVrEMotAWGObm2u/cC9SFSSarw8nB6ha0ttMokxyyGDoyCVHVgEKPlf/rfbOYwzevHo3H8SDJQTPTSefTNckkn6u/LaJ7kXTa3Xh7MIUIXD+4D1Blzy5jetrkADLiOuz9x7qusHLJQb+njlu1xYzl75yT1tBElwfqKlNTTTKP641MvMteGpzkLRmem6uBLSqvdKiGA6SSCGobMrWN0YgCimXhWKqiDysWHp1Oxa0SWAemfTx6X1M7rsbzYxMbZZVwcKpZ1LEUhl1jcOiB7o+JuNeB5ir7q8RNlTS9+Y00H2FBpH6RY2yuVyfNxasSapoy8fyLAHpaVdeCmcfs24Ho9BMWgkQxXvq4KffHgcKdsgCy8Hr/i8ljxS89zerbgnTxPhhmaigfCSDKDA7RD59luPQtbTDqdOV5qryHOGEETnF0xeKEq6bMjGDvPjf7DnNECdEtqCPdSejlceLDVtD6XcXdFrTLFc5D/KVlwODDMnF3S3XaXNSDdnbYqBEOfqYg6Jh+xH2gPg59sDPJB3PJO+zGxdkR/Qqa6e4hPtS/QPVGXKmaS5kBThUrTQ2e7M325n5j5Azh18MFPIxES1NrWcVh5zh0Uw/Q1Z8lp8na/fgffYmDqqmq8GLKIZdl+eLOXYv7fyAbz37Z88V9IZWtqKX5ZiDReoFZEpQ0BfjWuUrc3gZdev3sKCMNY7MfydCStTWjZSdZdzy84S3fyQ9/ZadkX4UFlPpBhX9BkOQfplGwA3Vz5wqGIloD422OJFeOCIQr+I4SOGRIsKdRI7ls/o/KO2E1UgPoiZHCZlLVO5xqmGPuhyYUAHxYeaKbjatw8qNiXZjZhU5zl3qb4kZZIVCbg2aLEyFz7m8Gs91uSqYPbSm7ihI4PYtwydOi9kdV3rN2STSsFN0Hh0neFtq7UU9yPz4j3kkhP0WOGq9O5fOsGwl1fVQwFLTYImxxKfT4YOUwVcRFaNOPsxjxwRDcfY3lztPwZ/+S6e/7bE9cWQPScea/eksK9mwsb+qQDPRlD+bWzyjUKj9/evSgi3EBt2L8rlVkoJQHQ/gPWL//dpjdbaL4DuNEQrW5Unr1vNKnSibzu8kH4d4+6gweoAg+6t7D46Q63XBRYTyqar5ve+mYLgXAiqcvKFBubotSM6r46n4QzVTUFkkzX0S8+ysxgQEpUt/pyC/uKHwqSW7LQJZO8qktvuzY0ixl0zmMBoeJpGREfyZhMGAVPylQtjpVRbj7aWRhvxaZc5Cjj2OLO8CP5dGqinF6SRLLGJ7qOEJerFC8HHimIQgFMNDBE0KMzGeyyykRn+KzJ6dPvIYzKM4YezoSkv1duPHV2FZn9nU2DA5X9Rf0mOLnhtovNAesCGaZjZ31KdaEuBPByTsm5ArUANvR2iGu9lY4f/tTHGTJsdFz99Hga0YHobeJ4pDFHEvdAYEbvj2+lbawRYYm+dMpvlg80D8DZY/bRIjEBcLwdZ/gVZJ80R/jZg+VgUXKBK7mYav2mbPKNizzVa4R2QtVOfKr6tZXN/1EYphALCzdflRFzMLj9Jzu+aSskwPGmV356sIoF6n9bQKUy+dMDRR6tNfpJJpEAAEVzRohEbfDVq6aU1YklB/dK1YVUP9vAyh3cpb9oVOrBUbDwihwxvR9K2GDECY7+Uiyd+9tl19KcvBZQVYqAx5ElGS1yStnt0OVsRObn4bqor7qPXHihYNuumJNt+M6IBzt0svO3+OzK/ms+Q2XhX4be5LNzMIf4PH7Pe9rDl3ALPZXWJcYJse8AofecLWfpa8cA5ryMMQfh6MqPmMpdhvVf/alTwYnuY+5klcwPqCXXVdo5FU1YhEkukFbRIMA/74Cv07tVYtjQ6tr7Axv5wSgd/JAI+VyU3Vy85m5z6UHCDbw7BQ2ScJKXhaSUnbup4pjCfRz8Q/PpxWjXtQPMnSr412BBWuOcM+9nAm7zje3fWb7/MFMMZOKQQvjjwfhiNZtf56ZWp7rZJJhEHn7nR0uiR6qTWO+YtZKI1uwM9UgvezaslW3wmFiSN0Pxp/xedK7zIJEizZ1a4PMLXDriAph5vRfsxk8eZCHOHqmUWpuEnIVDgFXx5ZMw0Izy/4onjoqZDGyRBSMNgcOdieBrIAUjyDYbQL5lZjY4lHb38VGn9Msoz6DgM20/0wnowKGSIGRHcJdi4fUAAWZ1SH/5X8IcAtDXllVvmzxYg7gHUHFQLNhoo8QioWiIlB3FH/h96aBDXj1aTAgDpcqx64A8FmHWqOOtpfRy1t9ymjphtkN0DIK8U4sOxTANP5MBPaf9x5QvW+z8rcchq+nXm7EjVw1/EC1s2xc6ssQgTxab+hhLg8Qsbf3B73Nhs3BR+05g4+OrWRJCAALBnUYNXahnbbYC6bhpDTX2GoaQRU71Wg/5B3/4FDiI/axiOnSBZlOnzghCGSq6cBACCmcVRtUAFRIk3lM1hs+uSJ5i4379Ahaworo7vNCpGaj08f5+7VTSMC3ZllLoMGo9eTKIK365c2lUSuRdpA5Ov3BeHop81DMsp7cL2AvWUIIBYSvENuuzp/y7q2ai7ApWvATRVwt0wI/dNnsGXJKIAI1mjsJsmmm+FHI5VukZBYPjvreO35T9hC87CcYtNALoUAx4FnSQtnXcs/jAV0EE+I9XiwnO2ehYa6yLDSAGc/+Zxeey97d52L9NsUGzErnJGmBkNk99HPopNQHgWdoJ1Jj014SiCJaoeGLHTeK6aJgMYhXJJU8vI3GwIXxMrNqAfv4hSqYrLppWsA8OPtBGYfwQUwNkudxZjKGTytoek7bK2G05LZtaWQGT2ZI2vGWDjGIG+AUVJ5OqX7/xmQV9iUs0HXy2P8JrMoGDYrcxWchrktbsspFrfgMBfkV4MWi7oiAYxF6dCAMEbaxydZNGIvUOqWsdbjaR/5OFvwCOrmJvmU9YffwLwyHbX2jXtEowUc+1tRL7GZYeZDDTHl5D1ZOuLB50fzKWc/j0wOsnYbK5if6pgvBAcOiPXdJAakuRgCdr/kBlrAvALgbH6EKZCfwclMDVEpaCoI7Th9iSszAthPvOYQUIgqrk2So+23852gDZpsLRT6tri72NaJSVU2UoaGGo2dvbvntieYYHfjLXkeO/DZtdmcyhjf0ytITCMwg7mTXW6P7CSE1tyxFQVsUWUA7G/GLMMWI6FOhFUOrxPYmaVDlTuhZY1IbIf11w1Vv3vzgQDRSz2ssGpI2jqJLBNzM1Z36LsAqmf9fOUEyBKtPHcFrWqbfJ5z2hsebvjDKKGazxuTjl1MgcYyDeywUN++LtWHHePAcRAaQrxTSn/6EEBGVlhNy4a075+pnSlkpxzrN8OJZ0i4mXclLu6P2aypYIxH2R2AG6o1SCVhkJAnrjX8ZCL4oAjS8POUwbEBmr3ovOnfs1O0oV/eHJSBqCJWJd/TIC93fjbheoaEpl07m46B/M5kxCmy76JxS0zKRNSPTdXloix8lofYC3P3jXuqQtjjt2NjH3b0iJE71dlQBepcmFhStmrg49NYtWaS00w+RR/pMzDfo6bs0Wy/XPI0r1usqJCwdhkTbVyXpO2NCNXsVeBz6QEv6sHxq8rvmtK3q58EftyGep2mWI7MASngr76b8NO93MqWjUouEE54zACY4tpLIW5K1Phwhu1+YrmEjGbNoO7XwHsckGge61u/32JMR0iMMzlpKwG0HlANrkTI7yREQndFPcHgy/YKyTn8udP1Uo4mEdkT3LCUmLg1YpWSVkKNuqeUlsMmNSQ5HfpSTAT76DUna2GtLM9PmQw55eRVFycWYCCJRxZJSAzG5rv0OBs5zjxS1GBQhYS3/Nya5UPuvDTG7q/GsLvGa6P2L627XKtNVVoPsS/vsRAQo3ocJMrqHvOfJMgZmFMp4eY7Fhoig9d76OmIBPeeOzGPpGeBaKwJC7qws2b9RPp8ozEFtt78A1eKVhuoXtbFZMQ/lqJW1odg7FqW62IRbk4maeHOKmf9SbMa8HaJgDC4aj6eOaKd0aL5RLZ9o7E4L6bXfYmpTzk5wCHWgw8RXEu60Sd3VMG0fBb35KXXOQBXY8AhPowHy2S2hyWnVFKHFC2gewt/EdVn9poohcPpdo4pmLKFsje9vgX+An6vV8LjjkZYvRKP2IOPvSG12MhqRs6cz5mPxJGUZ9CHhKBDGobVTWArYVFQ6hcfrDy5NE9N3yav+WVW30BhyHSPhhSHotyNoq8fYxzsCdHeClaEPY21S7HJvaqoIYWNgygdMJRKBxs4PnHzRZZ30mRPCYBftWTpwuS6RCoPSSg98zQIP4LXgyjjp1PirlPWu++mgRapTNe48x32q/EcCCq47usORYAfpJwoDv2QvvMmMCcAhgsXBwcwi7AtHtUezLcIrfOr0eLjoqAdEw0rsESlVxDFBc/dTeFMx5EY3+y5Vhf1qosrwIcywe//Okn2F/6jukHJFObytsM4JQhYjklsIH9fs+DY8pk8vryswBGUMrWTiTb/qLzX4VujmU3jENRmlW2pyfYQYDuuaI1JpNjk2TSaxr1o34Lg8fUOfC2mlLf6kOA8niFuuGTkHheb2td3XL8fFW2viYUjpMmHnbPifOR6pb1SdXDqRM+v39SsiI0XUHGTjzdtaQ7gjmAOY4+wbVfbSpNizXsbAO/dCsSVLDn8IRYK9n5ooHsBBRFnwlxVwDiIsY02nRSE/Ln9JApibrmNeezOUB0BP7lrW5VkAPKSezKe/CEx/a5fpRkTIgdRnxTMuZ2UzEYbYd999ZBPpJcVMWrAhAnNQbL2TIdnvae/5iBEXAS8cGOt2qVcMEdie6JABt+kIvgi9daCrXIAiFl3zHRNOlDStP+bzC4nFXjANeJEUIRl4Jl4EK5rwR3sqVGLZtcSUCz5Y4kgdOWinwFdh2Q9KEd8bLZmLku5m8PmPyOXdBGaUwI996lACnVoSgY7VdDRRvrPwltpZqj7fV2RBzTLWWn2BaZ4a9gr9k1TaHk7oxCd2pGtZw0W9BCD1kDbeNF3x8S73idO/lG++6vYuelmQIjJFdlBGntbOItzr/TkFERDFPxGxlbJKvPDiPCFSZoMaAY23tUpmcxP3GPCGMyMSTgoI2sIsqlly1LE+bxa2wry3WzrPwdeTRvxZlWNvT5ZiVv5oTr4rVSX5dFMqigqYeDrOXa3wlmAmCzW2Wn/jqhKSgAsFT7aA2IjACPO/I3AhWIT132t9bazcaoRMgVIg2y5s7vkdK+oQO8EAMSbE5M4Tb4BQMEKtQdY4OCEjT+OnofXwfBotZMc5W8IaQDm7/x74GTdSa//aLH8QnX74lI0fGyVr1dIg5rcIJTq5bCxdD0hWTCCNirmhgc4qaKlgoidtCBckyvX8OyX28IDAzyLOuBOfL7tCI+hMf9cEobs67gkGsrGYxyBIJWtY/UQZzexUatPtC3/J+rr6q7DcI8jXGoIuyx8dlCOBlO1zz0lOLKXR3hN7sTRqeWQX6WB1uzZHGFshCZOKx/XXl1Sz2ZwwW6ocbqdBx25eg5nKWRXkFti1QZjzmIyTVoyaPud/eyiKHF2nlb0BhJxAL7AS1gvY/tanF8MQtQOJNecbWdMu7hWUR/NuvMtlSTcC99H7Qsp4vtUx8Cqm3ubbhPBuyL8vesLPdSXukyvOePCixOneHDoN0DdZcdLNfVdwBHly7YQFVIWeLJud7cU/3glDZbJ7t7iaHUDzgcgzT5KkxP9z5iaZV1Uwzf2h9ptA8kNc4hDLePqR1lq+jqeMTxzzhrsiTUgTF4Hz8VlUfwjTx36AYLFW8zgG/j9HbzEuh6n0KFbqkdD/rgq/NI8vPnNEtrlfD881kEsh8g+Bx96qH13OnHcZTMN55OxAgZRux6FoqoKPSQ2uFmYYNSm/W/8a074BRSKr4vG8qnhmijimO6macywbkSPSZz9+cMNfzZ456zu02MP5unaR0X/ZAkWwpyBXpFf63rTb/9vtKMCpFWDTLQeCoYmoiAFVEhUlXoeq9LLfrTAarxP2C8tBzEkvwKFzAxGJfDINK/4fC35N3esIbdYKJDvFVpVFUYMB2KNyl99pKtwKMUuEoPkiWCz2lIBVdIFAcVRcUkxQCdEqI9Bh6uxAH1RHL30hOuLbUmrxm2b5l5m6JH5O9r7+S/ZIs1AIKWkqL9GphWvfO+Vloo9F0cq9Dmmcx2yDtI1g5P09D6aIg+poxu8aJiTNq3l3LjdbejrbypYcVklgtW0KwhR1Y2EXTyCNMB4r92IGMs3zjY8PwGIOJUS2Q3nxho9PiAUbaHP0kQJzIGDe5dypsrlUN60eu7O1q+GhF5NN/3biAVBao1QUzCd8J2NVFi5rRkXRMkxdKJyyPuRswteVkjEG+8u0AOvNe/7G4syR62+5y6tZ7E2q4H0r8UawISmQ3jZAg1E6hbPl3NtZH/xHgzBNmxF4PPQFznmMwf6Tct425PTKyXXbq4+8SdKJ28MHCnfqFqF5xVsJFcpmg0r6IHlr9PcCAXujITstcTwT6RZAYB1uEzuUm6WeiLUiINvaceOTf3SLkxqFabG3D0jnVVcafmmcieuDgmTjLLv7hjaUr6KEhqzcYoWz5MhY362+oDewOGpX6dzFlRNkVjNX574otvbjFjhprG/4txq70ojjkfXRT4hsfs62SJajuqMWmXTDYNO1UwErHxC5yXYmcaX45QaOajomAdKKgPsp10iHx20saEdrSkJEm+NOrF7A3z6Qf1B7F8gzLy2NhguJQFG0t4i0hpHBtd282xBmYg/+gTVaErt69ppU1NEYwlmIY/0zfEf+eBLm1IxAOp0NYte3BWSvZRMr2iZa9TANEH8gmSRWJjLRjearrDllJi6UO5vnSQjL1J95NT8z7e+WyMhvzWJ4PVjaRNT+u2e5jibA4AicKRWMsnU0bLFqeibIH9C2u9nX9K/S/cFwQKoGD96RhUQ/Hlr5pn15/k6vuBfCBLUVEIvIXTqLhVmBwqX9bg1+7SeHGuSpBPhADQyfzR+mQ3+nL+EKbxK7I3F0gbMopEdweNBiFl0Ku5qQbOokArTd30yacOxcCQgRDzE6pFva3+xH9+V54LoJBzSXrHDA8pxhzS5W5Msk8Ph5eaBqvjJ3FY2Max58VmhVr6gT3Kz256aegtCgDMeMJCNHoBu7h95q0VzNNSjOD6TltlhhXnlVpy3Uq0tIKvMd/Dx9QGVtiTtdZXIa5wP5ggxYwqJgKQ3+N2O2kMXi1qkblwE9nfLteKN/0/5koHR1XBwDugfIu0AJBjKVnEHXzmBiqPp050YsgJ/HOlucPuJKb8YqCjXr3Etn87gW5QHE/NASHxnE6VoRxE6II02iIDVU9XjgRcybduT5YCVXaydRBOvUnwB5c2PawKG7YZGfC7/kVr4AgRaxmSnhPDOvJH/E3oHr84knodFh7rpbDgkT3Ot8m3NmPRdP8Z7PpOqkorhkRXux5o1Z7C3/K7j+jVvvxzVpWMMIVTquHece1kHsDxy4gg7nUo/y7ozVDtAcO0H2LbAvMQQD25UjjrUS0ndPaxd5BAlBhCSDJi9cCXUIT+/VQ4rJN50UvGWRsQ94a9ruqslScL5dojP7rNLVnO0zvOMVb/dRtVC3KO3K9YUmsb8TVV0mdOR5P63cUQjT07LdwWPuhIgc+pbqbmo3xTtkJRDbk/Z6qsjNXYOMkiHQfsz4Ri3GrVnDhKoMjaCYsYXbsbUtIaJBbvEQsbFKxgFNkmEt3Rq1uv8aIhkK1m6ncx3aWxfHAdiuspXSOR6yC6GaLA7foOKWMiCRLmunbCnTxUmh1XZxk7+GYVKdLOmE+cLwp7iWySdLgrdASmKsYihM1gjooFaKN+/Wkuh0PF6kvVTIZ4e5UyxEAPieiJy6GDYEfeRLJsW2Ru11VeAA7OE1+D9ZrcYn2L4Fvb9SepC0KXD0dSJ3ARQCTQcvBbztlrSyFiRF4oYZjkKw/5SrKZ0GHpiAk3azjk5Hf9iQAgfCURHkH4lgjQ1B3TqtoPiB89MaAEe+K6KDMVFCRsOXuJbGE4ObdRD43BmXBvQGshOnVfwae7Jz7o9+T/7CyFj+YQOO7jvLCPKnDmcbVJPTkstFiybyCFv6+WWi78LpWDD4gJEWeJIlp69wD1TKh0fjHMjY9Gtowu5SD59g+OotsJebtjVa1qZpVUHfrmfQ9pEQUSZMPgo4aCFwpAZqf7kerY49Xq7dq2PTPGX9sUwbvUs3O+El1xrokjsnPtq/LNDGn9xmk3slV3jspTCYqyO2KNILJLZDCM28XLLQyjfypmH7tlElsLeuifEoEps7gqQbM04xCqEB3ptg7u4sOhtNwhUdvT7CNEWHdB63RgxI4UrwRsTUfYWjT7Tga1LgU4zrglgK3VtdVqA8B1aR6tqbRQY8/jblziO+xIsfLwqvaW1vfN4aRd3Q1be4D7P8jnUtfEtWxukrwnxH0swChpi4hOccU1zB5sU7vjA4gUSFUNCL18dAj3UYnfmuBApRNkeM0PxTiPHzQpK37l3kiBET7L2gf7toCXuGGJVVuXBPpVDlz0GGPuTdVHI4E7deE0zz/DB4MHQUnBr5bhuFTfU15U7oEBDiUd7JA5nMBAoMybslp3KyhS3ksUpcTxPszMUaYJLE5eKs4PyENs8yc+b2K6qhmZPpPiabK8WA6MrQbnU8DBNh5ymEdnBouYJkIGf5qezQA94aIDJJW6/YOQC2agWkjhk2EqQNefohlFS898/NDz8BYmjuC2chbsJtAW7b/3hriYW1tV9EQ2lIjKTa0Bqt9OcrhRFwOuTOvkWtsN2mbdo4i0S06006msXEaoIo+1/+MixbOJRQAY6YxqTf6H4ZJWsbkkt6LJ1kjGSMQTPKMIEJeaWgmLZrBYRmGiHtVK14rmM1dbtpPtI3NyXjTxnMCrtbxCpgMsfHz6/CaPhOAGzyhMBALCbf03E+lWyogPAK1zulpBjJzNI4AYiEFhMbpn0eernevhOItaIDGdl29ABtH0rH5RX32eJK8tm2gKv+r2G+KmZYAXIrROsLRnEESvMA35WgD22H4q8OeeL6wzklhu1UljuHSm3rfIJnd14PUy4eHfcOAiNuqFU4BkvwSLzdD/2vkuBSzDPbhWqcx4qQYIMyna96oq+PebY6b4fXPmuDueF/NQdJWvt4CtxPzJDwXKSF2tJ5h6M0w49SE1G8+nZYtRDxdb8ieYRHFHE+Tc5zMRvMLI3K93NWs6HunHJ9LzrmGzZEwU+GLEs1VIjMMWT2HbopfyiBeU9t/y1bIdPoasy1sxu6sriWTJRcK9IToTL/67pN0zLAef3TjxIgL9aDGDV4ZfaxsggncXBeGYppRhgXtDhOd+qCjyV4DIVXZQYKv7B2nzEh5+ZG5754m4xsuwTcMXiF1Hw1IEnZvosHn3L+eP7xRa396mspU3a1cCOemJ8RSdhGDNxYj4Gef9SzFky8Sp5wMnbsIfZCUUkUIfPOSK322/GpzdVFPm4k/31Zu0yMpY0j/LsHU+zlaldGapF8b9VXAY9VW19XPEeowkr2GxXF7lnZk1bTsRwFvooKoL3zxovRhv4Qmo01hDlS7B43S0hxFKE05KEZcRwn3cB232JlY4dU4guzftXRAvOBX8U6YVcVBa3dWJ4TjIhas5CWCkl4JdGUXaNsqLbNKpU/oh9cQ4DyN2hPBeaOat/EKK6Vsib8fNH74uzKRQ3HzqD10wcLMvlzYyYUs2ei3CJwM8SlCIkahBIcYpWrYZqCuS6sZ/XV86Z5JXlvXFu2mtxjrbradkuLNEKlw6uDMZBWqKAHHrK3EQBVljVPT9DT5JofFfN1IE324V4YU0ClgtjwXMh/54jct1I+NmrjKtTcO5lPC/DieSxyGBaQBmURGyM+Hoy2smUjQkIt5wkJYQwb5OiwZTMxM/WXBCztmYZOB2Pa8p+JfxdC0Q5XFf+ev3O/xerKTQpXxdSV08lajclQn6qCMkW56xmsOkss6+nnNQxnAL9N+WwLpMjeNpSB0kB8Vf7EHr6Qu5WPnw1AvfSpL2iiCXVVZRUgaBrn8XoxUICtzdgtNxPJXE2TR3+MRzZJU1ggI9rbcwHHGqJossMMZH9cwj/NL+rWO0R+wHp9igjaOu7KW/Of5M1jT4/WrfhXd33aqOewclx0yeHjlu+6ySGqM24cYgRa1/McqWeNw97WL25OwIYLrC+PV1vdoQPf1Gpp0iXcP9HTmFH6rlRAH8ns0dtXRoZl2WX5F8Lm5mtpaG3Gcb8Krd9j5J+JolQ13aLa2+QzUnyp1sdz9tw+5RpVCEDlzmMqPoYukcjwJgEU2Q8Tv8f/U+HaBGjbwMklhOnvyNdbZ/Z2fRuq1G1XtkDzDmexlJ6bouTCT+AzsJetrnTwsNCYumky5Yeba/EoJZd3l1bd8kyIe8GgpzoubMgDlIzZwBC866HU6lUhbeV+TcWE/gaTx1nRh0fPSZI9eBx+wTe69ZV//1IInI5BIQDs8yn/ngmFeN/n307VwpZdL9OMQO2DL+Q+y0Jag+0PUkQJ9e7uU1Ms0DwyvyVIUJpPom4cYYVv/jGEb2RZvtDuYTmSNbNafTaPAy9g90nll57zuNUAPeo0xQHKVNWvQe4imTd99lBfODjL+C9Jb5YaBSbLLtuFO1HX0mrW4IEYs7TucTJ2CiHchb0eLWSImvFVDD1yT5Fwe8ZLa5Cs8xQWXCHArkmwG9YcHLopFy0NPTpCJfBIQmb+MZs2U2wBDlAe+zQfuyifX78AX9t8jpP9lEhRJL2EewU7wR4v+EgUECJd4vQVjeMngwAft+VkR1dWDmKuysX/Xb4WSgzkNtulMEcbYya+r9lOPfK1cXoBewGpImraCZuSaCSnGBIUgIX8KOMLpX9g48OZ5IfMZGldZ/RAV+6kq6r50qQdm4IdfgC3WotJzkLGkU8dcpISHyxOwEYiiQOlg7HOAXe8sCgngw0EdLg7tbT6MN2wrVTit0F2caEnV0vsJsaL8bLyTvSOZnY2rgCqElEkmwmGzIGACQumQyqyczM7+9eW3FkKMRseB2HFLzb+h472pOXg5iIZWODvOkgr3qU2RjCi4yivLn0IlaQwVcy0vnd0YdFrmMUTYrhOefUWMgafzRZIE0T0Yzk78WfR7417MW3PAdR00LYFomziwLMp5WAglgKN1PxAAoIJYRUF04azLTrCi75FttHDkqQUEqSY3fKd63QSAnZG75oqnc7ehuo4DNj7VE+yuUEXV/J08/Mv/CG1fRl0YckwVLWvC0mf9VpuocBGyTAMWHIiyiCAHuf3x6yWRDl2p8oOfta5inwkD5GovvUhRpuffQgGD8M9mbIhwtdWsxHE45lTfDg2OLUcS2I25YKSbYvTJY3WkJU7Cn6jFPRiNuO4Gash9ZvyCZU8gYsHdrKmXq3O5trTe84WOQbExBQ2XJYoao13QZEm3F859alQCJH0Ov1l8ujLGdcRt577POq9ncdoaa8dqhNygDkh/hdxmFp2BOhRb2u2RZuLytxVs5X2K3ud/h/rpiGOAQpkrs1KsVkIqvULolej+Rvo26pvwzGCO5iqI3typKy7QxbRaTVlg+PXjygTb8/vJOfQjN2OIxbBT2CJ/dOeu/vt4AO6Gyu4ciA660Jg+oRw+RAlJbIDXdSsYWq5s4jrrADvNcpO4YxiS2l8FCOE0qRZa5dpCsfHpq9FNIlLhth8agnSitKEsFw/+VMS3G+2sbavMchEy+3fsY3gJhgISHOeBx0X/UefhXCAcKMPHWIZKhrJDIN8CJ/whvykcwXwh1UT26VyqBKUpD+FH3jtzzz5SPgNglPpqzDwemO4b03R299M1bWd2m/W+QO4WAbbWF0Abe/Fkbm7LxKtgdnVdgLEMOsN0W5ZBv1lJIZPJr9BTv3axoi6rmFpHYWJy6F+JBJ3dij3xRH/6ef+DBjrU8iJnFQQVuz5WWMVQsQSUHnak7s75Bf2HLR+7T2kW2gfWSVmQEOnAHCBbvqWu7xUUQI4Qja0jjaoOE2HwBXEMvTNzxq6aTn09Dy0J7VqpJUpqnLz40Oz7epzR7Gttz818RPO5Nh2zo8Pk/a9JKnk0HZ3tv8cxwKwaEQ8c0uzYe3JMDqiaFDrP5j28CubywepoUju8to7caIZOpz0rWq+VUEdHtxbwNtDZuQb1AVMpuVuKn4gzJ2vxICceOXM+jLSMLpXra3jjoQvudgYkSzLCkAHI029OZoU3VKqiCbmeB5zOWzdQKVtrJxhOKYTufCOD9IFM6WUFO8b5C0frK8csxWu3ui3kNFRjG1MOigVK+quBf9Zlja9ndENG89/N3Yl9EMMsLVQISVJsJBvEUlRgXOTCyO5TgDjuF43Rn8nlp0UmieCJtDrDW+2NcURwok1GEdL8QA5DNUUt6qdljmuvu4pvufaptKYZm+GTOpoV5RrsYkuIvf+JtePHc2S3vmZTQsbWUjRHMcEnaa5b+b5ZCZAU9dYQqMUu2tUeNinom+2rAuHkslQ00sC3/0wb+hZZBYvBzf7YuxJ2oIKRtWYOMZsvV6gyLYyTqZ3xIgpByRavqNMjGxXuaAg9hw8zT6+c61NpRMXmqPlCA+K/BIvaIQgB+eLHbzpdEhGhQzOkiwreL2/cEz8YHciNcei70XUHujIWfwrie+MJIM9pE2ysX1SfddxZ2BYrPPhqth6O20LOFKEFNYmUb6ToExSWb0+bSUn7PsNrEPhBIuDEVSzWj4/1u1OqX9FWo6fSc9wNHAImTAysiNN4UuONwsm4SxYToSwZmnuToAUVC39lDnmwawTlHyUXFhJUCY+kPB+Tlut1W8X4EVOWMkQHNptJc0IGYmH6D8iQcotHX7AZdotpzzRY9nLb8kBffuK4wsnDhwPxP08RyrQUC2dzxjbz3ruwSYDk+QTvfFDlqtxhS3X52BChuQsXur1z/tTBMawlWTQpSlbiPpD79KXlYbLmfIYh6mugJChR7VWEqZIDM+gPjOxjoO3BS88IrK9MNodCQKU7xR4neOqDQ2MjuzeTDfFuftiqOj6nAusYIicno05TInzcZDik+RUg9QF1Hx9+BlTT/kasmFSAmVtI+LibwvbooNQyvWl2mzuVl8LcSNHupJyrKGoAPUuloedFBrEoDQvJJPw4602FEDLOvOacWAzAKnxEZp2Hd7Lj2i+Va/sg/GmiGTDVOE/CI6S5WyFPjHBjnMSoShhMsF9TomGICO4V/zB4OHOFDsiNQfKuoiuM40GPAgWFZiLSozzVmLu/DMLFJzBD0QN1wJU4bVGv02hX2lA8+kdUqmuyYB6p4TEDG82x/UefnMR0I6kaDt2cLTEE8l0tWKYLxspvTsrGcXscKiDLTqFxN1DLcyF2646CACFbUHynWA3QswRJuvqIDS1YWgvTf4VXQEwixGVu+FMrbVcMOYv3denxjfn5kys5sKS0YEdgxRfsymEtIddMDjVzJ1Vgzl+qfVu+p4zIHDuhKmY3PN84GGLbiRJe6FSMRggOWNA4xM2pNG0A07AVe7PibsWtq9UmlxsaZ3h67yCHQHQNPnlmbhxo1QGCAEof2Fe7rDyf/tYHSVZwJNOdRdbARovRbnEU4QgrYKaipqCio5zGZKnKtdlveuAippS8Y/jMSVdzR1ksptTkkaFVp/lgeZTKATrRSmnO8lqoHMotA2MMkFrV2irDHBXVM0hNy/dj7T9ToFHxIm8hO99AMBIGz9BW4Fr4ZKDGmStOX7Ex+c797vXQJsNbL1+kzN/ENemiba7ZbM82k2pUFyGL1AFV72l/s794FqGq8QCF3o2smY6+CrW9mXUmV25VIdIlr6w1EjM7oqNvVpXbquYb6xZZAtVh+eevacTUR4XFGlK9Bb/PahuQXpYXeXSLqddE0g9niAG2JtQl2q5amb8gDhyzuQXG5IUV/zSjSbFF1UC//mS1iBVDg19tv3dEm3hS5Pv+1YYfWl4m6oN3zlw0OXKquNbCt1PQaKEWJxgRoqEAfgnKVpFFSUD429ELc/BQfFv30eWD2uNnK2DUiIkoAjw2kjO6nRAxpc6KzbBRuFAThCqoO0mP1h5Jb9KbSDTsqMfbnG4BY238bR5S3uxYNUWjDorgoinNqN1WqZ8scz1cUDxIwCSaAbRKq9IipsQlXXtJifPvaUQS2sMsu/8sWFlFsRywtnsXdyf86vcIqsdGOunIvvTTI8v5vGdVPmjN3IfIS/A87KFmZb0oGk/Ja9wXrg+8K3XLL1M86mmOpj9NEiA6A2mZFU0dou95XKMdhp4RWSrognRMQkfZLRzGMIcIAAgk0pTVehGtqeSFjBPqUTmcaPTViOixNAiL2MiiHtXCzFYpm1fVyIfrOo2MVgmX0hZ/vyPpsqXlThW3RMVcGgnJL4p7LFtQSOjbLTsgw8khNyQCGDZcTlrlad+T3Qao6/GJvji7cjnJJ++9BdNadN7ljjuKNPgGWpn9dg7ogcJW6y4LUkwFdReZQ6kvE4wThx+g82OanqWNsVUarlh7RMNV3i0a8SU5RZ/wztdoxVxNJetWE3t2JfwFijBLGNsymNzrcxcMe531eI27HPTTJnObwKyovqv01Tke5W1FWi8QNyt7uGxUxCG1BaR96nk8axmziszm4db3jUBdIZmjpS5xxFw5f50GsWgz7p6g/y3Sw7SMvUf1AstQDkC186vKTvHEZZt8qugZ2l8Q2X7Oh6ag1eaVt0bexJ8+ZI/tE+JfDgKGkPHeod9FRSP+KpODSrdqYo3HpIlmKUpKvJxypsg+mILVUK/j6a6LSARlZFJBvgK/3TM48tLYgorHXdNOIY8/G4VHCCk4eU4RWKZOS7sObDB/nayopsvOjRd5tXnTMeLKCblvrDgiPZwYngzO34r4ZgqYZ7NLcrAuZSenhJ2eyA60YBucQyDQ1fTMA+rWvcS0Y8DNQb0j+FxXA/FkFHADIF+BsBkeZugSFBoIPxkhstfcTpAPkx0wpB4i2+vd7Find/Kw1sUWdk4DMt3P/X4hWbK4OI3yDFtHvKCKvvED8yCp4WWoe6bV1/UT1Drp4EbdLZNcEW7YjxtDDR0g6w9Lmt1NE94/VYvgscesT3HU5uLUj/E0EDbBheBlV6obM0f2CuRH/zf4EEK89H0hXFCuqBZpWl+8uiS+TGtv51cA7L88EdNq/0BVGg0sI3xQDFJ//ZU+haUddGQE8YI2minsc/SiZCdqhA3HgFYI5zWmflixq5eWnf2EZ6OHA7ka0dkbv0HExBUTNMGS0wLZbamqSCeRp9CFRYwVX92fljb9ewZj/GgTKkTMm2Smm+GgXfAbKUl+ZQpWUQsCZqPdYSQ97RExwclQjy84EGPgj1d+EhM9Vah6eLpPnKCZoWjE7pYhWEjLZyoC0wq08SKvfXqwMKLNFZh9PQD9v11IROOL5QNJh5hjSW3Y2CcHF1n4hzSlGUlp7PSp7ZkEp+yBnT+7F3pj8TSwFQLSSMjyvcxICfDnGtAygSh8XPukQ6DsjlhGFqdQI8jeiNYmjlmu7caL7txWVLwtyn04MOm01BMDUICGT1XRiTGov8sq4CKmc7wy+tTiggSSo4F5jOVfSrBNv2RRpJjEVCJ9BBg8Re14M3xRGCv8jPYQseZrhx/NY2/5mEqb/6WLz+pVL07WWRPhFXGBdaLTQ9SJ+YTsWXq/aEpMSOqg+TZcNZtG0uwx3reoxdq5VXxGr06fNPi9wWB6tcsFpL0P87bVkIqB3ogooTE/wl2fDo4LDSD77yvf3MA5hPO2Syuq6kfb+NJ31XKPCwgH/vuEeXkUShquxANPHEoYX67n49Y4ndvO6k/AZDC+jlMoOY2WIxMN3L5tq18gtoOCvmUg8jrz5JvBmpRu/34LHLHPxPEJko1unEkObJ4we89QzO1/8In4wJ9T/+hdmzJvMe5pgRpIggbnmMy2o9lP/pjS2lk/M5LoPYlw9PnNy9r/u9F/AdGBTayH9NqQzCj25Zl3IwJzVmytbcCX34RnyoBKK8VSiJhKN5xEo0uxx8iyPQfh/s91rTfBQ/CP/MCk0hG/j/vzOyqw+2qI8jkn3Ja+Vg6gRBdIZnhztjUArk4K4qa9E911/rrTtAbhzUDdkySuX+fziVARG5R/T7Zqj1zZ7XOlUXEKx5nX2dTihKTyPCy5WgqTz5HrPAqJ0CmD9+mS1/vJQYAZZ7FMsK8QU7bZmOdWe/pB7/L73LkyZwM6QHkCgiFqOPc0hkFbnka+gAHMfiXF2fV6IY84QOmihC+mm9w50arUPgJpAwc9uILVoh0R9w1QGR4TrA4lhRqAX6A3zAVdc+Hbg7iFhmQswoJJrXhsJiKS4lRgtJiLO6AqZa/hTyx1K81xfZ3mVfzdo1mD0UolVesptODl2w5VYuh8UF257QyqpMTf1lUuuzwBy2oeBu9gPKJyQx0A9lN309iJxlmexVYNViP8mHIr4I/6MxY6eRRArw+cuFPoNp31WU4/IHYxB34nB1L7D4GHBwjjPfFfr3SVlYysL0N4pPNaM0j+dDx3Wtd62n34qU0vZfycSXxJgPF516IW7xhgh2ry5rgzshTWwjE40bpkYtwcltny3l+SDOY9LvcdwMUJB8CpeCZJR0gNgLmVGKi3+EJggqhMzB//RziB8Kosc0S89z7LCd5c0W0q2qjhAgUQmMpbjf9raV3plkkZ5F+NkKLnM+h4C7sNjwNQM0V3lTS3hzQ3DbEoCthkOYNCsHYsWOMezYJu+KYmTOmpf06seaPqrSDhRj1mIoQa1yjAhvSMVRkTX8DblKRWhrnayXEjxGFRaIGsPMNjkIyyfxgYrpC3tDqnLIitm9Rd+hczde+8r2Uj4p/D5pL+MzKJ9kxOmasDqUQYgxwsLbJL69KRUxU+euFmRea98ga7FAb7Qk+F6xlTow9Pcz99t0l6ILxYwuPkbRxuH5gJmw6M/IILheIWsl2leHNn5ktQKWtSG46is9v0oB6J4TUuTHcyA8O8DPSW4vOWHjnh/B4aBKY4cRhydlKz982J8caJdR64x4YMeTfcWBSL4I8pLCEs0EbyO8w/EVdyvD5r9Eln0otRmM8JleUIPwxKmcEalJ65+JHTcEEyo6WuciHYS/qFyA9kq4CdtSmvoJk7FnOk3SugwtJzNC+UfzQudlO6MP49ewXTW2A5A/RcIBOrLEzh2hjd9L6+yb/XiZAQ8clKkFCJfgtQp2qI9g7uBQ0sriPIqr3Ot4VmIRzE2+W7Na5GLuz6apvGNQX22oZf9ln/LMxjf9LXBCJg+MQqyhIb7M9g5l01qv8c/OInGlvUN3f6BbcRmUG4SADZEg/Xrk57rnVnNVfyVOPxrIG6Px85bJEQtmGgwftCvywEmFQFk/QG7HIRrlCMni44EvL97cHjD12WLxavx9vcHxe48AXW1ZDUW2q/F+SEVzXYAbMGqsAxs9sYFS6jF8w1ljeKftGJ0CefP8xCMzYWWFrOOrY1N8mvSJ7Yiyf4ynoFdLkus5fLGT1WXo/p9Tyl8VdlkaEyBK2GbzwSZcYa2mrPmEohJAvgEGLK5X6n5EUE49L8XTFa6N46sa53oXyS4oNZcCgQRmmmJmN0wq1KkW2q9IvBnL5o35Ht93KPiRReD2S3TpjAuuta1Qwsl6tpMY4i2JVxsEW6fkAxjSP+J42/BJmiBFCqsoRJU9aL8VP4YJQm1QtJd4fYKxVcVtdOLN62AWiRt0OPZsu/O0twnUT7b35kixzubB7U8J6+aa7m6+Blh252HyB17WwsRDzbRIMkCCRp9FtBLcZtHpgSjW571QkK/i6yxrSzC1ofZA+F2hpHKrAbOw0zGt4zo/mTUKv0YDINAVEPExWXr2whwoLkqct1tf4czxE1VWv6CxqxCJw/w0G5lATKwY6Fvk6m9iar97ewd05wMHhlfW3ytDUuwxZ3A6yTeqim2r2Gc2n/LuqF1PxPBNiD81dX59jSAymtj572rhy7j/dAD9myQo1HxGOujL9im5fI0FJDz1urTuE66bmiOQzwvixtR4P+3xq9M54CVlmqX02yudPwruOEeZOXiFuX1b0oFMMn1CYTWay1oCofe0XxqJ4Gy1kERnBeJT5k6kr8dfJ5HLm8cMOm4FUb9yCqITCcIc2yUZP6d+mxSq+yPKLzy6OP2IVYU5epXWvzPXzahpnGFCOpG8j9EVJkvIi0g1dQ5TZI4lOpda74QgNnSuVd9JrzNdB/57BQEqfJGTINlIDsazWQEhQXZAQ54/q0Qns8So9TwQmlniyqgzSAVpISg7thUnpW3HF0UwIgqzoLQXOxX4hDI3V7Wxh0cYuaxcmx996XClrPcXFgj9JsdCoMBml9pSqV/f2UKfA9nwORelfc3xE9bkfXugSwFMyEJOD9nmyflA0cVezUEjs2fw2+9/5Lq1AHFux+Hp5BwT1g1e/5j7u99VUfTAu/fDPDariltobvxc77+BTelrXql2E9YjgbbhcW8O5/cmx/QDmauxZS0ROpzvHY8GC9vbOZNAptGniIWr23Wi5WzaFOHlYPFyfaP1eeneVItJSjzdwgYHAkRXLJ5pP+IdvnZ1iAQqY96PTyf3NEWRDNN18wgkDSY7+PVsn2xB4kLcnzGNvBpfOIcsyiLKYpdy/OkczOoJM6k4hKsHX4mg59lnxMut5xiX4B5VJdk9hITrr0Hc8uWSLIK6sP7u1Fm9A7HxVmd9QY7p0JPjOZWF1NVUG94QmvQ+Hu3syAbNnyB3VvEifdA24Tuk+Ds3akHjNwoJreSmz+kL4kEe3Fe6YlYHf3/GYUD5EiIfIG9nK9sQP5Gajce0/Zfb+T7UdbW7Fi9xdDU1a/SJhMGStLXajXk14mSoPkjQFG/vdpRUvg8Tnj64/1watipIzAjCCx9quS413B2WWLT0Ywm8tEIjIcIJ3arlcKHlpwLFDbVEX6EO0nNqB3gMNaIZhYnSBnepO9e8uDbkQRdtjFihIlCXaLNOTQ7cpUJMEA9t8mY4Guhppd9CAz3etY9Zj9r3el00BnIiRKxqLSRul11HMOoahjpC8Lf+Ojey1NwDhlJcyyIPvVKv+HlM53f7wqtppMKjZxx08PC2sOvFDoMI/lY3M2UYW9hoMmM8sCYU6QHfHdrehIILB1HTsp6uT8afyk2NdtKfBAxoO+LCJPPhKxpz98BH6bZCI6z4qX9kJ2SjAV0HT1HzyUwK+3iyCP78jKfcU9/8ykbcmk72S+ygI3Deo31RqsLj8Je/1ludpP0lepNbaY0xmDQSIfg7hWGuWF3meD+ruPUoomMDn+DUwMorgTVLYJli03GRw7LvoNSYZk3xuwa/F2Z310JRDEaYyg8i5Kjjat2bmpZ44M+XkZm7GUpLxA9Jk9eG9RO3XPpvcFV9xrj9STChFlwXpXKysk2kNAmhHiUaS7mf/X/oE82SV+W710SevwMp1Nn2UTTlHHJltvcw3EgPMaedAnu4Vd5Q+ZNehmz5Sgl39z2rcXlz4OX+gA5Cveri7XEQgPjoFn44D1EcYy2mUng/2UI0mobrkMjeDWTfj7x244FhJ4NrpfYap7wRcnkN1YkO8jbVQtnA7O2ksUpUrlLQwMBFKE+1zaeZYvrMX5fzgj9Ru09YqQEKeYhxKDVVleJVtXkI7awbgMvYuTll6qd6ChZd/HM3OdGJGSToJWoni2xnxfa47hA7UXINxUW62MiaZeyCMhBA3ZC7Fdwa//1B9WEk/hiuo+mcPATZcvRn8uw8Foi8lsZYsLJYBr96bjxZl8EguD8Dby+ZOJg5qtRJfZk4hcyp8PWDgJ43B2hGbvKTLLyQzgnh2xby7tEAQj3osH3LJOipCC/QLVtlyMV3kB+LTSHRFQ3oOu0eoNXeSe8Uln25F8OeP1jJcRTogHSIGdWw+Uj6tLqE8S36UquDJv6wQqlLiMxWn8AaIZ3xjw9Gbx5RZGBGnrGeTCNnAYZeFN+UkFcto8guQDPiAfeqaDKOAmnpOELae3ST15l2wcn7zagk0P0jNwErabsdZUtWLLYaabLu5hKb74Ydw/yPexES+UWu4JXIz1r1rPNfoBvB4SwTCEOt26Ar862aotgw3r2vp2YFDJXqJQzOQddRYENz1DhgUHZWusN51u6BKOflwC7bSS8qA69PTIc9rMYEIwtFjs2+rKGyPjSBRQK7xJujmccHlr4a9GMsyQeQKBJPPDTJnHfGrXZE3DhTXgphyrKmpSZlJWuq42QHm16MK/NqmOrQY1JbPA9wyXa/67Rc+z7RSzME+wkFw14cqUEhXk+oqoV/7L3jLtlVYhpzNuy0g+lNPkqVr0l3A7OXRbyRdOfnm5e8PST9LZq+ysNHB+9/43u4d4G+oknoF+LvWKi4kMtPCWp0obFUSSCnY25u8e+GaWL6xETfzy8RSTZftyvai1kTvomFryEr7q0NiJcAi0x0KYXJ1TACoO4prYS6gQxM4HRWjnlRKCT5aeWEH0Hbh/Kt2zS0ZRUyQj6SsITZAkGAR9V3aZtLQy/L8lJnk10L8YDyZgoDGA8/bbRVNS2f24MHw+DYGxvj1/WnzFVPb4jQJghiig3oQ/eidszQtr36FOFv/n2pXnsFzgsO+p46uMug8Gva04oq7FdjC2wWIuzcQ4wGGLvSf9a0KN0ujRRJEDVJpCChzNTg73TjrBIJRH/bGXVUv0hrZxrP9UzCmKiT6N5In2G8alXejw4vPvZPbVrA7g/a55W8ONjCadzIycavYArBhUlNgLfoSJEzdQIiKQNhiYUstTX7bpW/H7i0ZFkLb36j8wnxs37Kk01FZH0sZFk1WNZxtHvOjDZNbC4M8Y6sbker2kfDxZ1qIFhu+B4pK3eC5xTOzG+3uqOz4xnRTBqy5t6dV3RPFi0LcibmVltQFbT2SuxlwMsonDOLWRRc+UHc9j3uoZogrRL3Hyg0lE1zAEOv3RsDzuDueNfpc9faoQ9YQ0ZHYBioLfDOsMKbuPhdrTlJF9FodxDOpE/Jr5q+dGhSbyqNOFIDSzvXFVkfnFwluNk5kIKqatz/OKjLQA5leOxA16l57BN9yemiN1PipV65Z7OxE8cMqecZV94pCqT52ntMg52wtzZdKZMDSIte6TX2kOjVuVOFSVNwA8bFzm25HJIcSfdHcUlEh8b58W6bngSMEtybznkfUU+8CFPM54Sh707LhR8XBBfnYG/yxHkZPSzUubh9slUBIfXWXE/3wgH3vNRaG5lMKyU3E68/0OSbmx7A5iuGQqq3H6x7Jl3VTvyxZk5rx6ty4RqsmaNN+EtAuR+3OVjCtuNuZwKW0/4dLRcozD1pI+HfAH4+ydFEAQrSotIoLlrR1gbjK+CKNDMC4B8Mr+/RQnvrCWItdUSc9nqDm4TPbuZDWzpvxWHQrLalHM1bo07dJGBf2yeMEDnV7smMRhVHdxjd9agc6BpvlH2SkvHGvEMOD6HNX9w9eorCdTjWwHGdec/ZYI+amiXb5eOl0Ne5+t0q2+rt+1OWIfe8HmuRumcnxBN6nGBTZTbTPfjlcYlOElPriVsDCUOINqp3esJrdfBwwDVYH6agIxJs6YZfPodApBmq3H8tXy2HW4Dvn0el06bxJiwjNxxmdtZnoDR0zloCJOPF7A1MFWQvyh32QedRjl5AEsZtZzv13z7Jl3omGJim9Qxs4XFgyoy93/ac8wLAIK8zSPpS47AO/tNUQ0ftSKekp710EIxaf29ECvsuMOVED1MfsZ88Yf8mxJhRZ1YKOk4bw09M7MdU2W5x3zj14GLCtgUbqRf0Kfk+Rl2SIBINxQKA3dGky71ytCjcU4pes9wxQpg/xEN5EJxMXenWQzc0+5BbNcJ6m9xeIgpIAMI5WZ8jw6HJWiRaiqvGsM1JAdWxe5p3gYNtnBpMYKi3ZUcTnwMaUQt83Vx3jFIRqbFegR2rOns5kjgJNDip9RT5wvDzGdRWxfDkriI1YBxZ0pGRJPUASQYik53+8qLPSPFO6f8FE14BPY8zK3lNURVZ2NY+TexlO40vTw3uhepMO52oJQvADxsoHniUVkyNldZXzD9b67enGcVZK1sezU1Z1Af/wXszpOqpJASkYYF8IQiPbk1lmyQ69NSNae0ti+3KNMpm9PYJd6CHrDd8GSk6j/diNdhLG713mGJcOM2Y1U2K/SDhDSBhYI71GZz2jpb/pUFlhG3Gnm5OFP0Mn+CWGI7lPgBSzcBckR/03Y93D44vHd6XnQQjItC1qlWme2Tsgv60FIbiwvxgJPn1yLyRhqV0YE25wYx+C/IUCiteLrq0J5p+VtBcx0WG5xMX5VyR/jRQLyGWxfwV5tEBFIVkWudpOK5dfC7wx/jsHQZrKOE6AnMWv8dej6JEXwtfvYGsr+iUM2To0n7LWZzMFAuxft/rzjJBUuouqb7xVNHo/KbYyMs2Qpl8y+U5LaUnBEjcYp0nANE4Q7w98VQ9acDo5CJnJC10ZbEz9tRBV5KKvxbGY5mLtGoDMHJfvw8+CcVLGgcIPanI1JWrKEkfA2WpcOpV8iKgFcijpu9vUo8L4DtPYx3+sVYwVyP5QfmZRMQCOw3dohUNEJSS/2dsAHl0SerOWaBQpCTAcpd1LOsgLJL20K3mWeHVT3FA6ybSSemRF1vl+JWH+SLXqSPd1pzD75jQLMHz9wyktEwMv+OM7tnzrUdGi8uloyrl53yc2ukvEEy0pyQSE3v9Oba76ACTuSpXowrbUVeVHd++BhZ4uCPitigcFwcbARWFdh1RrPYucogHhRET6zUNB4ZQBK6EdFwG8D3oGFg6DiQHUNRfDS88e6s43eiYX166X9YVrAcZKZJs67WT3UkyHDVJVyP3ZKiSghhz1RWxHNY4SxUpHxQFGGBY2jXx0gsvAx+1AD00rsF1qXYdknqJf0r493LRj3h+S8eU4jRWK0OrZahUunqkIW3mV4HrdlKCF3+LDC7fSHa8BZ6OrtMgkD9vllB+4DDqGZmhNRHPETZiS3unKtBlYsUnNFtTRyXaO75ZGqYgPVQ+yJRSaf+Ogb9ZFr7oeTjLhmGGfHwHznrBefASX962LgW5Hx06z3IZgTdAodjF5pSdjsYARX46UsqYqsXoU6vDJidVNBzw4NI5XONf/ZUMwbnzUHedBdfBe5Zhl1bT5MoDy8sN4QC8Lj1a9vtOfp1Bx7N9E4U4AqtyDLYEMhCK7MgVZITZ/D0Todl7n6zYsZYBOa7wIb9S/r0TGJnxQfdI43uw4RGCDdJ7sH8XFMxVTu19VaRWxLIsq1zGvZfhKJO5omrmnsi3DXCoOjJPMViUizx5VZWvazF/ONLZDR/bEe4/WlbyhprNhVAA0K85HsajjRa3hYI5JH0k6VSxELH88Pyb+bFfu5lfjswDuO7TsmUitvo+f3yu7qG1i1Ut6GrdPnkvD3gnHOYScXsFypa1iCvePxabpEupqyIUNDPjGoWgPvylI9AwqVqaeh4ZsAPZVNdqqjxP1U/OmtTCjOXHrjIrNLDuazDE5B8dTxRTo+IOE4oBKJsoQ3rtDfjerjo0gDk9jKWw/39msfPwx3MEzb08LnOzShB7FpfaQQ+2/sczb9rLgIgszYN5KMyYyLkuj5lsip6z71s20gW/EkpJBMvPx5SPs20bxI5vGfHt0N93B6RoY+OwQxgazigmaINPgPyetmfqWJGAFG7A2rt9nQFLFGO0zYFoU2eAqX0VaSWUjxVwbXmilTnyxyjFqnyMDryn4Yz2Tnnk118h0cF9ea/ET8FeS7luNolb6RoO6gmvfmGxV88r901i3pIUOsURyc3MdhTTiWIaBxw0kYrbNG2Wc7Jrn1EBo5tBSO/m0uZyl6zUZWT+4YNtJzloFehncil6KBQp+nDkZYL0/0QGQfAq0Bz8FfM5hIdJD5KeFw6xhUiL+BHKuIYjll2AezlwMFulf/Th5wKs8t2FQggJwzK0byIPdY0m3gPkoaQpmqI75bcT2mpLds0a9m6/cNxuwYtOvuOLnsLcysZCCxBjbZY3VMzRRRdYiz3pmgwakLHKw4TxZi/deY5D8pbQWsKZFxMmryix6+Gh+QyJAwoGhNIFk1caMgMnve87mwyS1+D/jz6sz++DCR2i9xqI/w/Kfe1g79gLhGSSKH/QDZxRLZtnSOh9a8egr9sdyavluVMvzbUOXAmMDadlm3yLiHRpmFtek6iApR/aB8tQ7dRdhryF/Gt3G3t0NSoMXFo1BvY7pmsNy4SxCW7srM6bstZ2S3SAuCSAI7CTUbfy64RzWjvnVcWRF9iJumLCEiBYfUv4CAnE7AJy60o6Jsn6JR9qUy8Up57UF4bBBjo7zG+MBPhzjv7vUYU3BhC19vWvj+IYFLtRky99wzD8xddTkr+Rqrbclcl3wbWZrpEe6UAua98r/FV6oTBCyHiolVURn0Ev8Dsnja8rvaaL+zZd+8i810ejLvTFqVd83hDivQUIFeUGmeKvkRkRMLoW1aeTZhDDJq0ZOCxuvMN70mOE6AoEFFiuPcNyPYihd7O3TtfQuDTFuxJnJTEpWh57Ela9rMpO36mIAhkGTAZZoKHvDbn8TY5ZqVgREY++yu3xP9O/TNUzK53z06XFUFV7VlxvUibBdNG2X1Abm8OmUtDFUynsQ5SO6ng2FxH0YfvPqi3GhZtWgNEP5jj5QKau995CLf67KHTjq/P3pphbr+xcA34PSiE1rrK0pd/XuOqeSSB5Ps074e8stwhJbnuLKoPfjCNXUfVpyr1V2g+LKjJEJ94g4SI4Z30b643OXspMNPTvdt106pQlgeG94pZmF0SwBkEu6mFFgIhh4Gy9HchPDtVQJsE4Tp0pmKHF9oAIQeahsez8E+1L0PqjmIR8D2xq6qtz7vAuo09vE2dbiWMjvwUHZvP0BNmBRV2UpIydkEf2/L4MynHaMwKSNEjd24DmzayJUGoyuqVzrcb0sSct1SW55we3FC1reyWImPOSRzPVYUCQ+PRz4yOPoj+fL50kqCcqx9/KSJuePjnnj/f/aVRL2LdA6DK3glPZ8BV0Py8JI7HDgApsyfWzYq0rPXIVIjHDz+vLZ5HVVUrpZX7ac6HwWmPZRZqujX5+7GXyhkMi1vsuXm4JW5SY9cz51PZ1qdW2vsA7srly3GNex5WhW7WHcPiXuTd5CvvqYjjfNpyi1w97uN12Lfg6ER9S82EtsQFGTSsJ83SbvL055MQilj1wU1rYNCjHVyimgGUQGYAQDK6WqblstQqQ+iED5OfpQaXgZbSqhopETu1MT6SqQRmGR9jQrNnlXcAQYpSDWSQ9qSBB8nrpNRji8UAozt3WDe1v5sfxGNsLEVS241HUN5+gsT0NEwnqdSQ+REdpAbWy51R3J+8JjWjsEWs3UYjHwpGTBSU42deLWtC0qiRqN70GlIcnuVqmV6NdBsFeMl8ZeUnum00hjhmcWuOiyKfTHxbUirQQ/ojbR+Z/XTV8RlxOCJhH5Q7b/NbrLUovuD9CpyIDfo1owudPUXuHe/pZghPjeQJihwJsL1TgATzEeXrGRMUm4qUNVbRtRHEZQ/r4Bs2v41KYxEgaSw4YW6VcJYfnkilf+9b08diYs9a2wtYjIlPXhzgDVqcVx3UXUDoOfWrLe3FCsdRlbIiB9gsemNoOp7IOkprpHYRLuAt4IwCFULdHGF6vXdvG/7Vev0LI2aeaqm+210VmdG2KuHTXx7+9Rx7IhtqoDrHtzr8W4UDScNVYx/um/U7MX1G4QMUxW8Mklhrp8ew3ls065RYj5FnAYlNCJ7TUnoTS/At6MxIjMRskcfc82Gx56ubxrDe/2ohLuhpSO8sLm4Pda3YVQ6hKtM0U07RZHtogSGRIAqVO3ZelTvNbDSk/XT4un57XZsWFQvELiqBWJJ1qPT87Ormhdule7Rd8AJ4sLhwkMIe5Pa/pJJerQdZOgFsgJwal+X598mprTOYnCiovDSr02IRkPfAWFgMEq0W9tJgbH45TwQhpjE43MstvbKsGWi7zzYWiwGtbp2WgHb/tU4SYzpF0ZKzv/mNytEAz13Ajrz380Uw63t5iGqEG6BUttfknfxKvRxeQsQcukWST1UaMGa6Zsq/Sb2b55TBLq4nr9Xig3Q/Mm12oQquRvBgt+HEFjfMSWV3i62npPDD4yq9mMm75w+xxKYncScZ05cdY1Jm2HWNliqAdFR91DpQUEfTBh+BzwQ9IaGlwFReFj4sc+I3Jlh+4VcC7rmKgAwjuE7R/+rTZLWO55kE9EumcbmIZIFkneEh9dTek5IRq+4eFxqDJcy91Mxzpq10s19xqKAnEsiCyxtJcvneCYPLy7Q1RSX9cmE9R/jfgTYErkEtUf2xXXrmboqDCIRPTn9PuVzcJqwCE9+eEXXKgkVF5BJmu+w7jgKqQiT6H+K7jw8ZxR+pW45xLYkcjrjGADhoSEav+ywHNQNOKDYLZHTTjjtaZKN+6JBeXVHUMWx3DFM5nerxkwPHmX/5BavTjIiDKcvGCC5cAwT5lXpW2/RPa7uU0TzbpvuZB6VfwyIX7LXcg/TRwPO9EIMtN6ZsPH/T6eI3WtD3sGkY6kZYrti/w+fcoZdiheWfNdlJZvXX0Pl56BHJeAlYnjdoMPjk0BPRAH2Q1+HpqC/HkDBtNIWPsK733NT0Y1pYJg0/iGJCu7xm46O7pNnBjbWKV05yE6YJb76cfyYd7lKKR5w5Z+ixc74pehXPsfUFl2mu10ij0+YOWqEnPsPSz8G+zj047fUrJpszFl5YsZCiIGpXaJoYqKfltkU3bcWusgQk5eCq0DR3fv8vELyUOjyAH0IiHq0HU9PxApDDyLb/EsAcyQAx4BmzjRpHVeDgKDkIoOfHWgd0rdvUk4q6E8OwBaTBfndOw4v9EVKXDZZKdTE3O04g7qpRoEuSUD5+KdHgXcVZQ3+sWEo3qhW4SWVZUPaGjw3jLBg3QHuq2PnHMJ9sOSqdShTySdbEca5i4HlxHNGIurdgeiEFhLQEynKoxWEdrusEQKXuQJIKc8RUfbRIfv9BMZzDq4z0E0he/cV5aup8ju3FvzoXA3vD+OvJb4j7lQULfM1fyzUi6sTNkIpOc6jmRuyrBeMbtdOYOtx0x5OqCfsE4Hx7+Vo5WwVe4OeW1G1WCp3w9hSoHeMZDq2j2ooaaaOyM81l4RVywLQK1BA3QgyPPuwHDLHkRJ8FMErfYGGodPi/k1JuxWRWCWNUZJo5VBUPxQ+F3ZJ4y9azFHUJPhaXRE8kpMEB6sgNWSG0XshRF0hx5P28hKEEnjgecNwKnxtIrT1dNeyXeGaNp9ATNe/2aM7TKyzyiypjSfk5kyWd8Ul7Wfi4kHM7GJVVKTYcLUGgOpTKTDiT4WmI9tisoPGqLeD/1/BJdCOErMLsjm48MDMD+oKw8lrVMkbyMkwF1ObGyEGd+A8AEy2Y1daqyBSYZVjwt8IJhHhhIPoQjbDo1QxKXY5qwlPaPg9h4ZIggAICRgm3dM/Km9c5xc7FbFbDlWxHwbl9i9QEWkMY4C1GKddGcqu2x745YbhLHVfN1HTf18ta53FSfflmR7MA9amLCxwYvmJjXZ1p6X3dR3qKwfsw0CoPae5RC8is+rJEkusGR4+2aP6JwawXGGp9V/noGrF1pIl1QHNdi4td+qzlSdjCK3ekj+EMclXwNdg31Kc1cWTn0ZZTrpfGAjgcS1qeFF+uldi/gLGag3ArfbvsmWS8mOqWvB1+E4d0j96/rdTdhq1I5M1rqU76trsmMs1zyHqLqpB0owIMvrQrH5LcP7d15sDC91BfJCgAgU1Fvaty3qo1CxsR/Z372l3MlmDcR/fE105G1Gry8zgkjCknL58g22xuGxKagNzje6F9tGkZoH3GJh1pLEkDORJpjGUYDQIh0X+of0PvaatxWd8tHnfQXmwGUkiPzMCiFg9eCo7z9aHYLMBndcQWdCAj4kRYygw/pcbTqKTGPbpW8GqvRJppNgpdZ2jGUtmC/B4IwCNy1qXZG4ITmnlzwC7tXtbPvlishyemQgQxXaK3gvXUXnmMo3EMgFf0qHxrzWwy6Q1Ynzc9JCUZOy1dSQ46jdi/waHuHwkmOMUHzS6ppxvCx+RvBOCpBa5ZOMpRLu6QCw19kS5hLJ6ayDavREQGTb3UTQxLEFaLLjim9zLLuVWKPcGeQTJUl1Bn3ib6g8rtdosKntnORu61k8UYOsY80mBt2M5SQMxoBRmcBU2Jaz/MrQ7bTchInBitTYnWauXRuoTpp2VdW6H2wfO+yyyNUomXI5ZopsJXR+AMv77cem9qSi+VKxe5naUPPzHjPHJOstMwVgBGo+nurRdzNNJ1Wbb14iuRB8rddpPKwUIrIA2k4sMi1aCfyM3imVq+fcgAbNZMJWM4GtkJskeK2V0YoOurGVUF9gSKfOAQWBS9lys2xL3WqeO7cJFLSl9eOmp48G5tFvCiD2rM2chgkqJH0VAdGChqm6o9SGqwBYoKsR936GpfFRx2UZHA1xhKnHpODD1phG8jc2UizIIR+fgIISYOnFWsOQ337CnrgdRlkZWQyqWLtK7XKvF4bFr1pq2O5lgkMv9iS+1OipYCMfUU+yDprfn4Tyl3mpXf4x1O5kZu0AnehxATL4GYeZ7O/LRFwZt3f5lNM7bUrl4XMkRaEVMjRT+dGlpD5jbrmfLEAAF6GbittuI1DLsUIrg+5eyHwee5eg2964bsD3oyqgdAGxEc9JnP6NZHID8z0dXRHKolsYxIDswALfXWbqPkmIP+NLhTtD2DPoDKN3iPgPWyimzTNtmRAMpDZdEGE/MRAU604JoYNu30aZiJ1wuO2wHENTFRrSCMJKIeTQH83G/f1H3mVVt/e5eZsXAg6qFpVtljIwg1GT+ntskkJ/dmcoA4nCqvaMpowe6/gqwhWe8CgVpQMhSF7H3TXWSz3+VzVZbbvEh/56E8SH9gorrCSkO4R6+NlLhW4hmkTc1ZOhUKO6qO28Pu/4xdqgu2v8ToKTi19M6U+YpF1l5D8RYwS7nrB5H/4FdeIgexfoQiNzooxvFvzeoJ3lOSPqhHSKSkF+bH+C5xhuwzV5OFXv91tMjmgTqs63S5nkP757OAUjSF21SSmtWcB/qDQrsOBQIxhX1CElgQ24TQngN595fD7gUtuWjQkyKMomOsk1c7nbnJXysHeej8xHH8eSBbzxHww3MIfIRxsXl8M0gAhP9Fmb6tV3gAZmaHRMSK0DbY+MiqLu7eb7P6mtQ1SxQTkSeE3lMIvSQ5hsMi6Gi1JNCC4aJAZrmdiFWEtaCpPNBCuwUfWM8/jHblQY2duHL3hh21xtLVVheH03U0qQlU8PAJfB6eHcc2S1iSaHvwNl7wgbtQsgnGmK8tCIj9HARlrESZ4o++zbPBaEMS+alqGUfmmDXFQQV95xqlEqWxYHtrGdWWpegk0SDEtjLWoECbTVDABVgNh7D0txIDsV9CJR3ji7sF70vs8iQdBir91IVgwB6nF16nGWoyJ4w3CiaW84GT6DPYv+TIm0REUnD4tXBz7TVGK6B9Z5Z9Z6iojudbm8byRISVtQc2CPRdo4nh61ADSUaMtoxoa2MHepqTbaoqcsFV6rPKp5wSwP5lpaK+H1xf7cIOfULn558/XL5631pgjRjaHSTcGxHDGwb9W1LR//fZQcDveNQ/kgtajeWo57oB5RaeTrwND0GdWkIYFjh+OCYOu2xTKNyVi8W1HwfYnDpjSxFe0ZDKRlhLYnYBETNfSNRKlmcjbK9zIxiphZfqDpsanSCgurGf1EHDON74vYNCdmd8BHnmBXikOGxyClSKh9KTgksCpRSAPz4DH+SFR29XM1Gq91GqySPlwASXkwxU1cRvd7RuBkk/ZLWCp6ubz0XirdPowVvmZLFmGAvfuraShlMU5Ubl1An4JPIp8eEDoC2Ke+Vz2L1ATxfvxAYe5VO4PDDqxfShCjWcow0cuTg+E9kse2qb47waLs3fxBgvFAEHpYI9uPWRoWRt3W2JwFkXJil62Zb8LuGe9wrkpKiPnCqIi+s/BFwX7nCqsT0mTodRYryamgRuqELHDbUGZQ40MmV9QxD7BSpQYjJKG9DEqKrhVoCSGJcU+Fi7VrPRhAc2g/t5qTv84HmsyctBYHs8JZvmJp/XMijwQ51KTQFMHGLA5V0vOJb/sqkgYEVQ2hKD2ZOFNAgdYMb8251ZWHJPr7wSPVDGfHMbQHfx9mZBsRgvRlMHDP4X5UxHWbJjvml+pR4vl08Vm+ouf73t1U9zWWFrU05miFk/OKUp/vHcQES4dRVoiOviblOYv69sa9tIsCcM7ar3GYKa2bMF7xMyFjFIbf8ahNjRanTwuSjsdN9yy2B2OEH38z02b/rqlCZMFGwC2UaRwyN1XmIQN/ajesreZyv+X8O5muKW9dFAoKGcf2MmA1txVUYns0WQJ5I+Zyy7FQKlGcCo/tjBzKk/HYixIiFAfYBJhlhdz0ZDuDAG492c4CYncTReUMijp33kNk0goD3P57srrXkQkB7meI/OfEywoO/0hTZteElCaarKkcL9+YvIoeN1z/dwo13aR40ADiWohuGzYA60ctl8+L3jDohu1WhaVhYI4spPgwQCErtZ8jyXXwDIjaAhVgEP7S/n8KpIX2BsdrChmgGSMoVkz++KiQVzIo157A4+AZISZS7MhD8FyMtmL5yIST/AmOh2lX8ob63oNB+rRzwDZKULLRM45eDz1VojFV5jHDIccKblfX6tKCow0drGSgsDC48/KGhzHvVfG0ZeAMK1DtBr7t1vWTB8EwbbYer13FrBUXbFoBDPZnFocZa3k/axCW2DuELYrfYOGuh5xEwQDXCaOPEgyo5jlehdQ4jtwgQ0meq7B6/N7AKy3tu7bUnd06caD3X/PQ6Fk81smtHDRqDbCXm2zyWDJGX5an08SleeTo/IsbmUWnUzOMenT9khqJx/GFfDNLcMuMYKYv3xCq9IRJ8wzx0BQNYl9nDmtjWOBGXwkW3F2Un0AyAaRqratb/OIj4pLyzRcCqVFO1VfOj+aqn7oW4xow7IvPhSw57acACAfwHLlquglrw5A+/Jaqkd5Tc4GVFj6l1jkM4TeGHzpK83s1+M0+jW7CDH2TNUse+LiQ/Fr7Xf2wA0YLGV227Sihxh0NPLaCuzKqVBSiumshwvnvHIzN/7yCb7A8c8vGwxwNMfBmpWpbXpdHkbpiFKw56cjpSn1UGHay92W61qnbL8lE9M40Dv0icLw9gWuWCfqkHtHWR70cVxPX5yI8/QjJfc09VTCUlzQwUUpI/Zx3qf0kzU+36wofgYxlLX5I0/2DxYgusduRsWTKZTMYTz9BtO5UGS+DbFIpAeF67H5JKSAVSJnINAharE84nP+i7ST9jtzOvG9CsHiSjQ+aoqCjGENZRbZomvMBU9l6/lfBcMMDGFl9dP50AguITg0dbmTPR+28coInB7VgAIR7QJd1APsTunsXDWaFx0Ipy2RsjK3dcvxzo5/qMBaLvIDRm6wdOOrdWS3kYGohGMeal3BEMmNu9Gz0I/Od0Xvn9Qrj4E/k57v29ubEw2J8F2uihL8Dp4JiI1iCPa5uX9m66BpseZy5XwaUqC5G3k9UrVusGY18y2NKfrn6u0DZ1WSWvveDT1uVHRO8zLLxVgWrFCNu5x7zN+3+1Z/8CxYOtpUV3jQY7SHapVIVr5a+sgInCWOtspUm0fESqyGdmDZd3m/l0Ke5eCJ4w1YMEfdVU+z9w4B5DwjyrI7na9S+/9OxzYyx4mx1Ex0GvKFEgBDG0z3vQU+nUKLMJh++s28hfO/m6/SjT42VMSUJXdsu+/3LtLgHiuu62o1yI5fiiYJJL5jOdac8/VMiPtrYTNH0uHZLQh9Pmn7nhTQLEZKfRCypdR1db5Lu/whx/ZI+3YPSEbRAi0iHHtN/L14+jDrR/2aYgYesEZslqQ/q78Pvt01wyDA4GAr+UFzhVJgMqiHdB8wA0+yIiQAeVso5x9V8RxOtkZ9tMNj1nQT4g6MhGxNJsaBt5IMz2fAhfYvSMvEwsAzr4Xse1BLRoO2nzUFRwpQ9T0+O+We/C7a3jc3iZNgVle+2yEd2qLq+lgNYmiyuf6FjtQ/BlFRNdwrv3945d3Du0/+4HOD5EkAPuvz0x2jIQiEGxbvroFKxI2GqswEnczyOVIGI7tyclyqwkWhrto/tjizK4BWMG5y3zDbah0LRFzfkkgw80V7Ezpl0Q3o7eML4cMdgfaWe5mO5e2Iv9QvNPLAsLp7JUKK9NjlB8k1L66RDxO72kQ+Oe8rmhos6Ap0eV0WGqfLVVY25yYN/zK2Ny1/VG7KXXfPhxDTQyu4VIOj7V+iUNcr48ZeeZbGHItt8E5u5wq9ex4WM/hmEAUuUqOVsYdvg/VW3KrvRwvHuFmgheGYbtCUnahsWKGwAY8VHE83U1kCGR7bkAX2f7O5QVFy/xpIEfpcz7B15E7W3aiC9em6eQVgpXEkfaNfUACO4H2gVoIr/LkYrHf6wuwtauu4A+aobThR2VTOP2ufBkRIRktmI0jZVl5YCTrtETAbbPYgP2h54t3dzrJRzhhFD8veZiPqWTsBhjj1KVNDHle8LF/UHkDGwyGBDfeRgbPM2amLlu26WzWThBsU8jPO3WJiQD5ts2BGZomtSvu42zFWjkb1srIWIzvceE1mcINWtyA8HqbCC8i1uIQF5CRxBSw1ZxedmLQ3ifZ42v9qADauwG9mPkg01r1BNOj9TpL+DQF+PMMW6Cc92z591xU5qqExeSHNkh9Xb6LgLyM5zG2wzsuYpytmFcmQFD6i8/75LmcDRk6m8UktqIEDxukAB4HqvEN83HUP6EwcCOfvu5dZ9o8esFABZUePo0zfF8bjiZ+bxxyAADUM8g0pbJCDdaUe265veIZlIIbBFVD36RcbLQGKPG1LaiIg86pNHxqm0zG7ngLUqRPSlzMFZUnnRMWfNKeT/YaBCieANzhFLPIHJ8YKBQxj4wGjj4LzuU32uVqd2gXqzkRU6mEUcd/GZ+wav0qmjangO72VOg2eag+7klyUHSbCZDgVRw6B0hvqbZnclTHMYaMw/RFaf+UtkT62ANaqrbZRybE50zQ6NyX91Mkcmot7BgJ1QNhp/Sa/Pdg6u3WfXl1w7aeQAfqUgIWznfZx3i2Gk/IVclo0FFcIWRw2bCCAsTvlwM+ieAcMAbFnKrwYthC6eui5/qWt8vK4AbJkkIRLXjkHj16StHLSQ3Vl3Fl9lmHZ11XbeQoNp1kdCRdqSYzFbsSXnuTUxBf7lh9pCPPfUqXfSPqbU2AEztZBpPhVnIH6UNzA4M3aCQAA/5BmNe3EXMeZVyCFj/b1dSV3KAmlHRC5nGQAmdfYhusDUDe2bi4HiiK2Rge8G/Cp7IS8uYZGfM5aZDq84emr6N/54DLAzDYiJHnySRgzTeHQE9bXC+KOyWHDwob74ZDqJBGUdWZU/1Ax9bGg97Qk5+YPjzGZ46wv2aZy634l6CnNX43faUL/nbQ5dWP6IxWD5N9+p4XPWt964tFzg3DDkBGV0nlx6dnqZxS2OzzxTi5OSPaXkb9oX+04F42RNn1rfziijdR2ZM2J664TsljHtgGTnrzGpzk0xAC8qnEyCrs/aY7xlH0foj6LsbGA5KrZBN8EKO1XvfFsNVKTjrOP66yXndUMlUDf5j2jw4IW671tY8S2z1Lg4iQUWy9DHRWjIJBdFtU3CCUbakY1wbx+zwRoj/uUPzNhH9mXamkdJm26b5Qd+zTwwcN82jj0wipojpdVDG3Ol22LT9TSRom1DQ6XnswOXV2bNntL3egszDOudTR8UKkbkG98H8t8YD20GqBQeoLVHv2PUzw51NDNEkJCcUMgJTWb1Ljglp0RfV366lFfRuSMig3ahnit1VpcDDH4gKOAH07V9yzYKXLFRHjucr1L1MFQH4ZMb8dC2QFoA2MPS0YgkGe3gssxfexSHISVtL3z6EauPbeu7CxDs966aZwJ0cUE7HNhvRN/B193OB2M6/fDIAMu0SBLg4t5loCRTjvd28xAOTD9M/GypAjafjaEHvtIMCv3NyFciKxqlD49cWhUIBnkrPl5Zu0WPNtSPplC60DqLHHDQ2ltu98Wn8GZ/3LcPlVVvu5y6rNCqMmmuJCodKz0mImpvdIPs0iUvsVMj52lLiovNb/QVlzPdpF0DmGqRnaJKa3oiQxQ1Fpe41zz67ZANiFgGb61HdsRrj9XA0SvsNX4jV8Yz7D0kHkYe10PJpdyL2W7xxBHpFhwBPWXuRPhc+R81gZ0VNfthfJjMDU3w8YOzXUxi6aCxniO0Qfk9OaycNhdaa/AXCe+daIwnsOtWSxPJcMQOJQMaoErt0FYyrjF//DQJTGdfY9VyVehy+lDiVL6qKOezJbJqeItcEPYME52rMMPRk6Tx/gm1E8HKQlm+5o1pbATDOBZiAYMy7gRo0SD6voilZ+BbLGe4+iK5fBn4NnkB5duL5KpqWoHGAZXapLgYASSRQPipRvHseP/Tv8jFpqAs+tvrrvzdYkLDKaThRk2+57jXr3FiVke+wrar960ONG+dkMTtJK+9Cm9HLGkq036Llx2Xhd/X+8Fbu0XVF/9LG+Een4+yx9SUNOCN8QJ6IvYY/trCeMnUXqyH6f5Pba724zmkJuSsYJVIsOSDfter5ZkMVBcQ62NaM+5JhsG46BsdowNetYKm0ptCHXOOJWiXaXgN9O4DEbqm8W9LCsVtVuth+edGcyFloA61vKTiMctl+ts+I+nPkIUuOMDS2JXZu0viqPT06hcuASQezxDKvNLOjfg/1UArxOTu4QUZCNswV9IaOH5Cw8/V8iBNkTCJHlDGshccSUH7RtyrhZP5B03cvF0Ro9yQ5AnKUMRFio56Di2UxrUxCyKciStmXV0fB2TqU+eFgXGsyMQ7lyIWZQUYb8pJvhw+Fu6x7nGC6mmkdPzpMkDwd8N28aeAVoXUQWBt8+5csPglEpdg1SaMvWrQRYaYcLmyK25+5xGL6B786mLwBNiZnpmkxKI5km7gJGjv4O3Y78Q/boqcmi1Hu2XrvKocsNJg4GQlQxsHA/AlEnUzLC8sKJNtWO6lEWzz1pDeR5NiZu7E+dJC8q9SKv04CkCdTpfhbqZJSz3iVjwoOrJEeR+nvxmO1ROEsguYkdTJzb63qhasxOtpAtlM4V8wleA+cSRimEis+oTNYkqBi4lX0vc6XgSMqLGgWu5mDkvvsQtAWraaOIV4zykOZ/gs21ttVDGuuEP+weWKvATnb2IjJyCjsev44/OVwS1u7HVf10LQBJBipKqz3fhSUHx8Sw4ceJYUzUOhbbzrgH0GxeWLmCw0RlijZdYdGV56DhupPxzb0A6lYNirt6L3iXrP2rOkLtB/+y3LgiK8GLfhlK6QIHq8Z0z/861WjgQOttTfWFr6ks/cO0DLyc1V85lij6VvX7dFjj06/2FyFyKEiMVXTmf4nD3v8E0Bx87z/wFPseacfpI9DjY5dvXKkjgaXIoKviDGHJZYodSkZ8ZYmvlcFL/tAgzFria8QiVkwx/uBljBPN99Hmci2J8Q1gKjv7NuK2qlAELRG2ExpuwjygI8dMr3NOvJ65LnBPL6xbkyU6lG3gSz429OwEOOIHA1C6PNNoc029s8matHdrXOwbkzGphMSSYuVFfSN2OIGYF84GAFig3ql5v8rp1fYKDgrqKY5BrzC58HpNuYCij85VVwmx5dhukb9mtTpPK1wbXLAR8oxKy4OLV0Il0eTIYKgSLVk4brma2q07YG3YMH0Ir0vpfezZSrfPQYacXmxI4wO8CSx0/Nsy6hyOeEcWDp/nbLJ8m1QjE8tkjKAPbf0DSkSlXY6WvW36q4SPCoKXxMeGKbZpbFfJ337FFdbP5UKj/Zp7mR+dZv2gN0Op18rnI3+9ZVb5nl19P4qsKlo4ZExp2hEgVVBELbo9HNB6gG9JU5iEmG1CqrrMU3BKZ13o84IaTI3QQpuqG//vHBt7WCQZJdo1dzhvGJMjeMh1j6gang4zdCiTHMxn3W8Z7frGStIVDR8t+OlSTDRwTZMcpQeJ/JoOGQABzWzPYbba+o9r1W1A5ZsRTVjNcoRpq+7wMrN95bN7wdRHue0tqcaSFmxz3mhZjFy7h6WUdTBelRm65+sNr5514cOpyi8lpoYahQih1Wzau/2i0LEI+mj4r64ZXBdYIus4Ro2bYXpw/kxpxZtJDMBQWiKm7fE4Iw6zDqz6D4UHVFfFIobmUpYplAqm+Td4rT9eRXWScVD9Lshb6l2IgPCMDPD1bYgGJi26YPukGvSdHdDmv8UFOoRpVp1upUyqg3ckipQzBq+/92JC5fdoewKT0djwlws/LsieYUu9NVk6pKX6R8lfQTeSRS9wZSLaMleZRf3Kcqt6dzJHd34h2vT6RAyL7haf2wwA8McOXsvLjjcCxl2HWBaO0ZB2SnUmxfbDHpOR196LW2v0SE315R7clDsFJnUohnHzOznHD/uI+d++m7Gpfdh7HKt1vh6wuT4q/1MfAAjZ8EIRgdYRtseF5gNEuzsnIhpflyD6IXnqhwMj9upNEiYhD/nuh1HJ0ElYE1QitY8auIJWG052SB6PvWgz+cQVrKrYIijZ/RkKhJNQlwLKmLHRG+YGhWL6pmjUjlfo6Nbw9Fxw78ZuYI+LX/pveTXtjFB1QSr2aC2DEDUcMyT7turXzb/lkGiGG5ZMae9BL5MrqI0mHyM8v1BRKRUGWuoIUk01r5jSEXktNbcgleO5Xelg0CgivdkehPX0PDCZz0dLYPLlb9MrOwkoHTnrBFXJeXoggd6QQj6uUc/nVTpUYawbGhR2VcepwQ1elqOvu/6Iyp+dBFmSwBvh94FFGhKTzlIPk2tWru3GeaKjjSMD6GSfyUTWdP9D9lakbr9sf+R5FLYjWCYPbkZpzo6fbjs0EOovqaCH6gnkxGGG0EN/VT6exSrT8Zt10zGv6LkzbPD/PGSxNrTP0hAAcEDwgX1HkOX5FueFtbXvkPbt9ommTts7xlAOMMco72sRg6V+cbpwKJo+pBZ0KVzOB3HrmCiGRmQJU6o5pIl3fCUOaFscJtLTGVS6cbtbblC9wwo1Oei4rp6O0kGi85ueS0ldKzDrfCoYeeuNu7xLqJMXRE4ptvWJv470RJvxwb1NvzIo/Y1/hop28Y5HaNZdovlNevKbBpab6mOLMRW9P7w3d1wcwbzW/7QDWh6yefFNiTSZgg4b3gIHLyKXbMxuP1Ny4W/sikLL4y4OdD4Yt/HQZeBrjXLJNCFf1yJNftN38c4aI3TT8D69/yt5kEuDUm3OYa+aRZfBYWy0XaSVxHSMK9RopNwZ1CUPwRrBkZdVGKywg1ba6q5hqbMCzZpU4l2a+lMFPsJp3ua1HjUk5ewx2KPTnY+uF3/KV13EyJImwCwAGfrmewvZ1IdPq1rjg33BDXZUhJrOPOPbSHTawbqJKES0gtyU5fI3LM2c8f8Z1iMhonNKQK8CWspM8RiCIf76m3Vet5JcDq5FHu31PO75Fa4NBA60OkQSb2jPgsnYvjDCJi58d4dkIsxTS37e5L1MhhZSKDL4Zcrazhf/yRm0FGslCKOGMSpYx/7OmSvMufa/Y1uAcd1+2FbrDYv9NzjE6oi3OJLo4MiolB9a0ghyshgvUN+oThIFOTU82wNM3CgZypm79spyM58fweg68R+ixEhuXLBCt1L/e9GA+9va5SedLoHkzFBKiVhCw2fRohb5ll70AQWbTkBvBl33cT0g86xMa0SBrYSKIFmeeez5nzbhI84oJxlcFzPFCv5kC7vFK/Bu3q+dxZuLaCA23jWMv3lPF8gZZsU4fIeaKZpttGPLy1Y7MG1ndHvgcFg3mDt43nloyqj4J10rnNois8uWU1pmcoGwD3hZCxtC29mst6yr8jT8ExvK+n9SmMXVUhf8SdQjcFcfZ1YoRtuaBBSTiolPQ3Ywq4j/06ff+fIUmo3Bfs3JPnhp4J2KnPncNrra3NzJDDn7I5+Ig1Q4PQP6ZDGqY8S/1fkxLH8Ne5mz/DinPz8e7BrpnqiIvYq0z0jXr1/sSSe6pyPo1uxg7pHSCW2dDmlY09I3RDQL460i54OwXhfgFwM6N15a7LzMVEXmB9OoC+wrOZbS+0oINBnPKpYcIK/bUxpn+yUMyWuHHPvnXTL5YNU7/glQw4SqA4uEv6sgVHHXCA4yf6oVQokrHV6FjnRZZx4P/cn5bwmYUCnA02r2uH36o+Hplbo8ggYhrk4Oa5CsiJjt2uLkAGSD1Sl7TXdCVG6ymP+UzW9AIgrgGF7wy4ym0ysArW9s+koK3CWru5SaIcgt3PBvqtqUlUN26kl8eFfnJ8+s8mshZCOn3bGHOc+/+YNDf1eKw1A2fMGfRmbHL8uyXMQC98tLOJ2G9WNpJskBXRE6ydpukqyi/FMHYWAm8RFPipbxjR66JBewYqHa38KvKJzMynj/Tna0dOyFrSjxg+/TTJ7F4JA/KLtiZo+R0OTFk7x+VtCHLog65ECT0WdFn9CbJwMhUugBUxPWlqXOQS38OXdnEIo+R01/qa5zi6yUYF97gIvloYfCnjr+F7xDtKH1+rzQRN7ELIcnm1XLCbB8gn2Qv0eOQ09SV+edVuJnrqFWFL6D6UV2yTiZqroOBHqoWwZ+iZ+CWQ4x01740KJKc7wYYyhC9PC0ICQh7bJsYLh82E+ZzXrsiQrf6Q0+2oIpnWwLfhzwIA1eCVzDgZNxnkobUhdQXFx6c+e9Qxf7LuIeBXV5QoR/46xbU874UbTNBCIXKbZng4cKNcbISz0cqcEsXAC7H6CKmQ13sCAYxSH5lmL9cGMoy9M6vbXUQmMcmyp8NvAMx+mudJI+14LyP0gHxgww1Tv0qd0D7eAlICkjBWXBUpHLM/NRqlytauExvPAx2sJG8OH5Or+mnYexFj4veDsAmcG7aCFZnRQKjVAxiHkUnrn98iC6n058dxMeefAn7Ke7Xouq2b+gwChQTzqUqmkRWEJ+OCD591UnKNmLGg67VKxETSqEsWuUotsjhpvWq7ivpAmUlE3nIISrRTd++9cW5HMl6q1otYOe0M3ruPYD9Qfn6JN3qmx5bCME2A01ynZFlR+64jLdep7sdCOXtIy9GlhrNIEctySziTyfFjzCh+LaWPMLuboJd94UaVqTwuD1wrHXbnF1/lFgVPjcWllwNdlXx/lipNPPuKKcSNnhp3oMTyQb22ttjZjurjIJh6CAS3bXmXkVlchHKcNu/AjvCCW+2zSp0wqyb4Ru/EE54tc2T7iJKbY1SDL5I29WfReddt3iyyYs1Ud52oYk8462MIFF7NvSkx7Cq9Evh4jF33PXjfLZv0fW4pjLAlbe+4GZpwrmCLdlrqeYe0A8A6GgwzGOS04OdWL9WMu20Li697sgLv/wpMudKJ7zC3CIOrnUXQ4fAdpdIez0ipD+AYGuC9XptVlScNsWB7kbmvHknMrte3szxC1EnfTosM1GGFRmzW4t+JLvPkUE1G8s2d/ADyF9KuxUS1DdtKiSpfGtTAurx7jP+/L/sDbKvPQMSArsR9A5lVyoEpYvfulHs28fqCp8AbKcjKKSkPXYe+1ZHoakc8Zsp4SnNV+4aXQl1May8dVd1jHTS5TbY1MwtO/PwRCn3U7a/RCEp5K5T046MmrQ+ROuo/ok5aacHiU2EmIc4kTGrJoNKwO1MgZ+ivQRr81mVz3OmedgE5NFVgGNcNbGKmqjlgsunmJEZmSoQEbQr6vCkQSw2Rni0Cagppk8u6r71qpTsx+D4QeXWPmFLWVZOmGOT6KL7/Z8aFd0gE00+3X12Ds4yVaN7zF+UqrdFgR8g1xXB7BI6QyaXYyPrVRvK5EcP/CF/1Blz09aAZpgZTknEODUnd8HRkhlBIymerMqQA0Ui0Iw1BQOL0pu55mZM2r3j833qF8FeRhs0a4LIMxTnkQ8Yic1f366KgW9QF2RxGHzfyzae+DSaRKKuyR9hmsD64ASOjIoqqdT+f3xsYZSdMfUBs6pS2W52bGHnFY8gh3o5yvpU1OzoWZ3MCl+zMPWOVscr3PS6GMpZFpozvKdg45A9EUn0kRulE3k/xCrxDEJEWO1/8W4FOb5X2gatnqoQL7q+INJZ8tImeNu8+B8KH6iHsAo/tjY3XM1J9wzeduL2cQRPpiXD77Lu2fOhxmgyiLZKSJVS6b+3rPgJiciQbWF0r7SivpJB0bI3bCyT7GZIqRlRCDGg6AYm1EYL3bvwpbVFKfWHKWYfBr2PeRJbTcI9E79q+aYjM/55pff+hsaKLjV6HXbLIVDX+R30aOC2pd3HzdzJTIMY41fJb9OTiEYs3B2+nvW2QAfj8QqvLZfNxwji8H4ko1DtSzSsgEuphzpwxgbH4t8mc6q58fkrpfqM7zm7KqD3C9fQpQXsC6VEmmwFXH7SXwDJ0s+WccUP6dXVp6SF0Bzi1l26/+M4um7ea3JDmStIZmzx/+xk5D5CpHfgwXHKeKVtajepWf1Kzn0D39rdtQZV949tFjLMYrfLdr741U/57x8XDMKAe7SClqq8mNNKZo0DfoRwiKSP9s5srxjl5qdCmaR+GjTxM0ilkMHG9hDk8X34m/oMGFSVP7NjMawqclYg3O7gLj6hX/3+fn1R4x4WcHpIUrWqga/Shd/zC16hZnJQjtjylFIzim7HlbDzlOhlHrh4IbHbqlApQ9mHUR4fJQaf0/pwGnetJ8NUIRA/eMbbMzJG19xSFXCM5X59pBES8Lfkf1zNsov0T0Yzo3sPqIoQqrIIi63giLRdomgavO/Us57XTZ873VAA5Y3ltrekaQuvKsPGgy21aKw/32o3C0yoGGT8Lqhih8iDYiRFd3U4QB2LkHYo/3dK3q6v//7tmbUXNAMD4Rf5WpF73iCgaAQ2pSJJF4oB9tKaHpm630eljSdBkwE85MlvHkHLjsvv118LRHIuGVChOODEzlYCDZNkvRiTSq6/TBOIiSBqWAztI/Qbp1cMiAGSB1ksKeanrjew3m+aEJBe4zz3i27gnG4Hqr4Q5s8A9cdIOWC51WegXqjxdyDO70Cwg5uI1h1qhQb+C/5HGASqHXfKDIuyYsY3pb3NNTeLxfRyw3ZIAwJZdOod9SmRpEfyKBp+yymMSGIQoFgOiy4/TRCBkbyMf/a5JgM3UFW5qskacGdJd0vkDm+ihuhUOrIAaaqXZEetieOz54ANpMVf4v/ORT2K4VUSn0vM2Hd8GK7hBfGAC1L0Z1bAOAm17dRRw8kzLAT04WtzKRr/633n94sma6jnY7ZEz5JizmbLWjdo2MOPiWRYI1fQQWy6/6r8aLTzipaiiY6kQHOwFHJnnWBVuDxafrd0xUd8o2jYBG4ZMsHxeNWsgiv7Gf0HJMQQWvTNG0Tc6h1S2uLgH1UbfKr1oip5vHkRryRof0rzFTiRNooOrPnLoBWUT+HuIhaxPddo9vH7ZNqkjXgaMHuLJt0PkpSt51MFOr45PYJDY4Fsu1CEKNABHB5PwY+FWAtShESiwg30ilJzXaFoJkErDHyjxvnbyQZcXhaULdk0ofxXLg17FS5cWPrUWC0rZlBaPqiAHTLU5p0ggFj29CgnuIlGjNZ2D9T3s9Dk5sTC0dKyBXbdKib7DYdFKbR8y1mjY2UQ+KHGcNEauyCLOX6mQZfCdD9EsQ2QiNx9kN+5JjM8PnlDys0gjBlNzUgl0LGyjwOEqHQFr8k5WsqR5beNmxRFKnt+ua5/58yJeLmrFJc6DyjxHHLdeOJjAdXNABOtl5xjKbIgADYkW6xc80VhZbGLMGHw6h9InJSGT3e+KUa/nxXhlXM/uNZdGNMqGyVbFO6sDVI+hM/22cyduxmAgt8VogMeqWI2b6tl2k2ODPrC7MMnItrjQgXOMuVe7gTcYuDLL06aI1zMvMqMRkQVGvjXY9Q7slSHjcr90f3jfie5TIo2rCTm7JQjBT2uPo5aZHP5T8uguQeRjxsMIeSuVJAtS2XdXgVPjiVHf4T5r/sDKTBHdCo97j2FtwLwLMYXy8E0vAOMwFi/admMXGsOIOKjayrDpY0G+2hquwEwUuZmdb1ZnfXx9tqjAQ6mLUSBRFZkKE2yImc3ujyIDeXuuZoVbKOJ9skVmILpG1QFp7JOtxwW3E2FEI+QV5CsTqIifN0i8i1iFrXhBrJPIZBvcZ1UAr0CWN4LtxxArvVfmPxduAMOwOLLgY+XuBMRW7iVbxWLOgMikBkyHWTVsApRzeL3TZkLo0n1GSW7h3nxiWtIEwt/LLQx1A9Y7VdlMQHFb3hyhzjwkuuKQTZfyqG5EUgeymVCoTOIqqqmXN7FEgStPV/ae1pTbgClWP14cA5uKyWODTzjfJlHZnxzCA50M902reiFdvDaoQRdM//CKTGYqCdr6ePbH0oLUbseuL5/thELvvqLSZNnNk/gGV8fltSNNxjb61aES5etulXuKyBphGVaOmqE8bgbTM46ftgCmGzvVyBY4/wgsc03PFqqxlBvlPwTAZBsy8ytwoQXGbc74fT7sfNzYKgeEctqUONf6yAKJJZYgmAUQRyDc2juPHKpKg64jTvCPt4Fhq0Y20tQERLPwet2E0BMnv1x/KqnNWtzrM66fErBZTJflKKgTelzc7Vv6UomzlZiHtzbN7HfA6+QuqL4x7x2nhll3yUunLUtVTh128tijklG2L672ldZyemv4ZUKnLf7nPPYFkor53R8gtEPuNRzjOxNTp9RxnTl3LCu4rhoJDLa6sC/Z7PtDvwFgJYQvB9IlNjqteaXycsKYVVS1ZRIPzqwqCrsduY4OP+huYTw9KNP0wr5zqhhrEPYwZ8WmpOzo1c8I4QMtW5WzDwl1FarYmLBHLXHSy9+T6GE/HfyK/vL9EWmXw1OVZHLFRQc4PEcR5PHaT3oQzh7/6160eZrvGijG95B6JBS7kSOSQqsOTi6x4ODAI+zZSgFV1p/nvKE3/3QeIC/v8U+4lg/qZq01+K9dbSUj8jzDYL7cPs2cNCeCRpbIDRziuulsYPIeywNG0mJ3HMRuwFMox031AeevUL3OZzkZh4at8+3xtvh2H4SJkCZtEl5Ox4vM6R9dVkkCAS2WutZbSfFhR4vLj1FuXQhuFIbzmJrXAulY4CbrG4PcxpZt5f7uTUFwE+N9yRBtGfPqlT3ITLAwRF3IhUN01JbsBgdgWnLCgyIzLqF9dMDi3tGZ23j+33efQNO0I1qpPgkk2RVMfOVoO1aQ+R56foUUiHBOIu9mV8/fH/RPBWEPbO+DXVi7EznXzdLbua4NGO6lcKTeNM+myyoIEsNfOZtI288rs88tasXEUiIAU0zpcVWbUIkWx82E46aEfoJRls/RXjHobajoN7bx1M8mf7/6F+zsUB6vVJRCPPZXJINHy/TLubm6iESZt/O5kWdhHX1AGbIHXXT0Q0fYD3f6Q9UpJ0suOH/uLfYlLpti6GbDqYFnnx/99eIMCpWh1F1aSvXUUzosZpmW3Of+JpQUHCWgdKYChlS0BKmXZo3wOaqTviNCJGRdxjpQYudezV6920/BcoGm6uGp0BxKBkekz2KHa25LIGr7N06/tbUGUdSsTYT/D4uIvXfj79jY9Ns+o/+P8bXLDc9zizGzauTzsqe/QlZSJhmsNLRzGsSjHJ1ZIEQWyIXqmG3ixD1e9pdK+3ABD4yhKmt2NUohziBi/fAPdzEvFBUyFhrU3u9PHD4kc9MbABGHqh59NhxKVzMpSCQ5hry8uq291Kw7h2elK86IwKep8jpFE+CTcckbqZUAjWoVkNsfjLk9GIpBzKJuWaO67ZJgGyLGLK6OzMfctFruG3qCspe2JvQb5TGOGJhlnL+SXiYOazL8F2I934293tMLfGIsURUBW/83Jy+FaYDs7N83XDaDCqG2W27EwhbSDOixOkG82+Th4+5y+atvw7wDnnYL02AOEOOuKPorunC+vbx9/jxpdPPh+TpQwRsjjo2k8WpJSJHpVmfDVFPk2PLe2VpPGt2p9ScdCkxYB6xH9xUZXgyfHZU93Gz/78TsQBdEKgE8TthpTj2At4O/MFcAJiogSUOOM41DtpOH1BfyNTAMJHMdp18J5ms44q3lFCys0PMN4VxtpGiTiBRupu1rEkufcFnmowvQ872alwiHgcwppcYmU7L6SIj6ImJ7zjKHtY4h7z7l7REFhg8P/FwPJYWYTnY0p0ItARRalauViVeAWwWIcrTlL+q4dJE0hnrdtYjKyb84kxMv+yIWtKRXGufLrOHkRiPIPYWZmZxD0Pd8ufiT/eRt5yiQmR6NYcAupsOmgWKfRbbkLRP4ppxSikZdGhi0gzuEQGwnAYNmkY9qx6A0S9Ej9ZW45AjTiOmLFDIaNR0LEFbO8ks2j+mya18EAgqdahTIIgWZd261ZUlPuXrCMBHHcjsO/3/sDiwojQR1V840tfsPIqpX5bAgkfid0P2IcDaNut5JkVGuQYuOMmyYWoQv3CgHzhsUW79mtJIgRbj0grn5i1hIzrZYkTs3GBaySC8IujBcl8omFqrygDuQymS/lw3DwehWyvTv2St8UTsZgshsfo/OVB4gRdCGGg0u1yIX5Irhj1FatT9LBNMhZua834Hz46HJaNAfkO5ntOC3FtXMg+3LTacJAojpCPN6qsPfRoOwSV0W5PAX6KvbxrI71i1KmLIeMKp0kavXOdnMCvxC3fBJpAC50M05WsV0xdI7drjn6hhWSWUZ2/FmzdCCKkirDK4kL0pin5RpbIHCkyhamA78/b5U+gcQNHGen52DNXbrwCfVWP5U1RKBlfeoyvPvGfoXG73DjP8C1/AD6uxJRUTcD7etYkuWiFo9uESLAQssipkQaSX27RatrwD2klYEk6fEAzb9Vef5b4aMDB84eWTy3VVnu1xtNVwM/ih/2i/HDKSnyNuFg8JNZqGk9TTDViUNoeoguL4hSXPEsx41JoF3rFpMn+0ExsYvOizvVyz3WKil5Y3ucBNRHEgntc6P3z1mUgB4tqYRarlcs/IomOyjdg9rW85i+knAUwG4EAhEHRgku1U+aZepVpoRdyip6v5cgh/TPWJ80OoyFA0/KBqHly/BvPgKm3nufaWTiFg9fno40nHyXpHTf1X8RIVmTP2NxwS5dBs1xvpUXlXSiK/A0fHKh9MSmnjmodPWkc9AkCHMndY9i5Da8GRxCWpwR12QATYbXOaDukGP/wlsl2aQmpZM9ZG8VNBv33PvOdojbeSpTMSfisTsukIwQMxK7dWqB7NB5R7o4z3WkFCxP9XgH7qoCNL+65RG/QWinBlMrXPCSri9oywSJkyrO9AYX2ZMNaSmIHfHFm0Gmu7tA3UGafM4Enyqec+EQ9f4TEHcyUgcnQI3daz/9pL/xM1KOHik51VLbIRlRuSpiTTNviz441W8L1Fu/DGGGfyWxnB+Cu+q7q4/CmVMfo05CzNqx0Tg9l9E48d10noxS7Ej6Nc3hISPt9CQJkuk2tyr5KrMsZKTk1fPw8Sn64bZvDvuLAMXB/gerfkzVkx1u0Rt4kFhV1V+t+Oh1JqV3O/vSNqzlTU6G1fjfdacZ76z8NN1EdJ59xVM12QjPESEQ8cOoz3v6O9wnwRtSLz3gULLx3B3hZLnEyDVb2x1MNAnBIINETkxD1jzK//KORZGnhHULUn0pnBCxJ7xMpDyBxIQmlbmLFQN0ZH83Ot+6qJEY25AZmGeh4P6opyjgkX0qw4kPo86le5gQQE/Yet9ZNp83pFlWac/azs/f2YcqihBRlmme6Rjb/SzCFRxleIPeeQjddz5E4J5WZqefAdYWY0upoIJVF5us+Z6G3GrJzoILPsv0ULFooKLOaxaTHEUmvjyYH3bN6mdeNhn8XYA/vf0nIsqc6LWoSsqmLytd4NAf9dtkzrQBXIaLU1qYZMRrkWP10us5mmoLyQHoJueVkPqSZm1Dkb9ZdhSY5ZyBY7fvv6dGyei6J2HYjaioKvYt7Ayt99lr9/1zou4RzRB1kMUGmyp792Q7PTZoZ8rUIZRzRq7jiC9ePWtKaLIY8jJrEnj8SdtlLzIlwRvUpawRvFEL/E+nL6jJ5Blh02WR35TsEfs0KSqqZFEl7E4F7RFHSN8xECth9KJT5ulnVvHZoSp5EipSIEejF0YnZ4XxgNUcxoWu0t6GYjxWjeIbDkOjhTDs47TuxsOGc24oRV82ZaLNVFQSunP8c+M8AM7IltiKWG4P4kh9GFJD+3CbxjnPo1D6+i+ZGsFe0HQPcSOpFSqzMK3YztULTGOJV+ok8nynAe0UR0QY9bGTqJTKc+3z+nxthAas6t0TFmaTB67Q7JiCtKTe6e8ms1TVbY+atipJ3r9Vc3diN4zvtrOSoJ3WiYa6AiSYGIb/U5cus7KywSg7TfG8ifZIBeGKlwIx+3rTkwYZqXvrVSrQI3D2ZzhCXbNJ0UYO2WUG8A66vK5qXlRtfmAUlTXA94PBHWsU1csNfPPNTy5c6ThvngpXZFJbbztDKSdsKHOVkRw7/Bbv1ETfzKN/Hmz1E3cl1otJU55l/dvpwyBlFzVSKQjnygZLmT/XoPAUnPcJLsrdPYeltNE0l6eOfRePpwajfQ41LYc2yYhO23WIf5tO6JCOOsEoDWRX4tUaifioAcXXRq9J7xWjX5fMCi/7g6o7JzH3omz5YYaE1hes9Sqv5TAkJaO0YRhhVcSHoOIDfmbJHSo9s0rV9/yZtFwIr1zmLXAb1+2ODsSyPIxam3aCdekYAO5lkT9MaWFJwBpIEjQ3SO+iEyuVdeJp04WparBe7aPtfyU+d/aPeaCPuK3iQBlF0NNHI1ipy3YnaAX/lP1K5v8gaUGRaerXEDd5ndw877axvUCJYe622MH0s39Dc4WIzRapc6X79aPFgaMGrNlGkKIZWzI9HJDNlEAUQJnlrQzDR23ZpNVlGtazHdiNFUHgRMQyE/R4226kUUPqq3rnkFJl/zPbT4Q5z2030+OiUWJHTX6kB7Zy7cvLrD54V1WX//4rLQsOurQ3E6yIRX8jaP97MJ0g69+gaL26K1TrOl9hbHt1nirshtVlijydhGBH7XT78uy2Q/7KtKnG5T5Wrfot4A30VBLy5Evj7gcX2tnkupzUfm9NOl4H0IAhW5jcfGFGLGmgxsUvk2UeIcHOdC6qVYu8N4CDSwUFVC2Wl9ZvW8ZWQiutvw/UfnzBjlUDyleO2jbgF/cPsgaBX+1cKxmJp/znA1D1TBwAim+EIDOLudBP1Qk2oDXPybPPZG+YrCbT2Y/mUWkx6EssrWXnbY5rvA6gYu1ovAeINU39+ouJuF8IzYpaTqa1YJTpNSbrmR41KFHnVXodAbVJlW2CJNN5rf93W24bIF6P8eSwp7lypJsHUaoic0y9IshX4uacFApylIA9kLYjgjJf3oAaRJMnMYvDSlnT95XwTc+uNGxBKBrMWL/zMBUHudIE6cWySyZumX5KNcRPkp0gWPpqY38yQTcV2rE9rhLV5gvIM1V+UwIq1KXMXQe+4oIIno0zVenyemwp63AlWnDzi5O1GMOCOA1+ysGg1TkUWwFsqaIZsfvkBltDdAuwxPfrD+B8fAf+3cg3ZoXIAoHcjQeiMHnVrxClKz4fi9kDPKStjHASxf1gEpVofaDZvx3fdjpocEFUyE2nSvrA+ssqtpOURdX/kFPdkLgm34m3HPQevSaoGNAe6JRxXhiEZoFhR8+MZJfPW8jpKsoZJxkZbPeYCWsXZmAZ+aWZHReHabjZz8zK4kgXCGo280SbpFwqHKKoOyEwfDmLE3pr3tPvkgW7R8Hu7jDJ00t9wGRdj6MPMXH8c6ExVoC+eMekLB1teLsaZApz6TWp7QC3I6VR1RI7UqqFHonmqMjJUoLqkyOrwK+omVIAGjckx+pnJgcqabTxdETrbrccm1GWpTXBbc+EUAsplRoXCk570qM+G6BXa/EXPRDq+MfZgTFhxqR1YTFyCO5DP2eF5LI75wF2HVINZB9+MyxORKNNk2o5ewyqLMyIdPLRbbeeCgdvbDyAmw/N08tvbIlx9drFvDpT7oJqysHsZY9czQJHndRwjN8eLMObgBvspks/X/q8rfkZBY92dFrjLuyUDzfb7gEydxv2HrFsT1h/H7Mwi6KDEWrzJlSZBRc3gtE/KnQTJuGxvfYMav0MXQRCVM/xPBkeCxzfttrl4OOWVBN2GQWpGZeuydc+41cp8ivnq4V1nA8uA4VEPL4mKSGI0lNIIWG/ZkcqOSdFlRxyfT9mdrc/Wj5zkSkCXP6TJfwjq7+Ufnt3I4JHONtWKmb276DNLcEhRb5NPNyxu0Z6XNpGHJhRhODgOuZCzH31ucgbBO8xqm3x7w5kSsmXJpKkSzayQWNhyo6NtHQxK/+Eqi3iNTOEHeiCEorc4ZJhpvPs0eKgq7RQRc0s9qIDQd2Npuctmtcijm0rsXZVBo7jD/Dg2WG9628GJHssrCMSxB9aLN61dSLdfIwpnv82WMD3x31GQiY+hl7s6TjzgKD6g+w9BwuYSTjO4RIdSTuFrULcaslHZbvTkVNvgDF3IPP7eUh6ydPXLTLfwPvpIoxItoG1f+WbonG2X3K5d8bQwVCEZVW27EeVrLj+jn7KpUxH0tYb9w/OBXzLmBZYP4sN5NGGi/7KoQQ0EnYDI3BHYo1D0K8hfU7zxt1tGssVVQ4Ifhvt6HmD2pcpaBLSUNMurujaoeaqccUZEoma2mOdLUGW2tVD9GKLVeZv46GSO/QeP132lyxtNz3lQa06RjfjwI905OXPWZSITopQ3+/2RAv1Us00cjSFQlSV2RRyQ57YOgcfO60ezDpyw45o+g2U6+sk7B9NooKeJgbsGT8/wM2SUW0GJYCXVAnn2lvdzTyPHbOg+qQjmU0LEo1eGQXR89dK1hTlW0tDTA1uFkNYLWJ3JF9EJdgrzQ5du7Jmt0ZyS8EgC+WjsbXrfH8B0igfltaBtOD1CUJh51ogIl3W3I79Ljv7qc/2DRetNp2g0pMjWVmwca1ahaIi+i5hK9wpf1o9lpIAgwF3Sw5qYx1Y8CkkOt34u/TtgdCHbNU9ID9RNO+5PilyRg9hAHb+M4mQyOkrv1rgqSIHy4GPRo6rd6wRf5X//T/6KFCUY4q5RqhudB8qiBwINhKhP3ci6kyxG3JPQlBcapMJOQjGkPbT2OthXAQpnui/r7aggjPmERI8Uo+l1d7uPQSUOwW0xJE97Y/oVWeZ4WpR2WXBqS8my21scBlRdy9cgKViLktQUe51GH0raw6U8NtrOpqrxS3WPrxkzdruJqeuh4xMxb79wIeWdIWxFZ/lnL/tx6Ic2WeEkjpQL+5z7N2Jkp5iYryteMlCQmG4HPDTYVbQpSI1oX4O1aSmavND1v+oWuRj3yoFGmmo6xOb+DT7yCmgxYBz+UBLxgoWKGNK3NEKt0WohJWxRq2i19wIZz4oxRAJ1hliNfeuyL4EsDwQsKci+hdCt4D6Zl+ZgsfVMi06fszpebEqHe2olKKDZFyfwoGtGT0S2sRnb4RaaqMpWf4mahjgrsfIhp31Pjxo+rPHJHW8mpJqHKGMlemdsGHizK+fUohE54Dqqd3wb1CTkWOiXTjSg4Zk6pusGsi2hH9txOjTBoXW/BrXaNl56lGGg6n5q8UDDtx/kYiCOLDRGGACUJslcFdSqtkMhMCh03zG65b7X0hNgGO49aOD2jM5YfdMZ70WFOa1PYtxDZRtbAkcGpJyaED/6lKXYDClSK3pDxXisqHpWWsLWLHWv2VKAoHx2+lS4EoTiWkjW7J/LV8zYiTA7UW6y3nDeAH+SnwEk4ZunyOEWDtR7gV9fPvfiDFBNU1twxcjiwlt/A2lSlx0CgX6s2DgWYWat9u9hrgVCF2Na8ilEJJoAyW9W9hIbmnl99PWCQD0clGN3fuAikqTL359Sgf2HiZah8bWnqeSLY8IcDlB92O0b+v3yDu6Vq/XjNk9Gcu9UICS322MpIdZ5e6xKEeAmFmh1kJa/1Aot0ElTT9q4ujtdfX22DyIxxsDIts68lPdNXxskmmbTLJJcHXeleQkwKNkTuZWkj1ARdLO/sIzocZXDWLWmLWclR26lyheJl2Mei2OUPYt4RWP7fC+bzAfPiHq3XjAllIDzBwn+DCuWttVMM2ZR+sTpXXxV0ElVR0WKXMGXyWH0cOh/meGCgmu4ZMp+WTzQvO0vm8asiZP2iaxqIKp0wKFEy0WU6j4p5HN4M2gR7Lc2O5ZiXpo1hKELe7HRhIlQ+IGGKHrQ1kxU3RfvysgZlbX8d9jqXHC/koOMC5VfbW8cp0nikLvQ4tuLoOByiEK/tDW0g1QDM9WMGcYofUsL+wo5m1GVmkv9Edtj49Bckyrt6yY6abefS/ag+d7u+gLqdXtUbt0Qn2Loe100Uh1lSQfCjPOmDt8fCIQZgrrDXvKN9sd2h4vKxzisOqqQWHQRlOJBs2l/kULEiQUcH9zw8fS2Nmn750o/vTkH6HJQHvfSsKsNY7IglH1cLCd7RdPYFdUpwrV3ZTzhKSbl5ZT/nglVXvL4nsVgIYn4EMZ7XXLzyWXcdoAsvattzdULCJdZ1+uRh5vqV65PflOAb4kLZSmeYDKwtFohsLaxWnaofjwE7swjz5dvOidrdmZZWgiQ+GOIZrBLIX/AWe3h9lfkVALqpSnnjoMDUQGGWeH+oy+H0Gkk1hB+jq5w7MadnbmamqEopwmLRgyJ6nygCX9MPr1aClB7txAA9ea1J7geZ+8WhZDotvqqnmiupDg/6drePyH2u4xNRP9uZuAM+B/5i4eSx4fv08b+y1TRaQihz1yaNUqHhke6idT94XNvnhsLHkr2VAobZ/NIO7lesAZrVIeKSuQ2+qPjrYp4lBRUFeTDKHBdug2x1AvKmuOjuO0kLrvzSlvE3KYbgC6UBd5muHtAYNQhegbWXeoiht2NEDV3oEJxhRGvW3C0s5aKyL9mGtzNuzdg6a1j4opaxhiHXUJ28iXWO4w8KJ4S1CMPE/fJyBL8BzDbNDYL2BZ74+lN5hPBT5wE2lmreclV/BiSDF5t/QnAYWjk3zmmzeCew9NHVtOG/UmPyn93MQnMRB0YyT7zKAUpfaOqbtkzGsorRWUrJcRvO6S7HQeHDJNRkAfvw8DzB3Pcl7xmZ/s63M+Sv3Zy/xV+tByFxKag+b46OXQd4x02i6tBxljawxPyZgIMsyvSLeCHkN/KQeojl46EhkM1fPsRAMLR9mxtcNhbq49WET0Cj2XI++4IWLkMSOXBHc/AxzlYfZHf5+8siZC8zgo9ZFcNpjc5tHq1wBUXqrpVcrQ0kKGoN4ANNWUxuewVDtlQMeSMoID/6AWEMsPHcnuQQwB3yE0nMLiPLd/Zy99/NCBqrs4OM/2BzPBOph93heLLhhIExxfoJDVVSxgfNBxQbRJNFQLqq8dczzNxIcUAPrgyafTeaTPKEQyOJFV6DBGewAauM4nDy5JZauibP5EPGzkCO1h9IL2sQT0V9Rl/Poal1PWgP85F51BWE2xZNJK5tWDyHbC+cH1SXJC5FHKbAR+nnrAo3aBRon6Spfcww/VXM/nj9cGkYbu+Q5USRlWy9si2cZdEsqJGTYuG8rlqnLClJBOO8tPSUwjGR45+a4V/f7nZvT6ITBQttLCFSq3dKvJfoes1cDepBsduO2txMJEtiGdkdl4DuSB8ldcKXQ5os//+OlnS6yeYJGsBjslIXnfBXoTEiSFw2kk/cHLNvOrYeI/fyqXI8fb4UHXVMqNU5d7VjB/FfbbsapEoqfMfOCBuwxL+D8sOc8hLPKymrEgM/39IlB7o3ll7ILJZFlRwme7Xuq5ZLuAAZNdTboz2issa4Gi5Ht5HIN6xle3lycbvblAy7CNTTq/dOsE2brkByrFmiO2qd7FyJXWkoUtsOcGL0ZEwOiz/IxsNNvE5VMOoQgeKK+pYoJHSXv6nvfW46lgQdJH4CpeSiwjCvjCbFVdm8gt7T/LymsY1s8jEc0CUKE5J4WmYSsmV8elV4HDHpYJS4epZ3V0L8/GBDKowDCaHJBpDim+eoNCdWYFdoqQ6a/3RYzSiu0jBJTkVbjx8qJw4Lirq1XEAeVWe76/irp1Lvs8hFksH/kWnMS3x8meX4axH3mJi40uMGwysZiu1dEc52LmGshwuxjm4JUIANWTM6vQziHvjv2u1zvtswubm2B5k9HscvWmcmTHvuGHx17KSwLbX/8rqA2Pj53LGlKJ3zBLNZyQF9wjvL9y9/nYDtwIdA55VPik1sOGKFx7LEILvohKSmvDI56EXQ6byAUuUmtJMMvnN4Ze3eNndXXLR40/bvUl0NTm3WKjVcjCh8mXSSISfcOim25dKWIv98vPEhYZsdrgUpelEo8Zq+Rjc2c/eTNp4/IjCCy3JytI70sGXHnpenp0HMn9WCX8uC/Xa+71BClIH6ZphgvSXOlDVyjRfUIqJvfX0C3eoAwwb3Xi4x4ZOwsB9aV2Z+Lql+5saBxsDtVSeBFRcxyHAtJC4GG3y7uEJZNYBzqn6LZhkRRh9LahSb1ueLDpnd7sREcGji/eVX6Xr6enaDm1WDNwQ/7UOSKfpC5aR213f05kDUPX4XBUw2pbSGkbUf0CD/xGdznxb9OKB2Dt0j/ZGP0NQlNrmapPQpdfE9n2U/lkH3/+0WopBrjIQLGEe/7ljPBHE0FytO1GXedylaHfhtIrvCQVXJ5WVDSKZWX0myxGfTre2v1UCjDrL5R/S4ofV0mRjAXKnx+vyaEHXPDy7TJl1lfpqFZUfQb62ED8406ZRs5ru/tqUV7Rc+3ZnBvloLyhEf3VzoJpvHvQTZgkTg6/tC9RqUJsBUXLeKRxtoAx+K7pNa+DDE8Xcm5HJ7DJYoSdR7x7KCXhKhYthYMbKLYOHW3LsSdE3r5BF1z35hs5W6+XGIzw7zkMm1moRtGakvqmvi65tvx1panDsZRB2JUGxg2PRSdZDa9CMRRTuCyHCINwkXYA1mdxwR8RF1n4QKQgmmv/r8x0z59kEw5XE9uv+97u/3cMu2NgtZOfvFZ7ReXwPhveGFRyBIjKQLlTNsJ2IiMRAkSrixJTRR8L8tKvp3rK/xwejX96aaziwBKAZVzfWuQ94duOjl7W1eDG4+E01XX0FHvzPoRGrChHNx2IGeApR3H4D3IzKvtic+3kazmvcFZ1pJRMfezuEXA2amyVgAlySiwRC0uEnWaKjoUPqj3fGaW8Grc4ZLgsxS14ClT/cX2cq6kmi2Br/A/oVYIEYutOlwqExb16XbOhVcu7gd3zvLkn0GbjOglhFLXevqsu3ACJS2fnmrRpptYTjQrpsIwdPY7Y5J8/EpIx7ftM1YhSJ593jTPeyNriaHdzEs4RTqFcpgMOvZGgTgqOBM5hP0ZGyym/UiFvAzYuO+ovrB4MLJ8tL1dKDv7RitMYQMsOHpIJWWkip24WqP0Aobf5JUU4ZI9UAEWVztFiAr2oOdCi4CMfv216GISB7alTrRd8i/O648X2LA08C/eZzNIicWiH8RHdbzEFwzxJRSLQLpw/x2blblj87RCqdzLsLCLt/uwBQnXiTDNwdxWxejjKaGkkuo5PkAgajD4LtYE3oq6yHjbG1Aw3CR+g+YX9XPjyyd7Qd5w+DBOKzga5cvs2tqaeAtkygvVQrSptRVBU3SwiR3jZx8MGFW7M7dJtW/PvYfuLasWqVwMkYIOmft+4kG0aMZSONS5OvhVDT42zIwBzhdxtuME5ev69AiQ3VuSNbtLq3ae/EBebWYbYoweLdYYbHjM6ICoqrb7oe2Wi6K58UUz6bsMhz8xLubYlS3IFqSEZPBaHaUfl09U4Nvotb76ZHCdMzQelPDnUGIOcRoBWYkoj2JWRmjKNTn9RGK6A1b+N+f/Hhez10bH6/98u7lZMxfgG4Z5eKnSFKflloY9wJt26Of1W+faBFLIRkUMRRjUBea7lIuY/qdWmH8Hcb6IFnQVZ7ZtDtk/50IVblNYRIIexGnWwgeuc8S3fLB+RW/0T1MHNVP3WTXv08EnsWlS6k4RhIvGTt9w/5tXWzg8VXCyyySQa51m2NySOvwkIxPJwpCBf7bG4W3E3wG0MEBOgD4RoI6wH2zOGdeR6f6Z1aZiZlLPwabltuDkt2Cj/NSWNsjJo+4iM8Kuw3BEn+yIZVrG3IOcxuZ1PcWcnK+3569aqA5pHsYhIFkXmnJdE3V2NKcCVCkUQ3bhClg4D4KkklCzadhFlOXyHzeaIXxtLOi229u6UjTO5yOy3qJ7uSEHrLHLoRvauA4K8gDHGo2CWncyt1eTx86VSIK30Rg5MsDmJBd80FB09PpdX5a+sJfe9OBJslA6xAKb3DTb4/FamV9i7c4t8+JO8EicTm1BIVHAQ3ze6uPP4bZHFU4tB3SO4BW7wF4bqJ94/ucahEGvQq70mn89Nu7QSiJsyFyLBttB0DxxtGmDCCo34uVC/bmVvUuAd39Y6VrQ4P7nhlBnFmNb+8kzjiIN3i4u7Ie/F5bXOPm9Q+uggEnMyRGVdTMpPeBr6ILk8cEunmDrWawNlula6yBe4H9V/Nd2cI6vBjw6Ze7lTBAz7uaCZCdw4eNin4PS4M6ujqDK8f06CJ94jCXKL87Xo0qT95uXRbq93j+d7d18QUyhm5eWtp5ZL3jUqrzkEyJQL4w5dosBvvUQkB5ZHyZqoIvJW9TTqrVWWRESbAvttItd8zy5tGcqJGRPyeaKfuscnWCn+10ywhqEp8f6bWvXd8k1YfgCuSosOwcgA74YJTGbptdWIMK8YTStacw5gtWTQV6wlh6RgDY52dpHfmQOW2SAGyq/IfsAIdP8kob/f3olpotRFT9VdORrI1xARwjgCdXsWx/6wyrZiwx7HbZ5P7l4Mj2MdrRmFAFyn5tbKYcJQcVoFApe1Zn2ORkOSNfbkrG2uG2L2tPTDEK4vt0oXPlK/c7pONt269IGoZFfxRfEEd7X19hlqQRtfzDi9K497PDxeDNq8r2a/I/UWx2hFFLKfnkf27STlOIYYWRzvrSggXR4xowAeS5Qx3lsku5t+FvH/XE0v+YwYprefJ/5kZeioiQ+KsPWgFo1dJq6iFLKxIb5smRgKIZFBUGBXDOljKpnCmlekerC9+TwjYOgW/exmvy4dD+MxFhL9kFH1cWxbWxyvCsxU9X80GUEd8zs7llLdmMre68wQ+XOmygW8ZQT4+3DDXuPI1CzLqkffcbTEVtKn7PmdUylFFXYHpqgqxgJHB3oNvCTywjDHxl5b1mocQPCzatSxE+uOZn416Pu0ztYtwT+aboP0tzAcKrkgaJYM9POUi0PNrFpyMLK2yPSDaQDB1mMpLT49t6oGsKNvpIijDrGk1HsKej6al5QEkTULSFBRwCyfSRqCqJCFDq+CRliSJCKC2yJq8FfzYWP7AE0oq96J2QxZHR3EEEcpeoGcMb831eh93vQCEWAUOyHjl3z34IVfOYExUuOtMi1G5GrJrVSEhNkv79aCzzlGVgDVEaJT1JOiOhCCbUa4GhENe7rpc989ZudcZwcCBXRY4/GZj7UfYQxKqGjxjYQhZ6h3AAHoe8JymMeWFJ7BspfFGZtpF9LO1mxMaIFqjCKW00oM25lwKjbgdrKT5lTpFR5A0t/FKd+7Mwi0GwXQq55dTcOIs8GIRDeN2KDD5VjVBrpajxMIICxOPcq8pUTv2E7J8KPUwjTsVKss25ULu9jhDVBBD0DDCzuGN6wSbuuOZOe0nIISqOiVlRvzdmUtr5dc2XShubXqQyaIPhrt6z7qijSo8A7HwY8gJIOzHzG7U1lT6rUgj1GtgEZz0Telt2ezfiOvBnCLC6xlr05i2PpQasypHAuGqJWND7gjCos/ygIJtcuTwyUKo2nQsIapflY90yc+t9fTnJjRZ6d4+0B6Fwat4+cdaS7Y2GtQ2BYEGttaJrvx4LP7lYyMDj56pBcaTcm5DYbR00nWh+1n7GyNKblPNUpMttsgYUiHPnCJAn+IcUeHUtaeC82e+PAnrR66iWuaL3mtjkPWlyIQqlfsDdr7YxcEk5mDsOrgdzXbtAaB7mBJsUU6gOmweBsjY8wLxpz3IMPEbaD4iTpHHnXXTJZJCL07Jpd4l7MVaw2YF2ObFFaeYfHImB/1Kq5MF82rAxuc6bS6CcFbbiPDa/K43dMinaN8AnYs7iRJ9CV/abjEltqggNdsTc5Z0UBj2M3st8USMEGG76tGrRp+NofAEXGM+coEk5vWrV5KrUGmcMwkzkEi/w+gSJbxV2bSEN8chUNONkj4VCjQIpb6FR2PPeOQy8WwC2UEZoGw7fxKzhhl5HTSRhowGcgGn5ZdtB2JN88hYMkFaL/rJis1gKPPyWRfZRDQi+o47qxPk0HGRG+kcuzWVcRBXPshSI6prCn4Kz8XLRpK8DTsotsuSMPv2YHV1xSE3CuOw9aXgL81BbZpg7BcmV44ySlWy2EZ862VDF1D9LQ/XxEBn3Vi/HKNWr/qv951lYcBMxKWtpgXf1h003M1Fts6bVfQWK2Nc/Xybzxl/I+uKAaz+FeDRAWJFLwVIMgxaJri7k4EzZqZB47T21WFLXdhThjjdKdkSUEByTn4o5asVXZNuwXtE2Taxx+UVDYS94L20OJGslRiyUvnufOcBT8VO4UIcdxo5Y1PFhAEYpgQlJKOrBnFVDDZipwBirOJ/dDthQVIBVaBckNBeIEW6kMP8SSeULwwxP+cG3Hs2zuC6CXlGxgrjPF/d0AWvQ17qJmrsX7BallDwy7u2VituISy/z/dr6hiwR9sWJpKM7bVIqNl1tu4ljGL4sLKwMPc6Reuc2q8uJw2Sel9KxKji/Qha6lmSKU4iqdOBK+8o3H9h4J4aasi/RHxEP0GvX06pQCha0RwSZSzxQPgO6uaOB0LyLQiioOzKkgxRNfrjdGiSo7yadIeNqboe2h/+gywij+52pepIZW+3qdraRqhlXoG9k7aSBEbH8doA65sFgIIDc8VO9bPdvME1tqkigKKTM+2hNVjNbRw8stJxFbBZ9hMw6JfFuZmUlppjyEN+sb1/ZEf2hIAqVFS0t6QCflei50wYyzlpSxNTu0NksAcezT++LH5b54CJFLUsjchDN8ju30rvGo6ANgzVfnQWqnAla0bxh41TyCWmHwJc/dxltOYBrNwdIcWONCcmqdO2pUKTDX1JZl3e54u+1m0zs5jEFeYOU86dW3bJLbN9HMgvxMvEapesbol/PXFIxzwTm2667smoCXNQZy8mOp4BG0wfF6Nc6wZ0Ks/2+yRWb8jlKEV1mNdw1iA7m9ZupNktNm7X9LUdFW51jFv9wG0cGN+j5eItiss57nPJVdLM99ca/oo9Crpqhl5dK4IILmpHyVSgIYJeI1OTE/8lQcJo2tJVRGyDlvJREmrOD7DcjpXJR1SExkNZubsB9t9XP/EeSHuz/VhgInNlZC+UwYL8fxFxJpvodnbqTJKRFr6Jnx7I4TEVnL4IP0p16ClZm9OwWISUVM0lMgG0ix2VcVmH1mwHYdYXP3hKsbxHnyl1RkWXIoTx725tfPgZ4IFtvX8g8H0jQG8qAKUoATg5mXRGn7cs6WQQOVmGvnHwuH5ykGHgtgKNHJ9BN0Q1gsjOdrTJ2EB/vtyBxE0zzvIbj5S+flSzPqCb5idmCZcwpdJ61GBmu38ZwpaeNiWCHOmLMnd/kRzcxlZREkgdDwv8JlxRGq6pdRNOle0gT4kUva4XvBD7uXL/XP1eZ/Mr8lRaBPFhsCikzizCvwov+Mw0C0HL0flZsMpsDi7GS0bKgHjDLXU+22OXeZRpiXQzeaSnat0b03SXtGnH0dR2olvlgvEpHfkvRgA4TVBFHmce/RkhkTowwQXuyu2ZRgi7QBJtfGtsvOrfApslPACFFUDKrC3A2t1cHy9GDftAV0LPwuRZHwlw8B0VqHnYXwgRzHwJSo+rnKQEqiNdUPmuufDsqcA3235PhlUAWTDjMfMXvuxP+bi5Wy4CCA5/Bph5eEgULj2cKeR7CAFaOCOqhWiLWCBNI38BZ0iEgMgNs7VppS3bhXn8l5DvDU8P+/mkYd9oQmgulj8bWYOLnO3+r0/3sbLuX3wGTfmYnB12JLwqtKjToQwF06xsLLocywkMnWn2DQWyHeLmzesPqXdDkJrz6TAIZxv+NZZGAMl087ZYcemfwd+vMmOPRfhJAEAyro8/XcEtmz4Ex/XNCelxqLiycHYmfKJfFyd/51SXUbUmqvYGnI2uD0b/Z/1Q59mVCeD5yVvBOlbQriDstqxPw7o9cZOUYbcvSTLiuw/8Oi+JjbkufhoH0NNPDWsMXxr5me13UxGUN11F34SSw2nqlEAHUhUqWhbgEssbUoPkwFU9FrO+xOkJkHftvNCR+LNNnaMWZ2sPY24ACepIxPJ/IJHmNmKwIxJcNohWK1N1VuZe/+JR/eH0ui0M7lCbC40Dv0JDWaAR7U0YiJVhuOGLbBcAbjB92YL0BRf8hRXRjy1I9EQ//Y5A1RvAGygrbLh89jWlsmEjoCuHFL1zB+M8DcPl+hhwouWheEKg+ITnGzZ5ONwJAkM8JfRyMNOI0Ce0WyeNALlGBkg68Oam8SEvsoZ0w0ISDxIRKzy+ChoaB2rlRdrjX59DO9o3kXQ7gTJ9YEyxRyafO091jPuoRaC6IVou/esB2LTdlTliN2Voz2emqzExNqccelyM0HFVe0UmrBW/yOa7zx7kXu2vqge1LswRIqehpYALQZcmSf9bGkKArTxFbDd7pzwNlVZnxBYHzGp+0i4Ggw1IiX8EK0o9nrg6m7r39tScB2YsXcaRpRi/oSWHLVQGzDmf+UgFxsCZfQ73aRhv6Mos2wJqNUjnfCJ1PDwKlC0KbmMB2L75jPZ+ApcfnipT3GiP8BPII/+PVlSzjKAfQh4xNzuuQoIVnyDZ7P/x1slTr/Sj9bK7OHrERs5fl+7yij286Cvm2TsEg7JRGaeeQig2BI4aCFDzgWzKhIZ3d5rMcJLSii05I8lD4H+SJyG/eWJ3Qk2dXpJ1nmhzxcGbvAiydlZbNE1KUfBjonbmZeDhtL6woAwUvKdJ1Kb5LTa/hetLvZDA15M0ObzPTloF2oPrvJ67gmGn0xVBykmfubUdtkAiVTMxlANlf3URKmXNudN6DT+sim4WWcMh/Ykv/rnWKo1udfm4Ootholg8XkRYZQs4sCSjktw4r12mH86aeg89bmpVWXS2fj1CalqV/nBlNnDHsZe5ovcI/TT+782xPZqf2h5OIckdTJOJ0jeIGcx2QA6NbKgDreJEzD0taUowYJ31y4J6a3UCOgyFDHqw5EfKewJlv+RWqE5Y1tryFHU81UpjT3QrNLY9A3HdhI+whJZ5n6To6U02Pzjo5ep/zIow1iJkXgzJ4s0W4RYCZRSxYrxu3NG7fMWuOkwmaiBx7zsFdJ5/Htdb0km3kaVoQGRc6mIDnB0/oC5knWBbzhhNrr7fEaGT/eVGz8nt7zDznOHOHV5+BcbnxRE5cFEMeOKdAqv00t18gYloD1J0TgCLfD3HiY83lp2Ji0WgwykL6consej0UktX6MaaH+gMGipVg/RM5I8o8jlsskOS+LaSfw0ifow3SXaRqiQKjF47phYw08ffD6igE4abcHZ60xmQoItC/slLN6gmtKycHPurbboAVt1bCrSdqsKle07ybayzEC8/aiQAjz9FmPVeuBr3pLHGqxItGeJA3DO6ECqdxKkYOmO0+6FdtTzQYzzd3Sh4knz9ARVq+bbx/3ggDL19XtWls+7mWmEyiGauCA4tVuMVmIptSUFzfYNbev5vxCOeR9PbkRCRNq18mqU0KlSiYZO3xbzERJL0LZBtrJAxTvdbsB5epytW5Fzs1E6xwpTsfF/4gnwSIBfvUMo/J+fiz7jlqfqOekW2RqyV9xhLSp8FOdJpgWecWnfAHo0wy2vG47QlP+y5W55mLGzKd8FRtFINDxbq53T0fpHrEhhSJPci6zaz+/yuOY/U5a81A8mYXVXIgG+Dn1Hkao2RFTVvajCU61y5BmUaxvBsV9OkG82GBKqValwjkxqlC2N38L6q+L4chWZO2Gf56jw7D2ywyc4q5R7sGmrUIyUayfEKSQknrRNsXMqkHIO48oxU3tYUQF9JFh+jK+0+r4YnWnIUaFa5uvXXDa3cqR7La5NRkTeZOIl3yvE1fnFxr9k5qPfS3G0QEMFv/2VLrPg6FSsGsghG21KY8L3ma1u2RHWogcLlMPR1zRNoBA65ZB3/uztKGQ1b2FKTVc+f7RdmQrhq1oQnr7SFZS9/NIgGkLPTPOE94oBo4/5dzhijDG/aOUlUJMsf0XgeXawVCCxu/U74zhBt3cHyLXRkF7xqYYetfp4wYkkCBFqEodqwdu/FgEuOjVvi4PTJJQLqgzXV/JBr6GDI8iZZqI0n0CnnyeTZ4CEAFazoiKG8A+D36/JfIdPvj+EeSB0/VcdLEcIAH8wg/ggRxzpYkPJF5fu+7JGkNKW6BXm0s8YpHd2CZBhV3rtm8UJIBLqrFlNhW/+zVTKU/wx8mSeiHyAa7aMDasjhDpexqT4P3E8svjY0aGV7/D9frIwx/XnhplBsGXk1QD2+ksHdNqyAdFPLJEYvuJlGDT+g8pC8gdIl2snLNl91ZxCZMiNTGaFMq2esnkvx9SVSepvtyUoAd8D2UvobbSypDqllBPADymBogOqHJXRr+WgHnm8G3UcTCA1hjY/x7Cra1v/9cc1mxzhwvVutLRyZEl4Lz58vVgQYbQTwNl+12J4MyGlVMCWAwC0VQVpSVEmUVivK0zOcb0OsuJHmM/YvgFn8fC6wv6+DQRrKw/PPmHoz25ZXfAEZp/TNNdDBxdFFkHHw/HIHOLWZY92NhdL3kHnpH0BMYhRyxWCghQ7AOTJgRUgdnMJr8EeISXa8WZpCeRP39j2ijmdH2xOTOQ34heexcF+HBBQQVet9LIVatq8VHfOO89ZhaNBKM0MaMgtjVCqEydTfMTa2/f1MyQQ0zrxlvZG4XlDtx17t1Cy8Vay9NxB0xQtjjpe0SNugwETXOVr4MgWlmRYk8SXiXJfdokUPWv5JaVTV4B5INJal5fyPKKSH1fDJskcF+v7WAB7szlJjrs8rz2RknF/Kawtl0vtP0+rlazakK/ncb5sTMrGlEOWgT27eB5wnOwEWr2RWp8e8y1lKo1NPKWsqxOitEgt4IC8lCzESGTiu1Wch55XnYEALTVlbIgaR6P2Tr2ByZ3HEjaUnUWbeH/ODbkjNbSPk8MNhvqwxbhqJfMOFRh6kdMczyFEHz04PyaTbdcFv/1hhM44adgwKPU7RHtwHAP57wauDMpRc8niE2lXJFUyQzXM5FaXw7RrGzLtw/KI7Q6UPxL7j4JWR8TYKFKgGJjsaUvh/zkolYVAphyR7kSSsutpb6rB4nS9mmuyuSZyYsW2PsqNr4PYcmahTp5MjgwE1JE2GIC330Ayxt10Fw2rV/fxys3zRDXDVja9Nxr4267Tb1+aC+nlpLdVhv5bcH8jnaCV2F7lPIsJbe8zuKflwtvof1w3xmpQgfMFHI3cHoWasu4aT4WdNHutbHoFP6md92RgxmrmqRHm6C0hY/to2XW5D49nV5/T8bWtB13yruxZXZmZ6JBs7RU15pLBdjwcmN8MODjyRQJPCsgE0BUOxgUnO4nLOD3bU8dm5Qc0zuk1Gzh05sRDJInrw5rgA2rhFaNFemzlRE06tJJEozdW03hfkycQlOiPELTZwJQM5UlouqRboFWEhXFh759xMDbmoLTqSy64yxMrAn44KZY4zzAkoU5d24CtCx0NsPl3g7NJN/0FvTqy3REJC+gAaPv6GJdfN1D3BYWxUrRZMo3x4A0LYnFILwARoVq1xLjR84SxVvEazPxT+DbNcYg690mHR7ne0AqRy5P4K0zewsEAn/5YWrwrd+Fou+F2S4HpXBM4wYsbAzyPdq+ucuuVF8wEJZzhP/Mi3iXqrCbaVewpqGDfsEQmKIsQMWOT7I1YfUU0uwHRMce83+DwMrfwF3MvlFSpS0Lk0jxgcQX/G8lwM09fddosZRyL8YllE/PyPWF60cjdmMcyY/qLjDAo+T6sAlyXxQjP594QAIhoTH3K2lbLqQyKLkdGJWe7QQoZcTf1uULKL+4mwHmPVcsx7CE8880wqSALWPtuJ70ACVD4PN6XMkQGTOZsOfelVoPwqotoUU90OsxV8KcOM1wXCLHjXuUuZ9Bi6wQT2pUI7ajPBctSsueMeecgg38TQ53aIjaTBob86wHPBaALY9+pm0l5yJuVLsgT4ok4Ru2JvVh9PtY02F1Oc2Om//F6TooIjMLIhZ80gIfacdHwpfNeIuZuIRkNaE9Zx3UWF4RMLZlp2Xs46AnZ1BDyHI8VZ4mWXhbcQiHTBtJaNVEjn71UziJfg4yw4ldLNrPfBl0F79SAOZU0EPYxrW/iJct+GAZoJt9lPh7oxE6j67MuD0g1+UYjDHTvBtCxaOohKhNb9Cit0ZQDBmRGUEztfg/0G49AbjP6K7mXaYKa2ydoNjiro8k3YCrJAUcXNr/bebQYLrRJzEsp7Cv/RNEmxvYxLaKLEMAkBEW+SlhvSMy93tW/nO5IKKE5lYcjsWFq2xFX81qfNa1OFXz0JC2BzzBSP3nvfiVdkN2VdXyOUEXi+VFxQl+GbRDdoOXup8dgKVS3LjwqpfDYgHOW5JBQ4+I2Aq18g2Qc6JXMAoYqrICK2b1ET+zJuz4BQ/fQMurOcJlB163OqeUT23BgtY+Lpz7pmo3Fa2yUezlE5s7Tg4+VErpVtxnypqqFG6Q+B2DNBCP9Dsn4W7HBCBsyrZAMq1cdWbQiw9JO+12sqkfWgl6GSSUFh6EkA4huVO64XSShJS48mOd7CltOTsuDbuDu+PfDlidEbWI4ebWBoWFNoTDi8WDs0Pmpy5y5LNQhsXNEJ8CHdaRZ20XlTlJOi2rYS+W8RhpBPvj72f522piJvK/Xb40Baq9mlBrT/V3aYYYoo6QOwBtXSfW/OFrC8xTAiSheS4doWJFuhc8Dmnlu0NHOCzee9qo02yiHqrF10PI7NrvapiGZI0r+BvfW7yDWtdBUqgvB9QaAxH+jKcCMwJfBq30Jb3BsDW1xPYu1woVKw3Gb3fis901BoX3ZHYD9H6nW5gbRBEVQ269O6u4X+Ad8wAOR2QLlb/mAt8BJ8wPfXycoJ2dQOzEACrxxegY8j0UbG/ImdoX9IlvYRnDGZZn/IKG8oNwvz/VzH78pvzDCyJ7/pwZPlnGumiqYGejjtlRTTiGMi2aECjrYECg+Usnw3BO9ZwdaDNv2xifAl424eOrXkzMpZH47HoV8ov86X+/cY01q0rGbhqe32cm0oe9mh5r+rS/QpvqF7BHeRtky9VNkEjsTdjDBDdER4JURyKHstvv1wPF5BfXlOdlXiGCiRKvWKdtvuK0SlcZMcO0OUsleVevaa2udYjliWHlg7zImdf7eROiPLe4Km6/f2pfENY3GZeTD4DdXI+/nvWV1j5fq4DFZxz+k4YXwClQfLdAzH0s4YiKez3xC/TjmDdopz0iLpe6PTCph0dlA5tlLcHrLjroLyBrN4SXtYsL5OYHWlM59ZmCQSZOsXKwVKbJ/6snZ4RWvFC8r+u/V87NMhpNvIx+rocE8OuE1PUgni7dMedCd8f5S9Gzq7wnY3S2kC9XzkN/f7JSqX9p4AFhmA5pLixjmi1OhUvRMtihlZBh6ETzxZz/4BvD+p+hfVkDcCzdPlQwL8I5UJERNWQzmBybZ0rsW3bjm4URpyIWAd32cy9+fkbF5pKX4DGFqpjGwdIpHQuaJJBTgUPCBVcepCY3TL5SFu6oRsKB33zGaFNx1EpkrlMf3PCSstRCs7YBC7Ebvzs68mAoGuMKvvt7h66xWxWpdaZuyfLOftySHbbZjc2ADDZVBmQZp6fmGGYCtopbFm08+a01DkyWbgCkPzbnf2oMNquRIPCphicU+g4k3yY3UI5kkWD4JixGOzTsuYY7kNXXsKMBMTEOZeqwwijyTbsfxueg54x/ZMFpWK8TIt682dJfjw30RLEbwyb9/5gsMiqa7evdqdct6L3bpppIyU1Ript0l/k+CUb6RngeobFt8swCDvrJLkzAB1xQ8cDzWNdkyifajyKIOA85yZfG8jRZJ7Bb1fogu9Vatc+jVoW/hSRPXpKachU5YO9r/2j7S+axx3EM6KLGxJb5ul/OtUpO2nSf6t3wQmg4gvNoZHWezJtTu716tljCTEZIsqVPlaTDhHE9lcipgkh9lWqS/UDIb/JwEBdcrGINB1hARJ1+A2BT3KUMHI2heeQeZ2pLTgKCDSO/PY4NmAunOjjzgKOzOfMPmtfb9SX4gAX/se0RDs+wZQZkbmVEPGJG7WYbd72lsRnfr5LhT/lEyXb49UH5xeMHbNJyJOEuSSW3W9TdyJih8ve0sV+CyhehIeYHEGtnSDZoJILfr9SojyXmlXazuEjNUsQxHorQSh6+sz9mZuFEVEhtV4JpAocLTSr0hQcZOK/4oBptY7nqsmQghA7eBy5ZLgRr5eRlnEeSM4bSTdMBMXLCPnMoLtzrJVmgG0zGC+/bRepgi4ySeW72JfOURVTY5MJR9L2IlTJNPnCbUTK+IAthARRwAlh5HTiPt8i+wZ1cOxSjbqMkkX7Md8QsPiQ6PszfChDItXXZ5nzB44mRl1gpP59noPpiMuqSLi8C8mh4+TQIyLW6JtD0Hv7+jc33uzMULP7MPjVyvObcOJNfE0ewzdvvERM1tgjKrFhpCKdncLhRulNMU4MmCPLl1J8fOz9T/pLmE9rXuyrXf69rUA3pDVZCuxOo25YE3uJLiBciwvOAICyyLRrFulnkUqdbf6HHxudJAjT36QMwmTSVbV1DTD6rO+Oe7iscgOsEXibQ+xmRbPuUpFBbPtPJc4VrBKIzY54ZTgw7PqLpx9jYv+FBlN5OvbtA4rXnbclQjD/fhX11j8N71k2Drax5egLosICoskI50NgVeHx8JtRkx1lw2u+AMGwL1HRH6/QYyn86TZGG1+yu8cOZWWj7TRfK2gC8BJFKVMkD6BJJN+OQQjYzY7FXJO2OTSF2u8XS2e9DqOBLofBJVewLbeCmSq6Rbjbd+XAW/ShfrRPeMyCdF86405blNsTME/dyueEjEr1QgQELLe91fKSPvukifpFos39IEOYVWGbMx+RnzMBqYzN3cz29mkkoQmNz2fATGp4opFtBSVS69YtvbgwLkYE3J9LcT5bCZiDA2cAJ958eiFYHHBilm403Zb/vA0bU+PLdLi+JD1um0AsDCuYO01czzzf+YPg/pBEZAErqj0uqIZI/GvY78HTfKIY4IXLsmY+mTLGKt/n/miualM5v+f4Ln1Flh8/0G7W+oE/8RkmkK6VcaBijBWuGTbAnUx/dIMuHc8jsonO+Xp/pTCwrnDDJuzLfj7og8ClhIsjYhzRvJYCX4igxmTqOl493V7Ap6AbdXqa1nrI+r9zXSQQilqKn93mROBtB0u74lFHB7X6Mz7mayp6sEEHw4YBVznshB0fT86skYbE5La3zhUrkipUWTMVGonCLC6rVIIDiPDWbMWM6LhgSRODq3qefjZbx22zv13scyQXD93iZfuZ4CwdAZXi9VwVhlaG7cHw8e+HtrI36GHArNlFiB9okSmip6sr1bAqRi3HHoftBYsxLI+TayQhcxPO7rodHz7CewcZA0GFHSJg+GnJYuT5OJ4SsFVLPtND6NrZCyUGkoYPMxfZ/0KF/6TesTbpfp+E1Ce8wMy7un/SgFgFQlbzypHym51BzuiKjGPzpPt34+mRfdwOHE30KMbV4h/iOztvRH3rW38AU3Ig7698baqD0P9hVz2A41DdWZzz/vI+cy+7cDWoa5MRDi8sZ7zaqb0IcDIq/KMnlWGiNsvwhL3ioXuSuheOdEx5gWaBanEmMNeJduMvtS2tKC3pG8atVSQc61FFvUK4+bLK3XZx95VrhIhYUnGJmTqaCMR1hdIFbg2dOlkwtlkc5xdZ49lTjzR+lcpau6IibOe8oiYSdjMXH0b8R5bNbjqQEahXYXix945OBI7y/mGWdz9dV8sonZ1l4wb2kyl7D0y8ouuIOePGc7IBQhb8L2Bt/9RO6bhSEdILDOAj/L0i6wbTyswAtBiTyHa3+DqvzrPKztnFfceHB+5kDntrxozEoBhoeFm+Bci7FmGAqPa2oyF5eBzR6wJpXdiFpV+nG3Ngk9k7C0l2SLs/Iphr6Vwx9DydiYzDEvY6l4pI0kpQcijSp9RL7Midxd4V4bjITRe+fIu3/FutX+JqvDcGN3K3A1YaQJV9dYYfizrA8tv+SGvGCV6UA/XpqC3v9hWEcfquCskLiwPrzVC3nzweUne1DBUXzrg4hZlhOert3gakZbua5tvcPZjbzUZC0taeTNzQpUX/NMn/oOsI2QagS6dFGqE276Q7DXJ1bUGKskblFDbdacDIvCoUqUEI9LnFeMJMY/tWhN6HdATWKWjuqy0VmHeL8tdYzpNemLEnYnfuJHKoGycaiIiLE8e6OOvQLJdpV182TZOn7608y4tVR3tiopKpLtXYQG/1YeZc2D49Zu9whVN9BpobI5WkQ5PmNWnd2Yq7QtMIZr64qWhOyfcDCOW2w7FY8BNujTlAB8lnE6vq9z/agVX3EH5/EjxN7XTeTtdhzodBN8Ee98gnEX5cj4zWdrnqjzJnRDL+KP9NDotGXSOaHVflaJebcLiNuLj6CaWmzemECXyjpSiy8fRl9UW5jAnyL02RUyhjq3c81yexhjcyNvHuaftI/RT7aApeg7Pg8Qq/QilOinQH9s+7BgyKzjjXTX/udN+NoWaaQahhYhNhwREt+Jmh9/NaSfgqDthE9aOJERxKg6Wkks6ogXZtTht1/dcSShkX1utWCK+1dFgdMP8AP2Jp6ryB1G4lXFltAbUR/PlPsBMUNp0ur/KmSt9MoLyNrVWO4HeO6C7X/cv9WBQ6+oXeQTHJfK/wfpfq7NEHbw/rYORuwsxfXItnjuUyAWkOyYptggtadmuiYm5PuHqSxWeZ9CI2eeN2rwcDix8xpWhM1Um0HwktittgfjckO4ZcyHlx0kaIX54LBILWuHDOwwUMLDLU5saH31bE6zn5/YPqhMGYoNbs8KakY2TFfJqF74xWxw3GRp/HgdGEk5B3kMQaS4SsfolHG2FNbpDYh0WG5OnILQ5CMKul+p6fqOqq3sDKZdOPDn0/99Ee/Skz6Rj/Ar7lghJXp3zjX6sGM+4OnicK8gE0Jt3kbVcI6eET9frCV7qmex34TxBupvOct5AiFUFQo+boT3yWGD7PDJ78+CWnOaGDNteSO0VNmnsW5b1Gf/rUq+115zVBwF2a1OFOinirj816sZm5MJ2ogBqVkBCvCzQTcdgZUmbn9aF1BIdiLUf87a+Q3c7t3Nqr+Gxl6cLDE+jrpf44MgtAs8ZEVIdNX7dHT/vzZ86mo+kM3uVA73Cjfjdi2C/hIw1tdPD5x9RvrxsFeAbXutSZUVaJB/LYvcIX+uknAxpxZumta4gNzoGJNLeRULm9wWjaSLhSoK1aL5sB1df/2VlP+786ohIQ/WvBqKfqcN7fcdzofjsE85L4kDlkp9nWDrVGJF3xKJi7YFv1qKAQYhgFqzGfWIRV12UqTmogdRlJnhJxq2V8Yttc7X439oIeIGhZp25jkoi8iEdRp1+9Iy5ZDTqnDzcOhTyWsUtgQfkPuTGwslBjKXdgzBB6bwoqNEjB2OgdQ+Y2GZ+hAWsPudHtts2xkkDjEmeGHk5oMXwx/odiWTiePF6C0Cr3LpDQvI1evoYutVzQahVwy8l3uI2gJ7AT5Ejm5sHphJki5Bf8Klg6H/bjMUECdIfpIxR2FNp8DS31GIInqXc3A24DRKrPYTmZrJ6/MizS515Ckz03oTnGwNtRaAqUxSV3TdJlp2Du4uaWohFHH4eB7jY2sKbguRvx4vwVz3etIk5LS7ifzYFd7Uy0/6Pcq9fWNlTfa2bisYAUD6IsupnJOX36x0Icono1XMONLEYzOBIVZkQpcVKaQsCRIkIc/B9wcCkW0TubkW2wo2I9nN7V914h4lkwEpfJcdapfP8z37zjrJCY5tXqtEv396gmF8bVqz6sYVZTF/TBss+pAHlGVhbOG2cJKKNLIDXRK9jG80opWfnVh68g3zTwLEc6vGG5Ee5G9/30nn6RtdUxRwbgvDlgMdWjIGwt3JfL1//F691alr4g8Sye/6BoLhpjomJr9G13hFZSUt8C4xoZ6RpIqtLrBzpkZQ7G8nEEvt8XfcTIJQCrHTk9wErzGU/7eJJzaNwOMfrhPWOs8mlTDIO+Q8SZ1RCWuXyVwL6yPCpj/9EO2Q7JLhuiRGLXMxn9krq+y8exBBRZ5Z1mZJ6QtJrSQO/E5wkjT/+nazeYhu9bs7EQMYwVWO89kY2IZ2AeLcbyWg3FWICS8TS7eYkGcq7FQrRIFy7Ku58zgKxFoTwuZwu6UykT1nRQTMCovPBuVZqW7TVVuMtkzNg4jsfiLEJEvvTe5Ypnc6b1y9OL8BqjwdZ1z86k0mRyaF4Tk+Eao+v49MKlkoLVL4CKJ5tWub6La3SxhaKh6kW8v+oZnwY4I2GlABtP0fz9srECTlfhKajtxFh/t4kMmMDbnfrBFpJ/MdGFsRsBYhXWhc01FThbA+l3cyspceqThoNatfmm7E12k+6T8M1Kfa2fAq32ZLUCOdPE/g6zsrPt+FyxEDoYrXRYGXKusUT7RpaBwhifmvJsKqNVhHjAoyDd5EKGkry/QUmtNTRG2nJDFd/mFKlDEc7YdUeaGfgKtgosVFxyWodwPCG9x+MlwC10yFpIG+gyaMmoPAKHS3j6W7NqfeJgQoAjlOHBhaNUVumf2gIlLKPXkUSOtwYGkZo/fI5tasiVxykUcJAPIGPdZmYfR8RFUgcUKp9HrWfwrbbMAzwEMxxeDKIYpeE90u4ZZun24HtTZEmO5PFYDgIT5+5QcRJldDGl/JcaC3gz5A+6DX5MZ3tTgn+V7u/Fc0UGbVTpPkeQ5Jp2VHsbLoRnleb7T7HcZm3gDVBbWmNCwV/d4kwBvdCujNNKy0fgiHrBjDslR02NkJdIOQIF//VC7h0eJTxAeJU17DLE1Qc2sf5Sztiaa3ouxanbKR0fkh7tna/mAz7LgaTJsSfzcR7jWou/3CMHv4oYpayQ7U3uCVa7iuDkePAgTPGqkfyIn2wnw2WTjOuKRFygNDwkMELzK6z0haM3hT/IJK54SPrCmmjuY+3Jfuzy2BSN8tDtpFJeA58GNM4Tg+6jP6t0WjoS4FuhbfxWbrbcmkW0mbsdGI0Pq00rQuFoOsX1/dlKlcsv6zdvJe/+zNsGCGCnkwmcVHa51kuo2u1T/+l7vmGdEZ8hAqIFGfltnQRLFm/WNk2dvM2NeWxK4FCtMloF0yELCs1XXTkguDfM+5wGGKvWyTzndk+DCREEe58AkJ/A/9BRqoA6D9cWzTrYIw/VyCNOPUtgayI2LegkujW9g7dPlKBjO1E84OvmoABm/44Iyaa+Nk2bJJaKY9xPjepgvctmDDmg5Bk8Fzg9Y15SIZJeJMlQ80gU9CXEjXnUx6ZKntjE0Y7Cbsziu0TKTL2R+6qAyjMQ9h7ct5sy8iSBK0qtrajoldVa+owpNJDXi080j9FhFBeEFrpB0/w91VjxRCfc+02kGXh21Ah3P1PA/A9rnOUbiew//lImwke2o01toFRe8GGjq1YR35pQpPa8mPOVvyYulNgbKPBXyBElaN1aTjkEU7eTlP2pK3zpLriXQ0I0+jEi2OtvZFxAxBKLWSgz2ka71nl+tr/2kTadz+oCqF4dsyuExFabVSGNq435auhGxPO2b1zz3gxX8wqa4R9Y5hosXZADdxERt6QKcvqB0N5xAEmoLlMC7J6KcR1p94ZPrntSBKJwTsboNGulOb/EmB4BR5dBsS6W1c0/LEJP5ELHRnapRHpotQYe/8RHP7O5aSyzE8YdqVLyH0g28f5572Qax9ovkT9r7QD/Gn3Ba2gT4GHz9RNl3/Z8lPegGsQnyqLY9iBxO6jk/izA3BIxSpK74ebJpSzvvR/Ym5ibPRXap2hPTSycCCjd4fYI2XV9chEZp7tY7J5AW1SR/QPL5o6/4VvEHqOAjvQNWrrJLFJjpBRksPnSsX8gNKOVcwmNXE6zaOk0W0QN9mWMnKwFoY6b5YMWmXFBciqgbQL5LNx3AEvj2ev4DAL6B2r6cl+gmM1ep4PeH0VR+zNME0El0yPcFXTn4sGr2T4AA9JNU9mLouAyLK/r0u31T58ViQgDzby+RgIJaaOKijvY8U9WEHtvc+hrlGFC5b22yZukzAd6vhJh+dABQWtcK5RZCid+dfuKuR0Vmjevg8A+OQeXY34+MP0aeUjghR9cRb1bL64vDPuTzE8fN4L4tf0e9WI/Ab8R7BL5BwZYZFTkPa1O7jkNjQw7vrRuhhjtDUplvGAv/h5SJczefjxjyd1fOJkocu24a8amCHenYMMRp9QbzQGO6SzLi4ycg8VGyL4CUj1vj3Jbs31QK51GJLw1EQDelGrLhWC6Y69LSEB+170nK4NiwkCbLrtE+1POZjl3YLa2CH+No7wlTUlQcMTRqKGEd/YuQRUvmeULhfDHWqZrN378tgWpTfP5edB+ApkXwdNzblKGyOeneIatwLNM+nraEid5hE1qap0jn+EV0IFfzVsLmR1MpLDMq53mMJtLoQwZZmX3F2ctRCY1fRariInjacI6825/BPh6wAfj7/dcvA7dcFe4kEbxXybU9BEGwmB6RNicxOSOqlUKWOhxfbgg7SRUxaiHhMJfA9BwMWIXPlWwdjKhBEENfSUS4m/8unxb2F2ePSDz+st/aPjBybNbggs5+43RT913HqdqvbUPq50mCJZf5juS72OewIYOzC+CK99RvmcHHhTMaBqHCErburXkK/hfgaACrYrpwerYrIonhH4iAW/wciH/MErnpOvv2EXinN6O2Fjh7vjaGkW/V9MxGduGfVcp/qevfZKJ1yP8dRzauPTRsg8KjCWfHKkQI2TnDOLaE+Wm1iFVgNBuxeQtQ86xK6mSgxhC/Ke0Pl+Em/cxHeh6BaSVtbKwNlLhTNgxnRHOXA6V8FKVsSJxgvBBVVT7JDgulttJ9kS44AlFm1GRRIwIq8gF2gRqrqDoQhSvUZXlNmyocI+odl1VSxxT3x9+whxiWOH7dbe/+H76+xpRWKXPxOBjWviJ/K1EZAepqc0RFHEOZNooegV1mvuBWE54ItKEPJIPdLs6p9E8RrBJ6hfXF00Tb8bPuSBtFUEdZdOLfLTxGFpEnV3iGLQxbi83t3A9/fN1FIQqncKOqbUvUcmbg7YNsflJBOIpC32Gb2SbS7ZdULvcTdnkJe5p9hPcgratV8X2iBO8AnUBMGcc5tTsSiL09pS6i4e9WbCvqgUyVMfe3JB4B6ud8xPcTqUSeVI1Pp1q7UKIzKJfodEcr8F7NXMKOvlxr7gtEND9k4AjcY/iWcTcW6dQxndWHGh9W8rrwOhw5L6/nCE9oqq1KCKIjUiYdcRmMF4kWGG6zxwrD3Lf+Ev+1ssyMtBCKLQ9ve/NlHKSkMIaPnhjHUFd+DSJkIDyNLFF/MLskILDJhPLfqLs4YgU8vPky3Q7Pe5hfEmm8KG/fX4BtynaJQ5aM6i3tLGpJOE63Ns6ZuykOA0EUTzEKVnQOfS5dodNg4AhX64vpqlOJyzj1crt8aBev13GWRRV0hvQ52TiYJQkJXm9+QhH1miG88q77RfxzPvbuiu9XfY8olRQruAuKVaRugnGJw19ZoD71ViON61N5w3D9ty8eQqyltH1BX6of/0+YTJVixEcRu3o1E7OzapU3tttoUmeAKeh4xDeSkXKSfY2MDgC7PATh8yPYkBfTFDkAqN2DyQC/uhTQ1MX3lcBK+kvObQfem8dMkN8pcaP2+vZgp6YGtLrXJP0sGx4HEYkyoMA7gxjA/F/DG9O9+Z0DpAmJSLv04gALp3vm0c9JiQ6CSeMkZVpuchJB+5w0bnKOR9Lkp3VP2XYCTPPoAQH5T0M6ty4FhU+UV36v43WcY+CirOEuX9xrF7SuX2vt1stAXTeXDy+iJBFICxePQfjbIyyLGutOuvNehxAENclN2adYSbZD6+AxM5KTXq4rce8gr9tI0vlKrDcgokGop3IA3kOhJMf6A4tOivapksap85rMfEEwFIU67XZq7MVR0htPumv9lCpwEZkNmPxsegQbu5gQBmVo2bREcjUwos8eZn2QcaO/0wfVaIDiDB48WHROGV0MR9mW+kbRvtAQhsdDxszUtygCmtv/ekWd4s3k9+yfTYoFp+06+crFgU3+y5ax4xnK2rPKK1A+62WakiRZfT0SjL3EvBiv6ijJxFcki+YqjAHWds1Lmwa1fNKt09FkefIEUg6rCw+K6N11jLyi1Yuuz4b2/V52Ar2WvHBDfAJw1HG48GnZBUNm1yI0H1AdZItVFYbGnkiBYWom7Z7JJVpEOBghtNQqimOwV3m9cIhlabdwDMkj6Jk30p5VdoQmJf6tGHeR+LXFJ5Jp9+yN02pCfGQbPaKonS2BrXjKSWR0wjgVxsRJ39PxryX+23kNN/SrKpEC1ft0a5wK3RV18/rkNqUQ+Aecye+eHkmHAtHsVF1GDw4eu9E0rD5yxZSMhuFB1AK7yeHUh/wbS1GixXwm/WyWj1nB0MpH7b1HycU5P5w6XDRnFZtvEdbw/rD/og8LLESfLIr0Mg7cMWboqu37EobfyxXhdKKTurKrcYcSSXuXmynjGXCTcXtODm2KzjL8b+v0j1S/hZT09M71aP1XoIp/E2WP5Ebd7L8YRfLiJVUyeUgzQ087vvgyk0mg9ye9/K/mAd00oyrdjVdY7ObRoKYLsbfKu8CkbHmtZmG9ZGb80AMINAeh+rHB9UpBrkw3ERLbPYz2CZ2LTN4Jkyl9nwRtYuyP5CfRPdsOlbv4HcHWGs91IVQAvSF/LIW5G+/tu/uFvqDwMfNs7uyUDQ552p7df3KfLqc6FQCLarq4T2QS51MJ7/Uzjxayt6LLkd4YIqNd4TNR5/HDJbz5A//PS7jqbtVjkg5uwik9mVTptbma47EH66LqD+7cQMsW7GxYWCzRPay/0pxpE4vdQsu3t9KblI26292SUoYvtu5ONRMbpKGCkS9JidJi+mOiEEiGDhJ4B2G6Jm1tUPrYk7MRTQNYtS1+dL95TU4zrWtWr9KD2pbBuIReydwnaIsBD7OCgaADFIAMQt6E6Xm/9Z4vTfBKFIsrQoNziapFsk1Fj8+n0GFVniaLu1EqEfmeQApw6ZDbuQWk1XXLXCUxpKOTgK5rSYbgRgDhBM4+mQ5fYbjD536djXEVhNc0w/IEJAxIS2Nj8Wp8yIhY77iCU9GCwOtfH3vmTzLpUEuSPleltUxzXHVh0EnNaXRjX+ZM3vq7Uhkvv/QjZ0S89yNyPxHCybq08dg+h4xpANKGP/7PZvnjpAw0rwlJVHHEmV527L85IJwl9NAncj2nghfVZa7nxkcGz62jBnBmvP9vn1f6oYWBn4AUMnFIr/kbmwpcnzqGsX9Nkh0TQLkhjcuVxqYgtzbK1epDVQwxNGmXrDpeIYfu9KqQBEnPyLnvIF0Tflors/I8YPV4sePqGiZO3oyNJx6Cs8drW+3IPp4+oCSz/2pJI5i41EaLKiFDj85sSomS1Cft9LT3wCNcDtQLLM0U7sdxdmrnB53iKznN/91mTu2b5O5H2zweaQGafSSdu3VWrWYeCBqxRWAPYdnRNgwxh1d9gsqfSeoeMaOe21GWBpYwnfuz05m1m7hinvk5adUhzeZ05OSuhzFq5fQy418W5Uysjf8I/5TpmJGQjfPO8fhQv6JlRiDl4nGzMSg7EK0/BfoGnaG6sDmoyGbOKBW9HXvAOPFMq7lUg+VDPnvMNt262xvxFqI6AH0N6I2/Jtg0ZLveY0OVTZkaB6k/eK4wl/w9KL5R4cK8seX2qt6zfSx6ISYOf7gcbFV31SobQ85vDieDPgN6/nx0YjpYA/zOZAwKaLBEiyA3eKT4EC0e89bssgd2mk7oG3pEsJOKA8nX48iHT9zsNKJd2GbUqWLKPWOyTzbLRv0AjZakRWtSfKs2MJcEj8+onB4bom2ETlz7Qbzji8LktSKHb84asilU2eai8As2j/Qus2xHLJbzqQKTS2pm/74DE8igXw9Drr0ZxRfjK//W3Ccz4Dz/ALb+l82hxMEQbKjh5lzgmH3XirwMLNUFW3B+GZEIcjGaGSTUWig8bfqCVsQfYG2rAOZ5OqebZUnERoYGroGIA0y9a8FNU073f+ZT8aGlz/oyCsPfKd5SYVboPpwazSATtmHjhIAOI4WpvU1lBTPWVz7xySLHnp3mGt1bmQgHhMUOE6IPZV+l4yP2iddSnyao2V9n+nqUjrCfUevJZQblIaGdgIqzSSWO1ZYXOH0eEBFY6Ak8Tj+zJSIPMX1ftGleuH/C2sf4RHcLpJRXCcTnxYNflDkWuP+xUl71ATb6EZRwVROa8BFp7cK0BOMeHgE4yraCA3Eg4Napt+NYMzliQhTK8z3Ckf72NKCAgUoI9edD7lEiDZikD6kOt6TqTszDCtOq3nRz8/CJtKB6PqdrFdePjt14CjXX9mV2cCBjwY3hNlnDnY3QhNGlTrjaAlOBZJRPJ3MVcYBwSfFk4Kf1KanWAFRsR6PT6gxcvVSbGsa+E+LFyAj5vgFKAg7gpJent+1h1R7dbYyZQVBv2t2A9/z/D07WqTdn8gLzGAK26FLzR58iMKcts9OSRFWNu9/NxTAuhrK6A8iYaYpq0n52peoD0JD6efbi7Mugd+1M8Z4388Y7y7dXkjXIoMzL5lwW/2R7RXjNEnUYLpOGmN7JJB84/W767xFmPPetaQ9YDQVwgCu4C3cFVmm9K8MaLZ/VxeUVlpGpBLnPxRvBNojrMQT5fCAJ26thvCLTYnYtgQDz6oXuGDemwjWUt7e1tnVS9BO9WSRONGZyKtYrjPNgv7PrgpzUZ8j1X3wGrsxUf+HKsU0c9MaMc/3Ol+IO2jH1bzkBw3AzLJAAEB1P9UWmdT73tLI8ECBJUVIV9NfqwbTL5/Ijs2txNU7aSFnuTXh6rjAyAtZ6RZ37wKATIkM/QOjjqwyPd6fAkneaqGGna7GwO3jaBT74E20KWCmbaO0LortGQ63kmqTL9ipGEuNJlIlUQsErAdKmCTPXrNMKrajfnP3GsWitKv6fqkAFSI1coKUazJvuazDKjbaf/Y/4WE9qOmdDUQZQrqGZTbuYs2G4g171ckTDmGwIcq8qsFE/p1ainAgomHVqewNCo7BPtdDgGQvojkY073R/dPYVEdINdi5mX9EJFfc3VE2GhM9Tc9+/MPfgfCvZA86CHFFU1xIAQGJT+3Fd/DuHhEouNYnSy580pal3JhiVXTgMgCbEpMPozNBs/bv+I0WwCQUANTt7T3vcj+L42lZhcf/n5CkCysEeCPKFhnt2kQGAbntBsii0v+Py1s7T68IXOefnA47F3wNMLFkaYVBh967P5QCrtaryrDe8QIJ7DFw4rXrbcyqSsDP/oB5WLw85wo0nFUzrIoL/YIEK/+1xvPKhTTC7x81OYcNlYdIrr2LkDOWa1e+EfLtL3ibDyfgWpMcitkpWpIdF5P987Yz6jL6Sp4a+AnZGzbLeJVM9GDgyrz/FlxQCMZ7fVmko1yjWeFJhI4wnK9+YXvcAMAjWUAIlt5JuHk/4+Z7m+ZJaTIpEP0hHZcRhzNX+2ojDoIXg1b0v8tSEZLKn238FIY25JQooY8urQM+Alk7d/vX7HguAvYnv2S3VwNdOznrbMSxL1Oej4KD0j2w3cmWe19SwID2doYEjqzz1cup7klQ6ZmuldoiMrwNG37CRzPymomDS69Zt2PkUkR6gzYzlpXSpcHIOfM+fX90UtBjPWrV6GWmolU8hnHeACh1G4nto0EfzfMGS80Anjf0YQw7gZE3AdAi1OyTl5W+0ohWOI01NenSxiH0EXe/RVZiGydQvHsGq0NccdSPKGjSQJkmW/NIMmtzROoNBS2e7b2G5/y9SFYYPH8q4xVvgC0Yvl8Ui01if9i23d65BPgldAp4nL7Wq4wYX+K1KGHHiKMWQAurVHHbjwZCDAhsNXXaC8tFXBNeSClaIuX9/+8L5pRbKH1JS+9glZIGmccR6J12puRbehxG/Kxdge5mqSTjBsXgadesklIuCZdKF0KGmqoycCKiZeEhN/svnPlInGMsrVxSGkzA2iSmDIVImGGXG64rD0wBeN4jKAypWxyWlxDf3nKYZAjfmlNIR79SAivW4dK58wGidluqfP6NT8tgKdkvYtXJrSLG3Ge9ETpGBMAv48AYxnCKzKVxuCSoXz5LHHxdQHl4JXX0fP/H76nsEGEaA+rom2NqpMy/4KCr1lel/Pk5fjKUhpRDdMdUh38FeoGOVyNcFJ39R1rxDlqGBL4X2V4Zsjk9NuP7ZeXQ3ec3r6MSayzxoxo5H6boxswtbzknK5vUSteKNzN1PZIxTR1ajRSoma8I3FPdurRIVeEJhMTSSGgOB8yB/mfc6AlyBcLdafuyfO6xNM3hs4GpiutVZo+7f+PaFkPdHKIn74Hc6tTB3GgY6Yw1Dl7a+mOZkJZxHnKD3ahbs22ygO/55yj5UAvc5kDRHQqy8sK+u659OiWNzwuBP1vivMJBSpW6w9U48/qCRsVVLHQc0AlDMR4rjs5xjKf7sP9DSEBwrl4uogJg3jjSwk0vFlg6K0Bgryzw1MeXJavG0qLeeMoXI/+vUjAuZuAjd+Gyli7Qdw5uifMriAUn6/HnlafpQtdtm75wdOvXTo0aXFOzHdIa+IWVqX9XCse9UpU4vaJ7+0I1Qh731sB/oEfBQ55kQAAKhDlwPcF/DTJiuyrmL8zk/YaCZ17RrOUll2SmFU7IxuMT3B3DtWcRSXni9qdieMyI5PpcHfClK5ewF+iilcNGUYFSShFcf/kasTsgCW0z46h1moneh2TXGK8/1lUVe49655zWV5topGbIi36k6GE3pdRsAA5nouRGNOhWFnVKkh3ZLInOpPx7CXBC483WVw4AfLiU0vyw3KJwHRCeJDnRmtm8by+A0gb9oSnTMZ/02hz7SRmDisfoGLDrDC9rHiOutjH6fypHVcTnhfPbW4s+uOfaI9XTjsmczOBuCCcbJ6U37lR02ZAUZ+11VtV6kH2QB2b7lDfVjJiYKwHh8V+VD5cg0aNFBcB2hkZ1j41/DIm4iw6GotjeVp5Wq5sRpt4EA4EV2Fx0t2ywfRnCkKt1ZCDIeuHChnLU2PSrwnSjzfFVXjMug1X4LfBRIcpo1m5jmvA69LMeheDwFTakfiF0lEmJ4T+HTFuFL0afBuLogUKhcSNUnXcJRHjFH6KIpHuqgXYNTtoib1POkbt6j1yfpYy2K4DfZTDH8LboDXVVYuFsm98u2zi3lFEGHQZAFk9fSxdvmfX5aWJUGySvFYaeaAPemzmb0WCb0u71yOBohZcVGCmsdzwT5DOTlB6ZOAu7W99HnZCkEnGRjGaF7BG3i+FeWUp6XpR0rdJ9KQB82XrHB5n6cLE9T3wR6tnfIZeqZoPSAEkc9L3tgJABTowCyDLmxwv8yeuiwI9SNFd9irI7fYTCNvI94fDuZSlqRGtyVUnrS2zSO8UuCvY15ER2jQ+dI5KxWL19LcwhrxyvTqOZCNbcM1dBw963326n3Iy8Y4KenVQkOjGHpBaqpzD6GRU9mnqED17CMlvTNaL+c3WtD7lF9ByvBiBuBN//P0i+wW1LFHQlRedPUXQglnX4JqnJsPP0QYFR+FEu60nMysxiEda60f00kwMXKnnksM61sctznZcH9pgzSXN18+ht/BBhPegV1wRY7H8okiZjPMP0lOY/gE7WPvwveJ/T22uyMPvX5zP/0J68AhM6lVFA2qSHPLsHFzHrGv3GPJ1mSmQ8ICaG9YGJ5ClZbw6DOvYf061uHFTn3C1vdfvTRluGSzJhV8d+Ka/Z5kBecch2eIWJ9bLzamdb8fcLVxoqyV4Xc5ftbHGI14PYJcwfNl4YTzOGYRD6OVAEzcpL6z52An6weB+SHWkCBIz6GEl4Aq/x5v2/PjvrfzB6+lxsDS3U9M0tfZpoNdQZwhbtcGRuqHJKNX8VACmMPNc1hF8zD2HuzR20qXQ24Gb0FfKOAAoVduDIj3sT991/alEbXxttCk5XHVVro7MiWXGR8qsHGqzvKkbRqt+IheheUGEe46mMo6PaatttA5MMa6A7JfO3LwunBYrkY9DFmDecLl1uJn9o2++zxBYcczwBvDlVLZNKEgDpDDjugo1WrA2gFVW8qf5s1yrY867EHhfelvzqTkCnd2TAMg9iYBe5irAI7+gaMVI1bBzAWNUTdsenFWO3NGMYHL4iBtQVtw14oSrACLp3wQsrPTjAsN3t+FKHvIX+ffd05GUNHG+MHD/IKGB6p+jf9keELxKZ5aQbycmeVH5HP9IYsDBNQ5t2jXEDTKdA+3EgIJeuRsZNSUcIFVeMQcKR8SNIdUQysXemcomEytirWnDRsb8YYRVDFiKhl++1YtncCmmFcAlKpy+jiay7lA1yxptXRzIw7c2ERJXTYRU4ebxKwqBX2gQC+N3U5p5EY5No57Smif4pMeCitgAsqVEkaJHh0zRGbi6Fz5RMl33rBs06uS+nX9YdcdZ5WrcDIkt1/nBXu/lwKYa04HNI6fIcqWnl2SnpdSixt6aOO9fwQ8KoqgyFZeGJi9RsVZUQXFjjubw0YORynsU1bkQPjBmez6qINYh5LEqjpdaIOx2NzNiBELU3rWP/eo7ml2h9YzKFFNhZWrijMPjiRF8SqwU1OQ6PoCtQVOXPZ7dkkOI8WBXC3E+rhc2vffsJCOhZOLMNlfVnSWETTpxgt14pHneysY67G2F1TZq2Rl3sSiA5c1cP7Bii1EVdhCBHe67uWWk7QXd6SpaQmP4XFvw/6oTWMkMJk7GOm/Z/KETZE5VAFXyJZJsFC6FTYgwbuvIPcj9/rcNmZnYUj8qZCH4Rm7w58h4Wakhu56s4vfJIkbeA+ewMsb/l5cAnM3Ye0huv9JCpiv5W3ka3XIpwJAeri9v2g/H0A549+fru+Dfvq42XYCLK2gHZn5q1+XfQ9V6SOaOsXDRdAkt2bqvyA0KarKBgNfiFEGIHDP9/jhjvHOkk2YMr4Vwc3z5LBeElih2cSzUmVhfEvnyFFD0rLaJiHJmt4NLcmskmitkOZh88LRajeLPzwU+QoPeWjd09MTKVJ+tL9BiAEQ3vJJrCQDmHSD4P2IolSz/Dwg1HB6He0GT3GjAo1UUxWcUKFZtPTomNZNx8W8PalBh+QSIzA89L/K9Ai2yGwXbsVALFicA54NsOzZm52MdQyqDwT0ochZN23mlboMRT8LXF+8WXQKq/uWAUK666ADml1QXNzpsT9sKtJNsRn8Z8VT6r2mdroCeFUMnqOcp8PbwDzbYetcGTEKF0VoL5Js5I4COD8ADVrS4UA97Q5WcZcJJmK9yj3G6y4R9gdH9ZZXcW7w9xENfyg4aaOLuf32GLW/QVRYHUFr/4wiHayvd4oEnyLwxExnNzd+qyssf1SWGxSoFeUcOBwtm5NtOBB8dA5BwPN0lQ0oUbv9j4iuLZKVM579zPJr/1jEU+bJC68hfGktldCeKUchB5++MKc7Qo6eBTA+WDi0yKQE/+H1+TJ2exM9LwKyo0y/Sc+u5I4Y7xLY3Qo7MhecX5HfwnpSATC5BnlrswWLTMZ5LJdEafe8AUNRaqvpJTzPLuFdZgMvognCKg0zvgPMUxUojzy6eOInfYOhJO5DI/UgLtRr2Z6oKjrbssEV9Q9ab9cqi4BXpGAfLM78VZ97hunLvuh330qmvlY1GD5uftfp2ehxx5Y5KE5rKKWXi5n/9QDQOKo/cXpAbRITT6ZYP5B6OJBHBrlxwMS3+YhHeo8iEVNT7UCq2lx/W8eKJZkeuIxX7Dd6WLBW87I6Jsk+IEQT3Jme9j/+ATfcDTWRyyExr1XJI/y6VshWFOKJwRvFaeKHeBPJknlWN3ICb+5bH4YQLzGtTMi1OA7Bgvlxvp24k7/J/xPhMJuLHuK23gOQKx9QHjwEZL9WmrptEgu9RVjV16FZgqu4zSgyWhSJzcingr50SI4syOShO+mpiV0QPTpFPyFkHUZNpFbBkJNoppsmd+XRhH3xfGWpE5hLiOJYI7jZRFwfrzjoiICiEQ2DBv3vhTymd5DLvCXhPcXiQSxYXKVCK+ZxmWBpnRJgupRa7flPo5n+BIOivVJQpf3XILfh73SUIiLHZz7MD6pMaB0aTPSbyXOATE9g0ZduPs/HhHuESQ+QTeSqAjg9ADAdKePwxGBWHS65qoBQoJsdxJxV4kX++zhw3sKQW4sCeF4omOhg5KT3xYXRB7Qh5bMGpTRc5LFO/caPoEFYhFhQWgFqfRj34h2+Q+YuwdFb3QKtZIs3FWOjwgNNMt270UsWXekYPKAicrPr2c9qag9tR7ZN7uLP0y0xbXKHtMhhcZCEV+Lxboi4p33LIFGtYxPaIoyo1+K/oMvpVBvHCOBL7UzhVHCBnXZin5FPwCZWLlv+gFWSw4EYJtY0NgEn8Q4rIVos9xn/qlQ/cARUO5OqWLVCH3FSqOpIjE2pFepECT5Ux5rXj3id97lPjxCjpr98EAITFOtM4YK5mpgSBSAzGkG2MtHK1v8R8YG1zXZNcgB2kMmK8DazSIJ0mu7vit76MO1FJAF4AZvK6Wi5eVEwBdj47DZ9N4zVakg28Whb/iuM/htytn+JwscVb/qxqNZLw+LFK6G1vPGJHVmUk/O8JC6X+AqUqr1qU1SXFaaDYYJYyxrvSYa3BPk5XRD2I8CznmrsKWRt0ntGHIG93gKumtxecR+480eZjE61Y8KQmFLqNtqRfiSWrvhAwEBZaaRPD7Vgm+vBqGQHUaEFDs9BZpJlmiFs9uOy1rt+s5VkXV+TMdmoDeiMLQbjAiW5ZvZN4yCSSF6QK6oaj3+yGLp7t4e9IJxdt0cGJrVFinyZ6PEubBnkEM5wFxjyoNpDSTTCGdEu/gPyE8CEOwEcJZL5zzLTnO0tElH2c71x24mPaLtC+sQ8waiyu/OTnVoCrtQHQp7bhw3QvwcGTWvpdFT+5fFEtM3z5GfxfEP2PIF9+GZQOT5/1zuNoZ2dUuG9btaBmuqHIu8YTVgfON7PEP/8d5yil3pw76XhmPTrVOq5mwcwwi0DnHhvBJUhMeqdGA9ELOiQ5Qjkc0rLGKpHwy2jhYkX7vklDAFZznVpmpsIOxfjG3bkHApfWX9lLbaVm3z8+b+9cIGgSJJBapzvQPleE7aA5Cy4Ul6Ij26FmR2NG2vzrm4QjBM4pDnN/r8DRZDWiVngbIfzlPPIhjVpEJGH8rmVXm+4DrHeK2GsS9QR+V8r/VlnqT69O36p3+48qD87a/Xk61N6DiGFX3YVSU8dFZ2rymHtSyIN0EEvrg40Pg4UUhAFbwQ1fxQ3C+PQgOe4IJWF6anNcGPImpchk1NYuuUkI45s4xq14mWHi+tI2Ws0ODcj+7F3BOoDcM4bEgZ1F0AefOJkPdiU9Rt+iC69XpQY24iDVCz0xU1rfdLJ3yQGXBgYVc52wt9XDY92d9gJfiFP6QtjENEwvzNPApBfJoEEGRqpGKnfgEHbJRzmJvM0umFRI9C4bPdjHSMNSiY/4b1rsLXk5A+pHoE7bWp/OROboOBnx3wQ75A2SPTTVX5DvRps0ApPeQhieXH5iOED+qs93HbA/8u+hrI+SQLFgQe6RV3rdWxH0xw3aW2/itfkunU2Xa5k3HahARW9tv8tQ3pnYIdQs3tMMVTuRAJwbDtLtM30/XkDNtE2w/67rqfYItoYNCIBVxJ9p1lxGnhNkUHNIar2nsynXK7xm5MzBZbn5B9/LIDEHSDxNcNFnqEBSt5CYUNS+KcJPLX1QuLzc4mNKgIMKT7nPprfg0OrXq8OUuL9rpxQ8PSTK029eke2ve3aAzO+nI4qYZfkMmG0/kfWaRc3qHnh4a8OGCXNhBp7c22O5Wg7HKcOq8M89vPaZmI8FBZTwRZOy75uJwX/yZKPqmOrhAjRwRx/sLNZyyNOnpArFGFabyiAhB7YX7rqW1NZkHiMxqOOECPJKGBViu70pYYU5Y/ULc9vGYbYKLUPfb4zFo1KxxB14NVHizIpIdHQfa4I0lKRrqspAK0Jf/i3q7ahEkE+/N0V1WUQ74+QPluL55H8Et1tv+7d8NmK+Hma52iichAc5Z/X/pJZy0iurah43BPba+lIR5jHmtGIs+BQZEf1FuDX5/UBP4L20DdtVLSKVrOrk+gQIb3u7BT+rJ/O2bX9QZXRqN5l/4yQ8WWbR/efw3JtNf+IecHv0RFy85X0yU7Bpt/yzuGNGbDlf07WQITxpBHHHi5ZGVoC7RcVgdvK3oxUC5rsbB3gzjqYuCatIweysU5rtDMWrIZKRmj7PwuiCMaEwCi957jWen5DzppFAlcNHch/D7aKTUopg53RkrppiiB5HFk6TE8dZGrVsH5a8gdKoGZp+s2nEPPikzn5O22O1euh+2cejzytOFHh2RvNf26dsWiTda7Afpy5YTDh5pVfwlwuJAm17XZktQeDE3B1/Lc9R3TMhG5gtqpZErFG6eCvtuYd3aCvlkE8AcljqrLYJycfRozJds/YMA1a7Pv3jGDqDnylPOSkmsA+Iupez9i5Y66XHD70LNbt0hyQP6d17dl6QoIzEcG1pGSVkFLem5lVLs9OLxSa1BVce2ZOZOhvm8U3skR/jjLBp/XC9MzWGOm2nshouRlQRTb6GIUq6sabHzj8LpnkU8cZViNPpttex4Too4vdTyuwRnuTiq+fenA41zEvN8b5zy6evb11bQEaI4wkv8oFpizRL0Rvr09ff/j42kHO/B9FiXSQmPRQYtQAonbAJpvOlnCVQSusS0Je95gT7e4Nvd60o0ESo3qyj5mif3WA//XA6k25fDySKvuShYK7rwB8yB1GCkaCRL3KK1qbqurB9Tzr7K48b9E925E+RJg3WREqYaj4lcLjm0UVHbQya9ry4jlnMdebnOA8o/y5zRt3M23HcVd19mZqs4BdGpzlno9QfculeJWqpSbsEip9wvIU12zFurtUsVXjSAZFSCz/5a0YDE5pPf7+wHhBxfDIETE/8mUjMjxzB6iqRONDDnchxdI16WqH78mb7f2INLlFRpMGhkru6azT1jk6xwfuj1xvV8bbs9B6/48icD2dRPr8WlLPPI8GqyQCL/kNGIcEwQhihUwhaiwFmB8DMNAFsqbV5PWi9n5OHc6Q+sh1XjLwivnE/YSBu2+KCooNfsxb/JSTJOhBpAZPuPaaiT7L+hjJyFt40cz+lt73FqIRY2mXqNOPK08HvamE1/ESZjPG9SlW5TR5C0ZczYGzYPEZoDzYbJ3YftK80iebRg9SJC7zBFbpe4fuPsUMOFTSzSg8v4YOv190gbq05/ONuuSdkbziMOD6SFHlcB16Ez3quW3EIc9bu3u4gbjAgKInFIsIkZIuq1vUnxKSX5skmfDQ81zD9umr3o4ccCubFJIUu6eQyI4my6/PcCrJRbAtVTIiup31bfk6acTjV1mVNhjPys7dnrojb7Wy2nufpj6QCLgt9S/9WByRBdtvgTNq9IyQ0fzW+iLdbj5X2F5kKhzEY8xonRstmbxETYqDboHDmnN8BYuPLFMNbxo10+1og4JfcG5G8HceJftf8FkjzQCc6gjOMbci25NkcaNXmtA1wRKLY/47RbUONLT1ZwnNDkn5K7FtM/MT2+20VdaApIiG2QDKNrPdnsxst774YtXCxijoXEhSNqGcWhp+y47SikvTOpmRMNapMp2Dv8LcPtyNCKUxVHPo5t/XhTcduEQ+wNC4Tpd/2BwkMkabE8fJEuBIYgTfqktJJfbMQEeWu4j2Gw+ygVW0RSgknVCq2nkkxW7JWvwsqab9l96EnFl4TNhpwCF42d5BNAU/mu2KGVsBb9fbJ9y6op8K2diDpm8W7E5yI9cjKvqwKGzFrZIFhIYiz9XzcwIeQNVUoPML++3Hwxn2Zm5o3Isi3uM23kK9t9IKma+YFvQNdPfP8Fm+I1fAHJMemmCA3AaYUkATO3K7+I+6fto4g4KalTm3uq7eY6aZG+Uz1OYsF5DsBD/tvQpWsXT2E+uNRllK25v/a5ZUBwpD4q+A/mLi/D05HwcPuOV0Y7VrO92rdGvvUnwj8M6tgcOVhyrzxiooRDbfo18Er7bgOH/HKxsEx3Zbk2Z3njeyd296qwmzNT5hQxzocXdxAs7pnc/8dOvux9TIjN0NHBIsvFb1zNoShUvhEBMOWhrVspro9ISvB/LHs1dKK71dItg2kw6yjyg45gO6WqK6TKLXW6OnQNY+TFwjwCJtcWav78k9mpz4LbPnUl9sGFNjQixjs2nAuZrswvevaoY8v4diDyuynL/4I4tGKKLgTH+WksV1V4TxSBEhkgpbalVhL3kYQsuIoBB+uNYhiiIW8hMxajSiNUnMPtQx/5VNvvZmDz9L6j2JrodPJYp8g2Co9GT6XysVZrZgMxDAsx9ewDpEUHRdqGoRS45DK3n1tyY13B5RX3hXGmN3u1dg87/yaH07jeAx3R912G1IjG+xLiRWasygt5+F4EZVk9ntgChGDEmFnY2xV68VJCNjowQJPuPkcIR9LppiwZ2zJJDvhHdU4TzFCkbS6/lE5uv/hmbneaGQqLnoBPHowJSXDNmKpJGUc+fMB7QgyDphZi70wCzoNDbFXP0MdKqc1gH05L/zCtV/H1OtA02OnMGqtMB/iHMx+uXU16vMxvu10oz9Ty/b7rsWJCRCOqyp5/U3Cplg/LvVtrnUmajps3Nnwje8mnXNoQrGLgVX/DUiexmP4R5Yr+HE/HfPB4xYCW978aTWcXfQDCrTC11fQGg6TDvjF1cHkQul9pnLb1e0p8On0gmrZxphGIOsou2MZevDQBRbIB1GHIJQ4YjZK48ccQX+QbIZdfVBABOWq+18FLNMeev3kjuMuMfXzqqqlzoGBMXfjwU1z9e65ZtSYQXWQL0TfkXd2iFdAlwupFotqrhZzjAJr+zktlISC9SngAcWjasZvGJpQrAheteQgIkDwBvNLGDGI+7n3kwSci7Cm2AcSh/tbmSu4VmX5cbVG1CFS7AP+9CKBbo36Gq9q8Omy2ZRynsOA2dh5I+yZl3u01Fb9gTLHMkECu25huXDFz3ks+s4kifhiwzXjcPb03gaypH869bRi5LTLhOVZvikX5Z/o1lsMn5NaN0FEH2c+q9D2C/xGlfRdnH3V88OqwflZ4kccBqAQqCEuqwYvv8LvNxeVdk1Q9Sx0XZ7ZfbYpH6xE+XnVKe1uZNKC9JAVhmIvw03qpAETZ4j2kq4Felm/eCxqzvKIkvtro5PIBnq+pT1Z3Yhqdp3UJAMSha4tWG8q8ZBjtx6OqrTFp9KEDmhV+uhJglSpW86oNxhoiwTkd+8w5hQeK58xcnq+gZ8u4f4L9H+y+yeyMuVNav/R946YmpY81pbsFioVlUoGIDGTfgFG/GMuvKzKv/e0lY2GTAO6eoBm5Xy0BYPIiG7cZefImZsXT8n4hzRier68W1SSxsukB35HC3SWKON1JwvDTOAugu5fM3rrqWIm+JOuvtSKI97UKzpiXCRqzqSD57OeSUnw5ZXqBoa+vSI/RkwWhXUdjrI5HjGh+RzdNFGLRWOSquvfBwuBbAGPgVPt86al19OB/5n8LGdveqI2Xy3SM8VCh3QqV1l7cNVfnwHX4y7PcKvt049fJPsY3vjzuBhRia5pa+1e2TUsPjaTtGvvrSruGSrHht8Xi9iOmapM+NNJlbkMZOgcpFmqa+JIJ63R6VVQ1iKpIcDEgrxfV/P4SX71TOlFJdXOiIg6gOv/R6w0F0aE6BafdZ8Avzs+KFzVkp83SVsAPHSFi+Fr0/EkUFgW0gjJNPAs/ByJuxa2q4RZZck91EPSrrhDnqTD1JCqKqddnmYbmsN0KFyzXWPrVOhTjigm8mtsHm+mRkjSRWBSpSeCYzanfIvcOdR83R015Tvuiq+2PNJpLqC4+WtgwxwjQKk/c25kFqk1uV2Hywmp7yacOhRXMTKs3uexQHLQq+W5QRmH0hB5r3qAjaz8RwsYxrT6ZpOBbK8UzGGW3JIaOkjzeXV79ip2kVnUOSNXX7EJsUZnk5GT/PJKRVij569cWH47k+Rl4D3Ww+YR5VICnAZaOSL6jgCwI8QHpLh/PC/c513SaGo7kB0hLI24RE7UKKS1kbnAFdzbaB012j+AzmtWI1uA7aJTlnlZhiORS6IBLT4UeSBsc8PJ2JzWP8ljF/KE3/P7KixBhNezj5syqNnT0bkkYAzLHVrVNur6I/kgcKQitU/kV21eC61X3+K1cEoYlfb4L732GZVfkoYfIfFCwZL2h2c2rNY48gpPHUd+Zk1CKIRzuMAcj7MX2hWgq/XV8LC3VX+WCbikZpz24459cA1kXVwHKfg66vTnEQWTwh+DPlqVqrzqtwfgZ9JmUkWHlYdPG+OrdnPljH6cXgc4KCrGEJn+//njMB6TssXFh3/aPthdmhRbnBmTdkMWuPNsEcql1gyH4GnP3liU57uq5wPcoyg7acr+cELPKSR95J42vpqFsamJALdJiSaRshK8L8AvVzh/LPSpycMHpbAHSFWR9euqZakDqweAp0uLusUJ3o4BYWmr10EJx6QUSe/7kZdxh0rrODq2ORMW9ZZf/3yGFEkIiuH0/mCPSdBoeRVDnWwiRBAAYNlokzS8NQRY0t/I+2uO9uxl60jWTk0hLDursBvkxaWPmKE06DefSI+JpQnsVBNezKn3DBtOKR78LWej1Bt/IifiiqB2PzSGSgL7AitdAaeYBF5mLi+j9kdBhLouAsPmz7b6yhRG87UfPoIqOHWpnAdP/nJUDWAyuQUaFU+aKK78mh6ztoiGnE8jbT+SWfPkhE2WwxXnxvIWxFnns5cSBDEGAP1yGdoGpvxf/he5QwiPAAh4MWwaI0cBUixIIaG50n/ljqFFGXuAJljqO1D1mzMUbCAHEOcqHasK2vpQjP6v5qRqThP/7zwX9h0sebfJs/ulwzr+NPxzfTdXxXDgiNtVpEVE6p0zhDN6hJdTbqxohJY5V8A+efa2/DPcmv9dkSOdUYyaAzlRbu8z82tUxisEUEvJiNcOfTyrKLp86YMy9vF4B4FQjYO+vRD5/uMaX0zDbreR1dCuEwjMf050I3aPTeRF9saZj9YFTfxZfbKvRqdeTlTsdbJ+Hg2uaDuqjJnSPFCkSpH3tmXjef2XfcMkqdnmHiifgEraQGQiWwovsmA7+1VNmifzHqRPqImoEBtBjyRd5oaqqTdoTTUHYN229IbGX6sFbhpi/7UzdW76oxMAkCYzhZMvETBedzFD5pXZbRM9/F1zMe6aZq1bNet4k8xzDGe49wLY5zDmTaB/sYLIx/FO4vS7oid4b6rCIH7Pz6yURjzII4dxp2x4ertnXxYRdkzhpjl7w76dvLbVOF5eqn33jSsKSGPOYxlZQVkr/lsLK5OFRc3SLzgpV+9tE30DvSzoBYTij4gEtH5PBArUjS1X06ggotF/66QZscns6tgKVlP7Oy3+PBzyweFlCT+asJJiYs1ODYkdcdwM4fuw316eAVxVszSXFs6YtVNbtwyI8lS3NDROAQBgtKOhjBzLwny0A1s5G+oiXFwfGbncYI3bvOCAQuXNpZ7R/RKkURYBtAHAeG43XeoVogkE8rfVhLWuzqIt1alOMqg11ZEVPyAmE2pzWY6xa4uV/WVilbz4SAvD9GSFHNfhN2Pr5vPhtGXIcl6NU3qnNMrgEFLOPxtXmwfIX+3nTdalB2KbLXD16qda8FaFJQGjPZt/hf4KL+2V5c3YzbE+Q2w7TtcjjCbqNY/AoYL4yW22f4MUibLLzrX+iXVPkwtZbeFC/aVG+JfK1aZZaSLsbYWy3Rz7216ph1/MZYs2ENtd1X0Sj/CwhDfMaqB3ZuuUPgbODllGCGqFhDHJOzNjzbzMFpGNHQtouuzZx7nyuWVfW7QEjVLTqSnRPCQHFiLsp+ukOzMZlF4lDEYZoYqPMIP8v1S37J4GHvMuROC2o1uKXatXiMpLdK/IcU7KX9a4dGDIj5i71tNVrx8Ss13loqE7AcMUq+8gbJWgIVR88RMg8o3KiwyhAm8T5n/KZkrEuwYejvKSq4c4f7tGWNIBnIraqzwm9pVWHAW235HliaBKU2e31cSJdWDom1VDLr/E771PtHL07hvfJ/rtMOZdpg/USrzZ7c/tkh+lYDZngGacGyVeQ2QxzDh71RE/G9Of1QmHjdrXqqGTBA4nR10Ws89W8Alb9eZfhjSSfywGsH4T6BaatoWQAD17LkkQwLrjPD1Mz2jbFV0b1gufz3NJ5vAexQaVuPfjw8hM5fSLSO/6gfd4lJ4SV135qzu+6avqAwKSlC25Q9fBti/+zmyUgUfxPu0kdNW7lgeLYMxaCJvi38uIBK59cdi/oKzzYVNsk5dVap7cbmRbqc7LwFUuy8MpB9mGm4s6FdM+YCwq9ibB5n2kCza7wosLHQ+7OvKdLEyIPgVhVktocqVsWT4yx0KeT4JN+1WArRtfOPvGnNp0W+0uKrRdx9pON5MQHD9keBc/jLtIXu+LZv7WLwUUK1ZgLE9kWl4IuHtkYD9XePDL+N3uSfkQQH+wOcP7veJH0jBOG/2ZNP+PAtWO13DqlhrOWfINU9uSreMTHgA1ByMRrz+lF2hYF0bhcdMNrx3VMoQlIw/TeX5aPpXEY9hwBQksQIWm3+5isShYov/U6b6EjnITS8LJnQoLIEL1dq2tqkDpIUXrRPuisWmN+BXFTLfCvDlOE/+rPjz+LfmMFEMpdqU4EfBASJe9XMf1I+KwMnZfnzREufRLluNxx0fyAimxbSmQFoLGmZMr2SPDxaT/AkgYkHyLly6aTV/SuSb+lXQCTk2/PnK3qt4OgimlEqEgWv3BxzO9SK+Fz+LD2YbZaZhGgrqEauHpdv0Jl1hkzVSgA5B/tIPMniX/ZSRWZj585Nfkh8zc70RjAmRhACJZt6F6sG/U8ilTHKkB7NjPA6Es6WdkefxfCCaLeei6V8fWBmcmQ5HUcl5aUUuLE0IFg5kUtUUuTtNriF90HzIk8uHDZV++gNnuaxfb/1H69dLp3m/FSw/mkCktCjTtIYNt6x6zO/4do8sTqySa+Faomt1FpNlqt3bpEcnxAraqWYdIkC54aKgtwVfz/K/UEYmpUObn3nXZbEKIURL3+PPx2QJjgwpYf+qWQsq2wMBxlRJGHEhYwtTnwHd9gnSvGtchf+VAOMFjFAV1LGt/Uqhq1sjeWNqx3ZSZlAtx15ISldypSlorvv9Gcv8eTyDolpqyh8IAhBEyXEbSj30iAP4wwZY2lbCIEcc92jBRcF8N2IvcnOCpKga3NNvj7lvPL1TQWe5nV40zbDwz8aFMLiuCCDnm2YK0m/Y97rXFOKAFSeVyO1R1KcZldqDu2hKUEeSC3mLjoff88NcxZZLSVMkeGA/rcC8z/0VYHa5fmIQyzfHB/iBTb+bOpBQA3L5ZBmlgR8eGG5YOVDU4Oa4pCPCiYjC2Xg1Vpv5hNKzHmhyX71PkZRF/RorBp4VW5HNF4XuktGxUW0eewIq+/lPrZ8c3O1xNJcvKivhus/hf1RaVUMMCzU1PSHHD/5pbf8GW8Zd8h5DsuKidZkDddv+Rov/98k4+Ip87z9hcW48fkNnGxOxNAGn5Q35UoDfNGDM8sgHe8jxsUPN+HYFzDvFSLduzRIfRJywdrST2iUfGmGjWq635B6sYKhxpZ7MOcHCRE4NCYhddqCTt46S1Ju0YLvSzq2lkurCE/iXCfS8DWrGBBcJCJjCyqIEqfiEdKMhF3Se1rZYckQuTzoNMGCjrKpzyjvXpkCTO/99QindunLC07s/0x07jWDmWEf4mCGB4va+WIg/U6I3/7FkLqTuI2WnjT7/We/M3qLtVlLT50PgG1np5Vk+leY1yH9Db1DZ5H0vYMnfP8FcnUbNIU9eu41HEqc2nyYywM1XxrPzgfWf6fy+MZ9B7GeQB2bvJepS2idBYY9hrO9K93Q2liHvTIbTF/LQ147WxgCExdbqh2t8a/HyFMiCzqByqpH7XcW4p2NAcB3LMPwGhGs3ufZLRp+EDtX59kPZSUbCMZth8mRo5+zXMFh88J/eY9qfijxyLQzWfKykrqe1d3b2iU0Mf/7wrhxeyFdNCrBPuFMXKW1luT3+3IKERO3fiyyTx4dNGsiHKtUoMXbQ6cb0ssHiLPTyNIxpNR37kVykawsXQoSEyxhxp1wsdXXJRqcr81g5/+dUxn+jXVSnnUJ/T723rQujssRLInC+UNOSvJ+WXW9wkcqqrnbGIL6TE2iKHR7pFLCvL7FrfnnxPLESgISnZjWt2ok7FGHZWXbR2tmuq9mz1rVZ4HAk3TXZMv9RFq23w1erTQ7PYJK0Tc27I/UY2S0nLl2HbE8Gmmymqlm4a7SfeEvgWkd9ceWy9AblacdhdJQw6T5L74q64tTe3gvE3kPX0FaOO0vHgukr3s9vyP/jSgiUVGG8jkc5uOPI5cfzhNDQgGXpNUocfi2ufLt7+95HGX2JD90yFyJhtdBcZgrKwSViyfxy7J8T39np8dRRECuPWKTTpMqZEH76HwuR/bkImjQLUvrtdRrL9HFULk21fHCGMQ6JPE4myr/qttp3LOQYRe6gRopD1bNxWWKTOGiP2mlegMedgM4Fhr4BvgNWWwNcdGMkcFpSzGw+iaLhqGDrmczYL/7WDF/FANBUANW2oI6g/wIz+gJnLKUn35tv3zWr6o6cPHjDHTrO56Ctu4wbY4jDlu/vbmceEgJ8IveDd8WjlxxljBgsDU9zGqlt+n0GeVlOj25j0+I3hKEIyRce3TPITgxLK3hkhSx7Dik8lMW4D/MOT1eO9SxaTyUc24xISM7xwpkqd3sqd6RMFdY7xg1wFiMfL7/aG+0KkBRkHZ1zY+F1UCcGh78o4JxoATkwypGEMs0BTQ+X9JF3KqSiKHkSEmY1BH0hcNqIuQcSq9BY+9fms1HwQTYweeqGmO9ZvhkkNEIIpf8PjVotmUtBJrmKhB0Ov9YZ/azBt35MfBRtyxYRAQSGxzvNHJy6fW3OaJq0HkRNVuAz7beC3FlF0WreuUU+wPASRA8/LgzOG7ZcRHykesDTSViy+/r/mZBPAXObHyJYdzh5W415HmKhDUtnVbJjHTPFiwwfwKIIGmUfHoWemorykaPhS9W2CuIZjIh9fH+FQAxPK+tyQjgnQpGm/4d0GASoYClHqEvQ7U9umpzz0ZYrAguP5SKuWO9o5qXPprU9WuAkNLZPvknzw4WxhnsKFIcdEWYB5Pu35+/7cCXooWi6tCP8eust8+nQpj2ClZnAERS8BdTkLYEb0hbvRG6mBEP65x4PDnaOEB77ImcGm3tOvXedu30tIXPfrL0VjfEhfnWCd7td/EUg7Ups479CdqGq3VSLhXTFlnJWGihjp87alnCsYCc/bXODVpImMU45obPEOknLEpyNsIdodUARR/hlADUdZ/d9g5v6ch1TzTWpu650kirIWe+fcUQLwhenVBYQsbjoXSiImO67FhU+jL5Rv+UWD0K/ZaYo+1ImqyMbLQ+yJ+h1YoIiLtF9I9aIAA86y1P091plNsfYiZmO+vH3rqFjwRoKw7MfsRG80rndxgddTQpauWDJRVh2BM3yyiHrnolOXy5qGHh30qqNIWd2NhRAYWIGje8THl/1Gu3cYSHselpMnJhqtVq2SyketXoW+KLFng/OsC7IztJRLgtUCB77afe3E1N4VlOzh+yxAlsuo6Scq4DrdlsSaEw6BgPY7leUF/pDeoq1ZLoppvt1I+Bhm8yc45zLw4+AIDOOsbB5eMPBMcgJrIizii+IihAnuvSEd9rN31nfUzlaKdrpr7Tw5wA1ddFcJIQoG5cgmtdUEy6wjGhqo4wDmA/4GySktOXdX73/D9HNod3pwpc4U1F8eGu5P/MYdf1DpH2+4fBTThPX5IX/RMdYN8Pscv/9YboqHdazqRmrCiiVMzcV1E9e8Pd2TR9l0ZGSjFYDoz9ZtugocKIyAe2MxIT4IhoBviWXqpw3qQZFhVhskJF0k/xvODU71Rq0oD7Jr+2ktqkrDOpZJ1nwwRJjuZtTwJ9wfjU3zjhGxFP+UBIL4kDdKACK/q1QMg5+MpsNZGSbmzcLpWU+CFns6r6ghmv2t8TgR22ObTZMzNBsj/IQpBDpwXSsX8RZ2cX/TbvWQjRFZL3ZLO4J5+HHV1h9EM92jSNYL7QduhfL7CZ6zYE3nrnvBRmx9cLHaKf6Si8j83LE5BwJ0HaThfS9w6Nb7hGUVEQPBjDxP7Ml4bOKL4gbfkwyF8VfpkI+4Zli6J0m+1MI1cCpdvpo5EWyn1FwvfKAjnyssgMTfAgSnVHMiqsKVqGqbdioOH7PnYEgMnzMSXdjfL+VVJ2I2RBor9hz4hCrUHcnhhHh/M6VEFGqA3DcoV1E7bWU81Y9KIhzG3kZegmvEVF0tvHo3FoZlsATzTe31lLMXRdvs0h14wJcWY/y3ldARJGafMVnITgYVdcZD2EXaJY2Sx1r/nuLPEJS9Zqem65JzNfXrFuP5KZdif2fMkPssR7IxEomFmC46knDEWcH66vpo278vBsIgqZ7TxmUCQLaWJcL2w6/asL0ST3wZ21xF5ZDPRKzVvrJG4JiYSsJznVOaq4NJKjMYbfNV7aCVLCuNgeJt7/hwHjgpoDZl2gYPdm//fD3z3P5EdkEJsY6tr6r1sA4nW7j05bK7av3SSLf0H6MIxJVHiSzoAi+X+MLBOWCkC06eYM+y3k/+JJoHLS3Wdbv3R1w4Vje6//L8bt5/j2y7ubXBO9oFPm6JUKBVYGQhwSbAfA38WiMRuYpL4gr3lcSe1u/4F2O/L1Twea2ooceR3L8tc8xLKxhBlatQ64w8NQGK16W2QBMYofuhmB8EZ+VcdBiMW0Ub07CQWgSljhd+amqI5TgRpx2FpPjwFKPkSlkdWqbQiTC8xSzc5UiBSY/S8o/4xBU7elYGVOyaA25Q3NFwtqwQGS5un9G0L7UAWXIiYwWDdwa7yOJcEqT0uUD1iBLxARH21TpWwmvG8lGGuRZg4FsCb4z1rueWlDGIeNBWPxwJZDq3WgS6XVPQy6gtm28ZeSwCUquFLaMyQiL7Z+lPIWtk9RYJUiWih6+z9nBtnDShXf9qo6GZqyZnACP58cLE2jGjjul+LAHesHos/VgChLjWAPtVZkTNfW5Qy5eanbJWwxuGtxYcArNq9toO+M4t23AYzI/kyau5WXE6OdCiPhbq3rdc4YTVTCU2yZ8Y9rVeC4Qinyw7iOj42lTqI2aWdbIpWv4jhFPOLs0lMBaqoSTTBuwy9UeIoWKzT+imkYdgs84sq4GGzFqoYfTU8ykPILen5CPg4b3Mu9I1eindDSybroTxS3kt5YQPIIyFqPdARwuVS5+SEaxAeFA9dWy9Uq0yqXTyEXUUsBjqNHHxDJZNQ0YTqpEJEcxV+vxaBQY9rL1PoXivDaj6mOTljFuCrYH4LFQZYCHw8dGm/AXtvD8KmC8CYjfT3P9+jeB0lccIgWmjZlcmXde2rj6aH0+3TurGA7VXBtiXjPQghuGPctJIacvlc85S5HQK5Ygem6zYx4uurtIOWBIex8Zvag9PIdJi3V9Fg/iaYoGSNGhT4mSWlLWLGKWRw83DP6KlYX5HZUzszSVHG5mJsfimXF7E1vvDUMj6IBtDPeQ0+RFT1JAtvk/FQXDrzMysRzqjnhNsvKbrF9sjywn1Atv7qpkIYTZX8UbLVTNWUetOTeyHstoFQt48bUiIVb5nDDceOE6X4EE7T1YTG6voSrt4IrAkT5W+9hddt57E/CueOAHbI7tfn0sf522SsUG84sGpsazz/IOxAlAyesN8ZbiFITaRd/HeqHvcBI6u1a028VSgVvn8XkiWZApZ4JmesKyhllGzKpO7PGV08guIaw4CvDOHSjxnrDvD9ysOTNHk4SUhpC9M2QEhq5vdUTIvg5qvVCNP7jGc0FbAdazCKSNFSo2UImNhHRJa7sQnmTclcCiLv5Kl/W6xXjRFR/QOjWvs7HOdzsW1C0UDPUUaoZBWoOX9MC6mQG5BeYM/jOn/5x2g+vAHAEsELRM7sahOlszNKwBpSVKNkL16s4vdZRH+VBbRvhiilsFekfO9ZLGLqgxP+DJCtSScXb4FyYknDroJPbMrmXBySZCjw6UhygygPyqwqhlkuEjk7IJLqP3qiNUpKX9AKntCz/T72Tf/MFX9K9bqMJseFcj8U/nL/Z7GkzH+D1Kg/M6lXoHrwC+EGbkiXn8HIkwQTV9PhgPN5bsVOUtJYkgPYmb7CAkdjrkFfzNGidR5rCfZNlBwGGzJcvfb5yte6MLbauSdO+AsQiencrWUaKcLAxOPv2ZqMGRY/Mr7NiiF/D7Q6khRpK8mClj82XVcIOVQjbPALij9FGyTZ6RCa8dEvOaarvo/81fPY1D+lVADWsvv0tCS8pvIekiax8GSqi9Zrl3p+1vJ+N8+hucKPpWKKMief422lghCm4s/GLbY7y5YXxp0eXZek4pX06maJMtOsEeGfkQ1j03NXdM+XFgFEn7M7pF78zhE4qf20Hc1K+w/FUTYFp/aJF5j5Q3NDE1bflGa9+SQ81AzOHEm700tirAwxG6BiCI9TzdW+7gRydzfol2Uni6CG3aZ6XysLR+1oAXbcluZRK/a8B8HunuLwb5jvLrOBM92tEFAVdNnoZyk+Ubc+dtDkP+R0BYlv4V5D8eWqWWYvM6mtWsOudF++KxGzEK4IXzCGVn7XJ4quGk4sGJjlZqbySAbKhkb6tc8cQwy6eqK/jZhLavczcIc6rcPqg8DctstHj9sbuLq+C/qVKbNwBYtIJeNGmLWLDU5ps8J/BTRwmtw6vkcRiXkmWkaWhSofi3VbUsLH3aaZlwK82ayW/mzz6xIRXFNXhfxa3hMcrSSvWwZomvYQkYPu9i3fpPSuy0pxMYzIsOpRm9uT5e1Swqoah4wKVLKDoUdXIoEV8aEGb3xr6eHhNBeKLyKGHu1ZzdueYkmyAJBRTnF53MLx9B97Ub79r2U0RtyKepMg8/LIaLFzQV8X9mHx7wFWVbsbzrvjFG2juorFbMDwhOMDI3+UORGSQWRALlvcGmOm+xDYlQSgPv/IZGvY0I3GFDnRBkN0CtB94gSXjRsezHTufXXLSFHhz/K/x1zw96gdg3fl1579XoccU6dbLh6QLP43/A5QneSkKAwaCbb5gOlBxFxAuRRgwH46anVV5c3Hzre9S7/ebAun6PqvZFPw6OnQlF19+bTUOYsdVPihGhqez9Xubk/2NqWybXDMQB1sggjY2u8s/I0E7fqDEeDC2vcXIFfLhsuyh+EWlvSaZSr7kvPd/wxYr04JKtGmuB6GNBrBdv+NkW365VNrDejEJyCJw5mNFnQ4iwRDr7vTAw9bB2JbYZh6UcqNAL4cWhWD5kDI/EeuUtgiclupKEYfSK+zKKNPaZQ7X1b7xpmGK3Tvo/bxFSxE9g5fM34rK7geWdsIWXM10hjSRPmTJe9mQnxwrdbV0tuaCPFpkbhiaFvwzX2FD6gXcmxPQO3nVJ0MJRHvFfqhq1/218YwHelrd8MpfmMQBpmApMKFc2HqzCgB7qNYBzR0M4m7LsrnS7RrWpi2A04qidIdSsMwIhwq4ct4Uk2hHW784DZNlUEupY9H4pZqZ1xw0MQzmpYbwChyrc0kYJRzcclhL2xXErRKvaZ7x1fiZeWtSdKPadUmQlqliENAjaJM45d7rH2CsoGpR+pGyHBRUoI7jRSyOUSuXw14KRoJZrKpG77HFCT6tE9S5dCWbNoHzgKgKiqYmCvCb7OwNaBeKX3IPW97g6JKOa9SGQsXM/KmnOLix2kuZSelmDPRUdmSPnUxHGo1mwsq82vU5vw1FukiVeeYO1R7Z+1h+apeXO++Vx/Ms8ZHE5xrOIFcygR5KUz0yA0d1gl0hEvP4aetl5BHkq9LSvoXoM72IXg4KmjCqIkJdOkRkKnMcQFM8KdHVwWeuCsM5DOTkN8O52oK35XzCaPkOfjSjVFR/NT0vkukmuLkKhWbTwyGt7pqQHHf0UQg3iGzCKAlbO88rnGoowBqEf4XrWFydaaWWE7vrSb/ahPnm5U8WhF+aQKjd3ev595zF3PdCR9QmfIyMk1YU+ba+TGcMp5xf+OtyCiVsEb3ft/9uBelTaMb+jAZLrgMOjZGhXtieb43RndAGdaCmMuO+DRGSqXM6NN2P70JE5mgixWNYI58QDboDlQOQw3PMwHDGO1ClsFfTdEiqJsqylTICfaezfRt66k8ak5KiHc9Njz4c2OsYvkJWHMTgmtG/nZVZS/j/Zv4uQgpHoFQyjxdS+H/idDjtB4q2SRwwXEFTdEtvrSUCu81vbitFRes9CcKYSfLUS4OaUe+pS6IaYBYWnlBLLYuuIndOOZfJWMNz2ApLiTDOSaI49kfRfucQpK8acLSLOI9GJuyuafFQuHujG5vtx75IFRy/1lwhaziVLhT3LHzEaHPtvi3qxSZOv913OkougXVCTvS+5aOpCeQxClzxHUq0UzeDEFRakguuwzabSGbE71vZZA2tIpIVEnLw1fqRx0HlnZZLwVuZAZoNFAa/qxjZzs0p9Q6W2XMxIHpfSlzaOuyLC0pidrlHaOPdltyFMSP69I0L4o296OFq39LD1F5NDool8XTFDUt6w7JofA9K3L9wfD+uZVqgY3AQU6uV636/rrNSXeqayZv7le8NKT2mEMQ+NsNgVp2y5PMO5iTfuekuf8Xd0DmX5I9DVyfaBljh6uo3XuFforopvqmsF/PrQrRLpRoTTxhHVkbzeLJqabp1R2HH8ALj44LiLSiLW79zfkidmhm848/t7KMAtsrlyWzub4Ze0iOw17Xq6GOcKtqFvIp35vJEYAvXHnbqio0K3aAFUzj2a74IIhyeChDL5PNmZYHkZXxVg0uGcr/FF7+PZWVYL0lui7xTITYvyowkT1dRLm31z/35bsa7Z4asGFmHlsfEXTjdJiJdh/2DgApNf9dO8DTRr5H+cGvRkU48WgJwNmaxt3HljAkdQeK6yY7UxxrzrLZXI50Q7XHzYTBfhwrlKsbtCwZFM29NAVgOK0PnR0Udo7I41Oxi13VYray7adcJ7gZF9A2KtTWb9DGYkUvKfSTCY+mXbpLjRN1UxKIX97L4hgYQjYskrENd2wbo/su1/0fWZuSenkRFL5JawJ773lkQsipMxggTKdmlBuG4kbo9sN6kjJsQyclCm97pBsIjWnn7npwFsM8+V0JVsvm6gmHhXjYQBUZLeTHTfl9gvcsvS2FHdVCtnWSWxp4Q5BiPqnj0kkFVLfmTvv/WXB4dkpobYZNJGr7BjhxemzlRycNCWFY8IwcKzheIB0EmRmwaQ5CydOKWo+pHEEUwIi8ptJXnOAR0H8yzDNGidkUhK70neODXGwIarrCDH/rakDYFTKjtAF2ttc7xxKOpLKrSSDaS5wZCcJvFdzSz16h1jQyfCszzR9Ug3olp+7ZrWUXVJBkeEVFX6KDc6vmm5AlJSkjsec6D1CxWxYNwwGl7Me9yJIltFoujc5aWVuM7CddLMjcL3NKPhE6D5Q3Gm4Fv14hgAHgDOngwPmtH68er2Z8ZHrKPlKx5GyHwQU51m9TdhSjuKZm2yNBXdof4+3GtSs9b72v6e+mcQWYh2jP9uJu1pLqGxO7O4dxsbUPd/40piyggK97Ogoaocva7REy9SZ2UCEGc4MJceZqGTmbaHVeSMg/FhVsjog42LexT9OQ3P41GYfu88dzkPRXpLAatHapSGZ/ftfTPbFKUAmxkV+NnyEpiFJJFgFwxGJ529k45oTYNIYlOdgUQda2xVroTaClGVN/vWC4WcIYL+JIUEtWL7T4mZMcdYHQ8FutpjprH/7J7acR8MDsUZB9AY8ykkU4PIrgzlYxYH/26vwbL6aSyhganF2zu5WkkJFYfW3nCP918HccT4dzkq1P9+ZwmdFT/55Qqr6vuUNtERvA5Tnj0vejtxPdlCDRso2rJsHKZDtwxgcaobV5wJPusUDjKp21i2P+qGTjzQ7ezRZvg+R3kYxQN3kh0AzZMWCoBhJzNV8ujYXi5BgjGmQu4sc3lPjTwkJA5bT65wYmv4uALL96a2bjPWPuj1VhLCPvQkn+LnCNY82CU7flPIlcIYojTAs1UFwg9yRT2SXVZRyIdcrcBjBmVjJCTqh1boSppz/N5wmSocCrVSBNOh6oWN7Y+Lto7RuxEagmFCiwdcqmbPKoorMrx+jZ8Rr1ynR1dLGniLLnu1q3ixFQIienpV7hKBIarxNKai2OyhX4mY+sMC/Z8ucXoIEN7YD/Q5Ue2vySlH9EUkIIRi1Lv3+lM4xHvUdbI8xzTMtXsYKQgwUXoa2aSTWMpPVnh91a0RQIbixPt9uVV3nAZry9L0vckUY3LWNweKIeH2leUj0QB6GWM+tV5/NMmrrN2l8B5g7LJo65FQFDwfVctDSxUX9Frgmcln0P8etRhUxUT/5RU2QaRQm0IwmCqASvdr+LSjOA9joD2aqzdBhggZBDBrZlNjf9wOUKXiTbGFInrZO8icDqd5Ev/7GQnxHyMDO+QWwT1WduGKdZFbt1XvVsuXgtJt3dGRgfCxSHe9eORHy6tTdvG6iPkYmHye8HUcvmRBpwEXefu5TkXIoQN6m3O7vAC27nb8r7eGhkn6DhSzLAVAvS9KpTjQOEzr0obvsVSTGJ8xzCMQs7Wj+S4qDwqHyuTfBBRjLlzURgRDhN1MoPR8Jn8iEQcsWqi/KXRWm1M6Fw0igv4iOXtKw7pIjWVkPSkcMp2HG4T778nNagI6Clpz08dK8jWNvVgsHJdbOwaMUaMCRc7Um/g38Zb8xv7lk0RkspvHILaX4J+5H+w8p2QRE1a3DThtqkMbHL0wQTjp7XoTFCb/gkkAXALFqxcVYQVUqw2fQWPpVwz4i+yNQ7AiM0jENOzbpAd4AWokDsj5TVsiykBt3uqboljehBVkGYrAfcT/3lclIV56zdbWBUaagj/fjfLxUTBMZ3PXGqM9Up5DqSVj2vSiyDOzmAAEQiJ4sKccqNp7QgrMMIcPLvVpZDRxlmK33nL4p5iUbyrd2FRh4Vh4EeZT9BThd418hAtRIlzpV+eJ+/UfdESxTJH5BkgJLGUKZM0iepLC5JZfsEmjfT14TTpZDVZJozFD07uHPgLY5Wekuail9q8W3t+095DBZDLdIMgj1/24ZJitRk5vR87wlJef2MmlzLqgXdTcOvzVqnGoqmM1DDiAfR8TH+m2XGMQhR9u8zROFjm4ccWlBL9aubrQX1hDZszr0cNv4C9xzCvuVom/yLc7UydpQrwb51Om7sxeNTa8DXT9MnHWEbqtSRf4cIe7N/hhxekVQiGvVCLl4iLZxNCBEfSK1ywN5D1dMZW7+KqflMWTgbUOgyZWQstm9WarqyGZLd7SSLYCj9Mllc2Bmy+Wl9VqkbZeVln0+zfwpCvzqKsW0RkLEjkqh/ne/OuMVLNcl1druu+0G3RSEiLnfnGdEkf1Z2LajZIbqtor30skEPngsqtdRrkqyVJWCQ/CNlfcqdNYs5bxXUOS6teMBL20vQAZ58U++ODZZ60qa3Ohs0i66gHrfNFOtdrbmr/DVWwoC7gzFZdbcKNKuNYDof9qC38kJ7Bd8gEEX5EhQMiy8E62ZEmRXcnVGs1SHUtw3GyItzoYAwuVQg1pVf4KWq3RkFAEcIZJaXUWx+rpd5AW95ge6qQJxEUw9lrCg1zY/tRG4nWouhx/xm9zVzJE/5dKZk9+5rmCWN+p+mkOVUGI5z8Jug7v1Q+gmKxDo2IJ6wqL23ozzIGWcooJCHKg/ag4ldjenApGVMB4mDVLZTDDwg13+Jhm3p0hcQ77a/slOIyWlwjIV92Z3IG2uRvJ9M+C2QvROqL85JtkNiNjnuSXJKwb4O2Mjx6K6Jp5CUaxZ83zk3x/0o5DQmim6DN8afL8cZWcIvUY60MvDEvNrgNhM5DL23SdyX7mrDWT/2BZbMVBgyvWEWdeUMn1oxJXVpksmSDunBRDJU11sCUWJ/EV1g93CSdL3eSApsv+RPuRFc/Suoxln3VxGiaPN0lMwRccWG8lrW3viNb439E9Jq44yXa5YfhpeP8lxKt2ydXEZjx/VtLOnuMSPbClC70C60EES1zRr0skYvT9tm2jfLlFgJTZ4WVRbRTzensVPEm0LcsrsIWV8U0sAtSJaMzcY4KVP0yv1fxb/5GbLm6bpQyiCbBpL3ojaLcgIhc6f1P1zKswBt4TnBz17BOWjdBl/V+rN/EodCO5PXwi/zpswtvYPlfBrmiuJyLVs8YTdLiK46ES3FhtS6ThFwudAslz9SEJ/wN8+/yiQS1p7YERVGxBclUNOq9iC9BVSknPcaDOpmasxPu/5G3dU05LmhNdWmFHqVVmoV4HMR5Sc7AVFXBNIId0E8svKw4HcHeK1tAgPmnXz6M2lDXbYleWKl+4cOhWTkzX1I5n2ZxVzbOIyHa3gZmBb8+3iHXabCG5nEEC1WmNQlht7hl0q7O+0dg+0FT+oDgRdcOKajLx5FCBFCd2eGULmGLYlYsKzk/UZPsSND7IY4+UCA8f4pWqF2dihFbDEdn08F7U1KI2iu+4CTrisDTrmxCkRHtYPHGq1z3BRdhspFgbege0CpP0u6+Hs2N3QBdUEbSShOP9uQlEWKgkfoxrCZsjFVt4uPGuTaJsiScnmuJMUFy2Ckt4s3fWDcLZVqw2E8qb9RlOJRVzAydvEAjWn1TrkLV4/pVzl0w9nhhmbmvFClHA2HgqcojOm+7CzCcfsDu/vS9s9rOZePCJA2A6eAD4E5eLkF9fCMhwllU9aoxvXOlYhV8Cy283SqEA6J5iv3g5iQEuAKbmfSvFdIVX/RcUzs/RSmgyqqpgZTRtl304OigRsUXqSFiQWAC24aQRKiR50Zz9GZANmPgryBZb1/W5cLzdnmpndp65kyq6C8/kARfZjBIYuzL4bQz8Rv0mpgY6TXbVtH2RZvZ1g9IcXjoXy7UEnR10Kn6T/Ka6EqBWL/cOPPF140Y8KTheEuSYL4aqxfg503XotaA83ZgEi67Isj0CEgdPDBQo573oifc3j4w6PwXR+HWBw7ytBmEPIhMhwcpnHnsNNIZ+9KxMqvlwiRHcCCCIwxijXoSF/cStUajieBp/ITSpr7XrRZ/cdgE+avTVJfm1ynBd645l8LhESDV1EapiQHTw6WCalYrF82XVXlPKKLeOT7aZd7raUnpDmEXllmhThrZCAH/cfCsgNOVrPwS0lgpeA6BtQCC7iFQvy96AyHItP0ZkdIuGcFccQWqKUZH2zZG+cOzRdCponosBQCtCNDYoi+Z0OLN+E03Hz23ffjdOePYmivzNTNaPS/qS58i1eGRTDQic0kbo5VSbApK7RWjH5nL/I7d3eUUnGgUkCzdOez8fPP1QpVr0Vxs1hqRdniamKSedhdqWJaJvZVYeDeUE04IsjEODlcAlomUtSh+zUWrbbi40u5fp0WqSZCmFlcESrbcIfhpljfRxCpftpz4K+ly/KKLQQ0Hgq6qyVt3c0XCLzQYKRxQTr5X0N4LUIHqC67tla2McBHywCGhpoDEhH/HT/LwMhSGyz07WucpppJmfyM8KlXSc3a7pS2AgwLQZfAtnF/wm7vPSQtuKRvjGc2qSoXMtVSMLeRQyj1YhcMmQKT6TxOgLB4sqvK2dY6xuuwTHHetrzfXxsjn57Ep1AWk0oLBLqIRpDqgz4TGdKjNdR0VrgAtz/x5It41jLYwiRziGFO5XA928JenyB9bJ5f1X436imtZU8AC38OoSKBGy1zX1SaHz8hulWtIR+I4wQ/5qxyRQkrsnvknNBsEE9OD6skqTVPYDnvWM+b1t678aLxPVZwRHgLHRl05aLKMF9fCFtN+wgqdPGHcW+0XINGYO6yjDqPwqTZEJ7X77zlAsdfyvdGxn++ARsq/KV4zaOtIuJqMDYg5CpT4ascsmzxm0r3hPjY2uLweohm3cGbWuYaQyukMxtmjt6jo6pH+FA5pbiAoB/nk8NO0uAxh072avhD3t/Zuin3NiN2EeRvgtDziiRgRYitGTxI7fTlcg5y3PedTGEbbsKLx24VhSFOyOX8BbfWe1BoQqHepfbVKQzCyFuNLiY4WvaPQeFciGMFKFxQ2lSAwrPrguOtdCLjB3ivHNxXeoXYOy0Zq9qpGi7MJppjk+Bp5vR4rBBK4Vow7OQU6gQB+/7i65pseZTxa9C16vWYQVnPZDuoPXAFaTgqv5xvThhjTURhcnZYnBXlrBzIn0a9IeuXHhtE2O29BhtFDPrvmNoxYVUOlek6BL79ow7NdDKdFFtj2u5BpRtGrhKpMdX+qht/9SzRHJXZv6+UJBaTC8MSZGmwzDa9H1rhnO8hNORWnWSwcpuHvPSAHYsIv+Vr3yjApzp3IdzKd66fTImN/bqgna0NCNZ9lXkBYdSGtknzDtNmATavTIkryhAVfeVYSuBv/nd2EaAQSW97Bnq1ebhzCi3gUY35Mgq+wyvR/WeRpZRngkttVC2g6zKVcekONqsRJXviGptU7fMebXv8O1l9yApqiR3iUSXICj2ZIOxPVTkYpCCaVKrghcH1g+ypQ5sTjcre1YGPqc/hCloagFJJxY7opO80hRY4INMnUR0UDYeqRBExCJie2N6AetTbUutg0aKlCd5+WD+nMdOJXseKkV2A/OlMCCwQ/QBPq0rPK2G+/ZxcYe1FAkxRnbt8NkER5LYfJaTLoh1ThLvYkrXmzRziI9ON6/yPBT/smLidBTlVAV6V/uQbGX2xAolIoUZkxME3sx5K8m82MotmMy12I5wumascC0jHnHpnKkrsdYXiwfFGePe8dnAmQdqxbbIU7BZkfnIscBZ5jF5a1N2eXOm15PKn9wLlp+BfzkbHTDwxcR5zY0tRRU2f4ji7nv10DrHdmZCMUjECpdqEc6obd+adhvPhCRVs0cOEeruWzvVKvyWH0g6g2mst4bTBOTGqIuKGlUoQ68fAV8byOPxPLwMqgiCPEoxUGSODJgxiFrP5ZAMjBRZ58koORVCE45GXXpP+xF/q+8MD3TRIAunWrRY/ZgE6PHOXkpN7a6K4ELemdEE/Mw1g4U6GBWISla8N0q2LGe1RNAT0YfDJMZQoTCD5r5YVZ7abBr5a3L1NtmscSGnwSFm5G2XeKAH8puQ8foJADaYYIdGruITkmn1LRpDUatKKGOUAz1ZwurHPNO3h/c8F3u8FgtuVBddi320ePpK/MMlmu9bz6p0ttR2RH15YPpt/m8dVL8CFcvZSm7qgy5tyY0k0hY5lIge18rEpWxmAEGH0Gv7LJPSuuhNXZn+KT83b4Uxhp8/pGsfehZ/O+c4Fxy9WxTp9Yvfnx8ydzHHA6OPLc53swZCpTkvr9M1lCD0Z6BRcWyrIv5e/MdZK4mA2MLe/5JtlvFDDOQZF49A2K/hsQPSIFPaBaUtBEXAXgrDiWFCcIKpZC3NYC3h0/78MDtKvcYTKRQRWWVBSRGqgLiuF2b6ETRA+/w2BqJ5hwYyKqCR2iq7l7flozyZIK4p6VQQN3Qxr3f4Hi2xf7tYbMk68MeZTRwEIUAcu5tM9hoF3xrsunJVmkxcUqJse8Aj/Mw5e/rw5n88kbaQ+GA8PIajSSDk/ezG+0l3kD718XJ051XMuY06NRnC0VnyMwWxwZyVqz5iZ+uhFseSM7qIgNvI3yZnL9mmy47RRGyp07kOtbNNxGec5HZPJ59sBoQTsVIj2Exr0k5vadTc1TanJNWwjWGtGCooAVDg3TjAHgqR2yfhlH1PrdeVLfA3zFIWknDgNwH22u32a8yRP/+lVhRvcI+AH/m0IpeH8NJzFplwdzelEoZxsdXOueOjQ0Va6ABs6EzeqYt+db5C5mPmdWXWz0rWNzDdd/tChlqNZnTlu8FNsWPxL2jm84FP69ygOopgH+akgrfyYM6wt2SfHVaShTjljGsKsKlRxraVIUSIdO5deFHAFFbcGoT4siKZHn9pO30kqwjE2Zi47EWYW+8KpTSyvPy3F8tOQ7Y/FPredyzDg4dCSm/DhSWDlII7//8H7OyLxzzKyUulSlg6Ax/j4tooVHsa13djIaCZXRxoBmlnWbWFAU0F5jLHuUIY1DqwzrXMiHUTWMWVADPDqdCfN77Q+Xb4zCLQzqQJmENZHjZ9NCibMW+7z+h5NUWD0CuCUpURrggVUBxCCmtC2kJ8uYjGVmjh1O8J0oWkOH3eTSZYTJXU48fR2KoGO9MgQd1YePQST5xQo4c+kxxEgtJ0RvHxAe7kGWVd5+JRuWswGeCcDnHqJbkmC7O3grXM6VjHkpyYR27cCrhnVyQs+SieqcYyYlbMRN4Us4p8V11ulTZ1AHMit/ickrNgdWevROtrE3RLapeTlcwigOLZPWUItIM+GUmm2MF7863aMBgopTBQ8MI15W8jsM3lh+h42mJd+V0OF3w6IvSkKBhUtLkkv48Ot2+eV4MI5YjRBIwajfeKmeggQrpd4kCc7AiULxsuFkBl+pZNd1gbP+B0ckNtcnsFQqFdO+AKCkTuf4teDd1B7+5obKp4JeHy6MIvFr9r8UW8QL/AsJHFV48Wpu6jWxpz3WsOp7D5Ab7HuHsacHfc/B8SdkuDH4pMbhDI90nsI5yq4Zo9CAEWjFpe/t7N/ZugEJ5lTCYLf5lSNWBQikK68hsY+gErBifor5W22NaH6FA0bJD7iaY2MeDj9y2KcFDINEmwKL+sg1D+zbohkNyo9gVRd/TVBXi1BUMP3OJYAIjGBJT/imo35aD1Hu4nET5CJ3uxBoB5DwbvjcR3N2y03gOOy64WJ67qmz8ZjiPmYrb4p5Yd6hC7/7DXvOGzoN3NQ/z84HJ42RusSl2WNJIzvkSHi+IALRnP84UeKUSJT548xuie0CjOQpAVHyNmO84a2OFLJ3tbRncXLbSDBdrcMteyyywGolKODvRQeguU0+hYVhvteIeL9bJkD0Tap+ci9G+wf0CLN86CjIH+9s1x/oaN01dQ3t7G5fO+PlgRubXerd5gVSh9hjGRUJTPFTBQQ6VctomJBjIyJXQS5x1uHWVFvRFRSApVHzAhMX1HmebUayWwQaML+7QVKTY0984P6B5Eh0hzjP6+Q5GnOgT6AUfuCG/UEmBmiAxksoQYfMStoYqFMljtB9cj9j/kiwqgyAO0esvFh7vROUUbZB2TU5d30AskxL+CGR+KG0eFA2q/poYe+mdnjjcGqg+jaG108uadfxRwIRC8vStmygg/P1uHI7M5ebb/ollQHX8/aVlNjzBEkJXrqByACmkxhpD48jM2FmYNMLE6QF5y78cVNvGYGVDJk6aoJFhR3Zrd/HP12l7+qyVLMeywT1f/KrNGvJHfi73WuPQCoYr7jEDuveXmQRlvQbwhW8APdHaiQKvLUdbiJ9c7NGP5030gq5i6/VE6aEQCrET3FmRQFQb5+Td6meH2eRSRPyfLNDAOHNFglkbtUzLZ0SAZEuHfhPPtWb9GrN9/1PKdfy0MNCg1mF6RNuIzpQaykltqfrXaCkO/rf/WOEUX+D35SZrgwMxsgjnQt+EZTR2faLQJ9919/tczSoS972TFgth3KYg8BlNbrStfPciZywlSBhrO2V3/BiGAVMhQ07VjOhf3Gjnxrd0ZK8ZVYK6ZbAZ9JIfKkk6xD3lo6vy5TdNbYtxJAUTMimFZYEnrxB8G4/bvz7LSNnpaTPuu2QSOoZqLX1OOLkgtLL43ILTcLJ68RQExyt3XiCv5cjCOYPnKncaN8EQRf2BX0BYqLVakW70wcLmlUGLsw2ijXIJS/f0ycjQTRKlZfoFSHIESdJyfOgMA9cftdFjOB2aaF5oPxI1kAz+SFM0081RgZGHfOKO6dq5M5xvEVaHtokG0syrWrKOqC7JdB+LsxXZ3+57n983cvfiIeNYghs+k0k7b0hTZGStkdOC/bbGFcRRjiRwbIgMcSd0VqSTp2pCgMsxm8sZev/Hke0+CCPV6dPSGkDKXvdWiWIP7dzo6q5u4lKxvJvXcXLs9gKxXLubJR3zRRjGWmpJXSiUis91a7XQzs4TI6Er4lXbPvZAwT6ZEOKVN+W2FSxPzKdRCmhB/QSGk6HbYu4LxIA9uZP8ABCjnbnkuj0HWVb+++97t90qPchqppchDzmJsEeP95OCYUc7OGCMOQxg8D/cSuQGfvTbs7IdEy/Z2pzQEVF88w92Sq1UJVIospnJTxknRDUujB5MOeieOuT5fE6699OD/AZ6SX4Kh+82X7xIjd2ELOxLi4T6UFA6wecpxDwaheZdyL90869GuvS8MLH+zXAtZSayp1R2PtgR4UmLRZ+3XCv1w2tFcH02WGuBXH6mnCECiHBi3tRZ0COe88gYnJOCuBvZ5gW3xSRtzrO+/2LSbjT5GZrmPLonl+OULwhCP2saxtCHozpSbni/oqXGp/Sst500rd60sZpUBvFj7bOJQ/wRll7Q0AARhQ4CoqLzl3ZnHS7xSCi+FTjZolvgyvdpD1XYX/U5dvxMfsT51nnLU1FfWYg+emuwvWXmpk/DZSxUG+MbFz2uphpiFTH6aftT6xbB1rxk9IbgOapeXQtmZWebdoAVrbaygYoEJF1f8IBNRaT1kiTH3v68JrLMvn3LW7/tWaJ4IoMgJHEXIcxjv8RPTrb/ZLbwIa6HgHytZqCKMATRyfJwLk+uSkMFjIc5xZxFyYwbGq7q+EshcLu3XiyUVWzilT3TmAkvdeXIo5Ld5biCBBbV+uU4GtqYzmIx8Rz+/N/4ZZhSsf+uOusN++cQGY4WaEMnhPPC4vu7Zldq8R2SCgPthaBRSiIxuQ+8RF+pSVbEo/iRVm9SG/91hSf6Ew0Xy/hcuWp0+971Upep7AWJ3v9skdU3wXjOE8UTbFxvxs8bAZQde9FKc5Ofxxo4R0KeCy7i/1w8jP1rs58RYx2pY2GI7sxK3wAv00NKm5QD5VV0RAy4Wdz35LU53ILdwmp4xHUUwWEArmtMa5DZ00UxAK4F+5Ryww5YwXUfUy6BWaRQgW1kvkYcgBbrc0WtHcAcluRWgnq9NMRgWTJl0GF2wDGv9hhJpfFAoWEA2Xj7It+BA1HCO5Yr4GCk7nU4s/eFParrE1REbXtTRI5lxyfj2FXkOZ/dcOYFuv8ZGJEunZb0HJVW6bffFmZaD3EbNuKkum2JAceIYi8w/OhN9h+Ohn4i0ocpa+oqGabbXSDqblmaXK8V/uGHl7NDvyIEs8kfIK/uZOA25iivshJFuRvLyefKPQ1XUwVkF425xMhlPK3wvpnhcMvzHgDZstjyRpowAjHePQlevMfhIdNGklx795WxDLDVwgc6KyHIF0lT9RAv168lUac816rVmIrVUWdjtMG9eMvaHvy8nFPTu+2miIVSwyKh+tlKfPEVuSg5bozZUCJvuA3kreG7oTe4YVw8FdhLB3pe1uSZne1lKjN70GMqA9/V16YleHhX9L7h3Tzumv4DgrLfddFiOB1aCNdlO+W4VSQCJAYe4KRFa0OTy+Np6HtUpzr2XvtxAKY056m1kt7zdNScupsHv/jdqJqQZ0Vi0OuacFgRhazaftywJz3SfONWCom/i+iGqSSvo5g6onfOA2MtZzj30JbzMzCgl7Q1031h95tD890KdT33wP1LVESGi1JAz5TqIfuc/nY4OMalVay4hqJMvFhsS3A1Gbk8xp4YEYiplZ8Um3qs2Hp73jy9Wk4rpgdVxev0ESdhTSKrdMtpzbRDNMQfRpTpN7h44Lk6pFaErCtP9q/z7/Dj0nrj2gyk9eomWGnopQOUJ/zTNZX3sRa+ocixx0bSXD5d6+kAyIeqQydqdHDZ6PJPvepakL0QlE3oyN01Arh4cP/N2kZp1TT9iGJIhTVZaTyhvnwgQjg/hKdXpG/GQt24CoLWhF7PNCVR0E8UwQ57jpyesV65Ey7Gw6VQ7nW+t55Uq2UVbDgcL3LuilKIZIQy1sEJ30wtMkTcqZCBIEcbSon3aQtXi/AGYeycOe8YmO+T8lJh1sGs8py9HKx2Te7Xx5qKxyzUpfENIJQDTIPzXxwMjF3GvaB2qgJYkHeImi2o+H+RCiz31VTkolpz3fNFG2AfOtNMYPHlT3R4Zt6Gx5opT1kazAU0uxF8wgffGpjJHo3YHz/9p9nbjQ0/ZLDdqqH+CbPKbievl7z3UD421ixhCmoY+yXG5k969ubpANkcvOcfSQKRfQ5VGlXTqwzwopvjsgllH2TnIti1IbFB/6qE9SuAmyLzn+wjuRZp4YZDtCWr+sFcSDAJxQE8F2XhbGEY8s1KVMP+LBXwjZR0gIyNDcehYFCWUxT8PY40zOWMBxjpYgDzLeTh4nP75pJoMvd4j7RL41K3iqn9JSdVRV4v9wgJqMymzOlvC0cil23+nfw9+c8SZD7hUJcGuqUBUux7BZvNQChzzOAGg6O0NW3siDVihM2mhfY39/KrDmCX2x6gW9b9ccrPwhBWNrYBIDrtLIO3NZAccJ7cpbo70EwCUM4JoMwAw9l2sb+Cv6HJc8VnvdWXQX5ijYThDSDXIqGGVb0hcZzJRQiyQwCKRScuh7EYszfP6gR9XcTHj/Oc8JOnn9jnmkq6Wlr7nwNppHs/DzN1z4awDxiitB62ubO4MOkqxetAwEnO3HdEdAiVRm+YFSyylOw9ff+8D8Srulzwjz8/EzlPTkPFH3UiF+l/J/mw5GntbtEE12NxsxhD881AhhJECsb5y0xCmoNw5mPL112tcqDslklJZE9YatzQoTo8I85dBfCr6HV/yqr19AMTn7ALvC97ITxMfOXT5O7XEGZmgtHKhmZr1rt71id4AuWzecwC0b8YW4+Qo6Z5LwHLalg5yXz2EQZQeZg5gBUiRuVgTau8J9uj8zscEHhnbTxv25FbXDXCyjZqm6iL+oF/afP58pkIf8HtPfAZsLnI57fOQRcRmqcDFswHDqZ4FVVWU1aq73pA57uymvoc84nlea0h9S3aZtuSqVuvA5JLAwtsMy3Ljd+tCQ2WnYbfosAu2noje61fqv4DR4DB/+FDslz+cV6u3IX+XXg/0CKJ1fPklL/+55Rtjs2X/xSj7CQ78UA4DqEAFMRc2v6kgzhHNPHcY7ZTESkrNT7qHcqdmRQnwsBL1N23lwFfMeGATJZvocM16vfyWOy86JA81113squW1tgd6v+1o+CqsMNlrvMKXUFlWmRhpgIGQFrrT6s8zwk12FFgQ4irg+OhjrE5RfPRc8I/3v6FXRwXPztvgc4jvvYeYAW2zLNR+KKKKlkLLuFPjkZwDMxDShH1rtkI7/LzadBUdk8Cbc9VZrea3aB35MQrA48bnoGCV6bIlgs/0jqk/qFs+IisxsfmPy9mcnc5UAHyDXHTHx2xEveQzJW5ZzesGiz62bqSNiXWeYyo2P5JOhfSInOZT64I2TZHkEPFA6/tNpjSo57l/RT8xU7uw9FQyzYPOSnsgkrkQoI0Gd1F+ZjVP9XJ11TBIQCh7O/sC4GKSESnNJlGEPr3I618R5/6KwPnUvCRPK7tREUaXOweiEZ6OijaVnXL0mRVgvOWgqJeJ2QwespbMvDoB0MnyMSPiOdzMYSeJ1rA8QdRDdNO5I1brBtFPDo51sqD684+MVx7eFP8KXAVwDeDTRG7gMp3jbLvE3buYj6+ok3nRIj90QpU0NSA6wW9KQszJH3kSvjI0xwhjwCM7DT0NSLZNpvnuHy9GXebDSOiAf87AkXxMLG1kNlJN3noxNUWQEFN5D+DxgZDDvHadpIUx3XrBAtTNWDcGFAgDqodE5SSHaaMWWGmY+zQ3j/k5XsDycK8GKQbhXTqGzofWHQDhK5ffnWzJTG7eVcIdsfXMFAdXunEivFkqkNK6FyLXvIlTl0YGX5eZppYgkcNB/PiCAtoSqqCj+1CBVdLnl9u2mRRm87ZPrJ8/IKy9Tdew1CuF/e1jvi3s1T0X+o5/UB/pyAdCsVB8S+vzH4zzdfHkeEMmpKfHfgwX6l0rRgp9xTlYHniorhADih5ZRtAFDcrQOTOeLgsjNgvAFROGETJxLx8jaIYMJGG4+tEaNJCHCZ31cg67rQcgKLuj+u6cX2ohicMjA9FGDyzGLk7GMc9NsRh9BbYZ9RgzX9la9TThI8JtJ1OtabNVN0Mewyl1/0A91ynkRLeTgeRwBcn7bk4fo/jcwgDEjaB2lBjwuEn/T+Yk4nhXEYsSww2mTyWy9t26q9ZtNP8bK1b8zECo8nP5mCLpb+7BmeZax7TzJiwgyrQ62S3vtRcIxO78vztDtfyHsOewMeOH1rkD4F7uFmmSKmSDcvdu3bpRP0HUnk5QDX/4WpLFyB1pmm/pGlhdwIJNubXBOZBWT3g4ZRTSBNkg5eglxrEqEFvFISlP+/7KF5Jmbz0dEYISyXsJRe3z7XSAu8EiQKsgrm41psOkdY905pT5u3Ywo9D1dEL9lHQY6c8cVEfd9QwODxMsMCAQUg8XsvZnCZK2S0Li5h7FHT3XjTww8S7VifdUpoI6PdUoFp9MTEwiB1U8E1DVUIq942c9CheDcwk0LAJoOWlOl/T+PWGAxnvak+LefnxbEyLtKUCKCZo+ICqD1l0U47UDOqlZVZhv0omuL0BsYnVai6F0culWGH2FmHYbBqL6nknVDphBWR50bJL1GUWEAIWi3wFwfgzykK/Dd8Pymks0m2xPnyj13qdymSD/XPLMZwjOFJMf4tZvURPPOwrFV9PBEIQldDUNvAxr3wf1LFv0olymanIFjvuPodY16+0deSkfuDWzMJsd3f27gWZmHZFcB759uGkR0WniJRZx/7YA1j1JC/P8gY5eyg7sUk9/6lUKhwiIO4ZVZCYF76GBN+6qLV7aLr9RPNSGkrCWOzyykzCL17ZDRQt2ZGQG1TrTnHlbJ5fREVBwIQczhRAI0eWrMjHmSKFR9tmeCptDptMXjkHgttciMYG8y3tLfgaRXgTpoPyv7pZuYgwl9FSQYiy9N1zr0qatrKl74B40l0Pr6PTPKm/R+y5RSs4i/hVYjS2vVI+XwTG+uC9BoVc6+gw1Y/OR4M+Tdz/3jw1R/4zjptofKDIFlG9B801KfQHRWU55acSgGuoy7JxBNyZ3WCXypVDvOQf+t2dmzkg84VKrM8MbRhAtfnOic9+DlR5NU2MBdeuOh4oG0FU4P/8KuGlgJaQXhh20KlE/4dpQVfuFIaFnnelbYsWT9mAnuQA2DPsWncQ365YVd9UZEPd3yqnA7BxJ/n2FsfALDavZGJT8bGSEGbmrux0ENTBj6uOyIi5ryL9RYeotH9EmWuQTtenDwEGFqq1n7cZAeB6qPyOamVonKYMJXoCaVg+G9XHEGQUy+8A6MwjaL4tpIRK9dLuMTI4coHCe/dTpHo1GZN2Zm3RQKO7LJGqA1KqcKRrsg5njKM7dk8KetOYGCydyFYNz5A2uUJwoTCNyT884hwp3lXhO+C8+gSQAJSHUByO3fO9Iu7QQHnvUHgaypzNwmG30sCopOIHkGTdvQWgvD3eDbIAEJBZNGkD2RkvJDx/1udlkZ6VmPLgnJYy4NxIfV6dK7ulkC8wZ6pEh+InfDI5qvV5vt2y58ohtG0UXP/uXglWRkgzoVY5Op9OJzpIWrZseeqhVtvzHgJQZXC3lmmoO26RYVyoXkhVi7nA47l2ZC42tkn5r7ZKSMaDP1bGDJBS2BxomrafHBPj8ykK0o9MIkzsDl7gyYqlTVdTTLGAXu5mD1JwKi8PZSfXYZ+vAyOW72pymQG6qIRuUDwhj/yxtbq5WZT/QObsNoILKmUvR4i6+v6fCyOabpre3XMAM11XX0CR4kJCUYJ1FfIRxGQfSJEJieNfcwAuZ0/H+2v/r2Xc7WdyVqexbgU7ZLq9QTkS79U9uLPCFVTViQpkawNHKtg2knQEpHQbPxhR+sHdMa2Wk/NS9Tk1cCb+aPWvDTBR+YytIdaz2/5p1867GGAirdOcukaI0r5/pQhn7epHx1JD8otA7PoZDfouuR4++efbE5PxOTL43HJeFlWDe02YmPFtio+Hksp1tFcmY6G+QrsoOwkXByivGjg278jWZjNHMSfaPDsnQeLCFfaPemuHfFex/x2G6TUXOhD/5P1tRCffvY98wRa4RktKUgBE/icqw1jC5gTTuGveUtQxZegdRoelVFt90dCUq7vSrE6TWyvA+UE1b4tccZPeexLW5PxiSMU3K/btnRHPDeLJ7oSr/vtkVpzzIbPmMDAmsBdHCdeXa+cB4ELS9lXbyF08HUAo2MSOEhTMAtHuaPNGhBy0zIyBlBC6BSbZgLp0KWVkWOiggAUp0/PGjFeh/E3BDGGCia5l9Zp1GlGEnFaqSQ0v0QfKKd1x6nJezUO536f+HVcEPv1pXfL6Qz+yMCr6q4PoE232VBAxoCbZ5QQcn03f0dP2Kb8oY46/qqS/Ze21QO/xttohp9WZfjN1mMiZojK8fgZnk3R1ln8eEJwmiPuwQ+zjpUQluAm+EhZzHZrXwmCtN8yaUhM8pgPB7RKlDycjnvHtbk3Bqh7yGNVu67b5IT4OJLLQ1DFc0dnc2mt2cl4X9C0fLX2lzd01+sSey8DrFFSevDeKlzteV6zKu61O+/T1sEN+TujEZf3c0MkmZL3mHhetrfpOn+BX97LJsA77uDgeNfqBpYEi4yQKxombPQkNIOpIOzY/7aD/+hDeE/zgmrBSyPAtqofKHDgyHxStgY95VXxWGPzeZnqUu3HV7GMLjLuQfEaRQEGNF4DLuyJ+Rpqdfe0SvdMaxUftkEemdTvcmnksfjzRcApzb1ZIvoPdlYf/Yo3Xzk5d1oyhicwkHFWT7P95AK5gJmj/+DoI7uSI1wk4oad2MO7EPyPhxrMbVxG1uVuBLRZ9hzty25IJw6mr7BbD7XnPZMznq1FQEaxTweLUarEgmxaPDhOwHFnH6BhHyiqWP5ds9DjgywnuD+Krbm5hWgdQ+5NayaORwe7lk2l7kJSyvtqvt5CYkS+J/kYbe9DEgXNIvSE6xyFOBIXaDkbE+2df37z+wFcqJ2fvp3HRMWjsy4bFfzZBGLRjyUJlbQnYVESrfdGDuMiOrutnNO2abdGuRRXGdxboAdYtbNpaWxapKAy4kVUvcgntBppEXsKYsz3ASb5G9SvVyunzf/LHakQxVS++iBCmn9i1IS8ISQW7xEXXPPr0Zl4i0FrGfqP5E/MjPLDEi12sNQS7OCpDEuZzt029KQaIPq8hr2Cwy6hgP/OGkI2pgsrk7r/h5lqxKvEfSPPc2eF5drSEywMapm6zujTUk8C9+3S38DUDeo2zT2J3O4eoP5NQeyZVSu3XMwpdeNLZErb1Il3wRRczkzDLD35zvbTw+MJ8cWQlwfHos6NAh/icWHgYRuq6tZQvtfh+MdqJIyzQt2YLsdhjBSwwA6z2stga7nt8d/7L4TsteZIjMKPGsVHsFFnywtnsSBXFmcUVNWkfvhiKF+Mr0dMjFgVKXDFkjfXPW0ujx5mlOsBlxtvWccTCax+gfXSbkDrXPW2mL455PruWSG6UKRmmDt/et1CzWh1DgedIaYM81oUQ/N/JYMclW+sBgCX+dgS2YPJuUT4p8VxQscLqUWbl3sZ1bct8TzCV1gIIRhnz5PAoNGKX9OkAgjAa8p/axTcDneJq4Tl/Z5k59xGT8ErATbQ7+uYzrzWZ8gZc4R0dqvdefpdtipaIrPqzzAQIVi3VYKvYBpxXXrQ+gdmuodMeUkOt5jvqEs3nDwYhrVcnpknoXfClmfmXwL0eBmCbbjw/uKttK9WLFmd2cYLV9c5FChl0wJvgBGnkTEH4X4KT46wCC+YNnx4KyeIDUIRK8U7HmVZ+D1JITlsqdEWH2Vh1NWd3V1OvjrnqghEkfZe1BYXwBAuqAmrmEug9gZNNevZ4xvQdqYFLPdRIekMGJZ2wYpVaKQySzt7Viwwk9do+4gnDhsoX2x+o18Mk3ox5WniePZQ8DGTRY3d018Fj7DJhR5Me3V2oDTu9Hh0cMM6XYQQQBK9QINmtEm45Osv7U4DfRTDVYo9v1QPyl+BJoMTrI4nmW2U4Ck+83sf4nvyiHOgbPAVDEC81mPxmFdIG2mzvsoY4jKOBtm7udyjC0PSxpKIUGlWucM+q509FcKrTQBYw1sXD2WwAnVHVZosYSVLnR3r5FtFkQFYFvzC3XN6iK9/OnbiH0P5yGWYz/kLyDDGp9KnBnOdScmsWylWA/CqsshQ5KtNDAc4e6VSku4FuLIzprJA7B8SpvkGUbvsFkh0zoh0Ns3IssoQ2jdxvD6Mm/iK/gCRQiStJXMx+N9pGrarvB9f3dTUvkh0Ld+Ny2xwJsMhY06ySOsuxMYTAT/4u432TFB7gGnvBy9LiOovB9I0oqy7wXECUY8p8OhETCQ/LXgg8rIMrNGQgFhe80Q5qMLJvkLWcJwF10q/vR1EvqIpJE99pUblSfq3wDLQzenxJOXPfNfcYaziZdszIFnbA+IaGT0XftR538i2CqgI25UgLC6vNNM3SsR8ylVKGbz+fsI76lRpOmyCgJUci9MHiq1Y2Ab2hWitvywwi8H+gGQA1pTAVn52nbxU+i/Od2Jshi4plqrxgkFxV4FXq4dlBPwTU0GZXuX+1giqcaDwE8lQTeSdHd67dD8NYXzfa4qfZ/6RPH4K2Fyei6vZ1gHTPwUVcYMObNZ1uMVxitxWL5lvHHKtwnfVSQS1OzO2UJfynXECRhyUPwS5wZx2zMLD+j0rgZ6ECbcAQxbrVsio+LnARmmttmKBmEmzi+pCmknTi/m9RZ302SeHpyvy8HzMaoonYqBel7IZyrUAZ22ftublPoTMdTL0QQvgHW7ZKgjQeVg3/hrNj2ckUSRrtT9ZXro4zL24Z/0C7ogNTg8zGXYv3TO/U392k0HK/MbSjHA9H8waIuvNU/FjCcLgzBxCdqlQP+UTB/fLxEEAEUMUKteOBHdqBx1KuTcBCQv5x8OmWqbh1e7dDJ5NXGN95qY+Syw221kXe7DubuUDJTTBg54sMlllqEkm9Pq9iwK9nfJ+ypPpXEnnnKAPv4DFSRILAV48oivO9rzWWtKOihSLSbi0DfgJxkJ5s5ZADEtfELdUpSU1LucaeEzUyJgT7hTHHz1xTrI0cMhRhDxHVWPGHG4EpkehCXAb6eDxUpDRZk7Nfm87WRl/KTKaYXS3dj6XA9m2J6mPtlR3idfy4E811JMqtUOIX51rXnojh3FnWIy7M02eBx8AHYj1NkwydRyMiG7yScy+YW38XCm0/B2uJkawQLm91ns/9zNTzRHTjX4gEFIAAlCsF1eOLQs5COqlivZTcszV5JfhbjiIS0HqE5Gck1jTgrL7Q985+gw8KLo+Wi9LEUE4aAB7/MjemVcDTA2WjHhsBzH04gznHAAxXdiKJaMv/xf9TsyGC8Ixv9efSGhJqtT6i9RjZh8usMsjsdCG47d95OWej2nHYpuiKmYUVJ0JfmD45Jq2CZMCWOhbDDf6oJV9G4Uq9719FsORTv5gbcXHMI5DuBquPz8hNokwpcMWu4bQryU3u2/YVnO7LhtpAdQMX/L0x6cRFVGbZeD9CPtsgDn4EhNh4m823tYAcs+k1ohQaSWRzarvzh1J5YWGxYqZwNyUyL3jS0PUGgB7aDe3R0+21+r66ySljhcIpH4ATC+dX3zR9AmPijnxEaQ4f/EiWWd8rtHmOqj3i40NFy0KXYu2zFUJnxej9b8gnQ0N6eAk2Cp8d3dmoDpOagUMRRnGIxRmXWLpj//1zmZYW00W1/RPmPRu4b1IiTvkzxFw/pPfap1jYiqp4UfwZvyLaFg/WN87RP8P/JYN27V42z8apk/5uj1ja8xogofyi2uCYq+VF45S6FIWYZSG7AP0ksgQjR1824V8nBYD7pmtuPVGzxdPe279uyVwq84xO3BXUWX4zlvgAAAUT3lYM8j2sArGAUOiRA/Da5n7c8+1/h5YLp8UV3cs3cq69fPKQVfW3x2w1cehAw8Y1WlEz/xI2QPDugImo5Y8rw/+JYa0562OG4aPgECM4SSnx499t+X4wextGHmkKLh6ExtuTcEG0V8PB7gaX1ZW8rWzSNmUxbQ2b/DuMNARh6BJYRbi/mYMbhEOAnMw9c1+Ly2fLJaSNCBAJDuMjFbySbhehwt1GMwh5wdYXuZT6ywQF3Mz5u9wW473S4nEYI5YanvVCGoW5og5DUZ4weJoDWqJ/pq/nHmEGBLwmooFndv6lxnr6N9Mugsk5drTvgxZbpm3nnZThZ8hyeoy7z0RCzDM5VYJXtZoZXedTdB7fDH/3sKJVgVestPMUh5y7puypLUNUo7x7MT0oCpeaIJmDrIIrkEvbH4C3CXBs4aGtgt8Zswlph6ncGwn6X6UTTlbqRvm81Ts4cgbK+pdT9NP+zn6fh5QmEMNzRrWWAJaZ4FYTx7sGjrPrp5X4cxMiYhwUo/ziyJjQukJu7WKz0bTwPEJYE+PvbhcBpjlqOy50rhTwFYEhIuLFAvh8CatP1huCInrM7TpCch53u5a7Wkacsy0s3YHVJZDpi1w84og40t85etHu6TUYyFIXbmuX29nVz4klL/uWlgeTVC1Gvmi/0QJRblHUV0wXcp8CjKfVLWLop3gZKwZesyX+/+Pgmqoo393ZWfNAcoUbifFWqOyqvwxNQIWeUsYX79WWl19j3Oq4gZ1OK8LzEDzPTZOqLbP0sr4hGXQIK8xY/ezeTEBVidLVsPNxIXTOEtHHKbG/MAIZatwSrb1KH1VSOS6yP5dFSJi9DSW2R+0buBxfTWxWJ8FKlVBC4mihjR1nSzVJ2vqvt9C01Yk26U/C1xKfERCbRSIRrfvAjnCh72tylyoj6cr2F9g7Vbb48YBUXE0Txdf6uoNZB+tKVPyD3vrx7AWxIJrYmP5ll7CqkpSceNmtWBJHbYKhhx8RMXOUXUdAPq3RXGy4LpaW8oB5nvNhX4GIcouKTQScMtKqP9KpxqD91XPzmctg0IYY8+TN1uQSLLE5okaoH918wwEb71SnNBV9P6WxNPTHq8n6mgeeuklv+ojIq+CKp/mlKRtCTS+a0TU9i5ihb6eZhDLC5iTOT8RVHY3CR7aQA9L1Y7vMaWRZG/GyTADmvuc3Og4Vulcvxqf+LULn2X7Ot7xzElIt0FS9OGK3pgjTHfu3rUKhQygfIVshC9I5gf19L7A4j8GvyzYeSpnAG1kARLBWoN3r3aOSEYJjDpfnx+NeNHm6xu7H3sqTXomHAQHaYRASW58b1+JZPZjDxVI9DUQTJiJJjgdj4wEPrSeHl9UizXV9Jnd8BxD2MWEQTXSVW+jt+O9nGSfihcwMmZPcw8GpB5eLaK7sVRxahM8YIyJB6v4pKavnZFJeGvWlD+8e+hehJ2V3+gh4moqzHJQ57/khMTsq39Ley89+8vsL3XXWk2XkqkRIh3cCAFqgq3jrbwScGNhiS1AwCeyohKbWVFy1segRqJ4oBWlaX7bkDwxK4Rq73d4+yV7WWsNKk/uwCZm3qPvBGGxQMCavguGKFcZTjlUfVX+SxFNTo2GTPxQ3xqfgE/bqxQGbZ4UT8Gx246IsDT/hT9CnGlMHQZN2DNVK9WQtdTQSkY0viCpPdpJlTOpyS5Stt4cKtpCTBMlqL0BCPp2zRc/pkDtwCy9vXYY0PdXZUtt9ex1E53kTYkMbPbLtO54qwRcKet5NC05R0an6rsgrXxe9pHrmYNhWRT1rmO6axP/Vxgd4k24+DvPwqTQ75AsxDxZ/k+FnHXwMb4sptH2Irg4O/Y2XqA71oNTuy3zWTvi61msZbsmoqx9Fc3kPEDP3GO9UK2GVwjtVC3+bTCUCM7EOWEjp9bnHF5Md/5vjFckn2LSWDKK5D1newiRm61lU3KmM+5EVpCH/HUSbn4PnjfClot2zNFZb9w+TuKBrDx5Z/1n6iSFd13vf8ybo+l63hrbAeZEqh8bS44+aeymtS/ls7h3SncESq9WkPZlgct6UJU7qwsJWiY4hEVUa0lMTEDbrNFE3kOcm0yAv3Qz4P5Sw+RO1VuR53L2GNDK3BLQVLmQzsWSlD+AOyyGhRzra/d9STsPpAgf/UJHjGjU2PxQDYBYiRSrtNFzInuQ2L2punVyGaRfTqQA9dEpQ2YmzAmqXuyn69GZm4Z/qFF0uhlY4p5MZix6+V5YsCrhAOt9bq/uKPfX96kkQAJQ/uzsIzYxzYrHirpFjoEZIOJKEnIUCcxMppbMZKfQPIEqmWALxEYyERT0+JTthwDbqPUoQXB/xIzIlhDJqwlZtz1OjBGQw39UfIvkvayL6HKbNRq4hJC8qLVufznuALpvbG5wnoWepPbDpGlG0sFI2xec8t5xW/yioGtHtUd/iDUE/dbR8T9Nz9DD0DkW/PDig9gSFvT+ayx6H+pgR0MhxdkCpGQENQ3/WNuCqLJzj3jz1odIkxQFmqRhnL9TRTVjEOT136AIuAGtffawJ5eSE1wSWihyQ2ReWLCvy1JbjwHoNLE/d0L4sNjqiNSzK8NDTxVX3zChjkVbReU0/YJps45kvkQ6PbO7LMf8cq1qqknXKrUAW/G4s7ClSEHUb4PmdbFADjge6QVejTqxtmpnAgl7caJozclfp2gOXkAp9Rm4FYz2qx3/PphtFnkWUv52sGrOUZ7e+ZxHU+oy0wYFpe+e+/7T7WwnSS1vmIl7SwJNbF6Nx6pjNQ0Uca2geWWFN+E8K1o2dxgt5jdrvgoFboUsWZvfAXp6pj4Qh/WVtdVg9qiGvzDO4zg1SE7vtEVRmypqvxAUBQpa1z6SDmu6gZ3tF6UxxEmXwD464U6wyN8NpAp9R9epSC+MDHQhWB04DQKJ/p2FnxXIqjhUUBvjABHW1d7vr4DxTsRyc77MLH1x+X0vAKduRxXtIPf4/ig/BfGrIVYjlwkTLT3bNDnJw/myLTeUIMVwNXuj3+qN+XpuMkuII5bvwyeeNRb6SRtHeW2gTkGINtoXD9+K/Rt4kVa5SOIycgw0TlgugsWYpzs8PvXpYTrELGEYxF6heX0ayrvvKHv7izI+zHSgTLQcgNbIXra524FcUKXQS+hqyWcSv4wgIVP08xd23ZOtoneDCWJg9b8LDRT8P/uWd8FfSFLUXwIJBg99FBI+Swy0heLKPjWEqjLiMq6ohz7ztfB444RDEeFxEcRsP4OEUogDSW5Azi+G3+BQ7AGhdwi7HJG/lS5dWpYwPE8Tu1BUjyUN8vnIE+fv5yp17hEMe8V9iBTKrvthkhP4ZQcXOjrp7lJQv/YDO1KYWV9ier4KN3VWIgZ+ifZKerbLX4ah+dtO9YHiMGF1zcknUoaV9SjZFemQ7bUaU1dv8qkJmVBwnI/hFi3f4/5UqBpOIKSPYDa5G4NWkCFAbK3ZGwbp5qukuG2yQdlbQtyyZbL2i5V2ITh6vtZ4qjYZVcIoIdQQ/rsJOC1xtp6sPU5/6zcfHijOjSlzyvSsJwvmsS+YjGpHvP9ZfBcAGZYR8zP30G4osQLA7n9FhsXRs0JwY4Wh7/MNnZcOs9vesET8o9o2LsATz4oGjXbpamFQ7ZVirkMw7uO2vP70zq1HtkXUlD0wOl7GNusDBV2vxw8zcBeZYgGjVwGwFLpiS2OWtcouU4+t1G0fZAD7rckVbpFYkqSP1SC6vRu5iyeAyCQ6lkmGytWYl9FDSs52zAc10vUAdHpwSnCUXsA7VbAEFPu/1g1T1fgTU83XHBHbt9g0lrwWDrbGBLOQU1k/K7y/fXmLvOP/C9TFGGyA984Khw/B1J3E4GGlJsF6+RB+bm3Tj7vfh6u9vD8Ci0FSGONGqd83GeQrz2LebRkX4g8oCmiIzyAOVhYMZrNlRQWqDmKbjTn+TWTmoI6fOPrnw9uWc0kmVhVgR4tDb0oEVrFn6XMweplp7rKOLE7XrC+RoMR1tiP21MMCm6rgxSlTmU4Phn1TvDNscz6Pdk0p2ykfD3Rt+5KXGBkpSCbgKG2Rmq7w+Em+Jdss5HvJN0tVZSlpdPHNKnC+R9+x8019OqAuK+dIi4orvTSHgtjdrhcsaUhO736RPV/Qnt4V8K3pShko1qSdjn7h3fk+nAlEWOAF1dwiEMVh12JDjxErGWQwJaENn/o62RE4XM7MOI30gIzhIm2LshQHOUF3EOgZjQECJdczdd33FJ2/igzeuiDdBq4Xc8J5WWJIxydBPYXai3/OFCKjKI2o4OeZ7wTiaorZPtqVApApIj672eiDNRjfwtpoEpIMEUX/8iSLiRpHjI2p0ocOcPU/CjNxpQvDtFBI/xg0P8uSASrpieGlaryJAxmEsrzXDXp4O+5HFtFEbc8VagUcMiJfKY7ptRSQBBCBD8zw0PpBId0wHgRz2gZYSAR11vfGCapdB8s4BLFPOmnJXh3ftKLguh3j4D/CX+KvWxLfVtd5dLeNkXOfi4Tov8ZOplTzGXzLxtTOD85FHojawROjH2oIz3w2qfTLVVQ0hNyQ+HhgrJ508mvWtmYDeYhqKUulDz2kApgCif6AEPR45R+8NWwqgr68n0FJSRsGis18N4ePWaWD/w+gBG+r828ytx8j/UVx9NprwbjbAdmHEMLFNAxWIaCtH8nHeFh0OY6BC3dqLbAogYIFQxI08HlCOEhe7j0Ze1kT3vLA53/qq4w1Lw6t3iupniX2Iuna7ml/ipF6yG7POoi+QmQZCg+49aaFzP5T8qIuvWcTDN5HiyTwVyxOnut5SL6ydfI1yCYmh/HO8CeGNtg8W47MGYjob6M8Ivyngyu72Dogjm8819016wFzMQSFlqYLwezfv9Li00DMtIDQwiPIu4ijjY9hj2hsIv8UAo7A31oRm9K3dj+Lyu4PiKEA5OPGg5xD5nNv5F1RNOiyWvp628bRdmKMrctROde0iQNF0uotqG76zZGooxviwIzNdXr/UnAY+aOPaNlEe+cibe4ZR/pUDSGjIcUQ3BHVWsGXkGXfoWKhGmvz3TUa10PuMAt+AgCDfVdX4mPEO9A37zFlQ9vw1LRNvzFF2vwnIrb8AfIYpqv3IKICatfcHM4W6xAx7R71MvCNDw+8PzDRDzUZuM4UHFczl8g9kBXmCVGTFBsus3KX4RXedwVzyPdTxeV5wpuDRaBMQOzqttCg09l58ySedD2Ru8E1sEjl3M03ZRqIqlu0JJGfjZcxdRo3i4K9DB6aSHyeHxKaeRrztunV7M0UEqTvTV4K4hQd4iIHqAzB/PuVgyxvOEZnFIHbPms82plwWSc8mAROSpWsDkTWjtCt0tBxsJUNQjKr/zPdPwQKP4/OSd34BW9ILLXJ+t7oqVWj0bNVgK7VDTWLWVsmQ3VM4wETM0fIeVct7r181Fs7zho2ipaNaVpdYTaq+PC2t/jKyhaAyalmy49XhNyVYAMJcFRRsr/vxoQT7/R7A4RK0c/rmK+gOzNirPE3beY28QtTQWoDAaiWh9m4ULnwbT9UQ3bg1N8METp3kfpjQT5RulpOOvfkdvszYYhcyejOxeTdoCj3VVId1BUEF1/nmj2TGH77UP0SMklhTfgz019Tnxi/G5ML+AHEZXzEti0mZQ56Zl0ua0RosfcHTSYi1wzmeoSTLXqM9dzv7LQRtXT/IaOGHJBnFyS2L93VatgbZArSjJNPfIPUt4o4iH8DCp0gkqKwOJLjsh6sZjZkyAhQihPShHLV+2qGCnlNaJbV6BLzifxpfuZnPWkGhXBOYSG0hKkFi4bml5zQI5qI6BxVJf8FJAeHssRv8YPKkenkeSOXtlh5j+HaijQZg1VXw9lcOxqhzfa8egjewosi+SgyG6UHbDz9bkvkpOceNENnNsVgE1Hv3Kzy/dCtO9R/9NKQNeaFGyoz9XOfFc+eIs6V8rj4RvqQj0r90SbM9403d+GYS438M4DoSO4pIUc7a4Wa7YfFM34MeNHVPcu1EWa/iaoK5LBMO4ij82gBUxWIimRw3QEj8XR9VLbAh3U3Vy8RcoOO956XkqhYhWy2zhfcRUKTnxDhrq74lYsQzgli1/ckSyFi8glSlgTmxnG5Wf9s0x5pUwomE895+m0yZ57G8rlMDSvtJh844/qDeB4Gf9LRXHYm7K6EtOgRvcYgHKrMLB6VrrCehxJsMrJ00JlGxU6Hr0glIwCqa7P/7HiNL81lMvBdUiAK4VAJd7dXy7/nsBs2rZARKwmsTFB2EqCLITIqChJzZUbsYkL9S5WqxdKNUuGM+AeR7v9Q5H28p2wxYJH+HCtCmvRoM1v6L9bamjlGY7WHOV+b5kJDJUsbImRRhU+dJwgnWtOhhgTf8oP5P99D/ehTWdPvv5/cvYW6ez63nCnFHfuAfzko98NVUk4lZMlhx1lfj+/60H6aQjerTipjd2KYa5sj4CtzwJN2GMD53LwSl9gDPgeHlvrhON5MRBnsU59s/Of37K1K4gawG6s9IMEcmvxKV743OylLZbUVUNA8cm4GePjIZF9B5mbOcpar+t9NbRBiMU4A7b54groGn4xQe3hrKO0mQs9l1QFnjxICXdqFokUI5NVZCRwmOoG8v+E1MfLoy4CaDxXujJ5VtkSbV3OOfGa/nTQG0FrRznEX0INykLqktH0fGtajf/ETY6aRjFJXnzIX3X+Q0mKsEWPL3KqeTpPH0k/xAC9pgewTlZIutc0tkcxdrCils8bD8Zdo+N/aD7TVXbVHNFjAVZET+EzIYLFMhUD97etUasn8LE2uRx+6x++TXuLdOm5HiL1rs1YH40bYjzAjz0ZZns33PWNDguXSZgaMZd0DkjyxLSOEyvo0Wdv1v3/x8UGo06b1jwzwbJ3AeXL3GZ4JIiX3MLm2a1SQF4ZJJhzHBcXR5N2kbPSrdY4222uSPOYlZ+jWtWufU2RYLJPLIC0dC/WCs+K70kBfetZH4WsH6dG8vD5F0luK6IITBbX2xomCL24O527kZf3BtumgEQ2tQIcDiTWWbmUGF1kIA+O94gM1Se6JAmYNusRzAEuYlUikKxMVeTvVyHtJN0FgGsHumNEWnEVp9MexwvWxW48eUF7LW7P6WjghzHxmMGqCl26C9tRfMCfJs56kBQ29sa56bzJ/6ddcRxQ4p/1a7CHmSpUSt+9dqm2oPWpJJx2aOQC1bOL9/RGCQihYlol0DJbsoD2OFxQPxvsE5AuEkMmGTFQiCreQyimH8L025gKl4GBWReI4T/UXCbaKCG1AL/TsOjoak7/ltJPn9cWB4w0y44Y3896DUA5JVMdddbNgcA4wyhOwnr1kYhJBqFEvsXEosMVy4EtXtoOABK22BP4dMWFWaJ7Lbdnw2KSQPx3Q4Y9+AyClcXB7oNvOKa73kqbeLUC+KJKe3gZ5cuGR2q7Hxyw+KIcMmLfmvkfsOYLrRP+4QD1cqw8QZevTdDUoVMJxkTlKrylbCYIvTnZ7Vw7vXRXcyfTW4BNfwN/t4ubjcxbjv5S6Fh7gTQb4u4qFgU6d38DZRFJhHQgSD6Tz5e3kpq3ASS2yfMu9wnG6dIUwEFHCz1yD1bFV8i5I5YfPr97jre5D05TvNK89SUtbRszWmnnpMQSsZVnmmFOJvHJ3S+dPh33VeXgBovZqFr5K6fhEYCGtCuRWkF4VncdvJ87c5GXQxTfzIVnD3M3BCghuRpERp8aqvy4WtditH39gjmsjR6mqhNRDdv+PpnPDtLnxTLNhtEqObwHXsLcrRSyX6lBiP8zkVJI/nV6sZdYwX6tpsmr3NZ3uM3JkPNiLmKATLvpWh31zIFclyzy047vP8QQm8Aa184PB4H9Mibhrfz41e7/vVYTxzUg4Gq5eqGlE0/nUpIiMQMndXGjvRuin7qEC8AzzQ6YM9l0IVRnLhWRWqvVTG6bwmby0EAgrf/kqbk/TjDT3oZBAqeOyPeySRAoVLZE2db5ZQctC06Qeoi2dPJaaGaaGsQzU+OEKE32NFY0PWc2tm8OAWt7o7ydpLaUo6Sv0YbIMjW3aXy/2uwg+sskU136Zr03Bph5pCZbzDYrvCwbgsu//4hkaDSk1RDlb3PhyVFoxSWneFx8Iy9xWBzfbGvRo8usPRcBOsOD1/IbsN7NG1JZvJ7RMko9+Qq2c27SQPbIU24/GEz3Gzo18VdjKq7aeaY2nyKCCxKJnln/J6hXCCVcIcbAUeHzVHLYi4y/2LrwHOU5g2Ze1QfkeU+3Lat0TnRJkVEH/PyBIHdqlsK9QpFZAiaCgpH0vVfuQQoIsO3+ZppQlWqSsTcuEdGy+dozfGcp9y4AcQPrb+2n2YxI2qfYI3egbzsKuHfJ+noDGkr81bCZvDgE5RfTwV5UyLuf1vi2WuVlk7RSxAHbW7u8lGyp4mQEm7qvngrvqL4lSWSArqLiTdWDFz+YnlmNDLODr5psqcSU6YgR+wmLLEQQ4m2I3AsFBRAKDm1i0OYHY2asXoaEFp2SE6Vlva2Zweu5XlpaHaF4Xx5ShkVbInKPLjMLfVR/RBU3NEBrADOOqiqZ6xQWj9WTSEfe7k6ZsvZcFNHgezVtFmusArMUwRigiJLNztDM1+W3pZiOOFP89w89RVWH4tup2OBpKY3igz7dzhQ67+MScG11TDjKCQMN9AjnS3vpFmTI/6aLVpaTq0EZj2i+cA9U0qkH/3pL07iiJsfo6I79nQe2/BpaiBYz+VqPzS33xd2X2/sqc2qg+PmhTMllHlaNbEJApv6lfzcB0Dmx7CjncewU4Mt3s2NQSF45TUMLMtEW+XdyZKkjmTWHSz9Be4suKTwVzZpodoVZybnZcYj4khhVF7jQqpYfLE24GwCfIsAlqfipirsKnlZET4caHPr2qTfWXjnVlhIeJBg2nPfrp0j4VirpGVNYdzi5375bpLEXV+k/HhXX8CYfIKc1k591e6V1dJfsOZrfQ0912uoaZ0MB27VjyiW4VsnKfN10K1Ty6LEo5wxcp3GV22RAy4Xu7mts66UV2cu5JsYRGxosRSRJ/dvKg50fLI8CSXaoLOlcTb10jY1TRamySOivgte6j536M9rRqTylULr25zQyJwf43OcFoFQmgc9gNmO0Vu0gfEP929gPamdWZEDUB/6+B59oDAM5+MPdhUaGeN7yxoLPQYjXXB0d9gr5uyjV3OvfyA3tdpxGVCRYUdW8LLUu5nbBiI5s4ScPbyTqYMiV/XgSdPhhB6t4XVmTjkE3QsT/5SYWSa91/8rlZrzjMzh8iYBqskR7X6Q4DXCZanGfDDV7OK1XivOVHFFbGVmY+bv5k+bq1Or13uF4yRiVSZr2WMb0K7wIZo1q9zRSrjGE9NNjOb7AJeywWk+fzmp4jrFxapqNJTmqAND0x/eWkq1mCXZE+vQHnnse4LhwFt8S85jmLP8dGpvFnG19QuPItcdPw+Jmf2IZi6TocuqfJBMz6PACOTUR3b3KMqk/9rLo6XVS1Yxmp9WPS9uumeLhB9RCgStQ3QBHOargR0h9ruc/H8th6vaT0rxoiQ7QcWPXzmrXww3jqJ1UUxh4gFPeyiLrZsVFFdvV8DI1FBFY3MYOGFxpIpmfUn8RjYQV3jo7VftmHTE/hDfH5Pnt0+bL1/0P/lPDjNZ+2uT9n1nTlJ9cY/1V47nTfUEy/iqGP3iYbKNv9LxiqY2qAzjVA2JCpkMM17584Zm4ojYPryUnEiGtOKuFpuyi4Cp8r5xognulYSha4dZJ6w8/9J9rliVsC3UXXS9qgonBBTQ+z5hsf8++ay+kYIIl5GYG5JCTCXYMQFPY6YfUw0e5TYlQifwAhtZ5RuwXzMuGZgzson3hiCDdI+AOJtQMqX+wwojtROP1srVdlQZIIjofRVIB+uxpqKZzxe9vvrcI2rU8FJuwYG5JTMiEYpKk1g6mbwxEwcsE5rLDgajqDA9BRvPvCqoXemnyzD0uLrGw2wC46udvzqv5B6GeCAxgGlj4l35QoJ8My9cVf9sF7pc3B79//BrhEInzKZydTScCYz2fDxA7T0xcf9YHMdjgKoTFyiT7rfdYOcwEzLapNKh1PVuCgqLav7nFIoRghssGnQ4AK65pJVhaLHlWt5dsrwXQh+A6a2npI2ZepItWZW7kUdyHRycjzC7p7TpP1rp4f9eVb0drJ1YQa8Bo1FE7VS+kLwygb87ADbCfNxe6b6sSwX3BSGBr6G5Y1bPkjI5Rt5U8C6D9/dyJN8fxRJyV2K87WYHN0azzBLbke6Id7hm4wxdEKLKUpsbypR8xQrIuP4dSqJ9hxApTM5EgUYWaLb5pIOrm+E0LULTSMRaOylzXLmzpNYKsbeFkoRLhsZeFeTbynI65AsvT/yAokNCFTAFsSG9bC/cCreLevXRJImB12NfY6tNN1mVbJbnQb00S33abwQdTSVlyEgSWUjFT13BH73sjvQXb3cVu0o6lcfadXFgFVFOXCX/f5E2B69yDUKIwYiiswHK+l86KTG1hKfWKd0Ezx21C79/6R69HlJgpWiI4L8vAG7cxlMJXQo93tQVIUuAnTeKiySHwtwkxsHhg3WVqqwXePdHFQYiW/P3NfMBgLv8FiZdfE1fNr3F8OsVjOoZ6MY+HXqoEI5uP6UdWy15zgx2cu7+VhPqegiRUqgnpflubFqaFe6fz67LVZzqsU0PhMlZSol9mJpJqKJ9CBbc5dOj56A3Xj1/KXpYYbOMfR8KdkKFDRKRsgJ9fC9u26SKXStTD0tfDWX2Q2biHSKm/utdCeX5OZeTJg/WzrqYnDvB9v/cXaTjePamuaRj8wjVBG1mGg1eHIXvUArt0eKjm/6cA+epYXXbe/ZcdvxaVf5ocHRFXOLdHzXIRB+9BjOHcBspAY1WV1zXdRTpVWqf+sO3IHuIaS2WasbbJkeDIsFqwNG/0g85O+G64yZJcakqKG+SG2lrG2NCZChPITMkDeCOeHCQG0wXrQ4/NVdSxh6YP0JgB/4a09oQgvNTpYSHVAyEvsranmASvBxBtMpeOTnBHqCy4CPDrXN2xZcKJIzIvl9uYR042hGLQqJtaVd/unEJquORdC8gkgJ8DKCivoe5wnrVqdvztLJUYaydFhKm4serHDWdEjTKBK+eNZXqFZmq74jN3n8dnFJbiwXjW7wJl1lyK5j94xn2qNwTAKLltmYNrxC57f8LqFqc6UeBHO1jbtu16Q0pzvzsdeXw7pDmHidALTEcXNFJJYz4GlVxltPdOr1fs7nUlnptjah5SbL7PzrIyCHIkRG0AGrb9qoM9zT5/iDZ0gMYpYoArIZUNhmbjgkW+l4YDgp7hfqWXCJOroQcwN8lNDPJKCk728Fa8gIF9unU3gkN9BeoUYGQ0PPhAOt/J9Zfj5Wlerf4AJhaFGWLK3BFpKcQg/kM+s1zXqU1V1PmuoNjrq+zv5GbKD5T4uj1lURJb8/1jtFchfeytYWS0PIIclZGM6/DF4vb/wSJcq4mfrfpLV5fyz9Y8i9GDVQ64xkETgAOw1/HPp30GdbHWQy0M7OGItHArwW/iVj6qXuaWI5/W7l3Hevourp2gIcEU1HQ3g8qdOMoIWcSRWKHceMRRp+koMErYj7qetNaXjm8UPLFqehdT+jHvYFAhX3qeH6fcpmcOlY2vrDDgZcN5OCY3co8EZkjtkO42UvGUrZGrOR8kLKzjv84tbeoucRJ+YB95l9ObFMrMx5enB0JQhSn1IZP9ED6nnYx8GrU8MQfXWs+cmxRn+6MNfTIrg2PK3tdjWQSx9p9PNguRbtN0GRhZj00z9FnG148Cqkb7CMId9bln5j3jcU6w1qCaUB8F8Y/MCYUTGBaBRIn1ZX4nbksiQOodxJv4N7gHYiXlKhrG+oHS54dRJoCunraAYlyxQQoCiRr4NDgGMkGoJulTTjSFdOvbSO2aGKkgnNbBuuPQPHpGUYBjZR6367naoopQtIM0WEfhohnltC3C8iWBhZFRUxnvl5RUSXPKXl/ENEZY0Zg08diVtgS/QyescLZ03pESRj6BuckIMBplee++K0yRks9lIPEGSfgPp/JRLTNwjtCfiBqrCa2O14AFxuXx5k8UiwUx7miYtWQ5Q79WR5FYFj311QUe7eJTamW2VnQjTbHsFMc3kq21h3A+OO3U7ahTYM/IEAXKxXOx+L4FLD4hIGfreLdTxYYA1Aw7+qz2Ytp7kPcnUwmr3QtMFUYziF1AQmd11+eFaXCx4zQzn04ONO4/E+/29coQAz/0yG21eIKXePM9kiZZgdEQwoukdHgSSlmIC+hwHe2S18gXJaVAdumbYgt772OAhHrVrbVyOqZICh/trWyktWo/lFpU8b92JvKDC1jVs7Hko/MnTgjEw2Yiqt/nLPAizR4lAmWCwsr3Ww1I4Re0Hzw9FCjoFWR2dOCBFdydcWrf48oxxGOqhnFJ1ttIZksd+QqlkFjKss9S4vyB8miPX5JOcxPz4setai2bbuhmM2QKxux5GWL+OG7QKjGX+wIAzJ5+yPM7bQhtqux9H+M0gAlzO7CiOigFi487RyMkp73uQPNqq+4UocoiOfSx3KOMQca9aT/JWHJ3mQL0LH8SnU6kHhtKXw5i3wuVXS4C0EkpYZ6AxB0GZIf07RHT/KQBh1Jb+wYdRw7j7oqVLsQjkJ5YLYyBtLs9mpPNheh3YA4jPAmjpy8xb7T8d5ga+VwMqZxpvOOXbxJt+r2MW+CTdk5AXQ52TPLFQK5zKr8TWGCg/O81vS3vW9Sn7X6MXwzxMl/qVdMbMUixgVmrpVRlsOjuPHQ+XsAQmVQ0z0ZUTbrLrLqmSV0zmaq7VFrFGwLGbK5m6AKMdTfPLcv8rC8aigyd1VWQ/GWcxHq/WQU53X5LqhhFbWb32Uj6kmqo7wVYGq7GnJMtsSWYx1jRdWoR5dhG5osZjv+RR2IGDWvfAqGZUCPSYdl2xfU7DPeiXSU6ic7fm9ABOaf6sQuv3EpI6jdT45VasfS1YFTlA25Cx8OuOdeuBh507QwIMUPiMVIMkcK8E+NBIcBryGvdxRAgUuCvdwNAgFh6TxErHOJRwCmVcLkjZGIwK+PU7HG2vYo61gn1bgtTynZ6lh2JiGjAM8VEIkkvYmmtvnNoaOWHlslePOl438iu7xHGk9XNGQ2r841YsuWC/b36wgLVUXTsrOHYz7uFVU3QIrdyPcglZ4rf0YaWsgx1R90T/BnHqjg7KslWD0jBLsPYMBPzesPyjhnDMEKNcCrE1VTyT9+9Hbr6VFwoPd14Z90jB2Vh5uFj+66APjPrdFobkX46034Nn1E0UE3vrsBxfXjq5vw5idAm2YklA9YePVsSiV6gpbSLWe6Wt6EvuNFpmK+Gegl4TVzd0r5c6QgUuhkgqnFWyZdxCiTGqqh38FxhCKGACGG3lx9bsiL9JWNMZJFbpE5Kty1O7YUIofcK0/R/a18lW654ZnbAhqOcRbnGp7lvoG9cXxSVAGV2tgvXYZvB78LhUahDXu34B7Zvi2ya/1m239XmpBQcH8P7in2lnmTQZtXy4D5k1/+d1Sb88RQKTKps6LzO8fVDKBoz6sqz26pAIWDprrjhn11bzNDBIXBxFJwGmWGwCNc5l+CQT5WIho75nC3O1VcainGtec/tLMUrn+otm1mz6z+uhgm22S9DnY3QL9falOZ7DdbWeyo7IXv4Cv36pyGlzeOKYs42m03rTxIEzhzaELlCq9MpMrD/upRpSVVes1i+FkZXVL4fe7uZM0awWcCAvilaz4DuQQN2tnE6fj5fqGGlGZ9oAysQk1TUDaWs2nQ/murm9PZQLOFVyW0IURO00Y+Li+oERefDSAPMU6ZeqVa46vOrUifeK6TOWcQMSIuuo662XbA4cPZdOiZJKe8q0GHYQk/usBYfpxIWgRyIpzzjzFbt6CrycmjPEd1okJQpd/NPVPgE5VY+70nfp68IuDznlh2Gb4QOBpvNDyLxcmq7mbi7B6Baz15pahepdwF9j3t9co+9MpbmK0lFOI+66bfYFFv/ub9byi4KGzkBdlsGJNHq1bhXn4vYsGUZhNqH2ljcq0j7HMlxCy0pEZR0DSOIIREgkie9rmgok1O6KvfmS22KUYXJbiQww6d9EwR757NnIBMjwx7GI8wwl2FG3i/WLN9KdEj/tgS3FkYlcw57v+CJVC9s9iGqXtlKg0QEflp+ki0RAUspydc7fpSFQRK0/F4f2oelQ2sg2R6aW/Z08Ia+b5tOG/Rsax9fwBhSsla9w9EXPg2R652IZGrSeeiIFTFnL9Vn5Ono28AWlJESjpG1Fcf8eXdPo+MgqPKs1+PAWkntU+prnYsJs16CCbdy1ugiu0o3qRNKOCpycNSX1aQgSwHlBBC/5AOSXXhqZXfQhmJ/r3hSw+VpR/YqR5ryHfuGVLAV9tfUOKIttGaKODhYoY1vdnN1HSAbea1hy9PpWxx7eSLNxTMawSrHG/sre4krtAL95mNSz8ik2vvDBmPC8Wt3fqDMlyOqofRyr6Dv/aG05LvXZ2h+wbov0Yr6PYtdgqVS9VzepA7hJ7Y0h1822PqCiLAjCECbd5tP5Fvwq6whkchAPiTb4SPhZO8VbE4b8fuk+oQLmUKarDLO85HXqWKrXxd3kBTeb6JRhtv2VU9rBqtmONdS4dAXVPM1xYfffQ3PJZmXKD9vgsHbyli49hSiF1hq20tJOxOZyMeQ2ilXafQROht3OqRf2/DUxEJWHO/o91m+ylSJKZ1GIlJBfJppYs08vSLubE24dlDYIAk07najCQWpIUzNKh1P/Mha+EIGRv9ndvYpNOj8AC5uCQmPyRKH1Ac12e115IIAoyG//oIHt8TON/PIdllvuJSBhcKiU0GhCXqZu3fPhZtlp6ukJIHpg3JM7o9JFV9Epy8ThoP8/ZckZG8p95cvL7mIecSwgYrsWxJ8y+0p1KhKLIOInbAi8HJvRLEWAn1a7FPaDc7zxeKG/rNxAl9qtnaG2zFWBnX0/dF0Q3VhNQhxLJXC2mtC3Y/RFfaD6vpZZAvMC1k0rks3izSG9aQ+yKF5V4+tocOL4ZEWmNdnHtbBb40tygF1i+cfYN4IShxnxYptLVhgoL3hSWMhZsd6PBaYGqz+GWT5wSuRPdv02qAMTOm7taUc3JEP9iFqsdmPmFCEXbR1YS1qKxRaQfUWv90lUqVonmyp/vapdYbGTQpL3Ln15EbugBvWR/h9Ba+joR+LWnhx0H4vrQq2r6LT7yondBhO/3L9dvOIovZkaJbWXA613TjcXk4amSIZdbsBKq9ltaolGPlcF7rfcIXRbAFvmgb+6Ct3wa7Q3XC8S+U4Ku8mky+ZE5buYwoHZlqY76oyyJLUjSo5C6rLAPz9iuL+hjwXkbpUu3xCg+d9Zb3Ceg7mHoBavVkfrtl0GuIk+oIc2h8mLy7/yTIiNN6f1cOGIagYhTpaHqJVGHBQL9dGT0pxv5iP2cREbvkhlbtZbaZawH3SexElYZanM9jOfaj97e8f9s5ZwZdpla3syPO0gxY3eUcRIJAfb4PHzfNbQHEkoGzms6ycKu3fD2x4D/y7YfZrOT6cQ3aaDrQuenqElknMDk6yrXS8o8dwGi60cNQuKxAaVj3gi42tDEOkaiMaJ+Y/6HeCnGSd311F3P9VdW8jDe3v/31k5pbdSKAOsKgdy7UEAthPmor/68NS3OJPByO32D8Uvv4S7OSr3sXjSsCEBo6V5do4JH/mYModMBGEbbKBKcHvWJzGcdMg3ReY6reyzoAPv519EJNRRMDkIOAFGEzwo0YiwIQQ9akjXKngwc54cVoWa14WVIHDW4ZqdR2QkEm3/OlfDoxc/Dar5H8AzHogdF7iIqW/NQKfbE9ZANPFD0nNx9JwXHQ+L1O4EwcL9Bjc0eHFbay8v6tsUo3Rhwa4SidoAVNav9qAnMoLByZrH8aVqiOcNlePFZyKGxiQp+dYFdyIfPw8S8qmHhVXyrc9OKxQYKuKNsOzcicg1HIenN2xNIUL+RRxcRmHRID0E0LPUgHFhrgVu+0DdzDBImGLE4Ipr58yKYbtvFlyAyx54gb8/Q/19ltCrB20FlcCY+CwyrjoETtLgjCs1k6w0SoNjzlHE2BtEB0P2A/SRSzsALiyBiGDuzWVpnPxrrlGKiYjdsKdr821ATtRWcJNcU8dd6iGtmGHI01a+y7WFej2zBYxl7HCOMdK7Xf3ze53yZOagTKNihZ0ASINxyA3xDtvbHG/De0vS0Jp5xvwWqjVCwpUjiOSGGczsbXq1T6USmeBvF973se8OCtNNmekC0Jm6RgGeqn+Pjyijmv3AqqFWjhAi2+KKWA7fYwEa/E6tz4W2kobV2LsMtsGc29ajRtwp3dGUmzZxuyKcmGKIlRmiSgZFvauz44VgqH8UOR1kG77jQopA3qAtp1++db21PN20OrgSl0u+QTmZjyag5ymc1xasH+M0WaPLOANS9eEAWZ368Gi4JtbjNKdDX0tIzbxeB+dovp4QirLNxXmv2IAsn6DeV9Iv7moamFRs0rFIL6D6iM8Rzwp6kbOps6tro1IykOaD0lx9/r+5/nSh76Z9HphniZmrGHfKKC8c6Dtzpwlfc0q31goLYfkpgZYVMETvUq3t2Lg2wA3U7eyvaMCDW6dATbyhsJHeoLHtjzZg9uxJm1WWwguKW8jSZxU+44eCSSWKl5Q9/wgx65iU9XuqEHRcZ+cfrDY6qEu6UP/taR/GZNEyYMI2E/M4R0lmSdekYJex5MmXAmMG3pHWbpiB28xixsv3jSIx9a0YxYlWpKiE6rdHUMOeUX1G8WtPRxvgYBkLR8F0V5Ijejful7LJReEaagohkIGKHEB4J/KpcNbksXYEoIyTWaPwtFGgzuUeeQb6rRqhtznUu6GH8CN9IvE/Zh34v/kJ+Q7YFB3XEai2uTOH4YQXYlE+H5E88xkKUrMoqosDykuoZu2eAAkL0IUWvbZuLmr+TCZQJF58X+lTsPnzpcfcD8AvQeUWkNYsLLgVeM6+mS36TLHLPgDiJ7d4bBdEHE1qyCOBSYBiapR/vwiCY8no7kESejEri9nvzlpuHzpg79p4aeWFD5MvGbEoSGZOGsLl971drdDggs5QiE/a0HtUXPYUywjTay8nihujoYNQ+3ppgM7B2CTALWO5h9DVrOQjc+J4pWwxxjsDyQs9uD7ew43SsCTtstqOWSOR/mTpTeEVWTDqBYw0NfeiqR3DzkZwpXrTLHghUkQtfQYdOdsnUpHuxZZHzzQVqzq7ARdftnpoibxFLNN2NsIdY0kjwgSuXY/42UfEZdU58Cle23+34enHQ/cNvTX01kHVm8jfbQfsYLfWMXTDzgPv/V+vsziIpCeNmUWMmvtOWOV78BI7s0+alHdOLx/KtSenRjipBKlKhS+um20BRcKQfeiCETyoNZLIjMG22ZT8MmUrcA+Vr7tLHQRf0EuI8zd5diKKZ57UjpjqulfcFSdf0oP3qoxkHFuGs7ah6KXTdeVHFoITEAs5JLGYyrlN317L0HqhwH+C7pXoIjfjeriQTuKxGUuehYKfo+WuK0XleKteXyIZP6A+9RjdfArzSdIImbElb8PE3Wji2gpx3QJhhyRRYOWb9LAKLlw70rI4SN3+S2XnXhM5NvV3VMyio9MJiqbeZQZk8PQv8Z5QeISLAaBLE67JHya1+8tbfRRkwGHAP3l5cFkLt4GxwRNrXknAW4lsiIyHJyMu6hB8MKLZ+epXVZkiJ5PwoxSE6MXA2eAEeDATZ9NoB4xPjCdZI+6dcdBl6eNQtv/+ddrZTJ86/J6Q971u5ujHbE6dicThZV0FkRy64kGgGyCgM6fnWxq4N0dNW3x1o6jup5VXSAkZYr4rv37A+N/1yp42r5K0itS04olCttWHi/9ukp05rFVjKxFEpn+h0HoDVI/i/ULfdo5AkK/Vmh7fqLnvZPlWse4WEU1aNO1sZmUp7K4/cBrkAtq4dwPe2cqMbszQqNvZa1wgwL/pJZe8leZhnhh9XhJj9pEOn7Ia6792eRhjc3GI14tOB81HDc0NuxH9WQVFaJRfiHUIIokAqAYTBbVWdb0lEGfdoIZNSmcYeMpuhmq6BTtkOgdd5rtCz0hC+WRqdL0zKje4oxHwDeNw/u/2MmC5DHZIvw2JLiubTxVgs1j9em1eT2Y9gZcWpWgMBA+d9zuif2G71Vl39tiXxnRbBNK+xgPMqpuCBgHdL3N5WRHaM128KWR9JG/0eMJyUM5P1e/Ut6xWG9exkI5cZ5M91pknD6auHq1p4f5u1mcGWBB1mNI84sO8eNtVmpDoIwlTl3heevWodmV5c4XuEp/dlhQ2EyTWgptJO1wRNk6sk3LWFI9ot3BYC1EjsO62m9J7UI6NVozE20ULnlnNUBa7owYfXD1BayqLH4u9nJwogp71gXDq6TTFzOnZRoY9LnWwN8M3vHjP0UnioKxSisN+o0cYsbOm/joKSf/Ox6eX0ESVz7J9UYbHpKQdC337YTMuKeRCCoe7ruft1j1kJ7mlBxfWYF57tVA+Rg+LAJCBLX/enJ+7xEsj1w9MZ8HKY4ackT6tijv7xjSLZKGr6zUll3wtxm0A2ZDa8uyYomEfHHP8TIF5/O9Sj6LlzQv+hrtmfx+ZVdA+ZoQQV+Oz1fSAipFGIfG5NDma3yJP3tQnsQnrg9kozlX252QZW1pV0gRUKAO5Duo1bDLcKFXfyE4xL9OzcRyq2YLvs7UrTb6R2n9mLt647WWTTxSG8N8t/4Mu/6Kh4yj8oKkjOj6e9C5/LfSQPvY5/ZjtPSMqJW+ZFPmUsemi8OWT5RalEhOLYS4DtUiqJLP5UwFIGYBTIiZpVrmnVZFwweIWMUnBc84QXLId4w05tWdiWDm1xcNYqGdG/0qT6qBDtd9zyIEsS/7MydrZ6+SsZpABX2eW87p4Ay0qIMZ1FNsy5e/3+CvM93zvvOZMTWVZAX51JnD1QbHZCQD/G10n3XGKjycDaS/KBnPQDo5wmsfKTJCzipFI0FfBRWq7KkSMNaxtIPqNbPFvui/i8KyddR6x2VGEhEldMWmM0xvtARQLsm26iwbDDSoHJXMpKPN3FLVNBc7h07VWnoywg1WtDSTD6lP8M2GOW0ifPzZCXCFQh5NozwirT2WxwuSstyP9pWcwzAcuf57II10l0DUJsSLIjPzQTfOz1oY2IuDxqRNEk7XSNo9Bb4wTmINYFMtZ4KmS5iIIWAVNxyvlooYUHkF89lFDcT998kXJhfQvSbLXgjXS1LhH7Jp7n/+PJqPayRsjyQezaPEUv3hJQXUhuLHhWuD+pjGlHSRnllPK/yRPLE0oBpW4OCQOlfJ5Qk2INCm3/X0XouhzMz7tI3pRWmHmfDznpQbKwo7pQKCF4dBq/7Vol8vZU3y8wdcnhIxJ7g3ZHKrV5cZHTh6PzGwX+IsdpRiBV3VrgLKp2Ox+UMiiBBU0SgoLHdl7j7zSr8wVNzGS5jJt4ivlaoY7e7NMd4Ifw7WCknTwNlDn+dyWrrXtI5TYWp2rDjtu/auusK4/gnwFqvpXyANNfErYRMMnbAVg5VA9Oz6fKKCtr0utrxWi/h80TCpFCC3kGtwCpFBxlVzjwr2KPz2dGtu5GcbG75cgbjiCsTGVpaF7z3YPQdZcCHyw9W3Zd4u9PDVqtNHkODLsm1ClF1XWQ5s+wrM78QL1kHavbTxEX2TnOTiVIHnR3Ms3VGS9lQcgfVAAAFkXZbmh+QrwQbUP+02e+He7uQi4GsAkmT/NmfAK3l05sZTkLtJnlEMtIDSUW64sg43JBUOgZJ9o2RTfjKiOWqVjtm/izZ6uKaUdvnMudamRStJHHZEqZTEdnQSrBe9AfnTmmIJBxAh5D6w11Tw8lT0ZMARcWBQIIInx30eGbXSKsbLEaMvAdKVfCorj78EI4HheLC94P51z3MtTBGyOUp3EvEiBAFsPQ5Kn2VRsZRGtqxzfoeUCt08uZv3LPIOPgaKtueKrvx8/8RZfKhOFmUNCYmHOpDWBZLdeO7HUpOatBCbhd21IN15VxEuX/OjlAKc9AuJT4i+PeTfqmY2tEnwZqE7g3T1647GSaKwKKIgxohqf4YtOn6KroZzzHHl07TZETQ2auD6uqo/jfthi1uAOeKG/Eqko0I+baVTNFrjQ1C3rc+dsNjnnVVCyUGpSgC/WPcSpcLV1QNiNj7UDgX0PwR+LtRb6StFvtDHE9b9ge0xS6T/53yYTlC2YYtQhDMCaNulcX5AhmZZEs/CmEK7DxrD7WB1nK4BBYzs4Iyo025v41fN6sPOYdkPlvH7jAIFGPcfS6epso8vy8BRmbYbA9fd4EYU7rbwsoDJPYhHGTUi+dbj92uBmPoHqyamfxcfznBOZa9xw2x8bQ11ShrVdbXGCCUJWMh+5ZXQuiQnia+w4oeXsitKyoh4Xuv7qwTFal2RcsFWLmSP10oTgXacaOLDpujnfZzhLkKLwxk5yElkgizDvAO3DrUmsipW3broPiMJgGCg+FnbP25ZGf0xZSk922DzimT8SJy5Zs90DBuDXO8sXIlg4glZLCCfd8ShAG8MNKOiq+BW5MZg6pI23Esewkiguumbizxi4mLWl9iBOCLKPqkGvaifXmHfRL62yJ7ents87HWw/qoCUY/UZoYJzhj6ebb0oOBlnniZDVEPu7/23qt9hOQh8XG50duZ853eOMnuwbtAgj9bwB7mcj8iRiBbbl+ngUr1YTnPZgDBDu5XZ9EjelLgullSKwBMNQDdUVVpmRRmp8S8CJ28nFw8QsaJ1RdmT5TOayE4sQAEAnTmXN4ZyA1/Tt+tj36ZfaBxQCNiAuVFIfBpiYtZCI6lNoKwiwwXiwxO+o1MCJn6/CRNHbXIob4qVbqp0K2HQR86DPYNkJqTq11K1frw3iYWXy1R3i7ByPXfNV7ae1zNqNf6wRCF57ya3q5X9h1aVgthVinAPIx/aJYAJijD3AwCOWecK3rgXE8owBLn6b3v6wrMzCJiflfFMdSdcowf1TRQkQnjLAHgTsxxTy6Py9ZrYhYqZenz/LT5DREBZvL96sMOOq8CMoFCF54qyiPjUNuKdo0RPCM02SfSg289kendmwnN/9rbIfS84BqQTEQlykIKhZEtigNDd/JztwkgIkM3SCKJA5fRXAFZ92sESM4oUKFEkkBkJMC0JBn7GhXXHRRh68sx4KCazlLQ7LT+iTBFgWVODl7Y8bMbY29Lty7iLhRWlHmEKoFWTCEOtSrJuh1RAZsKd8fnZoI6GWgXj52GKNq2iSzPlurl+BfV6W0osRN8ffq/XtSsPbRWYowmJMl6R0pPeTgX/m2y48g5NGh0Z2yhkC8hv76cys4lkWdfDuyrsztqAXf5xt8piylgw591akrmWgKxgx5++uBiGNw/5ocJn+bFjszhkU3s3exGTMPY3hP5ZdHIvIMy+iBljMH9Ey51wOTtpmeJZ6kZg9BQ0aTMaDioTC52p2oSY0dPBSNIl7lQP7r4yHKMFY8+Rnf+bhzP2Gt6CGwbX4q3CuBNq6vt7QwF53BDQFB8LFOFAUNVAqRj+QBcVrS03zjuRdgMYngFFnLqzaVQVauQEYPV17NhEC2gZYJAVveM5QnN+St15D77UyIk+xlM8ez9+gg6Wh7BLK0001Ifwbub6yalWs7q4U4nJnjqg+eRO8R4CLrQ3wB/xLDt+qFUdJmLPvibKdS9geIvLdpgVCdW24ru6WyxtdBJ4ANwx00GvTb+s7aRJVpdcvHZm61CKwyeltIFryFK3IwpfZ5hE+eLwzJHgzYZjK8MoPkiPDh920TM6s0SLupYDa9l+UipUclGV+pZsji/kREnrsCr4o2yImaiDsGKIWeFVUZn0hXXiJ31PaiQaO0H23HzuGFrcLHFhDUuUDW1xVaHrO69Sqkx7t+sFA9oIAXlVnNhjiOxDiYOuqTemEeyOLwlEGov1/7o3YnuT5sNBLUdrg6Sn9VrjbdNYWx1lX/C2a7hU9mr5BdBOVsp/tbZpLPE9pzCzkPPFKjpjOPlUNr/RIoMJ+APwt3l+Dj0atLJeCCUY/eUyh/A1pqr2rZmScvw8mdudQTHSf1va8rJB9jRETHolowcB0m6mxboNnA54I5yUTYBUkHQLJyN36HQE6XyzzJq/756J/trkuw5o+LpNzUSz9hqkYiIMQiGwfuJQYM5EJhPf9AiZmFe1y2sqaACKqIk9VXrL4wu5wMv0j1gSgRhRflQiPuPjXOfekawAZoM/Sb9k2KsrwMEvYzq8UwZ2zvRaj1LjQCj8ZQjkFfhEKl5L4oidWTcYe8y7mU8kjAiTLtDpxWzn4izxuGD8KNdrFJzKFM5+5r8epWUdjViGJXmEejnHWynlGbRMf7czb/cDQxwQxp2+CGWMkj4+K4GbJMuj7Dk4f+tLqH4wJ1iXHNBMlyA+bD3ZqP8bVXkzG5MKF57EFElGKwo3DluPP/3npZK7hr5/bgVC0COzVgRpq215LaQVaJNFMkT47ucQBy6JNA0W9Zhj4dDLJC0WJAoR0eQGkx3sTpw7HYiUq7kEcq4ZrBlZIqBVrY7hFE0lfx/1a7dC5Eul7xxV0KRHYWUJwU86KU9CijTW7ovzzkV/5EuOA95B9N4xaKnTzg4qzb/CIjlzY1oGm/p6RhXSm0t1tzvf38yW1XAFzKGkDpYkMF8wgfpcuGSIHCDM0yK5bZeujl3uOJc20FDDxZhjvgpk9ILHbOQePS77Im0FPGZ4EMZIfboYIWuWiNVsYBKnTnekChteX9dzShgGX4KmZ5xqVahMAN3OlMbCS3fv7p1zbW03BZNgXiTw76zjRzrTPRzWzEp2UhLvYA+pZWlgDzQxXQDcPJIItKQmTB9/2vSNd4n7ByG6t9mlqFwQSr9Imkd6PnQBxFAuPnSeIjK1r4IXEeJFfvi2pqo0/Zag3VCNy9vM5YjXKrWtRUSXBI7ufcCSjQPZ88dZMIylWlARqaXN08QThL8qw8HiIOir7AbqpJkkv4gFedzAIoRdDaW0hl3nbDF/Lg99cjEqkV+/d5NXsFQZZlKFFYrQEQsMqXdHNgJNse7p4K0mHYb1mLAZu46J3E1LuiHs7KN1/jQWKJTNDdPeP2kc5oeMtdILQp1y4AQ/3RpmzwjnwMmx82kOvG2UcPNmJV7oE6W2oRQJysg2GEyFCtdphYs+ASEr80eGYzp7FG93YkbsuddgtaWNjju4LZFxtTyGOC51vnZ1//sMrqIOiXSHp8pjZ2rJW/fSd4sKaO6ExrGvJRXhkjpfa5JJpR8xG81AptUeUhR1JtOctHRiuMQIq+SLOHgMRItYYaImZ8wX/jaT1jYC/hVGD+8f/WBv/9aGolTbT8Z94YVdtzPGqQxKZHPsmNfLd/AgyRbltbEop7xgOxUYBTN0IvZR1OBS4ixR8RMdec6XwcjoL5SmJCnUknh1XHfLGYL+077AesRN3MWIK5olBvNWDRQfXNPWIiQ6rJOeldGCu1zj1LSBq9tgjpZJWJjSUzkuBOty3O8ze+1a6mpbQ/my8ao7nVpC8B6Mi4X8RQ4SNe7vi1693aXIHRykP+P56z9HIo48y41fAZkBhUoBFUj+A/Xtn5t6wp+ZgAC9HebP495xCgQ1eapYJeeehy38/nKIsm4kjyyVGPUG0CptIwWqgP2QuNtCPHv99NOOWuowg3IMudnqUATu0rY11ph0wxZEBXu37Xji1EzgV4vZNp8C/cFPdIMbqePNJ1x5zFawn9slMsA9lMQJnHusPuflWzNTLhLFtiftxhABGhzV+OKnq7nwMQBlVKPEFG1+yrAT1qikLHzeZP4qf7qDd6GkTTFhb3+RvBV5vYwy64j2IigUDDiC0ALwrUbqGC+UuQw9oyPkN75cZPOnaMH0gOqI2+weGkOio1riFJ5IMuRoGARNbZ0eI+vgNkSOvybGq71CY/F1QYdnnyP7eF1ZOP6ZediP6o/Z+0NTocM3WfMctPkKX+au3JEiRa8np3j2xLLSsXgEheULpGKskTDdEsn9u/6ik095CLDZH2y+K5Yv3t1gBirfzKUI5gXIZn0XVeSibynaDywfrQVsxJepFQZ8VK7zWaJck8vhT3ixJ/Hj1TSa618OqPQ//+cqVpMPHBY5j/Ne5FGXoC0gJ6IEcp3gXs00dGT6Ik16AVhqA3x4iJE6fSCdrvwt4xcc8WTX1z7DGdwOhuZ6GvrqA2Tt2PWFoOklgKwz78kEt7k2JYCE3bRME7Ci5+UuBaJjYlkaWz+S0VKXs16nG462vRs0zFBC/enr3o2KJePySiTVToPC/Z6XreZ/5sif7eiKiqmjGDtx+eRM8WEskLMAXtiWRVU3YXWTmmAU84fP4GlkbTVsQOWAM5tRvZ5EF4djxXGO8vFKBV+MkHCb4ktoKhI5UnaCtSJAO4c3fGkYDlAKKI4751TbQBvBn87fVrwBWqX+8JJBSS4EICX15gYnxisEF9Sk3c6SpBGaYp1Aist4bzCD27xikqlFh6uTm2kxaZhZXIJrJQU5Wm1kzMUYlbj56l34ebGDf3h/qe4iXBbCrxDfSljPkVqmMxk36+RD6Pz+S52SMMP+GSWWqrxBVUmosy7k5pmTiB0S/SNqwkN6WhXWhPVIb59kIKTXQ0VwLVhLtq6vJj4fsiIpnJI8/sGhaJrfXuBC/3d+U1qKeFyILeejx8+6G0Qtlx1A+C95ZQdMcfDum/rbXbQb3SaYfV0wL8eC76WJ1lA+Cx2yCWmQiughD+ph+4Z0rDSGm6HSprRyZud5+vGB6C7UItUwgth9YH0RtPYFudsre7UYp6+xIdIe7uF11kue+zbUhvrPWgkaKv1MITuX68y0q18VcFwFbN6Nxll8lL70woEWda+mYWcD3IDBfvOjqpO5gEXcnbABb+v6R6aMTAgpcTqtP1LII2u7eqSe5a+kj7kXYJWRSzwXueO3NC0Bu/VvIndbmJzWqqOMlcoDs70XozHzSEiIoDJGBdTNLa2zOQgAStFp0+uEux3FoB50C6KwfQ8MQwgCf49K9mRnOMSGnywzry196n8Phf6ZXejIzbmZ35HdT1DUTFr3zapMwvlXkRwOIrbsNdVEFupG8ZXmASW2oX8BmMEsTM/5A7jdxttALIxO96WKvdwq+ZY10acQg4hGmgnoZr6yvy2JMghKfdwDKAlXwNou3AgpEO3X6LJWHuscHAtrGAngblg03n9N9nGBNBPS3874dBI7Id+eKLTUREZaSL6mebv9H1WUlD770oIwm8T2to01IjTZLrtN3fTSnxixSs4U5oP9ioiCdDBbvAwW3w943AxpahoKgWPUGDSJ2JZjoO/AMgp//AvbQQH4R1pc1lYvPKTLaE6541SO0oRwxcHBoETwixcn8T1DY6NnksteMtKrOMGVLWdWotaOJ/XANlP7UUafZLVv5XCN7BEk93AB3TcBsfLu94SxDvVaxPeihSabH8tAAD/IZ8TaYbaCc9f3NE/BRMeBkKMlahwg5Z0eOH/OYZpjHr1Eg4/Q/et3aq+PTAWuJSDPs+olreAoEp834lERNiLBOEopLLETyAIAa27WU304l5GoB7HmTJQe93QRWYhqPAfmkqcCCIIjcN5DnKoir/Fe582rKQQXajlcQXHEkutnXYp5kWH+5YEYyQ3WcaMWnkl8oVen707jEOfdknsAMRPyxVqKEYr1qwpVnjHFGsOUDxOINHgO6Ah23fhI1MpNvvSq3VNKR73EC8TyUGHIYrD+qP95mAa8ADNPJUV3YPBUTQNi4t5kODgdIfua35uzJeUDDiwqLEND/wTduEnWNnvVjmNjuFlbx1mjjJMVRM5AdvoM4fcL2exArtpVK7rW0Inh6upuOS7YyeQshOZ99w++OJd8IQJeKXfjGc572Zw/4HyCF9cMH5eJgmdyPQSDvy4vzyeuRTkyapOgMjNTcEURjPeLQ3LgypPPD4S2Lw95Qp0024RK5q3WbE0RNsX0znBkqgSW51NuWyRuiKlACDK66oyl3wMZVE39kR/vqptr59VtSMpzGWT8sxzpCB39qfdKflqFm2jk8huz0THRcrO/TzZIPTXwpOYRbWS3UUaKnapaoCqTPbKxVZcmyfI5rQUVKcWvyLZQ6mHSwaMhNxk6P65ecQCZmwdr6k0HiaN4iJnvtNWDdArP7jJStnx72OhGqFImAoGP86gdIiHGFED4W3WEMKgn2ws8yGTEMf4xBLOqORTZ+++myShrFHcZpTDDRmm+v00+83D/Ih+HCNlBL2k4yPvplVkB9rrTri+C8d/4tKQ5WvsikpHwPbOBdcvN1SDnds2JOHWYasNy38hV4IoG9rEmyQm8p0xL4oTABI6tZYS+0LTAyWjp7rlG3pAyqyrfFS1SMR9EPi/8KGCXYK3eaNSU50UJwlhWZ1T2S5ArMWVmZrCXncgKtvJVG1NhoAR6KMDBd8SVweT235tt03EtWauZLkIgqxUsVUxvAc8hQSlfJjCbvWxTRFqr7Jq5n/hw5UFsRBrmwEE7XfU7CD9z/5S4rWCiR4ILsZgyZeIpZuUjLuUpxYt2CS2rCrXt7z3lL+eVvMPNABvzic4cxsREB0kjnUwpPNPnRiSNBFXDErto8GxHTKcXS3jdVu5wMxtNNLUE2AR3lXf+BzbHnE9obdSUy8TZsMpWIGsALaPQNj+kHfHFRoUz383p2XOEGhacnzgrlwxtDzczJU2U9xbZdiyo3btN6Fk36Mmb/QntoAsI3rVe5gC/eKy0NiNhMOraKEMwjClw9k3HfjTQujNDDTr7skhpb9PAV/loWIPmX1SyrywZa4qcBfcixY6XdeEaRLKQGD0ANPR9lpEPD+8WWOKNDKpyjWfP8LlGp/KqWxEFOFqDT4U6/wvpC7UktU33OTxcD9QgAwggEIpu+JWzpVAsBQL0aIo5HAXABBJslW+AVj2+AwVacz+bfm9GRPG/6wsuePVxKdCzXuWs2qfvGFG+I+zff5Hgq5IniH+uo/iKGqTehVLAs2ydgsZAtzXJa0mrdcVMYxsofoyP5UkT3UB2NTX2nsVMsU+lXNM0sBvBF4qbz8njhaUWKJCYgtTYiFZ4VBD5y50KSqUEQgA0SBkSgDGEdJT+5BFcGRjKrM3mTYSFV0axNQGGA3/K23OLwpBzFdgcSDcwBwy+nc2wCn1cfBv0xcBHU/50X+u05UWmQQQ6nGCZxux2DqjTZwH8pTHGlBQNf9mRYxn0jL91CLugsXLIMrdl6mNi9+sCgX3nxyL4FubEMaP1vnuFwBFRPp/fM0BiXyUmb8Y6CMsH6erUE8VL73W1WFhyABG6ErTZPMpfCccj47HE137AwK2FGL53Kah+pRttOQ7SZY/dcnPDlrrcvPhaeFI8YMudExZjod5p1+jM1EteJyitMQpE4ChlyOlAmPxBdjWCyybAiDWZUg2ikVKCMDFgO+zSVMfD+a9qatqCYvbDXOuouw3JbYwuTvXw05bteqOpScBa8me884WxG9DorfBsgDLsfsCyMBqTRL6tXYalRWG/L8SZSfTaQzPtu4LMxVMORytj56qz17DdF3nI7z/L4DHUJpP/9bnZe+OBKDLBIfnfr3HeorNWLTz1hqWkVO0rOTjacfAiv1dFMqZzHY0/mNVbd1E53U2RhDWHa99xOiaDJxZoqdpr3a3W7XE2KjV48g+2VFkfYGjw4Qw/BoM2lnOk/FzUOAcdTebpHyUoIyxBy/CYt/ToT0+WacGY7tXVskMbum6VxaBEBdAggWsL1uarLclXvh1tK9apbNMMg57loOOh0fm96tYH4OLKnB0d2+peJZjZsS5dcWBubkzQPwKFKsKPtiu+A/5pq9dxCM+s08BNYecARnIHdkejCChdSHdQwVvFBbnmJwDVL2FS5ngwSJw57mlXWgzypFpsR8xRwLAaJft8KX8x7632itu15j5WnzC8r1Rm9arMxo+cc23tJQvcUDgd+ZcyZbVjWnLywugqdlUCOEtlreW0qp3Eh1V/J642SkQG1yrHEAyvZyjcVDugjltE04uSxLkaWv0Ui8BnIALsEQWqK8FdV/zU4zMEIZKez8rGKD3K1m2DCHo2b3Q2nj1pqkyPVwtEwPJlw/E7VoD257PVgAevUhhmhDG8ja0LPVyVoLJZ0WXTrXF7m9lFmhx1lOlnEFfKBRVTfiJxXXCd/I9oeEBT/MF6ZA94h1W/0i3OE2QOmeBlPmiE3zcx3DVqWkzJ9JnPcjL2ir+AnfZLxnGSCEkhS1yShE0i6QgmUgszoQbrZ0YXCQziMt8/H0AD7x/CesFhU6dNNVIbdYIQH2g574R8IawCJnmGuG46BrlQ7KwROVIxjMQfblH79R+qQIQXx4MQ3m/nrVsMIKh4GB1ssIFdLokQgQtumGKqXmK6gLHnPXOnoCdL0gK2AY+XDZYWwx6POIKx8ghiEk9BJ3Al1/5Vj0YngrieMGFjzxM7+I0l6a03rZZX7EyzxAFpBktv8oVNQN8dIbMPC5BLtlA2FLYLudjANklIVWSEZs56ZEvsTyT8hDMuxAIbwHvKy8HbY5KCes9z6BxXp2A1qNEgCAsq3GCCGbIfJJCdpVzIa5S+GVfeaXX6lTmogO+uZSPHhaWrvBWYX/iQIegxKxwDlU3uM1A66GDjdg2XYeLcgVCa+MKKbS20s+dV8M2CNxK9epYfFexC7c/F3HHabSlFBtoXU+67h5slKzYO12WMKUqBUicxqfm+Qomz9wcNZUNIxtT0O/Fhs3CbFOBp+/bXYfG2WO0DXc/l7CaDtSSpC70Fy1CH8fTbUniUMUVK9/t5W35sSunyRtXP0n9BlPYvBX6W1eVUhmv4CBENwwcCWl8e+o9VpXx30e7wJBi41A50lg7aAvuYWOy6oSpYonmSIQsGtgPVlYRNheIcRiBSBd6pOsHRqW/UXPbiCLtVlSN9KqerrUEaJ+gXMbvnJBnDypkZs4+R7GElDTPvl0p8a/n3TrOhCNdjTdQgWp/jpkwobidsQ1c8thA24VDdhm6JA/aeLWVQQYhvMXrwsO/IWtjrgU0GXcXm154QP/yU1A+rk/705wYGNuiDM3cL8NLGEiD2boeMjYZ4Xu4Ft2LYochk00YJu97EBp664DwhoWjOQVrD5EyQLgBrYxVu5H6q3GKry35VWWsk2YPJ6Cemnt28XyKmmga/r5nEQWDXK2vR/w2vAiLUECXK5VDRgmoqU/VR8V3RkEsPBKtSp+NLOUDGSaxJWJmV+16qnVwvjh0EJrh2N+jDpafAj3MvAaZpCcAKb0AHGeBdfItMql1/xPkfxFek1bxS8/S+bMgpUEH1XwVqN6/hwICZ2gRBdyGUcgQZCjC1yh5AP0YJGr8c81CDZcheELGC+fBtvvo1QV/mgck+al2SPTxW/ETPely4mQjFtYG/UZ0lhooBMuNIZPhjyR31kTGs2UysYZTKTLYKBn4of736G+gKpCiEHxC58/5wCP7js2dTv0smASbhwOiBW3nBOCbJEE7Y9kwhHn+64PurOyRiCn4AxVEIvMravxh17K8fkBNwa6LKYFErfRLHwwA2LENmvw9OhtBDXK3p64u+vciyofj5TnToq5/9LslXLNOlcAi8O2sqrzgYgbMQbimbYSxZxEVDi0P1Nb0NkJP57614BlVchlmKTanfj/URazEw1r2nesPQvpOJ4NWmCDhbO0LA4DYhNQIC2OhSXOYMcFRx0siUjFXnvBU4TE4T6IbQEymdy+nPEn3i1itzMVN4Q0lqv2ox7ZmhoWhROk8gnbUMhiV/DP0Usn6RlrsKKrImfuJApV0D9g8zEAEYXe/tIlLUOlkDfn8a3CiQ+Ef6XW1iha1hcDUDJCL6JvzoTeOon7DB1riUIDWnUixpcphlrtQXeydWkPXk63lzrmp+mpH68CPRtoBwU74FMvUtWiDjs+73AzRXZDZqTaUEHhSDHwBp1Cz2sNfRsqwhMTpsRNQWdiIHz3tXB8F3l3WcGx63tUpzz3uZcpuAvvJ89urw2VhuwXuzKgnPaquoHOHllKVJmGOcYJ0wKsHddOHyMcrnBVAUilso2Af0wMWVTT6F+qpbgEULQjNpFXEe0OkhYZjkrYxLkao6om/RTl3zFGHbOuMQMaRSeryNiO3UdiJ/udikSNFTfO6WNcPl8VRsj30Zy8KxW5qxXpvniwFDSCnbbLAN0uKXn1h/4RYf1t9/dWQ9G+xvB0ZrYMMmhyWNpRfljtTaLymGYE2ilUwUu5w29r9D2rSCH24WELI52jDVUr3vFAmqSNNWaH//A5sLbO+D3ueGFdLimG3CuYjcEL6XFwSAwmhsp9ppjUqHpxRnAgTd5srvo8XcWrfKW86so7PGHIWZC395ux81qcElelPKb/984BmfZSyzh71R3IZm9Y8A30wPimYDSS3Mig7Ozbub3MsPeywhd+gAHOYSSZKEJKo474PaZAqqCy9Pm9K+/86ph+GCGxec3E+5tNbPor5LZaDiH76bg81wiEmCWOSONd3zSMmArmkEqG7KMvoe+/QQKQap2qjNuIdC6eH8Qgg1jzLok44IPRVlfkIB2dKfw+aBbikdzoU0EZqak9WjMi1UGWeW8PQjdkB1QaEJoJJGYPpQTDVkOpH1OaqQWdm8NN73Fcj9IC7HCiBBXnsDj9WGXg6n2UStwYXVDP4YZd/56ENIZkRn8aSRNbrdRlLPTuu/AUFpKJ+XCwElLDMVyD+oQuqDwLOib3vorVxaFOEEDxo5hSY0tYRN3LA+XRU630B2CC4WVauzb43rM/VhldMM55m471TKiZIvrmbqI3ClS9kBWa3TqOi3QOuyS1dDqmnV+DsBrqI17vGZf2zso9tDkA2n4ocZe4jnK0ArTGXzvYaKxHtCwAEgIA/CHUF4hoX6zlOiFuhJGnsyBRP25gpqXOu+hnBtEImO66x97h3VZosP+iWjYZy/2Flzs5Qi/1lC3D4+xpAAq7aTFyEVSfCNa1Js/FihCfe6hOESKzA3vBIuLKkMggbWc+F4Qz5MJSDTzPLPs49yU9KzGBZjI6Om6xBPYcbndjyPqxoCVbIZphk5qIESdSV3MGoAFHn6XZFc4NqSc46Fgub2jDQFKLiiMQM5hKGVOfSBWe56h9ZmxRWSTKQ+bEz6vgWkhmhZWKUMz0rHQImaONT92CEO/8TZ5xnV23sJtNTk8f1ATLr7RVexoWCmJ6/S7XRTuBFDLMVMNcXeFYfBq4/4mbWMze0+DS21fjY/ZjfTjvmh8GFedeusuCxxUgWTQKVgEJ1ofyaLWf8dOxtykvWohAq9r61tN+jBO1l4R8wJ86nWRxfq9cmwDIAYz2Defx/fIAZY1ViJaNshuyMrWGf1R+IfpU6yPdb6nGUB+RX+/4uIfAnXzCROwhN1/oaIsTMk2YiLq9reNkr2Nwh2swnD50HPuRhyeZ4hITCcHRbSelcCjnSWOL6roB79yfZtEtK6fsa0kDF89MnMTFXEPONF9cNc9E/Lp10gAbyD6uJVd6VVshLx/zT1rLZ9GNhzkddJek5z9I3maNwkKou3FyxT7Vze4zTJduBcxBJFCsMAuFeSXxG6lxshCar+hn2c7sBQ9zVJGn4aiVKYrLniMgkZQQYW+TGKb7Iw1Oa4r3UMphKBnTV7rnCBlk3/5T3hR0WsPIQCHX+VAkdjyuEpf6/o/ggOdak8cDku6kEcJfCj+pWbVnUOsOoOyVlM8+43Y3v+HQh9ojMdOrUjG23Bjjij0aT46WPURVxjnO0taBEhSE8+xTzqFqsbhVJzsyv7yPeUWE4XxkGefJsyW6tqeSALpPfou7iRAtMqa2ahA/pO5AgfBRI1WKZrbvtM5RrnyzJSwiZZIv6UeAItrhJ/IHjHPZ4Yn5YIs0upXeKqMkYVBUhq1cu+nI1kmIBmVSMIuw85D8oFTMVHE3MXv3mXBR57PK0W3SdoRpu53HFwptabu00c8sRsP3kDprxneXV60y05Fg2KINyLnkILebFHGk0rlXqBOtSPd8MP7bW1Ziku0DGyL735tb4FpDQU07JYvLU2pH5+1tZIiVb1WzfdUq9gMQ/44evnZZRboP5SMMdcvEtDdv6sNlkM9yRwg5B0BnEz4Of0iIE70kcM5N3BPHkW5O91kpncsmyZ8Ccdx+Fz31I673J7YCpWkz9ztPElQZQr8jRIl5qHjWRN7WCgp3OBsMCNA/4CfmqW1b543IHeEnzHKTHk5m/vT/PQtW2PtPfseMKvz/SkFt7LXGblYZ/WqxnjpqHYSUH6yLxzuybGQUqsqU8WbcPLv6NyRjJupelX6sYa8whBXlDd9j9NgiFj/A5zVYq00UxeFYi+45PT1XT6iJ5/xoGdKc1g6sNec+H15AWxJ/gBn//ut5LrFewQ+M1wyXD9WqLMlO4Cl5szuOzg8ODknG+W9f4PKst4K/+wbb66KctlXgMCbbS4DGHrU/55VWOOWGPfHZqZcwGNYKRIFDIySfqwTYtUCpQTQ8z1I+lBz5o9FTa7NN/BOImCqH0Fysgz/Ur61EwKHsj+8OIEps5Z61KFKIl64NZOPh1vrJH6rSaLNC5YCSf28POq/wKH1W99aYIauDYFXCcWNEecAYuYPQgsMPJbTtVClx4K8pjU0LjcdN8jEp8IhM7CWDAvm8l+iWlXQqBwWqH7H+vxnwR//JoJ23Do68UmCAG6dc6Xe0890mPR6U5kvQLwg/l3fbDwFLfzmL6SRX5qExENqHFjVBlNYze2Z3UJKgQiEOh4dRFJgXZ/qnFC+yc/ASDHM80yI7aCdcdqRcoVlrhpPg+sV8LnPBbkteJe+vWfCdalerIRMj0RogrrBf+a9q4WM6s2G2C4FNH433XNxtlDDL2MfgxAZUuSSkUOkLfHLzrA+GkII0j/C4Ono9cjAIlHEkEXe9C1kFzj5i9pjkofG8HmEcq9qTQ5KzpoICXoaR4XAK3edempVmHgNPGAFbp3Lbr9HmdxkpBtVEZ9muKcnbRHOtabxKVhB9H4aFTIxWYJRcytyCsiokqtQqUKHIhMqcwNQk1FMSecxF3a3CGXYOruSrdtUowUCR45CBaWDX7zSXQ1PY3EJ5r9c1LbTYjlmd3L+p26OazHNbgBXtvyzWZoq7LD1dlbnzc7R6B9IqQePN4Kiwf+hdc4u2bP5wyI0B4jD6LJtLo6LqmjBYZbRG0rMQbsQ8BcqlxkJ+nQgshfYOrl6y+aSr5u6K+0POPhcJmySU3Jg7ATM62AGs2fZt97YipY6Zkfz2iiN8cvIkSfQqO9SXy4ITnn3xm/7xOxIMlHN8dsHkOVMH1HfWXqZCjCZB7vMp1FaGVRwwLTRtf+AtJjeeOd49I/GxIre0vt9859nt+WMyLfN0dlbdcm9DApuEeH08Pe88z6h9hsFkQ53TL/iFO2BHyu4vE3UM/bYdIO/5rou4TI+luElHpiY0W/qKqxlP54GFFM4QwNCV4cIBwUxZ9Tg/z4Xk0BxfbZINkCm55OwqVOh91SmdzUe74p6KJmJiq8Bqj/c+OWGCf8bpQXzC0oU+1jhaXLrh6fIx9SPz/W6Y2uwjyd8KbJBKIAZrKEDu1dAwdvidderIACNj9M7QAI/kJ7BIDM7nGqmt6XgYmhZb7h5iTdF2DcxKlbcQVjV1IzOgGMzqkPtESJOkAMgUeVTc5lhXrKw+RuT4qMWutHvFH/k/bmwqj90n5FO8UTpOyOTPU+Hc1WaDAgUgxw2lN04Yyn02jrau1mXhfxxTuDJuSoGbqvwXti3cvGs7DEI343p3p1HKXOIGdVblWpZvZjRywHuZqoG8ihfUCs/6TkUyEUeT9Qx0x3+NDAA+FLtMnqXZ1hqF19HPmkl09wjQ2/ZuSMaL1nIUq1eQMkiClg+sO2sO25HhQb9QPWy5bACEVhk3zib5QuhMKmRi4pekRc69oXgsUUooHmI9WOtmScwEyHcp9S/hgM8Pg6lUXaqAdvpp9FIxy7UKiB3Z/sZgYMf7mYHUOFDQVUUrqtrz+eu2DO8iRIjcFCTMeeYis554QKV2ZmzBZk97vXpI1RIeoDiTxeHH4CD2Kf9XdmOAfV+Xr3Pug9S2uv2DuglJU3CYaURQm23siH4JpmI5T5WPDmbxo+yZdmupM1O8RMwmXejmnkf0avGSRezBrvhWraF1LpgrTmfGFCQhzeCwaXjpnniD+QED+7sOCdm7olVGW635j9abYb/aX6Q8GaDNZ3/FqBLuKKtCvbN04g+UFwPKof3IksCmYJFA/827dwL4shvJeQU1nzEfG2H4nXJsIHmc0GFwtG+uuYfBTU5IuqinKwXxBcRafSeK4JydaIsl4dcZg7uN2rwW5yvDIsPu1IW8724k2S1ifqfBXKFJh31avMFwmpT9tdg6pMy8LUoMkn+7XGCt7FjdENBqDx/PH/nfpm4Gyebh6C0B47krH+qmjljck34Lt+JFW/5uMMV8xU/LlRdftAlFSpepivyeTrXej1VHoWFg764+ix5+tq6rGWt7sWf8aj3PKQklM3PtrE0+mIoDbKuyPSo02jUfP7tTFdNoXMQUlQ9BtyGZ/+h5IQhEG8sdbu92zRqV+nirimRcPRttZE0j5ZAUS50mwL3Fk648VrufUHOZ8TAXzgWYSHQleERuna+ufnh0e0+h2eYLJtTKWOUIq27Q7pe5HCoAzIscNp+Gubt/HwyH9R+Tieo38WxCAw3ElQcFEfgHyvtnShWUjZYJwOCKEsJM68rYB8LmJy8HnFcSMolvL0pcFnKyayEuVdVMnssY3oV+GVlMPXXB02AS841EXJjved7n8yOOM6JIrp1Ygvr/lrNGCslzaWA1Fc0HXJSpSnfX0/sQFFnwKUFtiYZkHVnf/eYN8MzOMS7k8dixUNmjhyI4t8+hiwaOYn8gX5v//bBHSnvmFYERQJ7pJak8TY+3m8YxFa9SSS898Vhl35L0z2Qj14RXSptmW5yghyrIxDNuZScVXzFY1uk5Xwv52OEltecy/0mB2xdfErglhOf2ewD/Gfh27KQJV9CZtYujIesElhS/OTndeR09NBAhi/6hmQ1qHxnKIVhnz3bqUIcSgWBOMCA6K5T4nNTmPFcAT0UDZ0eeK87uW6/y5Q3twbwu/3kkC6LRr02wZHOXdjTPcVzigBqfvPr5MjyIV9oNwVgCEcrnnsNKY4u+xCX980B4XwtX5qyevTWB+qj7GIobFCQX8B5ws9BNcuzoGIWIgvsbC0DCWOUMtiQxQKrqcOEfEsZQTD+gyMbbmu5USenhGkxH4Y4g3T8UgqrX+O4qUNmkv2zl6fuBilCkNW00NWJEk7JuOM7fBuWRuKLDtt3V3wgQWWKX1Qwzgj7Rfv9meGzQMv5OjfzjcAAZBOEnuZKBqq2GnlrPK0UmBtuquRuA7RCScwQwmeEjeXTcw72IWH8iL3120RvZP2SdWT9B0I0d4khTW/fXrvH/EgnJQdQgNnWnWxqG9EHpeztVZ1IRW8xuFVSDE+KVYc9StW/I2/jxcfEmJaEfkIhV0Ov65zz+meot2rxoBV1vd0xp0a7aHojswOEeEXeiDTr0MCFBZsb+JgsREtRpLn2h+L+cqaINEOtCBPsotnMfKsomqBHM1Ar5b6mEt7L4lYzcAl7T83IReSmXZkHWD057am5PdlfIejDTLKN+o1KQixTImZWfKOc7bb1j7NXuOVO/cXEUIYrhKCy5BsCoImyDu5bhq4q5HUjSDClZkHplFU5trY5DO4tNk3rytxebmI/vSn8CasDX9oNOcsOHm+SqWapvFBg6gEF77G0W5sa1CG/0/g8F0C27kIS9Zg2ofVvhZklfpu+ZNME5KNZP5kjsO+15SATanP+XN0yxGA4Rlbowy2WFmX2AkrNU0kNldrdAUplOeXigig6zqtL1NhteS3fwPquX/IQLPzHkeGUuEwp6okX86kjsm2VacUG9EoL+KjrEFsswAvaJQLEolb2z1kPM2QigqEtc5q5+dw53ZHPzb5APeMAtH2/5Y6Weh3UGCoSSJYOMagnRd46NK1zzB7IHHRvvothpeJKrAPizS4aZEhRDWO2nBB79VwqAX82Ta/7VVrFFdAJtOJOy+2G1goAy/+2NVJdVkchGoEUyvswMBxfPIytIMifdvK1+PyZfsZABmz5Qdp6EyeWo7kSzt/OkIZGY4+l7+c+XjZ3MmAzwrqMlHQHGOeuXiurcGpQvSnVmCsW/4IYpnGVW64KdgN4d3sMLcL7CbCkuir5ws2aIFafkPrGwYGd1u0+vLws4VF2n2yYX97ImJ6HFPeNhdHjWrl+qp5opNrA0w/V7D03lXmijFTdRuEjviI+aE4ofw4yKMbabaanfyfyhbtrplaPL/besft9zraXnDEecPlEsFoXR+inD3vnc1pwlkUioVOz/6yImQWklmHarSNfbIig4Zs9xcyo9fGmp8VMhVIzg4mpuuNQjUgflVQCjBo2x1eZ47UTj/9lo+gdMAYTCectuDUAspAERjveeJ9QRrYwdUUsYYT9K9nObD5Udwaa52bly+dfCkVMzHHerbj2P/xfWlt1EQDEWiVWoh5yx5sMtDHHHg7AJbwS18NE+VPeEuhL7IJaen5ohqwLL5jvi7zy70bcsIDrCDO5G3TvvUSH/XXgCNd9EwQhuh8soGhdixGMc8WD5M+pmznzwOVoSGbdXO2W2/5KcK4RKosIB1C5e4mjDOUJlgnmE+iGB9dpILY07Eyn1olvqqf0zUE0r4GZsBrd+Iknq2iNGUQKKZMiW1tav+waS3T1bb436AWfQ4EabX0SydFxXAJpXkr6KYzbgDbsI7UwOq0ZkembXZixe5Ua6TeyJSNntz5poZAbFfArn22uv/NKI8vqjqpzSt/DcnyWJ59D0oiOXngMcytRtCXhLlxGAoLUtWjzf/K869yY1iPr/i62u6/aZ/kBenN+yjUjpzDOY+spnuA2BO3X5Old+tBMPnl4DX4m8da4rKpj0d+HghnwR4Sj53LbA6nYlHLSvRA/c4mA6oL9KZpC988jBO8rP9+RV//aOm5BgbXe0IoiRrCGjfDnjx3jiRYEoI558HHBRyBjXyrS3oIZttcsvVxPa1LTt3mj+yjXT5lzWJoT+v+FSjaMDu9OQNYULwCkhcqm2CEshVijxZ/tsZK33FXQ4DB30+xjcIbR+ZTMvHdSvdVWMBE0dajVlkMuFyQ/OKQ2GcUjL812tG7JJpiHCO29kuMuqRhNCJGR7hpTnoACxyLlXenkzq4sjyeZvEX+KzSarBuv3+EyuYyGAvA6D7nK7QbmK1gvWZqueTYW6NAFX+nxytync0QjHLyLTKe2o4rgHp68WJGoaOxLOq6t47224a6yzyxmDXDCr03A0gV6f8OZ1AfVJ9I5j0qfMqCS2Gse9Z+qUG5tmFgF3FllnjthxIyhKguJV9GuKldgNYo/DNQVirmoq9sNPijIwVWaHSGG/UA/ZyqyFQylEY1Di33Wr5jQKuje6GSj+T3QMytBVyWyjwLTNsUeNqWO5qGgVa3ikoFnDk7zAti9fJ+bVL+x89UfnadTrFu05BV5UXASl5MCIlZdscvzB7Lx6+tPbtFU3kPrww4LlhQPe2eJGgk395B3O7GEXgHRlNqxakRxt7Tvf4xrAw13bKdDh6kzldLybfGt9z/f1p2iV6FnA6ZGilGfd6fotNzHU18/xiqCyi2cjVjqFK3zswsb5QljrVjUJJt+Bbk2ZMpEsiOXBQaF6Ce73GQSIvOIKPSVJyZdCd199PYslEKwdIUAOhWNbo+9jp2u/VC19kN1nKtQazQLxTQWQ25YLV7Y3hawCpMHeb4lwZp3IMsgbwgXCP8sfBPsCe2qSMoRKuaLj6PZL3cXlj3djgPruunZ8SofEmOxfdr7QykfOYxHvwt3V/PLOn2mpWfRMRb5GMonLdR0TXgqqy5X0ZGMIb6vdxAY3/6zLvpbLe7F0pHCX5gUb9TVqVgDneQosqdOP+NQbD8+BmOR0/eJHDXbCER4fYuuHR7wH08Png26bPwMjpkmfzSYsWIkupazbtWIovvjbZcrSPLir9sx2qJcBAOfVev6XpC63b2X6hsnBaxV81mLPsk3KdQxT9RzgNEZ7Go0340/mQ7M6aAnx6x2slzUd+ss3xA1+6roVkXxNOHLnCWRbOCVwklgAw5NFl9jr8kVMs7rbSuRzMd92Cf4HNPxrt7IMVAET924ZcDPRHYAgi85Xdg5gHpSUNr4iM8D+X76PuVx9lqMXK4q4X7pl0M4bxbaomDl8LhKFes7VbBg129pk9BvUqddwf+mslZnOAl1UEZTclJ9DsJ+t/KNZ+e2H3T5sDuIK/iv4Xyk87YQ8SiRivTB+bODo4ZEjKuZqDxxVJeVx8jJiuJ9x6cyjnUbqDtjmUPQ10ryEyUKyxw0SGSTnAqwIUmxryvxXJL48nj5yTryTW3cNmEGwE+qELfi5qc70JgTMK00/YZmeXkPXDvxb83XyZGf+lukDcjfuBDTyuWXBTrQGJqdjxQNTMnGIJyXc5yblyLqusFAJx1rUu3aYEe93n4PQJtKPAiD8Nb9uTjteQzjyDUuSbQyJZyvmv9oSN95/TehTh5F642E07rUVQ7grCs2DPPr4oyhMMXk7nliRDmLxw9j5BWp6Rb6Hg8OBpkyHGC0l8UrQWRtp6kirax/Euf15orfx79qN0fgyMD+9VyxQHVoLW2CBNckyccmlLldaGy07thBAZkzfjkgRpgs97rtF/zx0q41aibsDh8JiMHdfCiwRig1McSKbkuuqyi0cbAa5DQGPb3J7993+h0J2NQ7xTwMNjY3Yt5IjQvwWaGITerp6Dj5ui48IZr2XxOHLvVhLccbOGvnpNbwgLL6p5iI5Qn2EmYDnxUwwCph1OCOOD/1vhOiOFCi7xUG9tXQxquJCvJbQIa7iSkiSNQqET0igwWGAZDljJipeu7nYsnFYwyGrMKUIelL553PscIHyHQqfqm5Ld4EwBlZWAQP5TSCmEO46awH46bArtg0bBvsGe71dyJVSUMheNuUcpVRfgIWmZYrXqQTdCrZLNLMTyZUdQZtgWFISJ2Fe3TEonFQUdBTl6to8KQo+r1UeJaFdvHfRKlJjLHTvo7l91T45YF4NyDwZinYKYatfnJfFM1T5/SwOHe1tF9Fi2PYkr1CwUjlm3a93OXlciNkRK+0xN/8bo+cgVlITsx9w9bSIP0Ce5KVB9p6TAQp5K/A+z3n4ZKCsgYl0tSJXAKI3RQaBZa64nOlikJVpoOoETRhqmvpGZ1G411iSimhiZ+Lqb9Tlar4zTOJBDlx2wiJej4o3JQ2YlGn5VuhWa3TdDYNFR3xWBSKIwS8IT0udSIw6s0BKdfZnhJzbK+UcrXyFc6Xk3KQejzSP15t/YmkzJXM9/CxxRidUIJAQhvM7cpGcKTivAk/caDJNbLETzlqw/MoSqM1QaLq4zoT0viXrg4E5tro7QZpwCLHcClc2wq/dR4pwQVsNQFuN46fBo3+HYrtyZ2Z0AL++5zVPOxnl2Fu4iSt84R7/C6zV2QN7akkhNWGwIX9h5zt223jz6r3esDT+Azty/3m04EyimCZlSTi09bNyZy1Bd0M9z9EE5NUH7eM2hCIj8ka4NB4xZtWcpmp59uod0/xmF34r8CsF+6f6K6VjRkmqRPNJSHWHzxBGxdjPBeloAkipZrqTP6wCRjHHHEemppfIbR3kwqtWXzgWBfPmMXDlLjFNI6YMvdt2rNC9Y14XjOROmLUgfLyyU/rXYxajrgt61mXMu7BVH4lUEQrMcPCYkCZptZg7zU/FP4UkhSasoXXq7Y8TTeY6xiiTKNT2gzSZAsxw9n/y/i2QictMZ9IW3DNEdbNWgf2p3Wyw10lJcHwt+LGzXhLCmAcyGDFH6U5GcBvL/yhH6uz5GqeGTNB4NLIpGyoieFfVrOMJ8l95zn/0On5BFX5G9AVJuDnkWf3rra4Syuk0RzRzp74xVpYSb1S27VPPZTSqi4ZOCBHXM+4UDnzDOsTQNDs8ov8d5XgUgJD7BOMW1VQlNDBda6WBDORzsWkkMggKvOZJwGwVqlsfJlfBgxO15UO80yYAp3moy+rVkiCmqhWKkC0xOHVwJfGUBDoxOHH3a6QHr+1dvh5najT609lujgV8Ne7p3bsY2J3GBWaLGbX+nrkbHsFsfruDm7OQuXt8MBjDeFzhnzG+/jgtWusn8Uctmt4VS7Gke4L6Dgalmu7ihdkBgQkrQ3ugg78wWTElLy54E2YNGcfoWwF8+ekQzgGBe9rQSLAjj+55fyqxAuClEZQQpHbckQ8Gm6tZvbysnRDLF1HM90vsuRMT4Dx/pcexKBgcYsvTsOSdC0GlWCAItfj/jecfa5pJrtUBymztwuMO5p3dlQ9NcreozjjoiCG0OmwloBCVjVmZOcGnJlZJD0T5Ak9tGPzm1cjJxtkDIunIUzrowNl8IKEr43hueqHa1v3l0+jT4jGby0zP2Q5OFPzUQNZRABH7TcUx4M3dYBJrkE8PtE2xjNwIR/5zl/V/W6WvJO6zXKZRL9nimXHSDNBdTczCX1AVhDSzhgPOAMNR/D24jA4+VIc57mR6pG7PObRH9jTRnbRAyTt0osQhrbGaNKEXRL+bPpirqQPNRkDBYAloyf0Eo64YC7YYu2LTHhjQIQnvQa26ZT15dpQ8TUKPl7rhXeUg5kX350K76abNTYNPUy5yjp/NXJ6gODGea/kjSx/G2iwdO0XHFZL8/PQ3/4/S3OlDdrnphNpQexmX//QTfBKRNjLO3IQ2e/mIBZSyM9oGzP34VlQG04LsB0fojVJ/SCoFt1uSO/eHpl0wnsoAKHDicaImyPvreYNUF4/THAOxvQlfvUdaTZqXfTLCjkHjTfe7xz8RrRDJYeEFx2x1+qfDSw6HveRsxQRpL7yEiOpB1+fiD/Rgo5uA+84Hba17/nGh7ti1vRsuR3ZYgXcaAB1XLUAI4w25x3GWpSOomGAmXv9fl82xj+YRVCEyx3REcchnZHjl3BgbW8gD8Wtc5/x1/wS1Vdburz5YliGavVkonmtCYcmH1Hb0rFQIHvM9NrQExExvpXIHO5stgscg6MIXEwpB9gnVhI2Ut5mG84ptPrnPMmJMRv/F9gpztmHH73rwsS0/HEUpLuVxk6k4g1A4jJ6ESDoRHzxS1SJ37MLxxz3tRryUqWmhaxytu1iS240Z2Z1ZR7GeFYh1PrZyGZ2Zk54Bk/D6AvgQenfkbCvJKzRJGrr8/7a/IZgreZr8w872mv/GpD00+RzoBduicOOe3xGX9o9Dj0HfUSg/YFvr4t2jqHDB3XzME7ANrqsZO5QhvyHZIsg81nHX9Ot6qQUvvxmaUAREmvCVkL2Q9UKI/V+r+yrCSSXLzq1z6OFBkhHkB14J1n4tOkAgUBTHogrn4yxlX+X8yotTxZNtPj62+UTYY8l99Qr3bAJAYNO0mntlouPsqzXFIaVo22ZTC34jJr5jJ4M0XKfgb1GxE1bTyaKIcJRyA3re1UHrvS3LzN7vRbRAfsF48Pm8r4docafCiU6VOFSvl2/yIs6R3xP9awz8pcBeP2ZSwZDRRPjOJhoSVjWNj3vPxbfBbLv1mzK4tZ/fudtxAJuclrhEFnUw1gZ5UwBupTf7lgDLw9m3KVCY63bX0hvALJDqruoC8c9X4HULrP1L21lljNDoc40TZCq9ppDa3IHbK+isDWB6CguqYga9Q7MBcLckk/fAdVcbhZichUCNmph/4P7TCWrc2oi98qEZC7xHlVuVyIZVeRwX4LCdfmqoojqgwXpKOa3/dXFbkbwcEZPa3905JbAyugr3i1S6r0IBbdfK5UxBz7vl5Tx4c6qyTgeZ6Lo9bE6ukkIg4oRn+QbN1qU0Bl2XlkHwfsKwKGa6BsgpVaPFmpmLx+yQgXcgCKgRP/oo61C9ZeMPfIHt90B913AIOw2A05YUw9ZOs1VPU/tIw5H5yVXLGx1XtYySz4ymrEnJf3AOpG8cdeS5NjKZNTK9nwtt3KIttbQ2H9BOwYsPP7vXc01Kj/DWbSxJDqiYI9C1qR1McPUNhUJhgrvvEdJDPe+GPLDbvAPIJfwCYpfMiA+JHECzxqhkc+ARWNLUhEHO6RBCBjmsuCU7loYGIx7jRmRaMT0tHVDaLvb8f1aLutEAEfDpIYAM7yjk+/VZLaOZ+WThNcNf/NPFO/EbW9XFF2MYpEKFG2htJe2/azi4SiB4sClBRFDolO40GmVYo5QmPHw8yokx56mUj5/JzfyzIubkzaAa1IsaehTQxnpamNb2HbqZX+kn9Hhn9zrkxZ0Dolx6kZ7ij9PAW0+pLXe7twLso/MxELEZ9YIZl4PwlIytlrM1I9j8s7aiBEyEJuOrWgRM4uRAss0EJAJGWSgpx0594OG6cjV43YmG0LYm4+NGE4RmL6lgkPVqqStQf4ilc+GKMEk7QkaYt0JcmB3NwAgEMZ5CKXUzTcPVFNRxhATjrD+eYIPh2fiw9IJM58i57rYIr8jXG5yH3fVu6C13lDcxUzJSP2lsOrjZ5AsQMz9sGHhSDZ+kam9Nf1qNo2xgDgnYXcM6V6cJsZtTA6Qrs4OsOe+Jir4+dgfQmKl+SY/gQwIZzEJ/SIbMrW8zdY+Iz3LTa8bexyDB4sDTz8MSsMuq0QKstBiRlgl1w5C69sCpr8ffWQ47lo/wQZ9I5z3kU5dmLaEX/BENZT2SrlCvPd78MRwZFH9TBi9zg8JDDzHWv9oOxcqlYub5hvDkAw3VBclzXDJimVc8CTCde14uMcYDIMF2GaFGLxHINZM/iWo4HjouDQnWtlI3faUB9pkfdEZQHKDoME1Kiks1ihH3Hwfw+Uxielg6zmdFTV2/y75GehRgyEaYOgCGQbgHL+i5cYypXNefdjHa6YIR3jYAyrAB8MbDPaDAbtUg45+M9uVU0uG87psLqQJRqooB97LIh25c6zkBHnaMa+0pGd2XXj/cYDms9xgkrCpMEaKU91s8a7S0U+kkig3HzAz8Pui2029DTgbHUxg80tViGOwEp4oO8jUNvvJtrtHB8S1BhVH0jgRyJapX3QIDtS0WOG5hYuTTc7devT0s23oB5ueCz8mhUzE9lk7I6PrDetgXb9zZtHnta7GkfS27wQYmpRvshPjtq8jPOwBmF3LSeKql2cVtj0X0mMJbEsPR0j7QpLc2E1013cz/lhGOrMbeWD3uM5qUUUUlftT78qQcWF1itmu68+UeIVp6CEO4K6DjrZuuRFrJtVWA6zrVObk9Hrg7w4J5fpnqftHx0xswp0f+LIlbRy3L35ekU67FIbw+ZwCL65HDX2dN5stKQ3VAmgb8YEo58J+H1XxAT5RbnHMqd4kzP4JgUG+cnNAoWmy9cWaONeyJrhQMC1AOM4F+Bv0l/mYokSy9IgQG/6WfsJYAE2gqA2kc033V0QVGv7s5zB/BWWZTWOjOrYS/4oFiXnmYRo/NuqeXQl6nc7sY/AvqITNXIv9YM4Jk4hCcGm84Jzu+JJMGZOHmo1n+4B5Vt2kXHB6Im+0sanqo813u3CKijrZZuiIUniVbbRuT46JGZD+bAfcn054KVhmvhODOIL8v2Z9hRrP//ubZOAyq6fXVlzpFGOu5W+H6n9dW0fd/KP89CbDjJGL41kXyeIywPRMWPeL3SbgHSyR3BsRc2YIj+KMpxI51JVPz1ds0NLp6MwN2yb1tcxb5NEyeRsrcHB6ciujnprfHox8ROHaMXfqYRLt3srnZgjDKUuOHg304HOeW2hauNZXLYocgGfZZuJbjZrAtWdfGuVgMLJWT4RRGprTqZET7MS11qcu0N45eElHeW4UtWEnq93me1s2e9R/8epzpP89ercPKvmwdplgNWFs0Up4nyxxbqFOffx9HK1baY9Q8pX15QQA3qFwr9Awuaw8q5XIL+dZmwXCKD+kE2vxtIp92IVKAALLDFHm0ceyrM3I8Ro2Q8H8KGm6O4C76Wm5+YCkuriu5G+RL+o/Daz9Sgnvt4fQVFmG/tRSnRfTn7WfEXRSoYGgmXdyuOCSb/a1SCN5tjEzjPpCctpjt4RubaqqKMD/ELtMLCVgeB1xFUxyyp80TOebvYPC+aaV37hyBiSMDBcLWdwAMV8p1Ezu9gFPd7MGkEgvXeOzTPAimgtn3nsPJa7B20TYtrRbysxuV5LrQwBxwxZ5DeDhNaSVatMjDqmXznXS23uVWfgBRliZv0jMpDqwwqmvVNDySBNWxGH5cGgFXKduxNFK1bZ+FsnAR6GVry0n4gU2lQ2a0DBijjVN58dlNzB7G/t1WnRlTIwJVwGHpldtbKCCLi1JY7ho2jAHzgfG6y1ZmsrC70XAO3OiWoW+Dttyz2Jkp+Xah8Qwy0cMoHey/26f/UCzotapFKYWxGpwbo7Wa8Bsa0OudM7yKS4geFZxPr7XQLxI8gb6iiBJPzbzFxBJvyqxh2MwIQ4KGKYPVfo0sgGja2suy6b4NwM7x4OiJhxC9/1DGpRY1YSlwJZkUvk1e9Tb5MX4+4yYg09H45h7PzDWetfH9hG5VNY+22Nf3leFk1CkO3064SU6b8ZeqOJdvCfYb17FWY4VvLXnPx1L3yC2INaeLzbKkuUBsmCS2TOwFEHeGisEEW4ePkuEVcVq8Mz7DByi55c8mQGut1A5w1sXzPHNQkiev89xT5zFu4Qi/oOZN7x8msKPRUIDiPihrn+rzMVC/K11uJZHLhibwYl3MSMY/oA15Mq82/Bzh9cc+Ivqx0UCHQC6oL4DBgRN8rF399ZA1VttrDNByAdgZN5y8s2vx786Jpc3De0qO9Xv653sCQpXyEbbKsZzb8jLyqcd8tVl/GCHiW80/j77gF6Zj/kS664plpOcsJTu+//DD2b07EMiH1zsnUjr1RofoJvhr957PjrhjWFKrEJovF9nyNK4qkGe/GoaPlty63z47vuWAx0y4YzwCAmbGUqqLspYvGDnuRbRqPgXd4uAWAiuoj1X6H/8NV2TUb2vIwPcxsko7P8YJpRwlLhHts4PVfYj4p7dl+wFToIqtixpVeOsKbpaMpxORkWna9LbVbfe4SLaKz6HEerD8XpNW+k57952fIBZnVfhoLgIWToWJVya+i8TvojM9JI7KhlbEKWQ8BZZEYMiMBvQTk3lqHxrglio+znCSL+V9pv7g9qCZVYNtM34kJzN8Q4Irjh5UckWGolHJiPbG0LyD8omitbd19gFr304Rm3n9yLaJwWpeJ63kCszjb3/Ct8HclcCP52XXsGaX5icfBtM6sfE+aWMP2MbdviBgRiIekrl3G5CY2UgLcBDTx7MJeQYz7ZVEZ2+j6yWdxUWWX2z8EgypJCfwRpv0CG+wmll3PqBxozlB7Qnfx2/8yyVFxDvGXjd0QlH0ezKIDl3tJc181r+HBwOLx3VcsAfuJZQrGesJ+jgov2hNTmPQWg8aZOXo82yZ3BlTEkjXRDqo4UUFwLpn++HppVr1JXon14yilutt+63Waeh8gJo8ExB4EpAa2S20RBE3soHJ11XYQOCM9GMu4fyhROhkf1/PA4S3FSrATeTjRR3/KnaWfh9NB3CxdTxgGYP0yTHS7CH671YoqhRwz9dB7HHuZeXbBL0+t/M4SrL4iewSs6W0H3v2eZhITwQSrrX/fXwiRiGe7kVZfkNpm8AZBr/mmV34helM2qGC0I0k3QmUuNA2uyTOtI1UvLHB03aUwdZE28KbaEB9G3vNsXgJe46rG81WxwVPIve2xvSfrC5l5SXh2RPl4qrDrVNfHFTMxAyMZ88GMkX956lq9bBu0xCJ2rL8duMTdBKCJOX4ztcyLa88Dw1sWFRcZ7IY0ILcmIrL++bPKns3s/CWhqU01p482BBGj8yNFSrgW5zzV52VGfwJAVzPfoHzcu8nC5PdcX0VmEPZ0v+Z3o7qBrF5BEM5OyDFb85DC7dmA7f1JsGThtpCgaUe1XAAPvQi5lqYKsP+8bzPzQT37rOQaOpDEdcbAUunVKss7Er7uwobvwqgweIreg8kqcpjof8eM94obGhxkdf8b4ud/M/6fS+wIlRjtwvxADi3TnsaiGSTKJ7ar3dpqg9qBjiuq+Fbv5yRLuS2zhZXqM/jy2jvKmd7pQUYHAQrgiU5YJ/xbAuNg4Bpc8m550a96C5XdUCErf2u/4d2TdGgGmCU90FMp6rK1vJ056IwwToOhA9Cp2/kVt24KJbB5XYNH61Zkf5gX1AH2OOE4zpsyV2mva3vDOPCQicBV9IIfIG9F50Y0Y+NkyffFb+nJ4+WC7F5WVuvUb+6kewb8l0YQ/z527uhc73Jj3L++ghhlPBb0Y1I7RcUCttrFznyl1EkgitvhJ2XUIQfvCNRblQTOXqPO7+V5IiXdZOWpCBNBUUIc7diKRGS8974v0GZ7qSJkNSJ0/RzgCVDtK8Ps2ycQxT/g9pVxMh/PvNVczI71E7f0JMMpGVZvsgTtdLtsHsGiLQ8AECQC7CrL3+Zbnsr5JqEMAHfZjFEluqNvzLSean+sxusHD3P5g0o2yJWE9A5cYsnT6wiOSMVT+RqxyAeKZSMMMw2JKdxHqIGB1mpPFGJ1MDMmbfOnSKFsevO8rDsl+fPBvmh9n5ty1hUvr7Cn5YWbxQmRxBkQaVlU3zpshN6NY0M0sK3C5zmiw+cQc0x3jnr0D4yeJD5RBR8CeQX4qt9iGlAsNYuEIgrecGqVJTMC7bMN6tjwHHkOyW33XuTsR2Bx0kWqotqY8zpLqPh+xG6gy3FqCr6LFeK+1LM1oCEgsfcMCY9FZEAD+FMxD6nZspmK3RNaQ3o5V2embeL8sB8We9aLT6rJ1KAy6VFWv+Jeg6iIJIJZ0mjR+U0AOyRuNxAmOvQv7Jdq6IoIPr7eZSYeX0QQNFW9alt40PUnBBUqsFrtvtolxNZF6EPOHxc47L5Qot7HZtFp5/g7ycsr7NrcYmEDgFTkLo2x2WCBqnKrUcJ+9c0S4yCD12vy/zXg1oswxA6Ir9XT6oMvseolmKj32LvMkuLXPC9JdIR/XBLL9e0z7qfWp2Vv+u2LVbyGCcJpzzcnuUiElY240vFHwjFr/E2JTud27SqnCYvQHQAZcSUYC8NnP37Rfphb4FShERYaZHkPXanqefnZSplqYv7v5qYOanhC9aftGQX24QH+o474BYoqDHq6BpzQAcIWY6IlIIBdXUYI6FjbD4N1y0jK+7PDpyq8QuteRAvoEmiUvU37ZWLplonxdE4+pnOI19WKNtPsLNDAL+dLedOJYJwPPO1u8DNkg/GV24IbpzHMEnhTUkoR84wgtOr9tb0K3uLb73F00GNYBxcRJOK6lnyuu80tiTft8UaLGU2VU0wkiZZjrOVSerjH4l3rnuuJnVxFC+1XNvOcAdcaCDOHdyFrmwT0KxBvPZLb6o84+wSWMWWQ/8PVGI9tuDThjufG1QJgo/SdU/JFp6knYEdN+YDi/mazmqkcAt7L5m+7XPvr8LB8/uLLRD3I4kvBgWBIupyfNI+WPLIRZ9bk5p5RkqEKUsqfbTe7V7KxsOGlGji0Ryd8UjSNxLc+UvT6q2XLtGC/uuye95YfMDZ6VIxZLgiFkqxVpQ5LaGthQjXZsZvHqphyEkDm7AkhsxJp3YPPzf9IpfH6SC6s0zlpqfdrnKY+Wga+LzJyACikIxpAZpEwp9qhbbPAu0sjGn9OKzi1xFeS4HEDpCGsX/+y2PY6bcnCq1M0lHO/y2VBGQkCU2sRMrXI6u9GsqKHSMDswXHsmdE42i9xzosDXGAmXCG7Ie0w9y+R5p+bUORQb0mJcM9CDYFay3XPgZ0SPiX87NOjFW5bfUnAalXVFCwzW9pXCpcUrpUSDZoDIIYLqhBzeXUYr8O9FSLXTgAZXHeNVIUcP4759J6m+NEDSa0MzsqJl4gdWpqlG/nyAMdG5zMY8Yu4fNADhl8G6vZYMzBsOJJP68RiEDmfV24zPE7dF6dt8v75DMslbE7RWHIkhXexr/DuAVUZRLcUWRm1G/2stDkSqp6BjRvub3l5KBnrxLeIdg201WaDgRvvr5teuG7p5Uca1N2T5uKm9oENAVVrglwVwEW4erR4r5n2+Tab2iMb6rjdcKM/v8yn2zM0sSdeor9Y8ULMVRrXSPdgv6RDyjZBosC7dxb6IEQa0d8g1rs99uGcK4MJOKM5qf95NOY1fU8Y81ChqP7rZfRR0v2K9DIIY3+EMlPpo8QYubJa6nKv/PSNVFLCIV4AHcIBDIYGq7uevefTK6ThpVC6ljb0uxkumPTbJIB7+6/Ha1KjCEBh+R5w8R5WglZPAQyGQD9lU8F4/Izx+QknhbMFwtKTIo3BTSBihudeBVq7QWDaL5TKYzKdcMQq7Zez5bDYHwBUYoV+n0dFYihzHwcwKs1cPMgmyeNrvtZvdx+/+ba6Icgp4+CEaTa2hQHL3AqwBDKHy5m0Ysn3c7t3Tz4qpffSveJg82yMStTVXaTcmO9Te//uJmaUT48KJXYu74r18wnR1u+4nkXkx9VRLtrte+68YN04JrfH8U+UsUSmMbagGezTzytpHEFryhgt82WeYFDtpaaA+XSBqIjuerd87gUZ4hNaNJ0XpW+QRRa6GQuLIpXnNltsNUuhmP/REtj6mKtX8YVxyFTQzVq6cbixww4lG7r+zsuIi/rg3V1qDHeHGplXAk2Ld9wY2PFwwHcrw9QWIqXPi84qGV4UhrnVfVOqVh1iq+CYl9JsrUXtENwgxXzDCCRkUJNW+aBNoIfwnaR5NBhkNvUf1ZoRVyNTvf09awXDJ5bb15maioMXqa1L8SEPrJwK6r5LW3rzjhdS1+42AmQKwN9JJwYBDG3x4Z4n/tVDIoXseUgHJuQHyiC6xqWA8WjLDtSoINt2zEjoV8s+buHt7q86Bkk2Oa3lcNUyNhVLkvZNUXRPl7RRJTlg0QQT8tNiG2lKWBFwVbuDURN9l8wBkEiZYc4DuKVf2LRERIQgUdWvKSpnzjHdY1BrsZyx3I+syFfWCueM1lpB7KI72yW1YsnU6dO9lSbnAE1r8vl/2m3MEUGwLTFstXEMiMEGR5EQGY8XrTrzpMc9zeTx2zIBMPlAFich9iZWwQfrIiPtdf7P2Oil7Dm/q44dTbtYRZqouULZjGmqefH52FTrrLgqYa94U2pX+R1+rTvuAG84uGdGjbC6D0h+3iz9y9ENpqj9ZBcA/AhMkiiitcfQYuTSY5/W6i4f1C9R3cKCA0VOcUQghVaGPvmJEYbWo9ksLp0uQwcPfzfS974c4/WcL3rKrozq+0lJZ4eJzHxW2p09MPn8acsLnXWLmOxAyyTHFLLNXJQxv2rcaUVjRNwc0ZFXuhCuudAD1O6IiGkspdDHoq8Sw6Hf7Ere7SbldomrgyGNjp5iuOuX8CkSaJLGTt34dDByg3gTr2ghIT/IWzcmiNWBJirFe4L9lH+930rG6vqNEWN6NbK5cjbLizb+4FIDov3TV4wmwYguA0TAdEP5qwRnnH8wnydptLjPiyHRZXp+yhorfgPhwoHQZbuCoQHUX0rPr3TgGyKI14corMNE8nk7NDDH8CawXshh8zse8H3im/GkH5xwDOTmaPFX6GGU14hbZfnHRmxCd6hhmDW/4dDZF2ZTbvuyMWR2+IvvNy5PSUlw5Dsxc05zI1y5XlOwJujHTb+clltpodvOUM31OdVFaRRfL/0l9H9UmGtaPgigm7PkPC/QcvleB/SF6JMOGwLkb2WD5Vqy7Ta4kZpPUzGnA+gSN6RNgLB1fm0UrkguCYvjVmFVWoaH3IEMooECnv5idWQu4qR8Rrmhqtq3J+dTYbTFUwhJnAa7yY+YCMTnFrm4nUSRIC+18FvaXwb7eSS1jcMnQxdx+8JHhqnhul3QNJksTz7qE9//1o3jSQkOlNF2Di9PbzhV3uTDb9OXyRhH976PKhVUVFvdN0VIdxuGutYpH1QsPvdruN5S2z+cvT4mfUWQuDDTRc3WSjn8Hh2NNULdHy7+JXdJlxzfBmhySBlSEGGOnKpzI40i09M/lyt4Jj28bfQIBFFACyxDewtdidDf0mKCmG1wWj0zRkMnQN2PoYh/vnu++8s9U6Yqb02SJPYjVhLg6yXBxaTNMn1ZBt6+kUlYWOF12WHAqTWbytt+GfmACOK0CETwvSloaIIHH/lNUbmtp3KoV2FKTBFD+PNO8fs1Pyp0xWGsk0n/wYpnDb7b/qd72ZHCciYhmpd1cSD+9yelvIY4IX4E+b+DouLzHaGB2MaPu74MJzPNmxhlwgP0qC/t5JPf69QbY+wgjxAywjIyjHs6Ai6FX27SL5H3JuoOgH3BCqkxVKENz234KrfWX53KvxAgBpGBHwQCxI5XOSxwnHhO/AHxyoMbFlbBhN7hAlOi5n9Vn7mXHhf9jvazlZ8tRpZDbNpPQ1QAknUM7/NC6I4bw0cELbJUZDwmkpNtg1DnR+mG7I+y8SeXx7Ycu7pkznFZaNHFrDG4GYL/lpYdX5zZCweVJH/1iW3UR6T8byJ97QNLRtiJtI43jn4QLTKxMWgCSCTXse2gg0yvueZlRoK+BR1+2WycQdfgFsPzxjlGq+Ghd2R+xMeeBXZP1rmuG+hoqFd8PKTQxTCSB+tQ31MjnWKJNYCF1OEr0wJTnn3spN+ZUYhD/MwmT2lX+wOsSxNmmY5B8fDwI2BsOajAj7LWHmidTYLkrub/mTaYjpgcmgkFr9SOKuGhXr6oHVYsRV1anh7+uZz7SGIB0NwhirRDhaa7gf7SCzH27hAyDHZjV6qRAhlSLSRJ9QBC/HCXyb1a2BtKKxxJCOfN8Yuflg/kdwz50byP8YYHBtD0tZGvoVTUGLYplDIkkUZWG+dtK0hMZdVQlhkkXpDjNwCEgdOID6pBnmNidtYnALv7/rUfqT7iRSW8VZRu1ciV36Ol8HpZQ0gZ22hD/52N8l/lX1BHMeZL0yotuxJP9eMPn4I9loTZn8Dfjt1K/w3lceTQ7Zp3fxvkqndP1f8eSkorfipJcw5rBAoVQayCCnKvCpbkJKbfjrQVU1JACro2rRPRE3j+Nm+Z6ywbWe9V+wFpXrW/lJcStJ3UVAmIY2mujZ1l9gr2QG2t0qmnDAg0vyDCguYI/MMQ+jIgwYAi7nNfLN5htcxS+SOSqz1dWhSKIPceJcFpOIF0w5wX4Bza4Wq6MaRJtzu8VYKdV3GzTvvqGNdVsX7hFnjQRaBlqr5qfXNZ3dfIlNAMzl2duDGtGHI0xlE5T0RJUaQOsDydpTATkt1qgy3cVYPS9ZzPZt/TY+uM5M4L60LyoxFXwSeOLR5cRb7qcVSsGCo9LukaF0rCNZSQEi8i/44K4gHRJdoXVCsP4X961XuH4JonggDkIq14d3msuwcZ1QEr2ZrRkuKp1m9nWqSnK/Vwh45br/BLgacZqkiNXGY46pP++BaI/vPgE4AhvaJZmocNfAGCVhHEu9QnESya7zE6FYHkT+VDW9Lyo8Wnmmf83zFh3bbvnyyOM1cf9cA55BfL2f7PonH7x8uQhglNEGG0rB6uyrOEFplc/OimioQPh2T3ksWm83Hg8WF9MybuwoaUf6VuKWYjzz8BhseRZ1A6VtIqHy0D4rGLCFE8pujxbRfGoyieDEsYvyu6BYdskgSk5l1B26c1yvrP6CJxjtnkj+JPzqsNFrABnXYGblHKf46V6Gcd5FOb/w9DBwkdQN73RKymUmpzGy0Qe7KOjGfaaXGZd3i9l2OnYDBxvcK0YpfM+768G5LO0fojLFgSYCYRnQA8Jjq08mVcw4TCm+zayVerMV4kbHympjcGgMH20J79NMhMNGTA8pzNkGBHWigJMX/jyEvJsR7zriSNGQjk8/bYQ7Gu3YkXuT1jYyIYya/vKg9uDXO+6ycujcG9gJ8o/oOm1lQMFr2epyGQEQqzA88YPNUCCpJCzI6wHcfC+Pv10fZT8D6c8dV6Zgzv3Kf5cwk/syaiMsVb22EUzbfdD0Gjvj3nE72dI3/ZJEsZL5nsMFB+/RrL52xRXypBLBROLsi5KaJRQmPh22Z2RPS+mzS23t4JFxuMUiJSDYq1hUdgbghjQ508fG+773VWB1Hf/7JVxKbARYzHptC0pP6RBcgX8ICvZ3kUfsYI3p1/mUgzAiPutYfLHyM8nIrEpdIWcXk4c8cOfTjDb9xH5cRYAGmrA2squRKEAEyafXrnFndJJ42E18Awbpi/9gUDSRQCEBKh56534LlwNMvz97N7YEayv7oKebcV+/F5mFEhDL3oPjpaMwx9MRUSUqX3JhH+I07QHP3mIJkkW7d2j5/GdaqPQJ3o6vxmOaPiZ7hd4VGm56njypMbG9TYT403hkXcqsKk+GoQhmdEC+2PS1mGbQka0hilJH2tz72XI3vyRg9zu4v6zHZbRxV3/v1cn+/xPjU8fLCxKy9z/tFGzn1TH34qsx/nyrhV1U+saW4A0SzNsGChDixedFd+xZvNFPWCjcA5y94ZFGxDd4PEM6U4kS5tIARYmLXToTni23mMWzqMr05FNskuX1s9T053l1hMl0dWQA+nnrbc3364eZnAnTe9Ei4PiJUC2yvk0s+3htVvUxMfJaMc84ShiKbOoWYaY2Qk8o8CbfUNBPc9Rv2Bm42k7Qn0RF4VXMD623CICQIUzXrH3GBxxQe7N3Xuvmp57rtyatquuzvtxFV6EaFUsx5XkVQJUkBekZlb6WygEkghaBTMtIZ/ZXxsHwdgGCNmlsShI+SPINOnyuhyr3/LULvwTpcwgHSYWTgBOGTb0BfRxOTUp0PXFyKXogUUNqWP04nwAYKRdpd9sQMUjsWcacNZFStArxbAi1nsk2Ku15EaPdA4mon98IBuFH4nnRf898l/nz0DG4bxce3D7OW6BC+3j8J8YW7uBypw9lVp91Eez/L2E8lvFQG7VlC2uhwNuPy/RKEfl/FyfoLTqTFii72mR9IMhh6palbuWUhE6luIqj6P2uZbNo9slJT40zEdmJCF41dhnIhOMPjHlTViYR1c2JIjMKpijXcNLpBvVhrdnd7Wh/pIuHo3r7y4fS+IbHNOh9H7YcByd4sRfmminX32OZ+AGC3YEDJZqVwSztZ0f+rV35oR59jrwGtCybDK2/B7EeCPij+352hCmJuNQu61D4y83wEy7v4EVm/M7yHEw6zc1f6S6Ljb0wGeZFJQ7rVhq1CejHClIm3XAr0V2LWOqN3JKOFfbrZNXW3cDXiYteX1jQ8/eAYvbB8bJg+HxoenEDqbES7MMb8Ym/ETD3ko0SGQIBXHPCUwCJ6tPr42s9psFir+2dZA7zb1aMMt03GsS+8SJgma5ldGUZ2nsZJnm/lCbsm8KAFHlCsLE5sdgkxg4+b62S3w76FdEA8fBYjWkVfetQIzpD4/AHV+8ePfGZWQlxfvk0C+GhNVaFrJbUswlDD4o1UaXNronu2VCrptA2y5iplfAD52OSobJL3tbU3mFsDo/aYWMic+uGdunJCncKm+eHfgmYDkfuavsqVVIBijkiRp5Mldy+7enHY+1tyiUkvoqSm0In2XrRD9vGPtCyZc6HVpkF1k3xV6gUVrl/k2hROL0YfGRkdnVhVBeV/dvboizwHvCa5khlmmv9nbc//lRkHhBd5q/URWxwf2CU3YKj96v/KX7GYkeUfqO34ai0HesDvrVOp/KOaM8x7ogwd1R1d7pFF9PxGgZXueAAvvQisKn26L38E2QlaL4osoOANJnQk+7TI2hhWEGETDUvx0O5RvYkVBbA4lBe4/wd6pfjNePRfvV4GhVpqSJj3t7aJ8DhKsEUsyvNoHnsEn7w2UPURayrtI82wGU/mFc8+o0m9PjCtm2qwdnWDQXEbgfsTXsmcpZlYP0UQ/z2BTxEcq83ea09APSnow2lcJGYBIaJYDi+DCeUvJEvK+YvBMgwxauFH0UiNBVJAMH+1prhFOejbbd8nGP/g87Qziyv8t0qDWLCY46G7vU82/EyYFMEGav8v7O6HBNw1cbogt+dKqs3Slk5d0WTnxRcdji3+UkYRYlWQytRCaTzVqox1mLJ6CYvj1UTmIOP42Mjtbck2HMoZYhiHOULCELKKQ4L7Ku0Lq6mG1fSWOQ+sHf/ExE12235ND+dTt++MAr3SXKTzjQKxN6bXicWw3VYRxc8tplfRIPUJx6sjzkZYBdj2xWvCtZlD8tTGqsCMdtZiS9SzbGfGIsoQZbKznBXhLm1fDfD3M+Eoqo9dx6ryJDastiH8PhaN2weO+ktRImIIUlrh/SWMcqjV0M5a0e24/sIwRM+hHLRqYvwJOCxbe059ufW93JnlyBDVI749u7hSnY992B4AT54VQP4iGfK016haheVtaPZ6ueeoZLMfTwyH7K5DuGioeAM63VAvcSP7F9mT3bqSp/DCmxRYeKbBrMFbwDAW/8gRB5PUN/dJ2ALsv4bDGGKxQ/wlcrHoZg4g1VVOrO6WhtMGEDF4wZX42lnRNw9ZQBjWDqM2oK1GX1zlaaR0ni53rGVmu5uTWavpERAMUwIGDXKQj56lBE41Dd3tYQ7xNVVdouktkstQU+yQhRl9leWPFBOBd7Zjkm1qK9ZcLg+f8YIEwfhvc26qp4wETssx8UAb99BwSbByEyh3o2/iBAzbppodz9hV1/P9dnd0wM/BY+/bzmuG8ZrQubrhduQ/FtVuTUe/v/fKTKvjoneqt4diD/jV3NvA/hp+qTnvRfVs80QGk/lmVMdZLC+jUrHcpL9Ca3F2gwYAdBpINS4zSLMhma0TAC93wIoNWCTC+xhqyay1DDN9KM8oM/0QkRWK+CStpbDxBndYixv/WTKd11rEvfp+YEMvDcxj38pydeYIkqkU3sffoKbfV9Bzd1F3sGuG4b+ILR18N5EjTRqSaxRqCylN2oIBAP/fneuRtJXD3V9PkaTH1AAuxYuTBKysd/t5dYaKRveJZbQyhsGF28h4/I1udPhDssEoY+awQYDuOzoIDVKKLe6t7k7PXJSqsjlpQwsdSk5WFLHfQp6ogexUo56R4wzmHa78oHD6de2NVG4hT00YRScBjkENDPUYTCRzZljCE11ZCxG/38ZHH8spKFtDyPYslmPEfSGo6nwjt88pB9UWHczfSZc/R+OMgdH4P9gS4Q6vWpBMXr8QsUVg3ryGP7xDrP6UxfRxQZShlGVta+r4XjpxUKHtoDq2jLCOG0b5VtFZXnOKs7w+nTm12FVvlefJ/swflyMAp+Gztn6WvE2RP2sKqxP1QOtbLOeaIr0Q89WNWdec98s6YOSGgUNqGZJC903L58ndlU+9O0EArRYJ3uVjSUlN7t1qOV5o6PPVgmJg24JJzMbn40H4MryuBbUEnjS1hzgbEQ19nGIbnvgY+8a2V4HRJtguuTaCxGOLvZv4OXhsNBCXht4dWSDW8QXfCeF4wtXgfKzgBFQEeZHg8lXj/0U9VJkWfS07+2xah1f5lae3g9A8r20IbG4NZ+89ikdbjywIATfiGCRUCZ7nGbZWh5+BOrhNJ0ZrRRnIf6JBFy89Kstreo9r5S3h704jgawFV5Zc7qG0ZMDtrnDAgRP3HH9+In4oUuBm3wWvCm780jp5L9b47dpiHKotLsMNhoBlOYDV5ZpTZ7RfnMAu+iHqa165REJ8giMzZgMgI402BTtJtMa16ntxb8xuhE/4ahU5piESMXKmywdBcxqR8l6foiL/0p7AD5H2ArtP9gEQG5UvY8fDR+qFDEMH235GM7/83j6ge57YI0ttYE1fc7OfXpHWzHZr4Ae8VzFIXefvPIz7oOk/GG72ZnIBji8qe2wd6LSo0/wZ6hcLu6Pr7SB2ExMO7/NR6VzXb5sCil3a11dCOTUQcnYJOPvvAp6Huby605gBZROheUDuua1JXSX2OHwVwjHzTzpyFNp5FAYo/HDmV4F590pfPL6Ra8L5RTCywmyuJghkK14PoG5HT5BRrzO4xL3tmAQALdZH0RMO6HdZ9qRufHn/PN/pjKYpDmia42HAF917TMwo/eZ7pHYcVprT0Aic+5LkkEqY7o3SDWEC/ykYqjzSMMEhPluS189tuC5cyE9uwD+39ekFnhkVbntjGlCm8y48zIlT/OwndMAbY7RSu0rx6ia7iELrQ3AFnfbKTdbv2joVdVQB9TspURmN6rKTuRUZRaTDVP3dOUzqF52pE6QDyEs9bVZRKDIHxLUEEdrLqBF1tI33M0m1KJclkzPxwzcjDDdslbNRglk7kD9WrNufmVuw+j+eaTU+7nMviozZN233lTEghBwSv+zQ+8oGVJLd5I5cxx8hO7sd0VyEmdvcE//1NzvLh49QasfunnYwkDhHhWBeSH6mG3TvY4bqwi38mW49AzrKnBHs3fMDXGod/tRqY/GfhipMQ6ZiLm+DwC7+tfiO9ueo+YcOgRHgmFzw8BgSRHignLCPYWSmWjQTpy+NiNbGpKD0f44fSXX3yE1vVO7YuHWnKzLCyujcoXQ1Nhe8DPZkmTqJqTS/esHYSkw13iD3L6+JE81CQUTZ4e5ceWf+6vY5ge+QbKqwIsQ+LQpi7mUQ6/QfmzQd37bEdFjK7TbSsdBc2oiA3MIP+QtNoI5e10jKaKOUdBa8Ic3/oUNZ61Jk/KoY/+Mk4L31TvBqNa8Aebsh4ntFMQdgizb8u75AwY8VY6ZfDC+uY1/sNW1EpcyaBApfUQhYBB5wW8fvRtxyysVZs5eq6cLnWZkBYMQ7U9lXNDukOPGE8y5alkdYObAyNUApLgbMrs5sLLRaQqoQFIqAUxrAMZ1FlOSn0MQBtS+lAeoYUrP5wFPPfORXCI4SdzxGhKexCML7IhjM8AhYt1TIJJgWj8byKZnO3OVkna8i9X2iUvj5fFWy0XUZOoQNK2jeB9jXQZDXKlS6RMVY0YClMMJUkqQh9ztcJx1Odt75zsqIiPe2P4lOMjlrGAhh7u/TDSMmCGCapHXKhMG69N48c0CoD7ZXlyFeyy5Ce9jS6+PrrVjKAITLtMpF/5mqs4vAq4bjUp0iInvQCNcDGkfrlFPsZhIQTiNde4gsZTaeud0ql9X7fXPvZzEeTAG2rDm+u64ePhdTByflZ/DR9401R8wtCFSVeJ/pXfd6qcj4bHcMD88xsWCxEmH407DHNLIFMSQ8xPvv0lfrcvCgOnyhrfiGzIpJ+/QJkPJ46jZaTxpcW9qls56YIjnSIJ/zVwaoI9x1dpVCh2mr8KOWnW5BgLGE/eJYhv6BPEA0ocYJxNrvajm8XLcSgAnekJxk5jmzefSp8cM7Dv69rMHkzsN/KJZ65B0RKAabgTvfKtaS5SOq6PxNG+gMhlTup/ogBf9uZsYYgI/4kDnBJk/0t21smI9hbgtxy9JEzb9rRykiV+SCQCRqNNzwTNwri7iSKMw3sAMpIag1k2LtSVPHAdxpT4QJxzk2vQ7e3r+DolV04mZjRyy3TxBU2BBMrF0QRpMlblk/sS3nHntfXBTe7e9qlRonqTHDCm35gjyTersF9QMfeso+LnY/7IZT7ACj3Wv2P83EL6OQq4++zaHwAL4L0bcLZQkoL/UFcQJpNKm73l6fPzmHx3DQu3H42TJq0OxosXETK5bKY9mso89nln8mhZlloPSVJVsr7EgrLWSll2kmpqKDlI+1Dk+2actIS+7PCdbYsRI9nTWeRqiTlTFVsDmYT5HVpg3QzYd92J4HUDYYLAxcbgBWfVb1fuclweYVcoZc6gRXOPPHl+OIp9e0StjaCpDtKHNn8pUPmu2VmPxQvSKvNQ8Bd/IInbIReE8zPWBvGQrOtjWqtdfbMC9ZhiJvU9CNjAnb6I55hIBuOgmevTLu5/rPFW6/mpMziJ6QvYRE59PC4NDvr2sF55/1AxY+c+AymBTZNz8plLXYTvpQAs4nCO0bJ4vNjYJAlNxgAK83Z+WVZ2T7eeacYITfRWISS+OdrN28tgHWaBVSrI8ARsrPKQnTolG7ds4YBk0ofnWaOPRuMOE0AdHo77ifqXvUx6A4whKjlCXzIQ7injvq2bS/A2UZBkkhViFNwpMyvghp+iBU6eaYTMIPAOR42nmV/vxiM6EymHmHaRXzdj7zSC1Af8hZSVZkLPD6iNW/cPAfK5s6KNgDlslLGDw7LyYNzVj8GTJ9InDMM2aUaPpn0NQHf/Vwh80q4CS0KvXoE+azNgaBVPYAnnnGpoFGaXXEa3j45L1Bir6XUBsWZeMtS+7Tj8vMhJ+u4KArPd0Z1czLA/35TgQY3jPdd0cATLkqHLwS+0OXZ9u+uR8voJw/qyygs8UzWj13a0COcXZwG8CDg3203DQN7k380SKzcYm2v7LfnVZKHvyX0GRLLvfcVLSumEqqQm2BHVauZr3BbJeCOrQGvkr3CyjiOBlRboZWztkzlwItJlwGU7y/cqHekX12eNDM261pLXdaZ1PB6Fqc3OIVV7POF1oYKTtAOtnmBLVhfZKnLIlr4b410SJR4pXgEtU01lSOcafvPDEtOGbbyUZCgm2DJZj/YfwNUY6arJ39Bse7Lj9JpjvGS2X25weiTx0TQ8M1OHmDdV9upfLHC+092vh9PrHNj0v/Zh4LpPGgqRIAMeBKyDI22f7gZ6licefxw90hEvMNf12KiGfKX6fq/JY75jzJ3NMnH/4tlAHnIVqgfvcmLUsOeA4sKcjT2gg2Z5fvlQTD5D10J6ZxyJTrs+2ljvgxxNbdS3E4Z4OG0nRpk8wauw1gmA8BvzeN2/wMZ2Zp/vSo35PYcTswEg6vjmLIZ6KuL73PsxSNI6KAelW4SRdga7+OieA8zTpTHRbXJlcnQBnDWpVz0si3ke8H7AyuiepJirQhWfXuOpirGWA/qiaFMp3qWnXdXqN6oO3bwZAjdxVJugGgA3PPOiQEeU9oA3zzeAhWHKlH1s1dHItLO5aaQxOE7M16r9342YLJUkvofODDA8ue0XLF+5M3bxfJ5ylV6f4fBNOhFL5ma0p0s1AP/ITrXlk4O9oEsNZY22OR1oAe+8CUJrKXFML/m26Q4weudJ60MoIzVeIM6NavxX9g3OFIUev10W/bxoD+Fj4y3QwXi3+StwlW900MiHY2aH8s3Mov0xme6sUb3yZW/zrMKwKIMs6NI/aniG6w8TBl3aS1yoFo4UiiGpdPpjkIwAEKiVvQIrNlH6xu5B5HqEDjGy+onOuFu8xvrEdUSjlgJyTijpwSQVnNfLrejY8ndxowccDkNg6giBW4B0XBN9dF6GzujPfmYdgfFnQpZE4Cj9khYWAlDsFjiG//8564XAxRSobJsmzfSeMRcAnbg2lMgz2PTR7xy9vIsxFOEgqS5ipw3xZpa4UFqknDe7kSa4AFkr9BdQEsBXNZBzxLexmarCk2ebn21kh3xIAEWd/t/hZf/6odYqJKB4Md343nJC3L8T+R/iaZyxGFafn0lMinsOntVjwaBeaFeQfoFYJ0MWq+/r1+QwobayR4M4sGscbYXMVNdFbIXJa4dnF6fP0PbrWM+W7YDI3vX6mq30PzSkUNCZOinvBRVT/Co+vQaRuMuOmHYDi5tWU0D3xeqTn5dZ0atzWMaSZ+8/o9T4PQYaGUiokS2kCE93AwVD2Evg72PFJTY/pLgkiTsNNvyp/TobpuFYTFOuT1O7H66lg/wpDhiXtjfx6WfaLWbaSjVBpGusjnHL6aOP0jwBOHsYCJRPVmeXjXN1Aag05ora0J2aquNCELyqGIh9LPpZmF0AOUmLo1pWiqlBIhNqpvAZktaWl4FXmQ5ZElUtlpfvPP0+jYKyp/kkvsDW9lQr+ei3Y21lLiV/4HzJfT3Yl88YGdiOzbLp/XMCcQkIwEsGuwA0grNxgJLSWPl417Pb0iorp1WRYiQ8qrXo7x5IaEI/tPnk8p13INXHLuVZBMcCsW+Yw0XZLa+EZ7htnfOPKy8VPW2wvWmlx64Mw9RjnLy31a4d5BSb5jBQlHpiAID6k1hDJyQKgSRysQUbrpER8b8DFVLyPxBPxMbW63jhx/qHBrxHSlrPabrgRbexukMBlB8SKsujnhyFldqQ36JGb4JOQ+3ciH1spo+vWdXKGQrIQWeQmZw588C9bFT4+3yXcLcC8UxP4FSa4JVWY/B/eyYevXGIrqnia9fmIix9J5TA4GxQiH1D+EAwczW9Nnqd3C0JBAkawiSoRCE9jHjjSDiCTPIDrkg+EcxnUKeaBS+z0h7Rr9PhPiE42p2+tXd63QUvGd+QBV/9uGmkXvR0qKRyCdp4DgzNU2xeHXt96Bwfh9unG06EIx5yyoTIGKBI39kf/6TruLFoPJgDaVUvH4xHtEUzBN4IXGNrYzLd2y3KDuKZJlrnwFIny48kGcFB7p5iS/tpQfBIBhNylq7bEOMjefK33dWRoY1rlHvoXMMUxPZIH4RWycyEiuMPwFO4ov2AcLK+M2pi7+FbhpBHndaf7C7Nh/BKcDzgE4MIC5B1flrLezHc4wHVGpWS7htkd5JCz9t2o8c4sqXBzRKDl+9KJ2Ho4NdUYASnxNsyEHNGfbBP8y2/qOW14JA71T5FDBJ6UlshOrbLapHSpGNK0ONa/v4lQmQBQaZO3PtEN1BEIMNNOC/WGf2txRv40FdZ9LNIMNkmk/77laPbbMR/Eg0juWnnokmMNWvivVZ7VnbdvFXVrEzfeetmzJxmwauXzY/nvFFpTRZW8bk8oEgZrbtmT0/IWqe4CReT3QQfLWXjAZcEYITALgcSaHyz+1jeNF+YPuX9ZUhBQcvu1aQAYb/DsztwCsoG2PvNLHtZZMniF7ptS5B1+469GJ4EF1J+DQl6Zj9pGlCUsp4dEEEF4NFw7gEwnPxNRhYcPLaaROVWWBK7q1/pSravaROZOF10S1TdXu/dsA4YCXG3KQmR+5dR5gq9mQrqwczNWfRCYGHbRQ08P2iP3wJarCEdqoLXdlwkDB9LCfNZYYYFtPbORo3SIE8PVYPwYOI/OYTYUexO7A6NLr0+jnD0Kqu63k61489ibSxTRMzcZJqbR11Axkz+F3J/yywXwZ2aI9NQfi9DcwwU21GMSKbOUBFByExQmeV+VZm13TeTXpPTK9luERkoSCLwZtJHY/bawYN54VZ7/1AaqY6Wf2lX36o8PNedy0oxU+46mnIMN28GiCsotVf8TOiuqZ0Zp8HecFeebmiQ0J9kVXMjIqXfPa/kwDaiWeD60UKv3GlDLeSc5UdEVjPyFEVf3ySM5lXBiWNFZe8GnGFppXf7dUJrwdlfgiWxJIJonOsfwpwc5QzhYd6GQX/uiwk5vI7KTDrlooejOmGc0Hc1lr2noKwBLW7sOJia04BYD/tlfKofF0txfkfxtXacmqBajWY91SwpI4J4RA3WUCTLRRAxM17C6GMiIonG3AwJplbduKYE7/pT/v8B7l0Ey6KBdC8uJ7b8ZSynX5nJoIrl+AKEraJxVg6+J2x2QsVoJdcIU1N8g2BC0vrUs8VrqF6BvOnvvleMd5MBhgkRHSiN0JWfyAQRx24pvG29TM0xDDC6d4RlqKqvefh1WwrzWpVlB6xp8vUHH01F6XH0e2I/fqJAPByJs3rab6uEbMzlpm6YO/jEBhAr0/1djso38jNJgZvgiCcF6qABLNB/7adIOmjo5Koo6YJqWz2mTJz/BOTEOsa64EicpPXtRXHVO4fNAM7n70ymC9Yqd7plqDCqHWTHvUS7FnLGJkOoKg9T3uphkWEDPLFpqCL1TUQ2XcbynFv3VlDtYJ1PZrmGb0s1VIgcgXtZ46VdXzLYk1rBcAZMQbJumGt8OgZmtDSc1k4iQuWIxNN+plOmPU8TxvT4yiKGxrpo6Zur58H0TUbcMP7rbTxyqqPs2qbHokcX3P86uv5CMySpqow6OWnlnZlMeB7JAe8MFPEEsC5pLrlzkv8B/4z/xbJfH193QQMqjSB0lQLkuXjvXKo/1vEAYenZ3T1LLcsmqYtcTv36hfUun2aW3SNRSOEh9cN0IqfIpKdb8KEtpQFsUjOHjRQ0Py9n2Q1UD1nxRgLJpbK7GgGimpIo9HtvOEFMsmIKBM0JQ1Vw3bPlssRakFB8/FbCOQ94LIStLMJr3rp4jpxJjKm40sKXBy2lHe2T/iqpvURloiU/A92MWMP6gkdqTz3DSsimFZlW//x67iwkJhyAJHdkxDjB6Bq9ocH3kQ1aG3efabkqoStkmilJDFIiqgX2r44pdGRbpQS/yVjGOloZ+SWoaZzdFPKtdc6bTn0dtw8jTurTPKY4EibCYXO2Sb/U4nc9ILin+5jIoWJg333DxPVt7LdME9dYkI5IWrwUu8hdJezihKxlGgCW7vVxlnLBj1aBnm7ddO5GfWVV3b36v7yyuZQ7TRqxv9s8Q5LltVa1rNOvtDkw/5fsleojNZ0IeidH/+6NZPC+fn2sdDKSkNCoR8VXsQJihbNQa+idfB2qOXaK0A8SMO+Pn4ajXYZhRRkQNqUElmoDWwvvMgLLQNQf1hpP97+p+f3MQgKJvUesqdsYUC9rDDMbTHtnE4Tu/gUQuzPiEiqRec7h9llKVppbUI7RfRJoDeHhwixaCTm1Bp6u9s5TQUraSDEjhWer92I6PTlIi2c0fUysuikUfu3YrMv4O/QZ3EmGipGqOLnM1QbDHPIfbBMd8MbCAMDBWkAQEIBqh4CuAsDLJKOMnApRHnOzO+Zu2aB1v1JTbNFNEE3j3zjGejpVWWJ7kq6EyqTNRI9xcEn5608eZxq+pvW6uH/9GmWEI1+I83zRS7qbG+J2PRTyP9T+Eg40tTgkR+qlA/7BfGfMe2uj/6zyyuEjGnActWEzqtgoCpiyfBFBf9JnMK9y5fl2KbKPVBoSUurjmZS1q5p1IqcbKS8A9+LB0Clilli6Zm4Po5CRz/c3smfptDa4NN2a1XC+H6tNOx7r59AzcoGEBlLe594/G0EkM2yGAx/hvXh1pwDR9u37hC4hslqS+Onnnu9ivS/n3QSQwfk69B0n6cEB90IK9JxdHlOcAp5PfZMhN8uSXUgsufuZ3RgsRFCig6Z8VgBO6IAIxIeecHPWJ7wX87vCPP41oA/vSJsoCogo0yyfx5AHs3emrzpIA1TZ6UU9TTErKMwyNYHgXnIOnghgazABAbACxqXMKCCyxRCk3PTtLu/Caf/KJL5a+GLR+hMAQ4G7+2nrexptJbNoJJ9Rb5cPh2pKtL3NTJPOjlm3nIW7eEqm279R1qNob3gI21Ph/QeAOhMDzGDuyRhJ1aKhNdOCU48ymzB/voPz7UOmOOa7CN+jpA9/ggPXSW7dN5ysOds633XoCqa1HE/gc9SPO0nNRB4uYeJt6eYUvUPn2d1cdh0Gaiw6xO3vrRxb9OiFTX6Or9VwYOUYc4t77Ya2r/VQPCvEyfbE2Blu79YWycN3g9qz/Sx8ogV376qw4qmPHrMJRjE7ifRpywmvikJCeu6bB85SK4wjyG4z4Hfmp5ZdJqHFR39cNAoeVuA4eg+nVR3BLoNRZZ+ZDADlwT+a5jiGiMy7WZIb7X8VZoyWmN4aMWB4sRFRWKIMJMqypb4wmNXhA+ywWGnV/UKNzHIxEYL2A7G9TOSjsP+0S5CjgjL7atJSDUbSna5lBHVSj8eU3UTLKYvrVv1HWGSdz3FGjiD6g7P/b+qnRYKI6rwhYHPWiwj8LkZFKWhWt48pl0WjW5cNCvIE4KzkDtQa7/QWDZAGAjueksJYSI2l4b5JivgDvP5gz5OawDW7b2t5v7IJFk+bIXJjMI+D7ZIdqGyd7SajISIAIip5IxX0sBiHunY5mwCOUt4b8oIxxFPuGlbYuTHQyZ/935RGDZGuD9NydYj/hGBm94Xg1Q/Mf75ibs/4M+Ote8eNPGn6oSuy0oR1ifq3yncCBwNF2vE9mdMk4rR3Zh41Mc/hQRquqScAOHy47VsQHOoWg+5qJjXpbpmQTId7E4DKV+rWjsbe+q7Pxf4iV+1bjyoiHW4JnG1AfZTcpieW7LBewTvNGdmHpcU4aWjaMvMmg7CqoUvkPba3W1wY5ppgT4uihVdcDRMgcy/l2xdBmA9471T2Pg0tka0gK1Q/lAnXBf6H3PoobEZJflDKnWWQCq7WSK9d9+dc8pyBuoRXabRXi7+nUvGWi1W5YgshzMYvPx6vlroPlEUVJmx792LlT++jt27pcogBLo8Z8Igrcb8wDgMev02eeu7Xxp3ky+NSmVjFthV2n/6pnI4wKtQOOI5YhlNZTV27WhDYxZy7C4K2Q7Gr4lCoejSNa/3LA+oK5uE+CJ2DaQsHLue/o3ZkQhQUW0e6kwNkk+RsdgGWYeV6QKNgP0ZPxnEzEsqJaKfHTeZVggRgHGJaUref1eGfCMwSx/0XprTSqaZ8yaiv7UKCtopcNYY5dA+k5YgpBNZayFv4NJ73YswEoPwEfYInAgj93ZsMBfS2PkAJ5tah3V5eqtyAJwJIi1hgCC1g7AJNmITkF8UGt8ypX25L+sH/AvFHCiFZSWIJMZPC1bZ0LBc9xMDxb6yOyLDDRCoJrYD6sp526Z9t1YXUVk/Nw5VzLgi0HU74bKoEwfydJZ7frNpe2AiTdWFH4CNoOafirUYsBlswz/EWC2gkAK843RJPq+AvBM+DZO83LSENLHeaJmWVkLtzPp+Q0AgMLV1QuT2qTAJymo4njX44PQyXLPv6TzRy5ic55+d/ybWq11hN+MPK8JRtqF5kx7pIujgLkNMesLyOASPD0O9k8eTQ0hA0/tlsi/RPYRsGwJvGIlNbJ9T2RF9RNM53yeUhS9ZYEQTNBQawPEEaCOp2u1yozlLFdb7OT2SNVrLECBO7pNohh7g8+HpiKZCHJeA0mO5JXSHU8RvgBw85RzrgqAlbyAKSd8Rv7QrLAjxxovTkYcHSzCfRvbvU7L2bHmbD24ZKcupahfsMGP7ois5H5E/dDiUXkohejCOvJSlF7e2voFG7Cv46XGZKEouQ1yJlsTn8jFIZpsV9kcvIYyDIGDHys/VGfCjf6HFAk0lWwy96rdOSi4W2QPNqc8au6cwFZtY41Y4PiJ8w+dOTehtQnrYUh8feVUD2AWlKgQplgNGCSUztSZWW3flpeQRvWfkTfO/Guatdd5hAQXd5FgyTyWGW87IlUNu43jgL8J7FVXmlfi1bSAhZitX4EdNuWk7FxW0n3e8vyJGhsBpy4u5SHCOhhCu5tc0HdW/V+P3JdD1UPvyZ6R4UrhMTuOfaIyu6W0Rz523t7N99gyJic6lXNoBpUiwhg0bVdlPP1f56GHrZew2QClthWgbXe42AZe8K+wmcc+D6Xjkz5NnOGZHI5dFGU2fUHtI2bTTM2R0H698EJH3GLy3LOZKbnowV4IKHFnezjblsLG+AHj6BGZoDmH2BVWpiwejpxsHC5CPBfJNS/R/8zhauuKKSYK29PnGcmF4HVWIT3VYaC60/HLJ7ulpy46PKQzdwp5YvFM1JcG2ISf7CEMUUhSBa4ZlsgaWYsRWIvQCgYSq3GzxPMOmk5D5wbHty6pe+M1vdcFcHNiTTi397gaCVSUB4K7aC6HxLLIce/gApbF/qUdgWtG/FazDv+DPEEqe+piJQglsy0KSF6xCyYEM0fAgT0kSYsvCbuN4rw/7OGSxPowOh9qOBN1HBUhOqF6ircmyfgVM2+l+9b2WY9otWR6C3GFG7hQfrKkpbHmmTE+YihtNuDIM+wM2bClCW0ouuvqaxrUX3Fe4HO4sxPVvvbXJuVeQP5K2tlVsYfIndpbnN5K3Fge2sfBAMlHPHl1L3LZh5Gp7G55HUY863si4WxM8dXoR+ZJ+RGAwCi3hX06v2egUEtEl0xEwOaY5ZxHKXpkOSg1UwKoN0bbnKkX6cddD+U84qroCisOJIngpR7UncVMbolsPZ7jDcpL3x+shJT/+mWQLOie3YJpqGAt6vtT+ENTXR0Mlst9235HTgFlaLDXmJLi+b0hx0QbcuqEScmHMAgiN7F4HuHUN4Pb7mV3Jj5rPUAroc4vNZLDjjN2EL3U1C+26htw+vB9piDnKOsfCpGaubpWOuQGQmZ+LtYFhFYxyjeaMvLp1ACRX4ECcJK+ftbaNCNTNRdJ5MvSyKAF2EsSubJ+Fzu+eji1LYwmh6BJc5JWL8FFu0y0lBLETFIjvfBUxAsSCW4dofV7iWsYgzRxFECtswe0HzrfEnbWswXAhg9lCqA7Ufdh4da4ZwE6WnbENPXWWPYEbNwBDEumeKNpv/JVjDzVVRmG/DUNmOnwEdGT04/rzza0h3YZLBlGiw23c0ANybpg5pyKPvYiGHZ8z3c3Q0f5b9kBqaCQOSIIaA4DmmQpAaVrw20Srdqupkzf/sS0QMD87lavjVB5H12Zgt0Nxran5BKGakkHaEzunhNxWCJuMfS2qtDlHUxrZ053SOGhhbWKWt68/Ke0PpXQxAznl4OXGjP+u2VqSgE2mzkR1vSVkDuJ++I5K8UsjG+OXtJU3SWxMErcUVLDSVCYOyPxE3G/F6a+2LEgWC6XrDYwrhOkhzhAdBtgljhV4RpsVyjCPcB1esSk9C5XbBme6wko1Wg1N4VpSnDRgHgZJmu+NOZFA5Pz4hVsY8f9w2d8PDnzUX6Ly2NOrQ8S9KJyQDp0XZVhPyt7D8RjImWkek017rhla21mhsFdKsytiyywH6xQ9/cQS+gVkIF1TjswqZf7fzbVkAaSxCrEmy72Tst9+eD/4jZCXILumGb+h3swGrfhFfU5/U1KU/rxZ8PTLVRRIu3FaR0ZpNJErGyR6wuI4SIJ/ld9XgkuWknFVzY1+FdXtv8MaiLX6IByXtrdCCMgR7LcI3nuXad0134OCvaOz97/eNm7tAACQSSwneVj0cICIVfb8MvtwT/RiAot4vh+82C00DpOaXOvinmJqbmJNKN4CLe2ATBcdrOpnf9GYFQ61Pvk+ajwnHN6TFrVJpBjEBf93A89Th279Lqw+usxCCNZch9geSwMry8z6yxa+RcRqsVKv/o5H2mMVe58MXt207v7j944ISwaA4ibwirD3qLi5p6H5AAW5AfrjVLaqPvw6DqmQAV+ZgjpXj8bJtxLVpK7Wnf8nqx8PqV0X8c6p1paAkip7R7C1+7JGXeDGrgcjuE5kpT0fuqXMYAmvdRdhS8ip+OXT5yApLYx5L3HZR/PX35hwsHpWeXsHOslyE8LZ7TwI8K++8x3mbzF1RZyv7SX7JNpmsGsnJEO/AindhvZjjTwIGinuB5/Gkw5QkjwtnzZZxjEjU327buLpb3parM/korFCS1W5Vmpsc7Mu+1rrzBM35sAwQK41CDhOb3q1iDda/itILLELZFiQ1Sl4of7O+ueLAJzfhRxXNsQE+cLSYYhfLPvfY+IlVSsL6tOEyzMiDWhTPPp17JQ1h4BSU4ac80H9VNwTG7sF77Jix5iR3YHXWJLjoDHKDuAsN14WrjI6GcVeiQhXbgP+6gPAwld+73/TzPrqXOz81MEnqyCUO4fCJrJjAED1eSOil9ll4vyos+pZPLWYSnsMDb/i16+gLpWtVMA03KotNidyexiyStSH2VYC/emxuIw9Bs56BHBZEZ2cTS+XV2qxLMFTIYUbuwFVcJ4aLYYZfob5I4W6kcjPdJxUdyEC4aoRJCF7s++zriwl94Z5YkqJRLqsUWOIfVwdsqhlrtAW0Jr5nwCsz+G+uYVBALvEyoJeQtLk/7Gf0MvPIO6mi+qthskO/GCytnEFSdGObCzVRVhOvTiTf3bw8n/H09sHgB75QW2Wq1t7OkMIT4FX97xQCVTqzcDFGcia+oSpXIPk+xFMdz9E8kesdj66MPkqvV/eAsyYTbqhP4/NEisyPzRUEpJXena9l1NTIzecRztqMzZpp7j87pH9g5rpVcXVhJlXvKy2INH4e2VbMTPimxJ6lG5jSVLnVl7R6ZVajGGBLYhCltbGhOcHIIsE1PZpDH5lKkT1HE8GPYU6qvpV825M9IXewaqCKhQiQ+a4JaVNk/KC0LLmefDqq4Blnqql4juhW53hDTy/sweS9YP6KYtxUS7uXngY9c5hFzI39eXX25mGb8P/JQtQUrwLUjuRhr19vYmDQ5PST6JF8xFcqtmjE37CLpO2SKoD1jz/C4fvapXzC2VTRM6QQAQIWdxekHqowMSyBcBRftF7RVYayLD96h2axenR2LZeU/OQgjvuhw3rmvvwOTp1elbnf5VoAMTvvaFZMva0RdrtAg3f6ht8a/YD+iZi5vITCDJB9brOwdlgqjRFhv/PpLmMDoodz3GxDRkAT8AOEZns7aebgBBtT3Cj6QB/t+lgDEzOjAoXBkTN8kEWn6fGzsSmA10tHts1sJaPQBm8W3h2EEnFRgz/g0e15y88koHJCMgmMOXDmPWmhiFn3PmJYdYmG3IJexldKpmQd0lhqEZmQlnQs8Ynu/qCuDcRyk9TuCyOnvTnmsQ4x8m8A+116O1E6WaLgEYa90VUaflasv4wjRbExqeDe0B12hur1waQ9UfIJskDW8nf8mblTDw+OmmVMx7H2cGmFAhaYvCwFLzIdhdwiymr843DHacBoCW1HDLj5Kzcywr6vJCMNvYiPo0QSQ0KCiOvLPa5MvZQF2btp/derao9uP5gTIEMVwvtFecXcHjTaC1sS6QtN2QOF3sCTSI50CRfrA7nYbol6w8RVFMQMKXnu5hmPtXmCjC21d9Xc9xG/lx6vPPwgTsa1NZzuOw9TstamZeKARJSgNy1O5/oqYWCiWpuN1K/KhUOytGSp4d86y4m6HlmkN1AOkykOqt9b4FRJaWzxtZC5mmcn3jbCvLCmRn+Xujbog6UAR+e5wVhzrXrBgdjLEPO+d3XdQnEF4Zo3uY2WyOJwX0rlPTJzECUCtlvNNI/KxVSqND2A81TMV2PD6xVOBge7GOoIfmURW8X6qrQo3DF9/by254QuPMVMrYCAjgIPz9GRzeqnoxzyO/ecz5hqq7VnsBZnxTGsIatrp3Yx6IlEkizg/r26TMGaaIvc+cHRmgJb2RRtlK2nKzdc3TwyUzRW17FvCCFE9N+sLoKvcK25PXTk5yKRxz3ihIrwnfKiRCJggQbGInx8ql1GX3IBnmGT9bcR4ljkJZuMFYQjrDgO0kYjkzNmcvdLc9nuZQDbvc7VztqW9HrteUdjpiHzuFrcILLK3yyEmRp/TR7iZE+1dAkurMgbaJWs+7QQcFgRYNTnEkpUtOLC0y3HfAUCnt6BJdrwD16HLj+2+3AH1vsSBNOAb/8Q5qY5M6HLrafdBaPEnleRmFBrjxU3vHjc8tH9LTwu2YbokD4GKfQmUM7jnizDTIP+tSPM4GsLjMnhzMeAeXeTdozu7930RY7JZrKBj3I0ktlTZrnHL2lpcC9dMOZyrE22JqcyvdCXnEtg6VS9swsPGRzP6oIyoqTxgoYq88WccIYqEkqeWb1jQDF9oY8lbQLkPhecXK4groebUHXXAA4dhpmMXmDvoQFLPv8nLyzHteI6MDbjSl3kD0UTSSy4RdfQBk1IV3lY7j48CrlEI9O9PabmnNGsJq2r+r14kgSwjdHHvhMjGeN6VXA/WQrpz6pSGD9PXRgS0U/bTsTSZsRdJrJJu/wIzHQQzd0W1fuhr5xAPFmupLOg2w2w8fQZ2w1iIBK9CO9feuOFsBFvazkXkc7CAzJePQReIbLReHzOqm3rbXDFmp5Xv2/GL1RF9CL3vNIGnyBJsW7u7wQvXmiyLovRM9/sT79iZxZCsrN11+4XOMFzHGH0rU+eNbpYnXdT3CCoGgYg64v0x94RlUquj2Y5QAq25dvRm2hj6B6U27WoB+1jeckX3eoXxTx6Av3buqDMURSkNJswpJlAaEJ5mMnLb0RtbPTetVHftlNJULtsp6QTjBz1Tv9jOcEnHgrkJPyxHHLkDb2izIDLgYNmFeU6/48Tf78M83VcJ9yhYuNmvl2GUhJrYa0i0j/71TmF5w+rJS6JoTDfli3s16Au1/YjJC06lf1MUadwcmPSbZjkFhi1sdNVMFLzDTZ83bOrhX5RWmZz8Un478b4anMBkCSOwTRkXmzdyZriV2mh5FtwgndvIuDwS6R7I00QWqxdG9OXK3dsc95k/BYQoA+OpDPTHTSwIbvqXUNJ84tcnyPx+231EnqD50+gpt/U/p3224u0ixHxRT9sLinFVyfT0zCBWccrjTPMbs7AEB8e7BeIWqgRXt0s766/LxBOTswVA+YLU7sLkgukrB7PMfGqtnwiKdntB9TMp50V52A0b0NqvIdoUHX/vfaozyG0+w0N2Gp3PNHwFwJhpMfybC11gAJfOVL8YVs3fmp4dHXA26/60u4sJrsSn/n7MbxWpW/WF6JCBOrv6UB1mBfykCzvgYW+AsFOidpsqmZPeh8GwKuhgQGXz3MGhKe0PF9osTLEuUyMs0mKgwM2bM+uNF6aGtAsgJuZ+bNCUZu9tv5tQ5THSIq03O25g7kXY79am20R3N+A6VB/Z77U19Yv7w6K629e02X92+Vz1l72FfPUyLGUKFhdybVOI5t2l4jL6lNYbtOYeOjoz7RcE6sE4CIt57rUPS+hkQAFleSeOaKQhi9/phuaYjvuEyG39Sm1FL6FkzGiN1g9uDNdXzC0XxzGik63mpFJp8G2i+Vj1TCw3UueS3q7lPo1u1658w2nwDfkiPvvdG7j5UYp9sYNjdqndFyYF23RVsI6EA19ZKrJ737HqewjR/9t5FevxHvFcPQqDDHekf+Z3VYeiOBoQNQHoOigvfy0r1CnWim9A9rXdgBlrttsIUXPacmoAYHf1sBFgC2kMGoEbTIge0d1I2VR8dP3dDhLWdXbFhdJBdrDe5gcHCmVQIPoAaNvF8JmVWtOakCuaerWWK6tV3Q+XSGZBsyqFAnRVLqfLkHcbjhP5Gz8Ly4hqJ0l3FvUV+Dlze4IAgaTjm+/MvnIDSYT2KnF5dr0bzktXZ0HCVScXS7GzoVfI//kzM/3s9y0gLOSxpoK+J0Xvu1ZuI2ZdtSjCLNbi3n5P67JkXGLJI4Aw5EwEohPxfgo/jjxCKHH0G1azFqBI08xrrdTQMwSx3McDK00c2tPEwbcP7SsUSVZzd5svkXEjUDRcyEoVZ0zCl4WX4Cs0Fp5yghQY2lUCHlsaZfTyZAcBjDGhzH1JTtNO8CpmbgEDL1yNluKPKVMiuz1RIn6JY5Z658ZF8r8MjUbEYWGvzGu7hgPBlqvVfxS6rHjMW1v8/23x4vPZ+8n72DTTcB1kSefMCEGxzfOfcG73x5uwyN7pzVeQHkyMiycreHWu8EZ2QzIHTzFoVPBquysjcHb1Izd/HTztIGRvFj3HyuXpUwOMrhg9LyE4/WUWY9hn5LQjXMG9m3iEHz2sQ216ca5ZAvUfxjNoIH6bFWoHugUKjwyu2kx1kDFYdHkyj0vPS57g+uTEVQ+g3lhKiEFIYaL+zYx2kNoMpDZNj2o4RIrDq60rjIOffzbSArl7Gjl7fujwT/6Y0kn/k3g3g7W34WV7FACL3qjZYvmUtpW39EaTUPt7G75tY4YEyNnEJUGq6InNoo6JsqujJZKuDRUIt78sReRKSpZhu5Ge+WgXpFpz76Iph4G1t4QW5VWazX+f/IEbJTFHfhegS+ZCwUOJbrQeP+BCqkJhvXrqG0TfM3f0uAOLoA2VltfpBGf5fqWHal2+a0GpVtyKNP3uHKn9hHeSYjgS/A91EUTTFTvRiUbM/a5Bw11mPq2oIMmHUQLsFIF4k1QXGT6PasTGLf5E5dwFzytebeV8JJViusZqns5Q6fVZ6aIk/XzfrQW4xT6Ji7yIpFHeRkVw0c8WCylHYQs+H7RGEt9L9mGxvfFp8rxa9K9Hva9f8nauuq7Fmix9Xl/QRj4GIvQoUXqu8SO1UzwnOtWhmS6H5YPp/AIT2+HIjL0fCV71FudXu5DH4UUIo9omvX2UMq0M/12XwxCpXU9bLw8qT2QG/oO3IYyghwvZEVkNHpEc6Xtz7eRtxrLf9A1AMZiJ0DOJcDpw03hiFJFR8ghSPtNVRW/QT1DmOwFDMMd3ygp1oJ5uEZCIQLEkRPuXg44YQU1FCNGflW5nEsvWOo5eb3vmXxnJKx2C7znB5mkkEn/Z5y8hsBW6tM4jM3CB+ASxolXklbvI6CPmU9UETncOcs1X9LPzvePUlc/Ve7tlMrPdGeRApdsgLcg4dGhLHHjDSKDGvPURrCQEJRT6+dVklVpewmF7OmYKN7XDmreatYYukHpWkRt1nouDY/yhcxkAVsjQ3D6qJBhye+BgzwCBW3PgQeD77nZtgOGgtomtZIxHcz7Z7M1BWDomGipDtswGelHtocBwxsFsR/Yjfh/av8RVSSHHVregP0L8iLNAC5evs1gX2Hxib5BpvVQSN+ZFmtZaSN3fX9JRq1X1RTgOPOYIX69U5xwGyvkQyeJAVvjZeoDcHafVp+ZAGF5unSpMiBYoyeHZWE1qoqyjxXn2DkOFSw6vHkx/nX8bGpIZ+gi+ZSINt7z5ApLSS7msQSU4i+R1dPFAgeo7WZK5j98NBV32EczVZMPFSjuQz1fnTDiL6fTtx5btsVeWGBHxdG6Q+r/+Sxe58vIbgAAFwYpFc0qRGlzwgiREGr/EXUNKfEdeuunAvnnBBNYqjck+bktZNMoY58t+j1rSpxUUsjzfl+pC/WXsIaGj/nkNccAjN68DMiS9VHN46gkahllMj4iRcOurBhACdGna6F89uvyvaQV6ugV9EpZc/oaHWU0dHg6zAvZkRSzuhXABBlUrKiGk5HzgyXhYgvRm7mS90HAVtix9obVGJOl4T5U18MOd56KxR30Chpt7BfEufqEeUd38l/iRzctxB9IzeDyLP6oXXZ26GqPY6Zwx7soO8NMmWHdFLlsIfLvAWsmz4eNUWHrLeWmNP6fLUssEKD3KO4H8S3V3QK5cHcK/dEirUtITsdDEbkBAFrf4iaOyNnffWkvys9AoP8H29I4ZtER4g8IjUaywSZ3sxSs88LHOmh1H+ZJ+OzWdCeeHQKS0gZLiLtCjE7FUjxQT6rAHnQKSAsVrpDvJaJr1qZFYmS8tcxmYRod6TGblf7z33VM6EaYEE9GMk+xywhH+YIrvUuhQ0EkjGFyKRxnIKzED/UputAn641usdprGGEu4EOPtuEDUgMQ04Dg+DCKXiBBNBFnLr1YWKydofP+564yome+1/7k3hn7fWXce63RcO7IXTAllfWVUWOym4yVXNX1HbBzBUL3pnvE3Q1QkbMuecrFE30y8gh+Anoi5GXTSBiUmatanEq42OexvgRwf0H3LmIct2ELyFx51T2zZy/ToqpxqrGRkFdQyw+YWS+pZ6JyB4RPrzzAyM2AaLhIkFoEHEeVy2NvdcVROKMgmAHs1Rln6M9Qykxb+R1Jo6N8uXsWzQ+Sn9Y8T8v3E+5rRdvz7OxWal3WApN8pMax79NGGug8DkFRgnVlVmKfEmrQOws4mP4uf2rXoD5wBWj33lnDKNHy84SBuY0cgiO91EFod5axtcDYF3hReeTa6tUsrP2xj9YIev9VS3BrgkMQQFQ5QJ/GAmvRA7yNz7g6zRwpo49HQRaVuSwZPHzpjWNS249Yebt+bXqBx2sn1GvF8zT96oAvScE9a8lxZk/TtA5TSp18fHvaqDeMMh7qsJf0dH7aLOQmsDSNwEoCUCFV6KGPrk77SVCgrxTnazMahzG3nv0Mvh6k7K7X/LmBZy72O7vyfyiGnoAbQ860+nkx+9UcYasegFbjILtxxhdiC0zn4SIDFXvPHxG6IDRaoub0QD78TPKUSYqFTDAYQkgJGUGvhIawlUQR9LDC9HRDGRlt78etR8vYWA9Tburl9rSHQZfQKWrrgXvECV8kyy6SGdvxdOpCCC3IbHRiABGSwHgR0DCBd+FvwE9q4iVhZgBWIpraVZUs6MZt+5fimRQmRJGeiR7HZIuSy7aUCbq11SXvX34Jgbp3/ohG3XvNS/pmoXKSyyhiVlz7SCtKoalzHcmbtb+4GnL77k7e79Sie9cqea75a1cLtm7aiXUc6y8WXljCcjtYv1U2BN2Do5KhcRAkTS8Pv93k0xXQjW/cGBqGxlL5X3M3oYBoocgsKuYH5iOvcWMm7RQQjdceKlX28y1vU4N/tA6phfn0VZFEYyU6RiyTg7Ermyy876iBIBJN5SSpncpzw2eX5J3rNZUEVei6PiCG94uoZ9a0PsxwvOGBGGdA8JdaKV0Lfkev/6YnRyASQl7hC0OGtIqW94rTEj9cKvqubEuMdP3H7BnkpnwfyrANkI5Sez4WOU1t/meV7T9M9DLie8eL0s0n10tP1EUQry6j7ils9jyLDZflLMIU3Si9nGkFqZr41yXF0+qpOOOwYGNbvOcChQyWuP+UIcmdzryZfzIVPUC1MaBFX3ptCowcy7y0vXIbkUEO4wVk5xS49TZeqc2MQtfcrMEhB+ZEsTfs6sZEGWry9h6qgBGjFhVMkrqBHbWFEjfZ00N7lBffkMO4azDCtVktrRGN6YrFJx1fMOkbWWHEyky0Dr14VHti1YSpvnBrQYm9BOtl8c247urVDWgX7uAYIZx/PGcGcwdSe8szAOsek++zxIgRH1X6b1qsQe9CXNhrRQFnbOA9tGxBvJ6i5kn/OnaTnSsI9yoSLOIPFbCKYtkKqFyziwWMx9Rp66HEJaFv53TPwxz6KomqiEhzqDSEMa7/P/Nv3kxKOoJlBMBUnc3JxbY0sm2Soq2dNbjcpYK3HgdSaJogblqKOSkHQMWSPo6bR3Lf7NIcPyKFT3mRpmNWNkRGShrGROe0L/7m+LTtFeesqsENnTo2Zd/vSxdvo+GPyXKov3qelfhxybR/Nz4AUJC7CmJCOwLMoYdWJxYY6aQ5Us7gAxrQ6z5NApUKKaTzSX5dtZQ/+kPdaQgNxse9lwSlLjEycGPlwZDUcTQwMVvIGxs/TxGSARAj9uYtKuMNp1PqM5WvQH+7/lPpXOUuXq8+j/zS/xLA1rZGEjqJkbPEhUjd331sX2boYn1GqcbVO89+9puP5pFpjySdq2SAzGXxoHsnATYlCaH8h23rqpCxgZXxZ8Df32U5NkgnzDCeuGlfu2dagXp+AXA5yWVx/yDo2t0D/NuaL3kjdPt9WCLGgX2hziy/JM51igz5jEabZ053dYiIRGjiTFPlRN/47G+r8yEtUyIhxAnWAV5kdmxS9Ejmkw/B6QQnaaRYxaBlFotIAeZFp/03phO2YRF6/1cR4eiiYd19w3tlRGkdWgd/e/UMhqwDRjaxflcee6jZLBTOdxBH5ZhTzuA/xZSdQRuayHQ6admKMwYmGIjvxYFh+H4MFH8eQwz0Bb8yevdegBM2ua5q+sMgr0fkz01G/GZcAuTIXzTdqtUoqiHEXEWWlOi7Sn7HSQ4MJdDxwsUXixxa5eDFYK0+fTtkccKDn3in5+lY8/SfSkWQh1wbYqVx9azw4sMYklEPOBfWX/7LpFs9wwtZF3K1wwufiHgshQz9LUoClQaJG9dV4mV1kFovXVx+HzLf/JqhyqozYnyqzm66h0AHu7fypbdc3+t2k9cdjGMy4Lbe2MFlPxTX0r5DibfGMkxnIsT//PMqy9rynQQkB947kbqjQjqGepp6j3GjJr71qj/6Go8BJhSARVN5ztxULq9IKtIipGyXTW/DYfX3K0JFuXm/XYpp0/NQFYJbF0ykSIQTzHHcQJycovg8b3eWzbBFDOvrMimGnmHytw5lcL5L0hTYmqeXbwnfDXKmKfrTuq7wRVy8/sQpFIReS2/7YdScl5JGdA19uDm/U53l/3vxQbL49y1kVapeoqj+OECg1MWddeCrII6wPwJ7Uao0h2KURu7MsDex2EsapNrhTiWGJfhnqHE895OzwfhkFNmsAlHke/5MHJxj/hqpzoaTU31BBVSe+g31qJAijyRv+2pDmssApe76Q0tFU2I5KBKZ5Y35jsUydhiIe7i1WWRanr0Hnttg6VLWuMJjJ1yWFgTQHp+hnKIslWTDUFMSbQlRRcl+IDL4U39N6p7ICplirzYyLoNdo+wvfZqAEHSNueuUr0gDvc+nwjGwCoCZTsaSiqnTaWnBuHi1vadkDq3VAE0aTYwARlRbDXZDbCTXLO7o2+sTkf2iFpF+lDZQ0lNAYpDpRETTse8nlLAMLhaEQDeoGVyaPtV4gnQbDokYEF+H6V/2naAA0HlLStbUcRyh39cIF4pwc5YZ2TcqHi6RP4C/Vz9y1eHtmfKTE0L8Ov0ozx5QpxXX7ZfotprHOaTzhJ0j2QghITe7gw83vbTcPDTVy8tnTtewOlhSBwKziP3tpgruBNLjKQ6EFUyRGdALK94hW2TA8u5HwdeYXkjoU/sTpL8m4j3ui8p04+DS+3iVpT2qM/fgnitbbCAi4lMtnrHA6bOzhIQJ+MJoV7WwWGNA75I642FEiDzypolVP4l8RBc1x/C/GkYIAmcldKr193Hp2yxa5b0g3DHB1cxi4UZJMO5GSUGzAnPkeA11BYVD8CnUfSFkZ6ZviH2fOW0nmkO8j7rrkg5CfFq8lYK22gLdpDfKUQtv6nuI6gkdS/HH1k0Wormr/VBFmvrVKMMi+VT66xtJpsXo5I98uoh99O0Y2gKvAHk3Ju9Q8upvHLlU7BahFxzoY84ApTIr7MyggUam4dmfUREcc289gLdAp1lQ92UEIYMWmH6STEwfduTJrByeMejVZsNGp4Fd6d0k+w+6cv4bpcxR0Hb5YyDfpLTr2JKau9TETL2RkBdS9mTwF3X2JVmIpuo2ZzatOxx1QRTO8W3KKwu+90l7X/dZUW11vlWdh9ToHnjP3VijPskiIkzaIV+OcpHcixtCK2a2mek5OZiJgzLMs5rOOBJYi+R9CSVfDSJKrj6fA7ZeKyGxhNk9k3GhW2ba5D9dJZQ+oggAx1eMBj3zKHU/YALCCSZvALwc1g6RTiQ3w+E1Pk2JnrLuT3UAF+HhdqJ4L7ykvCNHiKOcIfpNUzHQY8bxjwayIIu2+W6ntg0TBZ/8DU+sTJuRS3YTmQBo2fe08WsIAkzq6gXmyJ74LUXw8oUq9hXoeoFC52gmve6FPZZ+TpThw1oCykbShz5FAwMNb0luyLKLAyavzdyv58FY7Lq50gzrP0syK2ajz3rJ5PNY/gKDcqh/2bFcixCui7Q4VWoj1VO5PAWwn0NPkYgnzGm/vlZpk8MPcJluyilcdLF1bELKLqtnJrgpNHu/QnjxTvTBeCINjqGi7zhRVUiYGUt0kaxWSkSza32sYqNY/kAjj3iJsHw+bDJnWdu+kUzmZtnFscQKstiGwSlFnUf8GWBTT6E7YYJH1hY2bGC/kHno1fhrZ3xZMn7rfYmmLwm6tKajVWxk4sGbwUfJ6xvbvC7pUAvQ+2fagmh9pFMQts6oU+jQ9FrS4KH4Qya4jqr6EK7D/dwZ8FWN81mt41U09Ga3lI3yycEilqglE9HhAzJrrXhXCJ+R4pzXtC7S4CdurI7fvqJqL6Tnb4jjB/lbhn2etc06s5fLfdyKC/reA6lCHcAxUzFO2Y5TAEsyWHtrSaDIpqrJF597Xpn1C9Fu1r5wviTzR+FxcLMG+TrkTQEuE6UrJVgaE1c4IKQLHDerwWa/gEHYIJlAkBqe77j49WrKeeB4kjDuVZS/9QsFoESv8D2phhlJwKTtYCiMnKBLDSCiHaeBXu3xPGG/F8/R1LgnUG782N8aH0+rJ7XF/1GhyCOCc2vrOTNC0qzYHKlh/PLxN8/pggmWZkGQr678qAFabs+do/TeP09psiMEERmQquEfa7cjBnOFMSyskA6x1sQlD7bCVEZDQdcCM+SahhbiUjHG1U9Hvp+Sg/8QM+jCD7N+fulHXFniDnMNRNWuHSvUjl6VMKkPETy0Pv7xVND8I153MZIGGltsSs2d5yw2QclM4Vo1+1q598hyEsSzD/wOfeW7Q0RighXwYf5g/A2uzZkXIEBDWLofGVzHhMJ3DVEjaGtkACUTxCTI5phSnWRfr9ibUSG48ctMyEOMh/6KhMV+nWZQpdE/INlFeDDHAcngpmB1H7gYhIyv08DMhlXiZHR1cPJb6pzBdcECyH5wqsK1y3MztHkQuFXxKfa/8qoqsOG2xIS8bgn+Yjzx2BffCq147rrz+lRxBTfFsJDoT7EGF6WLvXVWk+/TYgSYdVyzZbk9g0b2Orw6bO7xoeQsqUzfG80i+A0NtjRvtz+HPITxFRkjB1dVXKkTQODxrldy9O6syeZuZ4hc9snAlvMdB4lLEhiWLoZQ5mAQXUtrVO3SpUsKOFzhYJ7ROOf08oRSaAzConygvbQUhI4AAQrWcf4VvHyB30uVWo0thlvycSbK50QxbkXKwS1eAdfFXSs15zYHfkrRJfDDoNze9ZDUl1D187GhzRlpDL4+mwGHAYKMAsv9HGLLhup92LMagiFTKFP9CzNThoZTXjOIRJUv5/t18gogM2rep+KG/dXOeHfOru3nbdavGni4zbhLCiaHdRb4BAbvcQs4fSLhOIDLEM/bQpYKDDpqasSfJ6/BQYph23OMhmPXzE6ZJBJzmXCevDKCovCdLBXsz3kbruZeJt1S2XvxDgPo15Qju9ImhcoCCgmrPE8RgdEOSLh1AL9liLDO6QgiTvuuKjU9/gvmE36Qbeb8xjlKxOuQSqbXpgicuqlmSR1Hq88nB2CH3PmDC9o1uapLkoYoS/KHeFeSHqt4Olk4crhhBcct7ndO/UUmhHlMAITP/YRTtcRdWPL0z/vC/xC0UV4z1ONCOaa0jDjIhKVX6cZ+bSZsv2Fyy0IhcmY1xFHyQWDLFJeG5WvTu83GPbuVImiwp+pxV8YMbGHuAzvlBbpMXNwIAQBkWHdR4qhML7ie3HNr+GJpzJM1eUrqgag6XRhestp4AoqIv3xlSHL6toPZpVkOHu9LEfzbJh/UA6O6kuwHyqmFKANF4qlhDrMdYmNEVJs39EaIElBMjURIURlxmfzu1KWJSUMoT7DrRANwuR+vOidgXE7SJk3andYlhxjCeVL3+09tyA+EfQ7ORXc9yiTMZgjVMNEvehFBqjld96zDm2yPLYkogNNgKsSe5tWoYJpuk1f//sHKWZLvFV4fVwOfiCNzsVna0HQdn8dZclUrXP+IWWVQQKG8T9uYX/kkVZIiZ2h9nG4XsbWhjSywmY4A6SW9GbE1K9t3LWnQvj7MU74IXXf2krypQMoPX9nbv6biSF0ITD9xQSfq5+BHOhjOwD9qcJGlVyyzwf2FVw9wuqpSYeE0yi0a2eRlo8wh3F7wQsh12vJCGw16cURMGrvw+cGtp9tMQi8HhYj0s2yYyCWqkGfdL3uWkYKqe8nN/CU/AS/in/1kCO68Q9U2li/bsPIE+Jufk3n+izJFNoev/9qf7MQFyu6nCv7xbaJaquYQd3Q4cCXFDmKMHos4i+tKZfkRTcKFV4HUU+eXy0y6wIADcFOlctAeIK/vRBra0MXLuXsHRwgtjzd26diTBPXc4tdzi2OOxjMTdx27pw88hNU4e56ebVrabnFsIDNAIS2Juby0Z3WUsJ6owOkQ1JaScnqIgyjY9YNZnxfD+siszpm2Hu4fKX2cuZk0V+CNG5TPzQT8jxvlmTzeOelNcIe2yMVmWf2HeWwI1QFFuF3DEZx0d7vB3eMcfGZujFHGo9vpeR+1aQJUY6VGg2QE7IIndARTUfKC3NSmCg8x0wdlFsVxvnQ4IXT4DZo2da+zHMPRRZq/khsIpOjj68vii//QdJFKy+iQouXqwHWvccy477BRKJMCiYehhWj8gK/VII8yknD/IC0ONFHnEog5L4WpLn+xF85DBFRjvs9PABtBtP7uPI0ZMBpkNpv1/ixIUSkTeBnZjTWo6j0/iNq465qi81oULi/KG1j5kDwKqK42JvY0GgYrpfV3Ru6a2W4T8GKTxXQeQQEdJOUGExBjh7WVPCXNAlBnBYny78hS0/xR1Ag1rAezLtIvbJrRhYZcVPqD+UmKhhbB7Y0PlIVRiji/a4UTqEnUQZ7CI0Ad4hxIQEetRDHrNEbDqzGLhoJeJlKqklPhyqFR7t4xj6bNy1sqr5zkbdxyczc+HjfqSEI+AKFxOI6jnnNby693ZgsPmiM4ILDO9cK+D542gAJUjQEeP4/KRQfHQaszIvEKx1QKgmzSji3R+Y3/dM+vXCN8HPbaTv/JdQhwKA6/7F1DbbcMlGtq3mYtad9HieFsLZwXzRfj7SDMgh82SqJz0nKmuYYpsBoPN6CV4QwP6jsoIgtwiMZ42CAxnHgVBQtuwUATM8sb+uedk97DoaSubehMtN/NsYSR0EJYG80Qda9imS9b0UBu5WGjyc2JXLe+S0eUPBzqRjtCQQXZwF0OCfJU+/OWv4R58tfiPBBpajdKnspHZdtg/jhptFP3K9LB/XE7bQ0ZAiWJRoOFe0p4HmXgx0+XI79aUz18KkZCXO1Kc9jY7H/tBL2HGXkttJpzHk98Md+m0T7fgZXpENCOGlNOIgioV873j7bc6uiuy7Pmx2HkRzvsI1rPxtXy7Y/fOhyKIhoIcm+/aICJSDuwo8lQgPGCBCzAq3y+eT57pe5E6fgtdHPhSS8QPVrHqWrdhHT1Qfqq8vk6CLNkbNyOdhHSFR42k6YzxgNZJF1tB7Q9102GNt30zd5mERpUlglpy4fDcSBXao+jFY250FikMUA8jf/63I+9mwo44+wWyUOn2wzYI2I2IsDyh4qly3DTtA9Yuw0GXNTt0dCc5pXFINqX9zJ9xQ0YQqPgwJC+Xd0KzUy9aSzTgBlXYqCXmuncbgV+C9xOWPHsdDowz9pdXqQ194t8hWF+mVzCVjHMn2R/0HVIrzRZ6N9Y09Y3V3X0AwVuLZtfsdp29ZtbZXr6QNbceV6YqXSYJ46vD1gourihGKg7ExCzs+iyV5B+28kZjRyutLPNuo2i5o4uCvVjY512sR0+JtANgytC6dzzjAy/hYz0Sz/fAr92xlR54GBxUfgRfF0ZxpNoxVm9Q/ieVj0JH5F4xT40EtzkFZLbyOOZWtBEtV/lGm96S49oK3h0pT6ljyoFNJXi1ovwSGODI5VW/k44sPaROvEWM6VCQOZItFzFilo0CAsRrEQqYswNRqIGyXr+CJpjEs/eAHI/cfJYd5M20PDqvcE20VNDIUS8XS3WaTjHn0AIDxddPSg5xedKock2fLx4HXX+zsNRjv9+9L1ISELmVSPyyZrZ6kfqG4vhRUfLLSNxVYJ0vr369yTZFH66dtcwu+S99JKzivZVplyHqwhPn4FeEKx5qXQk4q3TQNLaVbThYAKkAY9PTLnNDOlFgqxLLRhvSPr+PvqFF6UhNhqWo0Wnjq/RtUN72ys8LAkj/3dwHWBAUMNTgG/zO9rdmemXGjBm6Sfx1KyW5c2LKzdyml/ZauCljNX/jMGu7ronL5TgTj4tN/EH2HYBCWlK2EnJaNWs2FcC92e0lLkACJ4HyaRj7+2LVuG1evlkXON04jVHsdveJ5wV7R5pU71+BeieGzulp2xwei/uSoAGwTg6eOMQB9T60XquXF5uyCiKbiS0R1YfB9ZNz8yos8yaY1bEvqyzc1nIiJzdvhdYjg/Tinb7Crr81pnGdIe+e00bstyahSBqH52GSUCZAuNSYnOVECxCxRA2BwI3ND6g/a0ZDA0cmKiBMp1m8Ad1g0IDgJkwFSLp8FXb+E6g51UseZ5Vma8LiM4P8w9iu/jsch+7KR0gzri8IbM9Mk8hu2gxF8qnY7cOvtsi0ROVhqoEv+Ew5IQ+5NolW2DT62hXH/EfqycKapxf5Y2Z3oDGfIypBK/QxjvBYlNrxUnucuhslXWBLAJ1PhB2I5CDoOJBTaLuetSzcv+OWQtcX20lxJedaSl+0a896NCR+5UCYiL3W1Erhko1lUMDbisMyZLv5hiW0dUIzHWywL/3jkt9Q5AzO/u0wXEMz74ikJZj22ICzlOqlgGAOoPhx2FYFuTY4ALfzEuSOtIHdneSgRGAIg/g732LqNnNSj2rvlX522NvtpxDXDAq/3X8SITETyjY3qXEFQSNdjA5daBFVc4L5i/mAp05hk5NpXfwawiGAGInzi585C0073E8vMNySy3QJY4uIr4EC2jDQFHve9erMWzAlejH6nYaQCf7NifqBo9zsVuN/89/JtGaX6xryCP3B3q6R0FH1Kh7ojFBW9aKPommkh1eFND8DnguDZIPMefVVJJWUM9cXLUi9jhwK2lN2HKwvjqY+3nYpirijRbfv+Y17ApRdxDZjf11VzLA6rd0hUxFZc2m856V8vJ77zo3Wkrvs5aEFoSuNUbcHNfACjhcJ45KgoY7jxCFDAdugzLNFmZPEpWa2NHo6aq8KEk9mZSH+LKeNVQ5B2nzYQ0hKS6cnLae+SHuB4zcSoLF0zS9ENSh5bnXiCoaj8k9A4nnxTPQclw/sicIcSsj1ZHIesEwZtM39iRae5u/1WQRfuwKB1HWwV6g/2jNGIJKPBuxFwiHZi1Jy06CnLDBWbEDEwB+7YLO04WgPysbtwXG/EgfiBQLgJljzmDTD8QOnU5sNDu/9XVwyNYgkrAo1iPt68rQpERfILASpl6MSwEWNdMZttni0jxXjBCH8c/W/2arl7Df4xt5dQP9hdt1f/zxbFH0mhfDyjDnjz6U+Ie3rzLZ1nx44grTOVrXPXzBibxFaUa8Xy+0t5KRIDWcBbfcMHUvG5EsErYh9u3h3A5vaIuUOLe73Rt7RevEtPMQDBOy0ydDoQsL9rqgPerI0tK1PVOZuaBhoIHzR3nM+qV2UnN4qk3skbQKb/pYxWsezDZk1nEPAJPQ496JgX7+PnivNpMN8EmNg5p+eU0aSFODAsSkDBRq55JHlP/tbjCJ5oj9nzzJymV9IzmyxjZjA7oUii9h2+EJnyv5/bI4+PRUMqA5T3POFpEjWECYsiuUr6Wd1a4i8YH/u5uTbe/HH9vb+KuK2X3nqV/kUO5wVMYWIdsAoNXdS1aXXsszXvM2R/JmfYkFHsclWw+pz9SrGU4xSlqVfSRerKN3wbEV2quig/L6iL9XckT5hmhQZdRxLU4+fJ/LwohRZpCPWcOMG2zug1ZGBKfl4cOATRxYLuXdwGhasxHuqIHqHhVNEf+gp6oHHCyr8ipqewr4Y4e5w70HTko4C7K7rYDpFMDk/78uskTeloy7kJWPpCV0sLxtXURG8jMbfJ/lGa91gxVkHwvvt5bsc61Rt7LaJbQgXoqOrXV+OZDUOrifXLOFFW+1lxkVb0XhgkVoWlSqKCNp8lvjcjrKgE3bCrnq4CxkUWt88NhUlRwLNaIdjERIRY54e5Bl9PoCnMn/kOwCqo+U7uDvJ2Jp7xDkcsNedSQ3RqW+7MZD/9XDRUApxr+BLTK/wa495opQIv9/hgloTuprOEJomNxBOt+WC4PNse/+9klZkdjZtVaf4tOcZXdQd7vn5QnEsgBDlteyUVmxxzqGCeKNlvwMK8I4rzzQ1W32rr6PQ2NJt/gl7L6eumPwPE/70ksmmTRJlLtYiXHm4/Od/unqLordI9QlAl3CtpBflMiJsyiIySsPO8WEzPKaQLzREB/J2s6FR2Aiv5kb+eavBS3YJOSrH88q+GDG5q/WdyCZzZnZrjAdxFU/vKxOQpC0LWKwbc5ILELHudmHfFastO0tSoJYGH8DfLMk9tms8Q7T7Eu4IgYTq6m5xW6Vc1PC78SHGe7eL9Zdgaz8gtLHoOJZ3IjRDDOjHFDAjq6+dXJNbfZ4p6pu1VS4fqRAQwqhgELAwGaPx4nqtHtxHzKab3Okc4nTkeBKePOUZJNZdSmPIq3Ylmnm6V9FXFjlHI4acAyACDywHeox07Yk5A/sZtuYdawwE90u1MQd/ul+xaZB2zBuarMdlZTDiqIENEcL2Vk9gh4k6g8yp163ckvJvcCY3z9sRjN7pDDig26BL8AbCvRSLpouaye7YYCjDn4f2uNlnDzrWtHfcs0QtE21p6QZj4V5Y4OOmciMHrDe5hKSroFSC4eGAvJnj5m+PbV1ekwtGbDYmoYzH7dXVcjxMAQj0xkJOWJPRXqJtzjCDOPhooeuOqGeIRC/RBNRfM9X8z4DnAgR1uzcuww6Vsq7Uuaav3MARpApyV0PChToH6kB95aphcqvauXIcdmk2i5LYtSA/kHJmzEmYWD4oiu7M0fpCmJmYTmteAxYzNxoKVs//5NCpzJMbPNVwf60LdI8mKS/Y7YzzIYzz7TXLPmikWkFGGUJpmI0FF2FidKMmEYZRJ8GFvHT2KQXP/48T3v7J+AvPsJjE1qMza/sRBz+I0bbNT+D+mDRmEfPOyGB120u63zKAvYOShoMJMzBGZwaTW05mbni9ZRgVv6r1z6WKAdfd5zxdKoRk4cZl3rqA7c2eVfsGpL4+e7mxScOI5DB7eG5Eojl/hZTUHpSdRSX5XZ3KC9wxZ0v9uKfirwkqSStM2zmuzDfw9N6RoJ8z12MwnY1+K//+rL/VK5yOBhoymVYDxKti1LC7jeyUguAwsvmxFPYgjALeqvD/81PBrWJAlvNw+AJNDKS+PvvhRJBErvlCZceVe4qomt4u6eWFzCVITqTCZh8WhwdkHwNE36EOU6+DZIxYz6+WZ9+E2ulVczlRIHG0lY+ZE83ws2bcFDFa7JjCL2b3B+VUzwxMQ3tyftsAaj1XJxEfsslLr2q3byPV4TR35Khv2sTYNYcVSs9L6aaTDWUjMgxUT/SB5NMiwldviGYMI+Ye9GnRhEauhSYKEfoK3mwMP6gp5O0Ehk/OAkW9QTgjUv5Vwu+L+QKUclMeBJcVsXTgpkJCPWHE2hFFRl6pOcoC7XczikToxnUHL4ZhlqnQguJXtKmXxC4Bt2tAboU8qAINllHVdBEOMO71/BaS20XvEqLs/FB6fY9nM19Ij2ED3HPERwNJEsEikzARtOBko/2Gd8HVyMQuzkwvLm8kPbA7P5n25dR4ojOPJy8ixM9+BBtVNzzI9TCbQ3TCkDW2KKEqk9CKinX/+/8T0YMcyMz5vpvGNZYqrrXAr8xek+GWFkSqpiK8DQVxdOefg5bXQHR4kvrySE7pyrCZ9Prltvnz30k2xEo/rbNqjL/5fDBnReIfGp8tnyzaBu+JRKMQfEHcctLycuEDC2lkoLbR+ew0CFlBQGdJOWLP+4hiRk+OFGPA/0exPQzx0N0MYx9Bmp/3+S736KyAWh3qnKi2N2C/FaAGX8plhef3tb8Lua4egoHATROdbFNUpj3gmfM/nUxlpl6Dj6HOAMLNAX6RYJK3/J2LCyLV5nHn4NzCTp5/BvfzFl/ZyFBuHbrjlIdyuAoEuq+cvEso5ueplydCCEDEfYzExFic/Nxx2IwlRiz3olY3foRejh1QVVfagw/3yL58V5sZKz4wi3KKZLjE8XuuXz00qMjuEo3m5BGnCjvSWBT7Kml/VOoLZTRR9Q1LiIeCVivR3ES1GONJ/Rt8R+UbxjuSuDxJOqJuwY6JlEDuEW1jl9FJgwk6fVY64e0+0otqM8Dq8hB0wsBPDhKEa55BZRzcw82rtXoWhZl4ofCEVL/E+9BQ6yLxPp08b5GdGSKKjSWJau2+elHCClKs48ZCxYszojqPgSMPPvrTXlG47fTLOS51YVg0wV5Cx8oEetbgCBgNmFLdP+Vag9EuvYNL8fBR1970urcqgDgqVIkL3TP2aIQZCL+ReKsXSuYCCNAcnU8qrn9+HHmvlfqcY2ZYbG59FwJsdV5nZ53rTShXcolbJIH9hfwn7OfjOQLweYY7fOqCL8fvEvPPilCcCOgAzmMHTvKdt13sFK+om8BOXVHTLQNoT/KNB2BBigOuM3P8Ik3tmh2R2l3rOAWQmuBe/GAV80UKUu0dWj3EfzuhtbAHeVIzGZjId/woQixeJfhR230Ay9xea058Rcu1tnQ2VwpKafb3HiywP/f5pfnHBtsCVrwTZhks1u8RLve4whC27F42ux+39XqzGkLM1XyOisTAN7+254vhhF26CA61WzBS/vxB8f5QMG6S1tJPcIlFGCwa/FGwh0BMDASsWxuHU49dIGGc+Ks/g3IPwkANH8e6fRtNttY+KeZfA4eeNBfMcZmieZ76vROxltDHev9jD2nqz5oPr5TLMlybY496SgnzopfbzEDOG/6up7Xu9nr0Gt4xygsAlaZBNSjO8oORgD8sbVVhMiCkWLIaqtCUahOqTFeNanzhg1n8VKGAh9K5bc3kGcMPObb8qYNr1uMeVCjuTIwo8Cy5m0Hojml052OGcYlqzdCWz+bDuE/yKk+YI9P9PbsoVZM8P0N10d1J7lavVTBJEdKomLhEsegQXZaYjNvW37XztFekU0JQd3ui/JWmRpEfdQ32iKDcZl+s3QAvkQw7ORO9Wdh5IIaUGeTXu9ECRs+/3KHa8pMvvjDOfwK83561ciPj4EyK31OiqC6xFiFNnCwJIjMkVdjMlDXWgcVn96jqPjx8+jeLqsoVtKwzOjf4sCbvuRhn9NjNCih7l65I8UExkx9QxjkmU8izxIp6wiUJ0lnG0y2W2gFW3uksR8SOFSdgtlTsrLkcEIEWTt6SPvNVdR7w9O+i0hIMZOtk6ZV7VuAoRsfHHgXHaeOlr6zGOr8ublAAZQzBA7c6cNgVwDUpMt0ly65mT2l5t66BF0Rq3HJWBRD8FFRb+3UymWAYrvMmWPsmLf+zisCzpQAQbHliBjMMDBevV+UOWoZ1nZJQLUZ9esAY915wPE5VgohBfgG+OPvJpywZ1DOojdme/4/4Cp7/pWx0HwS2C1mwZm6ydQ4ta/o/h90ULeuMxJAXIHv6QH3EikKJnyXrXiK4BwxPp+cYq8fIwbP0px52X8BwZDszdxwr+b8oRXQYGGDCGcflwyiGzgy+2T1lmMUwPxYLqSrZDljD9uBblvnxuFTi+b83TlX5NIvAulcLUywTwvEUgVyJtrdY7iYzLhN54huGLw7w7ZlIvyrtn07OhPLKHfGz3fqjEyIOtOtgI2qf+KG90bDd1GUlnpM6fIE9BY7qpw6IWUnV4pasxkVn2eN79hQHy1kDGNRk0WxTLCzJ7Os6uO9NAt6BGRaorM43ODq5VDc3EkVywjw865tftdX6xjoqouxGnrdw3UBi8lgVf38cXyXMXhNLsA6npBQHS48q9XPj+cSfGXgy1Tu6cJBtKUxEIMPlwb2Q0sJUKBhKvAFafs+JBFUCfNlkRIByGe/l4aFTuHvhPM6g228swdeLyrLVHKruzRiBdt7ndLrJeAad1JqE6ZZmsBp/maP79TWxUquDUysdAG+9QsTTHLi6hJfquI06KZgPIztA7wmP5sILA99K0xX+VDYSqXpVapfSTBZwUSy4carSYOzoTiZRLmGnXvtovhzg6LyQ6hahhTwSWJSez49lM/zKGvshNPfznbyinOdOAu8/AE6+NeJdh07XKi/cwaZFkK9cktTpOPOK6V+R3yI9gI/QC2wZOzKj2FE4bBksGqNLubsfjqlWsjIWoWyj/0VjhIDlank83ob4YaI9j3HmeEAsD4O0XSZyt/Chg7gfGSJemOEsQ/I41NCEIyePcnNT+23Tiuj9+1UZirSJ0PnaMfyzA+wtYCp2VbE9zDXEg3pQK2egJ0LSOwkgRDwYM8/IhwRjwtk4yA8FPmRVOyQAjyIcz3S2DK9Q3qoLpslykWHC9sONhkcxtPZwL+juzz9oEc1UehnoQSykvmh6wt7UTcFw73Z66uRe6isXUb0TbX+9UIuc3TVnbnYw8fXruPGbA1ao5jIGQp64f8CyqaDBBLhCyXL2LtPmp7FPyqYUqXZIga+iJlBR9CRlPkBeMUs2osAYKg+Ma/hesc9sNjHT+qu/pCETqexhLAPrY1qLkbHd3BPS5qIBi+SJEeadMgfOtVecapr+bYLQKp48B80SbkHiePGBHzlh4TImgtcqsC4V+EPFmAPy4zUpjnDqCufCBMu+2tOOvckCxy9805UHPDqRthR2yO8Wv5viKUavVZDdC30ctq6c2ytAZk6OkZJfFzgkEqc7N73i9fdf8LYs+Erv500XMAtUMqbqOp0NW8wa09Eo/aqMGH5G7LIfLVdIx+Kg0vAINOT02KJvF1mWmH+Ko9tbKWnttXggT2omSGRBAsMzQnwSNwjXpWjoNXohSBxXQoy/GYVJGzoRIz/iyTU0wlm9HlC81gQkwqdVK9Ki0gPEVZSmeu1cFdQi+woBsPxUunHYumaWHF4AL2S7N+hz0QeGQxMXFj8qIccys5+a21iPrFzuLzoUQLqkaUd6SPlrqQyZaXj12aU67+2AkRvRPDkgUN3I/XkgCOJK0SCR24mF/KwT8Z0AdKi+HDPVSkdtthSnu9OGS6Vsyq5YRsjqnlERPYyEL4HXKDAvHLkCoOJkKFhhuI4CHHSb9UNqua3XdxTKMZPZ/Zv9v+YdcK7m/uMvmlGvrYwtFAls8uGd5F6aaN55Ah1lGIT+kClHtJUtwUotC3N+m5nR+0g71JfgBzKi4BbG+kLFPbXIPv1cnyfGdn8I30I9tu2P3/jh9ghQNagZfLQJqsNs1KeGjMrDkrTJJ285kdC58NoG8DjMrUHUuRVKL0pvOkk9s1YvjVEgP1xsKgi0cd8aZ2lWBses5BzuX39s96X+S5Q1/wr0/MLYy0x8SfeB0+D03sDxhl+R4AX579LLEtdQ+ZgVgj8BSrFYc3P5fAKPRXjQ4QPzqcEFi9kfg0WXZwwRO42tity3cP0J25pkqKLSH/3HNwJNLt8rYbeJlyHBnHzTdrmM++vkAPivFXNixszwGDCc5/wQ1C7j8W4xfc5+m8qy0AX9//BFhqNAsJ6juefLFuP23uK4zd3epNkXC/pdv9KexHi6mE3iyGbFqWRdhzQPmZdcEU+fAqX8uPCpEvZBczk7goOiND8cEYVXHIkssblSdKhnrsaCWlhS9g4DuleykSgFQA72/9NiCDyAXr5a1KXkGypPlbn0PEXKUZ/Xwiz8ExvGVARItcOi6cV02VFQOh/qBpE3FSPvLQkbE0OyVWZoofZl2Z/lD4sEwxxExK4HuWpY4f6nyJ86I2tdj9fJ36lf5xr8kdWCLBghQcywk35rj/UEow0a1OhOTZhh9SknZXxqoH7tuRrDs8Hqujtsdf+zgY4mWqeNmKJC1gGsHHlKBC5thnb5Bg9qn7uB+jV1hJRTeeo92aSaxoGukM7Gyo52jz7HxEaeyWEs6apZ/Lx3AanR+2cAUulgkA9994oiqwtgaScPdRxVomICELrV8anRw0mPu4lDuxnHMxSOot7CFOwfR9Hqk2OIRbZ+vkM0cUrbQqamOcNUcQkNYpOzS0uLDP9K78ZKIKrtf/hY9HSjGC1TgPqt5YDEr6CVjOmycKE3lAHAiEx1LiNtG5iZKNyTpY5JYKZ16uMmh0Xe7b5cnBtLz3aLtAkpHGgOTf9RXg46YOyBTvIR7wglw+2xnF2P6CqcbBmHNGW+sH7Yf6NOrIiiVJ/L5EjwVIjCU1e05IfUgsl3xW2kLXCYObwoJBF6ieR5AO3/v889KjkYlkgFrP9xLKu/rM0m2/UZ6r85D3zXIC7vWyBLGpSSR1GCe+VXiQeBeLiICHUk/Kul6ID1+UZKSoS7ku60Ud850w5Wjh4F6pAVBYCL+uHIT9N/9JrDsW6105rEd6OD74fsYTjFLQ5K5AlpI+UvdrVCc79GglqAw/n/NFe+Bir+i0QmlquYOP3NYbTBkehNC5Y60VXhasPebqO45ImUUri9veR7M2jAZs0FykhByM/d1iTDgKa4qLHbsiLTJl07l2IeLYVgMNyO7ALXrOtRjTKPMXWnOuDHazWUAaQSGTTweTMDZxORr5OoDceVJogvswAPQHtronoYak49cLtLFtJzafSrub7vzJzx7HPpo2lHY/9HErsq88oju5T4cJa3q93+I+NlsagCYddMCCnQ3m6LcMxsi3j448wOWKRAIhcCzQGQcgpNYxNDCB+oj12yGmacdG/0HPxtsXtARSGINi9ID+GRqaBFB/gcrAx2VXYIMD3SOOyst2qZTCSRYqGWB251OQsnu88OE2LJ1fuZ9BzOMEYAAPXUDonvKA11GPBSwWBLZDFD1MIDhmHUEFXrAnz2oIhgH0fOV4qpL5r+CpUVL/8Tv7AZqy+X1NT8ca3Y2E0mtSpliPaLl5IKw3AkydJdo3cu1JSRcSBiccnq1gfSnsN7Yv1FnjgTfJ//j/us6xtrUmd/p4n7YFU94qRpwLGGEtj6UNSo7/6+GmVHT18Bj7POHwvjc5nGxtCKtSq6ROeKhuB/gVi/hAaTCX+HrZyWI58+1kb2SGgu0P39tVg4F6mpLmTeCkJrslTxJgBzYpiuE4Hcuu5J2bBC7fF+DChxLlGlOSlKA+KkXgN/mkBzvzYIq+G7WXB2PLvoKI8ULXwX8cEGeyI9HTfYrxldahcZtD9T6Ba9UQURQ5Tv6dDnF8hTioj0/mWwQQNeHhHzJB9ClA4jL+nblQEs1Y6W1wP4yijushZoCcV3EiROqOALI8gJ1xi+1iQivLlEI3EgM2t+voPKTMZHInhwvWMZd8JpslvB4PvyYNLDuqANgO+RXtQ7enx5J1RPKurbBmRbbw33dtqVHQ5J00TARX7vzMDmuC6eSBwW1hgnnrouruPhsKBRWZp99SBS3R/KazV3JqWdk7Bq7M7TaAoOiduu32o5p6c+ULmIzQOqjtBS7lGg/pzwoz+LNNtVl5IRETC4pOt7MfXebEjYFxatazEz3rA7W+iMW/eD4OesKWt6csifBqekDu8/gcMSArqV9QhvF2Rq5zRWH8LIRf4XSvZEP7i4a9J913cOkwTnBE8ylVCC+4Z7KvMS+8LW1F2R+q3gUKwHry3jQzMIxUepBmQDFuaw8iN6SKTcGyKwqhS/jmPkhyyTPYBIeMiMnuzw+nSUD2LpIiIPIa7AKAyFvqBmQbl9EaECpgItPsF7uw/kwtYzmD5aUfOxJ/2z4z0Cw+qEcI7gijqTUusdeLnT6cu72V8tNEH3KchdCZnjH4VpISlAvJFdeHCNn1BsWoppfzs4v5mAFiRKfissn82I8702s6FIU2gNbjuRqkQ2yPBsdg7Ae5czaPa2M9yKbQqz3mAjWSyy1uib5iTp7BWz/Q9v6N6dWX5gg1xRfzS74AlS6pnQV4HrMmJJpM+McZuPj4EbfaFhS1IcHnAuWj/1FnRL7LGDj3ClOe/bahLhbBvloyy03S8Otde/np+aIgDfl+v8C1PLZX/YwQpCZQG2DyL8NOnkPc9X4RdvUNqZQUE88pc2y+Ep/La6vxGy1h4GLR9mINYbaK8eCqBkf/GKVxT26lguogQ+eRPK4RgYDg8k9SmhNlJrtym7nvuUnFaZY+a9jLqSdDgxcMil9tllq4h+o/QWFvwvKbAEfbBXaeAlXHUZi3zKYNN3sxQSBjtjrbrlr3CxwODnWpw9kiRAHsXggjKhlQLGs+1/TWP6tcaOJ94oFOeRpSo+V26ZGH6JRt4+Hh7fbxVpsrzcuCj1bq9KEAiSZLc64i5vN9dG7l9cL7uCV4kX2/4b1VHGMtyxvLTWHwS+gs35l7R0n05CVNwPtH4mQkFWGoE4wwKxJa8PT6XCPWU9n1vU6xXO7NRULklXA0vvaMws3bKoBTL9kpa5q2wVMAYR+ekrvvIaUiqVoSDMQM3eZFgVyop1I9+G4ZGDlWHzPdTLKQoY7hUiVxi6cfEmkdCff7dY+ksgNq5rZ7wpB+Jz3K9DuKFhAb9wCFjPgY5ihWUy7Wn/bFo3xvVoiC/Z+GP3jx1uBjLskuSRwuId9G9yHcUQB03fqbZyZT+qIBkyqPMhWAjAuSxbc3udX412IxJgQZ1/7hQDi6FXAS6YLuTSHhB1DuO1HWBruTDEPbt8WEJ7SiZfjpqAXsW0ag7bdw00jklnzn24DYx5RSFqHpH0E1qQvIZayom4vfS0Cq6OituFH3fvs6gP8+Po7sFuWaNrmH8NF8Oei4bwl++KvVKoS4qQWKqBfiSohTlDInlnQxYbnOFHNY9JpktpeVW7ECoZCkkkTWfrtK1nSylKYbTl473c5g320PuOQGhFF+A5I+mH1d45/BvFbPR9xyxh5oNz43OlW5PTP9d7LC1SUjKWvhwM2f1iLpaMZgreswBx7Pl0xssDmoPoSSDDWQ+Ne7S3mJ0uamk4OeRM6P3Jc/nAuAceo1K7TxENF73fZtV5DcNCqxvgz75Hggyax5h1FiuiFaFZ2R0EYN9cpLtr3N1Ik/B0Psu+62F+Q7CzmLra7d+MksbMpAG1QAAY3THUEKdorhezMDD3+MKyhf2wH9UESP6v5KZ5PQ3AO9HsuF0+yvm0tF5fpA8V3bSbdjc8WBAJFd3w3VO1xuWRM+wZz7xSQ1sc2jCZCZSCd1PP1ixlt4upNwj0dkvQQQfKSKR4HFvk/n2r4lfGw0vd2jOxJZyFlUygXoh9eI22HYgwAMa1wlN800vHJWTlm6d3q1IoZTg0SqzoqOzVBlDmk5apunpuY4Osw2u1vSQAfAO74GYx1xDYLjM8cSxANntYD8e/bpu27mRn/205ev86rBzwPRz3Oylgszr456Z9hi0Fifwlbw3zk6CyUeXwvl7W9ZWg2JL9dBMJWowEJu5WGon8c+K+Ch19EwdcDiNCcunuX0JGJGS6tJDsUuuFAC2JtXpYx7DwRcgvcCjI7J2+BXsG37xgbHzNp+TZefpXY3CNH0086TJ0poWtn6thO260Y9nirHMSBHrwjrJl1Kh7zMHdntZhIrEDve/8BIMrO8Vg8EW3pinqPMGWYZgigbEZgMWpgNfC7N3q7CeFjjYlWk4N8tY/zUK96MwYoFztI0Somdqbi0u78CKRkHaWz2ucxzyoEnPyWtcSz9a6As45xBEz86JgvhcUFWoosqc8zjZ7IepxJ4LOaeKbBsVa0XPxsAqe1fgPNpKlO9DTey/WM3op8ljoP1ux5DXpfGhi7jFfIecg9+LIbdYbB0waL30iVVUpcHadQHy305leqW7mQcgeTc9xy76QPGuiq5lOBoixCZbA1Aw4rwoIyDo8jEYLUG/55A/yxAl489KxIJ+Ai/EZBMAk9x1t/HVcZ5wXO6u4FUxJJZMVomUpW2I0CO/VAxKLlz3sIoeuFnerRuE1+r6kIgYaAH8q5UsXzEQMXsjNat6Hxgpo5yJ32uI5TKf5nq8pKNNsWWBfO8MIkOQpoMcE2UhLV2fjHDyqDteXSvTbknEAbUz12Jln8E/j9bKUjrSlF3Q52GMTEwBZnq4ZIymCKBEScl9XOKu3zAX01r3LC7LZbT34UqJ/XUZognn493wahErZJIEbeGL49/qRDmWvWJkgO5uE1Ovsfgt6arUFi2+tlHpKYEmG05BLCGm+Uoh6itFD1d8laOIQCmb3vjaTj3xGnWBt7DzkvB/RMfyGq4B8MTroG3RLADeLYujZ1cE0DRDw2pVcWeFQ2Ki+0Z65RiSzt3u3uuxw56uigmeIdaFlVbNJwdG3gcXbYGtC9qy1dih5RoaIUf8isqqhI6bjVRyOplPBJDlqH7unPKd+zE78qCyl7P3Z3Z9BvBDG4HZg14ZMWgIY6vprnwEIaie1f9izQk7W+Qfu8r9+HkBEuhl3TvdnawhK3C1581fsNYOCt1nTe6aD95CsgZnBtWUB1cMRHnadAADyiJYjBXYbEiL1DLAPfFzn/1Lcm5/hCiATSffqQ5oHxEiYJkzhsVNWfD2a0aeq4eWogqSdnf8aO99nt5vgnGZrUuwCAs4eZpZEozvKugcbwlHsQluNpujQyW/ergpo27b5thSFtSM12BSd9XxwXc+7R1QGb5+XRzQN3ScOwl0elUtoZGq3GFq56iuo46pZYP0Y/4OOK4d7TnZihxYEYMTpNGH50Uke8HvWrQKYdqrD2p3x7oTBm7MuraO4KG3JH3eX9yzQwriuYXYc7ZKYRB3FxrjPiXhrUkKDK6tkHVS0e35DGdHGX0cKS3ZXgc40tVKLC/GFsMIPM61qlu6iEG0PEfDda6okorzhYlouFBI8lTjMfgUirppfx9tNKoYXpBV/PNudGpYb75EZpyE69AJ5nH3uuYY9WAJrx1evVBj2YLCHJ2H9exWwDEFmpoQXWW4DIKXIBDJlDqLWgL36vyHbj08Ob1uHFZPRYrmZ9MZHp3Vxj9HGk2wZJeJ8F57Zmm1xC4w2sZuikhriA3Tqy9+WUaDnkdh746qM2H/z/u/lZPDgUuvuqZrUxbFdggIVKYRJmyW8IgXbqdWxowF/YPDaumBZPmsUQwkbjH2uvftOMjZeCSxn37r6VIJgL0qI8EnsdbakQaFi0doejOfykB0/HYBuQCD6DljEwr0MN6kRXmpOJs5Tcg22mePItJO47v4PMhdosotGvRicBlOlC2vdiKUmeJy3Cc5qYYSqE7OpF3VN/jepnHobdRCa/g9+Kt1CD2ioJivcsesPHXgARzPOyI1hAQOJ29Dza7jH4/RsUuvtkkbIrBKbo1Tg+Z0SLNGrRSIMuehsQs/HKgs1wG6T6++Eb+Hn9TV4A0CW/6yNCOJGLxH6MOXx1ByfrXROD+dperIAwiRfKOR4f0OzvhUQ+NS4RR7XBmJe/fliIdlGtwYTIFh5NnEvZNOp+VBZd2PSSi6msCl6oOAEwXN+NIy8Ce8+Fc7qIE9XkEMUKZUsidPa9HG+xKEoWn1sGSU43JgzzQQN3LzsPr+sJTu6eXARjJxScM5Fy2OKvTsn0vS79mhMQZ/6oSsC+sj9qFSJgGbDmDzLWtgUEFn1UslvSM1rT/DyeAjXbwBEEIY20dUridxOD2U1dxBBu1kX3M4Qu7uejA3cHxGeCVwU3frmbUsO8iMkdHydgJd/lciSnLzWAqXW7ICZflqybGUAOXbzqBzp1rTRr9cQ05I4z1ZmoZHZDBxKd+0NuW7LSqKdtDfxTNGsKZXQFzeooSaPgBZ7KhnPsgHg6oiy1Y4uxdoptsKp5GxeoBniyhpxSU0ZPyYZo7X1dYDwMCE+IcYeTNOiwZmHOgf9V44/4UV3yh9H+VbemFPx46BZMRLkfnqtd+HfLIrwp4OCIY2RcUjEarFtKH1tMds5H0lsyOMbRrKPJEC5uiU13Qv+Gqcv04eYFM2blpHRjghc5fr9HhLjnLDOqaUPjRKej9/l8S5Sy1WDFmlsg1URgapjXGZiShA1IOMuS6QHTx0Isi93oB7nHX6EGL2bvANLSfYroLpw2RJBac/NMPwuYgn+kCy2FzLLqTVg3a9C8uQMPJx+PM23mluqv+HBfC3mLRtd3zyqjxC32mQ35Ejl3XUf1Cd6cJVmAg5jDSbwfLce0xRS8VFhRfjlgtU0NmotkT8L/EC2gpi5YgiP6CSKhn66om1TAvHxR24RfBmX5DQ3TBHMdddgYcFwNPLFWdg3UUgNW6KO13d9EEwyx4tAfDK4gJ2m4tQjd6lAFoS89L+5G3nwxxlMQ7ptZlIv8KuliZCCU62H4a08MofVrPfQAxC9/w22a5qdMwmd5HXYjmpfeyxXjJWduWvD4+hR+U0ablHtuBhdKa5z3GXMUIv6RU7LPGazo5f3ZQNyaoWW0JIpTpFmjUhawy6lBlSjpPKk/QTdeAkmDzuOrP84RjSy4eyfwghqxef8pDx1aG+9tklMWK3GvF9lDzOcviU2bjI7YZ/qrnJ/Y5hiiBTHCSsbNQ2fOrHi2cSTH16QPjzPDHkt796I23t4LuilhFrh9nS6s3OoerwHPZFQmhMbOFgITQa3yT37gXnZiaD5+Q1BAGvXN23wWysJLKEwEM/g7yAFli09lxxYVIbthJD4PRYRIQeWYH9aQ1gkQKXeYGgR/Skz+R0EmNCXbPaKXG18I2WkjVfXyampvDibX4z9d7jZj4AE4whHSezJ2trvJck4cKam/dGT4zn1pALz8V8/pxQ8Njh1YWfAbHKbZagxv43g7CHWo+yAIE8V+wuB9fgMG2WoVoy7jqhfsqsq47bOrFkTU4wT5+Ou8HFWZ8TuOS9yLxiAPd9BptZLeX7FBEt8St4vVrltk+ZxjvB7IXyRoWvEdT9RHc5AJkUhZTB16cK2kj0u4SkAQgz7DxjKuVNjdlBaNCE6kMiEqi1yd3XVygIaD0FbQcyoOsv7kifPSyXzBT7L0pNFrLMjWo7glc5IH8KvYPpDydfaJbggsIxUfGY9lBAfcYns1cG+U1wnvPZQfO0Lfl15gVri2dHy4Ht4rb7hu5o53AQuG8eMtJR/b6Qhh/xwkBH/dcghwOshtvnueGrGfQkHOyHqlMoQjT5Tj2hxMppT87Y44C0r7KF89fvFtrbgiVaJ6LY6elZlZZ77d2FY+H5x8MsfexwF7tYFjn/hDPSaWv2/+kKzhuM0ETNa8YAcZ6oRIhkbuHNLal1iXmny/+7U6DRjVAvgssIlXg26igSAGqapoXB0Z97OZWm4VbGZTTxQCDTmLQZWuQ/oUQEz7wMYy34xVql0WRGk9NQSiNDLYfJ0fhi7rz+KWdsWR6/0cZrTfscqtJ1pZqYKO2qHC0no/DMXuiZUeByLdK/5Po/KFFM0/t8Rx+tbUoetKFw6nSLrX9Ykc446DgQpFHDOOQMkHjFAeCsMXHafFUHXYLHD2K7PpD6oJwNX3p2ldcjVeIYXVvkZDeaBZGvWA7USLPbUcdRW98VI7j8TLJPIHqAfmrCjs+Ad/2SJGVMWT5pY7Wg/pW7kXzJ3hc0Tt8mZxUyX9yy3CK+qf5xEfS/CjBzIjBlU0NBKVAMRJYw5gJx2Qe6cM2UwHm7S7aVRicaDSptq7mdqFMyBjvfRsrF+XIUIgVMLKamUXB5tY/lJQ0XLdgPi1xJMfYCXI/kGo1/yTlB8U2RGIcsNBwFLBhG8BVDStEILzBtARBz2e5oUdd+2tTRw7zpa03nIU8bfxSNNiXWrb7yhTx4evZ/x6ADbyFe3C5ZAfemyTPjPKAIhKmGPF4jv4iVTXcnGQNDu27V4hV5THiO9upcnemfmLCD+Oq0QywH3oxlCFz46aAKHCW6nOXeDrv+NYe19FwLJ0oc+cN/OFU/OICyAIwAtmZPlUuemD7NtH/PWXm1dtQb8LUmnZIxRxP4yVCjtdFuUAt31EvwodYT/V/M2mK1ZEBFeS24qw8KA8MLIIOmFiSkM5+KxokRZ+XbSRR/Urqq12gqifJuVmKK4wtMk5o2knq+KOO6ai9cLGhzL/6CfsEbWJZRgmHtaDETRnzEkIJFbmuyJovv85zIVv3AxLhdQHG9einS9l7VkmAyoGrnY2qtGois81p/D8qN8G+3rk+VV9S7IuQ7lqRgpc9iaGInX5PFGUA1z22DpuFodiyTRwv6FXOSaXhVL7CYjNhFvemtly7Y2BNM2ryRx0k9ATvSfWhVH3SQ7edCf5RuRdNdqSEl8FwnVyqQF6KJNDmawaywiUoSmyv8goMLMYB1/fVKV6Kj5JdoeVQ3dneFJrkf336kScZD+O3tI8Ov3vXN5TFFy+pyyh4xjPtLNVTmHzzhU+dh43RHh5cPVoC1gt5woVzXc94jBpawKxKusz7JBd3t+I5lX9aoGCOSXhhUf0+5LAkREuxfmV581R4KG5W9iSqrglbY/rjp4xpsi8g2UMW4FlrM8jJy9MkMlr0EaJUTG3Q6JhkxKJipMP9Rdrq4QhMIHk0KDJQhev9VMkObdH8hz1/eK2TwJkm1pmGXCTqiYe/MD51gUMy9q56r5/uJbObrcj4WYIDzCgjLdVJU6Kgi20kkHHEto3c5umA3v12jKEUV/8qJn+1uN1xW0FGXvuGAXcGwUl4G94NNDnyI1J9QXVOyWknGEYGsoB7AJ1AykqsL7aUBhw51dlqRoEm9IWzQXewNXYDrltw10aCmX8p7L2QTt+qWHnpBE1TXdR6ID1g2vxgqEfOVJ54UDGrD4O85WMm+vg1zCQzmeczBj5D6T5R09/8SO5BwTkX6kA3hdU7ZgVvLyFSELtq9GNedHU9I9eocz/M9Dtkh7QXQmFhKqorMoofGEOQed7V9vGPF8By8eCyM4fyibAuxF4gEx16g4g0kQvya503ZcmmcFcgGGXkC3u28zK4DqG0EqcTh+xQwE1FkgB1/HpnM1FAVU+6aL5ttglP2A4hOUbtA9irOEPpEdkgvR1BZhJ6lgVxS6WJqu5uukhJBaXUelJw49WNpUrHxB9oNe+QXOW8rQaWBeTMzzX1HW3uh5pKQI/PWUZ6IpBWMkzP7OdvUePv5MY0u4FhrN+6D46TAZPq+z1TnfVVZIm465oZSs1JtBXgGT8ElKiUUr/T/UQx0mxmCNzY+dWiJYFoVGla/qayuxN1xPR+TjVRAqf+HspJB5uMeJZjd3C5QK2NCiHgdsGUyDCayJ9pcsk0LWg1LC3oT/VvEtLWBnaTxV01YWKfpSO5vd45tCRB+Iz5G0JA1wdnUkAhLx9brMjpnPqmViPduJsR2UiNX5gU9rNjBgLGtXG1MXIvCoyjN1sKSLBVZdAbCOH5KYdMKYn+q/sN8rQWZ7TxCPTnc8RkAvwD7/BUp2YGXlN7bbx8B3GLzhtmInIiB+WU4AwswxG1qAzyVaOz4jhL4+bKD/gS3hdcx05m1fGyN3GVh7B87EPvF4VHy7kHJLkBz0lyzMe4v+q7ASeRBfEVMyRCPOrkgsApeaRaqoBvvM5BugdySuWM/vqOmuD3utW0BqIDiprtPIeal1uF+JwAuy216l/QLr40s9/MaMsjvrMFbKR1PD0mybIIGb7gwgWYRcEakzVlDDAWZtKscanzTUzzXHcmgwlOm4uuqcnb6XsT72Mof2CUuTSUbsERT3dmMHxZpmbVrfZoKnyCck0utB2gtmCm+dteHwEGoEAwLnuZi+7HE1UG4Q1EoGi2DNzWJ0Nl/FOOX6HwjFrm+nGEiZWJBD5FTllweDqOSOYuZP/1ay2nENdfK+HpZRkkvaHcWuNnDL+n2g1v/oNuwlYsoNlbuiQ3uduEUrlEXnzk+fnI46KfAXN7003fX7FF4JWfWA3qED1KPDTfpaqE5z3HUxNtyDtmR/sdzBRCoXOELmaBdSh6Zzat4Pt8N3cGDX5emTeiqOid9Yk/9l9BXcP9yn+AhDHlhpezO5OcXI7vYks7D4eTdm4rh1HhnhOkTa2NFgnCt/l0UWu/M3yqzMPuEiSE33meoCiETLBBpAcjZiRUXxChwuRtnQkuKbq61iX8weYhAlAc7iFtmHHqQBoVxLvDwg/QSEHDbrz5d/YtXT7TvUwoQiHYLqFWamKO7+tDaraBdHTIA2L1Hn+OFMqZ3WQYfztR278Y1BjPLG29QJSeHxZGnzkUModB7FkvqZPsil6u4HGdqzUyNrMEJfsA3n/k32KIQR5HwLUBbhO0RR3K4OfAINzvtz/FvGd5smKsA0ilO0e/KSGKdE9GPrwR6FG459COJKRXkGDqx5Mp+lwo+wOhr4K2Rdo3+1NR6su1/9pAe4rGObnMB93PP/wyOZ0CG/2ee7/Y+Qfk3NJMK0EE/G/gzCtD6QqZrQ5vuWANh0Az08hS8BrmPmoEnfn5ElzxI7HkQj/BUlMjTUdYVaUZFapMz9+eKJMolMP7ZzQc24IooNS0yWdyqiMGMMEdgCDj6bfhiumnTmbkDOEXHi3Ql4IuSIDwXVPmNQkpG0sSAG+s+nEuT2fMieuS99MmO/CHY3tz1sagZSK4s1VCxS4l/EJwC/w4XX7s2GKO9M3lmgkY6kU4a+Wq6csMc7LcOT51kChD/WhSjc/GU5+is0ebSLT5Kjm895yjhsowEoqIWWiSIm/wbaZiMEcKGXr/dI0fOuu2Tn23tYo1maX3j5GDkgDTjMsSY8x6Wt47cAgvk9dWp1XDqYMdo3lkbwDbxk8K9PDqWw2T26dP01n8kdHdxYzL8+5fbkc0kNF4p0FiQsdGMSV2l+VtTj68nlDqR2hOBjqn+dnwcXJktRw1VPf+WrQvEV9kAVRFtDVRt8XMjhxXpsT/txuGLkvZzw/r+ky5tcP4JBjYVVTd4mFzvmStWw3My/IzTkrSbYQiHe0AzjpxKAtynil5+/GC3SX0evzg6VbZyvF2tr3s5+VbVM/wc1d5XccnQFOasdA9NPt8p/HDxYTsQ8AiMg3aHss7FD172HxY956xTQ9EQqhLanZ87OSwPNmBWGmsPndm0N4yeZXtWus3568raB7tHtsopzLyJHqGPC31Ebc9QQRUERB42mzlCC/nnYgRBpJovBs1GS3ugrtKvR2ErW0hC93pVfR7MbtgSQk/hC1lWm9IqxjS/E7UAG/ZLH/ynQumx2HCKbIpTCc8eTxGHzAPtX93R/SbO4CLvivZ7IUHPyGBX8bdzlrKacOZFJXWI2TvYT04bVHzJb8wZHkNnTS9O6VvrqIQGTBgTYd1yRGhhgTEjjSKZbABwsZB4651j4PX3eq0tbz4ofz+eknlRGATmIFkJlSYwHqzxMBqhiT2YuTzYpoNz2xTOSywW6r+ruU7AmB2KzkB9+OmwzC3utd8GosXRQCF4ieFgWVrT2SDKccBKXgQ5DHUhjOQemi/MkoIAgWXUTZAXBpiVcefug9U/WeSqkXR11z36X2ZgYrzkOFZCZQ1rDU/DLRGh4NIwDu9F6nXioyIKTEHE/3Ps9f+/DkXHNLzompwy1bIKv/+uV4bO6fbrdttLXW/6jj+lfmyhjU2HCGwzB2EuNQcstLxHkbXuYABaZArUpgdFFrtU//2UnFwzYQY09AwS0u/tEI6mIY+N0S4VUuLdWqfGA+eccUtvPKRMJViwJtJ7s6SrbJgdfY8lEqOWVMRpswBS+/G8CTzbyzTVRbQYR3DWC4jkL/S6Epezsj6MbDbSPekuhguZgN+NGyyLB4ZMDA7dWIm6D0kSTtxtLiqfrHoe4Rvk9WGZ185CDvTkXVYXm0ivyijkKdRwvlNZi/2CeX5P9JakCDnvQupYdxl1wbaAx2xqBvcf7cyLftuC+KMixKOWypvpwRfBMhepB8g6ET0i+R08oQDWF8D3vj9z0ZCbedIMC0+woNKTBQZzheYDYmSreVugkyUwRBUcZa2UH5tbBKR7ze58qPMvRdQnl0IiYXJl59c+JYgaedvMV8zXrEySZfVsIwdGn2xeero5w/xVqkTJ0idBo8mU6a4ki9MxGrs1VrALnkskQqSLn2LG2JWXtV2KdSnz7o9NQ93eNVCXzXzwNJL/72iFLdEJebuDXP3XQlHUI5AYIeiJtC9h3hnYWF6o1co+J3uXAZkeVO/odsJ+pLX5nL5zYY/eFVM0DyxzB1zW8Y7RjBosRHC2owKMo9S1KPFugNlwbLJMJH7XfbaXFX1v/h7DY9LNwyFfSPOj5Go9v9+T5fT3uo45EpEn47sNW+kCs+dvF2E2GIMkT2TVCRtfqFcxaPgtEJNsrvHI77SBWGKU3PDEAWzN5fIy0CnZoWHA1c3hOPRMUVm5oXYapQi7jFKssaIgtjQTBjpCluRRz1Kvun+jlizPdidqv0vCoriuv555mHrYLmpfjbZ6c9PGYcsAptKs0xg8j68M9vHxtCqpba3h96qc67CxUZdVfP2SD2c5bstmSTzXqnn4s7WvkAg7IvnwTnppgA0hxTSc+V9TDU63IQui+jQlCklWnAc+YBCQNA33TeX/JLWzehGybdig4u5dCYABJNv9El2rSk2ugf8VajUSwr5jfapXqgUGgwje+ne5iiWMhboQBYunFZwN5fmIsbemMZAXOJQs7C6TDO82c15w5n35Uq+PyRxCE7F9K6OvBOUNeuIdpnJMph1O3gKzQwSbl+NjLV7YWaDrbve9Jz/9cpE1sAALvaxoG3uvBzaUaMDLHBxwD9npLvG+Hxty6gY76DG/KAPa7I1DuSqX7FF70sV0lnwE3VVxGPe1NBIgj8aGSyZWLitFfN5NgULpeqqXpUGETQ7OjLfer3pWwg1W7GWh88uwMxxUjrmbxqpVcLY9Z7MZ2EJote2UtKl9PynHWrZIH4/ku5TMjtbhBdRyYygA+NEbijfXpbBg0G2gtVgZT5nUiExX6e60ph9hgPefFmjF+IO/0rdn7mGRCOq94I9ESOV1ZWFd1yo6ESwxnqz2CtWjpTgFq3U9EG0nAi9ExxTrNYlYpe9P2vZoG2Z7Ig5BCm+VMI9iSQ+fn0S7p8uTSV4qfPc/ky+NL+QHpWSLQ5GKa19BDAvVCLatVRsx23JFpNLdu+Xq/vovw4SSx61hoiLCysGFagNSy891fNMjq2/ZPk8pRmJAFKMXLSFvXEvcLfuShWUKg8MqZDovUrVPS7DEWtSfRlc9p8aM82OGAPXvUU6XFpYK0rTqT54+4cHS4dxQpA5Uhec2fcvAdbr/xLJ63yD1sFA6gOyblrmEUSO2KvS9LHj8sfTAai0kqsSYSYsJ28Gp6vNho5Gf4TqaSak5gYQwC+wXQidd7CmA6vxOZknCQFOk6ly4Y1dDzGg9ilVrvToAmIJN9DBh6465zPHR+Yk9lokUydINiXrtqAIxiXHICJeE3dgwNNQirIsMGQJsxzXqyKEw53fdKFxYFzpmfusUtZlsjN5142ZELoPovuRlVpYw5XpR0MysRmk4FbOLoound2SOkieoS07r2gr0BB8NjsSNHffKurgUFekHyYKZK9yR/+Fc1BVADmdgWdcNTF2JfQf3f9XoB6B3bRDGnTcZ5NxseTcH95iQxqPMz6QH/OKh26ZP4apf9ISqDWCXOjGLXZrnYyxp5VqShxp6hclg4ZBJvONGfDBQpsUoj0uYBCJ1rsrhqu0r1ruVEVFm+o6ug3RMXvJLhhejYrb1+qJc95t45n1vAUTbE5fnmcdwkz6kJNH5zbM8bGwE/7uHMNNkQyAq7AxaKkHJ9T+ucw1Pov2xBkzr2OCp/uSz1eSaogbugD1yjmgTEv1Q7vCf1AUEX/MwtIBoL7TCfWatOtf5107iUG2rAoIcsrPs8n25oNIXkiGmkA3OnYYd1UQ81BGEDpLtZJPKUB5sqz8pLjuM8x9E4bwLRRPlhu3mimBaB+zu26ldqmObR0RqmdlUonROuzQhHwhFVVoh4Xz8/6YjoMfrbGZHs2MHTgh249FJg3uJ20UD6t/tccVdwv1CKNEqtZwptZRqW8YoXiq5C3pUBUGbRTM9t+a6rHdz7jEwmySrSk9Y54zk5HzEiozuT/uO4ID/TAS65UTIDAZO9QdMCaxB03SINnHg+Eplmg29pPsjaKmptOeV3L6VKdRjkh9qTShrZjJRpl/7WEaeYEc2eiOk/xabl9zK0FzbyJRgVB2vA6Z3GpBoNlfN5prIGDavZodoHEaJf1DNzuqueah5K29VzQ7TyA+igxRddvEck/tiTPm7Y1146AQwrjvZLOD1u7ZlfF+C8+/wghl1C0Ewu9YXI6qAizNOAVNFvLBCUBJXePzNielL/kRRp8eVKGGWVHol8C9kopYfCHFCQEu/h9FpG7ztEZhZRhTVh/PJln8L6Wdjok7B7pcFSXhVs3GxgDijvJ58BKfGbs/xx0d6fjvGpYOLaxSmEXnNhmRzkdEu4q2q1JvDovgW6NhoPNReDjA/Ie0XTFdrcuZC2K7dSsJJkEmixDSyIOUbHOMS67iLITZ3R1y/WfzFyybJIPz6pz5UsYWMasqlLzfY+UyIpXIh/hPTFzGaFe6WBjeJvdiLo+UhCoMH5C89LLnWbqP0sIrYkM1ozsbwMnLk8WVrbgDGcHU32LXXsTMcc2clXVs+msnOE3AOvYtgZ6wSuUK61554pKHp+/71mtASqA4Tdr0Luw8Av+zVIC74MflUhYa5cD8oO3H2vfMDJ1ayYD5E/ooWFB8TzCrpKlO5UPxukpoHx0EWRw1pv5UV5d5grtF6Vw887J4K3dFQPdgkUGMjsOMUCUfN5MzpbnCp8xox7uHVa1XlXXm54EAArHAzYr1gm+cvQUIC4pGxbW1/pCLQQsJCnimjs3l3V2sMfflEvN2XmHf1vGvRSOC2fvzEAQPMiSWhcffvIUZrK4l6LtzmPWHh2dM7OkkM1RgwMsSYjDslXWGMQTFiWTOYYAMCo+1JY5rtz2NAUQqsxNMgbqKjK/eMi7teuygjCLw+0h/dRc7xO2x4SDqw6mjYTRW4e6CmUk4SM615ks9e7bitTVFYgJnjXEq1YWEAvD/mRoyOVa6+BZ3iRdjpuVpR1lnYT0jnApzN/VO1V39KqnBLsCLZrAOLiPtB3gWQTg4U66UVR+vuk9AdRGPccdlebJC6DoiWbyqJV6h4gepkcu6qGzfErNz2Ps8MzODVlE5JPBW58rkY1Y9A3uYRXAs7mLOp+lt/S+u5mJADeGohRWoymXqO6RKLfnSbbwXaV0HhWRTw2K2+4rG37DVL//o8PCwDH2+dPcH0QTR5pnghMmZcuIpKmHF8HSEPH7ux1e33za/B+/LxZV2of+5aQug2+OYe8V/Zs6C3PK31ee6pymLhWbViGtMw/kHgiVhDv0NL+8Dwe5Zn0AhTfAtZB8YTs5OJ1cNbX/OVcALZ4tHwPAQkihVra6nUGlWK7ok1VOT8SdievsEuefKMFlQ4yP1QPunOsDOpWxjrsEzn99RmEagddC8bU5qWLy2HIWBqStvivfqCC1Kzr0RDcItqupVhN8RkYOdmn5aJDgqYVYfG0cJPeLzb6taUFDR2R6Jw6DnFSj0AKrILO2pMdbfjSp5mV7j1JDGi+B3Msoj77rnJ5Iu0FfewibRklcUSusLDQEN/g/Y7l7V/7ypinseqXNblHiG7aoNPp2uvyKcXT7+jcfrQhJ9w51s8mz4pGDDFwzlAbjMre4rWOo5vh4C9APpEnerw6DBORnEcmmM4YzToPPBSl6zKLyQRyox8CmA4w7l2AoaOegZmo6rDwk5BQ2xoe0cEsTmNF+jJEeJ2NhuY79xDqQgZgpjyZFSsLLUrwIFDHshMCCdQ1tFsrtFrnWmsm2FbxztOmdZI0D6koJkz2nKSCgn/GS2oEsIgjEIEP2QsLlF0VjzGvIIk+nAYOSv3Rr7vY1F7GkmXXsuA7vHosjlD6bTbV59q60RFZsDRxQER79KFWYrlNWQjr4+gt18Bo314YpWerhAXwv5MB/gO5lop2Y6FmkcihvodDAA3x6pCUSOZXkqSsxEMwGzzXJ9Z+FDkDeT0wn5HU8hnzzn0AyG+LyxiYnzT7OuwGCwZtY9mixbr/KbwTSXR7z48ZwOYq1HIIk25dofcHGqskLVFAPxEL8GWLgzVwL/OqbinCkxUub7vXLdYzyTa5YhmfoNMo3PXKsvX/Ec7b6ED1y9EsVS/jcFHhszx+BPPUlSkEF6tlGx5TqKKhlnZxLOLx6/OtJ7/mQod+3gAf2NFDhCRD5RLqtQnIGXvhXmoKf1jTBatlrgtM14kxde0i9RhNRhahohtwpAsdk/KEYqqlOCvVRW2112ifO4M6U32aRH+7daHliaVg51crkL7dSamMR8zeTp+MBHYj98ep84icARS5fqiIhGAEgqhPdjCU2i9k//MOe0sl1m8tjdnycpEngz1mK8LwJ+SZFFx7oXgP8sg/VAGtL92uJdwTjd2EStIXvU/jh3U0Lmip9KYki+8EIN24+bmuCaRVDYPbbDf7sP5l2m6KM5iMDFRl+B9+LjJAP87oiEvdEtEHkeW0E7AUYFkD0SodbLJcG22MFh4PYVFoXyg8QoIfzRiOEy8B58p9UQYojkwlBu0Yy2cs8PYNa8KZTAP3lWPIqMxvsqBRPnEB18cExvT4FwuQoVLS7SPn8K4YxRlQZ76a5fPFbEMY5Jue+cmxTFqlR6Qq+sb4IUd2gwCv+gPNaP9Jr9Gf0BYyS+Ejp530Eul+S/HaJnlMMJneoLcqvpMD1odN1IccqburdqlTD3kKVYTSgnNHk4Ps9iQ4FIVrG44eh/LmqEsHrMWvCisdDpUlZOlW/0T38S/wMV6NsgPJDurIrOeZszqmZyE4qFHC8ayhddTou6P8CZwmIyyoYenGNorR+9QNH5W890zoHMVE/FEzU+4jzeVRFNsua41HVUWSOCXKVX0lqwUU5zrvyiQco/AWkzy+JyqCfM0OYGsTzUqa9B+amzuxj1tXWRZy+PEEtj0ypWYzuyKixwmIfI6q3v/tsyYvzSjDhJWTPDsKKfmOMKKBSZYdcWsRwSyfcAc88/4uUmQy4HAKJgpp7J5OHpVTCoqDAwp5/39mz6/9Bj8eAzYkJ40cdu7IfxkhfQiL+/p6U800KyQWLNY9x3UD8NTGbA43aK8YkM2DaIo2Bki7y77vH7SAiQLXBvuQTAxm7n8MtGJL7iqkcnbgeziKCxZrAy13/AH8LwlDoux6GWk+4DASO2eW66ZDcfrSMpNL2gJ4UTuAecouwdX2zK4c0QAXGhamwtqKKwQG6TMjShZITEifq9c8XiGid1eEentw1yVvNdST7+iXml6hG1P3vwyNa7F05DipFvOxZXEfpjrCy7h1cBoC5/qLN9e9WVVUQOUt34k9GP3dE47rlCrG0Smjvusx/rc74teVhoAcBE97zyadafA1+/bVBN/Wocd7mqt+uY11j+IlQe2W/S+rdR5ofCTHWjAlrI/7ZUew9kM3Awx/ogDE0nJOsVRhCks3gWxMA3ocJgmnX/uefWj1KHlccbjOwdkTHxI/4GY+rdfHkX/PinszM3KSlJUgwQ/XqyaCqfPouLvllQOjCfKG/e9ui7Gk5fMTym3EhQXGe2CUjPLv2voWdyIZrjsZN2LXKCKhtcbvZ1pm+A5XVqvCfaa7NvjuXgP2honrx//evuR/gOYQwkasyutvNq3GLTeutslh8/xZCVBqo9uo/vIaG0z5TkT/7+xQx06vhzdBsbE5BCQHqghuP732dCsWFoA+MAfMTkZVJ/r1iK5MU+NgNelsmnhajyjbE0r0YQk3wXtMieGZUznauXuoVS+qnE+5Rs7Gl6cYXUm7UtXH5FwKjdB9BFQhYkc4e6Tz7NmFBKwiNbxHyCb3mSno71H4E2EOgJgxXl6RoxZ2eyDUh2Nu9TpnLshZofkENQbbRQsDeDBzbu3CRVXuCwS3gFfJEWL7zzN3Rk8Jifx/erZULEytaCW7f0XQvgTXEpDi6i7XejsTAEdcwYMGGPjagR9jmSu/Fd+bylmyrEQ7vM0TCFK2hFYbsi4jJMWW6qse/eo8NmC74xGIBEGuTyeNOQDhUvcVa5Ra9BG0uC8YBCpLcnpbTycCB1Hjux0u1C6+64m3ax5Zt9XmIfPdice6ycKNLH6AsUCwwhs2720uz6UF8cSCgDy4gkrt9fS6RJ8c6H7miyxuog9BXVaDqkuQb0sstf/VbZMpSAMFgDuGF9fE4aU2oZqS7uzcfjuY9JVeQb/TXnFQa4SVqKxHvN670pshifSlL1wMZh/zlbJ+lZ/+l3iVR1zj9iT/Z0EqDp+vrsQkhRcl1crvnvl7Aoek901H6MHHgiZp49m7masPtAiv8yQlfuae05s3WHPMH5RlXDJ/y9Q1iDmX+XQhs/xAFOmV2oXOxuVyUPAiq69C3on8lnX5SnRYnww7g/bBdT/P3X+sIFtubvS+3eGUYhrh3rTPCwlrseI0eGrRqLWRZx++lprWuXz/k7hEitDhazH9XlwPybW9U1mtGROGbu3LhnEhKkrgxE+30EBbG2AvypW5Gy3F4aMBeoPXIhRzSkXtGPgddHtEKUcIrxbCZuJkVP4C8WFJz0Q6AreKLje4ACnhr21bqeW7yhmyleAzF1h8xkQXswwXZh660FNiQXdnUT1GCM/L0+pl27BmgNnJ0ZdaQs60DX0QF9IJsPkVP/gQsDiepfQM9IqpKnPZnKjSZn5m80wYanZgkGXeTeOdq9/JLX0Jj4FKnJjr1REkDPwR3nu8IVF4Al8WlHx9b5pzdN43dz7TZYrwJBJicHdNzk/C5koi+amVgChk0EY0wGjf1GHe0Qef/n33TDSnDlQCAhnuMzM/1BEcqTbUrkWyNKtST7nqB8/nfwXo+a7FBv5wduho00kFmFjG1JTKSMuqz4sovszr5/l/HYBm6pdb/gkXGqmRJehXtt4/+BHoweGHpcCcpvLPgi4V3Y8h1ih8eZ3qXVWjS9BQEoKUfdiEY2oMPYuXFY4GjnW8/fEbbflDyU/iTZs/xuavS2vgk3VE0jXjGrDbwLOSQn8XfK9jeW4jA9Y9BzpzbewxldQJN1XAQ6nw5W/MK8EjroyVVqyURjzgNWx9ob1jMGTev0WfV6A9dOw9P+jm7TZOsIr+guMAR7IA4XdIKtKxPM2y+iAQl1AhT8LUSEMnkddBFyi2dqj4VGbEtdZt/UxFb1Qkl1hJYLYKZ3k0362/10PLn1cgGiVI/VVjGWbNUQEXDv8buq+X12sKXR0uYkyhIIpeJF+tBYwyY7Y23lyu3HkosR88bENXqornKpm6aZOQ2MDPUCOPLfNFRozGUGV8bnZgSEr5zlUIajQ4DrW0wJeueabLlD3/nBZ1qj0a5JoDwc1dLRJ1bKSArlNRB9ydc3W0wwLNxSUDuQXDigz03zCc+6To9qrlSQeKHGe9rAq5Kd5ZjeShmJEGVmBsk/CDYE8SV9Ufh1gNBQSaSjowiQA0/oXFL5brdUSfPIyeBU3+xEu8yMnVOj4pMvRTG/k9NRFIH/sUYpWZsqqu2M2ZLDAlkUTsvDZ3Gm+x3/hiR6HlP5ekg/onj2ykAJ8RKplc8kcocMTO2+fqVR1zAbPTN7nZK6SN8/odfP1f47nnIu7Yam4jDrepz8n8jcz3xRoxvkaX9jTFiqogkTQ1rXCiZbLWHjGFVFKWWo90c9rhnOU0SddMFYbrchIvuNWT+dYYaZEFVJjBg8AcSM5M08wUbkn9WAVohu1s1STTyEojqcx3XahRUtsx9gouJboNgXe6tjxxWmqerFN22lxR1mdLUyK1mZUOLZzQg1YOp9PPopduIWNEaLxWkcVNu+CskScwpodIxw4yNys4G1puY+/bqiNfIcbhyVRulDTT92XwabSfbvNMeY3uMUhHa/joDkIaNYIPdvaFTe6BCec1ZKDkIyeqplRtnh7jQrDR6noCcoomBeQQ+DYePqVu6kGWPUdrpa9ShDEB+QVXyHdwBRWr0ZF9q/uo3/2kCs+5j31J86z9nI+aZL57iPMjjUu88Vvj61IAj06PlVX7QNqyFJfaObQmGbtAW7RG9GBfxDpYsH7gSXBintTTPvIvizjmAYadfiI8rjjKSTtUZKhqMAUD4KEDRqQEv5Mfia19xu1BEHZNY2cYD93taMYhirtY+3fYAxPF/k/qxSsYDRYHrXgtwFqpqRIz6lX+2RbO54++3VcwLVFkso5NKzZwvwZGR6mC4kgXD2uddDwMKAcZMtr1FVduTtzjntiN9vMJJ67oUqNIimiXSg5mTaTH+L4roZ4Ye148tOb9rLAaeHc0mYFZtOmnTHRRvInBaSMrQForIFxAjP5EzhMZXxjGVm1AoSbWLSrwodZNir3pcxZexyDIARoACP2zGq6ws6+gd1KP9TVT+QbGhOdovSD5LbEjOEHlZ+MLTwGPhc98eafSRZx38Ck5aIb5nsNClkF8I3AcVQ8zlJKjokdD/Ppw083qitqG4C8uw6bcjwMHbt+2l2HFZ1Rq0cq95jI4Hl2wDYJ8l/366N30r6q6HVogDYmuqsKUxX9FzVM+lwMV1uoHummY/AV3A+poF3hzD7HCnYfmV4BgeMl5V2oVGm/HZ6QtduHCOgPKuEEspDutLEf8wjqA52nAVdZR0nF1HNkF0Tf6T0Ydb35FTRk+aGhPhv//zQa4hyGTJ8StkVdn00H3JnikdQ0yqmL1jFyz9ZdmUnS2R/XXha/gWUG8lqLEXM1HSsiIYZEJOC/+3FhPDQoJ+1q2MxpNRzqXUCUpWqf8zsCHgsyZU5UxXeXas1xK6KbkW1DIwDKSvuon2+wtayOiG7KTN0CdqDY6Wjared2gqvGQpsOG753Qb/qqorHVqQc3cAwI4pNWoyIYC9p4Q1LWNCquogFw1zja19bYCa6bHNQnH8wRq4F5RSvil6JezZtQgjeuLrRHr6oeu9g2+tJJoAHl3XKcTIPymmlKGmjkUD/YDCRbpSXeoD51AhYPLlBXxfsruyv4Xf8hewLvt03gZ+ljafR7QoxrQCkQ55ssTVHqumoUodK+HxOPlhCOMVEafIRELQ+Lwu/57nqIzrNPW2RMaa6fWSXd6ZFId0mD9jqYA28UhV0/rDVifpeG6NT4p2Tm5Xn4OJjIFwe2XSxqzcnP4E8Gdwlfq4duGaWf0c+ZIJM52h2g4MSFPEbvviuseMZeASqaZ5zBkMvQyLHQXRLkn7etWd6U0ppZJYJgmFTB5ByunrGhAujatKMgEde5OsiNOuwL+naOu42AIdulcN0gUSw+T6gcMy1F/7mD1iNceXjicCY7S79O+GOLQA1whvW7E4cPPbqnjV/1zC07qLlTxIpL2hbHHitLVuvv/I+t9N1eWg4UkNByPXIL1UwniYfftjdbxdDc89i+NGEQXoZsQQGcvZPjQpTSyC8d81IKRPSvr51xF2HmvKkahNGTiWNtjNDl7q2dlp9fbTW2OnPHsJC+y6Anehas0Hd8gXAMQTTPOLx7/t+hTDm24AmUbbCY5iYrU9N7NqvoV+LBHCmCR9YCvSLVpjrEzoqjGF2KWjP/QzOoaeV6K6yz5p+B0dQDae90cuKIQ3q+FLI4fkxZbLWudV1Ef5dgldlJGBK3Ya+iK0YzUCSEtdx720dJ7r2hzR8eVRF1jxMQHmYQa8PskUWgU9kVQimZpRUv5QkGWLKT54reMd4vzdXzdjqV1lbbPeP+pFH7Sw9xGURnobloCQmbZoJf/PlmpLiW5SspT4XgNkB0D7z4RVwFD8tgDaC7ledKNgxO6Ky8gP1/IyNhx42PeBAfRgR9ui80pC5R7jB3jZSkoXS0DSNTbRxxYrj//IEqcUJ7DiIs7/IUXAw+WVAPwXdnLK8AKyMKIjfo99mEBP/B+Wt+LFiTtnA1wZimMbHWRJPCJB/iXbj20TjGy0a1JidUHXHbZwZRLvH3tQToiWy8lh2OUsXqotlmnDWXznFdZWy/1XNLhDhLEawDG0FNOKn7wupPIsjukz6wTWVni6XZ2FNz/049a8yaOsJIMqxXJGRkPLxYAuSysWpYiqFhzDOIvEwoQ1zR1v49SoQfSlhQR1Elu/tbIL3JDFXawvfHme/6prF7Jh6Knm5z/0nsGeFco0jKHGeBKzRBnZnJxxxeE8wJZl09tBcKq/8jGVd4PEBDELkoAStGZ8XyN0svV3vXwOTswhX6lg9D5kWdHBxKJpRIBDFXB0YGAA7HgYqbGhbcus1gWyCEGhd3nsLy0h9j21zGdzQdXBaT2pKxCR+dHzwQfM3LApMFRWWA6S0m7ojDwUTxPF80PQSoCTeYpSiptlVp6Im1TfT4svhTkwq0QVeRRQ6IVQOfVtb7Lg4fJR7R0FvZElaKBdIN9XYeehZFwk+Pw6weYDOWp+cpnF8FIYh/2G6ferNpzJPJHqsbgoNYZgpiI3zgJhe8upKma8myUS3spIPPZDuzb7Iw5AsNoq2z0mz4YXgTFh08RS12vDvDiS3qTyG+1MFgAkcQtff3YPdSpz7cvKniKCUKPu4dASvhrrlKrP8lpXS5VfzsReawVVwRRLXk/JyxWBe/Ejooz/MDsaPJ1aDs45BSE7ibCj/s0CqoclHCkgB9v+Z9v7ReIb6QxRpahv3r/rTXi6nqWLPcJ9m9liY29OyahzAojmqqPk1M6Po6B9EFZi7uSAMm/4Fys9peO3In6I/ZZCbQaCRBgwVyQjJacADrej5qu11HiRIDLKj240kkboG8XIucVdzyIBT980Pep5yekDBfSO6KRsC/uwNb1X9Gp85f8D5Jj7wfIj08bFls7ZBpzfPRypn/TtS0nsTglJTAyibXwwwEOjr8H/QVEfc+0b4ThIWRyUUMKUSivM1lb5a3jVgs8ercj4FQpgD/UdzjQeiRrKgbjzVmkYWVn04zVeBoBaeZVNITi7gmQLRLAkQu773TGE6eJ3ogNXNxKBnW0VsSXI/z3k7R5MtvyP1Mu7nAyYOCGafmql2cRmqU6ipZ7gq0J+5GZ+mzTUHVvuhaSBUOkzmqjhbVHzWEpRp5YydvD61gDFWf508olW3roZ9iAHqB9T/YYaj4ABhTX+heUvuhA+zWEqz8e29yfW0ScGJ0i0kl6wMvb6YKWHEZt+9UDXI+FEcCpwgjjalvvq0qMM57cYHr63Lfmkjjrp2Jwk/NcVxDO8t9Zj5NlAU7boYvTs69QgXawkLTUoV4TwlKriRjayfJ/Ag68+SyD+KSLgq0STkqcS4ruNcGijTzrsbi0JYIkJQ6Y2Xnb4uXwsMmmcb+AxIxeJ/H8QDCmKXKybdbvyzVKL2zHv25DIF6TtI4lSP4MZ9bWypncbJADcP6dXMaGQUdHzG7rNBjszxOtrt/wmtkwT7w82/547seM21Svv14l0+qrHdN9KCXBICglPZEzjgsCODoVSHjwOaRxF0WI/JML8pQJQqf5zm8Biz5m5mMEXcgHIcMzABcVhpVHGziEXU4E3lw8cStz/Hv3GLgv+VNO/FkMgaYSSedOEX4VdZlSfu3nNQ+bmL3VU4HoyyzdA2NxypcVVC2yREDxEj/L8LSSNMF5POSIJQKNKWzNn6Ynco0CLtlnAN7DKepK9RhNy1THRqjDRvphDgQALA8lD+jVhXsqoyw9bzcY31jlSfLnD1gHW/ZPs3KbDVmyX5pHEzCkiovZXVUn98GLiOxdhdet7YnAyiYRFhCENVX9+0ikSpQb1fdIftqq4mwCUruhJDHwAx8EkfjuniJ4SHBYJY/pRPQshqgUpPrLTQ4hLzEv0TSyX99iK48nHpj8sDz443E5GZwlHaCa3vELqOKFERsK8K/obMHAe2FRpRiMrwNJ79YvLPZbECmGFA/DZbsIWrChnLxQ5mooiZYDS7fbtXoS8MACx6jXAR4OyeOGLCf8Svn1lzxltQNmDRRq/mSLvstIscWyx7QQO199OyoNhHZc4BFsToGhROCqCKvk7amowm3fBjaPWjJP+J9B9YdHbTpbMKUE4WAtGCx91MSLMCT28lvK7aTYLsOoFeBfRKPhGqYCEklftdiaQD0rC3QVWDtb2KQ8Lj3c3sOfhjm/MzeoLw1NBkHEx+nOiCAFFfsHgki5BF2i3MmE457qvGfx2TRFrtzHUwIFJ+jEPC2xCeMWnwLg8H5WCI4jz47WvX0+0vCus1vpI3F6kYOzmlusLeqxhDlARhDuW79UI/f6yW9SzA4lvqqiFLvU6+KAW4GXzq8CumTLcV7/GelBU88V2ldS8dMlwfyc/U1ypYO4tb3fmUOWhYYV50TnQ/9PzT3cWPPUkeH9zWTuyYugA0tmFYHoM9TM+aaq78eYzRaIoitl3lckCCHOWpX939bVZ62tqj722xsbqtb+KLcXKNb8MLsl2H862/guL0PMjmdLc3oTHAUlVAGYhmzcDk0nlTSsR6SFEDkXLiHm/eLTunec7YLId3Z85VHPQrJyxRlANyljPKYlH0T2dmjoGeiQood+2JK/eBRveeNYlXuhxDDaI6SY+ifepITGVMDjjS9+ihIWnmpCqFdYqjdVPEzIwtrM+eg5ykKb6idSaTHP/6rZ68S6BuLaklojXWjTbbCWyU/w/rRJu8GpphCdArtqVSRZ6cbmA0CTOdfFki2YXQUbPZhZLlrOPHsDt91tOrKlj06MK0B3IAv1sGXAaGIJswbmyWCEhzrJA3pJBLWwLi6xHL/0AQXMuoSgoAGBUJbehFxii4Vncc/7/4Zj9IA92waXpCvjuFJynensSQMdoUXI4ppL3/vtOyqqAWv1IRSAfeeejWihPzm7+Zr0QWoD7LjDaM8D2bQw2tdfGWNMJMdqgijw1YCZ13fU/W73+Dgbu9/UmFGR66d7QrUGdt+oBkaHgrwn3Um+7R1vlDqM102O6fTxayIFKfC7PpCCCU5Tei7SylqSVQIlrIad+NBG4Cj/mCs6t1qDwIGCxzVM69ojNSxxM76ww4UtRLPyYLKU9ug+QTRpzpeWl/ugAT9CuLguH2SXTcxLoRhnndGwu0Ou9Omzr/Qy01wa+ZVT78W3z6TGKmJC1I1tnJi/NVKa/YmAMcaOr2OykTWt7SoILYynmO7p6e+hxl0bQ3yfk3e0H3QxkfUT7uvXx5HYN9frYdQRpV81o0EmYDZBJQRMqWLstmhSFEj+dJx89AWqDcQSUcxtlHXccXOvl+TTzyyJw9pYgv2ayoA4KBEIBaq3s0IF0AmuyCSHclH97gN5iIRm5x3fcHX4IoLP1lKaG/N3wQ9a580Wl+Kid4bRxQpRPSXY7HhjPD8x/H1J2kaWiyB4xBUVV0AqNai0jnQz6Uw1THF9CBgJVRQXqoWoSfYIDR5Zosn6Zl1AAAHOQ7hApIBydEFKBmpfi4eNK9fr6KqKKkbg0Yv2F84UuDiXC79b7eXmHYE0iPtJOvFokteXzi9aWEnmNB1++90JBcNnNh6r2sFkpl/Nf4BicXQeoO8XQjfQEE/UPstpVzjUGA0KKUOqzQaOR39cEOlxDdQ/xlsQxHRFKgPjoQq1yNDk7Mrfi0LjydZjNMIDNpN7gDsqc1DkAETB6IaaBB11FhAL7TJWuKUoyN5oHrZKOPwUGG8lHfP11Rn/ZpoXaNtgmfOFivsCIBpdLvdumGpV1UfX+hoUaSIFAatFSPY6mQ2JYCgih8krW5DXKCMclBTzHCAcsn9K4q1/60BvHTlaVRVy8i3K/MVLnolXWwIxp5eIdqCS9BWMZ/UhW1ImnHps6Ks8h8Zp2paYEgXtiuEMD3zEQyzWV04Lg/PyozBIzUhxR62SN+c4zwkl/jAEMF2eg1dX6/BcNwFhrYAB5WfFZHcvIXOLg4HROKvWBnJz5NNl5Hv961yIMFh0ckbXpd/5Ra+OzykLSTUFGNHZhfGqdKXkYVbtx/Zfg2m1eZSAtVXFtX7QvPHvN8DGJqVZEZuAqmzAGPK8INTSzOvheHz3ZpWCHO8sKTQrXBqjpRgcGrVxTMYq0xePOPXoFnl2A7NqaZ31doPET7HpoN6a2VxcjVSJZj6D+e7+A67Ok4rcLw/FBN7Ixf7+QyTXc9gdXRWdGeCIFUBwWXAr8HlLj+urBl3YAuWTJqxJRbNS+uvH4sjRIUZhc/YAgvCvcCQfqOqOYnlMWJzGJBwb2PtInXlhU3xVoU3QoNwi2kFxAjL3z6aaifTiAusayOGtPE8etrgF/I9oQt0bKlaS75bclEIqyZZptRBYyG9ffbcW5QpHK4hw7QDfZLJd0jR/uUjTYnyNtbd2kICY2/uo3zeg3ytoTk/pzk6kfYmsYMlQYnvlzOvTxEWrcRyiR1HxrnfCY7TYj8ec+v3j6ZpyE+EEi5BsJMwCZiQpv1/hrUcPIK7hBCS0V0ffrO7EdJV/E/6LPvW3wsnG6/aHftmIC3F1f2ouBWJyl7mnouv4OVq40tDfcGZfjc1dUJzv0UckMAt/c6EG063F3tX7McNa2aqhIYxnUKEpJ7H2/6Gdr4Z0gfkbrxkStiER8u4eqy5MY6o5jsIanvhUEhEzazJxeqew4zMaHQTcq4Y8hPSK/Qlrlr83FrFAIZyY9AAEXyETJQp1QkhY8m+tva76f6PXBECgMJK8mO2W/zDTNFQPPMds0zmMexqALLN0VrBiX84s56L1eBmhu34LmbwZlGMmLSzjUfipkuF31yh6adln5RDxvqgkQwNvMxWIHFci5Ej4+rbw6Zik5vCEhILpicAd1pyPtKB5vmw9dbnOrAAEs16Rq5ojBCFbOqFG4umusai5wr+gzuIcdTxTvkvaiA9zFz3nhKmpsaORKMP1NR4iRWrZeyM4ZB8E8zrDxcjZlkGMaGmejtrhF0PIQrLMxiss6bvGk0aaOXh00q8U+EojE6fYpVh0vYodX5WWeCiMyG8xwhTuAOEPLz8vlYtf8cZ2eYU6qw6W4AyqOOzN3IEl1r3Zp56r65ZsEpzDS0OpgjX2KWwT1JfHvIikdIiiWqpD9pniMijDLYtLkjaNOr9aRKJjMyRdF+Ib8inHriHFBBR5DDI7Kkww+xilk/Fh3RLm9ietq5G+jAKvYaJ7cdu4egdOmXLaZdMHLxo9vsm8YRh5SzKwPg/PIeiKQWjDZJsZ3pWLGQX+8X7S1Ja2LbrSM3SxrIwxgQmGenc2PVcxDtfq563WjGzIlca7wNbQ1otMiqKJNixGXUvGU6zekTgjc0SJgNR3doVJD31V2pPDBiJPBP0ao2n3sx0ZMivDKZkq6G9RH4B5oNlmqSZ17XyYrtuRaEdLloZVpi4EVGrNvD6wT1CvkLcr7mtC84okGO76ZWkPZmLKYsyNbT8IabyL4m88tMKqe5sEPt3vkzBs8d3JhjNhq3wrNBhpzH8wT5/32mObcIJZGqoOCoDA7NVii3EeX5dSyPNLBpdzYrnzeUeAIswHBoVkX291yDjaXW7qznhYkbfjj0vXYfA8T1jwa/AtP3OxmLlheYQxhI3X5y2k1uO18e9VC6Gu/lxXnAR9cqbLwdA9IaczoGZ8jlHYbKkGCqIgD3TvhwRVn+1B1qOXNrCY7KJ1fTGsbogE8F/SU6Vi50CU4rxXSOfJtoX0GpV1fYDIjdfzKc4yqrtQ3GhHJK0GLkAV7M7E8giHIWjIfSkFYajT7iJZ5OejuBsh4Ugi875NTnOVAAarOnrhY9VGTfkrOh6bffktYWNisQ9WhSofJBsCUaP1E7r/we2Cdtw5lu5FuQnmOfcJq1tIhT7QPVuiFOvM12//aS9Oz7WFDnn6o75THN4QFzEHPSbqzLmFOQ/Z2TRGPZ2xvJzfvU4hu1a7dv1hnHFpsQdfjrHeVdEbc/35aB1I1EMlIjibnik2etY8FjZnuKWXvgFIwflozZSoTu9sh4gxtc4pWyx7h24of8g1k/2Egn8ERCDF9Vl470WydZPghrCHuz7kpFwfNj5NrjGpHpjitTqiam7PLv8MqWtemjxn5OWzHcjKoctH23uZrPb1LD2caOdKlyR3Uanz+AFmZva2vvBNbetzxChfGNv6Ov3lwf4s9ovR0LJnW74J4TpkR52p0TJ0XXRMWGW73UsnH8tKDhWKEm0Rg07L/mb5ymPD8T80AY3Xp4fq8iQXlhNMIz/E/Ul8aaJCJmTpQ9SRaMErDEoEqUPGhW+gUTApnbu9hoO8XN6H24+D74iKqDZ/OxKXQz0zSAroRMVaFqcJpvpxR0ed7rF+lf0ebdYo2pUQXHlc96CRMJvxrXeRDxlbyNXAJZQ2HgdlQg7qVb93tCdfywGG1IxZV1srywC4s9CMd8Ceg+uSFx8NCetGlDXQ9IUIeS16tWXXGlVshxMpsarlnLKviyWLlw9mdsHtnF+xffkfqMvMf01N5pDggkkVsy3xcFsqumTjZvTeOzuxH//dLHBu58paeV1RzWDHKOIltxgwPjUN4QuCylYk8EM9kjevfrMMrrZU4lP5/p0FVi8wRdxZPQ+xgXgljZCrEjQ7KAliYwVFZFATE2LAhElPr/FoSSmrTrAxJo53bbOw8lwWcBMsGiDIcGKXll50dDpAH8xVW5lC7rRPaALGwSdok+T7yHg9idr1amXeB9P+NxM17g9Y8OYfiGgZEj/KTa7Zn1pzmD5sqzYZAwRU71ZG5MrOTntqrPM1IuogRL6l5/HHd+CE3hdTo8PZO1aX8/WfjWc1WMIC+Hmb3LA1TCuiTTQWQQT0mI5rnLB62TVVesI8o5cy6th06y2rEaIDlYr9eJY3/cmNPz63Mge6qrOP7lxqKs5uWMQhCftMY2XCs5nnqRYFfbOmdy05fUrcdxP7WMBCN9IzFBy35le94tRtnLMF77hSjduzISdnHLxAjZ2lnEbofZ2sqItrtnW3YXlC63mmg6EhycHGprggrvXe/PwtIaAdMsF7Hy9jJZrzVl7Q7WxUO1ozSVIO29ASlWlkc1z3uTeFMgoKH1Ye79C9bhS3aMjrEdAvsHtfWX07tLGbH/9AFPIhFpB0xa0Nc2U/ZeNQ0zvsbY1E5aIluJMtJmydL+KZqjnKkfBnf0llNLKMPVmt33yfBipqKnuabja44RJsDV6pKZE8tzIvUEghOl78bNw3TvGCh8iS/Lq3kuh+RbcEJPLfHgMBbpz0kDDmhTtv1MAdGwUTGuDtwXi1ujNGRZTlP0Zkc9JD3MSzlah0W6vDs7jBdbug8gwJioIAvFtlLoMkb6bki07JRWCy37QmKSAAhcB+a8TYJhBTPVBE+ZHz2vrkeuOuzFimdOlZYKyKlZXjsOdOX949MqvNZFToOTQgAZT30YPETGLkpk89NoDyMdF1SYFJRKanUXChsad6l8jMbwQ9zFJX3jcuU+kTyoeqoXiKdUPMr+V6SCfb1KILh80fhDVWaUiHH7aKDeDp4R0BDS+5j7GnT7OPsEeJplk6WSjcRv+9vy2N6kJDayIuha9k0HvhuCX2eZCR8nbYGS4DWA9WvUlPhx8YVDvmCfjfFkiNBQHIy7P/0d1dXTKeggn5HkqvCcDKSEzIhHgi7qDeZqPKheZtAdSHoAAKNUrFU/5MIX33JMxShshFxEUT7D3IqhWRGGucQfKTylnbkrBUtGXFe9uWtStbw8ugIwg/d4SNtflDmSSKMyqC2AyVrCB4Xq6Zhe60HtUmVJIvCScLzRvGsO/93LcpGFNnVyl7vJ3z3nm8QtdRwusqqVT7dSYv7L1/H6k8WtCgDn0O8pq0oSSMb6sAmdsoUGMqXA+CkWjka7BnSMi2Zpf3+u7U70HgxcYU2OF1YNlp87S+P3U6VdwF/9UZW8hja3mBJOYwnR6kTin9FNKCJXzzSTTrUJy82QHsX0BQX0D/bNIDwVZ1eSVk+NkPMu9WhhQ9HT++cWe63+4Dmm8VTIBdnirg68zwGAq78t9t+aoZFAELlAUkQy6KLgNUCl4UfmZETdUJWHG88WlyPOi6uSxCAC90z+IOlytWnXwHX8SFSqrZa40iFLFy+xXV6Lu0uNU15nwGho760jUQmjih1ecM9ktZWYr31W5EeX7dzvzGRnBc44v61fFSBDvx3waWm3e4FxiIGF3/+SPui1p64osDs7ckWxdSrDwDNO/t+vIXQO/VWzRQv+Ww2mUzX4dVZJ8+HvSZcRELiNwYujhbAXSzM6y00CZbhHaFuG7azYWI+Vv/LKqMEeiGIPWZR6Adut+hLvikImoCRvHnnBr3yE3MhDnMu7uf28JQRi8JTkalff/+xxJZPFjz0RErmnXQ3irTnJ//IDahF7xAZWQ0f3KwUnSE52GJM8eRaCXhXBZ53ZYJwJczg7/jlMOFhzCWeiOT/+7w+Co4iNZsW49jJAxWdphtSDThKJutXE2kbzHoSrsDed5s5KB1nq0MYnT0wd80bocQZ+iwB5p/Se8RsSq/vjcIByVKHUceOCownQq5aoOIKQMo4/Jhewg9+2D1qIF7ywc4DGotBZ/Lk1q3WpQ/kYmloZfkVszUcRY4VpBDMVB9fKZKvc0UbRqCFkv2d6iZR4xDngXUpVRhM0c8sPjGqKNVjIO7qSgHBDbGxRvzbygS3Q+3Y7k6EezaVw9/xXqf+Doq4c7tAO8LFXezBnq8VLRfzVdZ6s8qWITf4vN3PXzhZrwulTryGg4inxaIaZOYLI8PdONRe5ZHL2o6CFZ+XLfQCYmJhLrO6JDkRxpqswkch0RKayIfHGO6nMwYTR5cl6WexiTsH+Bh5B9bBfwW+DBENFHMjBEgUV+wecGMSbC83Hh0CmTeaV+ky0IQxV8aqBW5JMr1I5ePGKV14ezy2ala/vTYe9HZo5bot0UpND1MactK9R1fjeBH12ehGJaOPsqM6u7qENqcOfDTFIGMu/Csoj/B1ZurENMKRahvy4CGWz5rRkFhdhsEVlYalPCglFPSzzy13wtds98zWj/Tcroc+k98CcsA3RWcr/T/P+vX8E2J0/n2NsKJ1keNKrjMIsmeb3w7t+jDkK0N02bmZ80c1Oq0pyQdZ1ZK8cAX8XKxlh6XSWHNG5V4bcIsOEQczY7cZbt2MFTbU1og42HNY7MdbLY4U3OUdK0jUqHzOrzfPju2fKiYmAygQzYxCw4kd5sAa2XUYPszJyjp5rB1UifymeENgjKVWy9jYrL5488jmIQO4KykAQ+vjmPHIdph8d9lQS0bBj5yX3hCFpuTtNVJ0TGbavkCb3MpJu04oTPJAEm+/WPzNFPUbLSbezOQTtlttgmOw2o4yPWR7TfD60jJPXRgF+OyIkdY1uY4dwUVDCm02BKEmPBJcmpDzQPPj4I3miTI6rcs7quzxeHuk0qYuEJrpRbRLwqt2e5YC6ubVI0DmiS0Vofc4flRDLWaZkjQQHVqjQEF5qnIrMCKOuj9IU21EuEiekxYgFJYMMiH7S34PeQqIOq74G379gR82pt6X6336pSnu/CcQUslrd/Ag0v94aeYOEY5zfWxJgY+aFrVQB/YG2AeSo6bi3SlbCcbUqYqrSNnyVpAZA1TTeF7Gv6RZPWxUoGSmBugEeDDQ+9/lqjinhXOeVYkC7Ab81A7NkeMZqIV4xInJqKs1SZDZp77W1UieKmOdUkNxik4hRRnxuHIATTM7q5WyREJv2WXqoToA56bkihmrsNr3AmqJi6bTqytNoPhY9xHKcWpr7KaJqv7uMw8uWNFQ4w5b6s5PujEgAFbV4EQ6OtadxvC8R1sU8UiQFYuG477Qqgm1oU1eRnEV8klK8snqXGZ9LIJ50CM64l2nCYe33IgyQ6NNudlUKB0yBY3/nvQOB8eIMtZdKbR3tO+S5xkqLjGb5CVqT1uEGKTbExf2ioBGETcdiQepA8sOH+ijpGigQxa6oxV5/R6dsDdmuJ47lWu/vLKWnCRZ9uiXHXBfjqPDJcc4JmKvVxKlYQ4xMccL+dmrvaEymgiZSq4BE9JsAns65jv1eznUlT3W8mK7LJ2d9zSAEUUsorfVbWd2t+h4xCAfunOJ4NtMkVZBD9VKr2IxF/26FqylbhLWp8iZVtU9YfOHjC7NJTUiOiI5tP02VadFLrGnZ/ecfZUtvew2727K+LvZWpki1WZYvAgeeiqvBKHDwwk2OZxryfjnC5z4AbsQUqRx876JeZijeDBPYxEmReuGNv/MeqgbRe2wc/3VXtar13Ohk/yAvB8plQTj/75KO1QOQcDHZSeYILVgVe6AnHDIPJD5oV8Wt5YzqPmaIfykDUl3qc91wynzzLjhdhsyfrJrjf0wUp6I/d4hehYMzITORx4GG9DlN6/WqHLWB2yRs1Zt62L4AFF5EbtrP6ARNPvQZdbHkKcWEWm/Ajna7Bfx9phP+x51Hb3Mnk+86FeOVKNYOp6Tqv26h7Mk88qLJ/DpI5PW36OSdWeLp7ikBjuJwkITt+UhvSB11lrxVhWCObynTeIwacAc3bKRMiiAEfhfQ4kGYFzk7CRKuJECMJkenuS2Wb4phip6/txf7Py8itDNhhDx5aLYXFKAACEARSUnGnesCrHVrCpltDe8B4ahwsjNkZqSpg4cLIdntDAQY90FvRp5Vai2qieqw6BzaL4D9f9yXQmQKTRizldFdHienol0RnTy03mU/aoGK2jH5eQfAG7A2hIDbZXS4bj1rp64DODLNf8yUEaRQQvHCX4HErt5AKKZaRq5LWKeqPhp+2lCcEegPWWEWLmlYvKr0f8svACaEfeVllhC/8Ob/uyAVW1lL7B5yFuj8NqFYY37Uu+KecNeCJmLG6GY3kN9j4VoX+/CofycdqTujtBJfL6MnXcXhALitZtPOjODovyoupEFm3H8j6zI2vE41PjKim8WZbF+K7Fpn6X0g/PZCu/nRwheDM6uxDOI5B1MDXZCYWgQMW/fSI05oNvA2+jJ9JfEUrBP9rjXEnZXRHSUmc+lrB6TBZie309dPXOp3XQ06PZ2cPYDE8nLEY+e5cHp6zIKK4rTAnM/7+dlB+luuNyRgR6oEzlunVfHW0fOgIpPnq5F9yCJEHAi99oVueeH7oBYRK/NZ03NdKUy5KNWWXJMELe3RXuBsC9kDKS6rVX/+5wcFX62Nq+3e33dKUOouNJDeBjCnApfrAd9FXDw5hvNe0bzWwallw2SitaYM4eMl1ySl1YTYf5dmzbP5+31chX00p3sT+Nb3aHpVHPVIvOVojkFFv0VM/gZormqw6UqV+26eD+5S48m0EnTtFdq/PIe7dpWiiWLWCvHYa2UBB+ixGsiEcPZVJBMhy2Ig4gnWtoEVSlS1QQ+pTE3bflrvV10aqYOUp47uAxtk/LGdjLB8W6lvGAXWoW33NgtDvq8SJLhaQARkQcIeJ/cmvg0ZYOSXdcZ3u6CInd1/xnSTRrz2NPtrDLH4sCLj5PSPrk0TA4FI6oQIhRE6Ztx9BIaaqzK1umuwDtmW18x7yPClcRzZzaf5bc8cBWxq1hc6poG4QGAXEXFktGlMsTm8f+qqGXPSCUJdvM8nA+XgY6ynewDsCFW85s+ZG7VEJrbMRUM6q+KEL0OPC2/Cchpl+Im1/nsmb7eJoYdeQIjCRcNrkSZMevOtmOlfKXc1XnLGyW98yQV9lNOf8+hLNHZmbiKOJal9X8qEq30NG5bvpPEREN2kXn2Em83xvls6wJUnaqygzDtWynZOG4bSFriVFzFxCjqCNPAVu0uuZsYFRd1NX5Ojwbi+cDd7LR44XUlC80aqZYFPiPc5Vzc6AvpqLlZlRlD2+ioiMxuchUdNtz9DDYhHFVzc8uPhvvU17SN8JjxwV0mKyoXqM+EIgSMBIyZgpwgP173foGjEP6HznPwUDzOMRJMXZXWx9znqcE8sL6cfMatSeUreDsDb8OlCyqubCLuX2FyyKFhEKpAHu38vgLzQ83Gguvr+lVXNWGkjcptmZMKbDU+q850pl9UjkxVr3khUhVsbGysC0R8WIHEdTdVM0fTbYxBWu4pck65Kb+r+GnMrOksHzfsxPkdCphG0JEEej/piEtYG4LIjGGIeOk/t6MuvLJlr2oF5MqumkuszIkyOY5SOcje4hJfUIjb3/nnO14vSmhNxvS3liHW9Nv2DnsI3BpYZwTboz0S3Az/aHUsAei53KMv1mgXkOBh/VZvTNpljcXmEEZna3Bp7WI8PcEqH0pdaHLDnK6CUKs/qW/iWkxevQpNfz6amoq9DhRE1R34rAI1MyWsmjQ3zGGKG1yHWIOONppg0PtLbELu285qxqU51ihm+2IFJ+8z15mNC4Xd/NtP/JQPWLhLDxRwCRvNzJRIE6zGni6pVcDVkdISbD633+v8xtvxujrWyOIXHhgYgYW/DZc+DG97l4AjOD1AJBUsjFIar7rdzDMtIiSGLZMfMKrYurpxZ1PC7W7g3FeuDhhRKUYNuY+OdocDfQmcUONuV3xHVznMdn5iIh2T9byFsX/sMj3W0Qyeo5QFOdZbjWsEctedmALoO7hW4dpJUGhFARRsCQ1MIj3CTb+kbhvcmVmge9bwqO4kSYZ6ClN5VTM5BzgOItuATlswLeQ3Dqs2+Xn7FJVn2AucN7ecTeDaZYZPv2iRaLg2/jl9Q0sltGf+N5/1L6658QJS01l3LlZEbNAXDK+9Ndg2/t/QmC+CVTyrlrcJ4KWG6Ly4pavCn6Dae1gNuiB8h4Pu8qmyh+CjeEDTPr8l7MTkX7t6t6j55bsjPBdkv8ofpVJfJOz0jKns0GgY5EnGotkKedPfX2P/7yAc88p/sj0RuvlzNskOEp2uv7w2YriW4nuAH5xy1imE6X334nmQASJPdkS25ON0k4hsyO3Rw+l7rY0CP4kmsvNU5rSNtrn15GN3m1oJbjncOiNx1n1KAqc12Ks2YDGivyX+8i37pGbVH/WEljF3qCLRyq0FcMW6YCQdE5O2nMzIOEwi+iqc6+3+DHSfBIxLyi21FpTIOWgn4tVTmTTHUH0zfrz1sAqssgr1anVl7t/RRLQKM+n+O6VYymjRZNjqXx3IiL8L3G/alOkoTQeN/8FbzgYCL1we5dBclSso5ZGVUsUHYha/zo2ZN2oRG7J7wJ5Hxwm32IbIlcrJ317LoomQorUxDeyTaPD1H9xmINYBsmi+JAA5ECEir2VPP3VhvgxjKOocBptCKb4GNDGiC+okIpC11NHvVqRDtDcIADG4lv4BTvUxSMeDnIEKbwuct6FJOtP2KhNApehW02IAno6wHc6HAWEjrZvAOH9EXXJiWyBHTf8mBCnt0kjj+xcGlCfHp+SJuRMt3k0xN4/Sr+QLmf3oJFuqtZYd3GCFnlnjs1ld8Zg3o0b0CR3fhhZgAyk4epwwvUMxwesSuf6U+cXU7Sc0XH5PlcQ4zZTkdwdSO1rQXA/ot83Tq5nVVxl5+aXouvw/FjpmYvyGoX8RfZYBuo/KMVuWyL/M6vHiIYcHw6kWaaPwNakmAPliXQOlKS5ctyR9AGpG9dV/ilefALrTd64j3EWgLbxGYm2O5mdi06CdPgxJ0aP0LH577GGnrNCTZNMp53cCHcFkdZWY4mbjDqQ0dtd2kaBFGesLPAOyj3HtUSSXVzYBahMa4cAcnr0rF4t21XaUL5KcEkWeGHX2lIGYVZQbZ/LEGQEk0UbjCRgzJtiLN04/hHVZx+e6g3dEfeKP20fJ/49Wrub7x1G02yCZfB8N/MfbAwBa3T4GF5K24NwSFeVVxFcHPCkZuC976YflrKlB4KY4JtG8eDpeuVBqSmdi3rwAKtnrZMwcUREQHp48kU771dPSrsPympTKO5yVEo1pU3ZxesMQ3WIXhlV4qdCL7HpWJKjIWBMv5QgsXkYeNE8BufY66egZNkHV3iMle4o1UZfBijh45VDt+UuhypY5Ac1Z+nI4tL+bfxqoEPlj93WX3h4ij85A66rtNlcFkrDL0MnFaBwLk/jeAkuWBa4jg0INNdF165vQa62fYVnU5j0maMt2pq6DsRVGKCE3NVhOoJaZLP9ECDnnlvNbh63knCoJZXPX5+lVPLaZUOZwxppv3vq1X4Kq9vaB86hXyAfJlk/aQc28VkPB9eAqvCdjKU31PqW6idhDMUmb9OmkLJyYbqfS+LvvS73jqE0aV5ninhCQG2+xu85bUfLBIr/VJKaFU91mbT3oeQHLHbdyH3ZBcdZm1M1V2FrZAPPKJW2sDkbwSOrUdpQUb0eAOxGRgO4YbLJchaAIASZTyeNufXSm+264O31mZQCUNJbn0KLmkZqhopBfh2y9yl+Cg7EzgSiqFQWgSIR/H13ujzct/bGa+CTYlKTJ0e6nCYHw7dPdDMxoiu8y3fextX6ObSeTkqOJrGAswll2Lg5ekIApy+81u9zSMaSrKrDl+m1hUpZ5CzRN+drGglG6cW/dJvBBJQQtDXG28jRWCorY/ft/iTWjATSaAZZvENlWfHs0Z0Pt2YCov0P/n1vteiL5pizs2gbEWYm9N7SWEA4ti1R7TaIL9gORs6Czu0hOcYA7bkih4UwBF0HoL6rU6Z0C0fpUDHJPJ73cok/m6Z4od0NQ+ThoEMRjpoJnHcofGAqGRzU13/vkAOICPyBc2QknpoApaPSqlIxDKzsrQcQhLkEUdu7mk7r+8WwthSCVqJ9exmHCDSzkvW+BxZRtmQx31mAtBgfeYSl0wxJ3+2Z/XAvsopzZRPIw94lHz6GhBF71p0vvWBwc1Go6oO1TPerB9mPcQ+BCCu42PKmCxkl4QPDHzetxn8BqfclMopIEb87YfIpzqcfDXnQnPrICprLFdZyWCH6qnN1Fz/4qO9T2DQog6QJgz4clEL/63Bew+0Yk+31CCYo5yfTiu/Ty/RgxWMLD/zdA2E7GGLb5OtSaHo8pvLqxNz4r1sqLv/ia4ZZnJlY6+LieOtVxEKtkr8ztgNE0rwKi3iDRNM4o9lMkvarm7TkNq+tFYzpSMoJPkJNAyYUt7xNSyMM4OU/NFb1mfg7TuRfSPhytZ/GuGRzcQ5OKgSNK11z+CuLQ8z6L/oCAMcBynZ7w+kGnLViKk2+cqjVgJ7d2ZgISkRgYN+xmeWieoEGqYIcaBLmhnFYU6OgjK9+apWmOIRKkIselGg0gj6oynJ4WTOfFpRhQIpWKOKdD9qB1kQrZzIveLrDKBKKPDZfSFW/XgT4OsnuXNLChGFyuREXJ6I40V1DD+jrFYl35iNJ6BdtM2J86/jKSiWvqfiUOPFGCT+KCRomJ355NC8bhcOLAnHdPMSiTxcS6uuVfiIFCSHdaYU5YWchYzNscyzvI1BKY+guJFYZIHHCwscU9TwfYH0JsbTDRObseVt/+GILfhRp6In2Aoqa+4PKuOOv2ioZ/JIhudAqIAVwba7URgNcy1LkoAMuAnfoojC1/mu5EkTEEQGpDwFKok7mP1wL8MPyofB3kD9Fj1z78qA9oo0rgCCYGlCjfqhts48rOMfBvgWAhalltZ2kt+37Zzt43xN7rAG3/QtQzT9ROZk66x8a4u0Eqn52dv08otvriHrlLHjA7BVOzgWmprHTXwfxZetHqO5ICjQaSQ2tv7Uq0ncJsDGe7CAoAyUdXBNx2zdZ4+aTkBDmWAqAMSOSOGe2Owndf5dywi7bH4zqzE33NUymVM/kWsJnUbuiSpgW4eE8oNnfL/fmlHAW2V1yRBdRMjYPZI48SmF2IZRs7NBLI0KVtjdnx7opBQUimtB6RVaymZCxphJRMjynUW9ZvHeh/PoBB0GTbGAWaP5UwoaZ2ZYPntipoIla8t4ZRQ+6/1ESelgjsy+Ii1pdfPO9QDxIenoaMp7OnJ4HQvwmo1lqgF8r3LQbADIivkbTVSwfdKjwuI8n8dIaZzB5u8wnUAwLYweHx7ML+HSTVDSrvr3KsgLMqATVKMVbepnpHa5XZ/VhG2QszQVhoxfa1SHBtXGCA+v2mBjz/gIGF/AC+ceULA2ro8nVMtIowEvJ7JL6ESitfX6oVSnqKkt6ViQFX8l6hiRq7iAyCkKiLCUhaWxaWY0JSI/a/OCIGgYFDxIsrm0xYVTsu1qZ7pimSaZspWo4pgqQ4onq+DGWUCDPS98/tV3YjKIrVRiB9+kkn/yZ+p1yU211Vjej+AQyki9FXqovhxUs8Jn2FR1r9dWTMGOoPCgZ2Vqe28aAvpfD3BEG/IHEdT99MfQWU05MjescpZvTdWa+SuaN6D5dcYVIy5cyCAPeDJT4B6z5M22gZh7GLsrd2Wvee81OkbLywqvCAb3/fQD5InF7x7XUXOlyP64u554aIzAc0RiVHkhzczhxlOaPnGwqQwUQwtQYRBpseaznFHUeoRfR2AaBQSX3PW0cQAD3V/bPFwFvRqL0aPIWBw82cPzYVIUhbd3la7UcaCLgDg23+DEbab5/aqRwjmh02yijoli0IKnPzFKFReVror3thM7cPg0mUSXdRCqaPyIMranCp1jRWlpaMBy1aYse5l+RqO5K4tGFtGwhPnvc3Gz4EN1HAG9noL2Wli9Q+MqHHMrHZDhi63sIpJoJicu8yA4g1xbPg24veLhKUl+n4AWdmNVqJotdZaCx4FeLd8cujeA3IbDL58ufGoZIyb2UmJLDVG+PoIp3ui8IqqejPBlpwOsZKFYT9p07OeWK9aQfs7k/gZybtw59gM3J/3vkXEes+go1kKSdJRZSN/QLfPhfHZvQ3GIEoYFLxvE8GvKGeAwKz0/p2YTeZ/ft3LU1n5hRRlmT9XD8s2dP+wc2is9Rp2iT7trD+oVO5nQZvln+Revv828edfN1OTp53JM/+6fyzF7SfmaTV3M3i/iyGIWa4KTABR+4UBA6Moc2+2tKa3x37ivqXK2Yf9NyCXTv4JzmBtkLXggUjSONkNxRS9wjf9RZmR9PC2zsB5HuqwZXmXSL79NSHc5RgyMLKcvEJYpzGjuz6WYoar/owbezSovCmDLuZ1g7TAd022v593FLAXKof1oGDg9QZwJLUe93T/LUTagFGgvZT/yX8HAmf6V8kaoELlyRQXO9lcRS+Lfgrojy5AZPDQ5j5RJeSFywJksgDiJOzEXgnyC9SaQ2wD1LeDlJZGG7IQfCDp1kXaO3wDqP3CRgPghAvWiCHsO49BVduQhOnTLc2j9D0yfXHn2lqg7mol+BESU+iVJwqFIht4ZfCY7xCRbf2gt3IWnwJezF/YERU0SJYnhmsNBktHfa+CUbJ3ccQw9mc+jLeJKdFMRwuxcnZfb2f7ApblAycb4Vha8Lf4mQTZ0jbY7IUbFvBIz8IzMQ+yixEFd6qq+wYa69BQ8z61BeR8CiQZVaFaP15c2qPbDtC/2HFup0AwFniwPaHyxvoJd6gt6lfsh7LntPRPKb4vNYiPyful+EbQ9M37RRVVCs5QFe5ntqcbym+b4vY7hp6pyYL1RRgyR0OT9SqtDo5HvgB84JnpfKikZOqI9aZlFYlA22MyGlbHnYA8EwwLAZGpAbyt5MmBd+3Cs5H5AiJn88hzuJHzK/bCIAZZtPyMvA6nvRy/360lugw6OSd6DLjOI8PkAOJp1sCqP9v1WimV1ffa3PuxhfLK5TItY0sOOif7vw8HvwCaKsrH2c7thdDFJwFHan5GIyIYLiu4AyxxKAkD9PmZxFMeNB/ZhdOmwagm4OsDqLK70PIvlay7Urk6uFz31ttw1R2RoGPMBNlXu+86uq9f78MAi9cMx+Rvqy9Xp09hEaToBrP8w0cNdcJN3KEXBNTga/hpReoMZK1n3O17STEqSdIg88NN4Tfj/YPNRe9y4DjV8W5b705CRt8TOmVGCjGzGUP8/cxJ+GdIVcVu3Ft5O3ZJhrHvOz/hPPSe9RmkHxIoi9FzBWHddAEMnA30Xgps/gy/1Z8fecxLT4uGeWNp8hD8LkC8DrE1NRErpEgrhc4kR3fcNvzN1HHQzxxIK3LkUp866zRe1WsDE14XjyMN95eBVlkPBEHI04FVFkjUiXDSyd1FICC0eov5BxV2Wfymhvx7+zq+hCYmMEmvMlsG5Ry01AM3+geI5BMnaV4jsmORs6oQkbDBrnhtnxbUtaKMAqIaJeEOsbQDPf6rZngfe26XJOg3NZuoRqPZoOpM5JN0QuyksUf8QyywbOXN89ZRM7yB3cAJMoG8TfTTPr36CvxHfYITPlcs7e+ZFyUJSxhpqfii5oUx6V3ub6N1hif4QsG0f/gJ43fVo/CryN8FzvXBw4p8OeHq7JSNo2ucimonb1FBHWKZHb7nfew7WOVXCoMcFrdkMqin0tpON3F3azf0slInlKnOM+e2tPiknoTxYwa4tsHPIpif4P9LtLhKx/ApYyaTcpLqqZXsEO1O+7CC3gMJQD2c2vh1ZnnJkCrztuDKa686pGa5/nV1ygfi/BHo8w/5YchRChFcTIRglYxvTFh0GLKPTzJxZV+JtY0NhuIDdyS/TYOTKdua8fN89e5vE/sYa3H8u1zNNL7kA/6/s0U4hDo8GT6KpN7T6DdomxHm+YxomLNLv+K+ejrNoD1FPqhh2hlSZowbxT7w6ahwiOvERz5yzizAVhfNv9if+zpEQh5KKIEqiPKHZolj9xNQ3yS8V1uMt18t363uDw5iUTF4y+CaqjkS8xNOEhIrC5O1D4/e7HN8O3apL2vX+WlC+dnkwtNx5bP7Mw+Uj3BXAeT8saMTs502mdQiYQe8mJKaRePWGo9cCSrLx5EOmyu5+haqwKbSOh09tFW3WxtZmmSRCgTJ1Lz1OOArAYr7RqnjmHK4zMhxoDNU6/mD02lNxl1KrCyz4QKx9FPWQ2UjoSKIpfDRyED8DiaNTcQzdf5oJrPRXrj6A4R1tQtdJG11GTV1z50/hLcjGf64QhwiF8uDNgWDL4kWSOwm+vVNuWqF4kpKSzq63RWV0pUVzRvBmgr+NUCBnggQn7R1P43QjnbC6wfeTVCCMxS3rIvbqTC3uCUHVt/5iC3r/AOub4L7hQ9odsdxCmN9QqgPg9Ydn+7EYjE0xGSDpTPZDFchNdPc8uaU3k1i9YiO1yOzee/Eo7S2bLa99LFeADLAijVBs5HnQBw9ptSWJsRFeWOC8jjYYyZJ8pQCMiiK/3g92dYbw1cCuLpRwg8C45u7UQCIGprgtsiUnccia6SaVGSNbL4j5bSQ/GOoVpOXHIY64zfWFqxkCTpN0Ms9isHWFeVEm9Ic7wUWrdo1G/cYBZ7+J+Od+QYQjy3hAopa0uvGPIW8GpEQyK+KZJNBTsshLTmhySbFGIJzkLQjAq083CFd/7WnzWTruJiZBRvU72rLVKiSakPOE4ks+UAtQ13o/Hkd2EcAzQcT5P4eySwuJVgLwn9WoNkLoCCPouutb+wNPIqW1Co1NgqZDLdtq8LFhv6UUqM8aXTQE2/14K4j3bxs8X+WySDyF6w8RWRVtVR+rXCWNSGWOlBzUiL23KJwHzX5sx/6qd7uiNcSDixXVDYWuLFYMil3DS/2d1tzxzcV22c+/8QVAHXQtjwbdWLrypHcXZYX3QetvN0TuLTZI2GexAWEX695J3xa3tGLOzvFNwEGXbNiAjUWEA/UdptFtFLKABLvzHpNBmT+HhQvDuFr1ecTxd1moPbuORNuNBaKCNJk1xJ4j/Q4g6k9NPoND/rX2LuOcowiAZBWWujtSz0reg36P3HL+maL8Uw8emD5T655qfoGLl5Q0r0dg8LBOS8xm4L/I7NAw3FflF5F4mNvAIWA0d/YUJt2cVkNheIxXpBid4iFsG99a5sjkacOtSRS6JctFAWRbcQcZGeZZFLKOuLF7VKOD7HVdVZgKKcDCaw93PrsYRIDi2NKn3WojliJskT5YeDsbXNsm1+0DTua3qfnN6kNWRLsvATMZ/KTTH9b1rGXRV6F1eb8ihKpFsb1kABH8w1TCJVexlDsUOQQyeP26tS7MXQ/Sxj40j8WaCmHxySEz8fKIaRUaZ0YnJMhQ0I+PMLiorCujzk+TMmcxTPTg2qr/kxU28OYyIWDa/FKVvuXL4Tf+oG8oqkrjCWWWFRx18aSRvSV+yVaiXLbhMwA6MBUGG55IDtIoDKh6x7odyeyw9HLuO9a+NlWxCpUNz1CtY1iQplhp+C/LJeM5s19DL5Rlr9n+IozL5zy8VsKYD18D7xyL9BYI0DVYVfNoLY0eIL3aDE9GwAXJBpaMo5SzjmT2GDDslUF7KdOvv3YW+ZbsOPqGXZ0mOA2zUdQxOBUMk6r6a9NO8AeXPEyV6YP1bEgGQA9twmw4RDMMhWtkFTBwBrIiM0LHHQDoKZMM8/vJB1GbvSGgkGJzKjbVqWatlCiwTe0tchUEWSmY3UqNaomZa61xBpxYdek9TWAt2BD5lI4ByjL73jjEnZe6Oa1gHu9pTptxO+a0N9ZjNW9ePYYhtijdp0KD/7JQE6+GZovS80+C4Q6VnafDpOUspNSO7LxDS6BKpBija1wt5CRe55D5XTdGto89IuV4siYnCWgSL8+wqO+8Nl66svf+vkwUkXkbmWKZ2QT183GpZ0RduwBhEmdhRNKAQ2jgHN22uKqv154VU3ssiCdwItDaByXwSeJqXFYQq2TJ/5T1wFt3dcXZ+UnCXWbEYh0wURiopn5J/JIYyLnJcf1a2z7YbvAP/qfrhOPFluQz8LNRvWSzFKZay57UvFp090PNDP687Q5x4xCrhIS3SWRq4ptWCOQD1hnLFFFAvQ+YVsThDxBMvDsDjybaBAjOZmuQKa9U80ZMG8MwFT8DxRpuemma9UXe6q5QmPwDt5c51+Wr57oWmGl+p3esxcWq23Nyb0sXvURiSCyqK2kr292SNG4d9gzC9OGZLwLLRP7GpUWurBo/0S3yvPSzkS+rvvYxa+2e5DLycycPODU1EXKyQxWbiKQafT+BbG2sAdlB0BFiN+MhLvhR4i/QYzIJmHuQJYwuEy5IfZCdPUQ+rDZZja+zA87+QX5u/0KOeM9MJellFPouyjhuIWpldPLo8FMc4ChIUu4DUP7GMWeJG6AR/H+E3oEyP802bZoFVjaNcmBLBaHiGej4csHJxKiQiWFnkxIS0RKjII7nmsNGkc+11OgQpSC2nPA2wmao7p5AYMcfVMcq4e/KwI9Bu0oHFqwh8J0K6jstVxrrVigvZCfVsr52I59o5vkdOnaeYFzx3uTLwHTNwnRq+D0TTcuaogcWd23dFgxFD7vmSBlN714gI7rAgCPEMil0GVoWllKloUfdCTY+A7pjZQIwriAFcv9Gv1EeCyGvnQS+GDWtU/wpzK6UreGx+TzsY1YiTVuR163vv61PWsMBWS6NdcnJM3CJ4NP1UQZzgJP57GgSYSBe3A6/od/WyWHip3Zvk68AYAGU9BC7pbuF4TiUcwvD8D88Zhjoxu2KVv79RntSfc13vO0YBUsv62kPPy7UCpDhXoQb25LZ+//GG4Lu63S1kgFbX4OzJxjPfI+8Xt3ZyNcQFgnfgoO18AVxB4wVD8pyHldxTECoLhAqZhoGCTDVLniHihBpzZAtbBJ+HcrF/FkIfGeMNfa2Ow5wL3yYRgLMIdGgX35SyVWlNAwHB2JrBqJucOEcGbrCFsp2H6v6mSEumkaMRL8Z2M2rnDQw3ob6t3smoFZglsP+WKBkOAbMK+6ia6tOpenfGgS0zSXAamh5sAyxFxNnp1upvRGhLch4ibcMF5EFe9N1h/l9tgZMUudCtkikid1RlVlaWGbWFfUbgkyrYZvc5ERmROz2q7dtXYEs1wMzAPUqPeUcm2kyk01NZ7Kx84yE2oGIj2FqLEiLA2xcFUZ3fRKsvDqNL01uEIY9alvpafAFPG4JmZRiS1O9nVhdmppyRFwjpGaMwoKyU+hdUjoNR/+laFYdNe7LWPYEi81Ek7jxhGJdUnbnQDrT6zjhxa8/2TJhBp7/EJY6o2SHJZQ41/3O+Nn1Sdamsm7lfsIAbC0FQUFdVRwTKBA0PoGcryy421BUZ9TpLa86r3wTfRaOn36UgcxAW4HNH/FIgW7QhAJmilo9e/5FE8GRwoyYAulLjz2Da06kITW18K9Y81QvR8jep4+yUmIYidER1MOOQQgXqGYlDOnOZrYhqQnB5zqbZlvAvyv6UBxvtAEC9+x56GVJcstNqBOedO414palndJ7n6HkmbTXQj+8ly00UMPQd05N+fdahpFZ0IkB0r6ScQe5rPyCrwndPDvRVLOYxxiMWsmCzcvH8lZs2n4Odxt/9OvlZj/osXCe4YEVgt7H7y9pWarD7mK7d7slARCH0zOueiQBQSUQH26Ge2Q5qk20kMOAZMEfLgISOpZolTVUOcbHcQNpqZ9mTX8LXLDDG9YFJpE93bSXpXpxXhgG2VBsf/Efrt3fS2QhlDBakYpPhjRd6Cu+RPMnqgN7n2vYnqRzWhgJ1/a01EH3kFFuGpbwTpde5vc1o3U7SCONeFDsC7DmjoUY149UNBjzgLRP1gwcC4UlxIaOZMtOzx3kuvOSMabsmEjWRfwx0JHBHyvE7fwD1jXUcjIZNlmxzlSjp941UyD4Pwbd8JqkkMmCfo5/nMhuRhU5qPiOIluADtFJ2exDn/ua4l/CI6O0a6GH7KutLJvrPfvKVlhgZVNkaKhXLwKo5N9+r1BMb8ta5kNeU1XlblAO1usY2QJLZjKG4LJBcdr3veGJ47PJ1Cnif3bhzUlaguSzDJmv78vOwygd5jMowtrPKvzjREBSo5UPOqVKG59lqGduTpLRr6WbdJW9smk9qwHznKrtryScP6HxStllHemFqxgUqiME0J1ayvHXUUqbLAt2h4xOl2Rwxf11yuvF3TpTWQx49CbekFEZR0Wn7w8pa5DKu7iGa1z3SmwRSU8RO/Gos8Zp4n+RiJebLXFqwSxG4O496cgO+SxbPdzdfWrBJ6GifCGhDgHqvjxsi+9i/Ipyxoj0F4PS1qxdP9WaLXyDAR09SvmuMy1YasEj9av2bV/OlJo4zyNn1grldFTOwpnaUHaAdzrCkfvUE/gK519Pu6ugKJgnpBs9wlrcPC83z6k6F7/U1xgg+LAYVkk1vIhH7Oie+Vq5/l1NBhy4Ec7yp+Bhtwn4FlULGSi6cT+agXyFoJuJX5Bu2ZWBYG15TSGsHBA8aLUyIFC4dgqG/ubPIrpNEX8lFtQkOdwEFynuGDOb5LziUK+vyUzftoMRUfeiifDWA58jrcvmkW8OuZCfmysRQhdTzCbHWwGjpjm4WDMmP1KapZI7bPjLmDVbTon3Hvz2B46VJUSZI71qRxbMm7hd6vPodC2OOCUnIpqirE2FIju4Ijq95OZn4x3kerXzlA0tfZa+BQ67Zy4A5XnK5z8E6A+0vYUAcmOGcDaSYPjXjv4OnhebXXfDSAbZ4rcaihKm0OfzSOf/rw0bT+xAHYWfoNfOXPwP9uid/dW7DYgxdmG8zZhwBEXDbVaJkmgpkwl6aX5fzpT0AqkDlf9kcOzJXqiTzoylRFGy6Vu4D4x+JCTFlsQPG7e3mbyc/nhTC5uByXbzGd28ArbYcRn3tQJNkV2MageTZW9w5AnT+9pocZbzb/tgX6o61FnXrTR98V++Jqpbi+79l8kLWSJvrb5GlI+ZUct6exEgzMsiMufHA6G5oK0r9P4o57oHXlabwlVT/gZtZ8MDZLCXP3eyN6GFPDpLIWrI8j/DRJwZgB9j/saMnBNoRGYUcArQw16cWUdxQ2+bTazIqzU5TY9thoglSMgDPFYmVpT+X6J/ArxvZXFC6YcW5uJwZHdv56naB+IwsgTg6cZYKi6e3bb7gjukuuAWvOISfKWCD1hKnQbDw3GhWEOxPJGTlpbDctQiJ0lDtSd4nsth70WdkZFVwZ/wi1C2zokIt6jLrEzuUyvKc0Gnu8oi7Hza3ByBlvDQ2Py5RFy96zR232ZpY8kNNpxPRtT06qL3j/6OB0xlrc7TxHTN1hMbhpXmsoNpg7vW3EddXOJhhfEm9TdA5fBHiOwEKs4KsVi1W9Hro5m/lNxppntkd5O8KXZt/tFUCWAQz6VIrh3yEv4abCM9imOo4hE477z9+CeFmYEYoCcMh+tnhHM2if/tA1WzWd0qUzPuebO9NvcoEWxjSr5taB1vh21Y9P7VKp/ZJo7l+RrkRyViNzp0IuCqPp6V3syrVmwbURpaSnG78/EOvF4ame77J0Tdspl/zQ2JWx9NlD162E+4nE2Le91nQHNy22klsr66AvvE93ByxggEo/BWGfdxmeKcwv89D+eP/fT8jkEGVtoRR7RntoT9PjiMPDzkqKDzMnbrzC4S5j0BPRAcutJL5lXMK1kyqWl9qw4v34I5lM4XfFwQY4Hno/5XIpVnTGuAjtkrQt794evjxmNDiftZ20BAU7ElFHeTSmcCbTkWm6BAB3myEZvhvy17E2PQHhYspFbHRLv/XBjthXxsmhmpgd1azAhoEuH7xNRyE173T0NxVIzukori2Ja1GP37f9FTl+5OCEdYtEO6d++Kox/o4YhoB5GSwisi4Gaq02cG1osHu+rCDHtQTAN86AI65z2n44WNaRV9ryRiIw2daN+T3dZmm1WHsX9/+aF4HOfrRrjxS2Us9i86kCo706hv5sX7R9BHI8HUKUJQhTxEDGym/2crR0Ej6VwsgWYUMD4mrFLxmJcupNFQ4SSau8uceLQqCdyxVQg3xk4HuBXpdrm0QXgIZlEkypifJD+7Op2HgZYTpaUoe43rek2geLF3kNwyf5ctJLKvcKpw155LBgl2aUI5e06Y0v8JpF+XzSmNGSMjfGejSI86l2uZAxmQniYUJuSS+v1CTDdwMdpbTMaFJyVfpk2XvJKyl/Vt0ojM3n0hduDtvdG5lz07/SAR5S0i42y0L0wvrc3pIBCegvhR9xjm6PE6JFop4RcC57KU91lD2v1QvFcmvF3/mTgR6pXbO+rg2RbDMHxIyiNmT927aXvSRFqns4i2KYBdjtNiH7uHhmEM4iUroCjNVTemBBnSB71pdMvd00AGSXhLMVv5uE0XDQW6wfxeykDuVO7y90e6pDRRvuQfIHArBeKqe2+LhLTo0rJgsRTRnVqH+keNAxSzacyc7ZNEEZ2jFpeZmjWlJR80BspNfKiMmQDNorm78wqnVKDIrRGyYJK6q/W7Wd1L4gsyPITw78PK/n3gbch94yvb/BgVSCNPVHhKT6QBOFEvd+NF8sK406ZOvlUHZydT655+CeCwc+kcmn//P8zhCLEmaEu/hcGLVznC/C6HOTQta2yjpCr+XbiY/fivrmkSa0c0P61CY8qPPKkIXGop5IQ3ibxnTq8KcAz7BJwqP/TAYItGZvvCuI7RFpyD9YeqDQ3SlwgZfYn4FPTZqTlgBK30GIa/TBC7YMvKJxCNRcr4JZDvwGb51i83EaiQc7itA7zxi2xamJzCCUav70lVGSg1ChhWOxy/eli2mTJVW+3VPAhhQZUO1+4COim2yUrXB+OslxclZTs4CWMcinxOI4usXgkAafH1ct4dzJcDjDu5DqcUeCz0WIB38DAfVwEm31VjhzmOk0/VNeQODtxHO/ZcrhJdpJpLlPtsxLqTfeqdFP7xKv/tba/DkUqL14yL0B1h8y0AyHizthsccS2EAS3OfTwWuIeLwAJgEam/NgThMvIFHqL2C1j0g38jGBfD+yfbs7dnLl/4JHDW4RQ6OigVsHeJgyBT0cUFYwpLvthtb5+1YXJ8+YhQzyGVOVzqQwiGgmgk1sW9GDJ6c0YOtk9oaJnQFh8vSswEIa3fUKP4ek1z70o8gLgD4P4Ir3plp6jxD+PNRYC1TSAdHeP9DZNd1cGn3RldJiocqeUihtP9kKgxEmHfpJoVcoXVuTBLnEdExr0sh9TQFihTFnJ/z9HTqPiRyiGNsuABiN8ZSEP8ewzbagls/5Wq4Lh0/lUZ/BOd2pxDUdP9kT1eyNs3A9kXsVkEpVInkDZmas0VnxQ+RQNmquKEJAuF37ULlbKuzGCz58fKu03EoZe2OiM/PRXxy6J8w05P5RUJ66ybnAzzbsXBjOwtjQpOoww+PCmoyVIdFvtQcd2yPon047PTRdSOrdJNKVjbBGCyc0iVygGhPNEsr6x09sb65FcgwqB0iEguvRQC9BX6DUfDhMz5JwI9O48qBSOz2xDGmfUE1g7+9Z1Qjb0Ky8od+d9M3CDMUc+5FjaS0/g0sgiVPA3Tiiba3B9DNK0CKcwP+JR7zKL1YnNR08hbzfnoWDE17rM/RwBM+/JGHDMHPQOTt8rU5yAks/7XTMDfzb9a1CbjQf8KpeBpV6dEvdQXv9leNCPQ4193osip84dNdaqTBubHTTu6thDTGTrlkF7WsnyyYjFEjyS7YahI+lOE+F0GaZ7Fv/QH7DtUE5L3XY/c9vPsN83uZdeNw+WqaQHbuPJvk59DHVwTd3+ATOrmfaUwRmSdBZucvte3cJxdpPHKlYpZ6KCpnpcNj76Bw2yQmzl5ZXFgCwr/u8wMMudc4xNtlv6adiYDGVt6UtCRot+BbVEtiWbdhjzRemyu9CXfdKreMBLGGQJb9w1Qi0WANH0m4cS8XNGY02lr6hybAStq/+sXRrKLI8VTb4YOap2+lMHWJETCywQ3j/oLm1ifkvfzzn5aa/c/YQnNBWjC3UkOKRjeCn9JWrSEVd4kale1vvTyYsMLc4DTdXYRRtsCQIOsTBVe7jV8LOv6nhAMOw83FqsxdBzRTO5bp6NTVHa56nEYD0BYWXEu4TuWCccgzE/HKGlf4Fxa9EHxunR5sqGPvXFsdYWJHhfjYtvjW7hAVOadamni6uodAakHfGbxcgA7DRHfVL1iBPMO0KwMSLp66aKDOLRlD87wgBnVRnPpMxQ8Y1pXjNyxx+QgRLq1q/6K3h7LcPVU3WpBI97DUgnk6kPWjpSZiVm2SIBWhGIPW11CZ9X3x1bsn75Odk5u54TFJP8KZoalyxa7lmx2P/K1unGHShSQDLYakuWAP24/AZn2Nky53NMp3bYyE1dCiP+OonP3yz9nb1meVDcH/0x3YxzBAZiZGPh0lDrVL2v34XvsOR2hL+OMvhorHp4AULnBHvwJn32jd10oyWlGHxJm0SXeA7yqKZ1f89cNsn+q1tGMElov2Y+pHHJmFhL3ymms53F4iGY/GUfBQ1XjZHx6IrFBYUxH3zN1lcPM4nhFO841nIYW9e8etlO8RKCA/xOK2LQeYmiUYysEUqsNI67csfhwwitkehCK7YtvwqziBALVIH9tvgZwt1P2hzzLyIlXcL6w/EX5T1zfIC1cYq7QuZ050Xqcfs+fUdDqaA7hX2GuP1IoTKZRiDDe6TqBLBAKJka62BrSQO8XDDrDJvbR+neVSoZq10RdynrbrYwQJneyipg6f+of5P0LKdru2DSjQgAMDw4XtfBz0jerSRFMzJVNApjLXNks2roJfs/kMpdmt4p+8Rc5YkiGDjrlrS8gW7vMNWYYxu2nvvC5g7fKIC7ezGKY9ynV46N57hJtTjIz7wOu1+f4nnsm6+BYSgLiqGZ1kcFWrAdSMdnVInE6haBYuI5CQiMqdzeF0AAjY3i2wBQnsHHFnccxClFZmUtZWel/lgLrfoqHPIBBd3CjqqmhAigCRYZ7x/YtnTzQ1uY8k8JfbtJ1GDZH1CdTT3eKycyS4Uw1cI+tVgnh3JZqFoiNhu7FsG8zAsIAHOJ7aFV6213qceCYC8cJx7p7fEIBA+FplHrJXsUe0KpdLy4ubZhmTHEQbzdtIBdrfWfPuT6qhsA12n6YvsMsHTW4DVlbA8xBWHefzR7AAop3po/N899Epb/TjIYWNWPmjjQnEcdAAEbii7iPxainSK1ExNNPj81jJ9JARkfjdLkANUGwd73zzlSBJI3flzPU4/tcgxWpttkZzVacvhRNFdV1BEkx4K3M+et9evIBnkzbhGki5f1Y+zcoeH3gnMs/YHGkEHQxuSV0VQ1l7DqOQ0sP0DzNHcs6Geox+4QjCYiGvj6H9vYoDYB5AV9hs+6h19cvcFuo1mC0YK4BihWgES8AlBjS462k2QZYlCQ27sZ5P6i8LRFr84pKlSFBiLvVNnxhtxd9hH+bG2Yjqv+hKgZsQYuS1ikn7MjOWH66G12fxA1UvfaoLpgF6ITp+5zKn1kJuOnoejfOjRneRtvJGPZcVPtTsIRZX+DcrrWGKWuMQO8qe8/8jrobxYoN5LGZJ4z+YZvOvaRGGNx4SiW26Vabe5P9IPg6QKD8a6Q1FcY19KE4esK0ptFQDqbHU79T/cJ4oMlNZA4sRH2MmDswDT1RLOythibVqha0ZLnE1xCXLXW4jGUrUQ4QSmmUsfMmgyBj5R2NXZZYRBc6xKvUR/9PQVV06DblgcV7S71tujvXRLjZF+N5YSy2iXiuys1MxnEA350+ndtt5PoXfJ0txByCdlRfnqdbZ4uWFye424qef34uHEDPhOuvLUmLXe6AgHef7Mq45xXEuuQrTBFMgi+1KvPnzOYM5D8IPDREyO2mNpqQirhDd3hUJpVxQaOCA5a3XknPevVrPxU6k8FQe8ex926ncym1wjzfm1nj/0BSE5SVO6OLKvSa/MfIFKGKknVmM9POSkqxEeOeexpopzJXWoO7OTvycUCUaV7Xh/qIeesTE69tayNluoFAil0hBVE4PqRXs5rvrz+K0tN1+Bux2Qhv2PzBPhczRw2llVeQYnuJzUJMdBCiZatQ4uR2PlhqVlg4HtFcUDg/zKmMvoxKxtZmDT8G6s3tiOhSHCCmSKEqk1qeP5TxC75T1LFkksFB+OkTfHHP9rWLlo9/ahSlNphrS/F/908TB+0simg5wAZWm893tEgiBtQCi3Ro2zdPl/IfKvwhp+8CQMJJQ4rC+6h7brxRqN4Utos8/1io1eBhXu33IR6miEY8jYGIe95hi3GG2s43jm6PePLVKLkSTKmVr5OV64Q1ZSuo6gs7MgAszn6C0XhudWB9fgoy+/7AccOJYLZvd6W36d0cl1xGU0nFmS6ej3iXhrX/P36x0qLwUK7AYL14cuQgiqU98tPjAGhkfGpOi9owCAq7O/jgBVHI2r5qfqyqp96VWMPuaafNaIuaprupHxatYx8reKiRSY1AYaSYAUwireA8uEmmdysCUSnyQ7Oupk6VklmcsF+5x469ja4+6uizub5tg0QY61kg/EjU6uGpFr8RhRMI1qIxGlS6OuMVzGCWGU1uIaIabimRxCUrtA27JhHEdF10KEsyMDCvtnKQ2lbsYse877NRu1GSSYxwqaZt6EBVEOcyDXxlJh9tJwEaXd4nHlT7kk8PzPwJ68+FWmywOpY8skn69UBPLDL3aYEenVzrWHkW4j5eKP3QJwRf1QsHukHJ7iPZxcLL7hifW5AbDuWvQLnElHoWvWAz9N7eQDCO9sccWh7FyIRtujk92uoblcYDZ2B1ve0mh0dZOHawZR18y3T/hK23ttLDN+SYf7vWnZtiqDcB+c5SOCbcCpck+tBD0ipq6CVgCbeOjdenqCldLECVhlk0JwUAvmxALBN4WoBYUq/1BDB55HUu5Fn3TEZ77rq1EX6i5kMxAD9wKVHKhOFSCE2OOwh0Y2/rmnfqBEcCAZmumGwwSONklc5Ss6ztfJD0CLY09tYIz1dVAhqXQDQeYISSvIrG5re6oB6MpXbYuC0lSMiHWIKqqiE4TxfpgnBD2ObH/UJi1f+X146lbCWnGbfMqrpXSd7GFW/q8571JrYmJuEWDZYI11xQrLXPHPvQkZ/JgTSzTzY7bWsQg+Wo28t1v/wqBB1ER1d4S05VZSCnp7ZXdgUeHCsF5ch027iGuu/Oie1Yr8lpbYkHW8oYMtjkYwlrt4xPa9Za6OsFuKweBESKzc8MI0lKYUtrRVI3TYPoMqXL1TYhQ2/ByrS5iWG3wSoqvWSrCnZqdiOCWPJjc4BN/WlEExoVV+greqcemWoA1kRCAYXUXeCIFXiT5L5swqq5lWRHXgvfasYI4wICa5B4W54/XFBq+Zhti0RpdYV9gPaI7Kf3eOQtKJa1XJZ+b80OF16SaYDPj6DJ9ClkwiyDhTszVQoXGuYBbU0QWg0eqBmzvkraUMpIg46yVaJcmwQLcrybzBcGVD3QAbThnlN1srowmDvg9emhdZAE1B/2kYBl+a2CGvx2LPH2W3uEeXXPVqMBiIFHmAEV6oJjS79CLyeWRhnYb5abjr2HjB7lt9iYAMe5F7WAFNCKSdmy0NRjmwAcah4KWVX1mK1amRxYrCXZvlHdMnGvH1ghlZmgJx0LRD30FbGfzHYniYOvUzL11TzGd0RKM3b8ZMA4MPslqKo5VhOrGwxBBfVoxVXmJtqwDi6K0D+B1j9vY5Km0vJiNaqHlIxFBL4HPyfjKs2itwkV9BHh+9cCLDZM/Amo5es2uURZsEd5JEPAwx402zQ7jLIyKUxza5jth7Bq5PDR19zbzXEk67k6qwfbEUqabQjEQbFczcXXmtJpL1u8eEiU/c5BAGjNC2bwnIf7P0U5KU4zfGWWzozMLJ7QpAv4HUd2wDEVbgYjKpqGUvahu5kGCdGGvAgoRe3zJpsvRajrKK8Ir/9p5KHEoGhUqEj3ulfT8vGwtsTCJhr9zC0phCfA5RnNxquRgyfSnmNlDBIKBWTNc6wS4/RNmPuX6K69a7oTRNMb1TpNNlaMzzEHMnkCBmhTPvBQmsKeQghXdJWgH+BP+chi84dBTUyhJqJOa/VvY66XiADOlaKlY6UpO8Ap7EkcJ8zvWxUsS9OUPmPVrUFk/mhdiWEmpz3Eo+wnKmTMY/P0m1MnXqWQjWzQEsn5L7YSFc4pqhOmGuK1QhM+uGXY5GYhui3mSdYgVC4A3bnEbG6X5MqOsWDRqugsheWW68J2ePoTtUSfuAnJFOCM/JT03nRu8VG4iZjxLukglDQ/DGGTh29Y2g/+Q/wiqs+ST2xH8cRsdmrdGLwADDAY+W4mL3FDIYUiujCVQYGC/ASUkAJku2nq2L2rHaIFlYqIyo0408dGGLopu03dG/2lpZpRYwX4FYTl5rWyXuDLuwdj/tMN4bWqLfhojFWkiYDkFPrn9NbkhUnFvi9NMIulJbjGok+1Xex7DD/xe3xJXhfC44DRHHzPEa6VGsnZb5RO5DBEmqxTU9ni8MxiGhqpxjl+rbEDBnsQVUf6fsv5lwM2ReHiEh1Qalsqt2iMq5utzmej3VC3p6yWsY9FQoTXBagDtDGE+effP8Xw2pylCr0ZQEm4Gc+2xkBk75mEA1YSqIJbfgMsqSMRkro8w85sTc7a3ytnr5fkDzMlt3x0tVufWLVaptU3lobrNSfjd0QALjNBU4+P5jzSwzZTdVHwcSLMr7dgRblhMBZzFURsLksCJAHihhpDtKAJWbR86S6HD48pqMo31V6a8ZT/09QCrky8xCfcCqpyXIXUuoZnq/0x3JQxkAQ7wOg90WDCtmxhz86/94sGIiPxBHQ3TQ+QvQc+xfRE/54LORK0znWeZgCtXLHSn7qmIyx2ePRkIsW8jA3XK1LiT4oF02CNCfuboqdW668uXRCGQ0iQty/1+MkU2PD3qXHgytHGqhNB0Njz+NnaYL0/NoATxDC2iOKE2tyiZJhT+OcFKk3k3e0EkMoOoKqonLvfuIrljEDcScCa3c3MGlKSvBy7Z43XE9GCLzgNVJpCBNFk9049olwfn34cdAz9mzHs6gVf8/g8Gr//PpPA6siDw3coe3RSTVrSzyi/tUiegtQiBzItyiQan0oUOnpJC6DSIfCs4H81bkgClmD+EKQmOfHIjQVw/LiSaFN5TccmRFSSOpbY6P3zoDQSWGjyukyF8Xklg35bWFCtq2/rDLO3ISbRxltq16fCN12eR4gZI/8KZqxoHn6kV+Vl1k2VM2M2vr5XbHRIh8V4cR1D+row3L4+TnsHEjIjNNwOc4SAKUP86hNEbgQEcGbYc6YNiw5Wrd1Rs8dZ5LcuWVeGpIsPS3RHHJvN1OeMj4BKut3Ua6tHlOF9Eu4TLnOlClarDLf3nrytpIawp0L/6xLKXMhTnVfQmEgrBYimRfk/zS5JB0dp6lvIHgbLD+k6WPQ9MQSnW31i1Uw+y2Pdh71dq6ankXQx7wzU0J7DnoiEPNXr0lIMmZ1OsUHdYXF9DAgW4Rektt1W4tOW0W5WaBU3XPR3aI56EGc3X5NdYe11XByTQFonM0DySKcigNHJ2AO3rwsGTiB+SPd1Ca7xFr2ktdivINTQx43ShYN9yELx6DZe0K6JJyMFLyaVNZ/GHBSzfJYLtvBUNleyr6sVwydSDuxk+HnZ3GyB7UOWg9mY95apji49cEKlHa8dOVLOy5UEuOCitw2X9Xkr8hc+k8FTMshZ93mZW75QblcK7Bbo/7/Wpvygoky3BTVyMLev7pFlLdle9p80Dcv18WcKIrbAgmXnRRt3ZSC12Xl2JvYUKUeKMqlVIuIUu4fG1m/gSkaQUA0YM8eZdnDY4Sr59XSlHtaugHnaXCmfdHPK0wpkrkLAHcOVkFlB0qHWSspHtvGzXbk5BEuS4QOrsMt98P6w7l8OEyLpjC3Htze5Ct++BEsrgA0HBypf/HM/ymoLilgEDYkywxtzXB6tgqOT9zmFrrL6hIoimRCcPC6APJ4zPcbY24yVsFJrRaqEniAINt1DxZNVpGcyrQgGaY51q4EkBjz+Of+B5VjwLwxQPxyS/60YnA2OJD8hm7w823y082A+s3fPcxjFxvmUNvFxUXsPIrNBopH7hVIl81SWXypQwdhl2aOjBInJFXlFjR5SjmoOIQuBti01AgrGjc/aV7L1pILDkKoKDWuhaqUgLnzi2Rx4KctfO/OcPBXAf2DsrEcBEzWreDFSDxviNsdYjVImrVqNdyGRddLUarVBOMQY8koc4Fii8YVU6plfrwT+1IyZyZGN0LeeTIo5aCfZBkoK2wdjUEl2IVlsbLRf4e1nEUwdbL8yc+gQgPMryAky9kcSORoyv1tQLSMCHVrISoWMxYp+kM2DlJcpYS/hhtzDzLT67P8focdfh/LL/MaVyydc4c8xifJDShbv2fC81smw+FT7+Su1JyvlPzL37in5IIi6ScM19jIgDzNGlf55nk34pJ/0oZD2lXdj0x0eRPZk5U/bkeQ4YZxXYgoUfHNvgYcjIM0TC1yMYXrkPjcVuKdQzCAd3QUNqlNMQwemy4W1VX1A6pfumEZ+KBa5cVnvcdWuDqjX44g5OHVQ3BbBnqEQHXw/7v2qm8GyNMcdgnU4ArvxiDymZNY2rBJke8bvs/fisO4UPLh1mMYDXgRzrSqU3RV9zvToR1LZL7J2ZRQCmOHLTvLqIhYvFre6H7bZbwsThg8wkFjts2OXWAamAiesulnHyOVS84x+mjK/f+IAw4DVmVV1tit4FoYurG49xHgNuvWue0v/IbR2VG/TxNOHIyjkRp1QXwR18dOhMP4B+TgrFAqMrXtvw0tWWs39aTJ6ufuLGjna6K/Ti1j7bI8kBeLpmdWrZ+Br17+SkRZ6uPOgUREwiEjxLT8JW6DNDcCEEVl6LrwjboyqE9O2YNUTYsjzrJwl2HqByTWbrqewcZcPKhl4xXUTLRpvaTIVmfHnh/Kjtkhv/I/FTFpiN5WfSe20pfAC3Bj/7RGZ5vEeQGdX/XX0bFLjAuh2APSHoCj9na6utO67uH3dcMv4Q/97QuzpxW5ogEqGMy30hLvlmBgQ/7Dha39YCt/Rn4vxYxBLDPcnacjrcoMhY7+B4TqNA3HNG2r9ePPIrGW9kETb069UBOPwtKanBgH0iX7QzIbvgwAFfbb7pJTkuLNxwCxTKuhzrn8Ivl4sZgC0ybQM6WrboUcBszKCWbtG/ohAxjS4164TGlq5E6l5tWgD+HsqKRcBslc/VeZA2YrY6heX/5pJOmsI1shFP3PruLWTKBehZDEEwu7C7LyZA3Vduc5f9zeqGrlJSLVq4JQJ1oqtb8nGvtwseRnulVq6n338+MpLz1skNxYKDYsPMn6epxzNrjEaysFFwW+/SaWjSUr+64fDK3VOHpsgtBgMYzFxLZqboUGm8grQ0l3fH6m0ed2DhNbKyOhap0dMWyNJIyQyhFWpVWgbUiJ7mmPq+fWqQSurh4DOIQXqtClv8tHIxIzBCqssb8trfurJzc+6MqWjraYRZuii1nArKivWtOosOsd8em/MJOuOf07gQ7kdKJqgvRCOqbhjYf4hBkLcLUle1KTxRZRTpBeiZYV2vgpV1UcxdO6S2bHeYB+Xn9w6XT+icCnnLtnCf8UVG/7MTSZDjm1iYSJFpLqoOb/jGUjGe4FPxUMjWc7ZlecAVsVtZPLt8IrR2io7V25pEchiwL/qhv9tcZ9okzwl7Pd43NEfgRutyVl85PFxiVKE0ZRAR8p6KmSW+/hCvrncn/hlhNOuf2XMpR/umzQpTcOeQGafjtYl33bbruj2qM+AxzTLQH5uP6M/U0Ix6pxwZl+9xgEWDgmyKH1ULwuru7SguKXhvYGJf026ClxC8h1chp9X/i+Y08RrWRBMy4OWQpcHsJPPun/LkM2q6lEp21oVewNGY4pCpmNhG2k4ueQOxsptdXYamP+1tdjMzJFQX43vj/ooOnx0F+XY9vy8RECqsTPNmQOiTzOIQWz5LQ6O+nJQMN5miZROxfGR6vApclBXjqaKsaPRfIMnqKuU8cdHikr2WdfrINjKyTvG2a53BlxUXfDMGosCesL1J2ev9VX9VDmtbcFv1QmFTeqUK/RDue5KWgSkYTm9EHa1f6I6L2rLdICiMLVPrOW/O3vu7AUVno38BNKvyy5k1sdS+eoT025uD5mrzQtyi1aSyNphF4sOPNr6Xf0zTLZIbPJzS+wuYAyEh2x3TweP6693wv5U2bojyEK+mxEQ/aPwwljg+5zij5V1GJi1FMJZTULqv1ZMemJeKdsn3SXjeVxaOLBHWp+XQceXS9yM/NVzRXIZnsj+Q0nn1XWW+OMkXGlGuFvgPzoy/7y628BIDtQRAT48r9DOMKPkByrDv2dv5kC7gNL7Ff7iqw8VQ3o45PXbjdXT0ejU97cELaR1Cz0sT1S6mCdX6Yj+8hZvxdsPYVbXpFavxsIdXEb8DgEffW0RIjLkKQKrPRp+12wrTaIBYhr3PSk/Zk1j+Zoh+a/QKtQIzPpGnigWGG16efxFYjbXOWUtSPfxF+/vJroIGDLEbQkJpDk2Tye504zjqDDzsyoK/ACDwsxJdsjlpEEPmw7VquXgOAV1qdzvleY61SEy5V/6RsOm+hPqbE4pGsPRRmqh/E4/LZNw4BwTq6kTS+7TK3/+kWgNUUyjOnoArKaQOIW/EeTcmsxw+5kQg2SpffDQ79b3KbfWivDoUjbxKwEyH+kq8HBsxpE2DpXInXbj5GyvCwVySrD+Ret5CZWYFIpsZbO0lxk27j6qlMCcw3G/YNA6YwlXds4YVSBgBfMS3tny2iSVMVttnfeA/NhW1kf7LYWoGFtmxgNI12dlahIZEdKHKG4PUDMSNwaAlrBmkm0ayZlGnvFtGkj8IwKHyBK8KUKQ9Vd+2WsZEJJobw0YcxlYSq4RqIXfmdQeBcqj1apJJ/GgFLdzQgX9mPLFQaEWsYjl9W9FFXaDVnI7n7rceqvdzhfjLpf1CKEZWxBaFLfV0Uj3kT0NFSv+x/qRmpEbC3qmYu6F1wKljs62nLt7G/k2zjVdmDvi/MFh2Eq0YAowhEKpq7sGzq4+Lpd19nOcUqiPCrzWVXpZi5EI5cavza5VIR93BgAUOOOVwADjYI9b6S64Gqh0wl2PuOw1o5VET+r0T4v7L71v1IHzNvwvcfo5Vd4I567ORJKqaNRCMLDVZ9kXKC/WnkNVJN2e8zyf6FuM2TGkAiu11RPLsxfPohcZsuy9bPGssACkB8lYlyjmS6noKcSiLumr+TKYs/v1xyCM1VxjRnw3GY98JmnG070faNYFrdjUaz77Qm2PoJkyqo/9eCy683WZUg3whJ2vTqxYTK1uJpDubMxWTZbrfM2tysP5VES0RFAQAfuA7tKzx82yvCPJHt9j/GOcAxWVuyrokODqYdzNcdowEZfexhqcE23Lfzc4cYFBJmh0ThW1fHUxqhyyEFrRQswCQVDKRYGaf5jI05vkH1Mu95l0vKRhPazVktFr04EX33W9o3egpwaMiiP2xb9aBrCzrbHe/rGeD1Ht4QCw3f0f6vJrK9+WnRioEGcFrFvwKEFsQOuSfzE0DqH7kg9d23W0gGJvysITxf6E3Pcouyk/ofWIWijD0Z7GX16VicLbchkcc1v4NRh5biPpGbuA5v54WsB6EI8iXoK7DLv/IvZvjdyAz0oQ5LO0SN6OWJdSfUySw6Y9BOqHJ/vrRfFDlSJfDJMKKpyKR1kajG6ZYpMELNnxsDrsJyZqlOlYLp5lDQH6vBoD8PR/om1Umj43NcmAnhXo2fX5CPNYoBFkc+a/RWqIrX5fECCSSjbUzqDux08t39QJBPmEIx7ertRy5yjhnyTdKz6TC+rlSj+vWqXxxgmDfKtJY32Vx3S07TPy78WPBd3P6u5IMFb7IvFBunv6IW76PY/6st/BKq0BNluybXMbv6aD3Eg2N3de6hyB0qPEG/DpKTryS8kQebn4DG8P9ddSwNHUTPaWZdlWep2wKhacx45kLKVO1zSZDgyFkkt5rjuSgTSuu9/sJZY1Bw+LNgDnJNKgHBue4VdevIsIcuc/vpVupqvLHrN3yZ4cUILsSV+Otbk6/EiuhR577MwUn1ipGBVTQGm0hDYo5g5ij53UXT5mIldxEKqKqeB11SOIYStuQSuRKIkNU6EtXw0YfX5RGhfi/KUrMNdPeFZxJ26KVv6mdIKnPuPWz5j3C3H+2ZoueZRRTzctYr2BIdlV9BItiyv0yBkbe3dK3IqO7R3KSyD3mCl1xMjbdRTHDiDQF63Jq+H3HDRGWNiNl0OO1hUd3/b1RHpUXfHTgPkQ0xPfaY9G7RtH22beu7VC9zPNfAY0VkSspdxFNLln2Skyg1LE1daLqoOWn3UtDhZ1yMW0nTCTjZdXv1YsVkFBkgsR4WWgGLtAMvUF50zGFm5l5ijM1IFs02VmVKswuQ4DZwNkScZL0Z7viN0KADCJDAtPUq6qU3+ObS7SQeChXRwvRRKSX8zzyz/CODeSLaEx/gdWw/Lk315QNqoZkYuO9UwtZ1yCcAqktYnS0pADjq+Z8C/GlaodmBNprLpjENuEx1pndypqT7a6VLnT+IHYrHciAbaJJJIG1gk7d0UaItuhHNorCrakzGwkLDnUPt86S+nk1ZzR0FY3nQ268p7f5UMzqeEFUMb2u8gC9llrMU+vlBS3QQuLxoBSuW7W64eZXU8TU9w0Lhc1QjMug3HGjmPEag1tO+TJZi1ys0EZLKhYGnoeR5C0QVE4xIw7znkxR93Kaq+zktAShx0yZKdn3HMn2ut53LZsenql481PHLAEZJfhceEYsxP0na6anFsMCm2h/PIdnq9MifRceV3jTzwE6teXNVwVsAMJcgmR38KE9Qt5g9uAMXSHo8UIcxR1iq9Eb7wu2F439EjC2pokFhtc6dTixTZUqoX+i7TSNdnlfshIEMXhHPEWQObWByDOLs0wn0l3TrcWcPM2Y3O4+7zvA62eNTCq1Av186Wl6scxsLPhQYkYamoDrY7yE7vhFV7kxkGaFHwxu/2fwPH3WWrhYU/x5g7W8/aKTIJHINcC5XfCieXrJvuZFCqCCLPJ0HAtws/t4t161K4jKhckEax2rzVGr0X6O6kR9xW7fXWGKKRQ37S5OU/A3i4hFlmTvsYnX+tCBCnZeloZB0mnJYFH21+DhMzJvtftBXFolV3TPRtWOf8pfTu4hwynBxFhKhXY/bZclWrf4e0x51bA68jyR4lEOYTAf7MMDBCRWNvn2HlOTeYkNWmkAPaUdtIsU10HDyi5PVv6+6FuzMwQFmWvrX30kEsaqPiO6ftz2KhqKssmApP67SIQCOYiOSDWcrhOsm7H+7rFGHcyzK3B1NnHQl/Theag2NUeL3o2VArIlACKStkNVdEtd6UWwRhTYORPgH5U3T8xgl6WqBrwBEKWJ9kSpEjcf1/FXDzMg4aPM+/uL9abG7IJasGB+lM7qKRsrvCGdp9ylt1fmJsPWUXBizlKbpDiJtYNwGXG9j+4ehz++F+PYbaYW6TyngSKI1TEUMYJdoasYCDryv3TPSwtmKBLXBb3tzXBuPra8g8+8mugog1RUFrVaWkYYh4AWE3D0rCnX9IeWZio5Rat6Dwxdgd246XO9NaIWKGsVlMQybeEVzcXWZ+Zsn7GLIDyfGTNkjCRteJrklgqHsg8glvzgH7KHvtyKV67Uz4xeXabn++ANQeBQ81QsU0dWEuqPLXeD+YWTdrPRSs5n+dl6rKD7o36qjG8z2rlsVjf5E80BfLBJupWt0yXGFUDg5Zb9Uses1WPRzELs1hXhmIbGghVOpUCZdqnAnnUPHgUE7U3J7ArjZ4p9LS+jMR3OMNcyAibMxrKOOc7NNiHhext3Da+4CIIgMC5gMkeFsSTvTQpLfQb6wStM3QZbDt4lzOHzWO+cYyP6WOepxSl4Mj9bqQPJzw87loOH8rFmdzuzWnC8m/d6zF/StjslhsXUFZxgCq5Gq+S0+LzhhcnVBfhXcD/c8q+fZwIx8VHMPb6dFLO7YZVxbCy70A+TyHpkwAofooEEqpW0w/grTLE4nP2Rpc93hnzNqYYAhVuERzM1XAiP79paWEjmt2iiPzuPZYA53Z0JjRV8ZcGz97aVLSFlP3PQnh99wcsbWN4WgTm6XrWt/4Dy6CrKa7DNTdeg8LgCcwpSPIccjOmGVkyoAUbf1CovFA8Zq9DX9/efZuSVy7gkWVUqMorg0pqc6T97pJfK2i75ZgROkujW/jMFCItyZNabTkLISX0+sbjTQzji5o8cg2Q7finoLR6ooCraEY7AaCqLdMaPJ4efqnrTaIHb15FGmglE9tMhg2kEJzK0wcgwOZPT1DBOMji1nro1rRe0eZ5xXlJb6kdMxALjGq7vTkgjNeDrvo5QOtr5z4DWMVXApOIUcftqnvp4Ij650yZ7G0nVECCwOt2Y3LfeI7WrmF3eNUIFKNs4dJjdGhdAK+6IPDa9Ys4Xt0WLYj/5X0Wzor+ykJOaUkmSWPaNKTORZl+SzJzTLmgXnNVrmZssc8zTHGp2XfzmG0RG6YJSpfBisv54zLzGVZiptElmxQ166+1s5Pjc1JoqffCGZRcaK2+H71eAmpKB7FEbt+6f7Oqft5AOKVi45U/NLkdvxkWSLYUFrS9UsxxcKghsQmb1ToImuL0mVecMjy0NdTbGINUhuaWALLtTRaFBYVJU1wd/leXV4msG98+9Iktm1R9QeD6JPt4R+X2oWMv9HNTD3MwWuUJGysxYrN05LP+aYlPdjp/oATDlO4lPIMTKmATfht7GKTwTThi0/aln9Rlvaa8f+DkdZAGXS5ZWZ7PWl/RTYPbVJ6TGqYCxigL8W7QLfT6xJPyAtrGdt6hvyEDq7CFzH6b1xUK/Hm3803QzxV7dp3DrLjyK5vf/bcU7wqx2N/Z5BF1dvJR5Tizs/Uy4Qs3uhINBPrXGMb8nM1FpZh71Ssq+eBprbL6evplX8CLXiyDume6wl5xSRPPX1tZn8RycyzluY0CG+AggUQ8QLVHdrCMWjL37P/BvY5PG9R+kTlmC2OenNclaDiAb+jSQv34TOs0pjSJ7HxSlX1AopIQSVPA/1xHd9bVFZQ/3ujEjW6RzjdhIxcnzIXRTmXKYfQnbnKP4nB+hh7UZ673qxc25pkwwwCbTF6NwJxnNYNF4F5gcbXRSYuF5oxRsADINpnHwEgHmmf6fgXdFlMojstuB5G9i9wYn16h+xGVeY3gqMuuBJCFYf8EBVF24VhLJVe/t3Aip31dhrgtTn0EIErVfBnIfAfJihaxVSTVtY/hGeHvTNfNqqDeXQ9iBMbCMWhjB0Jb8QYTiJP5K8iFTXWH8xq/gi74rYCBeaclwTDKBh9QrvakaO3Iemy+fcf6XllsaQasNZxtq/GwVobRbueyOVSGGuFvYt+6J93SN4LvVs3me5BhAQAU6xsqXoP9Lnrw2Nif2hgmgVUa0bVg8LuMZlXQVO6kU4ySxKKkSZThKymmZmM1wALMEo2Ga8tGCMhLCNhOIDKQHUFgSLxMS6ZRhItBwMFfy7IZhxkdmscNfG8soGWL6OVArpqXoVVE8xkHULuX3z6B9EpviBKZ+AXhf44dz3l6UDemEzUkewRcAHY9t2G+ugUjnMeDUHVCkmNNsTL9iNiOgdun46s2HByh8WI+/dfAsvb5gY9WJihJ1D+rb7upXEMbyvL4UL6SU9oPPRaCNoja4ssX/sLB0AM9oYaMdBqp4aF8bTVDk6sc/tKGoJaynxgVMPYIXWqyuh/weY/tdUNUdZKp86SgKHvD3ftvgHOZU6aqNFNV7+gJu3bwFnmIvzdI1+SobY2nvwsKxOoZxHc2K+fr1j3UnkmRz8A3gkzXIXfvotkcmKP0TzmJcBDqLCz4/XtZbzQnX22CLoZU0eyc6R5VdQMpv3TlBLfB3+H4RjrgQ26KbHB1bbF7xrNs3QOC7MKqKk1deRS0r3xlFn4C5rO6oi563qO5JzH6BYdJmX92rR6J3MTwK539idPzNcbBE77RPZ1BV42RVSNAr7eI7BDajRddsMoJEPTUsmpcxlMjHRllHj3HDpITw7WV74hDRtXi5x4m8b7I9MkpknOlvSK18KfR1rFG+QWKZ3y2d215YAWebvM91IYhEv7cTyg6rwcxTJPkKKo0NaZSWt/0atd3t6Wst3gLw9xHRe/16nsSVwubQYphf158WQeDmFyduMgGkwXfTOfr7ewnKl+XnHUrJtybuD1Hg0FBDb4eDqHrTlijAyHcu2rQT1hFa0Augrr+ItACz7wHUk3nGLR7UkOhG1P9Q1Dvo4L636bzkniBhI+tY8Zh7qml1Ks3l6eTS0wIpcqXfg5JCmCJVYNVbRAbaNEeyO075joasAdaPIk1BlHlZXUu54ItVnlArFktXRdavftPl3xMCHCUNSaQNi7affKr3grB1LlV3FoAjO7jpZLIeI5EaB2UFrwSPQuGmaIVQNJP+OiX8uj/A64RCznCCYZ5ln3HodTsiY/wxPQWmmnpk/RUCF1xte5sIloXom9LTw+1d5kxqyhDkPc7pud/ZGp7J8BZAH5TMOP00TUEo8x1ycJGvGJatEK4TpnxzHBkE/8ALvJzBmUS3Brhu6clmaCNpZovJnYdrjATC+WObngXjSsulbqt29HYzLO8RHQswjAsn3axwVa+K/fwT4STNuIcTZd08Gzv9ylWDudoWqn0OFoyC36ONUtS3HXbYTur3JagUce77DHgOM9I6B6yDQ2EcRDbdOZ1XKAtfJLR4FA0u6tR4fEOGBriF5RXoidqeTicBLwYsN08gQdXGL6FT+kmDPmGCZR8jyDCVmAWDj4xE+5DAxEL7U9ctXzVC6GscvE/qYVwOj3DLwd5rIeSVeJbeU8FI1uT1SRslagg/U2bJhNDWZxlGNJBPEeykY7UbdFBmG1sSvhqBcxTe8DfBubnTFA/+nG0LFwz80xSBaKYKPaKvNBUVKyCerHeK74b2oRzQ48FP6wQvaLTocF1aRSm568wNIwIwT36IZ5dFytaIUP2y3/O/im6C7HvApCmjN4lPcMcbHqlf4ZWjE5Xk8psTFhWOFRdjejDGe6tUcgdSooMUlv5da1DpqwIJuZyyyAFOYtutVrF24HTg8bBcLwsBdeKERs+Yj3gEV1mx7mbbMzjbkGtTb/A0D7IiVaNI/yz43lxKGuWx6efSQLvZxFsT7BaHiOoQDeUa/BLys586J29J+Rf4tpjXkbqxPHyKmQ84QX6lUWxVtZvPN9rLiMbO4WuIp+4xk73FtAGGEKip2q0ECFLDitxvpKAT+WDvVS7FlWt7dEPpOLYbpAlRlrR9ngzX6SrBuZWDIJ2dliUhkr6Upmw22W6lKobsuWErfFvARW2GN99DLS/RGQw741vcnlARchCisD0GiMCG3M08R8w/eXekq/vuBTQFG+UwnAIH07ElSE0GiG+QguDfOvsFAB2h20+Puub/LDxN/UqqQ1U2DIS/ENH1tXceirDP3Ul1na49EGmP91Ie6vF70RGNYht0OhabreM5P3AG8Z/V+EjI7aSxL+fZdQlv/h8oiffCwH5cCphTXrN6rnbjpw+Y5mkapbuTA1zKrAfXlD1EtqYMW5XCMprTqawWt3/DdQA+DeKWHcp4aDjlmrHWwHwl289vrY6VmDDmVOIzxXaPBnjW/YMe6tNB9GhN0NXxJpO6Y7WrCkPTlz+c8SOUuEwzjA2tmx1uieh2AlO0SyHgE05o5oq8a9xa0Y4U4vVkH8D/P9HdU7RYQXeqgPF5SmgyLP9Rs3CvIx8axaBcSHS3rz7rdfkPD86lfXXNoSZk0uu5fP5vmk88r6Ym2k29OS332MM7vB27cHtvEZ/MEQXzOd56F3ofQvRqHmfTa/XaI0cVshlPQd4KRwro9cYKMhAB6G1Td0dCdE3JyG9pdcgOOWnuLx0m86cb3NCdUiO6MQqAQ7iBm0DseD8OarJ3UcWMmh+IJNFJE+58xg7GNBUzXt6TB2kO9uTSeGB8O4zlTrqkNtpH9ybha2xZ+Jumg4VdvFGyHt2Ru3z/93QKFQamxHf0Msg3d7SPiZtFztlYIzm6+O9am7xACFo6cUer/dhr5ISNMiD1jQZH9XcTBGH41ic3Ej2ORzfBqYHAJIxc2XUadCj8oN2RLSBV6NJ3RkPRqqNJtQTAstLSIHVCR3/pf2g4Ygrp3hHxbDlnalo7w03/3al9KaUsf6HKgq3zcURJ/AWL2KhtQjaxh+OVtA6KD23qK32oCz7LRBGbEfOJvQtKuKNDLLI+L6Dh0xO3R3I01aGl1w3xZXvhPcPgQWUVzNYUo80ON82hnKzkgayRCL6oZ09OgF2iak76tQeYafuvGhc/6M11mGisxN/iAb/bAMzBPBA5Runjdb1WrAp3ymVERgxj9uwZ/hlvd5TiuExg9xHcikYGHX/TXIJUEHbVm6ERba90RJ6p3buVS9dhdkdKsGJdTy6qk8oUsdeGQ1nZisJ5TVOEaYjOcQhM4lae2g0lGx1QV6/6mCF5shSVRx19v3FvIr4/3g4IQ0uO523uog4w7VkJmMIwdaA8dugdmOsWMIKe7FMRadUxxTnPtHQNyYyii2IOP0yW+kBI44yB0+nnWjuczG+eyaMEmAm8CDj89YRA2jtxnlAV6dBZqOLtnD9RoaDAsoI3BsLkubp4ZaJAqSRGYMINULX6EjYvkhIm0KeFfqrRYTNI5vyQmVNf6i/1xtowz5jvRCExokOET68mB3pYqLytaCiEmf8giaokZC68zIg2/f/dfv32jbdYmb4ns+5q/EOwMflQZWZE6ZabsZIat0hLrhBUl+uOBqi9hlzyBF2q0pLiStyolcB071y1XKQoOLTdNmYB0OJnfbJlKBgJX5k+8QYkweAjw9aMAeBOqEjpa5xma1VFAZRxMh6xdItnUlJm9XxVL3xtFBOAwSV9wleRIuBIIqQAf4v13fFXKClhaUCUjJkt7gzYDn8A0JpulveGdZ58TMEzLViSn44vHkOmcmplc6WpHCVQDfZL2B79qH6dTQaVfAyhTrH5DHyk+IwD51db+z1fOctVTiRLvSUd+uMtB/rbD/aeoJKh8pHI5C2ChVdYFHD6oxBzs27iruCJfwG1Wy8QCFgASxtmEhH+FKrdjMI56inRUS+wfBtPc6qvyxw6VFEMX506EI5MX2cKcwa1BlbX2QffgxWj9lDZoG5KlClGWTDcwW4G6enn7zyHy080cjFqKiNTQhQBB9PsuK4cteYGxR5ydoU9C258CPir4yAvjKdxQO4HfTFR4d1E8EhBLXd7lshsIZPo6eKcitFRNAILXcUnZPIuJUhRvpHXIokQCPIZ2dMhA6Eb+v1MISpiLC5hQiyN+hK1aj+neF3HcLUmuESYaA4d4dy4vwoM+opLnlZM0SNonomWghU+auu1v/0lY6Q0Wbi2iqnQLV45e+D/BDL/w0fdU6aLJtbxZiE8/BBpbTv675gLNtq3srBGv09Ji/5qCsPdeUzzTJbCTaAYzqR6A1m9klkxd0Id52FHWHa2uvqzSzh8NvOXJiMUbsDZwoMFptOJqxmXEsFB6yYII2kn+iGw8anSEumr1rf7AJ0fDl7ubvPitMJuUKmk3G3xDoE+r34C5mfuo4Wq2YUlYkNQ42Me9laa44neNkOMJXOisQ923RVkMLHEnJOrlT9TaHSLXQHxYBsDlIJHa2or7RZviygRdQzRXBAUq9caDbVqGMj6GRaZxQWSV3VVKLXTB3dF0/nm0nidWWIIzjV8fZTZZ96TrvsU4Pwl1jw+QSFdXKIu0yTLXUu1kmZFBhGf4XNqE/PFbK0pK0+B214BcHhfHZMQgjoEq9QHBesPTXXfnbnwJhc/pm8FP98KTrBcAKmh2twK0GKkL3TnvPtGVMDbdOKm1vrLcK7AxBJVgKJ2ycXxQArpmwKjm/05E8RYbj0EcoPC5doGJLLFzg9USpk8QNcPLn0emDh6PcHsJHHngyP7hHVzsCbn5SF14Rm5shVzX+CrlenFHIcZV15sIZ9kmV6pBL/JxG2EkZnV4LCtcFajll7Aa7zS3nPCKgxYj/Xk+kBLfE7LdSvXx2illr52LhXDPkxaSgbfX9Yzf1EP5jBNfACTdcyWHCx9EmODSCvE5Ld9PK0oLTtUsA17VrcFc/GcLDJobc7tjOWmyFvtGeYIk/YBuOqlyW0hdkOfwqtCJKDLqTUy8mxLyy+NkORJLLpnqv2M2ZQOxPqJLVvysVi7Mx55yZ4mXCPwLSMIJUmqO0nNbBGV7RjbA68Xr0QRax2OxNivdmtUS4V+0cZWuK6pwq3v5XdrBaJcg3ClJP4wPOvyHEESS9p6Rd1nQ4z6J/PoYOI5T/ed6HP0qJfuxPjKy4gS6L+a+D/InCp2aI+IDeAlMlUISAeM5C50tfwbp6M0KKDbFwC/c6Eq31w08Mk41cgJKB3HDU+X0bC8+4Botd9nq+5UalkEK66Jnwk8Cu+C8PIE2hrMWdsEVnxsErI/llZE6oPnAwsYfa+vLt45QehcHMspLkk3/dxhBi5rJrPjtDxmv258Aw4HtRyRxjHnYidLEDqiZ3rrKdlZD60M7Kn9d1QGKggCrUVFz5ezTO8fSlCmFGymrB9I2Y3KuOzRibQO7QY/6bUd0PAfFTl9szha9iyOVn4Htz3shxNwdE9Jvb01qtKPCBlircfgAjujRbi2zQpOXgPkBgubNgtVgteKC5RkKlS9pTc7hYrHoEhYklPvN8SrGs31liMisplBq3S+PFt77K7l/3TSi2OurfnmheY+hFcM++eNKa2QYSZuo/jtfH1hFujdnCBYQiShhPi9dW2l1jsNT8JmxF6Un1Cyn/MZd0D0PUQY3BBzVjWzjeVUOAgVDBx+6paLeISZa5y8nW1+7wNQTqYCkOXCQ9S4qg1OPcx+kP+FnNFerxp5iZrnqBbjMQmvBDiMYTE/Z+U0VF14w3Yp3T3/SNj9mUFInB3y2igZ5CFx6uIRR+O9AclGlrg87gHOdD0Z92cyhRjOLD2U0858Co6dDbLADnE95c1lHZVdFl9y6TRNy9RxSufrBXN5DfhGgTR/a0tcFUJq3q2CY7nl6e0XfZgOK7O4Ylwnxdox5M1q9INslODve5WuEJJgVu4lOY/HFcZuxD1/ljrX3p+10is5/uPW2ozTxrWmSn1L3C0/tG3rA3haonZf1nh0oz4dY5JlUUGOrJgtCSAwyAt4ztdJGkRhpzaCQGUfqAtR95FLuPhG8HqkyrF4cYo0oB8hWrjIF+fGAVhq4qY3W2lBbtEHcXeTjAhHM9I9YzEOFiuxu2fF/W64e0BBgQsHufP8iXK7fyq1osPvncTKaNd8sV1GN8rf+cee9jUgVct4D0427pa8o8pIRDhzG0ZGV9J98LFaGv1DO5it/hBRXPE/wmTkRlrWUAqqB1tGs5SI1irF9t3L4SsBWz86NcV5SU+24L0HmrbrMsxQS51tkTBUtH+gQWunj1Qi+dovBgzzZjbm5QQh+UdDHuX2EN3fb24atMh7dvWFTzo6EO7KV5VaPIbcm3DXJnlZB5uyppbXtgfAwSA4FtojRN7zIbFTQnm7tdzzw0fHkedWnHTjdGut34ZgBANuPAtGlJQ1gAj1aTec37MV8ZrAF393Kd+w9ejjB0eEHEGbiZq+nrVKFNH9QLIXZNDNxeuQSSxofXTtapcEwWkSdMnyphePfP4TkEI5gFhWkqRhYGhRj12HLjWiuxt5qGIvytt7JV7sRUKSEGVwpiW2i1ac4CAyDcle0nGvVvfwPEs3fDhuI0nxxe0wDx2I5YfsJ5lfsiUHdB7Ip0gWiqYE3eZX5Ihi3O8IA3/tqPwBcOpZ+gMAaZyCQkXwXiQdwVAKAPjID/7viB3povUBm5agTJ6KKpm3xMvHod8vMfZCk5Zb0BKxS8bxkWsLT8xqw8k058j4j+d2GImc7PZx2D+H/sBXkDNPvHuy2ZzNjWPH6mRhSu6tYGLhBcPtjglGjzHD4zikIKeXG5RzgbPC0y6yElx36Mx1VXAXy5AujPDu9tr3Kaj4RxHAtXSe2at91kP57e7gR+Ba4JimAcR/BaRBYh2f+hxDFQ2wWluOVvgj8L18Jal1Nq7+6a+KUJ8SGTZX8X6V9WXecyfZnWRSRWZj9vIlIy8Wj8HvBFK77o7p1/vpBB2hM+BIWtM4FKtJTPjqFYscZP0Bmvo1zazPenh4S1OdjaK6Voo7ns5EW0KBr9DA77dkIVxEG/2CvGtvdmJ/Pic2WF2cjZTVOu54W2H3hb0tvBC4PTyzZ/k/9+U4oEXPtoNtRO3vFQ0LaNIHFOJKMxNo6EyE+ZzMl78W2qt96p/tS+ffx5el6s1V1unmcZ0bsn4kmtKndL2sB4gFiMnyenIbp4dafqGibf44xG8y7qGBGzU5T9Op9PmfqXwNj7C45jFeMSQF866i4SoFyTkECATkjOEhoNADZc8PbQgPqV4LdTKN64KVBBO4FjalC+TQBT2PzIwkl6zOwZo1mzU5uQl56HWx3lSkBejJipyf/k0XpfNaEpHmSLxSVo+lJPf83wgvpiKLvIhr1edDC6W748ErEN8R1JtkHDu7HrR25yfxaH1ywUp3/uSx3YzG1NvSqQ3OkChzqnc1sCJ5sQHZoJ2NgoN075tP6bzt4lgDQOFe+L+6t42rEvcCgpAdepMCEaBaJ9NV920VJP7D36orMcFMk3dvTZ6Si/VD0ZG/xRC2dCWipX1OxXvhURPM9w01w+ZrBqaC8bZCaAeola+s5HrE99SlVtvnL5apLm80/+BTEK6Kaea8qEwT/WgGFFfA7pBYT8sfZqfI25zovSm6lmLJqDThQcpupY83ziouGsw3XNRqc2MvUus/Q5qy7mD4coEC02lgPODAG/4/faCM2A2787rFU5B4iOdIGsOBGJFoWa0MFTK/M+bKFHJaPIxf4QtC7tMNSg/8jUcVa3U7QqSuBUXBHZGGT8VclYV2M8IYLQT2r21LvNreMFTwO2kms7Vkt1dppzZxkXZpf0pFSnzI+yIWh3Vc5/uDjbyiDRDkVIGXHU00pZ/ywCfLvXJJtrSp1pdke349xxD7cO0O4iXxFewhPih4FOV2pRGfvzPrFrb80w01zwzExhg6BcbUPSthPfbLFds1uUEAz8iXXQomXRLMUZq/l4o2an4dX5ylriNTUpQJqX5jTdw/P1ia2GXYUHUc0cmtIMbTl5LRa6cDBck2hgWJ2OPQ5zahTqQY2JZevHn9u0N1kH5u5AB4enJGVIV14O8ZE0e5tkYNAlbN5XgO1c/SPXeFXtB+Ow3Z5XECwQiYBQ+dx/U6ZLU8YyBe2+0/0G2iQh41l7F9jy+NOHqhv3aZ1uv89lv1Vmnw7EkWl99JCUE/IV0EMEWWs/QQ8EZJ443oU7Ben5++G8NGJXNfA216haUzItv9hqCavpVDJaqWSVeDe/QbE0TliZea3StIUkagcYJjlwrPXjO2iEJ8ucpA6ufQ5YT2AqlSDhJFEOcdv4QsRZ+T7wsxpG+y/4t2sVTX0zKOA14CfOQUHfq5tQ84ZIPHWFjfNOxol1uAfeT3HFSpK72J1o0ulLPXNkSCWU9lSEmSh4FvKt2qRoRG0Uxx3l18oQIHhzRT/gj+adRIp7hRk3RakzVUtJL99urtERZyU3ltk8Zjso46cJudBLyKE3ZEtzVMVhEz76c917MEQGaCqNJTzCVg+qH9+9ISnvPSVuUsNeut1TCQGw7HJ+mKNvWCTVDCPUMTYJITi2j+bnKGR6McDj1FmgHAvA27p6tOAPGTrZVP3afbVAO2iXcE/jy6jOQu5mO70P/hoHUPB7UtOxmPqV0nkHQjql6X4eFISK3jQSBhCsrUfnk44u2nzCQIsczilF6jv2oerYa62NIBJtKlxYEmdu5Qz00U+OjOmGHGwbtasT/WjLqeExDlEL9Cuj4Irlwro59aLdWGisfMdMysLzzf80oysSz+Qc6Bgm1/Ghqw7YpX54ZJnTqUgPYw4ChhlIOhLd/iXffV+ZlOkABzH1AsJANtouAZx43zBM/jnHCbE5ezvN19RfyxJz0MW9qyNBIilzf5fWpZLUVXASppWc3f0+PkWS8z2JHLZ9vWd0+vL6mN0zpRLHD/c9Oc2d6P4s1xTBbQyUadtzHU0r+yxyJxil0wJfcQt0ud++kX6Ze21DwviAXriP+TDOWLq1ll5sfhHBvkD49q0KPW232JSn28FXEB3gbkAwihx6UGFDZQbDZJTOExvQKcfoU6EX1Y8oTY3oGNBp8NeFtwevr8JHKJx0k9s7C1Z3j5IgGOrPo+Yvk70/KNTSM6fKC/A7p/1qIKimeUq6WlUMFZ3/4yxJWV4H9i2NTAPF4VZZlQjulBIMBaWEO/6s2qNilYyfymIiEZuTHrQR7P4rOiOPfEOaj+681hKbm/7gnnogjHp5b0WdBHXyfGc5TuUoqquoMatG2QPrUOyGsAkzV7I7pdzfBL7iNV5wonAUGtIwIcD896kcw0b5lVEcw6IXn6Cku3tut+T1kCn8mdAnJUN8fh5hMolo+aDmqFvMu++WtFdM8BQjAYluEJpw7YFC4kMlMub2/VxpYb+9SLxFTnG8fAbRZjGGsiQrDY78mXib8H/lHktPEVhSHvbqtAgNbvwV7IMiHEJeUMsBclTnMhhYMe1xJG9QbB655ulNIwtYLjx53ojUDvd06drjU7Oez3zMFI8l/clWD5muiJsz+C++mWg35o5SllLYnQ9/FGVWeZ/xbNJ9U3A83k5T2evoo7nFls6hOvzKWVBq9q2JVg67HmAsxsvx7aXYEr27wyhddDeQ31u3XWaqpB1MgcdGV+xkIS48zqPo/LkQY7LlWbNtgYyJc9BbAL+f7TjbGtFnIOnR5dDynGdD4c9h4F6VPoUJFQwc6tv2xYjYWrJMIL2azjFYUCK4Kzc0/brAOz0WZz6z4vj1aQCECs1ghdVNLGUudpY9TbUckAwCTpJfukomv23p6jtoe8a7egKiRmjKOwW7GurlyeCTGRe6UEg8khn6U5dMe5SqygkhkCKQLDAKUAydlrunRAE3RChOgNkYAUKcIc9bouX2CZrlycfSlvOMaso+TnUjNbiRH78XumRRqczjODQd5OnAY6TNxpxRgiAVYJZZAmCtTEa/aY39T+6kmkHDIEexx+4bZ0/FGfuffsqgd0ydqj6qFbJTh92RYNsxAe7s9UjjzYZGtmZ+azwy6qfOLJRiDIZY9wjm4nkUDCeMvVfZs+zSUITz1TfR7oBHl3DkeKrZCn79TvOBoFpLlJ+DRGJZF+QubukHN4kddAn8h/MNSpOokURHvxpMX2GZFSn+l0ci7i7yBQYG6eTtvKL0ypLlhAiZNhlX8AVTRqcdtkk9xOA4ovHQl4TR907HA58J3qN8BkfdeUxVHi01DaQq8ciIz//kt4p7WZHOvcdtrefzPs+PN2G2VosXIg/Il4J+eL5rgPg4mMNKcMyoBiJqVcp6Jau3dbxQ+jHbAd9r9FvHiy011YXINuYnmwHZ4bIIPivBgd42CE1m5ySAnvMdGIQ+xZnxN8v4Y9O47q7gHcGNUpEGcfTmFD+AwsFpjALtrDqTR9WzOPlIzJJqX91zSU/bBRVRjcZ11ZPJpzexJGtPEhFj8hgfmJKDhSZx0MMDp5RWcgCqW4NjN75obWea9mV2flf4ybfzt36f+KILfQ02Ua4goVYb0bbzB2C9Ns1WNUvdJEkEmtmqtCkm+EeDyAEU7oYGF4xLXgW1IibwTRlYCef4F8IWk8EMha3MaU3SVmipVXvtC0ocHoTfgRdGcUCqPmq5jMDuzcZDUqLiJWGwFfOJ3nyjS4ovck+fBCcJEyZl6ETuGcLptHJIznjjQAw33rakzUv5eTF06AqN51uxj9UEUeciLHgz5Vbo5PUVSSDqlIzlgbA0QQFJ/uQvr3uX9GhCeEsG1zt3G7DD52gpH7EgV2At4Kqr/O3gvbDLNXW/dNkZcOdR3FpHYFz8utSbax1Lm5GYjaNgqItzHr6AM52CIZLo/iw3y6gY8lvG9f17KcNCDI/H2I6DEs+T1HJcADIyJI2Lvle5K76lYE73y1/18jJTsbP490oP/CzBcfD8Nl2Bef/CC2x6C/WYNWf2pvZhPJMMOdH0NIGpz1aKvwaxOXrUp9O2/nX1uQiqWc96s2VGwDLb5gOOcXpTtL6Ikj9JfRLzKywhYq2jnLmh1Psyj7eT8AAXnWsINA3hewmeEQfF6Y7hWsJGDZ5xrNr44eECpUFigy8Zz/4hI4N1XirKhD63ApP0/HzWMrfzANBxN8NCTpSQA9wCO1SJEpOi3vjnFoX1xHAeSPIjC+OGzShW2gwU/ig0FjC6x4xU4AA64xMDB834iBwoEnXj3yGTYU1ZliszwdURtNs4lQXD+U9Z+hYYiOb2Jm8tu/jRa4x9nND/hXb2Ng8eQjIV7EExHLat7b+PcZKrj9hgw2iTPX3KbBC6/VlkSi4ch55ciUt9w4B+v5DF1XE4pqHyLJvtyKSEAnoPPii4VrLmhI09n0b9TPaSjPei2UmTbxZUVjlm8iLaRIxW+8fdanR0LzDfpBHUvYdP0MGEVmbfzFA1fsimb73RVik8ZRW/h/mSTUXBHK8FW+FgaM+0mEMDlig8tStNVFotnozuX4BWty8o9p7oxITvPGIrjI+DRJYvw/QfA8d6Z61Q6BQ/Bi5bFmj1kX2XM1SEbaUeu2+AmXlxnvEj+UlV+CErNnQ78W2TQ8ibQoplyKJk5smYE15Ns2ijf/7qnXMEMsuHP4ldEp/Dx3ZwPPOhEfnK6VvdozgLOGXYvVtZSdlRffoJymoDFUryySYgODtClLiVuUL8+AumUB1psB0E5Z72eRTcdw2uHhjVcZZ1cAi18sY3tOal9H/S3IrSaUY+XywphfKxHVkVWbzP67LBLH5KMyEH1xgqXlE5DzuHSWRf3ndd3n+O1kdFNEZZgzQiPyapwGw73IPoBIegfKj/pd2vAD1wfmGvZNphA0a/tGdX76Kxfa5EpSPPNIJBPRtUcL9HWKzVzkpepT/6ha7oB+STSoOPN2dXiffyW4X4XdW/iap8/zI3uBT5udF3camTqn5JkIZXD46FZcq9yQ2TIl2Eg8aDroq7eTM8e0jRRhTHZsYw0NWQFX1Cs06dpfqHHlUXSBZ5F+y+kAsEvVVCqdvmwcDo3mjGMeWORYocHRbEqiKfPCkqZlMiLO7wufpoZN00Y3KBZeqTBduVUOHpqLtaZtiazw+tKibxuM3h7kKelJMOuBlJd+HGcpquIaWYryqxf0+fcf/64l38nF7cipFZ8qlalO2j8Bls7g2tn88AnPpi/UdxO/MlErd+hYXBYvQGJ1rbZvrtyhvsQXS2X9Ja1MTC69nD5GWQyF5GrCXYtzvNK3x1o64SUQpc/yrTRJgqXdrVjwAusXEyVoNDMnHTJWMJJubThGEb/mr86+zqnshKoR1QJ0dHqurkUsRhTm9OdX4kHbAGQYfkztM9LKvv/2qA2F2XuvU4R133QnH5Yx+WCZHAiEh2c1LXUTj+F0537qNA1sFaDnre/e3TBnK0PmseAO8b3IIuCv6a6w8rXZzv/m+RWZFC4TcM8LrDXTXgmH0KmmOMd7K8Arfwq9Ap/+3p1zzW0QMZijeRp6+wQ9nfI3JM7SN26TgwYL1KPJ4F9A8efcDk/ONhjpejRvDRos0mwgPuMpQOY6FpW25VGmqhx0WBRSCPThvs9RakfdaoYpAoccir3Spcc9rucm17KV9L3OJTUwUMII9qPq/1u90VD6wWPryY/WuMUOHJnECFwWuFyWrGiGhCr6atn4yBNvW+m3FoGjJQri0Grijn/QERqYaZK8pWdb0gsAyk8Y+k9BkSOJ2Sre5a/MfUwYZB47o4PAO32LTvhC9rDz4I+V6R50n2x+N3YFaxu/fjbJyFsoIZ7vdW0qPW/1IRdmXsh0H67/AYQgkxdPLxFfrfr2pJ5Ex938TvubdyPYaH47Xpk3FqAMLLZzxvfBK9yFjx1V8Zo+Ll8TFl1X+vesvHmqoGzAlBdVIbCPHYkS1eBjseJHPiAc0Wyqmr7iQ6qwr5zNse07707l/LPbGYIZFpnLyeutgrwi1QO+jMtr1664CMQD8ykrO9bFhvlBbXT0WHYGzB49YnuUQGC6MxhjEYqH5eZLb567S4QtLgMUsaMogpVbe/sbS/s3Vt9bulipNtV9MnlWQubmFWx8syQdqNY831+4sH3yCZ89E6voVd7gmJalp60I6w7xuo7vocsrUKfp5wE1Uv1yoL7qGyQYbP6gsXI1UkrKp8SmB6Nei62Rhc0mPtuchIFgFAAxhjnu5NMCI+/r2oZgdwR40uKnttD1flf9PQWAmL0CTzCrzNO1S6+V9OLycPscJqCW4kwqQCnMYIRYqNMGWUb4ZV8TEG2yx6ZOGYrc9CU6ViJ2GVwlLkVj7FG2+CRlnAbFcQSBCNZ7t1ESJkf1hlCYv1Y5AN+VQnKBZgPMWL5nTEFkSnb4nF68/7WD/SFdXyGgaEGtYNqtlG+QnhV37fxQOkUoGuhrfhaxE2wvg7uuFzx3QME4SPAPK+cW5eZtgaye/yyh+6mCH2aosiDw9p3YLaAF+Eztjbe68+kMW44QYxxLd3a1+/Y9BqtsVFgBRTC4w3D9TkZAHDakuYLw1qWbPkVhQizFw4JBHIWt4SPfhyGqfUt5rp5HhmQSGuS2e2a2iYzAJURSoZbf2naWLCRe5NNePg2t7ECMnNSpmebfGsfWhRA9AYNUt7g47q7eXyT742JdakBDAcPjr73OG+Pw6g9SoxYLO1O/B6ytSBqbGNIU/a126SrNvcvd50H5OQOGCWtpN8hHnVBpKSOcZeoz1RTxJ9nRdlIFYTdu2nNDV0am3DwXczzixxSFYI/XVGL/2fH3GW9geTbeFnVlVeqUvjgtbIhG1FAsMeSTubqESGOLsOt2qDfXU4qdqJoDhEiZnhh4h+YQuL2/NV5EXIsY52Y6Hky9b7WKtTGnccvPfwanCBrgk1dgw8NKV0ImgRACRoQGJ/s0qzn0nrQwphaZuTOxKjqklP9D4ja9zZg05GrhG2LlyMQAlPyLrPu5PI5Rv11XZaNLwAYwCSPLmNo7XebLwKz1EhGyk1Y/48Zp4icvvqfSlHm5hUO+leYSt9/LAVZ2J+8xLf3kR0o5aoGqjnAOWhnECjICHhrw2E0SUDfMCKvuB9YReoCy/4xOBSxhbqIbNshsx6cSdPHGBKtfiWLw9GvWY+jwCRkwfo/vshOyPYItbQ34/Secj8bf4z6uhPi7KaG0UtW/AR3lxOa2hYbgq1psrnKEcmkckelozEkkV7cqONuT5aX9m1fhUMTm2Bzr9BV4CkfhE23FAALZ2yoVtyXOoOX9nGNXK3UZkccD3PLxRUlI+GamJHLQcWfWlUquSFMJYjZKcyCJ5MMo1DuQ8ABEVcOx+eWm2Ur8W9FwP4QDwtwIjwiVrp7u02VqGNcg0s9Z+iuHzMb25gGy9f13mFoEu+IFBud3yyxNHM5e2ytCZwl0Khlybi5/oFp+E8bTNayhdNk/yuIqRcvPEQOmdj78sRJa5aF9tALyXdjpllnQB8WOn4SjFN7Ryc0KkB+1vNHEpAr0Gi9vatnEAL+zrbDubhdVwWguQRTzd6LaQsntn1Gk/omQ2paZ7V4aIqIYXA8tR4u4DfB4ExZ12uOoFhACNmfGme3+KJYcbVUc7+fJ8remBXoT2j7SjSsnljBUB7hpcmHt80ArKQtW2UYKJimmuExpRpet9+SYEGQznLlzJ0Ic+tdKOaSZ1CX5kahSj/GPQSNsmESQ2abPBFc8FHf/VsM8vVrTF00IZhGioRQJTtf/zaiuvH0WCvj0ZkQjm1HVm9cnOZsNRlMg7DRgEIr0eItyKv1iWJXSSaIx57L5E9stY4uF8SadpZu09gNFDGDeLXx3d6O0CBPic5N5lCHQt7oIWUkVH1wIgNsKKbCMng4TfiswYKzJAZNsiQXE5IOv+ZNkMmUJX1HY9U9dkhl6RCvawpKtCHea5WI1luX1Wra1XcoIctvWr7sn2x00Eo5Sf5hU7WD9B8mvDvyKaoQ+zf2RZmQbCpeBllodYVmKBXNCL6ardEq7OcMA7vRmHAFWJ7H1wR7YznU/e5DmFg115pMVxH6RO2CoJpxFS5TrUMRxkSmHlE5MHt5MlNe0cTMrrDbbfCMGWKKM55aUAYzreXh10Fim+Y1DVZSEoXD8F+qdY0YikYBfVe2uAOpLMM1/GCfIDTUI///waY8qyk6BPQuZUFD6+uX7TCdpl4byafCEnmYaE1Mn0YsxXM4Jo5xe2ofDjkahzqNyMS5CANr1gjlZJIBkDKsByjSer3hW8bTGWHvqYd3rrn40WNDVnHzduXXlmP1jrzyfV4XJQDEGryjFalWO4NUyEnM/K9qwTPjF6e+W4vlnQVaBBA0eVxCiWVf8qvtv1BClLaT/Tc6HoO3S00o2LxS7oAo7X3NFe7X+WlvtzXcu25K5ONmHf2sOQj+Di3nOKUq4+daAFbOwjHx++Q5s0Etv3V82EXkhBGvwbqUSokU3LWvGuZ6xCeSoBAH1gBWBlInWneS+g8W+l6rae5jPUfN7pdw5hnMt2ZzIbcxiKxUuyhuX1yz/vw27Nw5xfzoLDknuWS6rPaL2m5SJtbAlIm1pgoQPxWE7XOhxG/0cOQ8Ln0/uaaHx7TCbS3uNgH5Nu/pbQLRP3HtiFAzII+/x4jnotuILbGjh8CRmuxYki3lCaArqDRLBPWCIN2bgTozUnfqkyX/9xk/sQQMGyB/TZ50ywszUPYKf4Cynh/rpOBiqCmxzM3rqiCi4wsHD7EjWVxGysbVj6BMyZ0WkxAHSEuWpesmeqS29Hf0jOILKPEWrlu1LTjNXyJZz3sINVhj71PvBAaMK5hyBw4XlJGqSmd/EJM5ImluV4ivbKhQVGc71RSlYSOcjV2UgSYqr5O8+wq55WJjls66fHvvodHp1u9pjfVAADAyr+Y2phNUMtEQKgBhPSYKAVx+3TN3TSWD0dSH3E2Lu0nuIfHqBPxEs7tbUsJ489hAnMu0hl8mvgiUO6WlWE6dMw4aMQ1A0bG0Z9feaZ16IghPiunzkAnHBEsCX7/hct2IJbh6PJo/gw4rvWNeOy3aCmwQjqMacjP7lxcmWv1BTLDd5l1ny7C8uuL/CLHSXTsmbCjbBtzmRbQv0+duRsIK18DxYxDNN0ODhR1JA1KjGm13R0HsUgNS6ZkNYhGOvzGsu0BrvHm0LJMXwVjzYNfComfvcecVKvhD772NEP3POXRhsyOh8vdZxgDBmZfsYrHRclgszRgAxVnAZ2q0B43gofphV/2j6VS/zH8I2pGWvR2aa9PHBjVAOhPqoV1VNiLjiC56VXg0EGLEL4UvE/agMFY89/zD6g/rMySPojYCoGqhQEoNOLvsgpXjocHarfsO6ycB7h1K6SjZQ2OodhG9LHyE7JlIrJzV83IIiZntjvA+3wMoU0GFmX7XFhU9+JlEQ+ElVexq92/SXr+k7o4Yg7o0Rd7BxLrctmJjI2Xzn3jB+Ue+ViDwEu1stD0mxVSVhi2Eqplwb/KJCRd7nAUlqCSCkgLW5u2FPiu47QRy4C3I2cdRO1dThxXs9c/hwX5XP3fj90H//crk4lWu3fhyndPsjvYjH/dsn667HoaZM3IaIVlIOyQc9f2rrXGsnWYBp1YbFSjZtpCBCAO9WIK4hjwHqISEHv/KZ/urcokxW74aAtTwiyv26pt3T8llL6m3i09DqPvQmRYaT5k4k5Y2Af97BGHN4/rDWop/6enDqoQmPwDjsXVYh0E4ufJ8wbRTOL5E57HYT7OvR0tyvUvmOT11IePR/XErQySKrr9F7xa+l9EAV7j4HhjYcjUWS7HlKXUOG66F08Zb4FOUtc3RMrTMRZ4ALDbE/W79swoGkKgqvnCnBzzhBIqlJQwLv1FCE4KEEqLfJSKtxXA862+hvyKbzGftobob5cag6+6+i2pxxxx0f55UtxI55cKysmhVOG1w437LyX6ViGgWHtqjutGOjj7MWcVpf7SjHmn9BxkecMdgtLSHY4D3rSgHZfjlimZi9eTN6WunjeK8fCSn1w6Y83j5a7r81hMInRAcIyAU/o0XrmH/G8dh8vcXLk/7O6aw9Xie5hj7YDlM+f68nSxXa+AzGcTst4m/0b1hTQmLeYyBYLsk9G46Zt82RX27Hs0ycii1qKXheVU9mLI0Xxm23IdPpf43NJUWR7A9U9Rlt2Ckl+uM26FuHxfKLaLgTl+QTuJVh1DMzpbWUcnVURpe9eUyaXGO9NRvmZDrtySq+O5sn6NEggHTkpEphHznIYG2YBEUVcwW5nfKlnkljQnhRuQzchPLNi6Byt7da8m1NG2N2YYKaKXptjJ8QkUnvDbiYcOrrGJwwucDeDfexoHXJhELgz3hN33Q8/73gN8pSDs3xuiyBiLqGT/oXkntBK1RqSdJn1T1q9oXVHj+JYh0YbF+F6J6KMDXlLQ4W35f2gEJtXIwRP+Yl4Fcab6Moov6/i37Yts0PovvzF+jNRwHcpzkO7OU73fQIXs4nj/Wv+VRoBf8eQtp1hNOi2IlDJHJUf52ckqGOnSuxaCK8UE/c1qbyO9V4zDdTlblfSiT2/VQpnRyB9PTmnLGoprChgAp9FUEpVriVV4vKK8BawpEB8usKm0jacgb5XNYFQGUczJr0mr/K/C9emSqbANz+Fa5IBV1u2CAOZqZGGVHuN692Y1F3QeUqi5COibKlu8uRhLR7q4mwGE1IRSZ42yRqf0zgZPaDvivTX1cAY0YaQngVhJn+yPZJ8VWcWpOsXi9QY8Ml94eaNJtvTFNknfhAqCNG3GTnDhS3x33pVBhyHVD74hKsQ9qmiQqk5TFTv4TE5rgSG3QcTXzvm3kFflSdXPQJxhCn7cx36TVkelnKnuD8pD54oFvGTHQqNZhz5ZJTZlHCsoOLJ97AeFY5v84LbqwONsbz+cSI8eHjIAq+EscQ7se5EQkDu+U9s3A2KdjIs4yBL9DvX0bOgtHcjql6XL1IPrQWYSmrcChQRSvT3lrQw+sg1qMxcxDWqBLLBnQFJoffnkar5GD67oSGab+8/MKAeGoQ+zyTzLP0RqwaKQIouiNy8luBcIQO3sCwwjbBS2hQyJ1EPcI6Wi+X0KydmkPpu8YLY6Eq5lIVkMzk+coJoyEjUG484z34wccK5rUvAe/1eAYVnrA2kge7Z4SnK2U6r0IXk/k3PhPTbg+tNT5vzjK4tmV+UpAoNUsRdlChqCNIirBL05s17HOq9Dzt1/yusVSGypDiyE2O7KbOlnYRW/l1QHiaRTiwQbFEbIaM6+EerKOy59QqQ3zlKS4V3hfl8zqsPSnwwzw9pf1n1MSb9+LWtByPC+zpgtUgdkwD1agIkLY2saWoRlnX/25qANeGlTNTp+rkVK3BMmsSRb/KJEuGn+ruyFATkKI0oFqM0P4aPgHWHELiJRI2vZdNGWGDbY7tI3IELl2okEwWhPYdX4T4IbYVqJe2kEQbVIad4ENN8IVzODKfzZWVtyI6nPm7Rr5zstZA2dtDz8J80tMNkBvsezCfNTup0uhYuFp1gZ+Q+5fCjHAESACAgZYfs2UStPY/HGJ/NvPGNxWqwsCIHJwr2JkSvengFingu3eYgOYgIfbamPyYP35sJW4gu7QYXILrGQFUQspovKgtnLZQjwmL6BmMy3R66yZxdUWr92rzUtu4yMdO9NrK7SoboBty5BB/VWrXO7FDh20Q+WHT4hrHGgVgnAkfZ4OkO3Om4NeG4/Vu8CJgYrnTz3mB7824ltNQ3cIkYezR3/ZvzGtSHZsyjlXcAt8MuMFm718ZKjT9cI8at8LqjyxgkGUfNdp6/AbW5ghLV1Qf6zd0ifWAWfYOSg7bt1RqDVIHLyagbaZKyoeeMa8GbDEaxI2Nrof64A+UQ/yP5Vbu1ZPN2clhHPV1MUub1rxx8zOcg8bKI73U5hIq5SUCuIxMusHCDLmi/sZGXuplxKehXbtGtWDJsghb6HpLr/u0akJqU1koVLlZTlhWyyywSKZgXpRiES8s94E8/Da1qGRHEKINHUqGGhIMfiOY2EDpHNSlGtRRJlF4iH30NNQQJ4JUQHdPjJisRQuDrc39v/FxQ4GbkWKFml46Usg6xY0Q6BlFNE3jmz+39NJ1bmtCNVDIxcJi+5rzCFx7RYRVRD96DEDKg0aNt/KZ2jfeRKpWMG3Qn7ukFjs+dAY5e50WDPG2LcpoBCmc+R82kl/iH8/CSP0TuvLK8dI4Xj/ifBfNWn/KcX3moozjkCb1sh2f8DhCBpWAhK0nFeRgkFRCZ8ELXpeDyTNok7NaacgSprT+sH9JzQ43+StzICz84OQEzwanICE8n5gimmnjeeG0hGA7dW/TQl6lL6JPAce7YPhdv/2Jayfmb94PswqwCl4AKEjWE+YuTyvOPwQpf2R4Bjxj0z8wp/2x6YblIooZ1pVk8uZX8QZyptOHPuG2T2nskemnYxyjJYiX+0IH1GKQzSJpQ1YlOqILqUpIzYjSbfW0DXsa5SSNAI0ZdZSzHR/jrStdA4KE6o3OEYhDIq+VomC5Q2OYdNyh7wONLsS6Eh+Y/3npKmu1Vd4BvWST/VTaJdue+uD60+3opElglVtN44It5jb1rqE8CRJNVgiBO15sDxcSkM4+KYhT+0bqt5pbudYi+sWyWaWZRdKWyyApgHrzhDf3Lr49sfm6nzmPDUOIf0PjIYGVbbBd7K0pCZl61fwBfIy0Ua0iKq6XZooK91ubNspyA0KYkNOvln0dM87FAv6rsw3dZxYeYhKFKBVZl3mZW+2KEHYIha5sBBJi4FswMQw9eOuXa1fM7UlX3wpciRq4PUgaFvzRe+MWtJKtkP3fosMhJrenkq+Ky5s4eIy4YCSAAsivCNLNU2FlZCUtybhH5zmJc68R2bWw+b+ZdPuilKYH0jVZUndMyOcwox4Gu10NY5W3KEwNqKg/4eLdmA9oH/QKWw50jH2m/CRxKp6YLHZ49xNK2lT1oN+VmiLf0yVbCfLRkLwAdZtmmgtMq823zDcHIBzmh3UR/XKtw+7u2jz6C4yiZ9+RpDoqHEx/YsRNJlB5IBkIn5dj/XwY9anyujHdKaqQuyfNuM8k6wLZkVflzHpU6eg1NnslbtylHUf2H9N9LDMlCgr2pAO2MHZK8b3h1dNrDc3e5pPxeDPkzzBdViOQ6X9WkDCeooHpAcmYO0JFxWhdKsVzMYET/BgSXBpt2PrNK+5a1ervpbqLvG6nDaSjAafQpdBIa4ysgPg006kIGdd7uFrWKaOgLd7UfHZAFlztSdombGgBrNjdKC1Ej0UH36SSAFgMFNknP3DKv/rgO1kbDdMVvSDf8XwN8TJJJb7UNx1oyIYKqsQ1u/6qMeG6rOjqNUqhumJEX+12HxmvQbIZZd80zWyil4aAiUU1GotwUgH0xN3Jtfi4GtRBRQpuAIr+/sBqC+ErFJtRCUE5yJlD1xsBHK0wN4m554EF4aAFPusek2qJmKprobFNZXK7XBeeIOJheRIytYLML3DnEMFPG4XQIHRIB9sBFTDSXl1SnEl5bU1sx2HJhccl0f8j9/amBer0TEyU1kzV/0c5dECVQ/Ra/nCIEfOqkrkJp0Yn9fHvYXIY1TsobpXjomJQWATD/lJoaMXG2TKESm5X2YP/LqSbHc4FendRnb8oXbpwqdDkCnEETQH0UgBI0zuNWz73cEkmsm2TiJY2CXfdd/RUxnT6kHrI00CYWyVuMPOBzRVCmrMzLCmpz0fOjWVxq4cEwPXp/sMako4A1GlpDXTdfoT6FlDfxeoPg4nSdQ0pzqF8XXBDZCmLi1oDKEYVvjxe7veftZKbOxIxhPqZfqIXe2PP9N/WSNrFZ5f/5bvsWPMx3zpk7/64rFOJ8NjXEZXh9YPTy8AhRweiFF5bbS2Y2RCjUWgQHwEWXQgxardfVAi6kdQt3MuTf65xzNlNuyz5X1cEDvGh4YuglnWY26PAkTXX7QwRMg+wEnD3UQfel7Sco/ubHtRi6+U9kpm3xeWBCQdyCZLYXE2vIR6Md9NJ9A2sEzF4BozwHD98lF6cw2m12YHeESXWh2jNF0WoqVGrWsTyOkT7VMh5emC97sz0khHEc8+EufFD7g8aHzBe1jRRcnPKqco7UMAIfB6VP+RPe0K5JCko9TMefGo9UDKhpO8pAfRDxza0eq7hdvSw0Pnn+YiuAwm/N+SYN0JjvOKyftgjjMIflpkObo9uFU1l1W10YpaJDE6lVetpD1dNMJgnbiGInlJtOtNFzpRXUwcUj3vzVYGNi5a3eIzT6l9NX9We+T1itELHUApIpNonXz+Y1jWHmW8WriQETj4WtP7B0pkZEHIwfnpiHBQQEoXaHK91EGCmRpegBcNrcMq+OoRSMoKp2vh4JALKjt6sjvVDlGnGUYC7Abv+7435n9iTMsP5yrXf/yEZzBahtvu5bze3m67iVsqJ9KoHg+rvdDc3ZLbOwbUiFJQ1d6rOm7/djLXncpoZzzJCA2Z1RwogaoBD/ZS4F7ZDgfxpB7wUnBr4FGZ27PaadxG+PpjymAURx+TeVS4f6vBO96M4Hzzum9nuFt5RZ9U/rlILqgclsaRo/B855pUou9jaVZ8MkRT2uFb79FRq1AdLI6ddoP/Ey1mniW5e0DfnDmP+v3EQaxrSLKY+pzr3aBjOjHg3K1CqFcvY8ApP47EnPMY740Nd05UvIP3uesALFF0+DzeumG3/F9aJjKG1qyvW4RBP/EYlsGu0aK9fOP1kTJzhHuvS4I1PwrjSMgtZErbsTQleBvkP+/dV8w049tlr55D/LQJ5jrMr6VJiheI0rnabPLC6NB61+zw4MSXHHO946dxICteCm5dyik005Ac1amhOGT6/DXiyJuzGeL7owlSVaY3D7LXDOvEMm7K/6V9g6DcRqqV5Z7vhwaQ2B+oO7Ms6P0AkwoIlh5n+hm1a0aSpJPHhHHFBzDaBv/32YfHxcoQ1gVNvfUq2QXdU+OZYxWvIWU7sMHz/EyOKMVU2FR88p5obua5HpshD/NWK6h13Tuq6JRlwWnD4kTzZ1dFD4YG0v4L2Vwl+eEdY2cxWL20iYgU67GOmgCHB6QPB5VavFRADrFa2jghrpwYiCchJy6YOQMUKOqsRugQ0sB1t0IogF/A2/ORiMYz8VdGu1tZF3fZg48DUNq0y/0eoTVC8CwNqBi4VkiSYasIHZlNYT8+/xQ2rnWaY+etCEXJQu3xurAWZ3OBTK5pbcFVnFYbJobaIJ7yHN6LigCakFawbJhPMN3XMoGoNNrtyBLBp7SqVwJFWQY0hcwPll7xbKRRZvxO+Jt24PZn1p4URFAUA5RyvVEz2SUNBbB+AcdXs877PtQoUpR2p+A675giOQfkXYwACwb/QGUGGEj2kl/hHiCVeUllsn//bzKjAy5IlbY3EGQLKWw2fpARDNlSVQEumuS2CAQAYYBLrmaaoPV9SHGP8IWWsBOEi281nX7tF5TUksWEuqR/+qxvWmsmE/aiiRbyoaV6VcFBVJrj3kbOFZzFHhVzqXE+YnrwX6AlePWhZFedrUbPlTOaI86ZFsag7u6eMdrgcoU2PW6HgmyZOiI76X0fCu47JxN7/z+iXTTla+xuuU94qRfafaOHJKFYNGCC2cGIK3gpYHwV2Axb9OCRwCIrqbVqtDEKF4nlpFAt+ijxLyTvJzj3k1bZ8ISyhKBAGwDTak8z7M7MIVUQlcpwHJl8xAzQYDm7ZNbThy1UcpPLMejzp3JcuNMJRq8+IJh8K23rjeHPzpl6JUYiuBWp99sE3eHg/8viBQfLYYPzikLPbh1IljwsOAY9mFomu+OMp4lzzMdtDcxWqXKTqt+XDMGp9Y9Hx+n3WmkCaE8XHrl6AmL26wzKa429+jgxjFD7ebSGiu3j/ZtLhg5FsBIbEJm4poQ9wFLlThHoRtSz4lle/8evZrvgVtjUGNLPeP6li4XSuIFiBnNjemiqBlkUABpfl9yyqPd5SCSVYIGEv/aA1VK8fWpSgRJbksFspbbgX0WOmFH37V8x4FcA5kH0rLMblR2ETYi/48jilw+7hhynw9B058Zxg7R6E3/cvx6wOsyMJ4BQq5I6YJQrqVFUZXejd/ZIr+JcIL2kV+ayV0HPjDID49irlzj8Z6z7M9OfTZe4+e088RfwxJUdV7cscnI1WLUn7zRzE0bQS3VIdm6o2ozNPqcp8Tjp9jvonMHWWPt25TPbMQ8Wljn/2QaVCWATVwaopLVNgN8InWIB82VPdvodN06a3GMcsclzFiI2W/Zi2kDCgLSTzUMByGUhRvmg8O9IkMJyumLpCqvAqhlhWz314GZGZ3aFQWaaZt+6McFu/0BTBKzJh/zc0znjMQgdpcFGBVC7TuzSW/zrQwnEy7GiH1F+/4AQIu2JZjbnnZHCK7jz24wn8MsGcaYyAKVT6BrDUs5zBEYzXxmPc26VxB/yw5uxRVV7j0Cnvp20Icyds+jPi/4GbQ0VUN2HO76dUIL4rMrgwcTy6vUTBE8XJFoDf+wpw9xxCMHRopJZHmJTLEQhm1Aih4LZDEIMFgTfAgTApYgHMnlQ1agOvPBd6PditPhiMdW2jqEqDAvRp+0h2i7YMPvUBden0xjA1nVxX6tEGgFaoxVwywsg/yGZu96Karw2d0vMyhxycyaq3WRe+mQ0ZYxiBuvbJChwlRKoDRyaFe1qnI3tuiaqUyD8nu1RK3QGRODqjTSoxTnaSVlv/DwPAliX+2qd0V0ZC0MNppNRkW0mGCLcQrpKoZHy0pyz9gq+ISjuxyiQDM+X7bjmjTPyJ68R06bh4tI3G8X+Kr6/FYxYf36MYOx7IAtO7FXqe4pr8ixI6e9nh87W5IcBsDiW0Z9M3aOMCuGhs9enAo7iSWzpbW/chzfOcDlKOi2SqEFMMoAutgfSaiQK4rx96y7zckFQBbMOsJ5wgmYtzp2+/N70w7meg2DwvXmnmGK6Sl7PWk2BvfUj4nduGwgJ7CK+mOB9MuWSfG5OXm/uqgnTJDe+5gPr0ItThj+/wox7Q+J6hzbYY2OEFcg1seDQSyS05YZURftA+YbIGJ0P7E15saCuoja1TwD/IWNZ4gBy/Z22+tsp4+niZuclW0mozy/Tyn9Yn8V/jwIb6L6Rlr63QjuQr2SGUPtxfCHbPOp/M9GWiD9s3FjTPnSYMlnANTSR65+/IFrGgthOSxBDU1eTRSD9TUaK+A1mYaS9R3yVdwoj7A+u7oA7F8L1UPKKS5qA8dKXSw3U9AQVMuDuLmn86J59hvPO0GvY2bAuI4kGV9s4+H0+XL0m7B1HH/EWYhuo+Zi41wZMLtFt1k0sBB11jHyBPIPXfW4Bs9Jad1GmSR9HZ3fGkTDaR9A6xdjsiVpe1U/rwrvC4LZoNyLQ48AoWzt5mAgM4ne/SwDq8C68SN3ldLMilwSuOU2sBzOORb0+6wlfhuMWS7CvfBkaHSQr8XenzAwaFEaaprIrBQbqDuOADhB+JgPWzwTrPLeXJOh6pQ32xreO2d2dVr+vofuLRoH01UVGQGGTwN5UyMglu1+5Tpx+037GzeUegnGWaJ55MW2LLZt9k8xr37JQjKXfAyhU5goWT9hzYPHNKAnMgtUj2uXBcuaulmIZgzqy63849zcw2EFkLLdFU9RB1IxlN4ojGlzJQOOJYhHLb95Y7I7V238XDFcoQ328j8uaMjdp8jOh/jX0H2TTmvtjX2t5KsSM7UxjI4s/3Q0Phm6VCPZCmGz4PP9gSBOWKW6/mASbaC2/T1zcbL2F6Eu1ZBAMz0ypdGRQ6HYulSK3MlNUBlg82MdUaZ+46ZFObMnb8AWhfSDV51DXjcSZaN+Ty7GWRTzXMIIe6T6S9MeMrrojshuqt+odPvNxhszl4JPt+A8uLwc6mR3syC5Vqio9poluie4l3vJjKvbFmwAAoDwnPVyu6N03kUah3K/OoGbqg0zIDSQXD0EOBttRvFJKEzrh/Zm+D8sRTDf+L+qkdmJuoF09XtwSCJYHRy7RWePLW2/F0PCH370buKOE2cKeWJk51jVGNXO5ZNDDtXGPJSSSEABDL3/45E6gQ8jesNT8XOp8RwPjNVmWbmwO15M0X+Np6dfsnY0v5R+xDGhaVuZbhNDApowuY57dBy2v3md4oL6S/IZIE1TgXHKI0RuNzcP6UKkZzsO72+PjASIcLrqFttt6syH+mjkuaZuhVGL6ZxFDL9ku5tV/nEAUZQXH7IfoCSozgP0dT4tSm+dqXqWPKxLNa59SOvSDlg3nzipj47qc2vgw1tsEuS5YMmtoCe/y1OBUzPATFAoE435MZ11jkmwcmwATxJO7pv+8cgdpO7YXOLVKz+pEmd+VtpoG3NRdc4sUJoZHca7iJ49Eq16ety41AC4wkTwJOq4NnFBDC5eQF4OYvKnYJLMJfq2TETgI7mTae5dV1fnhS+iSk762hY+LOjsyMrqJGrOf5Lcb2mcMf2N7AWRdjX5Ny/UOYl+Uylplvasr2VkJxLP9ftr7QS0Si1YraVgQ1zdTG+kDy3nOMXL2WD0scafWUg3wVdGMYpx9M1ysu5sFUbRcDv+yHE807rWbaq4Q4ehxRriE8BPpGZYbld7uzDZAvORFe6hp2/fMcdpkAHPJkoVota+Ks0Z64spwb/lFyl1HCxeHn9aQB2WrenelNhISwfrv3jwxnTQfebj1MZx3seXlKXyIjupLBeYgB1lPQqYNR6XPhK5Q13YxEMQa+f7T48BfA9ZqFW72R6v0FudRFIe8abbWyM3FcCCBREcVay9xtK+qZ5mQOQsMOmrizZOxADtfOUjo/IOxsrDdqeR7hdzvPhfaWJYA0Ft2kJWJG1qNiWIAhzXrqeK40hRZ/iHex56hWbZ2RoexRMQbOMWYf1PflJ4KvINeMplIC2eMnoEW5ldv3HZoqR6SJi6K0HYEX6sH60C62cK8289Gfq0VHqz4VjGR+yo51TIBpaOd5xu/+SMrnHhD5mbdHhZrEcomwPP/w+sjFzkf6MVg08MRtyou0XU1J8oRYHCmcgjP9zTn+Ku3qrmlwatDROluwPFjeWVph0o/+Xzt1yCYX7R54MutpFGdS/KFK3VVkjD25j3jjZwWtpsEL6WqaL9YlrCyJWYAgz9THI6WO4/zbG5Zt1g246URYnf5hJYehDI/FFrlQdF2AM2LYtPFSiCdPhuUZvMIJIGE8gwuYIHAYyiU7dx/4BoYAz+HhePbN+YaKdApYEIOa428HekWykAZUk259g4oB7K09BsYa05AXQC7PLDFkoYFigWE/ueJyYYVi6G4/fNfWnBf5cJEip3q4SFpSbW9pNiEbRNt8d/V0mPHAqUBqz/YQsLagtaVYwswx3i7IB4W3jBgRKlKBFDTb5k8YD6YFRQQoKyJ1V8VfG4OrXy1hEGvlYPjMJVSHc5gX+GFcIyzqSX/38M55wTShG3vu3gvebSD8u5zu2HVt2ezneGQSlbflsu4clGxSM7J39mBmXG4BX4JZB97u+wnjFdBzB4vpZyK4S7FAPn/6tHopdgRB2srPJD65FTtS2/xSBW13cEbla7eyKoYwVIXc0W57/Ksvr1qfuu/GFy79b4LbRe2PtOk8u/eY8SOCpy5sUbLkNQOya7hbkab55kdNenwCZZ5Q6kJXBS/l6TS0JikAL4mLUyrZaueqYWF/xMhFc8Y3HTDl2R2ZuFdnEY1l0anVXLclmbrF2ncsH9Pl6mg5qZRuMC8eYFTZhQUvkUiB4zSZLqZCR6XOYdG3488ygqCWCqnm4tu50hA2EatSsoqcl8o9E2crJ6OJQvnZH3aHA1faTBDsvjj1Qk5h2QCzZ7kVy+1rKDQJsWhfnmqPQCQcyeS26NUh49+aIugG5rmGLx9vChpQuX8v2RNw8hODr6PtdRgVl9jj1QQvXzw2o/ap1vzMJ2o5y2/20TpPpE2VgJXRdusLoFYVFZr0rP11oaMBL3TY7FoE7rUz99pokBUHQq9DyC2FvPEk8K/8YEyypho606e/9G4qM+brmO6+pP11mlIqe0sJmsvriAFVA3JuAXfjsrT8MQMwIZkt4RBHFzaMoILQDtv1id2WpRIrOo0TWlOiKPB0dqr76OZ4OBOrpMcCUDeDPDMZ7edtWGdWwrnpgURsVcJ0OpD3Yi2rYRD5uu74vx5QVRs8ACIjN73pyAVTwI3yBbNrLG6jXpbd8ekbGr4hAs3ppBcwaDuld1Zhs0hjUiVN6DzoTZ9JmbTWrUTBw0BCWoGG1ywaSqjby7i+8dBinEEXSn3ylkVcYvrRU4Qos6FNuRq69iOzZhrsmHelumK4BxdqoB1ZN/OTFCYLDC9K9rGJQibiLA+x1bXj/U/MhhRDiVaxL/+bhyaoxgVmANhcTeRFsnBABoLApYwvaf5FMGa1mxjnE2PmIDlVXBdP/7dF9KLyuc8jQXnG+9egAgyyyFZRaOWRJWzwnsL3TaqZTxgy/+M0uFyWuDtdQY3YMHlJW26uNPzY4aajCYfh7oXCmcUAPjftSO/t+ZHVwEQ4zHuTTTO1Mq5y0/fYJgWyyQal4Qx6ef4O8/jY0TCbZ24swuEdnqPtd0ffPo4P8H8LfXtSabUubVbP4QiUErRDU9wrZikgw0WyI3crghNhdW3dF4eaLSTEw+U3lemR4SM09hTW9jtffbwEWsBNl24gujFzhiHjblZEXkZFLEQszSa2zbitl9RWnds4yhXEkwALjBEvrtTtcd4cwOtWPKvoLYhjlvRrAtuWU6Sb+w9w3sQHFBL0JSVmvJr+5eKZ2XW9Oc2QthiogBQHUx63gY54eS3ro5+8Cw+EpKiQ2ft3/iNBrUp8/vnjC9hTqBgelz1sqhm6YJyQ+0FgDk+QdFYeekwScIgzDqECvLOqmrVikwkVI6C2ecKF73EVO+SsQgd4KXA+6otJyTFjiRu53vD9pMeZZCaw+iBB7LVwEWFUkJCnMbCAl87PYlsbFzswVeitr4o9RiuLzne0O2yNOaAGlvzzN9djJ2fKi6cOqHIvWA3IOkJyIFjTZPveozDma5yIiF1oiiPnnt2YguSoEeo8eIKjKFbU3i+mo3ndWINk8Oq3uCz6fmp9ONY1EqZov1TDSv0nx/hv4pHvL49zA3xQTgr5KUsq3my/r64r3ZeUrBSC3CO7a/kf4gjRZ67dmjyCxP29ZwB+cBY6JtoS+AyfEMJX7C9+C4zV3cFYlb9PYZ6UG9z/fIlY1dkH697pMkhUSys1duvCsWYbnkcMOHz4GxtOPpFqxNGwz/4LcDF1ERRhsp13SlJPGhPmz9kGJVIT9uVDOqYgJMHJazoHLf3a8h8/O1q5pp6t74Vxr9syHDd1Mc30wc20GT4zrBUC6vlPhizSFhYklnSuiT4nk2aV2+2I08TcqIQR4hR9FZ/Yf4KCzfQhUPQ5walTYYk8bbOVoLn02U6C3pZRPPZuR/oa4ef1lNRJON1hYzYtTKCFD0e8zLW927a/vbwpozB3AdQDjvkCur6rhb1RLGUYNf/NOkbpyI08FmvROiXHROmgQwRlpSaR5OER9bsYMF5bV9ZfnN6EKTj+Etq9jadgjMTgj3DU8L/H/mVXvHgNDWToM36rXLdkcxr5nN1sD9CCQSoi1wVid6XHlGkZQ8N++70KFOA9FdMIQ3/1jYUf5r0WPn1H3K/721gmbzXUFdYste5KmHtTo01d4/CTvlB4c5fw1NynLQN0BQutTw423IxLYSt4MXLt46UR8dV0q+hOs9P+wcVl826a5pbfNUN32dQbN9rONTuT9zCJqHKH7iTbyjar7vHjl/mH94csIE607T2Vwek6CdPhm8gkC7iC9o6dg2fpORWBMm7b4jN0bzS+DpWxboe6YO62apAjByP7uogptTTvL10ySwlUoHJnCjIm6SAGFe+qxgfbNmD9PvvKVvvPLQDxEkICC82LNvxKsnlvy0RFPxy0aTQMhrrk3ARcGsm3Uzf1aiaGOczkDUjw9d1gtLU6N/tnU2DUu4WJd3Rb0Na/m/NY/fFqma2UGhJfsByMGYNK6pwy2aPFEM7QCTB2pouYYQ7KjrhDxP0hCEVt3ISm5cdcA9Agubm9DIM8R6suLB4eSscxfaDfAIEZSZjpMUjpbNqGr6DdHPJC8aFkCnteqqsS4EArb5E6sAT+o1TCDslRkxCgoh34QP7Z++VhPiCYWKoRyZOjkUr1IbRITinA3z36OJDvdUkDDScUDsY6GpClRBDtDYRVXw+nPgP9fIv+MbzIwUaRxRrq9v25pF/ZVkZow53QyFbUFLVdPhM67+eessNOdLdNqZ8hp9YrvAoiNoIZ1zWoCQu68XnxkbjnGbvgeLQ563ENf260S3YGcaMw2PYrLotNmBVDRLSKplQTMGYdtpYTi68RBHzI4Iijv/7aMBdE4tFt7AsSzzn7NxqUmK65o2U21imUp5gWIVlirkXW1riYHmkhkLzfY5Vf+Q3mE7rGH0PV2PC45mwueeSLG13K6MdL61mHtkpxcAEaX0gz/aU9z7f9NAQ+r76E8jZZhaNDhyrW6Uj4lCKDa2E4TPAuK6zZKBdNYvWNSIvBbUJQP+P+GVCZCpVDjOSlimoH60hKGO77qf4Y5y6pzly2o1fIw08O6pHv5BS5LJTjJRTiLJV4NfIfnZnYdcFXjRDQIZHJE71gUx5Htr0gro2qAoCEo8x+Ink9A/LMg45NbOwWAmxwA+0p50qCW1V99p27SjAg+NhHG2wnlz8pibJs9vBaBzrRhQccWKHWoDWlGu8OwPoesOy0nRo3mMwUp38pEFjO9C/3q86PoqWqkYaOILUo9f4uuCwy2y+jXKFv/0HPNhgV3QuGHWSyoDOmXTLT9AUY30lc3RKUg96yRrxMUYNaEsr9L54jhSeEGicDovl3xuwGLHquG3j3vN1mUlOsS+qOWERdupeKq9aH85h2qSUnC/045GIUuSydvTHYncrOxa5DXV1hy/PCWlDgP4w+t6Tk+vp7CWOyZbuJD74VmP1Quc1m3tBA/N7RSp8cvOJtoxbxmNWcw4ygjwfJMiMVa9HFeb1ODg3hmwfHwkj++sHRgNtKY9947Pv8fNgqzLZzdXm7mDOJhlPe8Y33X4KcWdufIhgi6y1o59KXpYxxP6A6LxdU3ZJmbr3b3WOFes4GAfis0SR0bCUH+7MV294Y6Rv1ahQS1VIsVYkcDtEMfRmnq6c2c5BHflhBFwnRWkN+/jh8kahkGGEK6PdQ48bkGZPNPPracTr5TXqHrvX2fSL33T17VkxeUTkYHm9PRTQsDmFWvnwx/7GCzqjb+4FFfcnpyk01t1XVEC7RAfuLv1HqcCMIo1kcMjtHrDZAp0kctVXRzom13X3G7KT9nCrWWL7eRA1dreATqu4lQ1IMbJMRRg+d1iFAl61NB9Dt/UDnCDygWMLfnDXixf1sRE9a4I5JQVmT+AOM3J8sBBNBXPOXLC1mRs6JhrU9I9PLgQApesC9zaJm3ByLtewAVqrcOvvTFvmUsidkw6cGhpF4DhgzU/BWbt8lJ+R4FoYmRKKMe85toC8EdQDdD6PIf4oQdmRNmJX485/MrwJbuIh/ufGdmrDwR5kksVzpFusS79vd+IVN1Ck2BKvDH+rV/DJ5j0Aoartlkfz8fua0K/YYIJpssA3cWqUpV3Q+v4NwHvzT7kxGmvmR+lLCk8xCHBj3uYcMtFSK6ytpgvN/lGHbTJWQkB5E+OmgG1egLtKZCxtRdNGVjhx5Bl4PRz9jA29srve/iEhObEArOj7WwnP3nEC7U2UQ2+J8vecKdkxKoWAda1jA/sPfmkQGqbZIDQsHnoVncub8oYR5eCWr0hsU63O/u1JD1vDATv8v8goG8U5pyCcypgOPKn/FoKo66fx3NTERqNd3tZTTnXjUJxZUreMgan47aEtNn0rDE7AAczT+sbR+hxsbuzoruJAu5kpbVku4O4BmdqvpHLSTXqGWL2+xNp714sL5IWSOKL+6nyC5ikfWeODA1IOW5LgF89egDd0v27Rhlj0kOvAqrBxJkFpfgH9DT45On23JMQhZDWIJ0vAhxCkFgqxpprXTYyVXGbOgbWRFrTZofUpL+VWQVJEih6vjlqHvk6Lk+5+5AaS6Bm4zbUXgu99jlq55qD9JStkvil+8GbpjqgAw02Pr65yfNTiisQ8tOccjPGyPqRBdrnDGMr4Msjcy8NIngLyPr36jg9kFkEK8XvPixPjgUfspJytnAV+cFSnCh76eNC+FPVXTyaa5XsI6H9FxdZh16rTHdmZH27DuXkIDNuzqLJ3rpDbp6xbTYCs7Xw5yRpb+WFGCv2kaLXhS6iR0RYxvtmqSsgajDGZ1OIYnD9b6GOlQBy+5S/XgLYFuGU3O4A8cOIRY2I/u2gy/+E9quFXpxMGdtTgEpYRVAXCKZIMUGWM4crTOOlnyEnHGfo2UcwuxS+l7En10r3FLBNkswPawRyCmsHrfMFy3oThUEMmWCDIoGS1xzYtswB9HeNCZ3N2i/fjLc2Q+aDe0jA5J6VHSMorUG1Jyu4Qd0dWrDzvCZakl49FjVpDbB9w9mDanZY+FV7RzOTDXy7tY1yOo4Nkt1Fv5/guiCOb1Xlot6kUOQZPzD4SVi0YJ7NR0MCYDhIWTj3plqYODpLxINBT+Sp1zstr9E/SCDR+sOFjlUdbrDDpdP9lI/8T37Dc7R7VzfNiOU6BXKja6FIV3dXR8M3ldeHju+9mJ5CJbFNRXqxNyzAiDs2J/ua42AvHeLXlo5grcVPp2Hul5dzq/VhLulhrnZuKA7YRVGWLfLGhsOfaS8CmFD+VUXdpWmhgi4I9EKypSEEH1zLXb5sL/NqBovhFomC4xZJDNk/MP/A14rTrHdXHC58Vn7hxmTf+isaRuJRn5Gx7vws6Gqh8Swt7l6wdC/acRGgaP0i34YBVVHXldQTxrml8wFYL5L+T3mV5JQTehVmqKcQPu8heSmqDivsxAWmaVmoNRA0yJ+LTLZuq0Dpp6r+9mN4l0p9q2wBOIuPIhGpXWscepPqyKDbTzvtEGI0d4edwhnaudE954wJbHzdbk/8xhP21QMZ2S9vOxGM6qFORNY/uDYcds0+J119HcU/OCqtY9smcCFHM5bA4rg6mfwB09LLvfgKFIl3YeSbJRY5MD4thfP3owtHCRisUTSuzv340/++xuN3sP3xm6B5DMCD0coS7LhgxLJIcJmgOHjyfxEMQlijXyW0KRV6YxZwLFOAdQZCbivdM6aHvKusCtnroeTou+fS+PqRZW++DjczBuDe1M2xsEYZqpEEA4x/GvAA1KCVZLXJBwVTqEgbVoen86WBfRHoJglDOcCHf6Yi4nyc91xtrhJnfCo17qDmUaLaVNzATelrdrJ8I/AeRUC2aEvOjmIxEADZil5g963gey74qzVT1DQR9gVGXHntyrBycFqJpdgPW5y+zvhwfkR0nv2FCNUh3BprkL5a/HWVDFnLNCeHUI9e7PEW0VLC50sgppVaecy718IgCjfUFLRodh9YjgL79Y5phCkNsQ/Lu9Z3/2JqU9/UXSqBM4N5CZYWxDNJ6M1D+gqKMuj2MvKhuWZgZJVGOuYOH4qu/dtj0lS6uUGUmZt0g1NKowQW/MDYzdmE86cNZUVjF9mqeHHxnsr+6XxHKzlA7UAbUXTege06nrrnfi9v7R280TfrI9BEpdTmIIu29LuXD/cHUsUrewB8dlXWmdaIYQBXtaQ4tJ1PcxPvi5XlixPoExTSuvKDw5wo7tbmiDq31Lnn2K69uztPfzjMd47h8greTXXeB8oh/9Y8+gbP+i8p5BpkelXAD4838awSIonu3s5f10LbguksxRMWTHP3hXSEiQ6fINVqiSPoOcyBugDNIBxHWx9yW7vl6dRNZMHn4xEBNF1R1cZkItYQWfa4ANE/e9Fn+0DXFu2V4YQVMjrb5OFR7vyHlnNlD9UfkFPVU8RzmqYlEez574ioJb26gaBc3v0lLhwQz9pWinUsM8y7U4izzeu/lJCqB9WdcvVZM7ArQEXh20wCWeZ3wyjF0loq6BeI9utvqWlybJKxaF3M9LlfNfSZ20/LqK9V/Dd9cvQbn/3evOiVXVkrlii3R2xftth3Zifcq89QQn4a0SGVFon8+vtIJbCI9vLkDWp2JMXqajDKk/4c0CsZDdowb5OSvvtbkIUEcrPRswb7jyeSGlMwsD+pscKlnKRDtJuItwjnF7WEHMrSDYePz9cl/CWPbncGrW/DDpxyBd6D+QZX2uA26hpSuXORfjB/Sum9xCo44t6pATL+DtkFyTB+mEl1FEb0L1x7M4GQf1dlLiYhz8F3uPmwMf0SoN5N3U3jjGd8W8y41Sp0Zg8dZPr0xULpYPoCxvIy9yo53F+vEVBDrRSSKFfHUn99le9RHOtf6ewnRkudhGwloNSKA8jT2vTJtePMy+A5PwhoXvnZTsL7w8047k8jY2lqYpol+L0qkdqOdHHYI8xKPdL7jepdoU69lFi1QHPleWIUbg0vsr6R2o0XYHskkOa2GPmnUaUOhV72bcdN6AmFJVO7iuyM8Ld4ZBmVT+K9MPfQFYadpHL23L7CU/MiTkKta2VLubT43sEmaY2SI7uOSqucAxBj4Z3gfvSnJ300FFJHe2cIEl2kvfT+Y2VTdWqaLcLGxWOYu1qVHeZri74eUDaMysNbkfruSJCHVAiZP437Qru3TSovUJLOboALDgUP8XXEoJGiZDjgKlj5F6TsgQVQX3lfZwCtnrCoqvolNuAcMbxeXS3BU80W37/anm8/83CxiEq4ClftwPxotwhJqdvMhZB+kL9NDTwCbzwGJww6NA1JopWFkmMBe3oLrqXQRDKKan9pG40ETJ3iaaY8LiBSm+zBCL4xM1vc/2lJm1adZR3dUXO9OCnNtDbShK4T6JJaUJzGizcsTZpTKw9RSMZ9Y9r+TO1phgKfg2pW3icYZ3s2twCQ9N5jQm5AMdyI8hpzDthX5d151ubLyasxvnMa53BvS10yu4wrnJ8PxgyljugSD5onLC+yNt8FnqwuJ94ABK+kfOklGOHagTocq+aViguh2GLVbQTCJHBG9da5s5PCNCbQv54xFn1T5SCuG9m6G4Jau2zYLu8BOq1QdTK6A8TTbPqp/P+miG3NvKnha5NCU4W0/oeV30ogX/cM7IMTHajeNg5mV2nX7B8ocPMdrN64G9qhIZZe99UsbnN3ffIBrZy56Afp4X3hG8eG1C3RF6RSx9r6F0so3D7PNt+uPgtxSuNBegGF71deBd6Z1NWjjKwY9tKeMAusLGQFdwMk1CNpHVj/pZNXCDlmm6Rm/rtTL0YVtMlDMLIVjxgwiEHgGB41g+tBAneJgevjTCGmjvQGs9B++o9kHvSsSU7lnab/4wEW2tweFakvNupDKM3quAgH+SYJ2qy8FtRfcRb3W6/vj8/lXa2DiA5n8jAXflUU8LNloE9D1Y8Zrs59T4eHSUDQ9zYj0AY+jN4NQ8pHRVRH/7vVJb6muc0swA1rEC6cnH1zVqI9+pevaEOkrZ/YfElplQI168754q0/yGzt7xU55CP+8OMa1phkXomjQkseVBcXxpb/W56r5z2QdKf3KaI/1RrBJXT0HWg5Z8DPqBFoGpK1Ih7M/ksrkXC54HXyTQBbCpyU40SNaxhkWGQA5/Chi4+vDVxXnnssXUtr5DNF9KygvqscSEaX3eqO/scoC18aZJbkrKjWpI7KhhCWwbg/G1AVJxuswD4XD7BHZbScvKGTN3bnUJC8fSNYwWlL95W5dqUVGDUi1whyn/rgZ+b8ncgG6Km3WGOXwHNUe6DCjFCu/dOilkqwPj2mPXFmUbJR3c77jYik+5uSbK314n37fsCc+d97Kp2P7sgDwVnAcZiU9hQXxDVFQ4hV21kDYDd0kUaJL9FrsCEQkJOPSkreZzcQW5gyhD/MTZYo7gsb7mzjQ7RYr2ZNe3XT/gHIkvVdtVYKvYqw/pUtwsds8fwO1C9VW8uaviFZB0122cN31/XxT8G9E6ttCHcJaBt1BfTKO6yrctUfQb+pS/H0APupXIAc4vaeWk1p1q3BtmHFNybCJe0N6E/4TzZ0Espz8AIAHwf9BoDlSagMsgiUWoDm1rDfe4gqyC57NexFzfqwjznIjamLp6jGbumng37LmKDGbxpiPjxcWSUHESToB6NbC9r9N0QrvbBQMaj+XvOTXV02S9S7VNKKwwSdVZp9NP+KwMdHgO0dw25Xh5PJHCe/FUeH/FT/EqIFuVNIt62NLD9FKprSZMSNSJYD6lGI17MgJazcNzclbzck0056PgTJfTHYxO+N01JFDII2gcEPQSM3kYosQECxLIAX/9ezs6WW9fcjQ97xmP/PjjGNkzMDQaUB11fmaJyHH5TsWgtOYFniolEyk3q/DuG/BEgjMTIQsiLjp6YTs0z9ba0pRJ9hTCJ4xo6DlXowdU4+t+56CJGbhc9lQOJNEEc8vVc4cbWTTpjAlz0XSkNWYkxTQiDdbnABCyOztgc7pEYmsu2DIoCWUFgKx+LWM/6RbzTfR3Gqb/sEKQH/R7L2Pb5qeGRNTXHs/nT59ldghRHADwm0GmmRqYjo1xwxCQnfptSpvR38gITUJ4x7XbvQeQAy8syVtScyyzs8YlCXXWgFL8y+zJ3WkXtmeBrqRl5yELRCab2bj8e39criTWfQlbXptjpwLqFrIe5UcWxJJGziPrtcgMcogHIntKf2t29YAg89RomrUDE/FLKzZnyToQ5LY7E1+2Rw9OTxdbkIZx+Y3QiKyW0rPrqlRkrxp5nN7XW5oR3WmPPUKeVTXEAmbI78lmNJR672czQ1bvp3/Wdk9P/tN1mazeHEkFuva1u/+3CDCtmE3pby4k2iHS6yVL+rpotKYqs7Fv1v51LgonEWTKPbiPf6SUANnCOVFVoLKlXIqm/8UYXlcaUM5lZYJtURe6074J3vssEoncmtJ5/Jl44PJWR8RJCzd19v69JhmV2S4k2WIxCvTzKv3wvOdTQ3ou7mDfafMXWYRyvn82XwoYHgP54RkdQznIerLn0qgiKg/DDhjMQxRKEjaL/fnUrfPKfgMOxtxeVZ75JgFcJow9l8brMRyox307uRCVLQN9XXRyjI8DXDjD2H6Gr06x2c0BEz3E/p2oWb/o9m39RWUdLalLvZd1+HxGyazH7ZgPZEUpz27DXmfQ0cehTf6Rd6spJsIzquTpwArfP7YPFgpcHE5olHTex1+kENFMTZ7TER7hxReI02gQYFcklVXGvE1wh42e4pCX/o6lCL/HKtQcVLG2iP3QaGoKFwQV0+yFNalsj2wKjdlT/2v/nxAklj1pAD76Er9+sudruw02uSI8DxuVPFrgnFF81AooVxITucDTdQhmaLc1AHrx24xfRlP6qoBb90BX9DD7gBdMqHa04drF3jyO36kHeCUzoHy0sS0y/xs9PlMHc2PRsjzG3BvxT2jVK9AWXpuTWaPRAGs+NXj6/IAwiLU8mnY1Y6U8B/bU4Ra/NvIEAtOUntbNkN9NO/BFWbqzX2SpNEVcvM2EeuBKUEeQmBVeXZ1bpE5ql8QjP+oQsRuxNZNqMlQ/LvkojOdUdbdHnC46ho8mglp+jY0pTMZvtZKw+3Lvvr/XoVCntyyT5JsBe60LENC/PC6t4CsMBsE+98q62Zv4nTMAops5V3+7nccvTL9FJzRz5qMU61A4YMWaGa4w62YWVMjtPZdDdbeATf+PquklAzhuu578/M8Wjv/YGcupiGAuQinfzRWWNtShGW8bfwVpNKVAgSmCyzEJhTfocZPftBtgyMM7efRcTehCB/Lu3cFhmNI8JG1fF9j6BigdfIfzM+F6t115ZPgr5LsADexGVW1m1N6e1PIqpetD9LA6DR1CcEPksa0bkToVA0yoFUCclWqwe4gxyIH0v5mLxp3CsH21/DKC/OJpeBvIYl/Hh/S2TtQtDtuVjCF0dQ7q/nw+sfidLeVKK9KOTRUdcWIclCu2estOBhBDP2mUsr3hTptGUOpsLUjvi+22qY21WAJmMEbXWTBAJvKwA7Kr4keao7mb2Zmxi+coyOv2VG9J2OcS/3iB5d7lwF6M7Rp3RwmHVWoRohWTxqkd3bbLy1l0G9kSSUQeqhw/9sxpFGYYQ9bMt/6pYeeH37SsJdoWv0Mvd2g80UKIE/9G5eWNzIybq6bsCCsLc6nSU65xx7LvbgMsbJprYf8A2DpPayhyIxArHkQ9Jsnham525kieLzudeF4SLCp1FHvHfVtP5SaohvZaBnK7GW7jpSzJLNjkDNSoqx2tGtGVVfwaemQte7bs0qkHjNirBuFYWoD6Ia1h4NP28CVaYOi7dmdJ7t8sDhhZFRhAiBtgvu4bkVcUN/Vdo2ExA8HdlmUNjtdLjpv/0yvu6YM+F4JY/PVWe7j62ucRWYokOZlowezbn1Pigd8qSOgYe72ANxLnkasbaOrCwwKD7LC2BGsLW0UdnbsI6UU6ynBqcq3ejol0NxulEmPuvkjTB1IYBJYp+t4EfeQci98TlccEAagW2Z1b3hYQ6fGeyEqB34Hy0kA2PEtacMtirM8xp1LfYtkcCxTwhXXE88rigprmqvjme3V0f/tuiyedPXtYYXj3KP63PaJ+KjhLY+phuM2lE5i5bUuwIJM5bOkZlRCbPACbKc0WYD/ibHBqIg575bV1K4te57kig/JEGxeNgVc9z5FBxlHUg8MycSPRQUYJmMEnyctt1sxPSobuNNpWNprQJbKMWxPDI3cfwYzzqaugqNDCk6llEiWjh2tJY+BWXtUPeCuxJUSxmuaY8pG/8mjuy58evO/TuQ/+rp3bVP+1jbkW8JA6PQ35nfg5CwSFAvRU2DST+15NVB5oo+8XSbWBTwCOHeR/8zq626gBFA5ATgx4Ftc/c+bN84Is5bUh1r8iM2vLAXj+lvjXriKSK7cLKsHvGpQEkYxKTH9CWWANnrsg30nR29lgaqz/LVq1yU2FpVEv8d1rQ8RgdXvbB6pXQ+5+kZrr6Xc6YEMExYJDqMYLperYVfP41euQAam7lok34cQTLekMcGjUDZRlogoP6Bf4UTapNWRFvBXTGZn4AI+zWH7an5d8moAANOHfsr0dfg/8nOm/p4A/dDBp+4/4jlCh2X2MYZywiWnaF+MLxjwTO6tn2Owvb20mt+h6V9AN85L2VpywfCjUzZRE6mcZm9u/ckkDF1V58fMSg6hXUrXW7qF0tNw1A4gy44jdgsc5WgoIPjLtUxHWQclFLWbQSMQ/J4Shj2VVicC2zYSTdDOUN/QXstc6kfCAfQR3wUsBBLx3Vth9W5ves4BBC9+MmxU258Kr+M6E1v5pHofFDHLXA4fLuNoxRnluFavEcAZ+tdNWYIPLLKv9pUx4PpF31tFi/v0kxYBeETx99LRThnuuuKSxhYl7IWE63zV7jh3Zxo7ufVf448hfPi05XwH9WGF8bS8jJo96A+tsGnOxxF1gF8bhFlSXuPWgcG05Ms2RmP7LrCDvFGUwhYchn5JVVW8e1vxzgKzX+sjJ2JS71SaoPlqaKI3XrVxWcycZbqh0fNt8NDRcj1ACH4dh1MO0u+U4QDl1Ab07VrRquk+8jgz4lSzitT2PXTuiRD0ikSiuOOOfECTfn/DslawAcDDhy3wZQx6WDKgVLKU9DFt75jzaVBU7opFNz0DjiX3x86Sgvo6yAEQZa3F9VABgRvmwugJN3bLAbzIDSENdjDBDru6vGe7W/fWpQkXIJMrJkv4uH0KkfEruqknWHzp+V/6AAtEQyO81DRmhMl6mAWSW3TN7JDFLvYyntdI6VFflgbqIxZhvSF06ih9dahJHN0oWDp87wHQH39a/FQqEPt/3bqX/5/3vQ3e6ZLF/esl+MTh1ajFRSKVXs2aXezPZUItnTwD8fAPQsCy+f9EEgrkbycUV9tGY8PN1kM/O/9Vxda1pyrQ0Jx3SbtwpP+E6n3zNOdiupaWnDRF2XUAzaH2/CHJM09km0jUPOANK47a5sX5rzOHzgZ+Qw3ngX6DWF9ZsfERYuGM3Tvi7tQ4n4Bsf0JVoWq2B9oKPCl9gbQgZK981nQErXr5UxB/NBifO1e/7IwFIBcJzi53QJu9Ygie163Bl0M2ZT4RuEl+yg5hu1gmxTPtvoUN+ZBM6K/Q7h94m8+FtpoXO1S/xwEa8wNh9n17maMeqXn1TPNHic6fgJcC2BIxtDECkm4LXWdC8iaVXkhV6jqxRCBlIoJVf3Pu3X8DVdz53rPRcUI9H2djFtQ56ENzO3SNTwuAjzYuLjY3uphTVcnUQIUFlv3zOjn4OFnnnYwmXuqlL93cutmZ1xQmMROxocPZt7RPc/Ed/5oL6kKjFZhQt7woZzyKlOE8qhBCeqJtnRLR2obdEUsflzic48abqmAtyA1kM2XhMz+xEzo/4arm7oYq3ISCeT+OOo8mptLvUeAQuAfugrTggaylJ7ZOUJQYDTG4UeqUoBL7WI72X2NYKp4HnpFBIQAoVWaD2u3AIZjPY9MXLudWzo+GPTgU7Ou8MzBIDBbefWV2TWNrmOJBnJdX0tnGYQhKGHc86GeaM1pReRGzjTuVMAe8Lj+yOogEA88Tw3mWmWUFDUXkyNbS+pQ1ZCRkz8cOIu8CK3PZDpA25L3ezJof7fvzTNWVg0vPZwSySVAw4MOERPpsXzf4NvJwgf46iwI0G4qP3Hv8XsdKDV+67S46sLMHVZINgjim1E57gmAmZXGag/w9CXTkyLKQd9q5C1KCkTp8bmD9Fy1cV8RlYTr4dLWP+csXTQid+McPXs0brJ86spTda2BHs2wpxwI0Vcz5GO5KjL2UQAlWbQuDNrqaD/+rDqDWpUyr6oNHre5UVdj1yIWo+vkOh1P3NMPWKO5qMPpipRfrfcSt3OA34H5OXPJhuyXGpQg+bCQUcS+7GM6uMwXeAIeR6EKGR/qOSqRWqd456qlRLvF9ayn3LJpEUeZVFQ7ix6nIEkMpbj8Mna0Zq6ji9onwhsGK59pntycfFXNInXfTduKhjYfF0TIRvk1Wg/4L0RUB4pegIG98IKq/zd6JaD5GCgS49G3Yg05tjUWvJexNP3oOT1Icq+8wVsF2HYB83EaylSADqf9JqRihiQT24H+T87PgzYaDPooBBwEL8jOwpjeSkBhq22aNtCgPX6G0SnDsvb61BA3abcMifmW6dzODglpOEl1GpIxHAh4bUk4pDmmhnEv27YL9prOqZot+1pojbAZGkU7/hydFysAO40/G/hJ0C4PKBsKFAW8dCkaxRGUrljbuYwXefQEEKL7l1J3h/Yem+rNOzqtXWYQke7/sQIL8HC6DDCE9i+IKXESEgyWjouExG+FUFgKawhkQNRQOqFUlA5aPJGrqkv+R+LOdhL8FoiZg1qsiWzSI+O8eoYo800VomwkXDzfNI+o9z+ZZQHBxInDCaFGwjoIup/oxrY6muuTMHA1c5uIlZS8CP8PdDaPuRyQaF9YrOJvV2ud2l75+YrdvEipLUZHxeoA+mx7KdG64bQBXlNm/hy1SZqL7lRlNHub9H+qjNmpI14lpdU7dBIvG08dX/JhGocTcO9fKBHnMaUkM0Jh4OFYSjTuKd6dvkrCpMyuTirMUB4vYH/F8sID1xBISCGaaIJC9T3lR7IXNl1PfS2lx9ps0HWn3ZUXaW3XehnEAZ/GzyvgPGP8DD5rubXnGfM98Iq36XlKViF6xNJ5fDD/qbDGsjuWrIjOt0VoVUBHwnJHmSriYoU2QrXwS61Jz/7fQvSTrltqgg/L8I4dZAmMtCENeW3PWHTbRn/taUoee+crh4sGHFaNgfr4fm2agRYk4Zt6Wp6TpAKbd5LvLwE4kfk9MdkPBskDcBF1D4M3jdPtlQPxyGnESExZPAfnI/phKHRVrMboraV76nPxb0NR2DdIjOQL+tdAYnEKQkZnmmxmQCTs5jnxahDjyXZkacULiVbNLqiO6VSj0E701bdFdUsEXpyolSRRTq8UCnQ9N8Tf76pCvqnMWsI6nj8immwdwL+MSVGPk590DBo6FnK+iqzib8ztEFBrGgIRupw0leLmExpQ936zXhWdBmF7KvHD1wX1wYCh3U0nji7YFtqOflSkYjqBhXx2N1K6J+QYRyaeN5aPBr/YBoqZeWF4vbEw5ohnO+X6EJFXuMXuVoOuGVucsGGmg2nJGBLJlfIzFNV79Dt+t8BfsmffWbjAMS6c0jYvdX1/UqpXIzb/yJ2o5YaFJG2zDJrasJ2tcMvSWXXKgCz+bXTZi3Jz6/7jiIoxNtkbzpGHmrDdJx/2O89LYniF4l4U5RN1JKC+xTuQ4UHZdk7nXrCcPlc9i/lQHLXGULzpF8ABv0JHObD97rgxZQZFM5DFOcITyIQqpk4SE5md0P7HxXa5qA1iYvtGIQN3Ga9P84v7ZCEYQ4xcOk7ySqgwNfpl0MZ4KndqBpnjS7MQ4mtb2ppLRXXKfUCMSFXM496ueLTuGw5rNi4xDdnHExHazDx6LwDItNyxqIqSXs+KEn6y80UA1Vr2bIuDuq7fDw4CkG23J8Ici4dBdNgo5Grr8R3lVOwUXg6yUrVaqjGn/EmuY98dpC6BcyI4P+kkRSqvWWHdKL9Si8Pfru/qS/zBGdub53tNZpU/73VDgipe0nij+h1xzb2KAm5lkmKvY72/f6YPCDFpPOzmIZmRTrT/+vZyrQu0zMn9EK0x/VbdblZGvqAq4BD9/TSs53HiIZTC9eDx9R7awsnZLNEVY+WR8SH2UwyUisbv9WaOArXMhcBbsjnYQDhOq1KXbgmGCnfIpIcEh2XIKpmNnjVSsmHotv3Q+7GQAywPd3LBUMSu4ag0ekvFn9JNQUyen92+gQ4gbO/a8JDQ9NW0NH6sF8rLl5UHdesNXCHJBeW0V46P0NJzpTeiu9AQ9u/nCaVOz5laazbHr/J7AU9UdRbcDrXVHDvb2h2lvooyv7sfHCnrNsb5j3pDXepUUaXNDcqo/fWQdQ+YGF15a9OEoTuhmY3fPdNoj1qmbqEO7tDHQoxMIGxsKB1WkUhRfiGi8eEFphNSngzHTLVYdh0u3z7vr+XVUzhZESVPZN83GRUE7phViq3QKwhiSDmUkKp3SC9V9qAroo7Vw2X02utm4oxv+9E1fUtdXt4RKIYSR4GV4Y/jukgEhZ9HVcyxsZ+NP0LaOrHsZ52xpSPD6WjN2ha+5G+9wCSMkipRFGAV9AIzK+VIsrE7v8H5My587GZlA9koH7xzTd+t2V+uuZDMJzAEo0j5KPYB9Nmv8vafDnildySQdShM98aXlKVj5ulM4rDUAUQSljzaHtya+2KMg6bDKHSzcx3OEQ51eUB7Rob/Ovmge3sVdLl2fI7ii9FsHkH7FlIzw4acCpf9/glGkIt6JE8aB+lalA0zHQsUy4z01h9S75fgDCFoOgQMLehhhZHo+0gyqgNuQ8XyV5Eidhc6eEj/c91oycF0moF8+YmFvxJmvO4Rn7yvPi7u15RKS25xD/EjyvdvbqAs0OVY5bWT346C+83qvMfp4eVkn0xLbeMdhaGHC+b+RIyZBNDi/a/azZjKQQWiyzi9lDeXG5HfCKmhQ6I90LPBklNo48rJvDZxCuOOwOkuZh8i4njnn4aM7InuSflgr0EgD80/BjZgjH+yxTgdG3nTdOwGrVU4/hITYPlN1yCpmkJLo9q9OUJzCiKyl5nQY1OIN3kYHqZ2I050ABi4KmD9Y0jmvmTUdtpI/ccxjKBdPmvS52mBKaSIQz+zzv9EfV+4HwIJbdqKirxOZo0Zo5m4zcj32cJnzbDEVDVdAy4w1+NB8r15U2D+4o9P4LPnJdJum9S5I4TI4XXf20JIaUh9RzUTENzKtG5VYIkd3SpbgDlUHPS3B+28TOdMVba/psWGpNU5wZ3i/UypRx/NIcKR+LbSJsQL2glbBedReJDeTORlSMw1qzll8mY+xrSTN13TBB+WgtzgXVGmvfjWU5YreGw3ZxQxEkGAiMzUqI5oKzd+CtXq4VFWyn2+YrVkCD2hTQEJjfgaMZc5hY+BSwsHyKxhiNhHqaJz3/oSST0q5UleALEXd2W2GFJGT+Bd87K1pUSlCgkV5I0kwuFsjvKG1ppnoPt3ON53uklZj56uLjdJWLzk+WcbsPeiJHyvgJRI4BwNeaCMzkGhJxMhUs/KDc/70cTat6o7BLfnymtZYt8OioHgTMI2csDnkBNm39a4UcNy3sN+6Tq0wvO7Qnv2KlsP5YzRoiRTmQpQCKC3/hd21pvy7LlKT4YpSX4/iP8x1+J2NkGDc5rqHKGjmulCHt8mADOlM9J16HA2CRdm49HzYCtYSgp5pXpBn3KwFu1okl5Xo9T6qRvJqfO6XbmM/g8Ol+d5o1xnghNxpfuv4QfQuRp/UowIhXJTzfKPbzSzKaNyK9IdW3MfnwfJBwXma7mss0AqX9KK024rz/2IdpXqmwvg3lOXY3GBqP+uWfISlwba47Sw2mhU/mrloNjITuK/kn7tMvCJ304v1sZw03TPwpbnGEitJzt/S4wl/zUuECHoOshw4dI3B8tNJWsLPCYmB2M0psliJxsAsZnrdW0d1YQR2A9giy+/nSVJQD1bJ6oarvL4e+aXOaoSv0ddlumWQNvWq0JEZD76KYUdOckMNVa9tNiaowhQeTHsiAVsgOdtXCTC5j1FZw+EzvITRTETQfpfzETpU6NB07hwPVGNDMuVytNWOEjnrBs2IaPDCGKiZ1c+c8UeDqw0K/lD9EvWz7hLXVJlemIUg6+MjG73ckV5SgAsYirRGA44eLKUfJW7blQ4M7hWtJ0vNwKyHhuVgmIhz2iVno4GQsINNhmLI80jG/8m9TG/6dE7hTBmPOK7g44wH/w/i7cktFO3I6NpjMUSeR0/9SuxQNXthBawInsglHKI9W9VLPIizNCl5V7Ev2ZCUc7ycswmr0NDhR4BE8N+VKWNp2h73DshcVjc88kZEms0xqebAu3J7fq+V67sh+h+oF2bEk1VVn5qk8nZirh7+QYAWjPin7XoieV2be1fUqqFZ6kFH4AfS/ZcV9OavJgK8E0q6QFswICRGy7YBCtu7OJB6U0MfCYfgY/Jo3HHf7HD2rr2/b2bBOKSGwHQ9e2LQGVi2oaHZhWtECUqMW8rW0Y7+EUymx0gVaQHtsUgSaAppJpCXvTN+YrmKjmlHSKmbEiMIMff4xcAAbj4nmJgv3zKJmwAJfve/z1fY6hsUz513utQBij1+F8A/vkN5Uv0btsnR9psg1ezWzKSFEp6pUV/5S9iCLGKSo9bCVff8SucsfpNTjNN3AdEGCq/UMRYi0Yt0uXBEIfqQRPLHJtJ6StSM+RDzpuFcO6at6UHiIWW2ilipzuweIFLcBl1K3csvDCZ4C5Fz3BWKBK3jdkxjkG7UBP3uxUqnVkmc1gmGtJOizEBwEnSEs1Vj6qW5NJ8/AW6cyVkLTa87UycPLHZFTTiYCbfjtg8apJpTWIrEVOON5idCalJnBa/b24cGjmA2vopnwlUzjP+VKu2882gapRF4KhQzW2/w+l4No6N/Yl/OiwiSBXTHqJ5EddtBYLBsf4luwixN05Ox2YKOKNOkGpbSfZh2Cp4JsX+5Yw5raqT519ETvs+CnwgbieucBxxf4Y/NGtL2VjrDuReY8vFcj31cspXzJCUxHDN8Xn7PTTPfJJsbXFMX2nslI+VyaKqCAGT4n+L+hFGAVxbpUEX65KeEgPVCr9puA3zH2vpPpBs9YaZywIpTzopFd+kvMWO/RTReJJN6Qvv9zAumqIHPMFQkrGgxhesbeTkhRbknJ2fMQM4hdp3bIIKM4PC6hBEqmPuP/5YU0T0sP/YhHB6Mfq2H9ijfnFjEHuF0DSEtWrTmLHP4mLRuJva6wclkKXGp9woVZRSCLYf/NCjvcpZTAdKaMoCerwUEVCheOCyvlBbM6D3GbOX0ACThgX9/amFJ5n2VspoR4DUC9hZggg8Q3/qbvMVgT3W13Pre20JYCDHU3xIlMgb8D+YUjW0Py2VC+rEgrdl1Jb2JaQo548ZAVpqAsNGWLz23BuOcEqphd8tgnU6u57oEazakhB/mzWuX+cebuPI2X6kMWePGA/1vR7mkn7fbb8kEVimvZ+uE7VJsmULK2Z3/g7AOsSxLPL/dSfqRN5ESKXgtpQTOrcYwIoVh+Xejpc5BPI6v+EWTsc085ww4QRcpgDl/ERtabzOrSOmX38cUtWb4c4sm692RjAt8lk/pKO6ZkqK9EzRQH0RrRSLXtrSfaUeBdoPFND8+F/aRtAWcqJj+2GNUrGW8aQn1GQL1S9WfHSACy3vnM8e2YMqy+X8JqMVhI1pdbitK22dTXumqagHeSIM321ltW6DaAs8NQCMV97a7nbN2jesVZK+599sjsYxNeWy6LwiaxUy4ApmwnKCtlDWoZMGssFDOaDmMiOM6y+y3YSpRExYgMMofFVxfukKJieJS5+1VTAcHsa8Q4LQmTPdLogoRYR19yyQrBM1xA+bxXJBj3BdsTPPyPvpMFVkJ01+1VkmFXsTCjVX540NuqLYQsswYA9ZPhDz4j3KOiY8e2rUNhTenWo6pFRzH5K+FrX1tgdBdxGK3vkpKC1z9UzDAS+GYujv7ZWxe7N8okcVDufcB+duQpsCwUvreTjJHHK22j0XtuWP705miG6VfVbaHlv+0mw4whYIE/Q4/QcMrKrccy7sBsXw/kIUwbJqEbJIDTxDqvPx9t2SlsLQtCE2UFZucv41PuLhMeNAZ+El9S9n3TpSCdZhgnXHh8aNg1KCq00AuWGTM0a8FzeP7XrpISzCEaJyEDyJFHv4BE9HpJyE4KFgSYYVhdoZrQJeLI066MyzrFnMtW/wHTAmQEkhwJxCw21NOXZu/VkUDVK5+1ZndDwa7G9BYeRt8tg3sOhrVPEsMKJY0c5qnFtUuwONZuWk+tlePABWtylc0Wg0Z5zyqYBpclukV99RqFffYzy5v7BsQsVsmH38V6+f5qh8RBitz3FxD2uHtPa9h9Sg7+6honyfH3bjniKUcHk+l4z7INQUYsn/1AJ2edSmLU9y4RTvQGzySHSdo+pJdQGdpRa1YH6/b6GWqeQtfAE6yhwgtjhJ7+/4ynW9tczS+b2YfZ6VR4zYdTbqlzO7OQkOFEhCF58AKeEZcYrTXXPL/c4ofsJN02V6SBI0+771ABaHrCfiV3qeyf8hRsdivC98PVRCS3yBeJE9SE1SkK4Xb+dmkYZzdOoCkPi1n7E4Y2Z+heIXhQv0ApDB1EoN8e3aTgn5ufYdpof+aiGrsbgThW3K91FJiadXU3mKJeyik/EJGK3z2fw65Me4PoBpEFyKuxreoHSeKS4C+6V6/TvBUuUvasjxsJxT8NeVwerH4tiYiYjadwJSPQYoi9A+MYFxrJjjEKn0BLDXmnWDqVMm3apO0Fm5bvzCKNlXFDsAIgOzq4jaqU0Xdar8q7xGhI/rv/qPDjhp9MjAOBs98XtC+trLvVcNqcpuSB+YwkapI5/FsXpHX79wz5NnEb0xo9cH6f2xdNdCFX/4E6oCskoQzCzHBFNyDjQHw9f8eP/MT1/ICFwvJlh35VAwaHoD8yZvSZCBkVO9QIGZdehbDbspMVGPMjzYk9N1sjWveaqQa5Ji3Ue4FbJIo0w8egLeewk5OMVnX+z1ydyCpbCrSgJ5M6A1u6R6zTIQaz2dLY5na3G0ZzNe+UIf16hlr31y2Zb6rWZHRHWo/WqPXvAAzRJ88aMUXRFjTSfVFsZ/cpkJqs7ghrJoPGOobyLHFTlhikrMu0LpbqR8DGP5XBZB6+nf3TfQvudSUh7Cqsh4ek+cPhKaEuE5NDR/lqjLFx6K/oPJCKjkjhy465UATFGoZGtXDBMtJxPITeGmhQI+RarXJ6dREljZ1Yvmq1rJZ9VJocV4opElsDYJHbYnRG9kycgb4BQZOMSjyTmUgjZNwGJLLRpnJk+uPPVTdp09vJAVJ/20p1vAnHLvwZhrOagSvbydCbn275BHal3kP1tnl+a6Wrw4kpkOKioPkPSgliO57ItW+mnNEyqjpYUrsh5CbNuappaL5XPDubM3xXRsI+vmqpP/Uy9BLdEQSNKuEgmOKVvFtaMNZ4TV2Wz7yCYMShMhNldMr02FJwEcSK28OOPTrTn6rqip8WN0+R1vJ2kzWtR42k05G+nCmpZLCl1ldOhqeMzaNAx0BlUfOBydFYGKGdvh1X7SiqRuslpScaVbWbt2ezr2wSWVx/T+dKY+scB+z+fQmwHfDlAKccwxmNL9DBHALh3n50Y650aU/9HECKwchPspZPqPI0BKndNSNNYYc6OL41axq/fV1RKEAOHVjgwGJQL7/VwGAiTCztTpYw3zHtyNFNf1C3fm2QHQRCtomMLLU7s0rk4zfY0J2iBQfMzlJyDyyToDyLiP/X05f27JJISc90LM8rZvxRSGalCeGAAkpajWNM3xCh3OkecyiLZ3awA1E3f+aeZHRRLwNXButeMqQsESRgADHlhhWzCVSQ1wO4BstIq0Ei9HBrZAuaGZIHKgVN3y/Gev86nV/ujyh63uZ8kI7TKfCHveXk8AXz+gmIMFlxHoKWfI5h+dVxaRQnqCkkHP17xl3aV11bBVFJ1BaLLEcBJvpTW+rzwQlwsYhILWncGHZzn+U+0gBOnLU24Ohjf1rshUCY+BBFDSoHOz3sGbOW8e5UOnzRnjZvZovrY2YPpX6MbqsyRE0S5hbDq/7bjxi7ZNJ2oGzeZ1Nx9aiEFyBgG1LMpp5dIqx8J24oiUKDoQZ24f9auShP8qPQgWQtMCax3fmAR6JEFsMFKEVOAyzwAaHocXBMsEw6jvRCy/z9yb8Oo6a6GLqOihX7Lpea3tpmqbv77X42fD5AV3qz7nmOZ541scjst9G6VlTCggS2iMUhCvJqKmJtvTPIaLCA1Eb/Medj0KuA7Ayjd5PncRHptCdcWgQHwl+VA2Eu7VfWcrRET94jYDdeYInjE49aju2Icuq7jeqdpnq9AXnVwwg4lZC7rYJ7CV4r6yY5/T0n83A7feNC9ip0kuxSmGjJjmugSSPPDf8kKqfnW7JDxZzVvBhadE9sgCpYzPfNwBnhe70btgFxLbVlt+FgoYLtePV7dqwvGZAxrctEmri9NQ1wzsWeqqB4PAWyIFRJJJE+JOBrJZHhss3qjh3dassj4YxORIhWRskzOS0ZvGBVi5UvJz1uSq/MEP0G5DmxxENcnsfdXqczl6W+oqgEBzhgUTYGzDfx/lDVwFtAuUW5+AB+TjVM5RFZOp+CQ41it/RruACih9ccFGmsg+vfLEonyeVRt6oe2nEoVzZ87p+0OhJOAOaZqOusZwJ3jTWHXS06+gEZj/KoDlWnk+xRV9PZTluaYWJZyjsnraHEfSveuv68BTx1+7HIK7xSpNabzepTKO63ZJQ4jd4/iRKqUu7lGMOOR8m54DTfU2dnk6iK1tTEKenoSV/hUwgb8hqvJFSsVCHIX4Ec4hG8Mcu+V1EnjFcIYPPA5B1fF29uSVwnQRZ1KmhKtnqMn6WY9dD0DkLGGdvI7Z1TqxNxQwbRZnReuhlwgDKi5AT5FAydosvKMmMrJcPbtZAgj1VJ/Yh8RZsGjTLX4YQrbD8NhyI6OhSt8Gz/7iOHtHZe1Q85LKNzvJDljNUfwbTuqrGhVdEBKitJc84wwwFTVN6GAbd5jxL/UUUfKH4QvnaZP1lFZngY08GE+8staSAkPckMXfi+cAwubIJELmYsBjQ9wxZHGsXYMw237/45erPNG6Ojca+qH1a3UNlNqlcLml2PK3Aj9Dp93rBKeWyIYLXBpms68+6TAfhQnWn57JknwwHdTmzkFm3rK1TCklLmO0DOlHUPHVx9ewoAM/h1Cn3La7NRFqbNvd4hKX9DC47m8m65yykrNcSQpxojJoZkdS4gewHdNayCfF5Qpb22v7mfkk4gYQ6ze3HQSk1w9qYGD1kjshS7iuGaO8aKk8qaofGLFbE2vxro9e+P8R+zBfWG/KoyUuftzsWOXb/IPVHzfZo9gHIggpwWsGEcHcET7S1QgR2+iM+ZMWF4ZE8oMwf2huzx0ZZLyhRfTGRYn/zkFRwN/srqkwGxVeYSS9wYGLzNi0fiElpuZUxjHVdpZCGj3ygzAX7v6FSg7nn8zuFRQdRv6MIGTq/61OjGnZiiMamH5iZwybI6JWSi8wlDH7fxzhGCjmFyvtDZ70rEetTGFrQJx8oGV9HL7U6W023UH773zzMjBBWG0rSn5sr3paliU+neOKu3lpDDaI8Jeu7b0m2Xm9Xuc8oeXSzeswuwbM8EgeDelVudTTe9JaO/IwFScpj+MNS6oZOHdvveMWuhnxzManPUXx6AFiz1+q4vti9YIthHAF34PvLYRSL92WGa7V9AvUDon7vaNkRcmm8mlaTvCe/mPFYQfufYW8yojXRGgrlMyfC82XMdeWMbjGf14FuyhSqnuZpXZ/KFLpOF+/KCxsww5Far52Z3HeIbyRGHh2M5EhbWghQtftFQUVUGkVmLYOalFvUoYIT2DeobfJd0eMZsqzCU2lSXc9xZC++M1UjiqRNFHWl1lHIVGu0By+AN0seNZZzuojJ5Yrfr86DvdGg2PDQW6aGsdQAYEpyeQ0V5kHOZ1KeLycBaCVyHM4meYkJ+BtsvWdHN/cyVZh0FCbvDzUQkJ4xdrgyxptZlaSEShqjeHCKsb5vnPm55S0YSYKZ2T/YSCcLvyqhs9XdZ9P0OcjsgDWBdGaNnYc988Q4fv9DHxOQjevuaNaGS4dmO2HfBnfiUAVIyAIiQC5Yx0E6itaBPQY+z/Mw/32zeEWimJGzpjvl9WCj96PhPJZY6IkviIzcqeTjjWSbhHk/K7hxpx5hwjiXWFEdqNRYjqd2rvZIMnLy4L7qHxBrN9keaI9fnrfREGJdEjt9Ob5umv4DU9A3jr0GBaNPTMQuPpFZ/ySWkNpFVypLYH1jY2oAOflm3kNqfkH/VQIqmXh3VoTzCE+pIfjX7CXduZhaNxasLqMOGp2pXS+mlWgxeJt9TemDurSLkSL719QlJ2Bt51dhfBG5K5acaJI6vP5d0ZmnvuFEbHDayEuslpyEnXHRKTJ2XUmpO2O+0KLHrUqjCnPB0QPu+b12h1RfdHAmtCWI3vzR+MPRoi9fbB6MQYuIdB3DYeiZh6tnAr2GJ6R92c22QeuOTOMvknZcLCGT1xeht3l26BRXvN07pX29lX8eN04WOzqlWyfh03Mw+ep/HmaBIL5aeKdYBmWRLUYLpspuYmbovtCnekbx5zdfrvM0b9axJwaK6eYCMobJ6YowE9cRXi8hlst87ONKm63d4H41iLfUeYJsa55zvafUMZy+6ZQpoHEzaqe67CGVKqbaWIN1LmUiE6vss6gK6/pN9zXrE+YZYwgHydQon2gLbDIH4ybyYl7Gy36LasGu4E4AkTixf1bPkuxYvmmhZvPTBRMnKSMrzPil1VsouJif2+ZvAPle4f0EpcSmmnNUQcDWWlLh6AMGZPrJ/JHLsWBJUJzrl4Wm4BEjC2ZyGTyKjF1mnBliWIsUSaDideV172HNCJNNrN7+VMgWZLphCUEFrb19NyJI+uZFxjoRp9vDfL9EVOzjvtk23/OIoS1pJjjeYePbO8OzXwhAuPtCoROg5gcOMRqQzNN55hrgV9DEJXXBhbMDSZK/mt2gT72Ar9zdXdBkOHEezNMtpfNtDFqMZUBQHCHoXBY9OXo+y6PSfLJNy4QpUWEVstFEKaYfGyDsxqjfXiythSJww4FB1CVNSff2AGpFnrK548dW10ioRvFUvJ/f6FqEOxajMohG3RErPVcj6K8sCENFpb0y9pUgS8TrthQ0aWSTUhwb9zQWoF+qL2fElBACzqlLAW2WIricjSUHRQOt4oacaPoQl+qDT5DTdjBeMuPPJGqkhV7pKD6AIVVNez1QXdeB1bKvnt2iSk3qyZs4G7PzdrWXTGiN21G2abrDS0OSNLW9dkEQOFJik9t4GQhAKstoMSWlYh8TGFyrt21djtxtzIKmStwFdGo6Jt0WtD/JcrcE8NnNKyhF9mOn9Eg32AaHEeP9KnwwJqvV71gYxeKu96faIuzX/CDuuzxRB4MnFWgzfGJndSLWnQIO+j4aJ3q4oiQ6KuQpx6PMqNuseLHr7oOvfu5+Uarul26e/mqvhrLuZHKXiCP5Nl2S1eeg2zD8BF6FgFDuhwV9rM92gsVLvWk9MY5MAbRHCGAPnLE2nWN7lvQo5HkNEIxPdERzcepFB9eJhS+Ar1TpU7SSwmA0fQso/p077hV8m9PPtefliR4yJ6oqBrm2Pi1rZTvQXSWREouYCIzyms2A2EESFhIG5IL4YIDAPkhmstd0wfKd9HXtx32zUSNKdr14Sl1Nx9r7I72E4B53Tsc5dGnfZ4vDJEGuVyr9i1XZrI+CO4c3KghiP8/TYfTZuZ8XACCA1j4QKa7+XtlWzBhdTZ1Pg1W1yQTYxqTzDIrj7B1daxL4bgyYzCKfDUgDiungYRu8LsZ5TURW99mZPiNoGipCNqg8c6B3wzrxIrAueZdM5eoXyJrdTi5w0mXjhyaPVyxvNSTlqEewpuBjtZ7iB7KlLkfU+UBR9hrgqVDAXUZvkUiXDBToYopErDqTGBpTkv+jxMNHnTcL0tVA7qwHoMIdwYUkQldJRE+OvXPFqbBHgVZb3WLQeoGqSz865C132UXdnbkex8AKulFCnC+/JZh+Y/vJOKB+J2Mouu+wbzjD6GNz87sWlE7IahJ3clNXdlYj7EO3yOg3Gp+HwJX6ZAvrcZXFGF0JDIHEYYUocOCf6H383Gh6uuxSzL7B8JhdixK7zxzVGmLzDE5cpUDG75Fr+laosh2JGESMl0TLOfmWfnXDz4yGjiSwXlL2vmWFJ8TbLcjwJW3cG+b0WxTFnLnjDKDcHMXoM4wlfcaQY0CJtsvoHrBsR3P42QJWarc9rlqFkyVBa0FoM8R9SStjs1ukU0NZ5Fm5TwtcenWeIjIB6vv46zAuG+yrGHsHwRmJ4tWbuyc+qiiyIuSs+GrQW3QMGExhh47PL91twpCPUCp35ml1SZ57/1ZY7bZ+NZcMCnr6n18OmDkz2o2KvxVdNmX1Fs7QtGkBgqsnA2y/j0zoMxqRokEe22dVfD22mD9CzA/qB124aZ9Q90AJOAYWwi96BPR0FyN4TjobxIm3KXWHbekOq9eOjDhTQlz8N6nQumBXaS9QBqyzwSrk/7oxBdbZahn1M2ch0/BD5mUxFTAOx7jSvBtBjdXqXm03n0Y44f8/jEVBy7+i5qboRrCac8fS0rJF2PRZF3/kbpFmD7NJDPHib+sGi5OpgZAhxn5KDFeKWra+NcOcVnzmfoV8k+I9qyhD82kQSq0EESXN6uoWa7//yc9aqxR0xBZIKlWHNvGKL8yU74+P8QumF7IhGcEgIOE4eOU7oSGoO8fUIcjDRTpNLmFrnj3nihs74dnAaso/0LUpAGTZcDnkNItRVpYCR7Q4z0LtLacRS288n87c1oUnO5XhdYas9kHajJRqoJuQqUo80ySt00xQ7t/iAw5nGdTrz5vhEW00sbGKS+xmS7vSPmTDPkLVeJsC31Lado7kN1/0MWA7FOXsynJDQ87yjbm7fsfQcttVmOTgoO7Zu7IuIECmK5GgcLlddjtJhj/1541fIQvtYqqcZxt/LY5fbei1aq8eoKQrhxbOmJ9uHRaiJBZshFrJRxmlHlNQ00Srabyij3ARfVyMuCHv1+ef8yKSO6P0geq9aaURW+fIFNvL3APfqDbQfbihW7whZkGKGyDAnXeS0lj9eHjMbMy+NLndhyFNtncb6mEfQYz8CykdBt/Fd9jTf1rRw/wfqOIVFJPImp/QCgpjBJmLMfUN6bH0CQUvEAt+n6YRMLILqOh3r4kEuc+dPDQ8Ozsd94AnqN5+blG+URqGohmdoz/57A6i67myR+exyKr2sx3UqDQfODYg02q/NWWYmUGbfDBEpWHbo+c7uwBuEXkl2Oc9eqNlnje5DrKeEXFdzmb/b1oKRv0IpdeGZi8j0CI1m1eMPoIT379Kbr1qzdqeZfTv61KALZxBeG3UV/nT5zsscOKKiOvVjhXH+MaDFWOmujUr6olJBSTkGQ0qghObEQcDueg5ka1tXCYEcDuaaA1vHm/kwJgzVzkpQgASF4KlVxnyi90vEKo6lsesZjFfSIv95EzFefbgP6ZPvgnw1dkOxO40Z9vxcndo8ufhu49XQHCYIkukY9P12fxJaYVtr8DrWk7gQzgUo0baSvW698VzYvVjg/8ZL1nRlg2UsKrG4PCkiuK46E2+t1knlfVCHYPK6JzQnVOf41sezoTcw9XU8a1aNEPF3fFZi5bX3IIuntec3n3r7Q/w7ecNxteyaTXEuLrpLG+2Q57KjDnJ3VG5JSlqTdQ5SWYBaxTnx/KvD82osV049ZyR+AbvaLpxpnNhFyajAsHnpMmvDJILgsSz6WZaXrFnrttvIfde3IcOFhp8mxqzXoZF61uYLHNHWsrtl016hNdH+Js+tw7u+zQf/jMHB0XPor7Vp0hEYOanYSeM62/pgG+aiQzyIn5ewaXV0yORSMRWuKQkAYA7nh5oYgxBz4O6latPJgkQ9VVkYBUmsjwkSr4M8OXqat+0RoYBpkM8VIM/aN0aWB4nWxFEGiiGovO5QWWLUaq0YVEiN48beUMc6aWlUCZXTRzXOPl2MPyJEVTPJ0o//NyazxRZl5m6mnSBkjgZh7Nxcr/BT8bTPuD7SHJ5bXCnFqCvsED00b53rz6zcF9MJ+EctDZrbof+Q1RXkCQ5oZvl/jKCLDMFzYHsxplz9Osp6ErAY9KXAUY9OFhFPcbxuFpZhn9QTVO/ISWUoQJIW6XEQTchll+CiJNjcUJ3i7klLY9XZLTwIdOngAS6iKSFpZmN3PpI5P44t9C+0R3Ggte0lZq2zvXEoiUXoXlZjTcJ8X52yxgz8hwQ4Ga2gCxF86i9rbEco4M5EfcIqC+uoX6tzprSCNQPdF61Av4DQ/0xYNpQm7fZ9fegNc7TN1mPxiNf4SQVch9osJaBqucPNDa+VncStmanM9iHkwXlEcfcEvgcQZ0OztugQbzAK8wZqQ+Msdn/FD/yqRKo5K9NkUZM8SFryz9D4WPhjEDepnx1ggqCKqqKa9KHju4pDp2VYam0NAMLVFZqvzxQMHFM/nGW9gpejPuAhH7o2qsLAdF/qHVVcvObO+3dgFwKCb89K6r0PDVcuJINqETjbC8kR9IFyGciNBMpIqub6MFSzRJGawYrPoZpiFEd9zIE1/F+HPCd8a2EhbZD+zWj+mJsW/tngLthIV5+it7L8Xdc0aL87FD2dGpkTf3Mpg7ZJdnO73/Xmwj3Vn2diPcG9nENNiYUsfRKIxxlYqV7ZDbFs9G/l3f8YtyRAOk/pDL90EnjSYU0Lh/bM2tO0pkWZlaR/606RrSC/jeOJGHjYnDcLO3oTKrSnbY0oDLG91DHOZvIVYlWvDz5K1jTa1Um6IF8y3TGdgCzo16wl2emv+nxe177/pXksqvVkXQJC354mioVOfma9JxqaS83xqaT0UKOzX++xu+utd9vq2ZECdTm5Z6Or1I+XPH5xCdhJSI5VNWWk0ijHwhpERZxZSWGPKA12CZzKmlXTCwG2jxeJOm8L585R1xm1SEVEU1tAD0/Wljl1vImVYR+BmdJlQ2igoj8qWTwdQchtOFMKDLKz2Mo3YDuCBWnktAePS6bx1bgXDlbbLLnTWjWJ3SHclfNh06d9rTCpHr8GP2RAq/j5yOaBenuMuwa1pcVLmgjVM2TnJsY887f0vZa5zxq17nYCOAoMG24MipZW44HSTkDRJ77AmlRnUDFDbTnI+Or+aGCnVrx4Ku67Fa0So8cgChhPt0TAb5Ps/ZoNR9uYS89ngAPuyUkN+NqVu/CkYmd8Sve2LVHrmhICMpVG0ENoHLcHanfaLatp3HGm/HyR/4yopVWhunuHA9cM+9R0nGxKdY9BCWc1GC+CBWg8gHGiX0x5ZCiomWXQ26NBsU2Lb25hj5hHnneuEvTVwIhI2zYjqczYBuw4se5PddfU1Y+k6cGId/x7FuAjPRT1UcIJ4hsHEv+SS4U34uVMRHaqiYAh3GkBIxlSOhjWaPt+nQsuQTA3qLB5Vm5mjvv3hNwM+DkEe+0g+P7/sD2z8poCYzpNP+wf5YhwLPNb+PyCIuKmxE9JEnEdzwlALVY5sReRhVBJ2xyypIy7IBdoxHotPYliBBxX54a8fd6iM0KwqbutXCaEj4aM4SxFnKiMkHWdFv6nZifqKn2uwbsZiK1xaTqeKUH4HZ1Zcs5a/smiNyPjKYR7L5vUQvFWmBkeZMUdGtAaytFhIu0e3ISjIMCaTxc8gmMHjdt0bWuSOp8PY6o9QZyrdRJIbwNImnhKaaRxnVH1Z/sxFldPRoYyeGpcadjoBXen4YGnWd8A3xlvBE6/UA93ku0N7PbW6yjfwxTKIltq/2gRTmQT2rFmUsj0poxxxvzb5eqeIrL99DgFib4XBtKgPNElBH5D3/FG8y1+j1XgLaO58weGPFuMHLbh7rQAxCAourjU5effmihfx2j0PPk0MgJ2N7Bmzmyk/0UNxQD6CLAozjF8fQZujtXvFmgcyvDH6MXFXvdL0l4pL2vdiESZ4ko/VENJxsvEOm7CssrZtj2XqihvstuRjZ05v4KcbC1x8mqz6I4TJaqyPJQsyEopBsKiI0wTJj/uBDiDFsiW6BaElbSBhfD/yVMxij3SNQr6XRieIgRQjv7CLCoCSI/r3+DcRSUdMK/D49bmoYd1beoiVUk5gy6jeewJn6lOHniBVqsBp3l+byiE0vjLw+mV6SCzxgx5v44Fif8KA1UDXsVBVOkWTEYapR+f5g/r2+AJ43JrZ6TGwO6IufLXp78V3N6m1vJfLcqpnEceGRMqnV4C5JssIx7CFzxMSKOInqOHlOR3H6KnE10tykMdnd2wPJ7e6duFpM9buGv6RI8uTvNk4kkHNdAv1ZjT+PqyBnSb6MIAQFxFdzimfCqTnSXRfp30aGh1mEYNBkdrd+CV70mYS1zic/Zj7yJanJ4GcWa61hdVoqaYY9jAvwYpy9L1DDiYACjBwW47m6ZHs44vqYISSAfyilue4vbCvmbQKdVWrKX/RRag5PsQ1xDMKD2lpN084LIupwY0VADACxo7yNrO9LC1PUkjJSTyAwS7CGls7xo1X6+C9uH0HFizy4mm5DBj+EYluV6kDZfPrE4kXCaL598R6OV2Mimsx+gETNeVAjy+5rZ6D/bMhCHzTwsxbNYubDrKPeSxRVT2z0hLiSReK+VELP9OFdT0qtbGIrDg1ChiKP8Wz2Kg8Mni6Cjghj4gL0+HG50Enhn8JMC10Tyq2C4AVXBL2qVQb74oL2J3VsK1GJkDkGnbIzFNN9V9zXZi+/Za678GsfVLVe6tLR32PhL7CcuhnxLR0AVN3s2ZF7WF3fvzDYjbw23Lw51VfcXrtmd1+rUGrP9eB8HyV8DAUJYAxf6AH22JIJnLX0U4jm13z6tI8+cCbJtD5SEy+0tF6UH3bDNLvuQAu3ymcSakp2C6ggwPMP6i53oVxPUs45q6KeJ3k47mDvkK/bxRhj6FFF2hirWFpdkAvJ8IwTCAvKsIoUWvF1xo7fPYsAyxZhAR0lX78qiLM65shM8ZcBHGxOGI4nZkceslBzh5apkAGtwpKP20fzJIoNzfwKJ1cZbl7WI5tpoYfocSfPGg3R/ApqcfX3OcQHxJ/qDFhOBXGvAxumdfFsK4FY9hfmSzINbeCVK6wVcTSLYNGuOwLmW1d5CQzKR0a3IAHHMDhtVhc62tkMO+9eMMDIAW8+hbB4Fs8vc/yIi3E1w4sZ+sOSq6kgrU5HtrCQIAFCJA/wqfMHYdDMwojpNRje/7hYIll4lEq8gtoNcvakINqP3rYv0//ahXBLwrpOQ6WGIeUozFIQhomVukboMPaWGCrzPg6lWlrIdEjuiqDgckaOBUkFvleqL9+RI3ZjordCH/7kY33Tc0H8/y82KbyuwMA5ysZY/dJ/CdkULm5AsvRFiD1svaFIpFaVXAPzz524Faf66ZyFESlwNe/HRR1JKSdCuM4KKlunSdEvoTAlGEMkNoLD6ICXSpBC2L+98Aa9wkU+jCtbuSscoeT2BMKJ2UZZwP0fQDM6tYx8aWLkU56evv1MHBM77EDd2dNBY63rkRT3QRMuGEdFIXK4cNox1FHheUU5LD8QXRmUcgRAelPRYr9SX1BzOmSvXv1iXqresDoQ3vI/G54iD93LB6XKyOq528zVlcN2QDnDXZ4StP/0wG+nimH/TNmpJpiZUNVK4tnkh8Jz55WPGHpYy0jdYLw01NRS+Amv2qTrgG2hZqPDIEapyU4L8xsbhuzYETqDwcJ33A3JAnvzND4aOT5YvPK5FRZfGEx9OWWabmb1rqS/tXYZRtqdOoLT74sCZuVZnnyXKfPKahQHb9x0mkDkA6vy+vYq5DAo7Cp6doboGfRlF72sCHgESe5eeyrKWuaBPsZdr3+IlFiu2Eh5y3TAXFskrxtDAaBhFXfWxMEticOO7gfih8rWjiv017F7oicdiCXoX773syyBCV+UWcLS8mnuFmsgAnleFwNFI6xJFbacGy5Bujs2eEUFcTuquYNWFXt9eRXAamisLEu++Jus1M3nxuU8btCG34YYBChSzeDvT3M5uA6zAZRdr2yqYbysup45GKsB0RLO2RC5R7dy2Zrc8g6JO5HyoPKdgtR7EUAjqzhsTqUan7fsnXiNnCBn3cEFO9IQXlFPl1Z+bnBM+qu84MTjBBmfpKOAT3S9yJiig9TNZ2Ln5347vjZqGIELvYO10wh6onbZYrZlNkc8tbnmnsPnrdHJtcwIL4lbKiNqStaoJW5A+senUbIFLPvPtnWB0NpGpSQcn4evdPmurTiWc0eZgnK7EC/Za7XcpDwGtbNea3NfR6G42NDW2Aav/laISYPIygBcKcC5F6NoQEhFFxaXLCu/k0jJ4/qAkVn3XFs3Mdk9jAI2FjHnXzYPRDBCD/4di7w52vTA3PNW0dDBcT3npPezdYupq4qDJBYgjF6FnQbb2RJl6+mdhL+eHABWd8BAXA/dtKDZcn8Xi3+eKgLJbXq1VW4eKzpspKXR2UYebrscdMuWyf0afl3+M+QAHGhXleewcu9UIDZjvL/SktfKhGdM16iOWR9NwZm99iJWPpnGAD+R5m+i1TBwVNy9m3qczw8hgccuMSEaSk6EIc+3NkxwGfMIeroe0pdmZNLBLAh/X4v8srnOs7aB3qx97/ZlbCgGfJZ3yaaKZvumFbN3Cxe9TljqOybw+VPE9CSeJjfx1hEDg5AAFoeMjtLiztumYNImgQjK/BFzpMTbYvUovbZ5X8TdkvoU1WzyRYdbv0O1W1R2UaRhJLGQyQ3iE4E1bxrNNeSw6k/bHxdppPMhLzYAVgao0vbPGSrGkS8Eq+zOlMd9EF9CEIt3NtgdHRvPzuu/1gW7qkGXWISdcRXYEdnB3Ozt9ZdSQPLXlekF9aO3nDpKeg5OAtp7kcVsRoMWfJlwfYbyznRjA/rUO4onSVrmmTYQiU7kWaD+4wuDUXf1Knc2U7hXv+43koaRgslpDutIQ/3Gl80C8Dx5PDrvdwHiOjUF5d5KlB+rJFSCsKxIkCus+Kh7njtnvmuxMxVX/eL6JGTQD8St8OT+d5tvhuvOqhYm+iT7eOO0SAyuT+0nHhTCIm7FmQkQDvS8hpEWK9tnMxFbI7im3iD90bxD8fWMD9mc/bro+VLYRdB9wM7Un+5+Jr/Jfq+n3862gqJUoS8RFPfkv/kZ/DgV0AzjORfCHwRGLuKhzeDlPJcQ9zeZN48YoFKgVW9ysQO5mCn54Bk1y1ZcCkTS2GgMTo8xLk4wv0H5aHsrE4YtDSOF5ZiI5rLMyv9dyAozBxBFAldPgWvDA5kkdmPJiT5iz5ik5blP9rjkJyR3veUkR88OBLzA6KOjPzHy8+08vfbToDLG34uyzAOPNoQ8A0UQBCKMBBna+F0xGJjEG6kr7RhYbw40ncw1b292bzOuz+vqGGZIzvKS0Tqb2kKOvBQkukmGhl/fS9oLiFosN3nRStk0s7z4tHrHXcw4/HHdFYWcrD7OrU39q/ozRcJ3sP1+C9PfiP8SCQIgZsaQakJ+AIyt0d1DrFIdWY69aWWSvbGCAt3sYQIgQOIPYCFFiNExKEg/Eu039ObcFgJyzuXqMn5abwsbK6r/uEvpEK81YF2tufaVvWK7aEDGRK/lmMWRP4XzITr7gFM/XksYDCzG3zHuHnBNuffIZBNBfwVIlfkPoCc/pyaparY25JwINeMN3xRvNCWHfwNY2wSMmVt6+UILwsZ0cyha2kfC8rSVY0SwKCw2ZTNb5Z7r3/5zCesWr0fw5lA8dp9FGWEx114ji6c2WOmhsrPA/RDIpPbUpjGDITxB40TwqBLi0RyyKzzm5GpEif9ihtTt0UVqbAVtS1s9yvWwdlFZA/3xlZND62LLS3smpte61As07NaGij9JaZIIa+8A6Lm+nxB7iXw3w4HjiCV80V2RdaIcnu121zdCuufNCe6ZkHaHON1/3hp6MnJjAzhtTSbeUCiHyV94tjLu5fNFVnptUwb9r8jEwzWAbQaQFTiOOzFpjzvIEAswu/iIqTRjhdJvIKknL5hwYGgIpjex9ylWydXsFIz+cIbjyY+7RcVH7kA5lLG0MWGzRkHwq7jytIEkWKQj7Mt6EQK6JZwAoEy0xhKSDAlyVhEpYImMN3m+UfMQF88DO7aRvAaalMH/4stDOLrch+nDVfmMS/kg6hxeX005y6cgtSxphh12NEY9ALVECWJfLlW8Ulnq9ZPXIcZ55eh8KHdgxXSYwS5g6CC5zgMXFcz+nrCG3AUyMVIozOoiyDEZcUx4U6HU0zs9uN3U4kRH0EG6HciQOm1qr7bU2Q3JUcWzi7kKVO8MlZlxlt0y2lzd1O7Vtqwqfob62dyWKZAqIgMz05d1JJeCynOFcp/f1J/5BNDvAOS2dITq1P4qIBFyG87QFQj66YYtEuXpWS7H9D7GLulzQ6YLgQn2WDuNbi2pBVzh+xs2IAJUt/CAcPYgRCIVkvSppWu63mBXs4SNKkxj2s5fD/vk+ZWWREnXOpTUHBLO8JRe33rzfWnk7oQViQ9g5Easx8qBO0FbHzXkVMT4Kt3EgP5Rjb5FXvcv5Y2i0sPGO7hvOespXnZ4THbcSEvCqad5hBjjA4TjUM89hDm1J8dyQFtQd4LVJpfF2iii2mcTJev9o9fvPYstwd7ZIrEKaWvOec93zWA4UFqhQY/RlCvveytquwAAGricBZwnDzCTIqUhFmA4YWOkoAkI/nEYZSrzR3uhj5gHOaXAssrF+91ouKe3PI5Y7+fwc1YPxZTxWuC4hCfEJFlRtVBurCcL3LXPEK9F4sZkkQPA9a/h7rCZTegSfBhZ5eiQbbNhq6dFkjvOgTKS2u+s9+rRzmXpMn3RHHTH8OJxa/9+XIlEjpayRLB9tLqZnZ1SRKF5POVAo/mBQW2dKPtWM7lt+cwJbsf3Ei0EHYSM7ONuzRtMDCiUU8AkYZOlFxk0GxZ7Yp3/F0GOZNAw5VOb3JtyXf40RD6wvXpGoiGj4K18IPEjTIKw2ntKS72/FAyhGEaU7eWcZJtM5D7rrbgQ+MX3l9s/XJAWgoIsRpmC629v3C78SHEwh/YknmHmCbaoulCfPqteBc89dAtrTRQ+5hbGmuj9q5nE1HQL3OczTdDubdlhvxlZI0M/tCTW7aix25P/tRXd7B0Xvp08IIITW1DSajMs+YfgZPfAzUpI7m6jjWBNCEHrrk2JjMde00gygqE1EQclM4Z1y3xQa+Qq1za8obMTfNgYNLJX6vISC/JFaf0JgsB20PZQkWNAmARe6Q0bR7bT6KC+sGWVDImPsAjkp35EuMk7NI+IcLpGUWax285rMHFIG0R33Lq5hKVCtYj7sHYL79YpH0s9B9AeYoT4zStGlDtPoNtkc1VP4TE8yHRs9X5L0xV3MXIoCuffOWQKuIrLQT6rNfc8f5IdO/oSZpQUXGmHU42NsELeTGfw9nGxc2H/VgtQkec6OA6lCuDHskw4Xdb42qDWYNoqnYs1DNkrqub7inzDu3HGuiueSx0vCkcAARKUuXG44nGRGmnql1WjE1zkObY5Js2Y9c3k1hzjAE3DNgg9l4YXaaiT4iQs+y1ifJAIeEmsgpyEcaRizzOe15E1r3hvRqrORSwJpJDqa5RShBFPVrgOkThcJCTINb78PoK5Lnr5bttd9pYhxAktYlVVJegeOi0XzvFCyWtCS9FuwUsqE7aibn+yDFwYl2PnYafcY1TjJy0RVJtBE6pYrent69gjPpiIeYmsBYE2D2o8PXyftmK1MKLpim66IKP0VIpagkkNb0PHNjRxOTyLJFCPuIYJcQswUKtVbmzVx2JQ/Wo4fB79lPStfhdooybk+Xd/vDOOmcc3mpm7vXhnjzWYG7bV1OG1zGlJS11VywizN95Mdlo+Q4h/iTMmtrFi3fqPkYULVsgJi5xeL1sSNf6EKO+/UwWG4U79rWpL1+x/IOXv2qzE5xJU8hT6Cp88yi9JaUtJ1rzyF8jHft1igsOUvoJ+J6mx5kcH61ZKO+GUM8YnsHC3IsN1rYvC9dJ5E4uOrzlunYmF3elws3pfhLW2Fu4i6B6Gg/aD2sWbu6SdlazAZhMgC0n0P3TH0KE2xV5DuP+Wvv5rlIa5+KfXGo+J+n3cjoMQq4W2rNqtv0vlpcr9gHQq531XeoxRmEo1vovN5QYCTSYmaeYaRuz5X02nVBMsoavO1d1GRRQkalqKlSMfuJ2suBxksM8uS7Me/jaEoFOEfVfmUcHut9ciUrt9/CkZdChCl4D1PMVQXi+8HNGLDtPnh+LLqiAzB3UI0QMwdMjpdVnEcgVTQNxYaUtQsMQPa52vGk9kN8cVlRtg1QYcq/j5mdfd6zzFmmVh/nAqeIBitmWj7uUNuuJ92Zss93aMItLypenmfgxH9QEQc8RoBYlQUjvpb3C0RG3LtEzeGrDqs8zkPmnIseXJWSbdMDCTnHhtF+ySrGEFbHCbWzfhtuMtPPlPX4+5grVVugWW3EyNDu+lMIKh07hrxrlsPEBz+c7GnhMreV6ZCVWhcEuZ62rsN/dznM0/g00DQm6zAtiyKSPxZk2aZwYRIbDT2uAx9DCH5oFIscwahFhl05eEcwU0kNYArhwifWaYb7dkoCX72R5AJhWFiSbDDG6SyxkVSLE3KJ35xVoxYILMAbZ2YhlvqnU31h6C+1c/aZdTsBue0J46r3vK5FX9rtxHbbFnZCmVo4DtmNWTBxhMXobFAz8FWdW6vqdu/Tky5nEgUQLOJg3JO2o25IO5nkOpyDlUECj7WAomRL3Svg4PCrZAsYdB0XGBo0uLBIrAm2DKR6RfNMtu2LK+7Rzwx877gR0Nh07ATpeHTQOX8Qb/AHZcQB1Wpgiv+psN8QPGxa9Z/Lcq8ThCNRpffAh7HZoXZtyupmvs9/PbNMVy4mNIO4yzih5LwO4wp4yKk5XycMh72hzEgjWelEVfRUb5MPUr1UG7D87k9loGZ/1k4jhJRsvQxOYBhu/uAZaejdcPZS448DOjECMOrMXN/UZ8qpQAvBaH79HCPALGowRaKbVwDr2X2okQbMP7oPIPPW7oIpst41+F8PqXVANmelrPTVJUkt9sk92t/szWOvYo3Jr9u/mS6Mu7QmO24U3ORN1VS7dkL0gfW4Ec3k1Z51IZC7S4dJZN38pXklxWMBWhQSOnP9aJ7PfwvitivfA2L/q0jjHpCz0f0fhijqY79YgfmyAMULGR4h2N9wvqgmlW3nOsDokEEGdlmaQYCjuxU1UrFtjkVrrKPZXvz5EIdDXesJNIHA+I617b3MilJAakk681Hpdeb5PBsvgusKN3ty7TOk0wQs8iUfR4g9ocNVSw+YeeDSQtryz27ncWsxVq6ZBRloaD85n2iuC7rS/9KEdnWGOH8WfZ4G2qzpQQloRCSuI0wY9MY8qefwAYc5WTS00zWEvjetJEKSA9ejRQleY1mDmdQ5qA9nj2kNyO567I0Y/j2VlKoQABLK40hGPvLjjYS7zz7L9/4Khjws/zf5frkFJsz4IpFf0kG4gCRm6OyXPGnFC8LXEt7YawecqKLfCChBPkWFnvCo2cHBFsxuDaG1prTBF8JjsCoSluigsrs8U8ypkkpY8jBOJZpbpDTct9/wm6UeiLWP5JoNVlr3NlSrRPkMkY76akYcWcP5/645bmKcNso2dt4chMj6ZbasfZ/+N3orzubixz9dh3iGM23Jr4OG1ZquOyBIEuq6GMhJWZGCU0peC7gwBntn4LRy+vJ5F53QunKmqCF9t7sQPY70sqUcvKxMCSnBxObc+X3sN7rMD3yqF6Bp6krN6gc94k6vkdvGEZO8NoAxUtM1COfSCXSVLgqCh8quhZ5D56qDfjyN+m3XC8nHvw7z2v5j/Zi8BcVzb8RmVqbJfDxgAJwLD235bwrtXSmktlKuQ5uGtM6ZO0QKpd4XP+Racx0Bc7SoeNKyepOru/vtxtFOZLeAQn6o2LLikaqRuBrmZPN4fT8szsN4dVzaPRWRG4hwD8Tj9U5MLfTXL4ijLGB6LeOE7fh7i8AmAhAnGz5UPDOfl0/VDaaiqeR+Z3tBE57cPUvdyX/M0gbnnfC4YEjY35gvxT2JcMnLQRroiqHrIA0nel1z+mPnO7ec0S1j2chc1xeh9IeBdQTRo1xJjJzQ3j3V03LTivf+x0LTpS9G8XybJ8DdFmEyfOxHP2U6LhGoFSyAzJnsx0UPgP0v2pyysshlAwTLBYARH9vp6s8z4XR28i/8PME1hS1Gv8OAaLpHsHJvTV29nbwOXFzxs6WgxIbYiLyDrmytulOdwxfD/cLUhNvjpzRfNfOPuGfkx4hY6D3Lx0uUF9oCvkLULEn1ZGtoW3AODR/QeV228h5+7/wT6wdLznX+OHxH4A2Oa697WYKYeDjK5ayi07Ix6jBPWTpJbDFy1DSSiu3lPFoc7dppGQvwCOwy6bExzb8kSopmgQAoBmBgziGY6EDgOXhpuucF/7SFHmIpsVnSVXI+mNSMHoqs7lEPVB8Xrg/EjIqIQNVpB5gBRjzm5N+DrFzMJbvV/swHf8AzcMwH8If6vHuHwMDSpCXbeU9XXltm6fOyj62bMWOr3oCVB4eKUA+NvFx+X6oSkFqo3PhM9kkVDGYjUGYUDkPGREESu9uspclJ6vnbelEBN4pjJW3ETmcdAvNYcPk/cZVOMOJ/P0RrQlzJsllstY0t5ATQx0q5bSJaDGLKRTcfMfUllXlqtDobeRQFlpgC4a3P7LZ3DAnvM6ohG/d8DjOOSAXhgClV7ioEyKA8JiMfNACGem7tZIywdx3GbEdNYiU/lVuyI/EgHFc+6GxCr9j105lRFcd9qWdtLjtc0ertwoNQocjds4VoHrb9w5iAY7NSAoNI/TmFM0lZ57H4uD6Z4LZ72MQB0ImF88m3nDW3yDCl2c7Y+XkKLTDZw3rzgeUfnbJTURWCHhGWBxl7K/2pE/4tjyYfxd3Ra/Q1cF53gXB+XbVaPXxa8cPJdgqKODiX/5a8BZWR4dlz89puPuDdyJyBlDWIDM+S2TCrDYcdfflqrj1akN4p1JBt/hFAG57yYbBsnLf2eHYhK3VrZq6fVKq+wz0hQdtcih4QY4FX2c6iU7GM3lKihNUrz/IKPcxO+LPgfKhKUOheGTP8z5WZZ9+91jS5Bh6/WNUzpvEI5xPK1zga2+bUqkWOIi2bTZKLrG1kH6q0jzBOGLok6Yk1/75x4IOGFDVFiUahkrrQ7CkpjVYhRHCqbRw5SvEK+zgyU8/JpjhOnK3bV05aIjCGtMbmS7sXPb/zaRfhkgJA7/WZC0dKg83fkPP8rM/nUch7BImtKIn2e3aH3tuJRPafdnASzsGInigq+acHJwxLQhZ7CFyJR8xU9RvzjKZ36RZML9NhcF2VDCgC0rUw/wHl1u2zkEAP/gmFAGdsSOINu6nyCVxXvlndehsb8hgMCuYNWQeHy0/2EiLri8JZwnz4smAJfT2v0X+BFaUNIs2HPwWJ5+lv3J81fI5C53BNBtPbybj9pu80g6NtlQqpgC+ijJhEVH2ygyxovn7Hz5muiCqLI6nVrrrXi41lgbdMnzJUOzDOlLfexFZ44kGp42xUaSFZ2QEe9/TfNzWsbFrshF0dxhL06NIxpg9TKCVDdvwK4zJ05ctLnbzFU+MZSKdDYQY2imqbEEYYz+fD0brlGUKMT67psqdu1Eh1frBfr/25mWkIn4ZQNoHOB4B8wpcjChq+pGiEehUs6GrjlHapV2eofkJ3etfObwTT6eidwV2/kmcGxtUit4gH80YfjFUwNriskyN9Pu/3zA2YEnH7rwpkXht6UJPYRGSWsbjK/1p4WV4X5Kx3tfECTTOlieMPcnVNgxJPD5Lk/9/ZvtD6CBQL/duVpZeRn7nsSvg1zpbkPuPgarlKjZkhefBBStTpRn4+FwsTTUax/4eJNKP+NShCDNryOZPZvq23Tio8K++g03OgAe0X0VowBYBhw54cUAdYUmjSXY4i4793QeFzYB87oC2IJwYwXPpRB8YN5X9h2Bygo5G/bLvMSljAFN3g4vJg3EVfFbZOHcm7jtqjL3z5fCNrOfZQzuVvOGhMJCzAW7plJMhwCoD5aBWCYCv+8ZoT7W+vBa9zifSYNw8XNjRR12bkgeDgZ7W3e6Lt+mz9un5uyuPw0H/avuuSvQCbqA5Bs1YHpL0QKhrluqqrZu5RD9kTI5RJZ+1Kpc8PG6Z4tH051fl7pZQVSNTm8J7kjKwzb3GjGDZqkLJ13mbHizX082lmfUi50uwlAiaTSB/mIe247zn5U2PnMZnVKoQNW4wXn4WEo2SIM9gp1b20lugbLXl5WRxHj17kEBwzzPJ8ShtTNBkCbJgUUIjo8+7nx6nmD7KlzZE4Paqamdp32AP9vLYgAhBPqEi7WNjc6OgqIZk5Xizw1VGcHgFeVMfv81b6oECOQklnQSUsjHHXdMfWI7Pyqt76eRyDmWLdAajI4K29cQmbnjx6zjFlJbdLe+Eqt1lmZFq8B9/3kVDsyQ8khq7d/f7pgBu6m2B1DvrqYtXxW56iLiAqqLXp9OMJhKL+R1jTS/gSEC0xUb4tQ5MLdYLV2Q2lkL/omQxG3DhP4qn+1xofJJgRjH6Bc1AYv+zB+YiKhCTOyaa0JZZykldyuH7+ylbAtwBphxVsVLA3xfsGQeM9MByGtzGLCJMNgXb4UdsHwnwLIjzZARBXE6CzQl0VHo/L50ZliOdKsEL9xOp6LVku64d+l3FtVNwuCj5t+Y7iVtzHNjgQfh20vpiB1QTI8vyNZOYsRNKPHAxd6Uw+F/bKDBk093r3DsMNUa0tfsFJZDZ5QVw/kv59OEJUN8fWf+1P29u68FiT2qb6IrihkO1XIpF7cpl91tUNcdUDHINw3Z8NB0Rrc1X3ViU+qbcV3k94ltz8e4/hjWufwhWwtGuWAlXtlEMq16RaPWiG+kBwUCwevIeIbAm1r3Kp2/gz0unXX8bsxLvWmsbG2djEj7r/6NlfLDACpT978JaINWdn1ImUFt9TQel6C3vckMu0D0bTzwV6XYQlxdWOKgWPAPNMUAAVfcM6twbGrN66H96sPwNOFHwzoX71UD4MPlm+v6owfLoi7cGv9yVKCTiN8wFl4vNh1kDTHgd5TdnwsVkf7NQEZlysYqIjzQIDG7Bd9u7ewvKwdOXCWb0Wlds6CDykiqHm5quTCicZlAeQDTyp5xXV4bOGzs7sAKZrZvDQ8AxznkjVzLhLH1fJI9GmOKXk3v8xVZ2d3QOZVdBPWxHy/gyxuVxf9NMnJ0iEPAO32LctDpWH+DcYkmGC4/h/Qc9UOQOvYGvRnj3/sPwt/GJ5OOUJN01B+iTxZ3F+O/Z49/KJq/QnZVy/7efUbZYz0UBqwp7ogBH8QK+azN0WejGv3SeWFZMm21mlAN53IkGrnv9XqHAya6yu6f2ptwlsQFqGP+sLP3tg6nZX+5x/ZYG83BMmx4IiUL27u0RR/2xUGP+qybcZl8TRXIerlw831riV6hSVtTpCwCernQKlqFZJp7H3PlLXS60hLr/adL/+DX6yTc6+YUYPewM1XaebSWUL6NQ/kx1ID3FKU8P+sFPxrCAeoyd9SIQj5ogrdqAwvXRRl1iB4O6N2C/PnnHWcc63ctehSaAq77E+ZrnTm4f9HMPfL4Le2/pxsKCu56GelUbsg6k1Fw8bkcJw+9wC037fMzMMl6pAbCqddiW0Aqk3R/jHmvVqpuhzugr24njl5feu2XuVrBvWrUz+y4ZwGQ3hHdVunvjRWBkzgTqChUhwxRrL5o7Khai1EAwC1wQkCXVRw479FSPnEFFj0ngz/aAMeJmxsQ0P8lPfih6HKrBq2rfCBfyXtSpiK5RoVz6whBm1/m0aKtGAp2/uvW7ItFzucr1olkfY+KSCAI06at7pLplmnNbdfYN+YNH/aLreNMuR8nVwLWZmHjKZyo76/4PC3ICYla82dDIQdNIhHMVTGrYAm1dHYiriSQPYD7sZc8xrWA+A2Ahoj3YPooceBeDpWrhxZRvJwC/akB3D9ZD4H/kRauEwWT9wjInAjggPCk2wuD7h4zd5Kjq6gPZvPgCOGUo5pGdblxx67RP/eOIfMXUNDNlVsnA/UbUAskdu7tSoCuHGSxjMr8s0/EXGDNwx3hlkbAFzxpX5EH8TuN/Luk2fZfTmrv2hSIC5TI5E05Xl0Fr9eT8YyHv2QdHTAvntD8YRhsSwE7Wip7t/KutHm8+Ijz3Y+p4GJYjKmiUQEHV+Tvj5F0fBbh4CGz5XqYzF01sqyxsXDX7ZWVVNO2zckuiANJnzI32LXsV5Zt7A437RwzlxnMtg78ov2RygwQ991W78CZzARvT7LTX9N+pozdFW3khQPvQf1ERnli07h55lj1CEhd02DIrG6JCkj/l0fzXtObn6PwKClfty6TyRKNDtboltXECOEkShgOeQP2pUPRgMg2bGz7tVv+q+P92TpgCztVYIurPLq3n1a+cRlezF+o1ifLJVlm4eIPRey1UB7t3XsH7HPgXRB5zG3P6kT4AfhKE9xxGo0AVBmbJTjFK7nDzze5FD65M9wiflb9w4UBIb6ahI2a7aJbOegehILxDnm97ULntneHQvXTUe+4asCZdpcXeS1OKNa3TsA/EsE9kqxs3/Ztq06bDnj4/K16Fe/D4Z3NwP5MI/Gnq7ge3FwTqYuKUGp/3qj5epanI1ezDNEhTqXdsqlLMAvHTf9Fejno4HpHhj5SXXml0i5JZQ+hpiIY3XbGzRaiGfK+ccii/tiI5PJ5c7uqYB/9zCgOqEy4xRveMs8qzb0OgGsukjt2K2SXSIjuavonG+ohfHbIG1fM8tIFn4L4o6nUQoVixrynoYBAI75SK6u80UAW2JFJe1AkDMsKeuZK1TWD9KtBkigWuLSaPsi3YgMYHFVgwK8e6YHXMUw2ewKwfI+bKK18tKoRWwx3k4hPzEQ2GQz1XDUwQUdiEX/T9sufU4Gg4xfIXPbxRrff0k8uWRixu1dgmuvHdWAdxwa+zXMD+VSjs7E3Bwrf6CbwD/DVCysZUbSmbiBMA0s/qBaGTGTji8uogSzl/KD9/zpHnAFilDjHzFmSiKNQD4/6K6014roooiQakBTfoYMHDPCXs94xfPTExkOsELI1Ux0p8OZ96e8xZE0n9EMM04D53EU42AJ6Hk+OcRNPxP5d8K9yEVCLfKzboZ8LFTnxScjbgjsp3VZNdaDdhVDAtTBM9+pLpSYu+wleHOa6e5kMgKGJ2WbtvqKB01RhcUTljNusa1JFHcIf/hGUE8ivcxmhbp0q+pUg80LMCiB2rKLWhv35LFsEUuNJvEsHTo83Z1O2bOko9aMUjPeHED6Xg4kFazBZTMe6p7H1vk15ocnS9diwydKw2h1JA5XSnRqB44BqnsqVyuzX3tIqMzkmZnwEsv0ROJf7A0t+tvS5QfNy//leUNtgGj8t78VZ49EkcQI8AG58hXWr6MWatZlOplzL/ujLczwChXBKS+OdTYdPf3SDIW9wKy7RQPOoKzi7IZR7lU3F1dWYSUixSNYVFABDDrXXWF7sH4aeRuOwltrb2JNuyCkj2UmQIhxhseOr8Jg0gRQJgYj9DqQaidl1NF8fFf3l1Jty3V/0g4oYf6/nnNKWA2d4AmiBwTze4tXNnmlw9Q3Sh5xxKcB+gIJhE3hFNFSlINhCFgw+iP2QYIVeY92QClV0cL4rciLQU6qXtXKes02kkL+kqH+8mbZ9FqBo3NvMLUqQsVLVyqcuBDhwvn329RuSeNnAD2Dnses38ztsLqrQfQ8hO3g83AYzArkYq4rmb4+eUwH0VJHYaqwdJ+A+tgZ7WiTmSl2DL+j9GETI/b1CQkcO8VBQmAVGT9pnk0KoduWoVRbXw2hnxP+qxRVrIVspko/5BYkPweHnbslXN9Mds7bgfvy8ng+z31sBHjxCWi8UWRsKlR4AFntp5Bcupdy/uRjrzzxdwWFwZ3B8J4m9H/WixyfXzxjHCjCf/enhj7Y+8DO8o8inveUpNuREa/KEz7NvHtVYtZtmVkbd3uN8Xe16wqzSzBrzWAHAp/PiASsPLgRxZ7Xzj7gqaRWf/RdSiOP4mm9/HTSB4SZBkyxbYdbVW3L5yMRprKnOSFG0r3jnPLjK/t8+7MlMeeCWB9Q7otE7iV3dIda5doVUZkIcazgcwgJSt+PJWjHt7BjWfa/Wyj+9FueSshXtpwe3uGzjBh9M5Za0matMwMIi6BDg/BxCB4XxOSSNwo8qVfYKMsMWX1n2SubRGL+1oeYkLJPZPQHpzWFK3FFVTbFUwBP7Ri9zYSOfe4Wsn+X8U1E7G/YUN/zYBhPlUjWWCgbsNt73xH0aspnXH4AJA/+D4U6d1yX4Kh+CsAEXXgTt2/8kCh04RwOm1Vt1DsMNq/tza/g8ftK9VQzk30VsOnPJjI3vvpgnC64pjKeIJVUq5hcWn/TjZLhYa1vlcZ7eiZR7m6YAcw9xaGB9Fsgmc4bkb5DuU3jy0Ll1+PwHjpJWkd/+Vkje84pS4m9K1SXcNXZKWGFm+qfCboezoTRi0LKYLUEgjCwtVBDKIdmbe3FzdlqEkZ1yCC7DRPCqe8nSf0+y9V+DPCvHvoBUmNpql+SepVk/7C6wZFyIeYO6wnT2jwSeB7qIpt10zIh06pqvARn1bBJC1XAOCUEpdQ4EVvB2usgY7PbNAp4VZzWgmtrF1Z2BIIFRE60VutBj90olNOsDQOhxxKkq2hwpEQI8yDx5wTS6T47R2vr7KsalZ9bycCZ8gdCJjznhXS0v3RIxGYA6ATUWz7miusC3HjeaN5mCVfh2Afxv8V41oTbsQdyVvXlJrYc6RLTndsNygd+BCdi5Y7NbWj8Zov4URJH24ptcYl4zKuukOXfa5/OoPfAfdH5dJrEsgDs4LvSyInuM8kQuW6dm8L8AK2b8YjM2g/Yj+xz3OnT36qAVGBuwi3By0ZlmQgdcJ5B3+sK3ZO7uIswxnPP5KBb9Y5f9ODe1G7u8yjktbzPQOtX9ZwTloLxCjRrFkM4ZHfp3OHxWuWXA+rxXJhj18Yh62TUf1s6QvS5pYwaZPeZmPZ9AqENzyitwodCdJwjqq8vwYpxlnN8HXiRpOXwklInOlfZAyWM8Nr1ddll4MZ7akpmKhcKzcYpoAwbV/03fkwnzWUrE8LnYjFejZwJ/Z6SJ0HHWOQwr5BBXPFlbG3vLDqqo2WIxSOoPWg7IffCvck2AU537oYzKBBgpkf0v+i2cbwmor180TkpY4TM2t8IhntZjOWwLxR39qvIIk5qdvjBlopTbKsXe/oxKKx48Q0SyrMqNGbVBsJVVPc/htaf8HGKfNqFw3zgCpwL19sQX94Atf5hVuTPV4qUXY/cUR/bF+kBgFmv8Ot0fQzbn4jrZ5+Ol5VCB/GfiUutqW8DG58usI3xBuGZs9w0HGjoYw3L/OMWWuZFmDPewsKtRuhGx3S0tF6A4eut9ZJz0ttl9UR2susQvBqIDSGhFQvwHM4AfKJfivM7/vSZYcjEf2i5LzUR2PRsdFQjDpLDvhsBgi2tPe5rgRPUA1r/alk4nQiUXl+CFBO8NQZ0Wt3Gwhj86Gj21KQwDkQHkrcgSIads5nCyZwYfRAehTEwbc3qkxsMUP9uvmfM9lzEAoAHzjg8MlAIccnSEd0AEwzp+k78A+AcEZ5BvaDIAlK3AdUGFHZ0fxQDEcpHknhay/KG3mH4snmadY1vaSZ73w8vuzVcH/TERdYCmc2c9Pn/JHYyrcfwa9GjqI6TRizQzDOnDHT6arq1TZUtgST10qJuO7cfIg7Tk9SDD9jcgb3wuIm44UkJarPioZ5+CBTCmxMRW/Ix7x31vQJ1sy58VIbfF++xQeibia+Oe+zrSzV+HyC4EC1ver47gHxHKip4KH99L22t+XNQu8cKCX3vJjxQUL9/poNbq5S9YQqo0yjkRvOzWxzoExzxFwUEd+k0wyip0V1P9XXvUk76qF1+40dXOYy6/flfAXHS+OVsPMi4xfAbdcCaD051Ti43Q5FgyWcip53CwkwidJaxNeUM3AzUabvArKx7yTPGDgTbYJiQ6+YxCNmR0wInT04TGrclczEdo8DPII+QLctVo6d2I5ALE7RzMecRWirK1Kkh6IvqHnYWeSuEO9HcRl/IBwLP80LuFf6jo8HcmrPzH4xpkXxDxJpTBuur/W2wihx0M6GLG6Z/Y+BsBX04rCMkQdX/X86ri0HFgt5KDXdnyMwUHQ//I5bzjG64MXXPlQtC2bOdGeK3SukAy38Cvt38Zc18RgyaG7gB2wamZbIfKH0FJdfWCn+JFts5OwzPjl25f6EZFnL0wpk4F3Z9ZwDjEOAI6tYPp1NL6B9IhV9OVqP0eCXrsVNZ/Dkw8OOf/ws7dfN8zfFQWhvU+Y6/XE23W8C82LDCKn+q5jawvKfcMTCMHth48U31zwKCGaizIa/68SYULNsaHqPXwSp9Da2fD2x0+TNqb3iYkmcE8AI9NVDVQQJTxqjs9//YxyRTdwtGev4tc5phcbpRd+iBwTiMygJrzleRo8ysjigv/uGWkNb9Aj+miEN6G54XB4jnqv6zsyi3b+b/OPRnIDEMG4X+I6qCZDsJHLPZkT6d1uRuBwtwTJFu0a3Ke9m8LTHXFQUkPq5fCp+J3YhJ2fL65JQqcstRPjyr6eLNnmcwC8H65x5/1Vh60kBCADWYAiAZ0n515pxll92bgjieuqF0IInrSrB1nt+a43V4t7EImV4IW4gG7l0gwgh8OKUBU7OrErHVXfForJy9Ct5XD+PKEYS7ksgGqIEMzE0KBEgF6psPQHnW/+2vyssdmo8xqgjRHHIYv/1PmzjNnkISIW3M48v06DwhrYiTZaw6ZtT8Ff9nOObuc4uG7dwc8MHQHnVVWxi2zddfOVJ/KQ4X60Sf0F4LTO4R9/lYXdDjJPfx7KTgw6kvBRa8WFHqwJtofmnJ36oZuz56Fu1AdORwX6d/TPUm1JQ2g/xM5EVQ65kmwZtI/VkELZlOmc8wbiwDUhOCL0Kj7e9rT1Rx05lB27AIrsmb5Cc5EG9Dw3nQcLuVmJzu5RrjkgIGHRfGOw5fZegwmLDT+9CC44ygPC4JxTq811MGTN0J2fRv+/p2U2UtqjhcdWYJD86wEN9TemWJjxpAUC1u7VGQK5jFtftrlaDGrBq9/jCSneWK/E9Y7MoF4WgVPB/NjeIto4dmaqWIZRZsxgtBpq/a+ax+hqXi3iC3bWjClJLzqYxATGxK7/xy16M0c5UvPt6UMy+suE7ceI6KiFzTrUUVSREiBKoSHeBiTJjd7G3kO5z5Z75OSxSgMTz4xrTEaHVxkabBrz8Ueb5+I697XEkPO5lI6Q4Kpnv2VOUZ0jz4v2foSZUtvvDdLZjIU2tP7a/yPc6oWYetj5UEGE6MVPgA2iOoAVfCkxmJVMR5JN/DI7k6+BxdEuhK8IyzbuFPX3HLFqgGJZElTeuC9m2Yf/4k13Qu+sYXc0/TkLS3dbRibIVC1Hysmc+Uf9rFbOSX3IIHLaowruNhuO9sNy7FWTp6IgfceeEz3ixCwKuQP2CwNrS0synVnjRLzgejMIDq+b2IIGUPK/xPfQ9oeti2am6qz2DMJcFejhvBtHgddMDUF6ZbRmMp35KGtV8HS21APuwgHmEmAdTxgIedJHtEE1gsPY1plhWHIj/OcUJjJpulV0LrOKubB2joEO9rnpPSiKf5IOvZVei790wrz0JXKt/+j4cb4cXG6+4l6uuIOezr4f1s1DiWkwJV6+RLgY+KnKttw4sesc/RY3f88/z4avduGblaZQX5uxXwXhu+nz9JHd5FpOZ4YhVJSgb5wSbVDtTajEMjPRdrkrb44mJgRxPuPg8GHJs79X+jT6lviUE1qFQUwFb1H8Wqd51YUNKeMLJ2qPBuB0n0HjTwU5C0z7MTuoj7Cs6vCTsH5DXyYoNo1DM3Wj584Q2xkQD8BrP76XThBR4rIILbzw7/1rrycnlgrLJpX+ycwWozW1fwYvBbFUr6499qP3YGN6ll7XthD5+1pwSKgmAluz7M3cQgcnCA7wRlx6Sl3Y700IxXfOHj0Zo318Jm+Y9FXe9Zrw9+n6Cqud6qj8ZNUTKZZ9vELxB38kRezd6fsN0KSxiddC9NqwtJc+3mGQrlmkI2AvSXtO+hjcB7WTs80GDQpxpgoDmvBQ2zNlwaGCfF0VjiIVJqys8O9+SuG8imSgXI0RJlElGM4jLYQ9Y+ikd/ikaSqS2N/IJhMzyLsukeZAzFqHlZ/6SkWgoM0lon8kCg7lWwCWFxo8tC3DeSwPf1j25A8WgEOAV8FCWQyE102uzdJ6/mLCJaesbV4CSypjY7WYclmHnhI7vwHQp+63k7RZxgbhrA2qi9NxXHrfYqEjZlhNfq1hFYwRwtBKUHybG/RFBwEBoWZpwuFr0J84HHExCnMcqgsK5r7iDPJGiZVmMr0aeUuRHUqvi7EMXMiRaK+FBHCQHfNaH7Daq8u8+rEtDuGnIzV2u9p+2t2P0lVzK0KUYrpzDMVZycY/RDEPjnwd/8Jj42Hfy666o3jO52oZN8QP3GeMqgGLA2DjaBmGFTMbNg3jTix2idIeldxvJg9A+dEypCi9WgCoe3NeCTH5+hhfQz/68szLRFh/fpT6lz1PP3sCf/afC0K/YULWIGCS1T8d/CqVYpQAKqlyE1NJ5arJ3LqUR9ucJ1MhI/GHRf+I1skVh4RIHI3ZRZpPTaTNBu3hf9S1SNLFy4vx1X/8/EtdOCP2dsmzPc2O72L6MFOd773tMGR9wA6T8YjxCXF1ttPbjTnWVg44o66bh+5tDT7pdCwOiwUXnluFiE9A6vV6/LNFUml4BAEnHPuophh1mFIysWIpIZUzz+oAEUsm1TPKhJg3r+SAsDNRLR8mXWMIQZ0usRa6iuyzAyc1LeXp7tLLAdcz9a43rnv6g1/pNJXiLkdK0AakrrXhA/Bur//EsCnGtjnb7YSMGI6bMfieWe/5Q/+8e6c3t+MAg2YRhEiBhS+P0C+mAiws1efRFjM0XudwIkQpLwVujr7qA3/HewZ89pzbXtIosXCAIFIeFg1AT249BKRfvO+DmYhHMRL9CiouqwQdi1KwMCbEnaeyRMik9Xx7VRhFxGxU/Ulk7rgVEeJItkW8QA/PpIrbilNpyA//yVLGKmLYg8VYCjj19qUnFj2Bxl5jfuVhsD77hbxkh8msjjk5l3odYFCeJEKnBi4qryocoL9S7GSGW9+fb6BMX+k1STXGx2doHN7et6+JhQpFgx1uRnKAlC3XUFtBIDfOhKH85NfBw9oz61cP/rjJU57ERZjmEo3UckRdZa9kUale+CKjjh4e/tIQggydCnIGI4SRvHo8l8o4flfnZelS+B0qSR/2tYPnkti30U15tJIZaJ+lAIoZqdjXQYmN8Y8Jx3fqmbkmVT+qfbfTpfG8a+MpXASLJP+PNWWh0hGIwjtUhzrwDSkYtq7b38d3aD9a5BCoxte0xDLCYQJ1CGDBhRedl5QXprXe0hh7XJGgTT4giYYmt9R6VfO3Z4uOQoOEuq0Z+rA+T4K5mMVQnebI7G3H/wO7+lWQe+tYMF6RUtWhESZH/fJtpTc8f0oFdNn+Q6vxH8c66mhbNIyApH2JNEGtQcfeLl8iHxNg3heqCYYXu+1+Nfv+olVbg5nB8ZaxwFwolvUCitflW2yghzjIBTg3x5X4+euHiNNMZsBayf7ZXpW3hu2/USwRL4z9MwqbS90aLFbyXMINFWShT4znzY5j0Xg74fDlyonMBBhPBWPh/sRW63ZODIhaidMhempABURrZjq3JLCaC4yVn64dGtlzG/FUtanS3+v+MrtreaWXXrv4v6WCm0OeevkgtfYIQB/nmPYoPI+1LYbWGh5/mrdpI7cFyTPYQMfG6Hndz2g6nhZtn4RHRC+8T37tF9CcczjcXpcOpanKsMHv9xLsgfl+HgjnYC4RsOYCV2stN1f5MSXbVmd4wK2/Q8hG4QMRtqHxy9D3RRPdC9VuvkBv/Mdw9bOkXt6CNw0ZudqIB5Bo5SP70AFGjUNAzPEn9X6wF1yVlf7Z7lUtdslrTcoxVJD8dU3MhyVi0gki8UceCxm0taV+C+NLnXbB+WzdYSsCnCaOohlvo0mqG4yAOkVkxGMZzyNs7BF3qd0lHp+JlK4FQ/4TqNRkX9bDGtMP2rknQ4r6SRtT5sckpCsy0Rm2zBY6RREdUp+sCnvTh5HJN88YjSjIZe4fbyHteduTtwpqSjGVYxJc4TbWAu+30aWiwDheSRRXUpGs7Dot221chpe5vpqyYTow/qKMszQcMJEc9bH0J7E8yvuBxYq0wBmi5+tqKAf9MPCU7nJMuYFSrZxu25u8eFCpgjzXNeWH34OzbdGDovWBPjC9mzX9yR7w8XnpVsfJobFV12I6slFUfElnf67HOPzhcWe+gySzfZy1Pc9pwP8AdbF1Jd5qRH+PrpQZpCqVlTt5WMluzEym/m7BOKD3ygjyrX6R7eQHkhr1BupH8zoRXDzRWjLifD87HMtYQb5n2j/d9iAfx4j9Q5b/35k7DoGvJFmsYBc4oTlJnAKjcGWEhVeXhYaToXjT4Iy+WB0Eh47Jo1wJ4z/ZQpyLIAkfdEQVkUGpT78soWFgz8IKfMmd6bGwoXKEDHcYDGmsUVxvyCleDFxepC3MxNtQ6At0D7jZujQQutO8laebjHGBMHvGK1F1kqcwZfIpZhBm5zzD0x4Y0n3shrh6H3rw9Yaj6un79q2ymsBwMiPFE9JMjbWz7QoKKOMV2o+aYugAi06cz2t0BLki916wmHHlWkT728nrz9B2gnWvj33iEm/XPsPwbvCDc3RN6B87AnkYCTWOSCsVWZHwmKHwmA5AvaAMtRFmp3w/ChMG6asDnD3MjPNMmYbHg2HNDd/20mcq0TU3QteBmdZoTVPzCQDspKGnecMx2XuWxs+RqiRsNhUibWITTT//ei8x5KUxgIPmtEaOpAr9863skMpVefwDEezLxPeI96a8e6zb6wSr8Ph1WrBtWNF3C73+PlgkI41P8aPm6uD6Z9z3cj/NRpNUzT8u60O5IgjQD/bwpbgoEIBejkxMtIP8HcU7oyNays7XF18F7Bf4BnNwwUg0OiX8doMrbARKayi8Sr5C8FBZtVabbaqh8ZHLuIvEaw7mhj/PyOUJmwXNZC1sp/2Uq19B+vVvf5eX7Jxxk/VcYj55qaa2DFJYc+xSeao464B8va6X2IrwbTp8tp6FyqYTQAnAHE6DI+Wkg34ZfGr6xEisvXagu7filruu40kjVw+Eacf9CSRxKCulvsZYlUgSB4z7ghGftVdobDg3rELsIXDpqtaInKWTOnuVc2Yibp03x/oiUeWShXEuWKvkstxCx4h6HNB7i4rcF2I6JtxQhet4jFmxVTTp5Kr+giBvgaxScrO8CLnacEUQSfgJIMdUeNyZdZ27040NmmZVo1+HMM6V7nQfrlFYS+ttrzcp8UmKSd/mTTTdFA/PXbivprMMHtUiSB+TKxn4vhXeRBEpAE1hQSk2PVylzrKj8uOvFBveCZUVh7NAaxGkjzY1XAmE1EzT1i+YiyTuxIdIazbDsmsPlVH3yzo9j8Ed1QK0nFpW67XevYPk8hI4Mwh7fLCvMuJRyAIVxItX423Qh32MSVAnQ0lxEjvZMNzxSAhHPLbSzSS1pCEIhvujkG71cgHzxuuQhvBdxi+tb41A9s1EYvmATn4dyBe5S0KbxNTzttasMkFpWC4r0wXVpsD+XMsUB2gOhqBiW+C5hckg7spOOsHCm9uWirpcRZrlifqkU+rbnbj+zZ1696hEqJMVyqcXjZi5gSRQd2UHkaUjaFXb6pXDlIHGcsbg28XRIQkiZwAMeW/tv6Oi08PsuZ9rLkuTMkq+z8+EoW+1ToPv4iKMbmoDpHMLn+GgTkWomsV5i3cv7smhKNNpez4PVPC7jUSnqBRMok3hOZI9DypUvDgsZhLcc67C7LPrFTrzn85ZxFwbzgwxBivlNhmv0Th6yy3oKWjPyOf3UYDUq5EUtS4fzBkKcS5JM8gi1+S29/qM73tQpWVSC9KNg0URWusneVhQAKHCIz7zgQSJUnky/hVnVjBYRC8LgjP/3fVt41vUeflxLnnG+BXPKGoyVpc1pdoJl0JOvkTP7xHLbpvSsCBMkdaCJvGDoZypgAet1KMu28mVO/bbkw4fbLp/j4cEtqtNeCVa4WSsb41/BMHqmPoRZvqkHWYEcrvpJNq/JvuV0wdJ4SdcBq7UXTlnBjX58JthoSrDBvqaSGj4Nh5Bm/t0PO96seO8s7xWoaSUjrHS6JVJQso3RE6xHjC8uh3AxDy4Ysm2fOft0kKXU2CPFsDVsXzHP+DHxbCyV6Q9Q9RS1ne4R4XNgHwh5JG9GpdJcWEx8EnVBPLtIVVGc9+Zdqh5mgdH3DnondvBUGCIEciyfeSQ20IhcuvODPvyRW6sFg6SbtB7OyERX4ZQ4EwdUc54Jf2M8jxWPsPgUylmET0zqa0pplhQY88Wd4g3jXOpL5Xj6hZ/ZFPLTjWyx4e713fUEroG9ISs+hY8nRuztLJBEB2FH84DlRs2sYe+eSxEV8zEUUQlocWsuWW2QfTkDK/jVsTm1GNqYGwBmhXF9xs1rpS9X6aL6Rv6s4ViDNU7Dk0PcF3MFXFmvcpt/DDu66sWa80piXTz5lM+47QPMGtDu4S0VqJL+EPR4PIvf17js/rkb0ZPPCtCp4QqpP22cYBPeccf6lT/0m4K02iF1xzjZcQy3WpocptgaOlXzF9OOWwzIoWR4bf+99KMMjKrHMnUd0JUJeRmlFI6eavwt+KYqDFTiI4PZAttgmTViMkgFkVjzFJPYb427mSKRiX46dPLprh8AyENDWu+M2gk51N8VEXsq8Gj+SdH5QnJt//1RzJIiHxNB1k08GK7WaOQ3TmR8dXIQ6Zjp5wFZhZbFf3GRjfCeGjBy1xd13CoCNCQjNY9DkVSW9BxG8EMCtCYOOwZAA9rROTKk1D8Iq20A/1kR33GZ5sg8j1QZf8luCG0czI5FFPUt1Y3R5s3ei+VzGIr5wXgjOJOhFqBelmbmWn+rKJYcI+mSzMOPQ3oeA3DADGf2RhaoMnDHLEvlRc7A0z3h0ceBiSFIeJMCXf2Ar2Y9tsgu7fVJSgthDJ3tRRKqRKagEWvMNM1SMgLvGB/4J/OAkdYA5eqFqn7NsAB1aEx7ATAkQWxVS//wkXqJz7du0wzrkKuTJx4xWtyCEl5Z11HjH5J+71hOAYtG0bKLhLvh5Zn8cOw9rok7l9iU7DLTIqD/taPplqamRl82rN1ivBO0Gr2lOhJdXEJUGrw3T1gt27NYOnuwqus16mz214XoNSGRlDTvMajT9W8cy+XpdW23fPb89uyPuMtevQEGfCdS5MItcyN7253Cg4cMttH3q8nalTDLsP+Ur4wPb5pBChrgOE/OcTNyBtvViwAeGExM6LAc2+d2tHJSy0+saDscKKFR97JuLh5mADjZMcULHzDfoU5JBct82ov5autEny8lpi9CmvwIBlMKWdTBMtWtzhLOoh2gUG8iI1y1+6Hrkomh7l8qJl3ic9v86Go4bbUSIOPEM+J7mfBRL3oviZn09Mp6O2oUKeizonGcUNR9nW2cgZnS/elkAeFsQB/UjrKPXW8LlMj2z/LW5RnYOHa8QYF95P0yScvf0UczMmPvyHQu/fDi54KX1RMxM9337DsVh/qywenuuAXS03LbdznjJKoeyldo8V2sluuM2wrZl5NwJ5pkCZkkwQ+GvLX7+F//XF79QAloPOZbZibduf5dlBrOdFefAl6hYOKITt8hyY+cQ4dNsfKzcKoC6d6nWh/9CrsLcNKvJ0wYr4jjbKBM3EwqQJ88bAqjeoZu0PjTVUyATn63nUvvCew9e9dSTFKVKT2Jp/25FHXGwJX7WwjG/YMw5nSnZk1lfqHxeHDaeDMHBPS6J0FNtvHU6rWgIDSnEvwD1/Vd9jboKoGGXBO7YxMvPqM2FYRBmNWtdSAN60/F4K+iVeR5TAFu6kjvb5ZXWmiaUKV6NZFdv7jcXQC6/W93gkQ90upkmeuOGBm8iNwf+apUKZH8YE40dFbBTKiBh6lvYevY9ws/9zFtSfTnDeNoUV0kDAQgHswZ1kWou/Ox09y1+H2wVdPAjYBiupY7zASn6/BUZMbE/DPJV5bcBWd1+IIVpOm0181qT8Qhyc9o099nQIflVFrsIS9PQivlnxKc2lTXtM1SioXuLd3yquFF5pMxWdTHDzHsyVEv5o17XQrAzKXEhEjoDgfntHTJU9/Nh505HyQJmjKGbEmRJar/TeZiBTNzeQGJwsTFxd9yHzIIaHHmFqrEbWzBGEkoQ+eiDnOzhmSpveCpoWDV+t3EgjR6SVPwwHmHP1FGtZrCLwNBwqOaLamLG7bMdjio+OUCJza56tcstoSAGoU159QGIKMvgAhNdCFWOtD5RvW0YkfD5r08vAYPtK8Lhzrj4xdMWZGRZjB5yRFZa31oYOogLWYlATzHaK/3RBH6lBRG+e1p0CvvFCmWY4mFSpCUpfiTMJScFnvyAOMmZnBjNa77DwQlI1I2qzDB0nvE1oMxiXDG5xLpIAKdAVGhtoq4/YU5hI9XGRoPiVMIWHFHSzVYKYh6/8O6Oj2FxCoF7sdqsCxJ6DFI5JxksKV/QHK28ymBHrFpfOWbrN73F0egxFiyJXCEc1Kb0S5rruQQx7pzGJ2Ro/s6VqlYIEyGRfrOF/mbthZF1AIEtpLhGdvX/oXiaZzZkMm4zgmkWpl88ulZ2HKZaEVsaq8ce9bK/XEo0WFSfeitI1EYXPY6PsSjS7cdrQJHY2JjJjeRuNxVu+7cTUBWvDS/pIUAfcyEwBCPX19gzxKZVwvnqQW/HhbM19DsKI4C3ZA4MqwSLSXFqRisigU0u/FXFbVkI1ZO5qEGHEh2oqhZE/Eep+pXA/7RCK1whOFUKsmza1SxV0hQE561hc7C4iEN+kMtYv5uV8d9WCBeB+paE3qnq8E9v19O8njTkix3pBh6AawiBMPCes6SXDrUY9FolAICMux1LzpZwfEWeh9htWYcbk9FcnXZVOSieGWYx5EyR1eRiBIQAw9fksRjHC1rRWZxBv/3lEcWg14c/dSiR7yDbeu+OL7n4f9urJpfIaud5BVOH2v9sN2Z+PfA5j6YHblCq3caWh56b4T2fDeljbC5keBY3oUYTaVfeFXEq7ZEm5nB/YFPDKF24GIWvIdgnQYUXW95pM9gpcP0cpCVgsISivZVTH52eAN4zgGNq0S1H1gAV4hh2kAXaOBMJsA4nbaoYWPPBDxoQhJopKochtLE8KhhtMKUSe45dYpEUhFacF0ttr25LWBphO3d+vQ8tAbEBNY+gnzAtj0pJpN6ULWoXOdfPv0n9MPMG6epCzo724RRBbSfjDer5a2511wGDm6FiiYwqttcZCZLyXF5wmC3N5/t/TaiMTIy4P8MJJYDtu8kUYAYFRwJUMdst68UoQzUw4MYsVKNOhNIPYkvTu5hb/8lYml1Gi2+HO+7wXf27DQevpyLNuqvoqLrnBzTrCJp6dtOuF77OdRL2Szh+U3g7/2VFIN4fLJ/t+zo1AI8pxQxmfW76LLFYxcW6AqGSdLGGRnpevTbyGiOZa4Z4hBBTuUdnRIM6MPk1ku3qmxdb0GRxA0pWDox6KnUQv4sTztvt2HLy+I1uE/Cxq6cjB4FOK95+86dAS0q+bpNeBPt2w1fqYWOODia2liSrWQaALtJo1tV2F54NBI9xvSl4ZMfSgHT6gVonUQTQxxtCuGAyWC/siomoY25xMJb9fg+rLt+e5QBau/OP9u+iAw6LYRca60brloeAXCbIH+RX4KgaoxUxpBu9Ar4gv5sUlYlLJ8Kn97Dp1zSZpALqiuU1LJ+9f5qRrAYm3uzAe6ms702ys7plcNanbxuxZk4oM1umQggGgRsfQJB0sajQG77PO/uxz3lr6jHbaXuke6Y+dq1XsMWrESJ3qEGFJnWJLihrZ7hXmFsqyaH6ZU3yIfh/YEZnNvhq3yu5xfJ1s+lb0DLr3YUYoW6ToHCVzRtrrCA4UYn9HtKmPa5waHUcIR282ZYunk+4mTxmgZvsL9gMcQ9pDpmVSbct3fD03JndZ8mZH570x1i7y5q6RpBalpkU7QwnNGPLLoLzayiKlUDcKDBWnGzhk86J/dwLkkK7MJMc6Ns1xeYpUHNGNk4i9v/Rk7P8bx8Hqmf99K2y4VWBvdUFVvKuBhQQBjN1W7xRQv1mF5FBLwlDpkdnqD84UzAKAL6kLXzjZ11QX6gb8cNNpwkME1m6gNlqLlcX/D72n18bnQy122m1u1Qz3EkPM3N+txHkXziUpXs/pPbsE/CEDv3f0JZBk2ztDfW25fIfYqQ+Zj/2kf7SB4r9kzSZAyIPmSdURRJGFignr3lCwb30hlJtEPdpmoVD+UaYEkHVLFec1iIE3EjP85WMmMNknmtPZODfwkBRjHp2ClpcDxd/zDe4j8HYYyubprLuAlLqTWcO5YltF2ZU3Ptop2k287OBJuOQjgiSdI1qizQ3Gvnspn/GKoJMuEC6160LPPSiXZ+sYzGz1Z+EnolEz+xLAPZhGdgJLcNpf740ZthMUcmdacFSURWLJnxBsq4JlPXOXL/qyiHMCxIN6nUwDkd8hS6KwFqhGa8TPsedCmYJRWfKvTdO6B2rOJmFhH4V99IQM7EyLC07K0WFWFaLnFHxQmjeqcVQ6w7yu1vFRi6HqLf36BpMu8UKPUY8Z5BRNj7scKOL5x6tjuW6sI9rE6gccpmTc90L2dO6CzX5VTdeaJjaBhvxjnAzVYaibbf5p3FQFDBbGMhT+JC/BSqsXV5X18Hif/6pZOoNrCfy5MhNc2xSmupM+5g1nTGLOgzn9iMa8BGLCwV57mJ3t+DK+C/oYtQQuM2Pw4ps6N/5oyE5Z4oUwXaoj7oizbdHSfRiT1500u+dUUdsTOI0XulZOjKLvlYFSMrSwuJMQTRo8lWHw/ZNJwFJW6pMECGIwSmBZ2cgSIAyLWnr4/iPrEAclmSUf1r9Jakw/BKNscmCa750DDs62IXVMWlgFKJZsEh8vIxUKPkfhqwJLCHmWFaZVfh5/D4l70OMtyAQtVHKdA4tl2lG7n/ubUrA4lnknHBH25qt89oqrgrLcufevEVeWThbuAAztw8vYxM+oKJVtpHvE9E/9O7nmlmsKouivgSwuPnHDdwmWov4CN981bJ/YeYGdcCl0PRH6ySNyiIJIL7iSudrfq4wJ22wXhgDn3cZHVSrfW0RAZIfoNIBhibAt9COUhTbuiXSjbz5ivyuSBoHqZNq9hBNo9mFdhb5ZxcI6KdzytPNi4Hd67XoAtR300hQFki9yCR64bSf1AvfCTT9V1J/HRXJIdNdZS55gNWQDGPr4TBshxbxYFlItlReVs1K460XiWL9TCbqsdynQho2xH/mkJW8zPY+5Y777snM+bhuRxlHvvNBvNHK1LgQX3K7cTgNaSezmsHpeSRhxCipnmxtu73PF+8FDwkZyDOQ88mzhpbqEmlsm97C6+0nv3BpcdbuOQHkd1jLEYt01RicSBV4rkM7p15S7w1Bmbt8k6oFgKkZiyntktafQafQIRAKLPZW8lp7+esbmLYX7kqKBL+NV4TGXaDTOkQgB57Xql+pRBQ7ct0iOEoMuqyT2m405hDDYQ5zeyex9z2S0rMdbwHgFWGDcdqyGAGufQQ91g3Ps50c5rWHmEXf3i8nJs/I30eqVkIFY/otZZ4HfufSIAmAFTcCJE0uCofO361BUX8cfPFP3uxNO2ZDpcyRCSLrwJnLfs7ZNDehTsCFociBcSQTtVQ0tfi9fUkrEjnK8iXLFTTf/qQrjWqRzThNolfjHqB8W6JFM53XZnkuLhalf8Cn44IipFZJnABJxEXBSEP4H09XHbjKvDjLBy8Zrw0Yx6cz2Kw7fpLeQ/LriqqCE/Ug2stV6WQ//tCFisiTPFTI0j6g/zPZLpNEw7+jV5buzO/10S2Q1rfVF2A816WOKeHMuBbYWfXmfyWa8d8qN7MbR6nkNVZ1H/MnWDv+3+iK/STfJqWcN5EJdMGM43HFG/LbYqWPnIYJan0MFvW8ieQrA0+W+9BH2u4VYwGFBG9VRvX7zkB0AVm3ZrZwp8r/ZW7/KVTOrD8Ls6P+qqa5l/XkjRhSKHuWGYuhOGXHRSRsi8Wc4t6nBBBGPl4PXYmfn0kiKeZk8/B7KC/tfwuhuTjPAFPBysUyE2FKUm51bzUNcZGWdfdPTvuMZiBNb7rNLIOK4C0xA159r/Mo0g81uxKaUv86nsIkyrQzu4qpW3eX9eWjOPqAEZ4TwMGfWvsALQg8xv/ud/ESTldQUsiCh/qAd25TCYpw9XjKZHkFVelEevwRL0sTAuKGgDtIwOc2cnVyocO/2eP2SuMxHHUsVCQpOInnC8SgCWO7TdW4224akUo6ZiXy5cuDJnFjSXJ/eIQty2mgDRFcTWSV1BZgpxDBoToqM9j8Tf1KFodQdVegaH+TGWxThYYstRWgECdwP3F7XTqocLztCoCC7V7GHgckDhKkoSytsKQpcsvIlJpB7U8fRCJ7MAf9b3ZRVgbEhG4mLh27MYvcw+VGjNOh9sy1sFYAjWsDgtoNtyhC7ceZcAUUTFE4R60eYuAfNhSwxe8Aq8EVNG3mzHQ69IJPFYJ+/4i84luiHG4whe/bTJa1+/+ocQro3380gT4h8gSGwxvdQagYmnw7MAMrO2kHjiOQEJEAu0ugKpq6+AkxTvnF5iGJu+RR72BSObBEWK36yG2jwXNQ1Dxi19Iqxiz9nUAVA2HKxvWONC2fUyfLY3p1uid+xSdZQMlm5PJ0YjW/KyE98m9VweKzjI37X5vimPCGUURfAq0Vulrwku/Ooi9jMiNd1ne/NPdodGlPkEMZldN1BoSL48nj4bo020I9C/5GincpAMM7b9j7/Dy7LLsPXXhZWdnEqN54eBZtmaeKuISc531zYC+kavxVhKjDSAI5PtAaW/reSvEp5K3xqSJD4TbLj73016U0CUoeN5OsJwfI7H7HlF1a7Pvpb+JlDWkG38lfCoYomKDtpumSYAgEyK/0gMLqYtUgzwyQFIIsKbRcSuXcGzyPrncCf6suxiLEmHn4cVkze8VDbRatqBDvCsHk9+z5TAYqcTQ8yo95oKbp1jgDqE8rXUaFGuyIkS1Om9+rImbkTIM3d2j+XWTgkKaV0vjERglIrgo9igc5LPHVEhn91KSzjHX7ZHMgp+GPe+UkCb9GNEnBWJl+pzEY9sMQ99i1sR7OxquFUyOLoIqGK8YTAwZsBomG9iBDyAxixpgJb9BBkUizZ0uAKzXFw04HGXnZG9IAVGyK0g2zgmhaVJzgdhovZuNcoTxKdxW2MYUzkPUFiJL6qmb11Ij2SV7pUWFcBB57O5dFZSS/HS6M1st+/TKS0RIyO0iWzScgheuapMGoUkpgbVjPdsYgvuHghu105IXfgwm6lm+AJitPQWwr9VF4YURKazTjhvC/YgZbj1JbWYebNcwCKFBIYjNOPdj3BpX7fNsBHpeV82J65uZ21BdrwMPO4IB8LJQwK3YRIV+ngq3HLol1Scay/LG9qKYkt/k9BvbZQH01Rq1X3qVHa4QCfBEidXNauB1FiSowN0xrUmX+1q5aQOw0Ox/GuQB2knbVnNDeHMYvk/5bWcr6GfGb66pITzFUfbMzbJF+j4ziDq3UuV7wfzNEMA40x4zmM6d6uQEd+8WC3wlqKbg/aRNWaODt9d2pNI9w0ggcejcwOuM61chlPCNDf7jptsQ0XtSuq3V4D3zzgnvgJo1JxQAvFsNaKaNXMo2+7ZchGy0I9Q1wI9v9hhOzB3FB25M177oE+K6ahqe8pBG/c4Lwndca8OhiPVkbq2MwBr2uRMayo0EBF2dFRUQaw9QIEMK7LZxI8JYVcZ16u+PAbH65j7gu59bMXvr/d9QiD8m32owZvd57Qg7jWitI/iC36TP7eDP7aGqvv6KcDS0e9dIwFOpASW3pybNJxCulHMVchzcOz9lYpuhQWqDTmUm2Moh9PqfLxCE5vHAg03GdpdCaSNG8Gs25L/V0Q2ELxmCBZjdlojHmjh370iLVrpxGuNcoKbxsk0PA9felitbq9f4NzU1VZ7kamNRs4pnhXPzJzovr24f/7+hzeJEMbigyrlTLhEAQiyvhazdiMh9SQ4t4CPStyby1BnvhiHo9M29y4FPGK2fnBAK9j9CcgMaF8HnfbFbKro4JeQ+zfU5PYZJ3mwYf84jwXiQF6eRAZepqLslMYCWER/Oy2GNGlpD4lxjR5O1eFRCPhqahB+7DrCcJeCO1S1bM/B95weDylgLztCz+CpC4xMPytJvraIkBtarJ09Vkuekto5a2nFCNMRSUQ+tOoci+Wh3OO9uHmbJMsSQCT1IKgUMVSQsBCjfw1MSAPDdB04Qv+Km+2RL1rGLV4nvWvHHJqUuGWBLkqkKSPQ2lzArf6ckeIeounZnBmsdYh0ZtBEkClOFuuXpqca3oAx3UJkQ00pNM4n36+/Lrg4r+y4eZEE419zHehr0Tr9MpBQg6ak+4gsuOPYcCfNuylF9JFuyikwAmjjDdZkD0Y0HL4UAuky6YdfWRa1qOMndyrFc4hLQM0Ap583JE2enMRrrwtKRNnCMYzm8PRelCypgZ8KWUYsIvY9TztrE7g050Z5Vil0wpULo/vInhMAelExb/e7B+ZFJ0CJIsZ5teoDxgoL4qZ9unY2XdbKE4eaOFrA3L4MryokG28x7uF8e3vOWaQL8W2eek8Lm6liLrE1tPdWj8enxtLr6GwpUXCRgcEoLMu86aXvVLO38J4LBzHMecGBMUXyxNVEzC9GmHmm3RrmVYuJKKfglOoRfpmturXOc4T66e68lFXli1E65cQ6cMrQjv3SDUkRiOTFr8uPsUKsCoHylbjeUyJ2BMwms2oInNiI0GBzMZ6hCrZWviz7nYS7YilUhLXqRvSbjOatvMARNiUaEfVQUbuLo10lHHn7TIZFLv296JP2/lo5WijHK8QooOLl8mYnV1dSeqOqWGh0/6n4AvVD53Mb2/VG5yf7VaJmWQkwwMmqisL3Q/GgWz/QHDDT+l+zzGfNNw77wI/BZnUJBzFoFRuOpKi4khNGUYcXH+uNpnXNohj7hSA+iEvecapbLVO5KEF2IDyTTsEhxT29zeVT7kMnhl8FcPmfcu+vM/0Fsm84bCw6/xfnj26fr9uuMzBvSWFNfUscDnopBmCYAstevt0brrVIC7SHNXKViVA9//SY6Ti3j2BrSUBZYr8pk2bIzMc79grSKDdBw6CWkUl1z/BnzGlovH5wK7fTYXYGr+drWv9MHcwMSQLBkayDT1c4bpiMWH/cea/w/msBeTwQxmNv5hDpfkyz4vOlghmOA3jOkjS3dUX6vyKB2vF+r0Udv6ItfvfHjAOBXz1JFNsGmovlS2ZVbN+z69qIThGtffZh0WP06ID3Y6zWNnv+4uw0vHvyIuun13WAHF2C3abKKeo30WhygPV8tCN07cepjg6cA5wKpbKeiBOa7eu3lbZYxXeeTY1nDGzccB1ayFjoA4DC4U2xGxAZfwoR+LH9KZCNnZsxoCgDrjl8/KUuVRg6ARcjpE+A7EFKmoxp61beNiW0+HMehqa7iMDffGPnUBVOpdTQGfJ4n9sfGCJvLMroIioJ8T5ESWW5JZxY5qSy7zFh2a5kvC/xbmh1K/iDW0AdpdI+Hgwnr7UWVF1bS4q0mpi7/wARGQS/x+dEbbn/nW8ieS+5tiOG90b673qEMMJXjbTWb5bmZqVhehlvB2EL3R63Dw0KlXHmBPXNvtK9kMPQDVfyozzSoDGptzvi4/AA9K9pjb4WdH5WKLH6LfgKtkL0eKVw79dOBCFYFq0HjsORdTAKCrL7G8a/aoVzOvMwLYqhYuwg5yRt4/lLcUuTWuvWXznVIUoKxTDQzJihGcv9K2+iCIk9r+TY4UuQ4nMw0itJ07x4vMHEWwKXVjXvPrsrPmaRFg1ChhFVvJ5Xu2cmC77Oo8HLEHRkQfnmo/TABG3CLcDRohWj1UCOUsMr0e1LdcgKZ69CGyKKQ+dp0GvlVXBO7nhCTgE1yxexNPf4mLpYkA+CeRVj1cfL3uYODRSu3AOYK+WT8XsDYMLi+yPLXNnJiXFpM7ofl/xDKv3toEoAtoR5y/qNTKhu2qGzeNxBrE18o29SJEwXrfU4r4Pqrerw6zIsCBO7LN9KktgKzUChDlFEJ1H7iCUiHpVlZI1YwAPc+xH4uehVw1bnYABNBshuitYIb4+9kG/WxrryTElODaucGmph48ytOjmvrYyP0R1zMzSQ03uIt+1t8rErsGQEisi21qbA8MChYqHZkR7wigvI0OQFgcI/gRBSPr2PkEq+JGUdcmSJS1dIARcjkph4iL2lRCdk/IuH9WvZpDAVcBxKWvNC0Ss72iBVkDc6BnfkAcZ/PzqaJyuvj1X+LgFoGycKrTIbAtqcZhEU0RFGjWM7dSA7St2d0eMbhyhBxg9QaKxj8YawQMc/ZZGwydyrYO/OpH6t7AHT6mpev5WXP0ZnbibBoXF4rUir9Bu9fPtGk0zZRQxQaDTn7yjd0Z1HMKRwYwn+R8mpNWafwHe0e5ptxPSnLrzcJ+aWoNLTodZHdxl6grNWRurpL6GADwH464AYve4cW920PGdicwxMcCP0iAmaq7lJzz9ioyw5YGLs4lpxEGAe1p94BBv2tKwh7Ejg0PECo+xYHwHuMf5/z4zM1NzwImSDOfY6L/jAZ2E2MnEiyWoQwoTxmpFXfTUjfjUr3GJhuPsYeo++dqZgNe9vraddJAeDpVFWrdtnYpMoRNQGzSQwrTW3iYif9pP02oJK3RwSElX8rsFN/MhTGaxaS2ivuhjyaFi0cCwBN3cKe64Su9kiNXgkcF+0kpV4y4JQw2Jzxct4/Rlma0Z35hrrvE/f6nLI3+7f+OBAxiAvUgo50gSQnjBDRpD2TrqsijnTJ/1OMozsnhUCMEWlTbBemOpOnkJUGsF44W33mBiyBuki7b0ipLrMUk5JYwmjBsAqLEH3u78yI6gffuTcHhhLLm6OzOPksbVIjJQHvyt6gQJFyqlhYlffGwKXT9k2+b0iNB8if8vji4CLYZU9k770hS2NoWhENSvdYY9EQPpXfpaT0Ez2iU1pjNxm03Pewy+fPqnYCt4WjP0ZAAHpE53TkZTMDzUbmr7nRTS+AUTJ+5SQT6FiOwZVe6neitWqgmqDxKmZodK4PX06MkbNPSg442WOpamCRtsxcKqFWGOZ0yRl+OumVG5tc1fe/SM9D7XUUeo3MtTLtukpXMByDJnhSTZ57Yl7tMC45+SvfLlHvvsF/2HCvaDvLkHYr4QUfbeAO/3CNTLQPUJF9r6Kgsh4aKWhekT+G1colK7/AEW7Ub2mxewym2St/0UBVSwLVstWNib8ufXtvHcQTPlvBHHbJfgQh3a6oRqoibAQFn0DN2ANozdbhxGNCt4RDT5+u4r0vQ8e4oHJ8RpOKvMZxOkuRlj9jaAfF+nLB2Pyz//VPQ+dZmoszv5oaPV4lxgVEjxmK8p7vsnl64fniCqn2BLQfxRfr2H4e9xDRvh9kY7ClAlfLTTUjOOSFIWfsYtcTehWXCokyuDGhGqs2KR1OXE6lH/G8BTM+lznLulBOC3VbwLbLUAqc3zsAWHBPLc/Fw9Zw1Z3Ih28r6cT3PB8B6vDOHz9FP2InM/LE2hS+cWtNysZVzu2m+k8kdgnUD6/aWAnmwMMr94V86pVgxbxBDaxyAozZZ/X1+8felmb/SxdJ2977gS5m5WvuWFMNxlnM8RPfer++OcL4Iqi+2mg0THS2JlONCM8YLXoSjXQ1Rhx+HWFnDqWamOtNfq5u1qDiv/cAwuLBXWGGu4sMXfEBJHMq7aYR4hyONst7CzABjNvS2h02qsmp6ATXhbuAEI7UGzrTPz3EqpbnD4cWXIMEhkAmQ54sviii4V8q0RojTDfsvuIcp+gfQRjFthsAOGX+TaqfOz7cBv3p2plBVyhg3lMFwlSPIcQKEp87PzOC/2ydW7r5TzcIvE+gSWmidVgd5K8dR95OnRovukl5fjKd4WqVSv+VXUlkJq9cMbizra90Kc3LYY9JEeS+dH7304BqrV3LMxF006G6VvekIKqr+38tGNzy0YYtHuNQcDgPn3nGm2pdVtgbOASxJUNvoOSrOgOJYw1G5mR3Pc8vqhr/+f2bJusYsz/NzsdiMeidlx0LREpHOFlBOctFRMZH21VE6s91DpTMt3Q4IlGMJJJT3zF6VJh5ZxW0iR62iDPjjilM1MhQJG8Clyl0GYuHIhOQ4xONCJFfV6e87Gd6UH4AaE3ok20n7VkYsmLemIIsJjcyad1q2b8300Tsuz7kdguMORRRNfJUV2y3NgX42pYcnGGZPSU4/7AhfBs/27qv3E4pJqmLpFXRDHG5J4ZJykQM57os3TpIRnTttoDsIgM9jTKnu0qg4HWfj5WU2L9MY2QHjy8D/isqxRclIT9ZSnDANWbG7QgarZV1Z0vngPr+muxDB7aoCTFy5JdFt8/2W728OBW1uImhPAxcK3iXSo3AV0gsegnEu8uM0NfPaZ/+IjGIlHuvWTir1NvDG1D8LU+nE8uq8qdya14ultDObQkxzocLl7JXYRGh4A5TM4qVpJBGEMmMWC6shb7G/jjP/2K/CcHnYNQj9J59M8ey+xeysZ5Tp1gurUC3GS9U72NxH5W7tTja159nqdlVDDmFPdQffJDBEiB0Ap5pdw+z2vT9at5oYCfq+IVunvvZiVQHf1khLpsWH8TOiDwNBGoDTsa+lpfbxZ/0eLecg00nIAUN40IXH9eERMcOe+EEZOg8Vtm/yZq3Bb//bsA6uewya6tDTS573r83w4frLz1xKQr9ibMQwtpifgBD2zj/yuh5M45JAKDxlcW7j7RCVHyBDFCfbPSEvVYo91/gzB+Nc3waZVirhcyIwrqDly6djwnbPdpAQn1PvLVHEeJkRyQpX3Q73ZEmvilMYC8VsQ9NRmQUjke29mJAA/7QIxxZCnDLt/400mceywSPI574qsu490UOnkMmzf3Vtnx16mAzi+gAzWDVeBT4eUH5piun9RcIWpDfWs7rSXTXCeSfaedcps7nKvNgEF4NIO/XQZW6f1ghJ3Yj79Hn+VkQaId85qga9yF+eVo1ICM/4W7zI0Kb6xKPgvqEEsmDptbSb2SL8cBtJ4Z1awNe79VzE0HUemuRcdwULASHEhmSPzYAcNADBp/XTDhKYk5XvuzKKJgN5oC9VAuuLA1AhPxFRxitpudt6BxwJyDQfHzx9RRUPeW5qVMXoQdalj7Z5bbm2jVcfq2xXu2e3QDqxgTyGO3SeaJXNV6aCmKJz1JLcAexIJnTpL4+JqQyejcWVXPZdTJp66E8C7y5G0Mi1x7svIetNJ80uRhBj1Xdw/TzCQE572qs6Hu2GXYWWdYThfoti8qb+4M27VDJRY/m/su2ko2q4ByNRfabp0M8XkmhQ3BET167j61IkGAx/SUO7aY/DBI89mHf8GtuN6noyuYCX6azfkrUGakssd/m1VOZgvuqduVrdiCCbzSQ1+CfucyX+9fonLEMAYJH47cAKOHsM4Fwo1drnBcI1jcn5v5WJ4ae1dUVMyaHKD/PpZSzFGfK6T72+gw8XVZANBdIbLfrxOn2LQVzw3QJlpCRlQS7vbZN1v3CHgoLdA2BtLka7/jSn8+DVKAcGQlHoB+wn9no8sewNWRpk5Pvi3ptKUGfAFVW3aXOCzhrcCFSh7alF+OJ4/jDf9NqymwSElvS07rCA/5GnvuzWMpktTknFUo9hWpbTwIMq2c3vZ6MXYhXLzhv7fOQrf/eIMdf/lerSLJD0QQ5VmXqSNHFzWWzGOvybA4GOWzDDs50Tl8nXZVK5t2cxRbee4RXxtp+7TyvvG42gOuS3WXduo3Owr1dJG02i8uGbQvj03lK3j1MhIuJd2y2HuhmP52Zspx37D+n+eBm7Z70AIdDfhXFDuJNBH8kxBad/rBwk3IzL13uQtSfBdhAeFaGaoPwQT9wv/o1ltXdgkBvm+uQUPHmISYVsNgT7p6CKpZo6ptcZ6Xy1ISXqmNimPjFAz/1lXarkb6r3A8yjL8fbHfJuHhiy4CCqiaQMnlgcugZXTUfawf5J8PTXGFazmUuJ03Yj/C/zBq1drGCa0oHZLOLq93TwSmf/8EjDjfolUvk7pQ9tBpWmHjcB+LJG2jSV43T3F9piD6IVYzfsOYjVfqftOQaSr5jsNGV01NjL3+Do1V432Y4rnpfHzdb3XsoSsy7IDKV4K6NMEHosSBGntv8F13a7dlwyTnIHERlOCT2KdTsrAaXvQ72IdBtmqpFKjsKeFbHcSIR5rpTfg3wqxazwHId3tL4HiOM0+O/OmNBX9v1QsCbqfeDkQcf7V51DwCY5xiPHQREvnHNJNqhXrFph1DykjDaIdzl8wZbvCJXPqKs6ThhGThab61W/bZhh+XjheHqOAG2NGJnZcZI9ed4ckm4L5+QnZMhlW7yDkv79ne+QQHFvWXfkHbfwIbz+6DuOlQQCv1y5sw0PbdkB0vN/KowOFHfqR7ZVV3uaH2wrnQ2ngxNrhF8hCcU0n74vL8kxWuUrlhSYjNwdnCWZqCzD+vqCF8B7dn3XeOwnSdkeLTptQjNlIWxrlnmAzujE5iAxG916oce46dnhnpJR4vfNAghAy6YX1W39AtT/MIadAorwQnS1yqiQJPVsTyKEtdcpYNj1u4Yz+yHmXfC+brcXw+E0uw6iXsL06U2OP/I/CbadlhimrFAqtXq5aPZ/xkfahnfDeLEhg1FAvpcIeX51hlp6bBTpj6GMlZos8lce0+fmREzG0y4jTthLjkk2Uc7w6ZCJn4ALdUiN1lRDKC8T4C5HLVmDUsMmJBUCsmgigKrq9nS9WfFp8vF1mGtfc3bXxaMHmF7URT9lA3d7CR/2BqS6Mf43aemn32lyWwI7mgXno1UxSKASbWjv7kGWXiLKV8CVP62a58botBQgVuQGHM4cVoVxAschxrwfEM/wr6cPItfO8Wr0l3ee3wZuX5IR0ulyzF88ugtdU5RCdQkKt/7NdOwoNDXXfUKcoGDdwb37zv7pF3KX6xbX3CXdUsDKHmW7QyWISNpJh9GcjTfOUr5M8sPV0Ts4OrNGqKsXT7GypZhyRP62GNi6Qjv+G/L8ZaIDsb01hEN+iV0HrDmgybe0WTwq551h7P+evwzJFlNhiBPb+bsNnLCFSCOemV2pu3qym2TGlQIwz9zr8lnP7Hrtl77293e/EYC3w99LS5f6UY2jrOQSYeFFXSXqLxxnokZC7N9VPFtCw13PSIPe2Ewy8lDY8r3ILRsyIbalYRGrOEBSFLYPGWV/AIJY3+Gj+gq3cZm3v0fXJuHlDrXckcZSEbJ9uGLfn7gdlTyOw/5kc7IWcaETT22EoaXquI/vwzlIbTRXjLXFGWJxCI5YGFr1C65TcPP2SnAi8bcfHb1bm+kE8R1lmBlU2yt+qgy9Yjr3GeDWjLPZG2JL5Bcgs2A0kTA9bBV9Szo4f9XKFeeh/h5uMAKr62GpeLtell/u4vV3VmyXCnFeAZnfzlwhwRiG/aOUlQT+SxVWDETOrCMsaEshk1lKqN1odaHAp6NgAtFRLhSs55R5gK0ALHR71e5ypMJRcKjT8O1kpfPUnyLMq6gXkMQcEDffVpybildjgq7aNUi/PLijGBm5S/qa4HOks80WLPASrqPnvDoPN1qyHd0OghN8Dd0bWL+iu6HqgaZmkVE8q9z7/OTAk8gd6JlDt0ahX2WlryLjpjd0C2B1vKtewis1LwHtekQiSjDHztI3IE14D/QDXR7dKnY6C95O8/agBhCqbXuewlp9bDiaRPX/7AFTDkVLSuuWbJDFHaOrBAIvpq47jq8xlT1Z7E/zV4I8bey8PEfbtPenzg6M2C04axgsBl2NHUgA9eTx/JrhqPDx3sJ5NUdyLz1CWCgOsX0FGVBYgpIr93wN3WcOxCPTVblUeBlU19O6PeanFGwV9DKnZ/lRW24k8YtBX3LY1Klj62wBDMIPjv02JcERMZJLc0x28Jqkc5pbx9MnV88sKrXt5Mo1H7B+zK5A9sb91PyLzoyEsJcjiVFItUqh6XYseNvmKv6MThnV8q1CeXP9hWA8LmZ5OLm0I9EG10jzMFGOFcz4KzFNl3bYD8Qq23taD/em70yjZ44umcB/sQgr5Fn+smIjjaJ5FsjPf23Epkc8CvGI6JKvRHxmZI6S5hlTonGJ3goPeSJJC7aPVvcQETNnYxZCUdCkn5vv0BfqElp0DfzrmL923Dj5gbpttIQlEpWukyDHFlDEAscLhui0S+rNCP9KK8TCw1wRdOJ68FUWtbWc/3YyNBkHI+lM87Y2PU2XVx5tZvo8n7e8mYeOYxncBP5S4fhZoMf7tqTuD0qxOgtTz+E+vptiAzCUQCjmEOsCSvXV12zwWdTijtpzlKza1vPVGP8ivlEZagcc6qXgbYJj0A1EFMCMc0II4pO2H1oeq5/xgdkS9YJey5qmsuEJwQ3My2lDmWlTTYeb7KuZohEoOYjplSPE09Eb4J/l+FzW8cgrajSbIRuX3qsQp/2FQozR6dNSxC5Es6K9oC5Jl3g08sucDwt6x46OXuANmsKvTdjLxnRFM7A3KICRgP9Xu9EcvOYSqye1WykoMtep2zsEbQL9PQS2vEQTcpvTjrTcNL40IhJ4jexX8KOerWl5E8ju0cCCTEHp8oL0apKvOGHakKiVgn/RpmvFsWZ7+5+rLzKx7TcyK8R7QjSI5RHMJmCNjFPonrjzk466nsZEx1ksr+epwRi7jrEykjZsRBcIz7NGu7WkgOJJ9vHrAsYC1IH2AJtBXEv59Nn7PXZ9PRERqY0JH0NtYyXw980g7s9M2zQf6cA8sa+kBQk20pBE9n5LofyGu2AGE5gORO7w0CoSpTXs1OfHQO68imPTSxHlXvpqI3dyctKYlqhxQ3YHM9/vzqTmax4J98BI7GNbqPCPtec9C0xaUh1GzN1xWHwj/4elcmBOI+R+R/QBoHVxBYZlLi8MPbSxdtUSBpbFl4hssgX0yj3yeOaTmiPQkjAASQKJJhaC+kU2HP+no5sERtivUWgDrv1+n3F+yvDl4gzq7b81aRKxVA2cST3MzQWaQXX3Bp4uV0pBtf3e5sPYNA8//r6Nas2h6+Mcyo+wtGINlWXFdMx65srpRjZyBXt76pMuEVwvkqgYqUudrM5zXvmMGayO8MOHc/AzxugYHEqQ/P2yTyJUYiJN9dZF3BO/QO384+BobEvagHY0fM4m9Xf0HEkzBu4VorvNPe4LLTU0MJM3hiDGP3SsO5FSqWFPknEyX5gWiXn65x2mH8v6fF5SzNC2IaD9DVaLz57SJWSukeoW5kk5kPsJNmXattuRzkeXScPAGYFwNXcYxit1oSp+XZaDK5OKCZAyXQGwwWSmaNR+L1u4OYtlUwvg0OVnW9cjMQMGB6EYd8JPoZx5HmWsj6NehHnYhCdQXu8UTcmUWFMjsvCSswaqli97gYQPpVKCgGZ/onL/v0AK45nD7amMXnUAVkQUOUzp4V94UIiN/74pLUJHbwtj8E9FduMxLYpGXexruj5ViwvVhiFCQyJKtLftsMwD/kUHLzgBaKr0/Sh+NDV8XxOOo0WrP8E1SQjtYaBsdlBheF5aZMJJoM8NpaLPWHmarxHEDiHrzA9LQGYK20W9USwQmVL+IKmPeTqQTjVC/fiG1d0hB9DtkFuwhlTd/u+uXhG+nlEOup1z6Mdkmcsr3DD2TxhsrTpcJbgkhQ66uwdsaH8jerWYL9Q1FFC2CjZBoQNQujC4hmhsBC2Qtb/FJZ1b+mq3uwV/gW+H8PGGr4ML4Cu8xX9dT2fZrT2B+GIT94e2j8YwGc36QZFipxzstOQji7eNfTI6utaHmhY5jShD6/EFyoMM4La1CZf5Hu9tY53oH9crdJ56NSpXZV8xUl1i4QBM9IGNM3AHjTVOpyEIz/IQDxRGw9Gsi0PzbMIJGXseEqCrS9QnAhrRvpJNykABSTcMAvPZrzvj5lzGzC3xBvNGdLln37apVmtSN/7MSj6a/hGzVD+UoSFZPROpDzyq6qsgvc8HBshJG9aHgOv7ud79leEtsPGXrhdZFVSLfHjR6zRe5bDl9kukoEEPEB6l+bPaps52NAFKoaL2VjuN2FLI+Sl54XiQDBl3yu7kD4TR3BX6JlstawtY59fKuBTPrItyDmP4u61tJ7XBbLh5MXVIkmGRUfrynp7QbYuOQjOjDTXYlgt/Rtnb4JXErRhizwOoct6uyGkhiPfFDdQ1CsZnWRg+yBb2O/ZPqBynd+C9OvT0j1uREiMu3HRcgARp/cTRUrTHcHkywMb1kT4PP1DSdOChP6pZsgby30BfDqyDVqIvxNSgMJBCOkZRQ8GCIhIuVJDH6j7ZO8UFLs1nk4wgLmeDoyIW0g3vOtPOhAx/LPDXSEQGOv4AOspedoFzr1A6tIEUkZKwfajgnJIShogBYHpq+QuPmWYPOuR7g+aq9zea/RLVN1ZGMp0CbzexG6V5GB7b7W7TiRmdx9oXv8rpjugdoWlbmr6BkMM3C+L245ntIPJWPLO/VN3x+zDwaJgH0MoLthLR39Ngw46Lfb9g7DokiUYaaVrFT2LKW+ROdewNAFwV3E8USkhMLw8LnMJqMlF5LwcTPKvEyRPMuIZzd1wN0JC7xRmJxr7wzB9MZJY34zV+98nGQ1obn2WUOZkmMQ2Kc7qhwzUqMrsIVtxAIMoEIYkKETwvzGP++9ztt4+RyjRjuzebXihtjPLDKZdelYWcd3kKAg4chxykxXa7ai/sL8hS1qZWvvHjHm7FdU0xTOkvJ+GNRgsJJPOSJ9DyflRc7ptGIS7XS4ZiVRkL7U28x3yqsxGtsFyllgB1vJ+/e1JoXAEVhnaKBzj6lqiEJGcW4Aieux5mp8f1/NSsExTwHpudoylH/75oWyVf2gA+b90AB8EqjNJK8SzfxTQqcWLmHdXn2u77csO8kD1FxGDx47JAjqv0tcZkphv8VKMLglz25ATv0UR70+jGHqOD46oITaJO9GOZREa2NLEFKC+uux4E1Flu3s+CAJ/CqdgQRVunOrjVOp2ig5txkDCJ6BAlyaLXOLydzldEwIv5oqEWYPW6z0skI9HpcvVp6YfMTTFBacfPSmOZ/xaf3qxbnUDJKws7HHZtqulajM/0GcdxSSegUztHkfe/czWTL/bgPNq6rARpCFUdvvKdOJk4ssOQuGfwN1EU5bipZst/D9HEh4WCM1pJ1O39dU5WErkcH3EPExGCzHFnX9I0p05Uzyw7gQFH3M+42whZSKj+VhY5VuPJwj5ec1NXrg/HWHxPbmCBNUf9/i4NNYyrDOz13VLAFg/+qkdccLucqqvNq6sFpdRXC4J+CXYN9JKaWo6twhwyvHkBa+hj7mlPaSWshjNtGKz7ajT96lHVh1GG+gallutpV0JC2GyMHaTUy1Sbur21nYcxSYG/N7PIxYyjH2vu28QAfSgYfhN87TzHM2DR/Lx+6vLk/U8gC1nxfJSzd8QFc6xxYFAr/X9PJEFv4eYfkMA54jSJkLhoc+VZrViZ6FEzHpL1+tfFI3q593/YoeO90/TxwbjinmBLJEnrKtH1ENQ792U8V/Vj+edbxGI0Nab0r922H9rSod1l7H2AbQUgFwKoWPZOpLpm/SzH3UMIMFMZzJVVOEINOMyA6RVpwDQbTFAwb/rUcoGZsBCR5QcRgjY9DrAg0HAgGZpVgEVJDRp2GfbkHp2SEz911k1KMIoPjwSJcEQu6dVp2S5KXAbVcyCNezXsCvUCiAFjfHJfzdQjZZTtSOD75pwjXSaLzhvYsRADu5KxQvW0JVl39QWiZFu7F4EoRzSpeDI3JTfoGNUY2EeFhqj+UFKebwGg5i7V6nVT8L8CG9stqGJ2nneflbcMjLB0PMwX4aRZzLDlb4NcZ3Zgv/DtidN+zclF9WEdioScmE5UVD8M4ny0oHCOt6XiQqtIunAx3oO2ipCQUTxhUue7PIryj5TzA4G2/me4wMYMBGOtbBiWIa7dvSxL/iefabyOYZwlPfUJUdG2Iu/gD1h/E1w74fjJQMpdO1AObp1ShxGNv0ivAkN7P6qJoLv2Xs4QOLU5g065pxHdklzG9uDsrlh8XFrbh93Gzv/uZZf6iJrRUaOUR17p42bL/ATgf8WeX6qBdqljnbEM+8RbKAhoAIjKGpGW4p5qnDGLZ2mEkQn1M3IFivnGlMwtNQvEkjOoLIPcmOqa4ir1oPPKTYKgIi/Hbc/iBucU6hX2xf0FTBz8gsFX+fuMdDekvtoJWAkSuB8trWQeRdgkSiHiDuAZU61lr0u2TQ2I1L8j8CSna+0nCrvwTDLWn/iTu5xifUMqmRy1T/yxLvUptcqFAMgc2GNpW0Z1PrhUj0ftajIvzOTBw8yAtcXrw5HtP5HiKPOvmC9SfTPTE4Bv09oIVyRpPTSwhdEbmiYSCtuowCv+nwpfca1m41Q6P27SaQD7NIQpsMkm7no2EsAL9R93/MrmlEx97Td5m6zczt+m1NPDfXqV4VLQMpTvVjzeH+vuybAwPdTbc3GW6rRZN3Dki4kE65E+/MJPnC2f2MWLpldeAmwLWkONjUzL+g7U19xD4mZMLjZEU7RcQ2xgDNINMXAYS6rK1KnW9A0NgWG7R2TYBuiFJTfG5+QMi3eWFhGdwbCokiWZ6SyMkVCJR4MbcA4bVVHHWBvhWb/yD7XV3l3i3a5gIFssd1wUbmtH6ecmicUIlQwuyC93q+kinds/6qP4Dq1gC5/evFWIXZ9QyZTC6UxCttJFM9fQ5xxFUAB7Vzrii+fWY5t3JAUeCi5KAnRtaeodrrQYOpXPW/Q0zSnDZFl4ALiAMYYov/kU4RXwwL4DkJIa0nN+XIBm8ZTBjzjqQAb/sylIXGVDlDmxYW0sRzLmXQ6O1mhVXFZV1Kkb1V5Zr0A3g2w0ADZ0sRs/+dHt3pQ8nvm6Qun7aOzjlmoGF82gZvCbn1O3IXbMVtq6TsQO5WVQvYCtuUWV5WSmgRTRc3UCr8qFAcZguvGOkBhBDVfj6ZBQSLxCVCT140IWvdwl4lwWp37JGOGdEENJyX8qnpiz0eK45HVoQNUDcWoJHMCPcVS27pxESuIbxrV2lEc7X+DVC+chWnpEhOjYI0mxeefq/4wR/xoadaa+5YTbfrgtd6LVoJUXlEwNWsI61/FspZLcZF6jBdXail5AXlrPcx5VoR6/LOtypFvjc3kfFXOb1PdiJ9PhSanTN7UipQTyvtzDCVBavIL+P8Zfp+iKw9GcqO3lXw0XIaa7Qdnkl73q/xCfIlvc3jrTAHr8Pb9pRUmVE5QP15MB+/NbXLzZSd6r714FCkCpKhIN5fXp6Tjnse/DB3v2Ic9bGLLJkkkWuhx1kHOE1Wj8kbwRV72ymRl5yAPM7KTyb8zntHrKJx8RDddYs/ckg2ZC5xkPHEYS28Xbg1/OaAurATbYpPUd0SYlUWy0ln1ZVMt57x4ncMOtCNTVCy4vUU0biId7YLIEZ9VFDKHd6caOtuRMI3aw48qQQcKoQZgidnqzrbGy/tDtRFRozngoUBqp0I22K19gaoPw+fhPu+q6VFdnrCIxf0sHaEKyOLa3kf6k8XXLKFzhp+aAJz+J0SQwdmRZ+YV07Mm5u8LeuLCSRkeGs3MYAkroCwhOhkZKni8lFDG496BPgMN9KMBAAqbMnG9q+5UmKzDb0l2C50uqOZgJvtDjPzohLU/8A7+uKqKABFxMq0MHpog9xX4nLU9AXOONQMwA8cwaunymecInY0zbLoiU1F4lw8SNkdbQPpuLIfE3wACsATfpxkz0lKqk068LM4mea8kE4cykenKIUfclE4YIMtYN2ozfRjggiD1GeHXY9LroldNYMODqMJVi7KfVu+9si5loYT9sxAv2NXcIUfBK6N5DnPCdknCb1W0vNNvXDw0n2QNU4rO1/CCs01LasJfvTw7QzHUhrdeuqEYzYwjJZ6BUY7xOSVq5AwywwCZNleAKl3YFU+AttfGdidL1EN/D455uNnHj2bYotTwqib3XgKw9zYyj+OBKb3ZZal85JDelGSY3z/MyHNvsWis+sofUfv5vmpfh4GNBUh+NDEAljqoP6F41exCbAL4cIxl4gg+dS/8lA+OZTwYz1/fHXLnn1nEwieLtMUH/o1BnBBUFyr/y2m/7dBiDJzjWXyT99E/Am6w4YUQPcghRFXdVf1coPyHPPs+Or55JcVa6Kottx0/8FE7tIwHhSylWbV8Nn/mmW+Z1Bm8F0kaPwg92f0l51j4UaE0uE2fK5a4KtjLikcduEUipkpTn4MRU2xXlQ7ssIGvXgzcPyCUB2gGQ1MbPPYB2W9+tgWx/Xo7GnncF5qVLGbsWi3szAm2XCDp6EsoKKMb07yXK7aRAG7jmOXQ4qsjLlervEwknSNiZJ73dlJGraNrRMadPJ9j9PtHNrUryt54lRs9g3w6z56io0GqhHW8YgzQfBZjvtqXTdXxA4ydo0tJUPnCb4IBcjWd6ZwxHvqGAVi6syXZSknCEU3Mj9eOfwKIo53mNTiUmHb4A/CQZ5ozT63grMRapW4d19W3x0Bq6VlYwVCkEDhlEDTtVELxwjjdCb4Ao5mDiKJ/sDL3VBDp2irXtIcljExcxrgH8Dkcs5JyDTQY84t3m7sL3mD+agz6lIlsF7HlPBCgb0v2nh0GnLb6peGu+Adnn1I2i0lmZTPgLeSH9PpIxsJCSq1z/eSrcEGmSqEQbHbacjtB4ZkHw24nfQqTdIebwoOBac6cKfkhlxJW1dnda1rOjLTVRtOafrBsOyYId9ETRSQeOjIIehUhxJRJLqe4Bp9vbiTKq8aRiZtBYVVxboKVPrjLu7uD8MMXOC8x/OyFnbFmVePYalh17KBWke+nkVksfi2G84mX+3JtEyDDxiEUqWYhemb/CQiJSacKQrB/eYAGhNi9KpvHUJS5fuyDbvoSJL5lrbZ3EZ7Bq2PCoeGTBdHmoc4bxyeQQHzitqvZxjBYh8ELzmHpOwxgjup9c7ceaOZWjG4tCdqO9Ov53wWfXKALWWNkaNnEerLUjUpI0MpcAWCreEfgvjug3T++rBs0dVuKE+d2hGRvc5gXOCT7NrWcy5bMhTYZK+E3nthwo1xeZ6GWcM1JRYtwN48A5/5ecPbPDIRalKvIOSCjPGCN7Gk8ktAWfJuZBK1lEO6MQXqYZNStJ3+njj8HhbS13nmG2EypglT26UkOKkXGQr0p7Vn4VM/6j8eiwXT9krYHU2HI/WERdlBocd67tmrdhysyHgY9EWF7yTrl7Kaaqbx108rThTXogbKotghkf8baY8d36sA9HKwByeFshdDRmnkx4DDdg6I0EqOMn8WfoHXHEsc0Cj6OAHY2F4R4TV9o9TCB/+F5nolrrDMQZGYzwkETiGTtB3kBE1wDSyA72Rr38lu3CUVTwlhalEJu1n3MSDLLdJsStr5mzaHnM6yCp+s6H45xbRfjDm0uoxaIy/MwMsN6h25DiugzGv73mKuIuRjUvpAf0kaK0Vy6W9LAZz7kP4kg49bmOaKDS+75fFuqLDaolE6+95IisOpKXEzsfWWf/F5B8tbeF9zBaqFVysFKsPTyR/NjhDxUuT6aRtH1wHq9exGBBNfQ2EOtZA33ztSQJlXbt3yEbkrZLaBXA22sp4qey0dev3aGsfWyImsA4D9IXH6xKPaM82syJMCq0qnSMuHRcLSBghKxqQyNkB7XQ0h96qWiQkS9rsMLPJcJzYdG8Z0As7hZfiUOMzz+PiDu5zMD6NOFBdTplFWQbHHGa0O+q43xvJN7HiA1VYkkQMR4di5xfwVYfKKB1RE3ExZnTdTpVcIiHI36snjN8tHg2B8zvPk0Zb3lSfjpWG0qe0/h/uOT5+IDzSKJHCwj71Td17xwjEUaiUU7pfyRlHfZls/XOAEpPGiYHDPJP4N0+5e7BhtqA/f9vsT8/VmlD30TqhmWD368AYQ+N8qC9oCxAmd3RBZ6/SYSYXqlOT8rT0F1baUyRIbBOiB20xfBD9vaYC24aB0n0bfjg7nm1ORdhIHnrv0nlq2kwZfqRFZuofIinCrp25Jf9FAMODe3fqHKwH46F3Zm5510n3P8CYcdwj1r9vdRlbIXghbMWZdx/GbvH6QrT4CSUVs4AQWX3RsS4oKalkrIvR324/nqEpp1990J/VGD9zm/XkZgTTdG1z4tDbvIZPqADiq1ELw2PNttUq86q4vlVzMVCTlBgToPs9t7cd3FpzLWVX+Zc8aNIlcdDOums2GuhwXWvRM6NEp7WRXsDA95EYDe0Cn4r+OJPW8fmcNKGDNz4qMZhAmxllGgAsxeFwDfIMIBklLInBgOoqytQibVzeFouGNQ6vuJdd4o8mwlzYTkj00L57kz6FZea08uA2cn9l8r3wifal1k2o/Q4OQg/leyXoivagN/k0kC9KLjWhshmM6kI0vqLuBGr81Z59cPOhG20FwjIYVdNc/QnC+pHJKWafLDG2Sr1hZ0Vlf+55NH2G+zqlg1+JibZNb2eXNEiX/QzpwBdVpQwUueJxIGTKF2vS5rBlh5xE+9ywu/+QaNBJwv5SxRf3SHlg4/U1oP9v/XAJZEnFcuZEg7VXNTiKVElmm8CufoTBp6fGRbO6qSt7jkJikvCtxtvnGXYLB230KsQiIEh/WEdiGDvPrYHs6RcYw/lw1+a5QzLBdAz1eM8cwL6SbyGEDFTWo/s94os61wT3d6duynIb4gI7kZfqOtj4rcOAbV+6bvqrFbch/VUMU+rcgqP2KwEZVaf9qUvXiCJFtY1+ADCD7wASnPZEhGb3v5MJjzgeX66ApoCAQtzhmpfFWMBf/kGOjOiycZzoLSgZu3IyNj6Duv246CDOgEeXwqSl/NxnQ+FF9tfGzov4cIWxPlNndGamwMsPFm3FholJEB4OuOcz3s66NB6RARLjC63i3OH5k5wXeUSM+EmyL123CbfI7paDQq/K/YbBAeWGXY/sWpIUkNHl6998KqcDb76tI7AaUHyNjTqr+PJJ4DhYbpM6WJWWAe1wsl2iEvlETPx4hMKUjSyzprw4r41U7f3U+KNoAYcQsESR0y8Gc63ht2ZH8Tnj7snI1BExDr6r/jp5u9XONxQpAGOc9bQc6YAhicmpvAeKADO0VCZ075ABto3vrW/Z5Paulh1K2ToBxZqRHCrYBsAcpi13JANmhmmZ9OUoBp7y5pZAX1AxCRaBtbn1T5UwZyVI8iHHaBy/YmWaTygloOOgFu4XXwLjxwxH4hZGnoJbTxV4lOakQahVhrUBTo+hu3ASOGq4BaZQKeFW2c6freSwDYNT5D26u0bchQ13QjcXb+bOHBhbfKNBp3NUMvQyrR0yVGTd6BXPCbffSxH8gz3aQ7Xn14QUY8aUA0D5bQ2Vib0AqY/RkTef2wMdet9398DHy2titFLAoRr48Ydx1yfrc9UGFr3u4jH49zqZT3Wgo13peHHHWGxaurczoXDd2hki3Q8n4ElG/g0hyFV9y0v8psko2Peofi9NoDnzHkX3dpNEOpDwVhzzq7jGDB03r4RG0lbmJcrXldPSoEwdpkuDeCVfXXaHg3NLe5eHRTPKwseauqhaMw3IuXv+hsep+6wLYsEcDXdLgzRxEFmg96Byy1V/XqKyialRtQP5wfBdNM/t/Gkiz4Rbhx2qL+Rn145qzcAtWXg8aGorVna/51K3JlAsULaxzm1AtDf4cL3DuhMEFIZMoijCL4UljpluxXFhRAxSCs5F7HvDC68UKveVL9HcEEes+iyLQs2rFMjFK/0ep2XIMdfWssdu4/yLD0vglQrSKnbtflw0Q+MU+LympMwkGxVjc6N4vTduM5pVMQ66L+opMM+NBbweb3ezquSmeRjXQ0CJbrbmdGaFPytWpScwpmVoGwXAIgc6bEvvlpFrIL7xvOXFfyLD8vtfBqgfDrGqGgeOdnqaiNC8Gbydjs54ynpmbYoghkq1Fc8/V8dFR+SQf162Ji0p54NJfoPIm0kFENXu5VGKugA+8hyqc05d55MoVZqhf3JKi0ouHhN1v88L4tw08iNGclTthI3L8HSq3dTTNUqjTzUA4yr9XAz3nJ+K+KbVdwzQd7PLXzncWThCmIpLzNlHaXtF6pNIUXvU68UIKtlllRDGahDgBriXl7+E8UTNgBgkeOs/bfrNMSfg6+XvDQeHr2biBvDFUihi8rabzj/C5oZ60hwUO3HFFURDIhkxYAsPL9rz4TVQN2fZVzhLdRCvC6u9ro5ClNTUjzLrUBqmGtlJGw8BSDk1mx6TyW2h9YSuA+Ux76yCvoIQ/skUGqu3nuswe62dHxTl+HK6mDVv3oP7yvxe3ZcwJYyxYo+8Uon8Ejf826OFDr8g7vszi0Hb5yqWzARPjIBlTosa48S3l63Jl2M9C5391Ncnnx1HbvAr+zXz1Nhqce+AdmkQHL9tP25q8FQiS9+qY752pbA6wwvLKsfJGogGsyDFqZ9y7amAHxPXbHMQMkv4/2e4VeWHzuTP8qekfgt5RFB2JkT+E2gg/Lu9L+dU7XLtx8bUdkmYybHfwE+j6qXuiIfVsLMfYyG91LS4uct/ysfeENg1U1h4HNHN3Jmp0PiBM7nu6apin5khCOS0TNH8X2UAFsDL7f3VfnqZRxPweQNObTreMrZRcYwhY3lf8ACPy2BTC+BRQSiJHNbJn045alS5YDSObFlnAkQuDupJSS8crcMnhzkYS4gBkhywmi+R/lch1uAQ8ajiRxz6EnhHdDG+pL52JLBYy82Hu5tW9Qx0fCReax7Gu4y2741iZDsHknbccZAUs0ILk/pgwA/Z6FP6B7Xmxc3sxQlIHCgoJvdR66uyhvmacTMso1ec01g9QjdKVy87RpHmcD/EeCm4PJiSLfrx3tz3IaLOaMJ4ydQ6dxj+qmcrOTUyNIS0VWkUXcySV+SSLr6QblPPJREguTRarjaYsiGQRShbnIrGLaQzU9uuEitk8M6gwU5td1OT1sPa+EaNSzlvNIpGa0RwhFi0dJX/bvwNmTScw5Rk/x0yIK/n9ikiPLHud3R/7UnxfiTQAfIcMJexYpIEnksopEKFUoWhJwtbhLEvxg5wtIiwJR8NfCkcCxDAVsFZMH1cUtujlq1IzmiXaazfp2I4IsDvO+l8ZScCvNgGuBAnkOvtu5rpLHUpNSlv4TpUpeiTGpeVH0h0QPzYL/eGfDWKwDP08cyVusC/TvKJ3mbEqtbi11wWIR/6Ksp2MN4/K0RgrEGIPwWQg54Q7ifpTlbASoNqLTndB4S+3wnq+REio83A8sWlJ0ZYQh0OPuDuu+gZB62HAUDGFn873aWHF2kQj0Q+MEyEkHM5k9uFvHLl+vTiNF8wY9J53boJUTrT3au6e5jh5ru+tmdEmhvWy6qyQ0jaNKD3+nCKpJBy2+6qZpFDy28IdNJ7N4tJ8ava5bATCGprNk3W6g4biqe4vGC3YMseCKTM/Ofb2gP1SlfTFca2qZvqJdnP9v+fL/0x8jz5v+hym5Jqg0OyA2fqi+6vKvOn2fN8oMnFD+Nxok7EdHjgPfJ3K8D/BHjsfFI9Z/KhJcCaL/b3ndCpxGvZluPVVtUj1lZF8FLSiRXXwCZxnhll194LU8/2uXhcGfivKi+35P3QotRpBSBjH14VrraF9JnqZ6Kzqz6RQXLoWwv9fNcQjzA0Ks1slXjLb0Kr1f7tkfe41XM7qXATHS9A6lDw12bwNl8POA+msuozV0bMz6saidrrQCwI/kKegMAmy0NEYKk0obrY1q+K+yRudSRlTQulV5W+EfO5/0BYW593TKXb4yCFMmCRK4tCy4e5TCbzowz2xzuD0jCSQacxM6Q50zLTcvcaLTnP0qC3tRq2y3zKYwpsrQs3K2zGER5LTp6UfZ+QZsewry10Id7YT4z6FBFmxnJnD7LNnqeao3unr6Kmjyv+p2dwlXpqjAKqfyBX37Z+IHHQgin/nujJkC1oi/V+yyFaSyxR/PiiWDmGWGlcwBwzjMuqp0QWe2JbxLUO7+F/YpbU2pNSPTmRNqiz2K2YwUSkYxbVFBnRTUMXa1ra8sY02ThRS2m7HLpEOeAqUx+ydNeyo3oneRobDLkmQ5xOkfPOtIhFKzqnoJzWfm8zYx4Ejr0E1W88C6AqEZPJzRvjD8FF15q1Z+js7CpJWOhafE2KMmy/ps36wCsBUErzw4Mkj40ZZjdoFKRiErs9KBRMsBpOKe5laY+ETmRDTBqZighsEN3cHlyaHIdq4TMe/e2tSD+UDxa/XQNdsnPkuadB2oWSJmuFQlSxo/tsQhySRS+nbeBeTOUNABBFFzbqoSwAUYXZzJiAge0v9EYaKEaD7TYTNJZIo7J4sQylvBdifRWft2m+rCemFFL2NP0NXYOlxCQyXcpdBAHsA4lPuvqTYEgrMIGORsmzXpPrGnw6nqNAtRlrCbY2ksOk0WXNmQKgnbB9aRNmlHviF7/6EIAUxzg/sPdZOKpAXJWcUBDByrJpydpMKczqNCoaPYz3sGrVDocqglOqBHhYrsJE2sikGvJM5ApAks83sZpgWDKV/hUM/muTQyoEEzAijlC7t62c+7tr1QMspaT3zqdiXave3VcFIlFJp586oySd6iVaZSTNfDxJa9k+1V9bbCUQKxIHRnZ0d0OnPPRm/ltTy7UT/H4oA9RsZ2A0pITCYoCI31yvG9+otDW72udM6FSgOPKp56pjze9sGi/M/E0LfzI1PxL6nA4OEdKGSaCiOpL4ZO+OndnUusdfnnt1WqxrtdwD/1i7y5W7pjRSHs/nNY7bKPsvSZSyUsOz8cvMTnWUfjbGPa51mFgkvjES7VRF/aow1GNGfLD6jZdeEi9X/d0K6jnrqzxmaY2y607ImDJlumKmPBmoocniUO4CpgxOZdz4Kpo+GfmbuPEk/OKW/QUWmZJzbUQXejFhQyMcuaTLWYZj0MQ2a8fhTj3ZdGUkCUUGVGI7W9pDwZv5y5XCxR8Jnv41URDnaTPN6Vm34ICbRnC5BDSkgX+KozfFpd37CTJb4HK6g4kRaK0EV4uc7DzApJ+mlAGggyvUHZfHMRoQBqVPAwxGX3qNRn2i0dv1uK0bOOj6gnD8xMC54QpuwXt2AIfTZ2FG2MMK01vx4xV5omCfBOXVBHEFJk+HRl6PfMiIKWe6zIx4Od+UgKR4yjk3i7Rgftw7agtlgU9rjPqFMKkqZ+BeBUhDgQC/LLH+QLzcM6unhymUz58LzBFoRUgrUbXuC48eQrbcJbfkgpx6JWbfwAf3x9Sd7EA8G/qD52PDdyn1CVZ1zvxVkcOjucGxHxxPy94tkuK8Juv0NHbARSyJ0yR174xBgDtxVwnlawY+uJSlnVm3JGsTnQ4XQD5BRtxexLKog1movsZ2mbMygiOoUtjxPJmQ/s20s7JjJ2Ya9Oqfu6A6vpDXM6zztOGYzNPE7svh9BPinFj1xAt2ZNGBx6EQgD7vO4oGLCWTG61pyY0s/m9k4dzMFQx3I7FJOQIA1/u0BoyhzGGKxmlGpSM4c3labROP7yzciEqjdbvBn9rNxVDD4lhwKM6Vn+5YR/zcIaZokZCpO/aiRTkeLRkTkOGwI5vaibDWxPaGU6g0T2ya4ge6Fc6YCtwoJWooMBm/u94yW+aiclyBpqmUjnEZTgD4yesOJQwMuR6P+ULO47ITTeO1p4urv68Un4DC5io3PaPon82yB+m+xIbZQGQBW2vQai1OS4k7kT6cllFyqcY0pUGROzWn5Q4qGhTMc5A98wDlNh5vm1TxqG83RX8NcJPKs+a9y4Tzo/KHfVFz3LcTDYsoM/M9fI5SG80ZllgBDrCdHlDioOLSKoa3CWaiIAWohiSZ2I+hRVCaq6sAJcjxOsDhT/PrHXIfCHfXOvc2fWzDiLDPYU7aw1Y4OxLPoCnQiggdregfUU5CjgfH/frgRJyTtFfssS4I0zGeyXghlvRwBuwjilOBBte1vITTtDipPy2XwXNm+xAzwm9veTO/JhyHmz+ziuzkeBBklTAFUHWmsQy5W3bzNegvEmV9x8XXKicDUeJACP5MKM7DWhEUpmCb13AwitnVJ/HeFBoQM4hrEr8buKg3UJR4JVhbN54wbQHRuKAEWmeRKQBNw34ljGEPCmou2ZddF1/wZMw0nOtyM8KwRv7fAQQVG3+1GBDPanQXEdIqUJhnz/oYzT+qgQDaZha8RVuGrO0w+X5711O0r3JgP9YictYLbcSoja3dkVZetRXu9N1gFUbRbrHUjpKu8fd3ZacoRCpfDr5OIN6YCpjY8vNBUgiAuLnoSjLA+FQnrQdFXUmewGc7fKBl7v3rzYGPB3UyI4uqywwMsHqeLo/nE25O1Gpf3nEg2kvZ0YxSKb2D5eUWj4Pb0x/XyKwsRISxUYbXhf7H/3QCy4hqiUhPaDUUkrcWbvRr2hB+2CK/cTJPh8F9EDMX+gm43S1fXk0X7q449FMWfWi8hc5B+UwqZorasdDEBGzKSGoWOtNTzyzP8RTdFMpx4Pyvd+lxKX3WdGwr449mhQkkbc+4Rt4dWv7m9NynsEM771eKkXEEKYR0nIk1DPY5drmnytmkdSiRfpoLsI0O8M1T3Xnl+nCyUywAQw+/B7KdgkLZ1N+dj+5nVBXyti9X9YDp1aNwdEa7bdkF+MY06rkp7DXaaNQ5FaUeOwRwsJzfjMXTPd9Wnva7TfvkRyeoW9pnlRUUz+Q8InDc10n6Kx77PkazOBxQNImgY8xQQ1SuOXm2DzpnXXK4jdBtZgphqGfAr2tJm/8DxwN07sx55l4xZmvmAywePUP6ZN9NvOBNPoZMrgJquxmiEbnzMoL00U6Mvp/1mk02nv66EMB75oJdejluPsU3E52Cddz900dutW5nbfqoZQM6ysFY2Fjinq0EcqLJtQO76T/NNEijrgm5IapVluVTctLzjZPRNgAIwQ3W8kfDj91jJ4WKJJS/U7+n1usveQiKjPdXIeQDtkWWdKaVdbUHqzRLt8cD9VYYDUJ134G5NLBLRLR791uLAIHw9tKfzLyRy7K6caOZGRjfqdXUhSDH0nFe33HysNUJbJepeCLsWGSPCK5tED1qTUu0hexZri1WeqsfqB5diPmfObkloBdn7hZBWbXRNzIhBesSFVUZKCKQ9B7MiwNYYbWNhN7tms5sUIUlZaarmPMV2uQ38Q0KArIkMuRX/vxdtJbqIuocjJj8PEvBYNUqvdojPrICMlEwQKppwMl6ZWbnFQ0ZEwv4T8uJ/O1s4HBIFuCVUZ8Enr2yC6scqFUigECsUKYPODRbozbmI7t94ZuAcOVaop5KDJivX4rqqJURvOdOdL0/neHf7DvRayKAuDLDmQqyADV8oznIiRY0eP7lXrSVMV2Zp8sJWXf3/kT+8LjaMvFE3xynIHKuZHx67OZP+KCheFjV4saVWRzIkQVl0Mm68PVqe5kww8PxHsgPFI25KcP4R4iS789z4ciLCCK+uEKmo5KbIXYqgd8f+1xkkcoF6yIA+mXKSkAheOuASIDFEWlcYBSONIuHa3s4coE++TV/OO82BTXy9dm4RcmKf944sHUuV0t4avC9bdYTZpNWcv594MFURh/1kp/8OBtXi8cmwgg5CcT312W/v7UBryAU9i8/l6dXkLF8fOFPEo1sQwj5bagJe9xqg2m4qjiAszRw1Vc0RA0JXePRtoNa2dD7RjqNUpyP6T1HInOAQf+t1qoNMCK3fY7KUf3+uGw3vYUgpMAGE1ay0MCsUzRjBxtV8kFWxBSbvDHb5MCFUhUdD2j90eXsygsAT58d481oYxSN8TWXg1ZE3tzo5jt3XVfRqlo0UolJQH8kwXvjg0fsJmCAg0NlVYFlUsdHm2FvRw8AkDwfrbIqUhnt2DXligtWSExwpKgfcnp8O6n+cAvqFkYb9Ksa2tpNWS1oNVyhFLtp3oG8ssbidgajVQHVq2h4rZEuav24450m+aVFaYW3j+obMfHjbqhz/FFW9yuDhqomYnNL1WqYqaZ8htQMxtRpbkjYvpD7v6Xq8wxbEWxycY6h06dThDhaq+if8eUQn5pPDkTebjBe/mYjVe/OW+JH/fO6wK2hzOW7XpN3xM6hMC0FGIglkNbEaEqp+JQXGGNkqgvNBPr8k8MXGQ6GCYlQOauGMWQTKiae/ltK2LSngdvG7i8FCSx0t6EdTcIY2JSkpsNgF1K4RFopzkjZfZWU5HKX23wQBwGplolYl7EfDz7HF16ITURkcuPsGlbSm1qF7KQvX65zqfjaC0/BUs8nYojTOhAaVg/btvIaaETn7rAlaAXLx49ppHU4s8JmNnyqa6Gs5wLwXIg1IEVdrrOELZeJHPotu6QEHWOdcrY6T1TpHmLdg7lwVEvSG2IEXItPlE8bhBJ5uyrCpzDzeHaCtXUzMko80RkxC4HE1HDP+zAAngDX8mO38YNgJ5kzlrFT9RteWKu+R4yBumafbLoDckxEIdov6O/kZu+geNl0Eq2x6eEQzn2RmEFReswB2rJbPRJ/3aJ7iC/U4U24Q0sn/Z9D/znI/7TwxRsLw9G7x9pEPc1yFQzJjJyR04crn/HdhjXbbGsHGBdvQCA30vDs8k74xNrs82wVPHbkiYH+bOroxY+S9zFne4mHk1YgOY5PR87A6qLUOqaWBUyOcadTmctDNxhiyD5/92QyrRI1esPCMC1Dsy0oHkX7T6ybiq/pE+OgOp2F5LlbsD571MQyVtUa0+XoNZiOuMw94D/cxHt+8NCdqJWIQe8t9gZS2K6b7wLPMmsAt3nd5kwTQCFfGv+NxjZJIGtYM9GGPVwau5KEdUofmN7MBvMRNsJWsi6c6lps3x0he4Bz0cuXbPEDDGP3l7gnpSQZlmYTTmhiImN/ShYCJyJIDTqUT3buMHG7hcq1GglN+5VM6BttuAVyb5vHT0eD5S/I4zheF1rT4r2TItnv9j6nX9cGkLaElNQdiUNcpBsVTRtobO9gfiQT1zmUeyoATxTx9/I1YOmTaxQhZbokZYcYpOb8/TRytAfKayxm8kVGgnqJK4ESlXWYm3iQ+KvgE6TzEY3MoWI58ekURYCc9UQuMuaYEuqQARicoykVRddorhAIgEpWmLPXNDqnQzWgAcbS9UQzkQuwj2sAU5cn+ZTqYRpwKC7FupLNFtCuKgldkT3WkuxEhhrQQNL7CKbKLtrFaLRWGROztHGGIy6P0z2saOlvHNcclnZQuypxwt95sT4gALGA2KqNUhVPdQGibcFoeTLA3ej3urzXyc6UFiokCkXlqAdkmrf6Cl2DE/5HfyvF8uDtDMezzTV8KsNX+RtnZVeISmTSUeHzdOMPi+5EavSKE+5kERSOPVUPtCVysoOld+QwlgkQmsWycdZeQUSFRpulQSl9va8atJ4RKQEpMM181XD+aCITuwwFaklTmKjN/p8ZfWGItB2f+sCnIyUz44oSPsEa3vTr6nHo83QrvLWQoP+QvrUyhHTjy2AtZZwZxFW/6cGZ7remVWuq2ra2VtHX2DdR0yEbfSi1NhQF6rehOqKJ0LEjsTPd8g7Ml98qofRzSHRnngTKnULjKwJv5rN2vt2LaVjOJo+ovMJpaYc7DtZbs+XIOszzqCvmsD5iW48vziiXK7XjgysrAv0Kqp4gMkjDYwasGQnGKMeaEg3QRGApYCoCZcn/gZqcIbr/wSS1pGUY4KEbWWGLUS9ZJeY3N2yu/bRSCMKEO/ZRr6FDOLvVICcMBkkSTMyA/moHfKVPqUy7w6XNju2xRh/uKbatsHNDwstzA2A9nlkUUPNxL8vJZiJLW+keIbJO1aUJcJlDNKXB1B4zD7g00YeYKCMXGCMNxqSZnB+yNzXBIzZIe5ib9xvcGamW2mx4fTCnPQLU9Zhs3qXgMbcan/k6jzWTvLjngqhxIqEdjVO2oLgMF4qSm7/Be5G1NALAxhY3ncq2+6CBqSzyIEt0jBcLrkKpqTGvoql3CYH3sXd2rx9Ec2hH4jQpKWsnfsfer6h90ljNvrUb8FKOx2kGrHlAmSLHNNG41O7MgbTlxqV61UAvwtDxEUJnkvskweRbKjH3qbDqFcmFANcQPGY9mi8K68HnD/4EhxxozCAKty9az/sUCw29ix8OCCBaJlEo0aIJW+ykucZBOyefo3p+87hLsr4XVknOzH6SixSz2edUAOzDzLznJT2kBu+OneUbuk6Ns6aDGq6nsN29vE9PQOI5o9qx7BBJk0aXJWCVXB4PvLgmOz/RSEss3SllXZQdP0R6tUY+f68BkwOB7OAlHHuk2gfvleyZHZxuyeg3CykxP0sQhX2MfsEJK6jgmQTPFRkxIFU6puWkydhHjsWAUAIpp+b2Pp+dbK+fhNjbFVuNCk0kXU5LhO560yXbSeVnlCKa7CDhQKCOHjbQNNICS4MI5B52ePLq8yZQOzw2e25zx+Qmr1cRQ1SN5lcnIM+7fi1M2zbtt+gcPknvIgk++ljmuTe70FhfJlhOFUg83t7NL5DmlHeVRURkoNUFa/8s13trkfU2KXTGtpI0JszNV1pIIt/0YetY+eDGTD/HIXEC4qd4goUxxSL0SvuRowk2dG2NNZR9TjAF+30Fk1eT6mf0p6+Alo76aTZkGc0lNnHoa/rZOi0s+rnygagaCKuHarEN+l+yj1Mc4k0h+DqRqPJo3XhjdksNHAZsNwxTY1OU+e7UWIrUJBZrlanVfpjg632wIQk4a9F8EcSmMxuhDJAQ3CvRw1TCqoDdoC2wf0aVVHtvjux6Hcd0fFmVHbi9gajmW+azShWLWIaT9KbzabVJv77VBCKbdjeJA7mxO2WQZK9DFJZWrX3wy9JDwWK4cVe17s0FoqC7W1Tkz/qeTolIKdRpnyWnkpODkvbo7f4dItUksqYljD4rvAc4s97niJn/vL+BhclUolYNaqostmWQsBpwok/6FQpOzbDGuEEmyCpB52YjRqAFC5Nv4sUyKhkK0zYkG7AEEoBfIClSgTV7P5NjfF7DkeU7R4dSblbSzrdb21Pwi3wOnJMvzQwmpjz6K9iERU5Npx/2Ug/VeAxqJuyhVnBusdZ7zsiu2sJdgA/syprPS16sRf7BjbMMzYrDqvqIS2N3I0pyZYsr5A4i4MssiLWIA2HuoJmo+wp0SjhVXC0q8yw0NKIUv0/rqgAjbIaKBiNzck0001JAPDYWwWpqBvSA4OD4GCpO8z2vCG9d3fROv9RyPFAn9hqEQSHuXn8wLpgLtbDjz82Y61zx6+199kKk1gKXsuiDdhiwtS815aI5i8hdYoV0GkrAo3+fzuJpESacbUsFllI9eMlTXfPK7/TUyiJxTQ9Ms5XTnv39F43YGb+h4Zbs+Hwlv1OmJx/83R8oZg1w24OJSl8pdvx07gG72ydVCXZTGaC5W8obs5bwSie0jDKTFjbVS2+JRjAIfxFogs5Gn399a/L8kNA/DRp7e4O9jWH9CQbpsMxLiEm21f8LMoAzWnboj0BrHb74FhCVagqk+Hmaynn63CBLEbXJDus71HHNSxQKqWsmHygAgQMgXS8NIkJDIbo/mJ+M6ND0q1cNJwJg3Sx80LOrgXcY9yA1W7YLKKBtO34h6nW6z7EyUtVvTdfUK5vKRVAy9nvmbMWEgCfuZi6quULajL/3EdV6YP5w+qh5/QFaEEYTsc4JxkIzzLmUAm6ixZEvBIZQE0gCsjJqzlRp+HX2GYA7AJgXwHrFmWI1c9xubdegjaBLr7B04PLaaLoI+/ZUIg8vUqX7fVMxvQlLVuskBc+U77Ojm0TD0psU2SDl3SFMju0auBg3yO4lHR9Ye3YYxlVihe6+A6pM+tk6wTz7dUa1OXw/qZqvsyTbkbl6S6rQQf958y2PXDVnc7HzYCFLncuXEFA37ipSLBBa6RV2ZOgfy+TEkLju6aG0OHqzC8udLmCQqWnQkfQQw/Nb1VCqpolYUKTxDrdf40iKCyQdbrlUxEIpDka4AxkecG/fcWYZUXzrlgpxvo4mtzJNVOSaVV1IjtIRj+mkiOhjtOLvag+3IuG0j7OWas2QWSV9T2sRYvsAb7oBuWUTO54yGi38290Y3T3ZstbdMR1L75xGGwlPQ6U9lcrdUvuZY5KN6ljnW9OgiCwZIp7eayPFxtnl9djVsvJqW5DZ4XxJlhir1RtwZGq1wbzKF+tvlEVi/Aibr2KBuJHuHrVhc6BMvHeH4MfFZcCHFcwaixIpMcWoz/kpeeMnhBO/bscRHQ5r2EQXvnLdjU8vGnOIIueNmNF8Qpx3HZnIG/YlFmx+JLNicWghXUMgTcUc/gJt9po+ojBWexGSktPrK5FEhVxVdLlUnGifPW6Au/T6gsQ/uc/iAbLuSfIupyOjCH/eHhWXgbrRUYar5A8C1xuAgGVvwHyXyr+wcZpOw7sAp/nrCqK2BwyqPNMTTwuYnOyNLAuYQmXvRvBbi0o4u7UUlxn5G7DMBPDd99lJCEEodR8ZlUFT64jfQey3gf112tcfts5ryAjccLAW55Tq9IcK/OpNefILQBBI2O4bpCwYPMzWI1U59siioEQUkpceihiW0CoA0hyguDvqcbCndKXRO0YPHRRKbl9BKgx8svxCDsSky+1P3oAzT8HxnHtOsdYYgJZsPd1WXGHvdER94IdsCE+QNG0husTB1BZ8yiB7vbMUCBuwXXKH80bEMwbMreuW4+GucCi5VJXPJcUHkik6jsk2dU02ezjRS/oHeKB8Cb6Zp6qWc3McCg9WPmRgfnoagaxWgTTAeEP8wgXEdUgw3SX+spQ9J2RXMRAEE9ah1T16l9SwHeJTb7pjMj/L7AdXCIT3BMhNX7XPxlI1h9y+5G988cYp3w2jg4705IfnvL3TtWZrjij03BIHvY94wsX+Zeaq3vbXhXp8SzdEi1eElLf/Btg80c5d1qoPGeWVFFY2O2RQ34FB9mRavg/3Gm/q0cXZQZe8b24qdlbobiFsKP4i9HQM2my37P8vn7ZwOcyjTp0RAz8V1j9bPP9Qzb7+dzkepHVg0GRFsL/8aIr5PHYr8JhZWYwqluR6OM5hYjJxL3IZYhWPe46Nm44pmrFoZMHquX0I44TK/oLbMe/jBxN3G6CxMngbpo1VmUiJP4vhAAn1yHCLqdnERVxurp7LCOmTDwmJGt2fF7C5/aM+X8aSpyebdLWv8E91fTmCna87ThnEgLHBRnz0PthKc6+uLoVNW0dNvYBcVRemteIFxFRMbBnJSKSyC3LVvtZ3OGLlaworr1Pg9LwFcbzBQescQ3pRRkcUlOXwvXN2kKAKJf7Jn5NdobWfkG0NLy9TbvkTHbd7/jw6Piq7OE7FTODT0ubVmlkvqCKmuTLCI9R77dOa8Jk9jMRMkNZA1E4QkRcLDT42fRkQSLmOWcMcvzRsdE9sSCjA1VHq+QGueoryhBxhGJ8OcvSolAlXkZaNUjFTpUuh34wkShJ6v+zFd5Q+YyKPhL1JfQhLnMHBlEVw1leIawptgNB9rWvx1z6t0NtdWK/psh2rMJZBxXboLhpH5Li49MLOedZDD6PL6SNvkP4QjJY8jAWz8rec3eDQaEqV9Kvh3AnaFElkuQS6fsAiUOSQnnJMTtwaCDLooQwe8EOPXwHOIzF6gfHnmt9rdHMiOZXeb9VsvcN2N/fOW3N84hTwrR0CLOIZBbCLd9n5an7KYkrCwsFQ3ybWxbyBjnDD9BY74GAmQi2/XhQ6RvbZ7x2kdev//WjJsIldpvnxbM78uoIaZGr9sD4apsXrvMc71Z7SbheHmu6J42cK+ZWdD95fj7oGby4+pKadj1jrzGWrRrPOc45wRntdKY7PjMdpnXpDlwsoTfwgobrepi7mF/jKwbxYuxoGBeJk2BPGxyQUTtPKp9LYAIOwcRIb34o/HpMudyKjn7uyywHDe8Q6jfYPl45rrfBOU4MHJ+ULTnkAh+t2+eaDxQSy/YH6IKld8vx7hAvi/f2bgobs0ox7eODtrn0AmWYCdV+gnEykal48iPgrajY8Y2kO+wcGpAvv13zeAghia3zTCxdpL7zha0oIIDuI9jCThnZt0uiRvnjhoKCrp6FSJ/w+J6tOGm1W83wNtHozAjhyVqt7szALv3UPNsTCLdpQ3fdPnn/CR8OeCyZUgiwtK06fGB035SFj3SSVHSsGytlzOV3VOylPPw/PJ49F/iQCr2VfvjPKw+4tr+2z5TiRYXTLSa0XaMFEkGpJXVjS4mM1baWVOjk7OnEc3you5qnZ4GcnIv2sTi8UXGDjfDsqiLxXH8TaRDGhGwkLcJLtI5/cW1zu/YS8JFxja5sX9Pzq6VtEkG2IArl9yZedRMj+S5tgLEYRBqYN95YhPfLKSlY0uobHD04SU7XwAm6LQuQWAuTDRBHOl7pHH5TrjLpIXxcbeF+7PCUbk1HXz33gG8NYoyXjuy7YebedL1NDBMO8ObAbF8wtfS9Z6w5qTTxd8esPlyWEhGN09823mvSbzKsGp+98zeADiEJXNcu0CWXYoYJHCi5fJDwR8H0GgZh+hx4+SG3QYyIXf+0XgSIgWs7fuQ7U5C6oIMh+7Pl2mWadz44q3M/jr8KE3knAfvKbmVXbG+8eAiftFvZxywzifYhCl2KYCcr/MXD+UI1NVlq8GJhX85HFIz6IAm4HmB+0xJqqIh0k0JgpWtn3iQb36ejZImlSatqKhwK+Soe3RJ3m9aWdDLs8AdK+HRTm+txpUyVWEbC/B5knSkkop0kvGQHpUqZ57tDvY/33Q4JJeLEkj/o9T9V3tXBx/YdaN8RMdKPcNErHsPxpmTEdc+UMhmCdCHY/V8basJO8QB9E4xvKYZW9tR9JKzqs+VKlsXDwryGjWQ8dFVqZDU79eHDolWpPgzS0NXDF4J+dNv+U1/sCZI5+6v0/c9gm1tw48mpfnp7RvVHzST6/0erehODSQ9zinGMi79srswU3V1zv/I84BYEShJs4czGaW7moXFGPgqXQFYmfuy0SD1NE4SIVdmNMZEHNzF2ZQjV8fDh95+J/5UUQZaaAuGjV2DOY73zci8UgwLnad+domv6ztLrZA4GBwZ4Fz1M1oRtKWX8MyIwIv1QWyOMkrn1nsAaXM4j7EJ2mOWu+e2qpsuT3A2YuwTefRSJnoAPV72WZShNwIfElQdjDHM3IauLhn8VrfMxBqmhQ6fXEDKALQlrXW5yyOM1tJcT3x8ZvwadrJk9FhJeKvsTMAe8qOuGYGIRxeIqczRA5NQHNZBF/zxIlnwoMD7q8StMkd9DRyQI459KOgXr1kt1pFYQ6cCmIZmiYaDNw4TrodVpFBY87840kLdgOsjnwrJ9ZierWXkWkNYSgCFBX8x/IGPJNyZkjcAjPqGUjguv2K7LvspyaLebXTIiBYoh4fHoKwuIG+LbC69EkCJtRmXE6isnzvt2DfzN28b2S2WdsSsbJZNzz0BaVIu9gQn+oq4tYDuDjTH6/Vw6KJ0o17ki0TuNv+8nI3PQD3AN59uB4YAk1s95wR6rQGCVJoy8poVNhoI+p0GV+sfLxwHFWyr5eC1XxFPwkTQ2LMiaJruPewHFvO/d/guVq8LEc38yE26fSSuBcU0DQh1zRtBFWXZsOP72OZiKrtiOBKgjfTzeCfRfSsc3ZcLPz6sfRyeFd770pE2MrKgOS53N1Q+9w4ZvVZ1SfarvO6YxWPzKHT24SE2gMuBbBEcA/JDkb03A1vZB7RHTXzhs3mfCZ9vtkulTu3Y+9CSHsjbPf5rnPoTE1VkHy5MJ093yc1PdCNiMJO9vvGxOgXW8674ZEZaoatYMijlRbwalOGRqpG4GZToEnu0qHtSW6bGUQKtmhksDPLdpQxvqtVS/YYi29XSzv2GzEn/zPc6YnFWiqYGSm0mxBTTwLRKGE/jDtwzgcczq2hpEXlL9flZdM26riAuni621ZhZT7ZbI7rByEPfVX9WIqz9+G0F7PQWqc59+TaCOwxyUG/eny2CMG4oRiwJvDDzXqJd8lcD1Gyrx0OwPPwkM+2YkIH/Ag/tX+YKFCHZLvCO+QDkgm3gf2rbS6NZlHvTljJ+VszuQ/KMAdRFZmBTCWcfHc1t+Nn9HWHygnJnHoRo7W2aubah/+w6kUYO4Mgd7KZD/y7lvLi1TXMxzRiLESItufkBWS3x/DNXf+NJOiBNxRyjaBoPGTjAdpaD/BgglIMxC6LX4epyVumPvvMgMNgQHVY/i7GVD0H4Hb0aKvcjjYkAUdPgTpCO6zrJUz9pI/thWVQhWTi/VpkSSTvPECKhH1+s56AEgsYLdBouFxf7V05V4HNToApitRrht19iTpNv1ytqrr+Fylx+0jMs0/okVnNpwRaMSaORPdvA+W5IYDam5F+PjeBLsEBBjKDZfesjZXB+NThluLXM4KyBRopC+I7Zr0N8MZkUNF4Cv+ZUfyeSPRO/M/mnAnubuVirqWSHc23Y2cOwb4UQlTk+NsJVe+5Td/GCA9SqvD2JG/RIFn6aw2yu6yX6QApDpgiroQVMY8ju9nW4AVluBuLNkKwz2dLK2+opqufUUbo6t9cFXS0U+aKz8/Fgyk6NbL7qjyGkgPBPZOZCAXdqvi2lwNRL365Y9PdxbGQmKJvCCqb2VvT07ctQM8OgF13VSq0xq/uOaCi0ilYo8xtxb8K6eagMxmJCiTcBPum02y7l8AeAS1UZCQuwOCUOij8w27pUmCpOHaIFAQGikX+7k1RQjN7XpE9G4ZshikHxquGj6RAvTexlTkxk8wjC9u5CIO6jEF/YB86bSKSCqYKt1Lc5g0hfJsShRckDFgDDU8LqAcWi/zHf/k/TZzpenKJxy7g0EW4pkVw1OLdzJi+Cs2RfoMkT3leBs9kDHBzX/BO2/YolXXLTDUozAo5PuoUCDDT2De1c2fO3vw0MnTRWDNwettZMF8BtUL3vFOg8S+5mMaFSBduxTScPgE0Ft1wW8JVXUHySRSOpuKVH+czSQor0EOpVfsKYGIVAUtZ0j9QYI9g2nPdBtQKjiV6s8DUZ0SV6rh3Dv3f2n6X0COFbqat+zqX5TUs1HRCSAH0XjQaTvvTzTrK7rvbFTIePN71gUhOb2sW3jGEOPdXassFqrv0WtGmkxTTw24yuIhRthyePw6bcl2GID8eRQRh4YwHS5ny5ES/JvVeYkWzrXJ1jOzfTCuDK+CQcP0DdnW/zwu3FqCCZYTUmmVYfwEG5BFN/f733C+F8JXP+gY3E0rdKztULw5pdliEej7ehC0Sn43uqXw/UAepMaWhrFDInZ4hujdGzJopzUGhqd6MaKb3jtj+5lXzGIRumTviogTqYNkoePPks/SqK3t+pIv2pSciBbP92ONU16Q6kEsQaWviGDw/WY3zdy4t4WpyH46CTSqpqNuhFLj1/5vianCPC7QxfBtaX1gHXybjJWDuy7hDNwu1anN8woZxVwK6EFd5nOL/i5YPLRTmUV+wDx5/zqyiaey6bGv6gPTUIqYzhTArdDSW5ff3boGG1uj1VsQLyoGJqbGQpTmKtRFjvQRh7hOEnDR0ZxtNFM1tEPozB3aSMYngrV+konZMyEFXlYzFj7PNEWFLokz3sCCWmUVV/b3cYRK4kEvaulmrv+iNBDZQTE6kA4O1hudjTfgqgIiNdCPRtY4rPrNDehssnS9/RT/ADle6oxPp/C+ewDRVVA9fmaoH34qtndZ41hBoyoAMOehC4sT24iurrzHW9cwKnQTQhCKAFy0eOBVA7sZX0vSNKS+5C2Sv1hXdYnp+BxbDlOud6TXOHM0WGE/sgObo0SR6MC2NU9gMi40dAuU+b9ySeceIYQ7rlScuSaHKkwHFs6NQJGXQOnaNPD2n3m86RyMqSv9aGQgMeNdAtEUjIyKwfZ0AfvSCxgAm51qeCwHX7upIN519NQtRmlf0VUXqozWWHCczpM6kdNU6xDw+RQnwzdhDgbdJPQXlRG5DEGLZ/K5OOTF9KM6KGJ0IAN+kDJtMt97n6xyRpU94Jmi3/mZvzUtIuxS6CWV0rYWrKdXSc34Ezi3Q14WfDxOwyCI84HqeHHcJgtlV8GgBMGWH6+eMfLYvZr6l59sCPIBu/BJTtSYPXdaWFnwyOubZ7u9GzmMAOGwgZmPj0NTxUmzKTPiv5fddVgK2mb/NZHE0lRnMqxFj7xckeds51v6VWEuoP4fRIuo5xpdYK3DjdpBG8rdjz/w7EcKBqff+SIjh2zFN+lGd9oVRar2B+4y7rnKaxWUMZuxVz+D5HCM4oqjx/j5qVTrWJMiRs/uYMSZ6IE8bXHCVVbC22AoEyo/bQoILm1Vu6NELi8JUqw8s1/6vff6kO/AQdbd1ovmSCTihjEsU1FBmK0dntLL9+SlrjpNXnoQflkhSpdFt9+35//L7fI0/hff4HAoMx14qJ4nWFVFzOp0Cw8Kc3TYI4MOGsM/hiskhCb2k52wCd/JV/3eKUogwqexiaUbz9mmktXkiYVeilK/xJa1JjlnyZbWQv6tx6oMSYk3AeBhw7DiQl5eg+CDwX6DPaxVsiL/xb4y7IaQ4QonIocGClH5hjYfrl1eThaPbax9r5US3XmMhwKwwCwuH+iiAZQ5LSK3WC9BtR/zOoa+6tcZA8jJgcblRW4dBuWMsIAx335Cg15EOTgfz+xSNYZ6lQ4ooj5oFDkFGpcI0zJAtcW5a6ME0Kg2RGffcb95dj1OGi1gY/3lzdAfoliJJmzsD3GrITK3ybiCDE0eJ+LBrSBcv4gu9XLUvFBZtC81MzBUFV4n8wGVsGZCZEvHcj+e/ay+/lCTtATsl5rSY/bhb1zGhY7UB2Sfw8p44GNWuFyGVJiTRWczIsv4peK9o2gAVokQnJN3wZI1su+Uc4fcYaYPiiQe+ed0IO/i1Ex28hjpRMzMypPD6BH1j4ldxUnMgTWcctPvVr48JX2s5m1ZsL20AUBP5CA2DBqHcR93DQU+893mb2es1cV26nRrVrEVAf2L0IvsPrIZyG9vrk0+eK8INbmou50v6sMYAFYgVPRHi4T8rfJf4YExACOX6/dJrqD2h7M+HOoKXgrPySNyxtWdvcO2ThVSx+tffDKEDI4AJUEs92uhbPzTEfL0kRKqy5FRNNoHz4MehhWZkRyvqNvtol8qlBkBwpVYjD1eH4ilScpdx9uwTTpoGbybT3D620EBQJ1WjxSXgziI0fDypLbJehoqVpzHH15cIMI1MurZobZ572drSNjFF63pNiHkwF5FeNNxy59xckjNVEenheh1fSRJl4F4/58o0rK3CburbFltYlnSexi8At9AdKXbrGOQfRqDhIiwuYog0Te90LI53whqreafzh8qcMSv38NjuWuMm2Kmqlseq5yTscLm1Z/WcyO4/Wq0v3n9pOH6AY9GFxwRx+abryHYudz7KLU98+sT6gwxvqz+76eyt9ohADWzCZpCNqQLT6jwNjcWWfErbS83c4zEfvv/NNR4ONsHr4QlB+X1Ar4QYxlu3kVjYCtU4k8DVFAupa8iQxpnyI7o3fMELvK1cUxu92JbbhTSJvSJ7iS7V+c+coaMAaFzjnD8zbzZZou9MluJwLP22PfftfpCG/9/czmBvpiEGs1cH1w0cspWatTOJBJ5BYCQpwlIo+SDg70YkQk8F1urvBWFbCvTBtjobx+s42fndA9jHnb5ThC58jw4TKn5cskXE1AnBvRWXTzVNnIndPDdlSBu/b1CL5SCpG4OJnfHWvyRscnho+CPMGPObj0nRBtQCTrHd2D2Rw+4oa5lz93kVmJ21WKI2z5oV8qOvu29KeDZjTy1NGr8odGmpn5qriIteGtw5kiL26QURA6WL9k42J+srPJgjcMVJ9mSTuien8nyM16TiSby2ijHJcTGFIJDxVLM+v/gsCerdQYXNBH5XJ+kiZI/pjk8x8EqZAHggfH9kB0OTdYcw4VMzYpexJA64Jabww7wKcQCBiPXoa/FNgVPxMEARj1UNjKwogcwcuclgokbNn8NwVDSoAQ+ZqVwyB9Yb1WOwzNk4o8e7YwOq939rMWlARBnx6T84PglbrsgGLVso4SFbVGQHHb038woLlUm76Z98Qw9Ate2zcrWHmnZgOGX4EzWFLPRSPnpz39U3zSHLh70ZNV0XHfItat0SbDvrkxRUpfuI4FRxsG7ST3nOf1IAnWAnf50Le0MRFwqtTpWVZTJapyZUnAxzwbJkPVF1t6G+I7mEnEPUgdQi7rB2Kb5TgEma2+Co6tZU4CyAAgdWHscA7RRQaWZnFpNBVkP39DBEPVq/xfqDIkoaQtNd5NfI3jZ43h2kVMOT1RWZckhn08Aou+H98e2Jj7hixlc0Yo00d98k/vwDNPJ+D6L/1HkM2/9j8NmfFXopaN62LLb/F78f2G0hsChTg47PbfC2QORzpcd6gMS35oYMOdi+qhZb8+577Lk9x86laIfDWy5s0FvwlTL3BlKU6MKZlub1EQhdaY87XC4mgq06Ce8IJHFYCYaCB6xNNu1mBrRxqxfjKrhLsmYGq4v+8TMg0IozWDackEpHE9O5sYboF7THctx61SYABIB1QHo+xf5pW0ykGQfW/Fyu0Q8K1ND8e0EmRlJcig5zAJjbiWeuF7e2keWsNTDZAaq2I6KzcdslBmxaAgGx0TIn1shbmMdmeRJGMDs9bMKxwbVCO7A2Ajfe+2qEk2t7WLIZNZuzuNlVZ44Gxda+wK+Y6bS+JFwuAnucCU1qJuz9BeEnkRkGqLfbTsbu/UHtCMjchakgteB/Hst0foW5hgFiNKyX4syRSSUzewrQwLOFYo0m1MvfVLiuJpsug1ghHnO+GaVe3m38nPgvpsmneetvbOZ6xgcpKAPJCn2fJVhGgMRU0dZtH9d4LQXSwkFauw5pj4onIDIMkKIU9EZyhLVCV/8AVbFZGlFTBWGqUTArVtKbsOVETALgta9AkzBmAC79jvFi5NV627uZGg2nBv0NNEkvBUvtShjTDjtxBZ8kXs84Wnku4h56V0wP12/8UiuRRHyHbkwtOo01BDXb7M2eAl+C3i8l5/kZlJ4w/u8HE/x3ad9vtTGTn9+pUl16uFDrI/co8Jg3koq9W7NmhrlBA88tN2Ix2tLFxRpm9d1IHpsMc3kuLNjo88jjaDzVNbNsOqsHxYSzi+3h8S85kOPgUqw7+K2lmfgIRALA2eGKx+cC3Sv5s1tAGgehHNSbTgA71/iY2zpeobp7/GQXleGJ5O2ugKgXUJjqWrOnav2nNGWoG4g6SBTr6BSg/mzOXQVSLRaswKzcbYCb4xRv0kYa5XHbtTvhgsplLftGKSU1dJDk9gH7V1K8yvNgTzqy5qH6DNcaLjIQUDH+DLW7SLl0iZL0SIXuFwa6qIkboizgT5svSry/BZGf9wm0ww8CBMAlT4czR1R6BL4iMVlbd0c8kjCaTq7/ONJ3GeG9zeZahhp4dyAFdJJ0P4wSxaMqDBVwztmVHoDfeNcXDxwAP1MWm3M3Qmv/oA7ddaNONOtjY3OZ2KnoBBtA6gQw99Y/kfr5+GAYKPGYthZP4/i6t1xeManAXFrHtbxoSQuHQ2w9PUxwAeUYua/J/hpPQKxHd1trBB2LF/IEjZd+mpAdLqNf1lreI6y4Yo88dDmG/ZwvmzDJGNt6UMdEHr4AABjgI703V3qSA6D2WkqPaDPlSH7j17TjETsG/twzC++Aj08SjTE3CEKHvbL+X7mK0eQwSffR43V2bgNcFKZ4tlEyxU8hS1noevf/4DY1tX6zOnC+IN5g4vBEBxXAMBRwxTQhoh0jKXh+0ftOgKtiDvwGHn3Jq1eO3sXd+bWMgQxvTUuGvxxppIQX+VNccy0FtTfWBb6Zec9TjE8YmcSysXMD21DO4RGhlL8yOBZCSGEAEWnATWYkY+Op3XjeBE39J2r57eqFO1QMXxpDmDVxm47A7gUyICt1faOhKGkw9QtTy6iC/ielUcAAEGrP5Y7/3Oa5ETSJQqplPXj+KVWxULKh8D92XU0mPG7xTKiHnGwWvLI1Df7HleJQdRexbMQvza/Vlza8mZmrzNa2Yd0XAMUCXpjs2DWTFlhnyLNszU6G5iPd2LvtQWDrs3tAne3sRSJXgt7k/hFit7nP8CwBFMpTMRWPw6argRx+jjq0iljf/74LtxNa/8+LfFxqMcWO9HmGP23AUOGP/3Tu1W/6mE/GVNT9f6ulJbq5LxPIJWC9VckZpygIgyg1laRf/RDnYQi2U5KXfRDbIfr1agmICnMQes2Z3Q9PgKiS9k/lLfqLa2NmXSJC3IwYHZbAfbBz8bLXux6DIM4tAC4x75XYgeq4KjoLXfsCncUC4OiWOyR+oVcyNtnaNuYpEZTTNe6OgAdV1K5zuJiYIVz3/dFEsuqFPXD9sgfyK1IGhod1S2QvXlQT124wNiEwEN7/6HM6FJ4miuB1O5Qsj3YEwT1dDJNdmnusin/d0SjeCNGpJpfNYIS20uf3BnFWM4YBmJwVGq/7Lt/yop2R8VjPtVIcGJuDxMSHeDDBejYEITcEJJ9Aj043M/PQLsqyBScsQMmlg70InHiZyOUwuzqZPXxMn1HMRDI/y3VdLcjGn7xQ1EHg87ZXoz8orNvsVvOfO2PMhEDJ4YBRof+oYltTdxI1xIEODtosNhm2Gumgq7f7IpRE16fs8eHqAwqjzgMA6PTDVxQRe0Gao0opPmAb4/ggVoOV/L1CIfHBvAtCnsBQoxgRB0h0MhoL11RfnYZMo5E491DzAq1v+D75FFJpiRk55bMSbSAo4Hn9yX4Pm1iQPHBy+9P6CZoLAcxgdsY3kjGaCOBjrKJ9EmbusUHchvXPnIxXPuucdnIOWtrUzNXO0YQAEpKNV99Met5Ekx0vVCfMNZFTAHDzjw21Gk0PuLCG7ev/4KxrYAshhz1SY5VVwNbX4AeThRzaZxANZaqo/2tGnE6k4tIl0Jypp+rgS1mEL2+RT8TchqpI6hEYLaDRQYeD3pkLnOghC+4rNMZh2GAmsciw+rBQ1EjnbAPYa7nRv6sA+zmv0xBnQD+dIIwLCWELT/gzXwV5tYupROkbvBCbYELAxvinVFOkHMt9bQ21MPr8t80+jT8KkWMlg8yn8iegjRkB4vT5mlqAgH4HbtA9/En8mWo5K7KHQDy/BUtzC2KRag+sxHFW+b+fXjvk5Bd56HKD99A6PrWmuATCtEPRADg5D2h5G8yLQo2xKIB1Wn+SgqXXvg3ESHlgL/97bh/PxVqUsiww736kv6lJL4V3q3e61alHZcjiIaUz287HwekNHjftMn1xqWvX5xVp3VlKsMa3R971zDtGiF4D2m3nQzwAUkKVPm7LLfDSCq5NHByGmysD7aGxJviQ2+8KO1cG0d7EjC9zFRDJg3RXHZFHcEBi72lACE338puUIJyXP52yasL+uujrmyLEtlk0uBIzYxFdbt6FOOoFxOx+EoW2KUwxF2Uqem9wlRyJbYYWJZut/bymnFr//j9yTUPjf7yIM/luC+Ny90kypj6uJISf8DfUaf2KkymlSLtPpL8CZD4sGCieu/VayDfmdoJR5/MZvllhkY0kaRrbwsD+vrbf1NN5cwb2Q8hPgPFpn0q5GV5Izu8CcxAlkBQA4arH6Wx8Ig69pdIG/MbCsUD4gtwbjl1foSiYa0zDDEMiJwubF8v456VG7jGKTdoQ5Gptx1PcJ4uoKkTPHF0yGhm9qOY/1/eJcRH6L0+Q9x70MG+oo9ro/0oVrjQJmnbbHURNRLksAKbE4R7gB8CDf4Nxo1SWavsi7yr1i00/hNIFFF3vI0TQc3tamYlNM0vbfqO+rZWWd05gIzLOjw+H4enPcDTlkVSm+3uPVfeQ2/uahz3r35Oboq3q0KeonEU/FmC28NcDkbKYDwmFVEB5Ch8PP1HRJHX4eJHZl/UjPdGiVtNiL0znyQ2WlS2PffLgCHYuUAjAsTh9KcIqKfpS6fLUo5w/uP6xillbdHVXw61A2nfokAvXIUHUIhTu9e6dPty78HvYk86dBLrBIRI/LCG1qq5p+dJ1foMHgv0NwRI9882x9+sGaWB8b9QIaZLzMNoLEA0m69AGoKlEd/wTkdtVq7r/UzvQ+F91QQi434QrGRU/wwR0o23ehLW/b30QZx07g1xp/WTZL8HwqIxgpteWnKH81ZNQnVQfzmRLBqaVBVnDD01Z9/CgwctVm3gZME5agJLxmKLaBb2vKyblWJAUAfbhYar7buedmZ9hrO7TsF7PuiYfGEF6dAvkSeyKGlc2vfBg8ZzlZ2sD5DiIbIv38gURx2/2ZbKMlcLzG8WfviBury16sc2ysuHHykMQfymFZJjMqwsMvF3EfFFVDL8MbQNuO92P4jvUbEw2hz5dWWwIL6YeLKP/VFp6eOe5Tk9nU8dOHFW/gmJpox8L1FBTmlk2PHhAcR1RvCNrZnhBW5kc65LjcxxSgM4I5Bz5/CYh7f1HNQWH4SvTmUKiq3ydGMJaSa9Fahy75MIeAMnbdpWPBvG+0KiXxOiuFQuQGIvj3uFDlK/B6YnELWH9Z6Tm4EWTuMKZ9iypCNBtROulDLGsqhh9ERjh9nuGkgGc5HgA1vMZOi+A5lj2mCioocmVVZ6YKmf7SDOgQg9jCCG0C/z2zCSeo7N9qo08ZQ+pdOivDywcahQVG+sodyJB7ftqRpIT0ohk+rPVgKN0DVdPodF2RftvuX5xh9jonMTwKg8pkdcHOCCq7+Hbe2Q0NXky6Ppvir7z0a8NPleJ7OgiEkKV7d+qJej6ewV063kDI3hLWSlgpqqXjHv5NXyb6EWKsX7eO9xXgMJhLVVWE2WvSZGSuQYt/v0FOtPdTmzpa/QDfZdJSMwHCEwF4mtGf0pbzDqvElCGKRZsMXB1SxijzZiXeT0fdRLd4Ejxi0QxWJEe/XWap1AJndh58w/lmBRRU44SReIYiZWtfuwbd63sJ9BBBdwGDaN0c5Fxgyg1AZaBgMp1IkqXfZQLXfddPmz/8yIp5anDur29+I+M0eKkRUOgnpkJsyZbhbXC2b48P8zbIJ8nBOimcBsf/047c8i86ecXqeHffHyZ8ep4MiMFSTpDxSCkMblYa5u/Srndw/ck6HlXIzW5/3oZHiAUkqQ0bmqKtUDKOMLzq0alB06Fy3SIsrwAjgYkAPTXfYh5z8yKLR/CY+2VErXnfIz7baZl3sbot820zWJhykbWH0zxuO1e7O/XRcV3lHYfL7PDTiHC4zdgKOJBtIYtOg6OmlLTMLVXGnP35v5lrL7mq8HGFDeQMRtbXMXjZLsq429/m3oNdGB0S/1qQ94k3V4xPRXAdai7ZOvNCBqUn7qW+4lV/Diedk75ld9jVq7yUOouNAEeAJmlDsFjKfGJt0ovagU4B7sUzGffmkqOfi2eX8cmEY3b8VzADC8bmJzJvYaifvLDwRWT7+7U2Fd6G1cnn1vW6y3OK+TlGTlr5chLjVIiDSyV6NIVnvNJwLwlit4it87uU8mmcKh5n4bc7Fj0FvDkoEItS9PNTcRwJgiCFexmJR3razVpR2f56vFd9zxa3KFRqktdWmKz72+1b3jsdDk1UjfytmZWzIusk20yfqQ5TqfeIY+ioUVl6btGROz9JSp5DG0CEnatu7QoXy/knM6oKWb8KHMxrZBSbzDV736fqCA/HZVjxr8nGd09KGonwpd6EIavM5HQyFz2tLs3vthegLKD98hmLanoxNVzJ5nYddhXm9/oxAqTnrZMIQoJGjWTQ4kkZD7BNMM/sGhX8yYnye7KUXrnu2zF4rMHKsSTBuUv/OG2lGlm1PR7rKxfv+j2cOAAvQ0osqfiiYJSyb/Yj0hWGyQ9fGmPZKTZuZyTK+IxT/mrlkdgZTgIOD2Ebiix05ARlV9bqe4TsWNTKIQ+ObbU1cqHiQgz5TZBtYjjnLg2IyWzuX7R5cbQHlQXQGbYwvuK3FJx9UToSITAWGy4a+XMGkYtofujagfxXhfBSFzaDRnhom1pZJYLnJpQbOVnmIQvZpNbb7OfOgtaixETDtSA9CFbgXYbiXhienZjzv2TmTSvq6VaPrZPkDlU3GKLufyKzcKkaIywK3p/phzr1mhLwpBTf5hffPLQsHadVG0KLJp+nNx+v78MsMiX/OeQqRQcboWqWf7v8AwBPblr0yJKQtRWJsXWf1V9VthWI75T+lXR3EYG8gT1fag/esIM/lQaaJ5BN/4Prcb5bqwzL04pWRTgM3jXiA+bGdDMBX7dA9vkfxMYypunZ3AQIp8MFto4buo9y8+Zp4a3FrJ/kMd9cJkCU+PGaXAOyTl/y3A3YjeNjyPc1z6eC9W/CdHlkgPIrccuXTAZWMMtnbPD9Q8ZqegzY3DAIEpFaFCrktRTMjnHIBOzkkbeLBK3+6Or6NUjDHkH03XEQCWlic56RwyOY3EyCQYtRxFHMUg2PnVNPdJdr6+RIKr/XZSgxR6ymR5wAECm69e0H2v/xl1YUwpEmZw91tbzWaRA9JV43i3DQlI03Ajz/k7pNOCODcWQPRfYz01kgtx/5XTLJfAqef4m/4wHyO4SOFQMqt2o+k1BVwp/ZlROG960RzkvqYx2WK17Nz8FWUj8CBVZ6X7f64sbMluGfXMJtJC68sh+hrtNaLhITp/Pt4Hu9pRbPa/PTGIv7rJnA7bXf3jmOgSQ376D8U/w/rko9A6HBt1Hd3q1s0KhKgphKQmrmSS5QtDqOucwv+UUmDNhWv2kBgAK3qzmlSbYlRy5wx0Q+49u44cLY6tH5snWXcNTzJxxec/dT9Td0ZlAPCtXMyv0IW2y84VUSLGvGyGeUjukq95cpqfS1PpBNHeb9kVcDwjc8xvmrnVTBGsQlwzRSkXRQ9kAMkCJdOxlWCx9nCsmzMrdlf9kq0DirYYjRSNVf1kmmwUp8WZgo2bu/gds+ROfJv03xixtwngoTHgLdoG370PdNTfSLhyvpIwvln7ptAF/cEwJEq9U06gB+4vqavVE4KmBKpfFeAZ45LtmujQ5l97danteXpD7UVIuoSzsvSJWDgUyicrujlVgtI9p7mpQXTIHMFeQiJTu3PYW85BA8mFYTtp4jKi07akoig4Y4pwsyJci1rLoDNATz1lQaaVhazmM+wWupTK6xPkH0BBZKja3S2KT/dq0lQHcvlxXWMuvEkUzudW1CrC01jqaVZZFj/lcWbcPrWgvQheeG4qpV1vN5kDwY42KeYEcSGSTVc/lEpmbkFIKhq3BaLWODC3LpNuZl8rXKuXyNdAu1TyWkMDrFwwtyxFQJ1EeMrozpAlvnn3X2vzIUSIuz8IKdsrW7nj9DnAeGo79QNsit561/orGeoXo/No0EUzvonIFDHrmzif3NFWWm542VIB6s+kZb28xD+phOgx6BY+tQLwEMaTd8AtL2T84aDHX2vk9xUt4qefaZwm34WG+JslWncdvzTg/cJ0ZwpoDZNSyoZJS1jYU7LbDHXZioYz/ciqBhDlb8DEQKui/ME0ci8oF5zqi0HWti8ScFe4Cl5MkTt2/9/aLORgqBAQAoEhPFKaP0Z6t1jq2sGg5wz1PkgnivxVHX3KihOvFAYwgPknJ1wrFWRSVpsrBUCJsUaX49lp92yjo4aOec8iySifUTemk8CPkY68qr0p4BnaYAL7waC1x2pl8FWe1Ld/MAJy/yILtiSlywY8xO+M+r9br3DnGJdQj34tEKPMhrzGhHx6uaY+PKt+qOkn0aIxU78XbSmD4Dlb5wC2Du4hwLVWzds0fX/G/zCdwHn/EF2qy2qH+n6wRGcAiRxSQk2vN0XhoUKK17uDA4YkGUebc+3Ms4bkN+1AVSyhL6GmMFbZ8uZcs0u3dNYUVK8Ug4TRdNvkkpF+ckcEgcQau5n4EEAKA2bEPzM+S8PfU5faCriy9Qtpjok4CvDvaWIp2gY5uSAE7D+R8ft35gSLkDvdN9lk2HuQSqqxTEuWTbdO5TrcnVBKpoWKpubeV+DdsoGNscrJrRo7I9+BN2/YxqRlzm72iHHbo2R1t9sv9n5bmPZTclMVXNUmCbraU8rAgVWKrrzkPf9bfXpF80yvkNU1TjaIqo6A85J6oMvFyhIfFqPxYfMTRlshgE0JRtqne3qhDO7ufJj5a+Ybgd9mCFIOED/G2eT+RCviY8OsOZ7Bay/QnkQ+PvelteeJZpr3iWLHZk+XX84CvcCBQsRx+8ZC2t4Iiw7wBcQQLU/z44Su0xtwxuaRES3j4ch5WO+TaHrWk0QPlo6SuAxawXKYZVIxE9gURsVMfTxhlbeCSzgRRv/wtItK7QWnDXVCvRSroOvaXeZ9A3ZIj5S0D+cIqW8AjikNhR8iZIOUNt+zSggiQdbw0LfzGasF2JSh4GTliMtAzrtEmjSFu511yHo7Q3r4uFJ1RIX8aJ5UH3ew0BjeN2+Spu0XFItEa6DBZDbVfa6P0MVwP3YhFrr4KzdFiclcYf3T0hdfheohDDixciloqEIkWHsYAcuAjLWz6sn1nhJPkjTRCBWFqPQoXNvv3lnzLFpe4LTno6rBoAhihRlfoV6bARC/Xjw+qaJ90I0q1K2VzzfsEzOiW8+3sL5GhUCMmMP4smlYAaYlNYaygX9htiBqEuIB7kh20oe9N6JH6yofnioXp5kHQGelC1h47/3DCyKbThBu3Mz92q0PD7Fw4S+Q9P5GtB1B0nWyMsu7Fq7nqVWhH1Z8RwLTlNC402R7nGQ38pRFZs8jj9ZV2GKKRWKY8jzdVZT23sQCRDOB1HGp6j8JwJY3XdBOlxCNoYbwzCYugRbApasL/ZpeTzfUMdDcM2DbtBtDRehe7rbVaQbP/b/j1mBTVZtc0IX1LsN07S0198UtgvVCQgkMGjpNAVl26Y/pyGWmcr6s+qMgeLtd/YG65nJBpLcN72kPVhBrzuidKG7kKQuJi6O45qRKnQiynQSysFegbl1l6MBE/8Sn10bmtq6YcUIAtwSJTK42XlUcdp0zJ+gGBgwhc12zssCHbvCzT+KxnJE0hmsETbbwvobpKv4eKZA+JisDku9uzL5lUJmWixZggsPs2eYh/P3iJNfCugJRmm0gO1jlhEcHWYC7O0Aqi49zg32JinIx1GbHYwWyvcN8y5DNxdom29nO+fMgO2LpmmHkxpzraq3q7lttwElwZJQpXCTYT8Udup8Kqp5pUxPrU/YwAaSO6BYoOPVO0iKHsefTDNnh3kDwI7Z6OK6J/5FYkQyym8oaETlU2Lw+byT+4AthSaF0jioHGkkh55x/Dwht5iKxLxGE2dbFlYYiHgbLiQ0GX4Wkdwv6m1TLYFq9YakdHLqeTg+n60dpnLYryO+XtvWikRWagXruNCIjwTLebSOAE3TzupnWR13GuL56dJdmkGxDxSDbNru3XdRk2mmVizhyePpgXe7tmtAUY5JSmkOGEKlzx2vfOfFbQLogLA2Jt/wn+3sfA4d9HgvWeE3MYDjAF1SC7x4BZzlWe+LuMWm8SLVluji43WBDkVzBIIhpP+gx1xnQRXbd8rR7ln/J9PyIWw8K+g8JAXOUxawtOviTFfVOEGekgROd3ExxWwI5cDBBi74nN1HxeEhkLk3561hgOK2HOBU35SlBHdQX9Ek2KEoDXMXCMear4q98+UsDxeA8jgxcTXgPOe/NGCiPu9KwSXwaI5AHpJGFafvUId0aVvnGJ/5yW7mir5TvT73MVGnrMpebxhEZiIPPbJJXjgzRct9zHc6rm69Ovos84JRms7BYVg4zLp9KRRET925UOKHURT8EvgtEHF2mIEnpWj4he0f82AmnU9hn8bulGFKWmWB0jn9EKMxQk8NAdVeoA86Sew4ZfypZ8RLuYsmS1WHZ9k4XKB/g8CazRFI1H5VSOfeTzcWYNQe63Oz5EfdPVttZulGVA095dAAPkP4xLhOtyO0oYUagUhT9oL6ObFaSfKVeejCgkrPBFBB8ximK8DQL2mKn2fRJ53lv7uU//fEWgpA5Vfmma0YcgIDF9PKAkImatCVCI4ZJm/xMupZdmZjXtezeDhv6kEoG2CqNlv5Efzwg/z0zpP371PKu1rM1+Fe4LKDn4zjK1Y76PEY4i2KuQUIbFuv2qom5WTYKTASQigOXoNkLFNm9E69g82b3/sjotWDdAoUqTnOTYwURaeqqW2gwpA9j9KP0f0lBNJaXtW9tS3bThQbnts4fsl92BhIqxIqcuVKqlzN1lD27VjV6VHpR8kqgaysPh/l25FGKZM/ALMXw082TL3zlJEXEG+OUWBqBRBdG+cWWffTMhqAt9NGGuCNz+eJ6JcfGrSCPCgRv30+lQQj6ZMSKaSYTAWUfPxFRfTWm4/gO+w9bdhNZZkvJY/2Ov0thv0yZs2zWTbsbhLxxGo4kDRuUhnsobMbf8ov+PpjzGyiwnmoRJe0wxr5qy34urGfXYYTinuuyGEumCZoB2kthMoZCs4qxNU/kihAjvGmYaxpeOu9icGribiv3WmUC3FPZ6naZ2uo0I/y6TUpX8i3tBjATJnJbQCa1MGTETk7Tzbr1o6ArA6ThyzPBSQLRrhEmxm7rwXTsaIJgKHweCxiYzjMJvunaiHW89aBhhcBv6sVUH64zQN3WFVqh05OTTsZuv9IdpDmOqqK5twhPYoQqvGy320ctM5+7XlKh/Ns1ZvCthTatupSL2RW5UFWU8njSY2ijFRXRGiynZZAjB7SCI/Ej34g3QnJh4s+IpWPM7fDJVSOm8/0OXEJ8Rcthge5SgwA0bzz8v8rnYkVYG58hIuYqEikR8NJISjO3jB3oHrvNdtBPQSPVj5iNWHSDyBTeyfOxmR0BAgJJ5tHYIg66/GyFMuh1fKsuViWkvrmEzAf1UkZYua9OBtK1Rfbi+UKZM3xieKTEtXbC0rYoKvHNVWNrXL8OdWtdKEf//dcuN+AKhAyb5Ot13WggU+qhhapLZEalb5vK9RvYgfodfrcgc41EKQ+77tjZvBaoQDs70uYIqodV7UilJFPgF+1uY/1BG+9OhMtzTvekKM5kFIZ4gwwcMb/vT8J6uGMuPotC5tHLa/aXux+JbMwbNhNrGZ3zQ80+UGGxAze58u3r2imHTKN91/P7sOCBLU9QNPvRZlHYCMvUkHUmqrq++pluT3YfcxvoQnqp4Vnjuea01R6s5thNAnhfR7kgNPhtJlEy1YHvyt6SWBp0sbEjqpjO7ncVfx04XuzfVikZbvmEqXS9MnPYiQQbRuARBAa3o07lv0ZW2RBxnc6q0Un/RFd4e6QBVwZgAyR2Y1pbfuMESmM45+ypqMApnfRWCR12E/pKTWt3AYJQtBxEYuuIkLXC5awcSoRjjG73xv2G0g1jeNXbj/ei7t7r0MBJG7jg5CIqeXLP7ldbBEHNglqT8uxNSwwbPYlpRBjPseB2JAhIgD7fjXmkP3dKbDOIQfmcJEHl/JRawHbIbXQFNoEa43kga6qbLgeR5Yyd6jYAFqaC/TpNK3uAY/DKe7sY37bFcHZeFujkIXzh2DRWfQyUOjVYKJlfrAg+OUf2UD1z4nOuoOehPYVzBcOxc6NB2dta4DNAiMYvXtOFrY5+AekDnwkNQis/bM3ldXTBYDeMUrzh1Sa93gheCeA/Y+cUFlLf2o1Zm/9gfowzYkpigwglO0somA5VRXC8W1EqHWMw3n8Zv54kjewmPVEDkWtLVIV0ZoFFjSs15k3Hjir4ucgBTYOaD4o5u7YPFk9630W2OlVb2OnQdiwlF9H5FKCbkM0d4lUjTB3IflaLPmWVXtnPzwoqmIU0qIF6Tf3nomZ8l5J0WTRoKNrSyYY6GVUC6ImgSGTYKWw7HytK/GBjsWoqJCsFRnF6OLWzbRzqBDJjA4MVJzREplwMQRkxGGfDCI5wUPqwEGw6jT61la6T86HdVWMyqKlTJSwNCmkGW2alkL9eEkCFXQ4AOrlFBXd9I5Hzgoo6QuhpE67MqNSFP/KPIeV9Nb5AfekedQZdVJ3VIcbL3YI8qAAGFTyV23mbLpzl13K6i6+l0vQ0L2XSL8V/ZuaoaUz8ugJJrozZliuywOHf6k8Jso5yj6OSuuzZ3VuVdS1tdIQcyR8fyNm9L0PYVRlq6mODBEFPvAShY6AQ7uZp2vXyu32HaIdQzD6pc88XPmYKNuGljmxo6e7VbiK/wFsf5/C1LG6g3LVg9tC1Q1dxpLHJDpmyILno4wOHmEcUG23yJnWGA298BruL+Rjolo9IeDwEqZeZbcjf6x4W8CLKmp/nmqB/j6obxRP+GDhlogMFH6rIIrArsL1fUmTZwiSPi1AL8DbaVwy0hkZ1bccx8EFX7SV8tFaA+FAR7Kq2T+tUDWIStAMf30GSFFM+idunRNSn06RlggzSD3c5FqbKxaHOL+P1yswft5iYwuZOW5iqQtxNaEK6Bd6yHwwnWgXYtuSxleW7ydO4aTR69Ulf5GpjEi4JsBX4hYwMP6UhZVqXJ3M+WA9Qamy9yar83rlVe1Wu1n7LLt55m5AbKXEiIQGrg2dSf0WvvKV5pw5B10GEyZlR4IFQ0EoFDoyiaKhUwIxOpIYGRXNXlMddevBqrsdgDNzUpgmfpkAwp7DYRP1qFny3lGbck5u4HVZC3tQ9c5FEKP89OsFzjIk1bl62R1fWN2jSaegTPC4xXbwU6alRdYcTbCwV8dBFeWdeht2hJieQx+GwQRLI0ZdotN5PlsIOomZ51ZyOO0nRD2Io57ZsrUmD3YCUzttVhIBuvEXLaSmAcPf4zJm6Jh21sbi1htXQNtGYuuc3QkY/UPLV/ftlhDI9b+tZvlxI2n8vUUjF2ZvCrvGLHv0ccJ+XQEvGfglk73WQtrs7zrm9QkODcrLWFOhnnAuFRkA0FFB/tGlmHzPJcuBnH464jXbswNJYYyFBiEJPnXjko1ciySXl7OFLeAPnDLVmPo1rs2apLgd3pUEEKWZRI1GegB1H+Vv1zNycjcSLMSw2979aL22qzooRaGnlNh9rckOeUuZrIHuCk7SVVoNqaqkbEXI9F+SKNDpZPN9ygGiXV7r354Y/M/bTkN5WtMoZBhLK4585+AyGLOOe0Td2rxRV2jF1iCgqxa+8QZdMKrdqIbG0NCayEbagg82cM6joz0xlNP2fJ35/LAQe+XhICKxvWEGTCq37F5ms79wYK3KqEU5u59EO4qwCSoqGLcTwDjYA35E1tOrezQYOunhHgoSlSvdWsC20aHx55NP0bNcJy9O0udOVjvStnMrR6E6lUo3BbFJNGwoTGUfj6VzL8SrLjaa59y0WNydCQVW76CKbrRCtv03mhYaG8QEY5PwAyiHKLiMVnOEqQ2/GLRsRrqYI2Ld55+S5mvFnQPRrBrGMdeEWC+jNCwHaY557409OZEFnVB4oDvmuwWacgDA60HNcqCla94mdMMuQUC564oxuyK8WF6eudZ9n7tpblrZwvXcpYSMnli4+aXsIAw4MRH0g61MxqwdJpV2tviyTx4BcMJy0UmvTZVp5B6OnRWetXeEFjcORi1L+EQUUzQ/RjaPuY6oGkamTvg06N4ePBAOK+GxTruTjh8bM2cDYD6/sryX0zKX86fWTDnH8THADhgBDqNopE0cRFSt5a/NdXXhzycVsLRSFBRWtnivFlmuTK2LkLNMRY3PhCzJK59M/5OC/holLaBAy8K9P06k4yT35kRbkMBG6aSuiPunm5+aL0LOdqyCDASJAQkX3sXMp7AsIA9iXKI5HO6MNRUlYgBva2bQYd9civF6Nmg9k4uDOW//+A2yFbL82r8qArIJvTEpA/4krHheZRve/05Mp07kRuvrC/60eWMY8OzaQE29J+ezxVldYZdDAjq/iD1+flVIySIPvVsdW9J8ujaYR50vk/Xh3k9uePB/Gz4Df1Vj8UqHYQa+lJEoHrcQBB4lHV/rDvcaTRvNNw1HiLX+2xw5GXGl50zamgF9+l6nUTCoBrzIWOmjAIvoUiEYf3LO2O+M5vWVX05pZ8htH/jMqqHvFGdMt4gq5Fdgav+GwChXexW9Ck8JX9dzRmf15QfP2lA12oJKHXxxWrVa31Mcaq0SlF6XYnR5bI4bbZbzd/swx0g5ZRJ+V2XDq0qjI6bBJER3ZMJkVKqgQUf7ppH3DsdyGw1eRrTrTooIleWLF6Gfd+UOkTDL21iLxU0G5PVSVh83L8odnDW4HN+qWUqEGurW7nFZWiY3owv0bfLseSar42D8qYO2Db7D8R/kcgkknQz0XNizRlzSV7IZmu4f+ju3MVjz+gfQ2op4c6WOt83w4UvLDRYxfV/UFGTyofA08MynvuiuI5ueCugVZnfKISNFerTSAwFNH5R6Kv3KTxkC90gRx6BUd/MQL96yj9jl5lKOp/cFdf6I9zJ/Xrq28C/XSbxDsSXbJR6JznJiC7ypa9j4gpUk381MwKIXl7pL80BsEhPvNWG0p+3Cy5nI44Xzg7cEjqWCbJxNUctwbzBuGqwyZ4ixO/G31U/bXxR39B16ZZPoYIhcDXbvkVOK7rDrR364xFtion+diWrp4bDAl1xesbILAI9TJhnskUrN4kJIoguy9v9/W1pQj6Lfclt55IqlDy1HTySe0Vr0+CWy5OM54pKP1onxiIQ2JIxA25B+QGNHtN5UooSWi2ulHvtq0igmtciVH92+HshnIlzulsewEFXcwRAZ79BGG2GH9A9xVz5W3fz3tCturtaZz/ncsLh0eSJAkq3oT9sCcQmJj2P5rtWtSCc6iKTrYX/Ed6Ac0aJqCoXGl9SA3k+ZDsWgpiYqAu3dhMHYVVXvMJfNCmCCLQy6faHYDJ0AIvNv1pklqm+ewTPMM/fVq6ZfDheBp1SdfVLKE3I+zy2cDS9TzHGczSY29/0n6jhHntpoVsN/Vn5kK3NWzrwBDdj0xXzyh/lUdguPl1r5vfT5rPPrR4NUrLhR1xbB6y39FouWv2ELVFKPmYvqMiGygt88D/ORdvcRWz83MNZ/gW25djRgsqNWerAn9htbx+rRgK4U8J4NY82Nv7rY/cQarltmi9E8oRJ+BSp6iYoj1Q1X6bC25XXSpSqyr78WQ8daBhW8x7wK370fXjZcBP5Ot0gbMdp/1896HRSsKRSchmouEaKyoiYokOGtyi6ZwkXV9BBZLfx5qPF1o2JbLjbbYtUSzY/jhhdcTheWjsip2gEP2bJs2x2b5QuouYo6IkXFRt2ts2istz1xD4SxrtLthV+m3rDlEXVgq6TDjLNTf6hep9halqbMNkEzhjt6DfbcHx6PPzaDrbJnavpjcraKLZVgjB4WHdzvNuyzdOxatttJqS9Rr3oCy94D5lnYC+fztdDWmkuKRu62T7GO1bmFft6Q2Uk5iT3Gs2M3hU35Bb1ALmSwFDRYba3kbKfQK0lcLCsbasvRGrCS4SxLHNflzWtjee5ggtXw6uqKjsADr2WROZQnfDawnBxr9X5Zr/HJetKRR+smPjzg2dmoHWirSRfmdeFeCRPDmW1wc+1SKxypjm2xWkPGmB3mLei+EiCCbdMneqGrN1cRb75E8kT8i2W4SEDAB59ZsLQzTWzwqmFkrtP3/woPFXj5/mxaA02Ev26xo1O43CZyLG5tDPzDMaClCDcFTK/J2+twUH9lajjmL/JcanGaZ0GHQ8LmY77ukver0CQ++4EDq2DmKBzLGwf83BigF1leV0dJ+XrYF37CkQOs+/lcQNjWCy7SJAbaH9iDB1MZ/5jPTWe0/PyumVkduX2N4+g7fEVf91mFVNgcqE4cBfrsMDmZBdM7f6/ifSgqYeGL3+rUutIdflI4LdlJF5HXc7y8tVF3QnpUfnRKZ31XR1H9Fmi3W4SIynB0D3tJjU5TuR5BweQnJpNnzkFSix604SNEH2zjWSPG9gKn4iPSf+JhQNRN2drGbZGg5HCXxI1oxpJv2lRmeCNF16lLfy4Cn8f8cHSsUTAdkcpaRQcnFUgMXeslvd229l78FLoaH453ncE4VriBwyjbpLZwdv4YwpTOmw6kmyYni93vRwssgccm8AYkZ1fN3L61AAEiREkskPd1xaNctKhDsaFEH4RYuoibvrKQArX2jhx4SC8dUquYbyqvm3kzpr+v0KZZ0zu60/SKWzT8UgTxAEnZDMGaMg+Ji09jz0jY4nYLNE4blXu9cc0B7/cw8AVmMXI0TgCWmOT4GH3nBH7maCABXRj1RhvVA3tH18OqkbtmteAxbSAfmxbXkYBZwFyQqYf4IFLUvC6LBgUB6y8v5teuSvx6Kp+qdDNlBAQSKv0x0arLNQY8Sc3QiaVDQZte0eoRL3iDLyKsOz0D8fDf+kQl9Jow1cGOrWlZbUx8jfXOQQ1X8ETOA+d2nNDl+EIvMxtk4e6hqo9feGmRIta0qPd2nsghTAKLp9xwemv8mYRqGmyuHovkTWDq9nk1uk8QmhrVRyBU2Im3nqw2Wj8IfCTZB6fsl+2lc5vS9SLEeKKBQJUb9WE6WkWqhrIHNEg58ML7alCDwpPydsQIJWtFJxB1JxEmue7czN+4l4cxGv9k5GWlfU69wqIEnr2NPop8ZC2mjmyLCaYMLmVKGDTySSWyMHR//wGtghqZiUYkKfDF3wk1rD+aSCwktFDA+n4GU+61BxjhBpIJJoqFyY6oa48h82j0scPCM21yF4hdtZhhy5sbzNQmC7jK4QeRtUtlQCah83oIDO/bs4nk7BdT2oqL/jKuXeIrf0yHhmbV3pRxRC26qezVoHaUK0PQuV+PyonBSFPG0ZkYfFKHEToBicPySXqRdR++P4GFtZzR/I7ZH3PZkIt34EGkL9vRF9QidaCYQvlbki+yeCx5uCsMGd0WaNnRclwAXqFJ0orAlM9t9Hs+xXgAPnIPNwWNf5TzjDwNHSW8C27WwcNfY91S3wPcqsZq8uPnQTkhzC8PVZjooREStMUoW4OrwvcZgba460y5ij+CySpLztAafx4O55CmxIRS8d75zaiKBH7xMOCndFbDL+Oeat+IReIJMfKfmoZ//KzqvRCVt6ZF1ze1Wf7xvH0HsDYAcxvs/9QsCZKooAbJo+3RMxEXu3DYJ4Vo/bjKwVgsCNuGV7tgij/1n3di9rdicZUciPYDemDqvHu2Y8mQ75+cRQSNkXRMJX7+sZAtKYmoYwDJoGBZA/skekXT/Wy8IY6Ew9JHGYjw5eteG0B/kasq1IRoXpITdI7u2AXersvwwU5eKxbVxpalvLmCa99rWuC13zjMcTz+PJrSTitbahtAH8rOinWBNH/h5jJWlrBLq9yOPS2bjwpHjpWM0TYpr1fzBj7xQ+j8kXUGMM3pucYDBQtl2yCz6KEoJB68Vwg22ugTr7/k01KjtiPgtEXVf0CfJ2Pd1bF3qbmvyo7I15tMA8WM77UjSbAig0KZR2AHpcFkwBDStbF6RrWrGG7xGqOxvs/3lLoz0uDZ10b1WGrKVDuJSAMPrJtlxRtBscogmzMx7h1k+QyZFhIrgWxkZGQ/hbVZrDddb4iZCHSdtt015zgAentT8un91dW3sOy5VnjF8ZOZGY1ROBv9XZW1wEaGNH0lxHq0GJDR96F0FyJPPfKB7WacAD5IhlqJa0jVc+zQIAbJ3xVchAUlvkeeIlWQEzepj81z96e04xuQKZREK4M+SCzmxJRNV/R8gFtAFhY6DQTJyMFgNNzNGGk2jNlNzphvDY2q7elmXTxsLSBpre3jRIlihzYtgz97c3UbAeJhJ4A66aNI23gSjgNikLJ5cHlyqDkFQfje6WPo00jewAl3dkcecI9zWKjv9duVQjCv4NH1BpwCQ8/I4GQIdbFr30C2F6uMPGEEFecGda6pp73u0QOttGzU6t0fM3xBELyx2uBsgcXiWB8mU2rxE+8yoGvm49btGdGnWaIeNcPO4v5tI3o6Hv/kBS6Hn9nPUtpq3N3tAKRPK0lh0ohvwS1QFN0cQtQALJj6MLdzTsrxdQ4f4YZUKwk7maC3lFmyfCB/pamlhIjcMPi7l6VfOBwWtl3wv69ogOUQBdC3Sjft3zwDb1zzlItKplYFUiEUxBWBYJOIAHXQ/AhG7zL4vC8vzyXZSDMDOtWfpfOx5ALkmk7U3/KMDgZ9CiafR2sWSC/xBhgwrxbVFdLD3epcNe97UrGGEJdO4SYT4Lnlpp4zKGisp+SSHGmccUsFkLB4ctqb6UhgeTRNoBfK+pn23iVKknUm6ar5mXpLEztaE9xNKLz+5ibNLiLW2IbHWjZaFcNBAUc4MYVy14RW4+Fw3y/IWuNwm2Uw6WwXAr1WmtYU2HvksKE0pcfsrX+xj83IA2uN+nKDuwJ5WaPX/rMtEGR2MwWuIYc2bhScGluQmNB3X81oWPZBpauMlO5W53UKwv0Wjh1yOeVRkwCxOS6nxXmWc1+84sAF896F4JGaatcjl5zepBdjQAqzCwZJQL/trhj4oP9wswE/yo6HqM42cJgSHTcJfgdsNjH5FXs+6bs47Dw14ECqZPl6MXSH97dAdLLRqn4GdZv2wj0Xo5SQDu3rC1Tk8sOb5TpgbD951WHxWzGbFbWYC4Xdj8/FVrxLBRKCmWO3TwWJkSkMXxhvnSqc9AvmTYzzkmJRnmEj4tnX5VpEtF8muWubNVfOGenvEobs2uac5v7+38UuV9pACg+EA+3Ed+nzmpo8AqEFpPpMsNJw9nSUGugFmM9/9Ck/AopVcUJ0n9FxZDurGmA9MyEsdWGhVbyV+VfA60ngv0lBMISyv/JwaYU5RAyiDO4uHWV+D8lXJsjpsHWjweDUd9EnlIZ6N1ctB82iaSlMqjyGxwIm9wBjPpJB7ziX8+v5R/3ZJKQm6RR0xehrplRmJ9yYs27ErKBUQc7sydsHS/2P5qoX9ZiUQ6iXKRC9Jvsu+ZJtoI3deQdXXrI5CxM7ogLrI8r8MTAO4TuUuThg9SqCyP/tvxFro2fGT7bGNycqOt12jmNSV9AZC9uP2ubU3yuQ6lOTUIcGiiLiNJm7WTBev47u+vYUIIkmBrVmrGqMYg/KXOECwk9ayUsn/jVZIRNqgJLKIhCfVZO16uusGggvEMWPtAC4rjc8EetHISE/dZhCB9SdAZd3YTCPPUm7OiRRvHjiWNNPmYGQTD21856S0Be/i+XYtZ3h1I32pZpWrwF4tHxjisbU7DL49kAN7lDC2ZwLqlzaMTWVmmRnrZX7O1xmBPFDgV+0Lzc/FjTbp+GcKtUvc3tPftFoHsrp/k7ECG1pOhJZI9Gy5mUG7Q998ijtPuUt+IaYTMGhYVRbZhJ0/lS3uWy6yjVmg1FZbnsiJPpOtlzc8ndmLum/2iL4rhV120WzNTzBstwwKkWiAXcmDpRzNDwzf3qyecXClqqVZvnn1q6/BK9jI4eu28yGBVnSiutcg89InUujq7vu21U6kFc7deHGhpPi00bsDgBNUiY21FbyC9ToZpEHZqjuxqHHRqLAsyjw7RGTUNBy78qvKzM4PrEHSCJw4RXuoru3GQHlw8Ps+GNdTOiErGeKHqFCv/sZQmyXVC0vwAMy8+EEkmc5ELUDCoIM3sP++9cGq2Z6uG8OjokzNcItORiE8dHTDocYUtk+chZI//pho2kA+9D2ZwoLlGW07cI1H76LLdavUBnmWT4qKCJRDiqD6r/JNpbc5FNGh/P8UQiALkNzmycoAiku2dB6Yujyi76LbvusEUQeC+BSssuSgGOKI91xpA2iVJbyouet/TIZXkcpmCRV4RN9d4EQyHTDFZSEQSlEZvu3kIO/NyOTmVsB8crzUfJwQTKaT8rgo27Lv+baQSDz73XYp3yUOoAZmGCd0fLDr0iLHP84jNY5XI++IbLnHBrCDjcS58xjoNi1yrIIRzTQFhcZl/7YzJf5chUkD7gWgYi86R4STOm2XOvadJqfUthEMcIczSpVoLrYDZB2O8rO/fk8CDkee639V7M5xb1kJAioZRdnM2KminkwKQDQl2s//bcizU943CL+SAiCvoDL+WVzAoGeKQSVduvLEO7XZ3K7A/5XhuVI+yIFtmZpjPW7BYyG1gv5SFvJT0tp1UzRO8DNRB7PaEkwLpHXZXVxgHRDW+yKxTXwvV6FElMZ1hya2wgCnLbSHtyLa+PWEuX2H0REXKe95jLQ5H2RyU5RZuraFmO3gE9Y+xC6bcTUvQHeHCTYpSFc3IU7DitQPH3Fk1utQd3WPobidcAUOyTG0iWeYxICF3M7QMpoWNLPA01hzIQ0cxFLN2vmXYJA/sW7ZdgRz48ej2oERUgnZUhR4/8rdUp5HOQNE30jPJuhkvCd5FYrLDAyPmymkgmXhBh0o2lJQsRzYbmz7PEdFHFD7ZjWJ5ldQ1z8qnL8h+t2oOY/uouJAHeHz4AyVer0mf0Vq06QCuh+SkLcE5hiKCKnGDG+lEzOjHR2zciVdeSE6CVYBuj9onCmQs7tv2cTm7fI0ZrJIWFsiNh/iYIYv0XHIGldRHeR06j9tourDrvgltJXSq1Z9hoWGtTMOfsxs36sl2gpSDoCWJsMFUa+SnN5X9lMNJqI3i13RG/cyExL1TNxWXjljvacUOeXsPp2IlzWzhOnTcvFmXwkA7TpfVzKB5/Te5a6D5Jd9R8K+qJgsu0dHrHOjQUWvGLJU8wKMZQhYIs+XQaXRfifw9FoXQfYTXXwMPPBxTMTdswobPZHe80nCSgZc5Oc9g3zjY6EN8qdyzoZsA2i8afvPlIp7kbvXm4jwmBWDmuTZV9kKvfiluRj0r92phPkxPKgaFcRwRWbDzc6kXIGDEs8OECBeHqEEPnvygDDIYuldD2jyOIu3z3LbJ0byAUh20osNO13BiU+ff1NvmMQ2BI8QUkl4QdaAWMPLHUeVVtUbzgG0PVCLESJCI4/DdumX2V3S58L4tyr2xpxEn1dpTM3sNH8OQNj4LlEPeKKAsjdVPzCO3tzoDAHusmcHUPkGaf2bix7MM1K0T1DYN5l9G+rr2rBexhMrsNRiDovTHF/ZKhDQRy6xPZfCP0Uxn7PmZq383spFdQ0LBvCuZrKAWCQCJW0SHcYApDZXPiTJnR65QGdjqBe1vdHbH5NPBoAsSlIWuEzcIQs5lTeFkkjLDnwswNct0w/5fm7X3PmCMrYHLUCppFPEYo4lf0vyQv4Pvr4Q4kbwEd/YwTt3k0wAL/XYvtAikBFw7tHi+FbAbs8rZXxpgLtNUTgmnO6YxXvFjSeIC5QjCNMWx4dOEqks+TVYCpKCS5V6aTeYQUB4858J/D8+pYbLDcCi31VXY5fuCF2tsvLJfAvIkRehRPqDX5xxfWrmRlLhReFUd7WrPF2w/5eYNdl8V79P8KgMu3WqAOf1mhMp3Ij8FQJSP1ihdbqXYd4h9A0ZBPvt8nJOJxlM75QDqnr8gEDTl2lmM1WRelWrumfbbJa865GJt3iY2I73bZw0NHr1CLdt4hZnZ1qYdbWbFhi41a7/ByacxFPzfzAJ+E0j5gvWvJ9KPInHE+pP1Hs2VBh0ze2lk9IIMdUMhFrwyoF1S76HeLBp/MQNmVkFGkzOsSAvpBFkLur2P/cUZGeFneQNCA4rOVQadaZUoAkwZ+ZlxStEmR/WUcXi5LkTP1vRwwDw+BTQM8k+FZA96u53qwY26akg6/1Z6k5IETx8Bj9hS/Rc35IVSRsmffC9JUiupAjvqJndhU8onovY60eXmbPL8PxH/rawjd2c+qte3K6uGKYklj1tjrMfXuzY/UEwh3qPu7g18bTj8ljnDfhdnvWBVg7i8jAkm9utTNhjQPYle4t+ZaiDSlMNL3pADz2kVXzz/d4TonVpMlP1P3sIC96WVvg9nPGNma8L4onEwDaySUSE9Hco/GUJPo8VWC2d0TkY2wxtY3AKeoKnNPq12XcL/oZl4UCk53P8uwuR9UsfiobQEb/DL/ty1+H4XhhNFmTQg8zPkjK8WvJYGVTqv6nkVTidq0anQaFH/KiMEwgaBElUOFYTKD2ZQyTTCwNB0k4yAXaEO5eemRzzxqntY65zG2O7URF9J2nKfwYEF+Htd6lchoa08j8fht8S77Lgsn6iUfeAD+fZjCoSK02dTp3/bf0LTcR8+qqnZPJTslAX4ULvLKdXidiKLku9w2ekdy5QoV/6mQzlvlvewL/7S+jq/kaEU0cT5/hCzHQYLxt45cMxuLmJry94CiOO6BV4l3VvQyuLJ3MCO8a3QbX15AYJKlAECtvfyXrCh3t7ChHQj/ifh3ia2NjCMUIBoxn9v4VyxPQysZ5ksGzWZDXOizNtRcCyb2fi3TTZR4i/fq1znyU56NrsW3VRaXVcPde/Tp0nZX7ChrWA905MJcYD+Bg3vKSPPJh9N3edUXl5A6IphI2ZPG5zZyojpdpyxKrykwjKzoRPs3JbpGamUa+wYloj7SNYIVw95IhnMLf1w/lJPw7yNp3mtNn1NEtYY88AG0NHI979V9L4MdBGM9bvVVVPrxMALGeJmUgk4vtj09T0wTX+WYa2HWlf88n3FDljMbr0VjswXhCXPtGxIwito1YWcLteoMMNCe2Vl4+2YCgCIsQ9XvX8RRj+TG929MlP/isS4fKyuxbLpWGTlUAGZZcw5X4q1SEqM76iDUUfdFEn/MRg917tbgKaH43hAPv+dXO467Ly9GITXDzyDRj2Aoe3U4DVVxbIZIoO0k12HNTsPu4scJIvAbYmcfo+/mC4PS+PmjLl/ArLYR/ahMZiDMmzuCJkXHJBNu5IAR+erQpFVmKRgIA/NdhkG2eAt7qZnvFbq+xC4ppXqwwEbdjiDVdhY0i5kxiQ7Lgx/vNiEbcKZT3xTnUW3gtiy3Zy2fTEI4lvDuw00FyLYxMIamVKmjS9IH8lp1iQsoW37Nnm2M8jJF2xBIaiFDk6tcor9ir9/+IblzEMDj0I28oWpeQPBLItoZw8H/AJys0ZseFu1bhd5sm5U7Mp5NguhehhRYOYnc4bZe/CPhc8X93B0XCSZQUKuJdvgAAjVAYTI1Usumyutfzq9NpcK1fXy8hesqGEsflx9/3QHxiyI8j60oiv+IEP6QdiqNcLoQE9jO9hbl0Dd8MjFXjWxufCM17TXX0eGses+eB5BaCnzyRYL/GevwATxZitm7DR6rGtEhGyGApQOGeeycH+qq6r2lmE0HQArjICpDNRfmSMJKYyNxe82CpjQJVIT1RsnN62xeTNgysfTrhmSLYTak3c6Wj4yyImel3CaGiHFDiL2iZzWTyYv4SN1V4JegqAfKPB+mAvKNzRT74jnhUw+98opPfzzCUEY6sRls8t9TJJdyeB0AuwxodPnJbHpmy24oRtejEIFol67dD+AbaoFlf9wfoeBLbwhq8y4WZ75H/BBKiFgpF7okIPJ6Ns6lzhvYEgAr7Np/IzVtY2t4HdZ+iwb1DX9VDvPW92dxeTefy2d3A/O6YflbxNdT0MSw1MEewUyNs2PLQBpnjp71qA9enmncsVn7a7t/NPNCDnD9lMahCJA9k6OPw7WqEl5kNt6luLPsiGjLtiJZnwMxK9n3d7wpQv5UL5mtCg/1e1YpJKMjUKxnNhMdpTh9qT82UERCXU8NagqhUaVELvni/ytbYzaqAn/i8lFI1uwkTyWq4hVnPLjmX8ZP6fwvwQxlDBCP2zpOnFRejU3VNuvpwQJgxFwnVNNxQKv2ImvxLJYA84OxyXL1KzvvwZnewP3IAE3RNF/EvPfxnEPr8hRWQBHMnT6pDhHARWFp5dHBfk1ZuqalMxQMEjrblpBoLEDOgUG9I+ZSB/ueYU+sW1/QBatRA6m53svCUbY3Thhknpw4caA5uPnkCy0h8JVB5UcCLN2UOOMkOsewTaigJHcppMfa4ECKuyxpgwf/B0tPGjloo3Eogmul66j8v+qc7HZUeO8TAbT/wZXQBSUQD/DBvzxqpiufkNtWDOFA+imUftOuMDVksP0lTP9s39qUogr4DgQHJd95ICnJO3AyVJUQkhMLNjJGurGX54TcGaUiTrAsQgxokByLAiSqiXYL8/1Fdbs4mZ8mvO2a6g1c+JZTaDf8CT7bNYnTfiflwUcM5wb8+FI4n+0veK6+sllNk7toR9OwFGB45nz5HtlhESCvDIpwSQH3CjbKUTwXziP8yMHMI7wD30kWlGLiDjM/0qpTlLaFUMcul73DjXxkhgppX4aFZu0mVWO0u2+RoVAKeAe92LezS8f404PO0NSlPTv0BpjLi6NOL6fSHmq/AJLjv/2fbmvKpLXHeQ1o0wXJqfugR3pMwV9MdM+Hks98kMHgbkuqHnapmZr4E0x767T+gmzZ02U87x3F5PssE8/86zMhP6+isfIk7IWyXo38PrIVR5NSsVwgZx+wh9IR9rEYAhINupltGW4nf8zde7lRxjZCkpDxg2ynEWWX9tFjovyuYRGs/szlLJTDamDBdFDfo1x646ei2SRTrP7vqoEtbo05oOqmM0aKNpcB6amheZdw0IjTIKGw4r+SnWMxBCU7dYnIDrhdu7eUhzir+0V5lpU+H2CYn+KT9qEL9MS8z3O3OQmSgsBzIi2DN99cdWZ7TZQiF9HB2KgoXCn4W6fi27iC14F5BhGOcXIHArfRppJxHz5aTdhT88B+fF+unjdslQ6yfI0uOkJfWtZ1d+3ZC72zXNria+9iEVloAiClbpu3cXZF0Kf3MsgTTXxjdzWJ7M0BmJIigTPOw5BRyf3BK3QY9iKJWQ05yh+/ofQLWbeYxYe74aZOw1R9KCDbfA2XgIA3ScmJG3BJJdQzdBYn5WUhl6m7VihIn931CUNhRQN4nem9Y4tm8IUH2mCoEocrPrU/4qdyj8vT158ySiWm1wzMxEgnG3o6gf1pDE+akF5lUo/g2WtB7yYfh4DCDT6curYNDvil3HxnVM+VWwMOLRTChs38yXD39mWiDQ/1miKeciDZIbrMMHkOGWKi0u6ce005wUCfnh0U9D96sCxzbELeSLYUGVOEugBvpNNzPXi6CW3zzzPMlb+anxb4I/nRyJxo7pN7o1UIWCiLu8s2L386Zo4d5a82bs5FpmtsIMfDNX/NnswO/ZrSR8J6onwFz2dxUJSO5xflII0nZ/faEle/k1xpuCHgv2G8NyNCw3Ja2/9gIg5yI4D4rDJAkeymBFn3BagoMFUAyWzUrEwU63OdW5JDhjHIFrB/8muNjctb14/kz+lyivfA+aDUXp9Ir2/am01h3NuMyR0P/CyARF6fhwMz22PDXOtjJoMye77VZ/cT096lVB7S+B41rwkV4LAT/e9nozDOg0g/2+sYeWqcfM1cP5kl3HoF9WlSbAYnFM4vjV0k5SM7uzO6Dpt408oegMzVytD81jeHWVdmStJWypHAc9hhzTmNEAeBIJx4FCVbfYhG7a8eR8e5DlEJ33U98MDJcw0llP20WBGVbgLoK6jG4wJLLxPMelpLcPqlD7JP3H3Bh2vOJ87Jxvi/R/7oUzDTfCKr981Zu3FcGNN32f4Yyqeh6GbEa3XDUKXB0wOQ1T2Gc+iPBTBDaST/3ljv2LWvH61wLN6n8WUWGSIPTeyPpmZQMXeX6Y4J5PKMMqD1Sy2/LwbtuRHbeut7dPB1+ZUwU6eNQJukxsjf4IzYymnjZ/d6mHIpKpRrHmhpulu2+EoLHf+t39gCevKx3n/JDUY8v1kUbGbr640Yn4SW72SCx2mSjujUHJJCaZYXjSTYMdN+8E65okLM4D0phq8lyYyIiWb8EtUBFk8dQeNq9PnqEaKcezgRzHD+Zq+SgRWz3uP+DVgsw3Avfzbsl+H6GwSFTvbgWwk4k1QGgmN+x9kjsVkawwuA+7sDqZ16ltHorqL4QO+PjrjF3ZxeDTeu/3ZAz49ncWDtahzLCdvoyP96b5ilP4O8o9hgV/M2wDmoIV3Rjfnj3BTdbIJzw9kiVlWAzZJYX+kyOdxNELKwxP759mogyKQSMVMEuoE6AMD8V61DC2+om4qMBDw+nLG83z/smUMGlAECzAnA+w7SoFYTs1tRyjBt0q6dg1E4fD6qOHnvDAJvUJ1YZE+DLt6SnxcO3gLRh3czXGugQfK640hlnwGMjMckIDcxIVrZQO9PKhfBkWSrKjCIpvBLZ4eQqk9VIjc1l5Z9e8ePoRcr9FQ8kHMskFLDE5FQ8Auo5n6LF44znB8AaKdPTBKv43z6XiXrxIqrVPbUW9LTpfQvx7F7/nKa2i1ZpliV/WQNxqXewWwXI2BOcqnQimPdEdUkw6sDkGtykAyJzzmDNGg0eR83LTjbcyz4ZAulPSbIih7q9/Q62eoUhTjllyCUXX/PWhN0mEgeMkZJRjJkTNuFgJdeWXjDJnwZSG3QE4vmJGMx1T5XF8AVkhObY/u1k59NCfWIsqn1c30ZCUwK/vpOP0OxjTLdqJZerlRXA/QfAzqyVUf3kKAW6NOhZTQ9ovQhPlw6Pu5mDcCnApH6oMV4uyJ/mSdvLFMZ8oyU27cMzK+iuAe369ZIbwGFxc/dv2z0/sIorSF0JW4xVPr/u+VGQz3BoF8D6Eytvapcz1K8J4QIl1jasCjuMSY9zAg2HWPD/Yixkng27Mwxm6pRcG1EdRLkjuF3dJbKVaatHOxCCrabITSkMa18Tm0okmVisbWoCJDTbDilP44cPWUkj6HvHMxcTAniW1FfJXYdm2/JiEtIFgKaJ+2IAlu521Voo+hcjQgg/WXKR98tZhxidBBWMPjGlM6gMDlteVAX7Id0m1DceRCyepdbiMmYBy3cz9MdczlzqgPinM0s18SahBmjk+7MyQMvgfE/GzZZCBQkrDBgIenLZ6E9gVicZuf/fJBhIt8VjZzUAQx76qi+yg/xHu9owGkubsdprpilUtqL87qf/4a/Lp/kelfRJ8VPTnkwP1AAvTKnG3/8L3C2/VfCPZrZxnfWZWnOPMzqcwEo9RKf6XKki15WAx3aqI+mt1ubPv0K8Ru46rocgCaVlCYauxXiahnAhYwmEFtyNNHa9UFMTO4Z5+qrrMO8o3BJVqIwRCdbOFVdGcB1ghzGpWnDdcM5pu7yhxt8AIuiulVL3veCCipKT6u92ePKxjGDQym6E+nGhcJOlw2BjD4sEacKjdhXwKKdWdFBN7L6NSyN7fwly32fde/DD2QRV3twgXPE8cUUSzCWeFJF0X4ZoZDe/4r+cPusLYj43oFZYWEk9S50WLw1x2dPm0skr1hmEtpJq8Z2CwW3MV1PXIxSieUpzctk7ez3BCJIBZWALXzSC52Vpw5QBP0bNjyFzCHF57m7uh8+0o/tQYFDNGL2W8g6Il1c8QE79wmE4LXeobMyjhF9J5X68biTckNJIFkH5HmGIHxHXkHkugdKYtwq02mwKX9T7fqTj0nOc0+4dJcezuBEsi7fxKD1/KDDGEvat40Uy+FuXdz2cHzblM6IsDVvpauWkjPqW6gZF+WBjKmoxbYmc1325C3gFSp+Za9m9M2eCiU3ld0h85RiPAyghnbdEX6C7ujlFALzkCxvMz5INZCiuvonQ+SanfvSFfdrn9Iisz9qxIClNXxs/H0W2web61ga9mfaDbKEDUPchwC0odTUpYhaN8utii3tOcolyfA2zkt3TYlkTs0gXdkrqGUBQzu8V5mqw+eA0eYSb4VjDrDPYK3sPfgBgBKFrAQZsoS0mGVRPLCrXq7/M2dtg5zmR0LrzmLZ8fIM0Sq0Dpbn4ozwzKC9aIoBy6BY75DDZ4stiNezTcOH9FoQGSVnWTkPK3h+QrnU8gl4ugEOuLe0KbalBmOk4mMBQlTJRtYwy9WERKg/dpPwKANVDK0CCIngzTNBzLp+7OH9IVr7uB7FrqKkxkBjYQhpeXYFu98ziCsDT5PwwhuimS4W8HvL2ZaMiznOMpcl41W1WXv0fez0u3JCnXZsPdOG3ZP+XqiUfT/SpzTULU28TDOXiKDCNCA6noJaZaGzeNG1kcIwnWxzrlHyfuDqDmf2hXK0IfaMoh7kFnYXE5KmkVTZJ9MiUkoYK9lR5UQYXd+V/7IkAVKrtZMl3HCLrDSmvB4CG9jJRUCRGuScZHXN/nBRUsgGuzonO3vgwUDVLYDMtfWloogCFFKHt4amOW8vtPVhPqdWShCEuyL6G6KaiT7ZJXdfwvWJTYgbiSs5h9YZJiWhCvI5IcjWlK3xfjGZgs6HzshjQgd63xLGHtaEJ8t7C4/Whxhi5jhmHkk5VQihfrb885hJTTHCfH8C8kJs/Y6gxZc338DE6MNTCieMLhV86JY9hsabajyZyC5RhijrfDMjcN/mHoJmdhJbM5zBjfC8FqMRm95hDg8QCGFVoDAdULagxJ1m9nvFHS0QvAdkkn2TvkgHHlsf1lDJ8Tg5saI9LfIWvEW+Cl/tZB55UMkVq/CbK4F7dIC+SxMxUxQArl9oIlaHwmckwrqLUqTdUmRWNc1XUOJE8I3cUvOv9vhIup4XtzjNWH6Oi3iG/PaImWJRgSQCYhF6WkG2TmWbqdmFk3G161vpxk6+tXQwKxtW9EFc8g4XHffZ+9GkZcSLoVo9qMIkOuuLNNpDeYi3gPJ9R6WIkSEG7hR13OcJ1PUZqO914cz0EOipTr0Dy0HBHcj7S+p7eTpygd3tTiHdMGhO3o9hgN7oFaupxHs8mmUHNyady7dq7uJjwNFvHTtWBGArZJTjaj0p7afdgKuiC6iN/2j/0YbEgN62g2EJVgg7BPkyupii0m9VaSEXk+8GY91X8seYr+du5aDrHPg8jS92X/sXH/VnWfJZ4jaC2x3/G10bJpZYqRSOpTe2ejoasnKbeXOifLnmzPDMNqeY7pNZ3tYAD7U/aD7d8r1Pvpvz5gIQ1G1ouuW0Zf/IvWHNDI6O1i6UbE0WlMyI9jq0N4dNKFV13EWH52EEHJzfB1QV+cnvuepq1NYVHTHocMdkOe3KFa7J9Yozyh/p9m/eMn6eJXhV9BMBvu85OWo5rubb58hqmP2b08ry+5gNpujPVLq0Hq7G9rhtrhyt4xOYr01RPVmN/hwo7GSybj5bdvjV6kxKqAOBU6mlvlOXMYWqecDxXUd5BEsqYkX7L7hl/PzRcV2EZI87CmK3zHF5/JY37XVaMAlkmipEqOIZn4QAb4N2BzenPgzHBRVga5y5KpG5+YOZgHe5p4W0UevUuKpKAAa42vmJ6GTPAC8M3UdNJ0TbHObFgdccOGCT0BXDvK1tQ6ybEHDuvhVn76tqYRW6Zsp+mSZ6Y4kPaMGeYo0uxnsxphyFsTvpV7ew3OHa1oh7RWvAcuKP4sGfruShQRe1cSdEBNtFda76JMi6HM0oDITVnBXC8nuf5jZb5t4Mjm3UaqRUAXlX52F2mn5q0twW21jwm3AL3VBJdBpkYn0PipwMNoqOdGVkA963SllQnxpLY95A/eJ9fOnyLk3OJs58+43J9LcfnIPTaVsbCDb1cllCf5hPDIMCthiYB0N2cLoraifm76JIsaXkWGbxkg+9WenrgmjFVROV/0hqMTgNy54tPBdOHKwja5Yeu7sU400B0YtR+OUxPssoTW/oCutzS4Ju2aOib6LVQIBQz8VnyzwVHMeNPLa9ziuMMSNpA4PxRSaJglyN8sVvzrDxg4ZQeST64BNMo69U0J1maNJL/5KnVZYV1TXDlE4KstXRREvpDKmsEwBLy9uwGkfwfxUE8/UrZir4+uERLyl0Md3f9zqUG3VZsbNbsQBEtP85wBgKxMbwUNjxS9HtsWaDXHTnKcP1AtT7q/2dghynf7+YQZNahJdpFhpoPqdWYPjlMfldmlmO5lsjeMlXlboOujSmkoCZ94kOYDYAK1vNvLi0q8cggjJy5paQj9IhF5hTYThO3iC8oGPF85YVf/wlyl5URBZeAs20rg8vxmvgYyVqFJydEA85T2AdPRhr1/NMS8TSh0e9j1zXeErHdqdyCUGgyYJHv24isV7Tz584QZmKWAzJMpskxqBDCvkme6qaxS9Q+z73vVdGL7gpm4NC0/CVP25ahGlqXCrVtrd4IA/0dzUxxWSFbofEkYYXH3DCcVwDDe7YaRgR4qk68dFV3ZxvGda09zDkF0sn/iXdiV8d5Fp+F2/Gqcd0W+83ufVwNg3WTQiFCC7FFYssPm4TtW95s9wNLO0RCvYX3UXOtkT7nowytdEEsG8ooDOpWcINgerRT/NUM0p2SnwZ5yC+Q9dxxJvDyMTveX1TaVIEslKKi8Y3ztx/PBsjLXUEy3P+Zr/RIXCDDobGkGTba/0eop12aJuossCNECDJDmOKl0RZKB72Iy7flYyDIJH322YKeTyB1T50eRtUeXvKgpPtzb3pszyDbc4KIVgkEOGNb6jsw3qRDQCuoDN2sTk7VMxHa/w2ZhOTw9fuvEUSHJ0ezltp1eakXg+k2WWa6Z2AFLD8Weq8e7VIbYyeFbuHb8Inki5ja0eyOmE7acHcCjJJ95QLLuerZF1+/M3f6sukGyHMP/o67k6wBBHJxs0FRRnScULmfGZ8bFz7rbDKKlJZJ2b7UPy+fW8zNSzm2xe5ds6L8cV0fxPjjPFYlIfiJI6bJvcGLy0EPjzCsNeHlDq01Gjwp3+mcxYNSeQVtMR94UwScPzs5TGQmPuBGT3feesHvSfY93liuZ1+35AUFPBrwS+W0Tzxm7Yifvaiy1wPuREaVTvHup6u3M5/39JluA0iYRo9jNvLuGL5U45DqfIAaO7MO5fvBT2nZHbL2NbO8IbNFeEDdcHbFbnuQpigtuEw4OhBNpg1c+aeIbVPnDgKUgfn7ukBHwlij0MloCqfghOdpmeVWuNEASaF0Bfz6yvww0zR+Ak0s5dWY0nf74riTJyT4cb/5/jEoi32Xf2pbh45o6ayw0xG3hbRhhmMSxzRbl59oMrafKNXjbI8RE+RsP5c88MUW/icqzhLhXEZxRu44m4fr6DoKGEJEXd3r5I+5zxXWoRYUTQWiR11O5WDZVVBSXNTfcBgbtojRUg+vs/o4wXJEITOev8qVTvdXm04DWUiqaVTe2S7hKrxm74qP2SU4B3AsAN4A6TH/lcixH2VYnn1ArnB4/4YSau571Kf2X0KrlW9PjAS34D0QFZAgVMm6XFDSArqKLcfCqQKjguAP27ZmMZL/o7aGnHhl58c4RHWw7DKfPWzRnLIBvMdGB3ma6+BhoFfxB2FPXYSbO6Z4y3lJSV7GdKZxtpx5KfmKyYnwsk+oiqL+rUsg/oTU434B2s28AWWzfxxMnw2f9T5TmTLJFINHx0SkGQG39ktaRI0SoBkTkNcpc07E0m+OkrXQWTV1SBPAZju2wiUMVxT3Z4wMRprl8xa1hTdCmNZ0KiDLFyKJhksRLr+35dH96zN8+bmI1ZlFbuLAIT86Tw2nWTEZAxzzcKBQGehMZUVItq0SStz/mdCtXlq8YCUJK9U5jABknFQ1rMWV2301fBFCjbOXHDivQ0/WLZzS/Pmvn/M9PAHBcVB9p4gpFLYlU1l/izNzBuqGDgEyPt+r/XOSb4TEdz1jkJeK3U2xbb1XiGFcokyexjxBQjoGrEu3elzYORM5Ftl7FLq1QY8Ko3Xtb5KNr4W9//09eOxwGnsjU4gN7TRfu8barrvctHTvUv3rMJ/m3qqjos8T5hco0iXp1LIglhqX8iqzkEtTAwQqsoexj6VLgWkzqEHvwd30TgGhGrdqKD0yqUbOFuRoBkhUsZZUK/9VUE6u5Pk4YG9BO9Wgqh0Y2Eq6XVQZopNsTlxZHWAkjlF3dKOxr/xVDlQ0viTUj9U5OXe5Mk0813pIbAHh3wTlxHiy7UTCLmefwPHPd//iBAwq1EowD9Nv7QBK0L63ANUdZKso8HfFf+41C/Ttw2yYxidVUUBCtpVdtD2ooZEPninquciyGPsfmKmFn4Dvu9huK7ZkMwia2q6zG08jll9Yg8GF3jGXezcsuavt7Qa0DiCU37eEDZXMtBnsC1s8REm3N4eX/rHnhT+Bnvgntogswq/iKtmykg1kiZGeT1DF8dA05Zq4vfpHtN14qBmSoCsxE0a5CwW75mBOQNM9bfMINmtg82HcDAEGwb9/nRgcQx1YqKB+b+eu4wZwTdoV6BFa8l62PneoCv0S7f0TtZJPygdzpH0DkIWbiAmGdU8/L3MUIhT0RsnA7vDFGGs28WUEn0lyr7NvdIZTcXYpYZepa2iTXnFHoMz0NYoQVj2JXigw7IQWWXAm4OAgNaDrvioYXohQdSpd2Lzu83R9VSJK8uXTjjbidkeN0s0QYcjIc0uAkGN/5xDsFiX9LRIb6+IQBenLJaCa+v7NX1clSV/jA00flKtwL0aqq7J2aVqFE+tg15gMmyNNnCG+DCctSP8QuzxwbcNxPIfQuIDwPf8Rlu2691FjlGukLzM4wWXpHHT0gDiRzVdB+UsIaOPWnVVaaWvH4dnXnZxSAiDVgMzSoH+aVgajAvbKac4pRKH0dYf1+rXf/IEWAsi/Q+iR8BUBscMdPEerfIL5JrM3hYXveTPhjmYWjQQkWTbakAAXNZAkk2F+QzbM9gDLCL/cTP2kA+0YaeVL2bbHnRJucJG5sKYm0EgIZ5CXSCXQDWk3Vg+73/EA8Np3o/sDHyphYB8iiLAlDQ4nYY3z+t92v/L/jfgYlpatW0w4VWdSk2sZNYUHfb/ALa/W6fBHhjI/gveHY/Ne7tTadb2cN1Z+8kAIQxL/i9TeNKa61jjYoGTl2ADqBAoSpdjxBipM31KscGjJBalxgejPPawYVJqQNFL1NzZk7zDPaRFkie79cNpu0aiBYd4xueTrJ8HILHMFUbQnV4ABWn4W4edEcUtprXxBIClpivzCeT2P55WbZWQLVi+Vm/giku2E0q27heXKmyjhRo2/i2xKNm2qZC9zWP9gKluQQs2m/BgurOe/+51XuRFkfMR6AbNNMcKdOKIRocBNVfwoDuWx97Pg+Pj+DJcH4E4+272OnAnxRs5lQaMP8gedgi+7SiH2WiQvxEJMP1tUfP4qKl4kp402WME82VvAp0IWarY+6CtNJdRAAZ2a3wP9StEC5piOxuDZ8nf63PpDCUVXEvpHQchhdTjwBv5IkpaXy0ofcCUWgXq8Rb4mRotFZ9g3FoiJJ5qbgCNcJiuX+RLMIuwEVyKG5bkRrvMSvGUrl16huDs7VK7mVOJzsJxAbylBXbuQy1goWfjoU90v7f7xi0XNiVh0GavYP4xuNzdDcHva1fPxn24r9g2bUjRf0gnkhQ2bNdyrehssanOVykljfsfvk1cYWPisnnOj5/xIwFruAmveneZDSb2pahZhszjobWSyZrveSbcp87oO/q6UGpRXqsrp8Ip1N4hu0G++L6fyFORdHMgcgaGWce6rR0YmFKz1a8j6B0b0So5SkbOdwYxPiAVSduGpcKT8px6aLKKBcKm16FQ/uULQD8agKVBTBMwB10QZckN0fX3VkqVNk9wboRW1WWrhLjrllCe6igTPqIaeFTmwHum4ejSotv0D6zfu8rmK7pgLXiqrnC/7lW0XT4kte27qLZpL26TGe+K6kuBY3gHo37WvnbFW0ezo3AAynHhWWkwEHUOY2iUDvXH4AcUVIxGRSv2t2UJodxUvgfxJTg5Sfvph8IJKHIGG7x3+WRDVDmLAIGd7AZycxeWfcbhfyItdpJCmLb8aNqTCDdbpAPQAQ97BznBNWCNGoVcB8VVyhZTMNRbC+mYC33kEDBbPeXyBpItM0N0IbI1bonPcGiAer5MZnGApBGBGXiQYGnoEieAqGduPeFD08vCK6CC7CMojMUWREakIaki315uSUujXSsHu0pkSXr/QNMAdGvLwTNDfZP7X175vAZcwsM7PQWOrk1OvtvEAObb6Eig5C+/XjkwTDfpBFSppdlUjGmY71cT8A/wFQV54pCpbnEGXpaw7X8FJPy51kgZlLI4hX9B/WGN8RgycFIydTHFl8Hlo0FMEjFAkHALnt7tLyTHKImZjmi2yF5r5abY8FruyyGrCn347mObbs1LrkhxVMaqwpc1c3+faqw9tDLAk4FDEtkJ2BQdCsJKFODk/OLKfQ4d0JXjqrdPOGvkF5ftucCHMfDihm6WqmEGhi9vlGMzuqZS5T4ptb67qIT5XEK+HWsKGWUsavgIb4h2hjuQNLdfg9qDxw4jWJ3ARK7+5bjh0jjziSjicNrNacP9c1xjrfWHZf50vl0oYTkBg/Sj3x/Ryb05vtZSWinvUciIORWHtGwwP37Ofay6zVji3yg2zN+UF5ZcdY4QSlw9hZtWxPJnfvoYSPg45DQsGeiGrizE1Q63zhZbONYYzb0AoEFwA3H/D6kprhNMyejK6DWoH1PL5TfvTcezvCc+6u5yI4ugXjFO6rWCIRNUCU2zApmKH2+utLoomVyC630wt5pfLfFO/596EruP4jsRg9rOfm6c/ke1XHIlJsUEq653+0wum247FUmeemzBxKYvu0kx9NhoV8a/PDq4W3ctSIrhUy/RxyMPznvH5czEFpKbTKcAklRwtiYJYUngeVg1xr77k7yVPp5R1nBT1scKKx3KMzr4FPilYkKMPohyTwgYBxM59PZtEiWXP9nHPvW2NgnfhAEry8vTwmFv1xzLjWTuErnMRFalvP6LdoKQ2p7SrerJrb3+19PV6pWKTcg95XuIGtnm3S3Ie94GTqptEeGy1DFC1EIywlz3D96p58xhuEGM+EHHAldFEa+1UbWzWhSoj2YdeESNqMx4pi0kTVtO/2RE0g4VmkOb5z6M3+c6bIJyy/NnnoHJ85S6ZUJBVYw7IBaejN+su8NCSdiXEe9ZPQuu0R4SwIiiTZqIiXmjPZ3VwSJxHu0pass0hWe9HDUXJVoJLNCQGO4sj1fF5FTRRDemngdNE31eBkJV2GUEgMh1YkiOWwItLuioe98QqYxKR9ufevYUPlyCYd6yvRPqRCHuQIo2quHLLiopVI04ZX51k56Fdg05iBmL7UajTZAkm7GP118IFys9RD1Nr+BdANzEucUuS4Hq0ZPlgWHd2tCOOC5rCFYBWDF1va5hAsV+cXpQnYBqQXYxRXBM2LH0l66SCWuk5nVcPExiHYaVnA7nK63qvFiv/72o4KAf+XJXdwS7mxylDNlZx7MgEBJ0rCTIE20CeiNQlmi619Cp3x8+0Qml46m1w0DN11ZknV+o6lgfN3VDlrbk4CxY2L9j0dhHivSIGBnK9zwb+Mrna93bMtJg0JJFKJakE5gIM24m2W3Pc/S21tabVse8fF+/SVLEoyBTekIn26Ve0bLDjCrc5NC+M92GOr61bBk+EXQhEX89BCeTKPwyPtM6mCaVhFO+laLfLTNxAe7E4Rf5U9Aj0uyafSB3a43shdX/oxrSB1fU1QgF7YAFb7C5tPzwYdh/+C4Rp2jrCGZ0qN+xSM/mZlMe+8M05DrXiq9fuplLsts13tTPJE1Wx+Vn1XhlpcRuRdcM9iNPIeDytZwPg3kAgyxe1htR5Ej2zEcyKTDf7kCM5//0RQGqKDa0tgtkcdTGqZLpDO+ADBWQez78o9ptzYQgFwkP/kQ2x85+s+HXyUkjJW4yleUn2t4pxWxKQVYDNRwuUxrLj7yioICABB8C0eNbDuTPa4GkN8oF/JPtqBSussGW7V+pt1RrNf82JM8CBoR+ppBYrIIqyCcCx7h+duLM9IjNWW/FjQqDdUYjBUPbnJeSxF1kadRBhCdhVFi1jzL3D9oSJT6nE09M/X7UC6ee7mHFnE/8jyIgHP9V6z+hGlV7IXfHiUnnpYJkLX1Dp/3qgtumoi0Rs/qU1QG1sH3dnFCHLsQWgqE95PDNB8I4vaZH/ZJM6oEn/rf+UBni5EijYAX1lhO+MlV4AaltQuZUwTW1flcae/WY3JdkNB+CtMXw8JI2ppFlGpeP9H5C4RaJKujsZ6fbBmcace0rFse24Hd5LPCJgjFkVsbVDLepavv3oCUchypImcizAt0tjw8fZ8gv7f1gpcTewvf3kuZGf388PnMInDLdTJ0Jlv02bJC093xF8EX8Xwx4N74CjelWgNt7PtSSwZdHhAY5uU7jBDG5FsJRj90KL4LV0qSobBNUPyMRl1e2adeywTalgastBhMoamQ+TBPwojLV+ENXoUBUM1D6zW8Vd7DcKsbBaXrOKANxVoepkLzRxjaylThrpwdKEwEJd2BFjxuRxMzfpTnARO6OJZCXwfqZNsGWhGPRKn/7hWnlwJL3sQxpyeWqjUD0WKd2IT7GNBVerxMVW1fehwXIvBRyHSD3CkfQvyj5ZyLPeT6lwkYOHMbNdV/iYniLaPGrbshsKI/cX/H04nm4cZo9ca51ATLnLLfoCg2JRpb4FoWo1cOio+nZ4FKZD4RkZdKiMYujLwPJuHV+6yVmrMv1hHwwSD9Em9LgJWYFTCMFIjltpYLarkDyetMTqsQtHZ2xrLs17m5dXBrYYLvnpyJcc/ehwqkODt2akG6PopX5wmOjJxTUKYY9csVQghLQRAkE0qEjYOQjXmn4ymvwRZT1n6wXdEN/agofFVrdNINOxcdqZzpOWaVqpuqPtrMks6M+wolcNEMGOt23nAsITuc/J1eCEkhqLJONITJb8PdW/fjF0SHDyWB/p8W3IF7FoOfv8a4l9ofIUhPcxSn6eUZh1cwFRGfxDLRvM/phuCT6p5EAfJtKH0nIE+ZzZmw7yMraM5a5L/JQFfEPv7eh08e6SllKXO3StygqxGTnXQVE4C8tPY+DqUGVh2g+ItmsavjZCUjuKb2pxBpjheeSGgo5zwzi+0PN33xxU1H5qPS7X6GM6rWPPop+ruj3dO5WMnewYiWxROpz/DOW9boqSElwcdlhavRnB9LKrmt7Y8vpTo3HoaTXuOnalH9Vs6muoxlcfLE6PDQzms++eOmo9hsj9ml6TN6h5IKzH+A29T7ugb/1Dm+uIBVACstPCuY7GDXOND0kbmgGdjup3R+hVivj1folHzA2Kg7mbtJ9LU1L1Wf+Y87UzYdTkQal8VRPbUV1A+XvAyEBP/T0N/m909Fs6v73KQZq/i4DjMu1Ak/1EkNqYI6DoTn0IwlJWes4RYqfL4XC1cZkFpfWrycIu/1Vyy00WChyG7UfqjaFKeg1RyRDgZzMo6pJkJw80tCqOL3Y1SYglNoDDP1S+FmdPS7BMK2xxuHgC2JFui0hlzV93GajcmWr52VAA0135MsdZiwxcGNGdU2+YFyVXNe7mMkkxRha60aT1Us2RuP822r37N76VKCY3hbrONDTQDRA7YHj71pfpAMt1ExrFvsoycwLQrOK1WxMzlaCFNZL6B38ThC7Wm5Ffgk9xi0GjSrHAM7/aLZwgod5Jp22ITRRMF7T4tG1Y2LjlpqRIu1asrcAr2QFirdZrCtkIc7UV21J9SYSxxZpNDo0on3MoxfmERLGzApJkz50Z+bSH1ooe7gw3li2QN0So/IgLzJ4d7xpcLXKq95HZ5lJzgsjI5c5SZwG7PIUKcdA3o790buMZeoglJwgTZfK3RpMGn7Hj6bcQIVcApnh3+erulTPLIDjvWR9iHbYoR9yH9YqIYPANIBO5NaVCL+JKVM2N7SPbTZ1t8p5g4mjbN9/SIFfB52K/rQabcanJ0v1QpBoAw0ih2QQ9tR9XraKV3Ma4bgpAFL9y4obCMQAFrC1eTusvfsEpgEFcGs6I98uDbzBHZISWtLkaJT4fdfc0zYrsAfjIpUVtawW7nKpiFDMCLJ727XPXYBAodnSCZ1PVFakNvHEV2Y9iyQJE/QnCDLCLzp48V6jWo8f0GNGw/qWbmXYt2f039NHcPtK12kRznITlzFeb4ArVx22V0+mLbTzcq2oz6r3TFWcf2+Sr6sC90Ek8Z//yAGY7ErGXUl5Oxz0sFIsJEAjqXok7dJOeMyvDyLvyulHmSKv0QumPisqXOp1KpXzCjNT3MvZfLbVyARa/c2pKZUgHo/kuZvQUDXlOdQxMetnJgr6NRnitIyUctcrMW+esJBSj0VY1DMaIX4xhyQ7pVNf9dg6LUWcqlsw6OR+cDBtRHpv3TB6fp5s7TAxCAkuGPxbXt3feI+Dd1tDT6XYwzuIZR4YrybIUKZ1I9PekIg7/f+20OfZ82QlgQYglJXsNBck5yhly9bR6trCUDuXfMKWdKtxfVVViGuaU/F/Nsfm+cGzbc6cFp4GmmF4LsyW/qPh7CH2n2hqUQmM7yIDTQSoWyye8nZl2OSC+07GZrJDHfV5FP4gLrQmdQWJdWjDBO9Q2KnUvrJtyWpoQS0npzO9CMB0G9LSGco8m0rMy4zizhNhE50U2OuGyQUvOGmFCiFQVqcwiqF8fdmpx6Z5IGgyeUm4wdESuQbllqoSZ+FhsopQVgFs3/uknauWEE1GI+VCGH0q2aww01vYn86bws0CHRsc7qSPmomtBNyRzIwO4tMzlNMAIAoPW5ExwGMWvPypIPjOdz9bhYo8MVmrFItGF9y1snGX4gIPtOTXeLSNkuDoduu//kEPqOz8mh5YnX1UD9AP/9zuDmd+801u2eXLIh0IzkEoaPm2V465MdiWjsIZ2sh4SlvOFXrP220LuFuPBJANTHgQlHUZ6WXUW/y4YSU/HikvTgryt/YnFzZNdZh8bygwTifAO0uVc1rGrjbX7vhgpu94wCYVpeZIX1yHWQAJZZpaXqPnsE/ZWdaPLpkXPzE+LPN/uGJzo2IHkxCLq85Wlfgn0oLVf21jckOKW9/KRCHr4OL0y5jOMyl8JWTV2S9h5FFVCj8718qAzLf0tTEuXqjfkFkMJIJfdagBIkYd4ZgoEpAqxwE4HeSwFKc19mCsIT/6l0PtG3D98YH50Vhv2fYgLApiFIOnaXT0qWKN1I4CtuHRjVvtFIfaxaQkwONrkp3OiDbkXP2Pz2x4fuL4PVTPJmrgA6MZxOejrZgZk3Xv7I1lDEwrok2EiPcxUzO2psoWoQekicCtMNh22oPj+oVkvfx47xkOus9ZBdvM8xL8uYijkxpxHRAau7LjyQDeLWVEeAegZQJTbM9x+HmHsWCxNcJCnERz/9rKmqHmUtBrQlhomy5zWEeBDK512ztBd412i2HUjykev3NQYxElyaTpqD6YbGzDTqUBQT0XThxOWarilVXCEDL/Eq49/tzg0lGJWIyFMeCiZp/T1LIySlH61XWtKepJGp24cop5lYUlcYpyDBqH+Ok0RDggE74eDfkOxmT0o4NKNmjPQPPYvACnZ8N6mSU38EmkMZVI/ftyO8s5hqWvGKsXG3MVZFq+IExSnXoqkRrXjUw+FzqTPgtKbLv97bayQALMVMOj1OXQX3/LQ6J4RUtsBW9DQetloAvi1LAtGsb4jNfewkb0nEWHqAqwFO1cJPHSOm3am8kUSFPb3Bh4IVYCKsZZ+6LH5Ju9e6rg0CTStMRI0iuoX6ZPc3IvOppghAO+Ui0HpVceTw5XLTXQ6CTvRqbSEXzP1o7uPOykVIjiyLhCeXNYpPrx9JQygKZaxpIp5HJi9W1jL3Sb60C2zeHA8NxsXQgjBdQwesqX72FV9a2WtEkZZcAH5dLD0XD5EgcBeRARNPYb1BrcodEE6E5b9aAT3D9mwDhy4wgVt0QIiXXi/NvJErG1RwybgWSFPZhgLkfnEzZM2pjTYnH+olUSw+Sh3S7m8hWxx6MyKO0JYhAFOxeHOg7yl5065TvaEMtOMi9zJA88PIk8DJu1UtGnL/6w4i1GelC7TWYzW5RQzVJ9vnFe1JrjNGnajhsEMRAhp2BONKldVWihpTxRrH+VOvsDZSYuQ617s6OrBBkvP0JqB9d3N5Y5+QODxkaiSoKsA3UZmwr+C1fsCIlt57umNetf2VlhMHrYUYHa+ryoZgLQg7ZnHbgwfUYEs7luK2jlnfH5Ksff2krU/C7vEWUra4+Qwjkm2faPp5ZRxNFkRM7kol+lGd0R14qZx5ozcesEUgGIYsojCqxLgxtwLbGTFQVmkvS7L50tK2Jc1tcJUnJTDHuQqPATmels8LnvXw4WcwTUT9ihETnW7DG+7s2fU80u2Xdk3aYa5TFlJSUJQIMntGdK25GX6Xu778yUQ9ZVabWrnwniuCouBwcvlOpFXNPofLgtnMcglrMaunpwInUFcLDISDTd3t1eciV79GkIbQMaktT3e369mUQ+MT1ZWm801WFtbJahUS7u/RF/JqFO6eXSzPCn/NPKFrZzxNzk9tudFDVXZxnOKSVtsqc/nsj/9H+Xf78W7DcdLPKlTZHn2gI7eJfz54chNIyBpVETZ8HzeXvScLOOuFrJ8NeqWKBJPIiS5xl1nTZy7yKmUlIUCxDL7xi4cvaWk+FuHb+gjMdsLl6CjKfDmtrE1vO/cicaPdMxfmmtzo9OTXsX4udwhRbyx31BwAM0DYonBpsvAftz36g+s58Laf3e64uWVnpVjvPCF8wWlTZNHsMKrsV444nKrgdwHp2vwzl5tcNEIxoYVbxy+1m6jepSj0zExiD1IDboBey3iPuMi8aP6P987olIdLBpo//9V3IkIEKTs4l3ZFslzWbL/3NGmBfb7OnTcBvYYtZ/CILp3KLC1wHePMulwujAairT1PbCiRH8eM9B4QYX/aBn23B9sapeCo9pFSqe71UxpqPrP38EsoKL96/qGW7dtCegU6di84Fwe43C0UVAjkfNWFxReqD4OaZ1auTh4AfB5cqo8/K421lUuZgZyFsAPrCkg5UewUyyEjKfOp/A1PfJmwf/Sz4iH5g0V//oajXo4QODXwj4cXUkXqtrD3qJbC6L2B+hw5YXie2EVVrl/UE1xFn9jeZqrpRemws5dF9cgPijCT5ik/Ggmvysjzsq6uN7HMzKXegXziGYr+swSmHIXQJsBYpI14vvLyjEKAj/f0xk6eR5Z/KD8367hjM/k5t5p2/yNSXxZNyR7GcCmEjA6XRryV5GVlbA/suBb1imzXpbYKeFDQXo63ru37vzCco7xpQsCOejGtfM/nit/70MNeyKxczD1gMD2dYgQz2l7SnsNqjHkbLEcV7mHSGySDe2CotGarBWnEoFoZmf5Z+Rsz83Qyl1Mw1k+DK58DJk0AFJNqLy03wYUUQjaIFmEXDcLGrjuY4uasL3wfKRpNbNd7h/9dBRG+l2QzOccU9BvhGNkYtaQ4GMeQfFECTFtUr8Vrku0FH4VmkS7hpjrBHTsm0vFpoY3zZmVA/CjXIZysgeJWhBhDzflYM1oCAMgWAuaJcCgyr8uOIYet2PEWaI0Br9PHbYUMD6ktxklqpCgtm/Zc/0+5+PJWOyXwFuoslawk8aDRmpjgbKBdbOpnBVzHiFFLmRfAHzlx2lbe+5Tbn5VOysmBjDlvyC+ZkXkQmj1QEO8R2bOa8LJ0EsZH5exQk+RTlWEQ8KqJMCG7LJT/SZLdK4XEziAmJTdV8H9OqBtxzcS3wI930OvWWOAOp3TKhSyarQQFfhjelTgIAUkKi0dvz0S1pxAgsnSzB7nH++tbiTWeiYwZ2p1mOrxXiFr7RyNwufVzwy1/Ku7889VDu1rjzLPFICgghFe7Gg5L/hWwKHCIkx0rPly91kdtjZurtaaMH4g/TG0Qkl+qRoeXcC8Qu45Omcc8A5N5lEnfC/H8xZjlwBZ76xrtr+ysbcN9enFfQNuHSp2hYPFDi7NlIzWt43aldZg2+rV2tq6ZiX23+wIF1nylTetmtuNnvocNEeaqi4wrn1SXemsTSLbkwlzBZmI4gQxpsgVuPjeIRpdgbbQnrZZuretgK3RU4lobjDk7Fj/12uB6pyxxe+y1ykJmHNsJsuPpGxk1Nli5v+UVMSTXBaCfdmvQAvldrQo3ElYHI8S7Z4PHcLZoUUBG5uFrJMAkPIIfTqFUKKFx4EImpDZOTTG+Q3TOuWvj3ZdVQjCZG0hxyhKbXPIVwHPcvSR/Vr8BzMvuIhlZHBJJ1WA88/1tQufwL4EsN2lQk6px89JgNMrKhXFofTS2s9HvLieUHAls7TxWV//sWo5BbH10mMcwlHyOGJVD/pdX/zs6jKJz2y5Oyw82Qg0ejxGbyZm6Tmbvny0CLtN/09m3oHAy4KyOkjCSgQ9KF5o1ArWeAXcsDk0G9OKEz3ePBsiOJLct2ujud/XpjzOogEIGMgYSdtE8oJyaw30A2v/nQSAb6upRxErWCQUeaSO6o0pw3wpIhaMFUucREP+83LPvfsgdPT2N73O16p2ldRXcD9SUv9RAqlboZS7nFApDqxjersn9/HSxJXhlATR/8dg0PDYTO2ug4CDOhPVZPVgrF+onmLBFnvcXRPPYNKObMQg9xeb8GQeeIoVawApQgo/sskyYGjLpgfQhglJcSkDm1CsTmgO3BFlrs9q7c4LHtIJ6YLg8XaKSdxnmjyL0uABR6IC89KUcwwybZ9FXtqSnyeO9LaB9UYRGrPXFv8B6lYyCub3+ClfnZOS91chTidqmjDshY9WSVL4sf/E8EoDTPCxJnMMO3bYetpCyRooMCsGXiATg89JEPPXRUSEW2Lb3st2Wm+ECrNn/1acktD3GX1aXSbzy6Vujwnz7rjq0QjaBD+/m4LybGlYZkOaM99q1CMKNWF5/NIfOwaIJuCRxXCmDsaQAJXI1el9E2Czrvjn6aDZDHOBWNhvzgFZP8fFylG6Y1M/Zt01LA7lXn+E0Da6SLOWe419A6NJGY33WB1anB9WFTAhaXQoQQ+RaT2kJO63EU5ciaN89H5/KerI84yYvdn0iYvMCgmj+wAHkkcORFt4D/FNUEEuqrTJvSd2HiHBfyls0eqDhFv1SUS/9xaDigXQ6CLH5p44p2xco4hr4hrslV6EhGYxr08hmdE1UUnk7nAmk7b2yAc55yaPoM8DwvbbSkuhDlKGv+v3cjTUWx7KYglhNflXXI+8u0B/mJwDa3KZgBHaYofM1TA6FuQLVYRcIJTJaDdS+6X4OfkztDSMt5KxPTZbKC4xLXwkgpUkA3si1gGuKD+CmWtJJngWijJje8AB5/0YtgxBNn8Hx8jN7u3lcJS6bRGVBwAKbKaISdhtQZT1rRl+/hbZqFPgzILXnnvpztLJZ+cZI0IqYB2m3akB7ygd6doyk2ySTe/8caBruF3bbmuyqm6otl42Bw0FSwICc9TwdDsFkBtmzwJE6GaOo9SWp+ILij8sRR5XwNef8Ihe/z7EdykAw/saWWXiSkAZmc3YSpvBeodPzGhTmXu2z+142EKqkS1GEJyqMbsgGg9G5kd32IAX3D+qiy49CclimHWClS+lZR+Eg3Q3eGQ4wZn/sZ1ThZU+u6VRHPVf2tzZ+llQUPRRsrRimK7zpQDWpbd3XlsTfDKmOAOYnZjnBYRd4zr1tg8z2mOd5qmsuwnWT4VSI6/tkZd6pvvazWdqUULCia+wdCBzTGFv7psRfYYYX0kQWZkFrepYs0a3jy4seEHuXZaLlpjnZxAVv2CSreInd+Qs7pRh4fy6rDmlHQST3wVjnfKy/1FabIb8ZRgc076CrNsmVwexjqlDegn/bJn3mG1ZCmvcTzDSkR4Y95T2jSLOAY2/iiYz2UXH1RcNrJg+6vlBYeiElXjh4WxYcWKESQm1wX9uOwCMdxzl1qCqc3GKaNSoFP0LWi0ZlhHJmAh9pJtaPFJR5VjcE0JkrZBd2J+xN6WMhqhNYa/4k0TnGCu7/0/lmYKq8s8s34D726tCqiBA60ehhdZHwDYlsUSuYRvxdFxwyKT/cPk7CBjGZnOnCcgcDv6TbWwow2MUf2DElfXJbk2N6gd6ohz/eSesLDJqBqX9p3gGFxmVU4J7UXX3SJfKmf2RjIq8pWo/RTyk59+BwzVNjh8g2JsBr2lKBKxsNN8WSLxkqV+dbdSHh8IpmVbFKhxPLgcNQCAAdCqkg03TuUW7p/Zkc/fCnnVKefi2JLUybHMS9P47dtS5fom1wDYNLIllL/tb5IISsyXHlOtpldUNuKcg+feKOpEvH6A39ABDo0A7/WpJYp2NplMBuSPhDmedAsU9+NV/vb4S48gTjYN3oXVQLIWbEOlhcYsvEJW/unty8CY5WX6lWFh5bbtmk4lOwvV/kxEzgCCr7+R7YMcRoro1iM70hSVvryGILgMnKs/qie5NFc37L+E+lfef6nYdNyMIn6LYgQusz3gKIiwokRRGlIxYjeTl90Ih5BRUG5MKU89ux1ZnFtRXoubyt+xHVfZAY7utIfoQvvIg4S1nvhFb2yreTgUTVbooiIhnzu/PXUqyO0jO7vJJOmL6iB5ABX0qAGckyDfyJ59VKiNQL1SmyLcs7qMZNPbQS4WuHmDtKO/Nq6g6VSdbY3TtEgXNd9lzd76n7OlN0f+iLbMszkPUjPMk1ShTf/0ydmfDijutw4QZl2Ci1y7wZy48pAHygonvERKc3RUu7ILMOoItPjCP5CGJQ77LdjD1WLe9Sq6e1JjOFdZEjOgSfgtmC0UrWSC8RNMxwDRoJ4IU3MxNc9fJGnnyIA1NvqTg9BIRkq7uCYde6r9PdjtWoFXExtio7mIyDOEuHAzls90Yp2u71uJltzKy4nI3yc7LqnwyNBOgtY12nuSJra/ruKV8Mxjmxb0MwiK4vhjM+J0oTlvotmotYbMQyAAz4aw8Od29OR1x6CLAD6gz7Eo3EbaXRFRSShjCn10P6/DE1sVGqxu7AC4zi4g7KXuZ9/kcgVO4X4a/j6YCSBF9c4ct4vxJFiuX308gxYtx5WwD8md5ZcsNpUMRc/aO/B1L5q4uyGS4/qJzEm9Xzugnz3uScpH31EOzPYRmHWbCey3SVmNH5UyaCculJd8QLdJoeecDKCLTBQUDVoQueSpeh0neMay5QyqByyVnfjm7NoCzPqYSUhCjs1o7wY6JhR4hsA1DQL6iLm7VM2y1fu8EV43Sdm2pxj7YsMmyAYUBCkFSGQ13rcIJmLuSyNbVrkvYMgNn6ODABMVbPtzwdFlHDsxRgPVQdQMuJf9UQ9p7MH0ifW9Ur6jFN3eeReIp47BdeiEo9lDj7JMx4lskWer43i1UTbqIDBBfgpRc8q6IRyRR+tYubfrDUClplgvScVcBi/xX644/pDWptG7S1NB8uIULe9ctI8oyFd7dBMiQ/+dSqX4GrYm2VNpO9nlkDh8hJ4CRyV2iz7xtNmdP56S8f/38PHkYXgPve1QHhGFF9c0ekO3qKPq6K+8De4tXWyg3QodMv6+BJTgVzYucwGZjHvmnS092QefS6M8aPndTsHgqEFgIhCrrQpgLKdfac6QdmZbCCDj75AiB+LdNHoz6KviwSawAM98rHu6N8FJiFxzdQntSFzf1jEXCBTyG1kNvrlVWHaib2jJRyRksln+/NE4Sk38kwySAFtFMvf+MNHJdRSlqXORSaPxxOrJzuvJOh4CgKtApcMG1kfP0xJ3VveRLHXi76sDO8UP2koJVNK1SK1SZSzQu6PCZGncstGlNLUODaAjgz4M3moi/jKQaW2rh8HwN/0wAp+FWoVyjox2T28CKwsMY8vMx4ZL4YIp4sitvwdFwG9ku/BlnftT463xC7NIaQRUA35J+/j5b3zCYgSTscd+Gu56e02qU6M3lub/9fMQ2om+4yO2hUJOgIQUUhboFOYG1pQQahoOdnGGAe6CRo9Er6jHZrMWOHDkju93YjklCVoxHIGj2xLFxk1gyhSdi7c1vE6OQIsjnblnpyddm4CpFTWCRIFEtByRJ9hm3T+VsJbWZHn0U4TtHNOGlNGEIFhqKw+0F5LlMagwTGhhN30GhoYIjkgLhn2t97d9in8TkGe2J5IF4P8IVes6qrTiccFe6ILLyaY2XfVQBYx3/5tvisYVbXUtKEpiPvd7Tt7Qpqyaw8kZvyrpbOCnqqQjqKbh559IjHYVrzI6ipgMspfr4W7UnbG8BvzXAGQzBE2PC417LM3IgSGYEuTSfYJhyioKXvLS+IT8eAft02kTt6HretGOrMqUbpSAzpDJ7E5vGCcfCdqxDp2kLbISMfIEbs6QC2Z0G3Nfmn4ziDuObmsESddYoYZGwEtVjD9hVk3H2gL3mnuiNkj+Rrb17i8bViaOAIxuyeN17Tcmn8Aqp/nctg1BmG3nQ57ztt53MupRHf4gvJk2ZGaRNAOkrB3MzrfqG1JKMDOpZtHgB+rrH2Hn+mSkqtACuQFZYsvHSkTK8D9wr5XUd882vZcWFJEqNe7KBq1ip8KAr+52CKRItoUs+W2B/WiQfBZ7CLPcY0dVpCYovbqfqS1H23TMnHzlN0u26wXwYl3Vhdqyzm7XEblKVdf233SkRtAsx44dDfxFUiGc5FM4n4jhx3iVieNXQK/csF3Qm/k6WpITFX3gfxglWuTOdbuQ1JbCquTZf88AUAr0bg8DdKMgdbcSTTDDVnr/V+eFY1zjCQ2844MvVfhRabMvMTx4SHbaz4PU6JxijU+2Z9P50qEeK0sF6J+YpRADFXagNawKHpDGsFvsGBICmHETWAM3/0CQCKhl5JFypcPZ5bfHxk0rTabbRU6a01cd+YF+8xzGk1FbVlWZrg9c2iKAleGfxpQU5AlrEH6AEp1LpXUVA9oVvYwP+hei6Q+UaQ/Rd2webXdf4iCEyiZl4plKSM0rG2fMwIUR/ynsfGVuffW9ddDPl9X9YGeqeG2cZufRHEYea7mhH3FrS0/TcJfJfWnMFSTBvBobD4buKj50ijASDYwrCV8X+CUI/2XTPvSRExlyUzkhyY4sLGjAmfj1zzv8EpKp6jxT5RjXgyh14gOX5ss4t0pq57scgC4a5AC7ueLBnuoBYQ2rb1SLBHcQLBj4XD2zM/yqz0/aKqHOXdkiyi3vLvRgHWMv8EV9c4BrDWcDzR1Q6Szr6KiSkucyn1MHLM/w0RL9dXxxjhTwF8GeFZv6PCoEAHmGAzFKthzK5yvWUgeIDO9e++qyFDxCKn0dvdCpHYqCGShUzprsukYI7KQxT9rjQUI42wOQpYpn+90P4QM+CBM653T/Dhj1wO5W43yBHynUhHdkUwomxQUO5eI77VvipIas1rCh5xU96N/KBW/7WB1W6x/ixCoJTd3UyLfEtRysmRD524DbkZWaGJplmKTtvfpri7De31QlPNAtvG6KwgZvQWo+SGWFUgXCzoGoF9MQmxnQlQm5op1HEK5Bn+xAPLJC3cDnBTZRk92+vBXds9LOD24SDcnOSNHPxB+D+l6+SagshmI82sObCytlCBxPe9NARNfFigIq78/LgR21c78D7SZy2c1x9KxzVDHqELLFSETvt0ov2OTQkSuSb0t5pHLG3qojl+AlEgQk4RmIfeib+lbLdWKwjW5zoV3eMaBxG/bXJ42L/reHlDeL72hJFjIqccWyilrxA38LOBqtyStSdfXSlqD6R1spTDF0UENEE1fGIk+VDdmPsiin/JIaIo/eV6ZRJRw4rBpVdDnBaTb/pjlAAEIw5OTeS7srseN2bMdo/HeY4uz9teHIpe5/J0a7+GKMmV7sSzkXeXIGCUkBRSsOBiNUH+OTUhsQlrK+mv8oCsBObOLRevv0pgidsBAfIJsEC7td1Sxq+u39rdOjZ7cHF5iXlmd/n2EpezqbaTWFWztzEzT8wse5ZgBinkf3gnYDS0nbcNm3vH3CAbyLLOZ/np/mlj5vZQXo7MyrjAj4kmMpWNpdvRP9ea14N2Cq3Ym4lXL+lSWCj9pHkBOUj3iYdKHKiM9DPbiw2J/7MHk0n5xfKKxXUoBdDHGfB21v5kjmoEsQX9y+crdTgifUjdYb151C/vbtNu27MUrGMRiVbDem8123/w5ABwEou0SIk6gNsx2HZjXkevp07MUBiA0H4d2nsA50ZdiRljthcn3Z5e8sE8udzY8hu7ZJ9N72vhRax3HOoEtnZPSvzEvSnABPdNfPJoFxSOL7ilTf2LQ5Dt7W6t7jEsJ0JQEu7kizM6D5nkGhjyIouzvFxS7h+S/GQktBX4pZRVut97Rg8vhiRwViq9InMIVs5ImNkveZDBm3DrgiJ1P/UY2VNqP5xZEkAQKsURp2mOJ28d3NeFar+U97XAMV1IJ4vQpKCUyNM09BJVopP13YQWVKi5b/a/FM2zspqw7GUq8RvLm169PvcXELDNWPzGvD5bqze6BaXHACYkF0fy97AYn37Kl2utcnobW9M+pMWXiRYD8S/SR5FE570+GTobWWKl04LqrS+9jrAyG85wXZdvwx1rnbT36mFvnF8ndjqO6+Sf5KySQXW5PaOk338gkhQAQnbI+psqGfgKuusK4oPrJ2dF4fU1BRky7tkNN06TE5okvVtvLdW4KK4PEmibBQhbJnArKqOqpDUnFWs++crRzALRYi0wRrJL0SiJBsqZA0osdZ1429uIOx5IxsVaDqa+T4LK+kRNeBrnk4Jlo6KqTRLqTKqIulbKqlqyIHUASdy9Cyj+4lsWGlSmpoFTo1BZeLy/xYXYsf1fYqtzgwGFr5Gg/UBMoVMLFIBpo8YxqKrgMxOcvNKirwGu52SluQuCUq7ot8ueB484bJovFqKASd1oc2YBen/JnAhokjvsZjSItPHZ5+GAeh2vq/HWVePUSh20qjlK6CC93nqnJ6wHv6sFKgDFHdJu9zb2EaQ765SZfzNc0lYux7tLlsGWNGv8/J6Go/HjKWhs9araFoMyHOtsFTjuHU8NUez4Ia+AR43kqmQ9JBPBI+SqBMGjZ8KLN0DnlRRsSmTLpJyChltVQCaWDif270ig6ldry0PiTUHTaPHdl3JbsqyarO7qtYbsSSysC/zN6fxExP5DIAic49RHrBvyhIvNnQZR3/zgryFBzr5VXQSnXKS1ssalMS8jLCZSTWLrnKmKSr6ixBPihgZrWCzz6zsQ2bMmW7d4CWwS6BoFxD+mnFCdmnpKmUaROpDuMQuX5N7HDOMDDgtmTbXQqIfsfuoxcp4xzLKOsgRb62xRoRs0B6/6owclHnHSRowhmT2RnwwhKf9iJ4vJGapPZFjnXXKOn3Yq+tWqYwvqPwnutmt1+qzfxCFw+ojOyc5XOsYhQhkswkbubHlPbcs8Gb+bX88CvsPU+NuY3+kmteHb8PItTed5Ph69GzLPW4GgUC/rEclXXizTFoQvg2OmAaw9YHM30tNFZTj2D8GRRpxfzLlMW1ml3IPBMZHw3LlkWEMdA78mLs+JGfqjNj7vYr78eTjR/JXiXem1NmuPZqjH3rdUKEuCtXb5ux56Lj7y+jf7nHJA1DZ7Ys6V+uwASC5Mw/EWF2NeIaJeel/ApBTaROsnqqkskcXHJwu/jwJlRatumufWcPSKE/27s1eq4/O3MrkqD6vexbWxkQuqR/bLPqS8h3S0YdYxonuThOVzWBGLDm5VhCqWpyCRE3lbgoHGxwZMBbMQxPpIhNyAryUWwl75RpKBsvEf5J7kES7yZyLoHCa3oiduM6wZybL2sC1Tz+kEFKFvapTgrhhZse0Wf+7FiOMV1YXPVT591YzXUN5xk9kc+bP+GL0L32jo93gwTTZFw5eb2c1BHU3Wv+LsKf+lzEGk7dwVWt60aYmzbRcyQFx/lzFJqWi83JLkztSTEDY/KgZH9K/z2/GGyjwltq5zez9KXAxhAwi+lpFWlf8pNl/CZSRBPvap65wDsQ0aMjjitZk6rs05dZbrYTNrGlQwxO01tI0Tf7ymrXv2gqzazlwGPPk+E7YktFu7fc6kdQfm/B08fc/CJOuQt86wHPmkEmIKmlN78qMBdRlutyl4OTwQJxiU5FTG+pfAqm7l+Y6CN4hw5f4DKKcmkuB0zsSzwJcUnVDSwU1QdyLZX18yDxqQ0+wNp8rKctf8qcbOO6NcPnqKmwBd9USHHQU89joPwZrmTZ9gVnPQI7I4VM6KuvbPAQbnBMJ+OY+/A1QGP2pSXS2/7ADJ5EtrOruNHGstIBel7+htfMGQHnDS/uuDrmckJ+M7eYBBLrJQZEDu3MfNpKTNMRMAHwNxitUlxhQoc49jLbfLCT8soQQ9Pm7eKCPi54gC6dMNi8SXn2P00Uu8Ra9nysrQZCjslUMzOCnwNSxcvqU8zB61r63pkLxVxXt0sOrsOzRg/2dPshrUdHTwrPdVQSUORH8x856QFVTkC1ZKm79oK+xagJHusjLEQcVofH7G/404jestBwE7DJQkO5PheMi1uCUHjHQbHZp3w6EfjXLKQslfAmAzKGYvGX9ECAoR0AjIBxauS+JBu+nDgXpc0mTHlIb88EDeFC/Mf5djdEYzT3pdkM5KiB8nH1GV4zU9P/U+2S8sNXwGnujIjM7fvzccTYSV0vZhcK3q6hSNUUU0XUL5ipFpGIkSU6P/Gb6ZNzAGMjrA/jqxgOvOF3NAUYAL6fSg0txTwfE7ha+jYPX6K7JuGn4GgTPDSo05rTe1D3GJdNkLY5kZN8n9u0NG/iZbRqX2Jswchik+4tUmmILAxZ2LFUBQXg2VD+AbCObpfhPeLf05wAXhIbTBB+Ls9PftJO8URyfSkBQqcgyUwYSkfaLicBUgr0C70u780p3s3+QC5xNca/e2tlw/eooTtwuHW87HAh7Dl3jWbBbDvkJQbXA88k6eAYOxGFtuJ5LtGNtNNasFRTsZfbGD7JX41XOVAAiAoMt4IJNyfxxxmHTEB1mz36ek2FtnJmAn73HkybwiCCsy/HmBg0gKUoD9/3lobhf9UIxgabmIPwpistpfv8DQnfwpZcjC6a53Nb7+oEi2au6XWMchYSAMoJ7CBfN5BXHoMi479LdwBr85B0TR3JDjCdJubW25kQcTNsovU+6Rl5i2M+fAP8p7+vWtoez5CvFhzAtZTMqebJZTTtOfSD4s9rnRuriwLTsIcCSbtmAIq7tF3SPwnT16px9cL0pIfi3XHGorVQAHloh1TaksQlvk2hgBfJWr1lCYTB1pq3+XaaWiWYLATZj302v2sx3WbW294WFvSxrBT0ak4QV+CY4Up0Fp9c1QtsCuducHxkWXtcB1L3yWxyyRwUiwrvqNDVpCyjHyaTVDGCGxBMmctPVLZTtiRoRrrFvlOo/MNqd9eq8kf7YTphyDAPYciRZvbH8zfrBmJObOtypgC0/Mbe6H5F2pZfsYkTBPGRKW+7SHuHCK/jYMlkcpfBt4OQX0Zmkiekun0Z0s6uyT8Y1IbPcYkOCL2YFrwd2fzDOaODdMwcJl8LX2lZIk3guwKnz8EmggHkg9xgPQMM5PlfmJIUxV/RJz/zHYdotunmCANUcK9OUs5XPJ/ZPUmSMkuuVmjhy3Tc2IY8kA5dtcraujCT8DEzNq57nflOQbIJ+tCzYFhMRk3MIfLp6bwkS/i9ZaJeI3f+BLzcdGpu8G5a7DvXLrqSZwURpz/wlzQmlafcyI8isjE+I5o+or4mSLMKCJ0e6MVCqlGlfi5DzkwJLiof//WepeXGY7EhFPgbmbpmCK8rpxccz9EOqkzK+XlEnebTNEuEKKahk/Zu7gpNBH1x97aRHlSRugeW+4/z3fT2mlLYJvXOmpMuET/DfNJSNAFlfGz8GPMOMNRKgDppLkd+9/rt4qRX12v+OQCfWNToZrXGJTveqqV4O8APLHPsCtJx5mAHaxFzUo4O0XPxpRTrB1m/y7ECHmgTBk6dLdE+Xugz1+VV+Iqg4NiCcc9gbSXCSTl/pb0C/XXWfDu5SFYMpye5nyZthFzAd97xR54vjvfzmtocqwRJiACn83iOqGk4TDWezojC3s8Gcn/LRCvkg6KrgnjvncGBtVxebZ4W0N2IO3BmflHwSZDUfBrhK5aejE+jBClPW8Z66sd9UF7K7xefXBDxgOywghDjxZyiD35r6gY5eAoLNurYVSLDbBUm3PuLcmh29rXjItv/FhPNYXW5NSAjQioi/cCOAH4+M+MY6Mg1NgZveSeL4shHSMTjeXG7Wzohk2kVLQABlvfqyeAPlIMW4p7Shy6ZRNA4xt7UucrnrfTcn8gu1Jk432R2NV/PxbJg6hRGTb++NNVZWs0nuExHXQlcPgeqYRSnAh9QZIxn3QSXVdvKK6jswg4hRsPakR3YKl0bMDaE/+SIYkKdxWGIIOlyUFTblp4sTRgfdnpn1a+hMZkUB+vCGaPzfbZ3CPDRG/lce/VtMZxKUxLLZGzOYSnRgPg7THwp3rEE1gyU7BEiYlSPf7pnCQiSdSQzG8ugKUA/roWNy9xLfGth1RspFp+BHfLfKDu6SiXrlca37PBeGmJYLjnEhlJL5N2LCU61kJeNtTUyMl7gXij8umGTp0NY+E17D3CV+f23wnKkuCUQEbLgOL3ayztTYNYaeb+qIPG8zZheAyQs/0kb6iYbbumDpXhHDnFfGuSHE/PAYSlnJFcQzhrJxUoNVm+s9uXPlBMz6wcIqijcBs3Ic8CYtzm8NgjxScFdvtQJXrzimMsrJr5+m2hhzn+m7eL/ncLLKydzl/3Q5GxkdYUnpX1x/wlJB86hd1tCIKO2qZGrd9T3fq8SW9QB/39ahMHQo+V+RTDpyWwgPqpwqmWj+AN3yVao8S66NpSqcO6vI+l8RdEVzqxJ/M8idBrKHSipi89902ldzKlJxEkpTOitJN4+hXvnvOIpAPZhiZ/YA+y5hVNpU46KmiSWcBPtmctx8uelCCGmOGsE8IinE5BWg7L3Aiq2vaqhLP47fzys8uRLkwA+XaB0B8eMmRMXcmkQUOx9yzephaHGmE6yjNKlplAcAnGZLbruXukBM3ZbWiR9rklEh0iKZtTonulHl10zc0njLhr2FmCzD0l2BwXR6F84k5jIVwFtTbo4Axco6GzSQUknU27Nv5cWxTaLtmALqU2MXuNuAU9H9vGB+6H+7pQhSuv+CnMI+A+tJtRi1hYrGj+JJ5HGCPE+m5zj1Hr+ygSLQa7oiAu7/2CuxAS8/wNx0dG1koKWGs9Qzr+xBARuV0qbCU5TJf4ysIGCKaRANwNZUW+n/l+Fi8QyEA7Ls1ufuC0a6Ysm3UKwmLNBrOmXvsuffRkThx8Dum7dfICykLGJ8dtMe2WNIb3vMK+RTRL+d8NX4cmc6WsgM8dZSFqScUeoH8jlt3IT2lSXVgCCYzZs+yfsBK15F5Ii1XND+wpbVG4gZ12uctfpcPJJ759KIa76WkeaHdGt2TBTyfM2tur1e7mwZJaqlMJDgNGyc2mZTB9I3NtehNmCqdKkNWSz6IJ2PQTEi4VDtbN/CP+l76UE3BrhOKTCBJocga1dg7Kq1UemhkIM0pVeyYcQ9tEh3rpm44gcNw6bcU5G7MIi/ZSEK9i5CtQxCoJkk4WR0PsSOKy2kcTrTpkQUonMRhyD4rZRvrRzE2Qfhz1ef4OjVjgrnLNABJgWlUXHnLxYR7asfFMUHxGMyh9L2tPh7HBVnBeBsquW9EkcYkUMwQSVJPhUY4k5rai0jlu/fdDj3vrG9G/rSOIPL5tUdr+ICQfBpJs49xwaKkCDtaSwPpsIQ+Ermm1d/LfEYPwJvaD3wytKK22YzNiwOc2rLAecWYZ8BRD1IRcBAX480bF9QkaWimuiCpFIK++OKRkewnBIIrsgXhY7ccIeiyQI+kAO+f9riHUcwflQHT4akSXgGswwfL06Bu6w98wwkc633M6U9iAqtSaRdfnwHOyh0cXJkBRqIQpCMWpnfxzXwDEGLgl0Nbuyqi3cQKaJk5lgmy6Vien9MpJS0/XXHxe5mUUCN8ufTqqCBcpErcWJiCRkWkkm2sgwEAHNfz7zB+UM1cqaWgY1J9kVDe0pCHXDdUX7e6ykGozHqtHg/r/oiHc1SA5muHV8TReVnagXe8LBM6Yau85iE2mLpb94yZtLQR8Hu+km6wnlxiIFs3JMD3YestMG8+THOM2JnOHMPNzCPoSvqhFrkWNVEn39D7JK+E5LjY+Ko22Ufp7nMGggrqWWecUER2CPdNFhgAjzN0WXlK/PBMjn4Avaw+7pj7ExFZGVc07R0s3XyT9Zd/fsxx/bki+DvbG5eGkBQE6ZcbuY6F6OBjs5zXwJFhCrAjnvZ2CZxlM+oHKONzjT4N+isIeKCflTm9wTM/vFLhik6Bx2V9mvuJLBOHcoSkLDhdEAMnVxX8z4TotsJYUCBUK9FlaNQNHMtZ8QijPnrc2dhJx8tknMniS0ZMB4qtjBk3cQAPnIoHmJkUhJYjFn3mTF1ESjRZ6KhIrBFAIEUYiwckhGPDyVe0AuFS5FuPmF1cxrDWR8+EB/56ikLzUWd5gSTfE4nXa9+dWgQmMQDqXwGNXMj+cemWGrS65ts05hYkfxQ1Cu97+o/CH5A0Suy6JFWAHlnfoPlPwKbVt5rUO+0eT4OJRGDk7uJ3QafSv3V1lD++7oLUN7dirlIHymeHgFPaPCUJJU4xlkr9zX7lfvZ+leqv+Y/nuH9kFPbvgxO5IQM2lKMBW3ijT2OxHqhg9Ni+tUTkqkqKbmztZJkYpV5J3ov36YVA6PtRD5tihkuceqWrpKGWX6FaEMReiGouH2w6kysqMSH59apXv6t8NbA5HXfY+nycl7ZE0yvP+vMo7gKWEe0tP7vONZvsWJwGn+M7VgA271EFuI51jk84gZd7dZ8Oz6lW1mT3pdztaryvSjcE6PG2PeFdUpfMB202xdIsFVa/Li4VxacR9o6wi3XZidpZsr6V47sei21SEnvg8+ZS7BAOC36EGPGAYeFi0q2I81hhl10pFocVraOtNR6CUK+NX5khSxCbvCfX0DvTPlhrm5MzcoPFtTenqaeTe9xCXdxAfzeop6zvdkVZExwzc5O4drm4yS8CZRTnSsIfF9MUZ5W6ljvSSHTDBJNBZtzs8zPSksRvkHwkhkmTWHE1fZEV6ihZgbchTFlTJVA+pQsGdsb6RU/Ea7hciIF2hKFw5XMV8icfINmAQGZTbIorqGYW8NgDA+6Vg4sVc2Ll+SjVjF7T+kGPYya0CNjEk2zU5IuWPDJkqi5torOWr+WLKRXCeakg+8HHy20QjRjMx8Z92RJhfz1AA1Gsm4/GB6O7wMfdYUMMgUj9lDC8Bscy7u0mrSWId0DXARfnlmj1XKfUpQ1tGFdFix++xfXsNu2JW7R+r/ZQDPPQwCMpeBvopadzHCLhPXfTqh3dOxAIezL9QKfNbe6SLzJfw9jvDc9MA4LhB+ObbovCrgRUt6apsRrSOGHojdkwMZ13CWoXNsGrouXOPtLXGmqwTASOVzomNlI1iRij7PQHBBYAnbsZfaaV0/HqdpaY8VYZVmruAHXJJpNXbszI9nxk9TF8qbqabVBafqSW6107INPcbWXnSSZmjZVz5zqvhcQxsy/W2RVrwquxPrwS+5Fwqw6VfKOYWdGBUj9KgEaUaH60himkeBMY79hRCzxU1VBpWdcQnbaOXopI0DiXCZe/bn+n3R+/5g6ONjbgYuE86vjSgOejJ/vrIJLzNlSHRD/cjQFstrL9N3r0RaEmnQNzYx7Sn8ONM5NFyGCTFBNlEjkAw8oW5nrfXiowl5Tx+V4bkrweD1p/Y9ESB/xiZbD8BpAgo6v+jlKnEt2Z9HwoyXKyo4L9Ow7kTJ4y0Yxv+ayYeqLMgsGBkE1kO18p3XJO5h8/uDeFgU1pPTXqzIBfr2dyQUgcI09djgEXurz2gFzmmCC/s56UHfKfZEgzXjJnUCJ/ynJlkXQkMcOs3eAVWxtZIIwPANrcH4iMfhYzICzcRngk7xnBdddGgqRU0V9YmUxAXP95v8b0DSD2aArYIEwvx44xLt57yPr5ZkhFQgUklVKE5OE3fzdPoNaezoXWzy6i5g+2dZFeFl19WAdpH7pUJ7VvHpu2GJsuEpNCUrt51XJ/AWnXWqv9lOh+uSSaWmwqxI3bk0jUPwPBDJ8hS2X/ew2GmtFYHyusZfAWcZV1l5p0OFIuDOeh2wH5fCiUIM/fE7RPZclAvPBGu0q6BafkubC699+16Nj7gIYYoLykQAZscOq7qnRjYbl1xET8gocTjLOkERxuH85vtS9TC8dcLQXEXDYGH8XspgNxGlwrscsR3ub5bXynkWrhpC9i5zPUc9sVn+AMKPf9QECq7MDihm4/+0l8umIvpkwg6d7C6DWlOAlIBvwVWjCOBBlFtZplgnisS1J8QCVcHyAVd/sgF8SMTK5yOX0HA876RItYtHNfvyEk1pkv3kfvt3fgkEjoCAPemeczDUpzcK2lgm5fuNImKggyyNbZd8sFCQlnKGr0G4RVX+FyXUMdL8GTihWoyGsdXIjSa2kzStKKJPOGj198s6eRPCF6AVuZOpoAtWRhgC+FNQnN6E+qRdCgWEN8vZQTPmi6Bzfgc228dCS2XHz2zpuiCI2Q2NNOr00zJ8W5wsmBMjLarmL75z8SNiV3ifQydpTbOGfbbRWa5qed62H1PySl2tTd55GvUoWNHtMhEciwFkI9cxpJo7D0yD9YU/4+zQoZOZpSmi6C8S0fcrGaAsbJAGDS4Jpif4DCLfELURKGFQ7V+MIC5AZzotWEsmq49EkgpSEHN8Vt7Wk5594im6BAHZyB4ELIJ6s31caaCcpVtq0Iq2lqKKJgXLuFui4XYO/QRyRI5qk8ICMCCdFO4J3DDboKB7FVcMoo+kP87FZIBrKVneBH5Qu4DruL/CkPvPKCRJ7uaTJGGRdqiiL9ZBrr1/Yzcerwglbacnazp+6LyNk9p0DjuD4GZSJeB0DoUL2WF4eM2TqR5P5iuviY16Ff5JwmuajRHrdc8SGw0Zvegb0SqbSc6iXliiHTObsKx18FxNa8TD/BBY5gg9HvuyjipL96b6aXUTf33VXFMe9jAb1IHBVEm3waKCYJ1nwRWTGXNpJ+wnEUCFoIjFJLjVmtI/EuhD0jQ4fwav8M5ygttNuoc5wT+rqvUVfPAm/OoyELCqW6eVEig1QHQ6vKYj6dMkcoLwD/Ylp2bFJ5x3hEx6CUTx/1KfEjp9176s6iUnyAbD0IU2j7xdGEYapHOskV1nDSkDrPxu3Dk140X3lqx23FhiSUWG+vHJ/+KUyLquBlEA7dvzjD5q69185ygqvaanmGXHuZi8ccqj1s5xM+rYr/DaafcLuJ8mpL7LGsI7fxp9sGj561/0yHRNbbrU955kiGjHtkBXkAq2JMxXF1mxXUr21DH8Inm5BPY4SG/GNLwN6c9/oBhQ+Vl3YXOVsiKYojz/oYEifoQChzyqMrCZp4MtVgwkgD1ee3WYD9+4M0DQZEA5P5wqCVreG3GMQIU9ZRSL/hf+4yAkVraxeFMReew+T4TxRU5uLhKxv95g6pLl5uz5EZZ+ybidB4/yrN+mmrHC9Jc7p3Nrb1vaR8KbX3Od+Ye9JEnItpFMTZT60CADGu3qddESU0I/0owF6IRUxT0EsGmuMBTm04dSXusJMXgLg/iiCWgsVW65Y6bBv69PRYDWHxT0nci155hNYZfk937kzNB4+thkzKj9+c2MWE3sBmVVwqvtpnjMfLbYkvkDL8K/U1QjaRSLzy05i/i2b5i3Dt9jLnxZUG71bU4xTH329w82QMa13MxBbDbK5JSfY6jjTCw1xx7SS8z9Phc/2u373nTNGm2QaNfum0PlPg/KVOXcymIRtJkUsYZqKvVKk0AJU85MYthgMyhna9qfIC2uo6QACFgAagL7jRAImfBB3HPmuwK2k1dFdGPj13n6XWtluhRTDGFSEXAPA5GFJsP+S8m+sV0ev2hSe32eDymmFzlDWmvOORuexQ3GLljaU7iu3yeMQv2OaCmUPKBRGw5fLRLWCHcqtCxSNgRdoExBmI5io4d5UySQdzcJe6ySUpO0UV8szTRYi7XR1Zm91Q5qLZGfoUEfRAHyJBaskMAf+GJ/1NbLslWoVSEbOH6lZ6Qz7Obu15Mk6rFpAMSj8VfNJL5rAznGSyU3oHNg6uT2dynOIyCgXq10KD7F9f05l1D7L2jLIlMJPCGWckQlJmuEyk9bjxKRtLjIoYuQ5U8QJn42Ki0/U8FsUxfg3ZV+TImtsfzL5X/AisUkLg1f6HToDELt9Yzb1kJ+53iWbBWkmXm1/8S3IJU0n5p1HQ8MpjT2nPXi0IeiwUiaVqBt6jGGe9ntAi+27BcnENBzjmDTg+ewnvpRbkC/MHxuLpDPZzw2DVN2g6Ob6nb+Ds4kKzen2HhmWJttvOdBZGycuM8OwLraWyjdTrUxWbc6mD3vZkzfeooj5Pqj+cqpl1ZgcZMzS2CU/K71nDEF5YrbqZNA4Od4vkOaYAVEgauuGKb+3/lckoG9Mns0/xewr3L8c7wbuBOSOsf3OzbTirkzG4p/E627ZjaNFdoX5SxLKWv5BApjbUelhG/jzc/Ttq09K7V5nkMiQLl3g/mNMDeAIMFOun4oKCbBIXMqL93dRMLc68YlAwVI84oequgvm/zSid9FyasJ44TapAH79hdw6VLmT3Y5RGHlEliz7cjFgPv6ZB9GhlEJCNFicts50KBupTZf1oYwmV160kchs6XugtPL3XDS/jfVeIdcmkzmG05Rhn7RBDQ6C16uIRm4JZf6bCfrXBLSRmRqWj4djEMRWcoksH0HoV1RNJ9XCm7Can/S55MwCjTkKMJd8r+0ivPWZkiUVriOdrs8XVDgjsel7B/e1tPbEZOlImaZnQJCvp3QTfNfW9yz/WOdiAEpypCC+Z5X993jKSCo4hOP5dq+Pte9swtcy/wsrW1dYvoB+NFHPPStlAnLL/aQE9Q7lF7Y45FTeoGElpBFjNOn65rt6W1w+K7k6sLj4U4ph6UYBvx4Guy8n1UqKPWEgqO3VAlZQEK2DtUDidY79b5NJcmEOKo/QTK61n8DpcRPUaSzl3pZrw5u3Apz0gQue6Qi5mxkTRWryC0aGaorZZyHsZCu9w10bUUBiTQ5vYZcwoOCZkatF317dfPv2FoP3StKMTAXCFDJB8e1KWc7uHwjTAPVYLzSLKT0V+y+kEiXmN1JJ68C3Q3O2NkuVLxghpgFjTjWA2nHDcNDRwRbnIRpHm8h9aiFTnQobQNEeAWxNmNZHuO+vs6FVWANLrl86mzVshQywiP24BRECcl7P7wIHDrO73k3Fr2Py4d4vl5GbKVxbNCGbDLbMXbipJd7+RPA1KhY1gsy9SJEdcnQ4vvxKzy5XkiL0DCNi+2zWLnqP/7lL/dWu7APnMuLb5Uv8HDbzQn3sKXdnGkJ7ukqmfMv+Pi2AtEkS40p9hWJNzvRTUYvMiP/S1Nt9AkNw/6bNY/LCUG9ErEIt+GcuqMYsn2uIyWkRw61QKMRD62/iCHkgOfndCYTmA8mIPAGfOYWGcGuTlt/bAZeyteVER+fwSH/Z/veR7/ujX7bERetZ+UncrLhVBZToZFISmgjwJI6XLDKAj8sktztfiLnWpP5L5BPx4C/vFisLXprRvA+2pJQF7SeiOD7d8bV6wWCHVUfIOir1hfPBn/LHsk5LUSy8iuu3Z65dlxa1078LG53DagWqWChWL3jNwkHmXeyjl9heN98pfAHPo73eAgxYb5H33i7XlJAZfegjVIwwt/slhVZulHYcsnat92LdNv2bVyRfzN71e1l/s7YI/lMgd2ZCnQhMJvfkD6ULI6kVgcfX0c+ZOqY38ZrjzgsqOGUd38VU1z0044RVvEVgEVjTPOUwfqHupE55qJG4/f+1e8Jlt1+8qk4B4vXunSC5AdkEHvzVyalDsY4IxJw7L8UwZnbv8VlP4CEqzXtfKIvyycgLKeG5fCtAIDPhS3QC3Gxq9oyawlBh64tdDRmGDhu0EBsd/uRjvqLv/8XLykNqvZFsL5o346m4HB1FBbHaaALmfdmVBEeUWRkR8X2ExLd936yQkQKAT/TTHa9kjt0MGHlLebgJx1o2O08NpFmbG9Qou23eKq3ZYuTeTiMRbX6HZsmyyKlw08IKFzaxFEk7Jby3r5wcAADdYzyFSvNZ9iWXKbp0sdBLMQhN21/qixODgpYOmorCSYS+bZ/8icPOE42iPwT70Dt23M9rkzNoF77A0JbTALb/DNeCGtmxdyJrtx3QM/RKt5LYuwQxpzMpMvrjQi0GEKzgts63dGVfYtf1WUY+wKYyyrALLhQ9Feb7qboS1scfVclpzjhAPYZVr/Da2mcx8JjXDqUA+4E2Oq+5okhjiRrH+S7Gss3UKciv309Jw7luzWUX2rzGwDhsm+c88dfxCIHMF59OTGs+6nsMjhZRgSohX3BZQqFE2U67pE0Ux1F3ix19DavLWaSxMD7cz+aeSCeTCWzjT4IyEsyBRTuFMVuXlNDaBOVYiCgb1kzE+mEGhgfM3uhbX7wbjsABxdmHGENe+j46tzw0dFtYVVxG7OMLnF3vWxyyOJXefhHzlaFWry8qDkAMXLsMBHVAdPqgLTjT0ktdfc6rVQBrEO2PX77bXOla3ybaL5uQ4+p1TKnkLbIXEjE1f7778sAYaMFQVaR1qVuwCssv7wtdKfZS9GjOnlfbdLMsycoYLBqWC+73cK8ZroqCb0fCFq+dMNC8aM2AXIoiHdrUnryuxzvNmwNlH8o0vOssQLkqDBScHjhH0ZRuw2PbIygE8vc0nKcXsU0YU3Y0ZQdhPpFviFqfZbmXdJvn3f/R8JDpZcMjpfmcLqXuU6e4/TSMT20NG3klBj4rKJOtayNoTBeg7EaQyyi5MaM0DmVafP05yoqrvj8QiAjuxd5ADyF+Pt4iDEKRvtTw38BjzMlcSrnVShhEp3LgTAagpyIkd6egMaL9rbck+B9/pf072Ml+bUiYdQD67X4spjPOc6DJ9bQRdDcVRFSNWSNVgeHmyElAo4wYCcTLV2m8m6905Wz1u+bH7nMGGJQgv/PqqunKlUdX8p9qoxvwRI17zuWWz13twsCqVFS2HJTucaiOJwbWnlKrj1lxenOF1xzovcs7fehHRfPNsz6cZfRgbCkkl2ioTNuAVfcyXq4Ka/1+2T78XbqesUzEA8cRVcc1ZaMOvz7JP7adBR0/M/TYYDgBnXUsO+tiN/RruozgDypWwtdXL9XsqYUZ10xnezejh1xCDqHAyRvJjsJpQgqImkb1EQvmzpZrDy4oKvctGAI96boQGseS1Um+X42+IPYF6+veKFwIj7s7e9wRl+QaHR9wE5GifZh47Bk5ohzqUn7B1KpWPrwg/OOippjDrBLfI3lHsoon61mcOGZhrY7O+Dw8OEA5yQYMcDFRFlEo6i4mBx09rTTjvkA6Rmgzj9Ogy4fl3MSJBYCwkLpzcOB7nDozoVOLBs261+dpxaKFs/aXsak6BTYisXMxwTHtyuxB4iXLGsBJfh6YDWyry+EL5GwIB2TBUfk7jeXHzSuUKoCoz+CZvi3mI7r3hmLO5TdO3vGL6vXTfZOb9raDuEa5Re+tr0pwai9hc9D5TiGAHCTIxmPV2aLF4XVQGBmO9wJrmN+E0o3qIP5b1lpSRXxyCgT1m54yLSV50AkHC9xfj9B6HBWeUtkPhaAFBZT0BpZwdVlHZZAy1eXRscUiwRL2+Y4Jv7qJd0q0DI50w2Gm/iTIgoa1jznwDS95NNWk+hPRmPdhJi3Yp+Csff6AGW3oafDaT9H5V/ydgjnfWcm/RPSNley8KwjCA+qMVYQ1Gb3VCz8F1n1R8d5sQkt9ci7juPUvnyy2ukip82FtEW1VY/VsoAVRKAbEP7kYDbXWHwwiTyXVyGTs94T5iaVo9Wa7JzTK3bCzIfP+2mQK0cEl16rgsOTQHfatPlD48tWnwW00lqpmzS9NHeFD82a/Yyz8Qg+nI4L+2m3gkoTfE6RXWyvSZ9+Q6sns1mL054bdUW7K5MdwRHHubiJh/Wzusp7wlEmmAORLGcRWVEGzbxmwcUfITCYFWZHnqYX/7vlJ+7Qebm1hc+6jUT2DUfesHAg3wYmTrUNd1yL0Sf6GNEqZkcnMni8WC8ikBi5UnN+1PiVOjIjwnObuxe+a4Rgg+YjUOqZKgNycYI/td6wNbOcqAXx4u/WqKZOPxlY4SCt0vUXTpyUBGyAeSUtfoDSoyjxwO9ttlScG6YRRggFylVzZzZN5Iqx5S4K88hQ4OuA5rfI6UI5pBjNclNGFqVW560p9NYnlQATEWwCrtUoqzL3uIpZU/83Y2p4MSbx6anJMvys4CmFdhWWdjfu/wXgnzWcFV+8zwJHL69v0DmmlPqSQIfqYAJvp2bMhmh+MjaRGzGexJ4bwdCw3vjQ9mZ5Uzk274F+x/PYIRErvHqWlTe70hUmn9MclzQnasgluUBFSexD7gc0bWJAbjPt8YsyUjxEbTjJvjnQhp1h9zJaU/mqCSjxjaBl3QJefdLGOCv1FcstF/caT0rdesYwl1hHtSHNIfK2oHxf1XBrx6aB+62Sxpj1iXq2HvSxO9ZM5hLf1eZ3MiPeQrRkvmMFWEFNxLpWUoBDebnXT2gKoHxurCgCn+5h7FCs7p8eHBVTKXVFREjj7yU4XWikKJb8otWtSZHgRWzgsY2WN9mcIVeQXCq7NDusJQ4NfoviLfY+6GbxY8w0vH2JE8UkkBxZNzk3dEI4GxRubIgU7aSqiSP3TTt4vzFoxwYjLL4m450avrm14v8oMCWRThWNAuNRDtKji6pMzxfyHDSXLiT2JCcXYiseOaH7D4deRH3jOhVY9LAGOcziPN2EwuXWV5A9Mk4kzXk4C5JsPOF5tWYcpTbMlr29YpI4/cl0S4KQ2kFI4k74NR+KepXbKDwopr69KqT16WhvJFHmeLYEyN3S/XLR/JURiMb0REyZ9Z5sFU4TMBNuxFbcBA9Ah1Q/a0eWk8RNivdwTowQCL3FDIb5qqBfvzZwOnka5bKWmH34Ipxb8YrQAOgdVl5nPfK0gq0yxhrmedyR3yDAeIPRs/DnI02PlPoaCm9J4EazRdrGn2415PO0HJOr8iiQlFkII+tTr5DY3xqxgdDqUABvFBjegO746rM71Lh86d7uCFzT54/m0kZwUIa2GCk8WK8Ha2qeu3bjV6W0zD723vPSOGdv6Fu1tNDwMCtgY4a+ouvenBAzNv+hkuCluv9gGFcr+pmLRRXfMMkcw2DHNxaOo0wy1NsspOxPOhHkLfNI5uNB7RJV5buAJzS/BQJobgM/sf7pHHMYPXN5cIYMRdklt2DQiYyRYQME3m32aPUtfeTxahDvTy4uUhAG9CX3h3BFP3NLzgrB75U4nz5RhgxfruDVhoziqOvrrVMSNPmzPpbXL4giWNDrk2lwXcu5d7Q4ImNgPu45Lz045l5+A/EWKmm0P50XMDEL3QX/9glp/NJkcdfs/oKHupmrEFQOeQ1WI7UqONYbLtf+8Ao4kA075kURCsyb6Pna/BbKX3dOY7li8zIr9QAAFRAdukCSPJNI4FpzuR9SPcDTGKAX7Jj0UAGdg/Iir1m+vjlOy+ll2JorRXu7YyhOycLanfIhKqHwXWd7fqdV2i8v5r0EuqscZTlqBWEbHmrfI3MzXIyS2pgQhdLk2vF7/1KoUwFYAdJcbZE6C6UNF+9dF5MA2B5P0wcs2TD+A/MotWBmtxpNtwczuCkcTg7ZLQd6xtfOFVM+uz4aoa0gh1Wrl1Yql6HqfdZVCEF1JWJlcTtwsAOQvQS6c0118Eai6v0qzuIOvcEdLXZLzIxaQI4u/pbm/0Nbyh0RlpEfAJPRTdkukwBwZUy32UB2epJZr9m48lqazJkRc3lCT7yeuKoZsWnvpOtg4hm90hoSEgz2ixMmSjlyEFNZQbgoRYdJvweXVTTlHqj2XQHcwrRnOGvw2Y2hfDKanoWLS4ADB5s/xCCvOvFcRQ0G5O/W2+yj39NQCq7sYJDINVWCcf0C3rMHvdfmCQ/r2WIvB9wxj3iq9Qp6Iffe/5h0YyGrS12+ztsa2sUlfPxjSZtEeTmHaQmXI63TgJFjGaEr1QHDLL/WJFh9+GN+yQQCUWTshIBQNkb8TXWSgLD8FdAc0SA+aShBYCUE3tDMIcUn8PLJsVUZTnvKl9WY2j+TsHHdMd3kaxdtwSLeHqEFLSOIhy0iALLujjL/J6zAX+pwxfVu/vR0Bw5JnYEFdZUUrfpAuQvVzKHX43J5s/cZt5IECD2iAP0aPbWP1cQxS4WmEMNM/MgmFjw7qCfQzvPCMfkCM7EtaGriWe52IkQX1JMJcqO3HqdAWOfsHuwlCXg0xtDm0GngiqVwXiAUGOl6KxSaW8HKL7GmYj6E/T2FKJSf4yZq5T8NnVeqmCWv7Tacl7svIrMqXLEPJe5t7BCcsQs6DOheIokTwA3XuNE7Fm6SFn7Lq/wjjXP2Yici6s3uA9EfikZhHahoa5bnvd0BAYYQItYdO6uOB4vZfmTrauJ12BK71yQo4txvlN7EZ6ywhNRr8KvVv5QRjgmsUB1O+Z9o1mSWcANWvE/uk/aT+dQoyQEwrdXtYqgKFX0ZT2TAJEwkTNJhCWGzAdXM5hOnbS1wIjC86fFq89bxqhZ9BrK+51fgUk3WLbAAZo4NbLiwUlaRGgSXPUtZGUR2hlbk8ohXieat9JboRqHIaFsMCTVgt9dQ+/a593q8FeX8isOB73RTLi2QfLc9BOlpgEpXPa1iyJ/+PxKM9feXc8au9g3muPol7ygTAtkkdfn4RM+4+5BKHminlWEyZFApfBfzgOHCNTCGGkVUratNwrEUtP/RGvCa1DHtbudSAJTxg0VFttAnmIPFSpFozwjDv4MpOcf3dB0J3SAAdYJwXy/K9zyvkkJXxF50pKuc4Lsro1xFiNLSi/gKopoEQOEf6xT5FVH0AFycY9cgE96UrFkxDvA/qveJI5bxp6Uy3fUL5pDh5S1xAoQ0DzCT5gR7HaeNU716sx4tt2Q91AkXo56tmVPpQbldjQAaZTzUanrmjEc4zjSBMF3u/TpQcENVUPu1ZK6VTRUoln+ky63dfqMgJt9NB0BnbYZpio/85OG6NPlh+bnf+hfNu+nv+Wu0mIkPhzudkdJmQosgMtaCVZDuzkjS/uhJShAfe1stW82eJJetF0o+qrgyzbL7MaryCS9OqjPf6fM712LwU+eOxyRua3h8DdiEvWgTWcdsuND8ZPQzNcF7EWOtBVDT3nV4EJnUxTY9P1WO9isrhMaegI3IMoNt90abJl7T2hIEDxQuBXcITf8iQlWYvfI34ysCMi/iF3ip6SlTiePMZ8kz/tj1uoOrU5J26c/ZCLZPE1D0kyw/UkGqoGFPhil19ubxjYnXhte14dZHBfAXZsC4LfMXqfxq4JSv4r6ECYZr/qOll4v4RKYxhFpqZ6YqAA8oZaIxoE/0jqpgap7aJ/K6ad3UxKn/BtzCBr/GspZhUAAzE8t13ivPYG3IBJ17FzbCbJ8Pz3QaU83Iw24UH6SzMnqSWH5eBtTrXv2FIEQCNIANJeD0JosaQnbAvhM9dpa3GLJs5IXyb+RTK8D57nR5tMSGpmHOxZSmBmmvSMOgG2PgH2/D4h9OXEeIyb1Mn+AafzNgXOkNU8euqZb7FU+UM3fADmP3lYQW7oHJtMoHZeIoW6OOB4sj3yorkZxlVjmeEwYdbzZDAOR3lRtb3t/DCRtTL3YSvbJCmVayxEa2fywze07/J7bgP1+lAlgE3eTCHe1gGJleTQfw4ca18VUQEE6DA8LcBmoXGlQ8TV3S0PBBRxrlDTAd0NTcKKZpW8ZWqarX3mgIdmdaO4KGxpsUXTgEFM6gF1xi7F1qz46PWnY7E32fz/ySqB6FXZ65dapIdvaGopCG/jeZ4zMh//+G7fRsJDzDHcHTJ9hCR1i/nfq7Jhluo+DnsdxLwKBzUtnGw7bzTcdkycyen4bVbIauWBoxSQV/XoUaND0v9tZOmBTuQ9zkESO1+NGu7HvCmg50kwAHRR4yzGg5JbzEqaLZ6cBNqGu3OstLuxbTudT6DtRm5nHB2p92po1Fx+aC5COvE12T7KIcycSY3JuvpcCCag4z2v77N0K11JqmnoEBqctzS8HvrCpqfONBnjv00Glp8j4V7YlMGc6l1XfAHhRNW4FI9q2lxujDUYyiGhlhL7WtkFcX7sIzSq2AZ0fE8PT2SEQyhMDefL8cMqbjnSRUnJegHQM8XT8dVOGPwy0626kdzNpMSKxkrMbI0U+R2V5bkikfDnkRcM6/hhB/eVkAR4A/sLdoPxrq+KdoTRoq1qYTHO1NsySarkORfrdR9dS4sXYn3dx3/Ge5GVAQwq2C0nOXswV9iQP4c+IA2sWyRagAaEN+pVHcE3FC00FZmvLr/YvPvfbM9H7U6qtVijPxwclcq96k8rgAju0z4nHOm99dnszZZPVJdHOtDxvupJFYw9ncAYAn7E4GpPGT/B1OC+6wOWP3/4ggF5s9fCWAQtXguUQXMmY+NvAtqcx8nxfeo1jQvnEnnJiltJdfDZMwSeIoU1cqG836VHUXRdmYOZ2ViBYpytpe1NVTkvXZzkh0y+WZDCVhpM/4WgLIedD0R9ZHDF8IkS4h21GXARjrgpxUvOZMXWKhl2017pY6z0ttKk8GWBi07y/GZHTsEW/TJyFGkM0xHDg01aHrc3rtspu3O2YjcHYaJhRS3BmF7lYNPp27Mr7nTOs8EccZDwH9IY5UofUHw49L/CvGrpEwpLGBOGMnh8M47IluVbBpMmawcZzXoYmbrTxcWtE2KDTJROaU72frZdM/sSgqOPn9lltUoMzmZ1qL+0oR72do7wROARJ+0RtIZiw/P8qO68WdSaueZSCHTci+BN6m4H/TwCWyoyd4yvbK8aVHif2PGU5yarIBR88CZ4Hi5bYanKwTR4Mx3IY5dWu/eHwB1DlNTLiYhtmOqIKV8WNstn8byjKaJwrcz56Hu0RUDUz+v/9uf3hmktnYvZr+K7R3EY10YKyx7ZARoDiiv2C+OaMsyBenU9v+CfqUPXYFy4f5FImKk6ASu2Bo78IaGgevnOhLNrkp8qvDoqNLBb8KIgmBbNoOOTQ3FiEOLIV7yJAqWS86Nks8pDFghzXcrbvgFGXm+XiFu6P5ajx6JGF0H2Q9URhrO+gJ3NoMMzj2eidCvsYyQT+FD3ikdrEW+g8HX7VcCiufbIbWozjt4hveyNCGGtGnd3es3h0InrvwVL44ocRoPbU+ug+UG+4fG3unpS3epPTtP1HjO42+M1fHeNIffvOgN+1C+eYUUtUWz9zTZV6oizrJapI2VoYh6kJe7UAFoTzyM7ywOkwtVkypOg2DnL0GpBEDJdXhqzbwTCfPrgVPxhSm7slAKIYMSEKc5rdpytqzbZm5j2hmtSPnYW7xLtPQ5oOYzNUETyR6+BOFMTmzKBoCguV4orRHPoSUD/e1NsWO6JI0esWiCTbJWvifTZWvdzHCNhp1zej08TEPf0KbqAeFj3MaDLEiOMKK5yytjBBNniPvnK+oucZBI7DCs+s0i2Yhq8goz9vXpy2rfhkBx09OTRYH5yoNiL0h0SIfdZRakIMZQP0igZgWyjffKPgIh23P+Gd+FFTllOgBKCn3+gpiIwvc/+J7Li1hwXR3eKf/z6U6nKnxC7t7iilV5PGNeJxrbSn5vnKuUO4cXr2IpYO7yCp9HeSOt/0yBnL5jstTps2hP2QWUFrVfMGji24YJ0YxFB3sdAhbFdTdDcvbEEixn3cJy7EJe2FtgnYaS8OqMfKwSfd9Zc1JTtuPSxWx6QadE+KnmeWB5ou9YKva4c7ARNoI/1Ak0tL1sTBKPamJOTta7HdcqSa3Mo6CYtMkBXl83tIFckQneBFgcI69uMufYT5r2HVcNaN6wsiARGMh7ToB0RdfgN672oyVN0Pf18ldbTZ1bdFEWoam/cfWnjjfvDh4CzrheCgC0gijB6lr8H3ph6Me0F3YvkHqgAWVwvh6MXTmQF7hjEKSPvmEXerNtczT7B9Gg46/AOlCU7fSLZd5NK0OeIygNmdpDeizJh7bRkFEmS4b04XHUoxa5MLzaBb9QR4voKLEAlLEGzOdjoBwqSIt/lSQuSuG9Fd5oVLq4NAL83U+8Wn3VaETFvooDt6ju0dLcCrQ+XyKJQp6fmcOWFZMl52/l5HCxJ3IAmTAC55KM4WmsknjICi8Z2CIn6lca8RukI9t765N1yAoLuneVeXgag0MnjxxBa9G9CQgkP1Y278ZWWIw8hy5Z/wQea0yFeQuT0bNxmANGTibp63r3GPC77INVor/jjxekOAd5H2dDnV0fG3NQYMT0p3bg/6maUyXCkHTLNz9CLK0EWtASnzr3t5oL9ZSNSul4bWDupiY5qadzD+WD8wI7BuaVCuQi2+jiiawu19Qzqul/khKveZX+bCW8zYbZsKqpy8+LcVlUmpyelYn8djQ9k8+BZGH2XYc2KqBEd+3e5w9sSN6tOsTFHXsE4GK/G5crVQCwsADvi4dS+GpIhR6E463N4yVUTYPG64D2fD7H8ZNi19mzzOF2Wik9xq3CsvB2eD+qGHm8m2n8y0U3+6RQXlenkmDneJ6RnRYDOsmQAl8qbBduir4/RNhMX3LCOowyvwsPI+S5m8Jqm0ZbvGHBTeiPw4h34LjTLeOs3zRy0ffIOZBvXbNxS4cbL2gxhEjATbkT6FDgg8t5B/wKddL9HfLAiyaR1mws6VXdZZxW+IAbjd9maXv+NxzkufnKKsJQx6QyYLCn/zAM/LoRgjWZmvJ/ZiOGsZbT1BzMcTufDDfVd8ZOgdsQvC/SqIQYhAe2EjcdLm7mUv2hxixexwip/n08evip9rae8y82izLqkFIgDumoonoIkZqzILJ6aoHKGjAf1QfQ+QYxw8SQeMgY6NpZGScUYK7KGp0bcA04ZMs8ERWTcGifOL7yLQY91onhHhjma3MsH3tTI63WNT6yLCWeXfKOIMohCZWUF+EUgizE6j80pNQR9PmGhGLSMESpv4QXAwWfC1DNMbcgFC7CmUATx6aOMWh3z/c3wY4V4DiRAoNWAw1GZvJNQeu3S/GzDelAG+7OuzxtsWbW28+bDCbV/rqok/HNOlAejgOduSLfjQWzbCEkopx5Ep43PqqNkOSTdiS0m0mkIKMUouGmnfo3CabD9nwm2V62esuC77ze/CPeW79YuyizETokYyNHmrkqYzK+97IuTgCakEw2lnOGapgoZfeN6dGgM9emmp1L5qKG9rCzT2tZfGaOnqFuicOQQOvDAQbIVRKNHzC279F7zi467XCB7r589Hhyc1q04h7wr/IQ74c6w/1kxGBhbuxI0Ii9/PmKTQnrPN0ssCrCdqbGYY9/owcyvPw5vwngED1BTURP2Se+TVKoiUrhgoKM9ECtMOiV1JaBmaoqSybfPxvbIRyVlm7JmjdU8+aXERh2D1wG6fiJ6GcilkMIquu4fg4bQq90AUtLAVTSvQNRxcXSd2/bfJwuLSf8z8gJgczd7GzrLAnSJj6i12y140N4ccPYbKoOU6ZS+NjezOIkl+ESpQbAQZDyvAOxepYZlVm7hAD73na5j8oaj8Q0qXDeZjOLDOXs8ki0nM3Nqi94Eqg4vYqwiYdREjWpcNHNTX82bqrrQmEZZhZEORuMXhHnKZbz/Vfb5yk0yh5wzVrbTy4mXMXhxFyZSHx/iE9mn6FX4g69sFQLnJ18r3kZez2NyxyqEXIKeCejGNAi1KnZxHTgpmndaY9m12zIruSWFtT7UUMGtiTyb0nZfqmooemNMuVjM+1QMUn/9iRxLR8Ka0Y+ZUpPWwcDxMi941IZXaIR3eKcDs7y0NYvNZMr24GkbnZB+lW/s4uZ5gLTz8Vl9sq0DWjwuBLqiEJZmUymO9b4Dtm7lHzB7uARxKBNS21jivNF/Hs5uqtCzD2sPufh9V7Vx8ZR8x1cBqMhMcA+FcHADas9gdK6PIxlneqBi6a3oyk2QL3yxrrtHcPBkhOlZuTwWt1Xs8znzo3nrIXfHgikxGXGreSX/6ih4bdhB/K/Sq6mseqhh+FUCs9GJNYzeA9QHVhA3DUxBGxqA1lIlTf36L7QDpX0wm3Kg5+Yyat0o7WuSFTRcFi64kcYy9mSMvepbZCi5/Gne4hcgcmAUBFb7gg1t3UFn/r5f5N9ZMO7lBEw+zS4w0fjB/C6yZNyWsWZjR+05Fi0xSBu3NMiMIemYi9NH1aRTzK97HJVx9eF5eTUSTNLxlD4b/ule7i4/GU5kxsk3CbK/5T1AQjZ+8uUE1kosPabVhJCgjAXUbgukA6JJHUsdcMyVaMpgikyH00BSuodn8H6F6UHAhHehDI18lQWngnBpxcGYLaS4L8LHL8ofbYBJrrcwnI1EH50mBylTv5AShShm10hd8m5RqW5/DJ/fZ/wxvUdjpniUxLLZGBm8EdoJ6jCSo801pEhwuRpzpY9h+2OyRHPZaTYoi/9e7EX0YhmkrCKNRTtoyxpZAujgxlrTBaT9QsdI+fKyvLs/1mcULu+m02RMMUlhyFGB7YdjZIYlFAVfkU0QPtPQ35XSLQVJ8DYFiQfRh+ka0gcELXeiSnHVscyLrnBoUnptUdar13Z7omc1+Nkkmr3M0N4dSkau8yAhyOZ7k92r/Z/w626W5ponRSoI3J8z0ovxhFtHfRibB59swiS0WPYt30lQfxGM9SxyjI1axVbQcEv6YIWI7lkTosiXvCkw4yO/9m6p4cjppZWyHYvXk5l63blm78eIZASgEpo05LUS05xty9auoOB/aXT9ORbIPCFaQEGu/ly4dJoLQjrrRQ2GLrLT5mcV6PHDWlx+3eqwNrT19wMKR+C1W8uURjmyOasjqglBYTEsf5sdUk5qQRfpmot+vJghv4ddf7s3Q2aVgCNpVd7gzcSsBPnAHSMw97nIPAGDeqyAg+8r2oiLk9xzP0COJgjFbpEOHtk65jON8R3IF5IEwC3+eyvhNhMbibTnufbLSA4o+S19vRTudNHl7Aw9oxGodDNk/SuNB2bnSJNC3+qC5omV+aLNT/GcHOCAhpI2M/UJs3I0Rad+YIluqWz+WRYeJcBv83oCS64pG6TTorqj+kwKW8WRDcGERFzUdl9dU2x8Uy/f6dsIqPYzliq7zO88zYB4PEdUCWLFr74+7u2nCFe0pgR/PQxqHkPfRhk0KFhHiIfriuetIRBIMNH2ZApJvCD2gIgVxaCM8fSlMZT3lgEv0I9NlGiVrFYf/Q/Fh85x+GY8HbnrottazOCb/H8bxOaXVyBq2OkOWZjQB7bJcSGF/3rVJFKIOgZRamsFVz0yIwBfnfeqtsDhlFqnoGOvf45Y56xfNaSWBE02UjpugY0FGTbnpTBVmB4iLkSBeohavWj08HxLiiGsHfuO33OnJkl/pxRZTiCrnVzAgMuEFZpRLprEyJRCyQrsk+DZTevmTTr5fJyMZKmVz2OsNkt4yalLpfXLTrJrkuIsfkl3IhVrIEQ4Km+38bf5paiLXJxLXF0Q2INv898eLXhag7I9CsQnPSBTaZ9jGyhWMRlO00prwnUwMHipPH7EqQ3KMUSrLJJyhzDxngMEYpn+TExnJxw4dUKucwf6bKFyNPz5jxQIiO8LvzpckLY0741rE33xphntvDROcX6OmudxXSUc0r723eBGph8AMl1eB8h0Q5FqbxW+SGxBMeZNGUlSsaZiO/ZG4l54y3YXo5CWBqLQttiZ3CEncFbTV1cHuJBssmhczUiKdwtdrwav4/9m8noSlGE121P8lxPTUfMDeshLc2tz/Vw9kW6X7Go+5L0ywE1Fi3gokkkn+ABImJoi3Y5+ybuU8Z3Z/Fguw/Kt64wqQL50gcudk2OkCQhFj+xbaSUaPNjrdhwzc4dj0LCTz0tGuWlyj83zNDre2HglnS9J4ySAQFLiRYqI5jD/yp5OT5RxvBcr9X8LUQy3dz8uGhI4ccKzXMImNPf8BvW0IQMKtGMC0aGyp4wbM4b3onKuQnPpE45pVePj+xVJExHXyoz24MicK7aJ/ukJwvDZXt7/wygxvZBSBholD5GVNhWOCVS7o4VaJAtgKSmCba8rXkMStAApuwVX0A1WJDX11YeWUAJqdcqBIf/qAbBRn1B/sqYTAhTJV6Fs/7ZbSDRMRaVzwNO58HNKDBoDHTGLXhcWvTePoh5Tz+yquPEH3wwWFLWx3SK61QuytG+Hu9DmiBhL7eyuaDTwRcxSji0JU752ZuIDzQDaQ8hF5cexCbB8XyJpRvln2WxU74sedLbLo2zOwcSXt5tV+qMLqylPpnL3Z5wAJ67gIc8yOK4MIBYrv+rAvlFnQPEkm1jUiYeYVkjO54+cg9RJmsSdq3LY0NvKwpOoMKSwS+056/SFapafH5km1peWB1v/wQLK7gOxCLtUemtlMF1nF3dT4BantqC0uCYP6Pha4YBg5zIfm6hLj39wSc8exeK4tGR80ThcxUhfDgH5eheeAHAkyvXaR/eyC5/2qg67xlUyOeBunbyVKLNWFTCnJk7Cz/Tv6CWufuKQOqrapXcpdDFuxu8vfMaLHTylXk8DVS893gLlwUGNnYQNLnHP7O/x03zEHgBk79iShA0uFt4rCRVABKN+cGx58GZUY9tvdhQKufkT5BOZFFGwl0WCaidvvDnGHi5HYIywdiu6GoR8O/kSNa82+hds6Br/8tdv1akSeaNNcIMk2tykEPw9gMkZBNcyiUhLmtX3r94pTS0Vx+Ycq6n4fhPAIY5QI6TDeydD5ck0GqQEqO8T0JTzCouXGNRsEGr4fOUOzHRa7H/2DFDaeWwLSrF3HfhMlTBsVnPKGUHzTefzxdE1IHGyzFZh9A/E5vEJTX/DE5flkz1gufElR/I+ZJGEyfsc+oUBqu/711Ne6rizd51zPJN0QtJMmXZ/4bFIfN0oqPWhxRNNvaQFDcIX2t8kmECuSo2tXeKNRavPKNjyycaLlV+SPrdjIMx/K73+vc061s9pGqijlyY7o/DHJp4hX6SlFl4cPhVayJ2Mi1uJFJ/kExexzAU3fkxygCWFNswuF4/81T3j8NyDOewFEW4bgl9yiUGV9Ab8p9j7cpK2ikJyM6MHRW1ePZ8AA2oMmigyvn6d+K5yMxZElxUPFj5SrdTwVsN+2XZAWC5IHWZUvHU7Qx2ag1dklv8fyDnAmbtkiB7wi6MRo3gXb/F6iw17BX12PoXuFSs7+fjaEE1iiMGsmPbjFURxQvFMND5lJ5CKN8aI8uL3FlYRx52UpsWV05vHAvrQNN4HLuEfQzmRzS46h5UDyi67vzczfTzeXr2w4SweSgWl3aZc3S07nv9q/1P5Y6ElV0l+Cmhjs2Mki/vZO5EFxj7JYKuRKd0XS2O7cG0v9M6JeeKmn1w0bzf059j4+dTAp+rJXEBDZK8362jisU2h+E+fcBayY6pOUoeJBma2jlGAgcE8oeNJHV/KLFqFqCBZt1zmGg7QJqI1xMnmUiHwWt0BtAajrx8cF87DB/Xespddf27ZHNvyjKWlTQQqK8ZWu7emVe/qw3jyRkAKNZNGzL6ATEhqoAt/rkB9PMAu1pAFQpivExUCskecS6HxyYWFJHz0IGbAMMWzeQKq23GZX4G8XpKxUIvFkCca0NrDLfW9IWyGuAQRsvoPcaB/PGvqa3lWMnsBmo7pEMbs4dntp0F+S12Rbu+SOYM80BXKV7IX9+3Pz9n9FfWS4xbC3ic311u87maLaS8DI27jgNH7rusvgRQYB58xrqWE2VNI9JPICcUF2wWv7EDvo+CNxuGNChwAFKmpcoohjpOu6kRfUlxr2UKXeGpvARel+GZLWLxjCfF80Q+njiSx7p8P6G3sPbSsSB4hG6KPbTK9v6KheXDHengR8cERo1O8okLj5CiNwhZD44gkpmtOvxqPSX5dilN8qF9R7Uxjn7zyIiWgJcKP80RWmSZi8qevuA3ey9Yqu0prhAPzA5gnDnO9DZoVDFCvLK2ImD9tAMqEOsMdNSbBzXpqvOTcWD/YL89PtMNWMlEsRoJwMkcObxLGJfTOwsR4LeMP+ixtYYrnp8RUtnRxNZvOokiBMNlBrwfEMsJk2dE1rdu7kVio0Br/knBboSYH533VYWze+woq+d8dsm46665UQv54KVAR+B3lO4ueTTb1bSEHYXfxXUNw/o5no3kyPzKk/VK/xOGB95PCz1g+4lzmAO/B5SOaaxU5q4h+NNbnzTpVlfudmR8ielBChBXHy+twWc7embs69g0wz/TrgS1NrTOvcTn8qsGOJlKD+y5/6bg8dOQU06TVVsb0mcEkGyhutlMAYSN2h2EaA0lB3Yh9JtoszNBY4O9i4O4Pu1MLP3YRmP+QN7c47fRtEW+Uai6mARf+k072SJeyJmePA93YRuNNGYgUjukIIrmwxpKKGt7P3c5/QQdVG2LoYYOzviXgAnF9YSzRBooUMp28wwDYpJ26p2jQj7V0elgLSy6D28QWfCaUZUDXVGu7tX9iPft2X2ggOWy1g4QA5Na7HVz2YJRIN4kg2UMnEcw2Iod4uLpujUPmoLCqEmsi5I4Cm4MkbsrNuBsOJo9agI+fAkNyspRn8LL0JlTGkAxizTLt2S3nsQOKecO/uxRFcjWtXYA+lnATR7acSxDCcrHsGs/vqzm5Unix/My9h05BA7kPc6KCFSYSitKeZcCbXy1Xsm6zT/Vw2D4mTYKY0GV854A6e7o08UD3EQEgK0XvIvCycpRxgby69fbAY+Bd4doSkneGEkSDAor30INrNNS7j6Cez0zmV+0iVk8uYoq26LnrP4ox9qC90DJWlW0ZqfAtlNVO/ToKcOeAXR6UPzz7Zij614z2FtsFIeHTpvO5VpWqU/iVOsZEPNwpVgZ/Z93E4zsUYpW5mRLfvJ/oHFcFfs9gTFshjY65c5SS1ofOSNI8+XwtLxRtSI7wNmqiVYHkUHuTLUWR/CIv7TH3XZlSdQqsZ4TTBVyjsb1+LN0YyohrO94hsdC0rgJ2xxCMse4yCQ2wqK9ktcmnoYCU4AyOZwvgZEd8YidBHg0RJe4ywWo6cSH2k6la2gUovrr2CyZyRKXeiNfwpG5XpshdUi2kQtMecO8h39Ex7I56g65ZGMVRSVuGLsgNOyGEkxbGIFkozEMToMbtAdlk946tn8DLpiVDeaLbC36D8FRgqy8LCdXOV/R0jaKo8E76aKLXlRLfp2vNkYaGZXuggN4mCpB8u+x+zWuOI58Tq3oWVSocs8iDxSwFQDa0adEUMS8qrzi2UrVCndmaikO7MAY1JrJ87wtStJSS1tRYOkWl67b1yRmy5BHevrgGuOdU2Ynzp3kjZg0stS6gT8iOkM2ZAG70VhllbgZfvMsx7M4It+Bwo48+myMQjvMnI8Ea2hlafoLxoBoTHLxtlxg/MN/RUCu9LpFRp+mPQCvJgwszPAdjkY/z+99McmTJSzaOO2DcpQELzMkbgVnq+Vvszczvnt++r/Lklw39f0fprPXEo2XgmRM67qcuokDOSpuF0PvDBLRvnmQcYUYTByZVM53mRCoOtsBZheI/nMWGy5PLGzWVsltjnbQNN+KpocLHhIdqEuDLLVz947EGNvvWGyqz81Vxy6ppGIV60UyQtEYfvBU0DkkKhqjxr0El/99ema1C0A9XHgQj8myWevR9aV2NDqHRTQVtR6gSxuO3p2Z1SWz5Aw12KW9MhMLB4GJ1BFrgnQN5h9GeivgCCTbqr9I0y3tGvhuzdRXZNrQCQQ+v0O4JQv3F54QwaTptVoTFiWuEh/PkA6tzuLU5l3O0k42J+FLg2RFAWhdesC9ycVfMstJ63Git+CW6+b2B5rc6QZdigefsPxNoD2JdaxlPokH2dc58uV88HdqHUeyPP9EQ14NLG8An8esLM7nV+YJ7UhBbQWLUXyEH1uMZFy1DGI3lCySHz15be8zDFTE4q0XxfG8E9MOFxSQ1haqAq+WjKDIX9xOlNHwIaihVEP38vS8PaEdqw+mm3k0crlHis1FPB6q/E1M33K3fYT8rFWdIburTPaXrDWfO+JuSRSpxz6QPN+RgCOLtZLfp8NUBnoKHJ4NvBMPcNFfBKPagRnu/IzMQDc6GohUX37PcNYm1XL70XgfPm7UeamjY9BhSee6R9ndmBJiRn8B56K8/DwCUFWLYLpBpY4W0wUVnA62i/1VnDU8RF39fyPi09JD6ML90CWLsA9fcNsetXDwXoHwXSxTwb0FKZC4xieXXTR0szrsqyBDfxyzkcEVJdx1MI2CDB4t9UXyjPj9MpInX1P0rmuBKenGwGHyIsbWH1eDj+1LoLVIwG8rAeK2LKKmCBz7eF1v9zyyoHS3BN0kSpVp9ER0tnjZFyeKwiOhHhX1bJ23neWsIiCCqDEy6k4ULu80bOni5kpJeesONV57yh5MvwnG+u/unrBFGEYRYm3PFH5heA+1ysZSoGxD9ZotkFh9rt7YNj7m9O1YbQvKLuhvvt6hN7M3bbQ5Cdq5bD15W98ae+KALo3wWG8d3UkEk/ypAvMWCI0/hxUtBKpXGicN6tjP+4E0LQtUSTj18Ul+vWGSSTIDxEM/wdYCKHLpL0fmi9AULLj7YWQSqezpGBhD4omXfYyWIeE5QKaFe5Ctw7BxbAGf+IgfLpa0QZY5DBYge+1PtelUAE4XxbcxwobRSXkJgt0T+FzqKOWO+LEOHZmKeBzGNeC+c9ilh9VM45CHVuc5h9urvIYfwGt3D91aFrrm2C7sosEQY9DSNPym9c2z01SrMpJUKBDza2mCC0lsZYgQe55VXkcgWv0/SC8wpkZ3ImeE+0NcjSn4qfzfCAmYmF/RF8LrSfeJ1QpGyfdvoen/5HVv1dItMrHjfKMdqBrq+ESJrAVs8eYdv1Fi4GY/k9EGWN+0CeyOf9KBZPoLL87zRbm9dBCbd2si2hCbrd+/cycNnDeO6343uPNOc90hDuLAIEAaV02oYCNWGLgfaBXNuTjRpvr5bvPa+DdLLBaTp6VhLMTv23fO5KVC6QRRbr+QoTylqb0+iiD8NqI73l7ZFe3YdUvMcHTzF1IFABDiE1jmHEuA0Eq1rzrCG4W4krhIxEOBXBz0W6r4v62+Qnku6cal2nR4WqsKrUfDPfJBmjpveYW5uRbgmkYTFmEiIzH4JuGuntyoOO8VsLAv8DMtfrdcqAu3WR5Ng6KaitJTwZMy7H93aiSLD8LbzGkricMYF4KzvAVZ5V43nkX09BeOZ/h0RMC9qPn8y+qTIYDBe1JLHPUsGQXEtaVy5scjSISlUk227z64/FedB4nq6lDQvFb0pxwFU5rL3lPeQNbVQD/5m6mAE2M27YXkBKmITXAMYlmpSvLzTAaDZKLg3nFNBGFUkBSUWcfBMsTFV4JuBuT6xu8jDHAxHeyY183f09rRtZ4k7EU8iaJn+/Jzs82bgQ+GxUCShectc4c19ESdMp/Vm+5iAPd9goz+Qv0tNt9ZQaOrkLSSCBfjIqSBMaxS/trA2OFD9+eAioMD2SOfvDphts/YvWiEA+rpxBIem57/HM2WEvt+rbIc6Cqdw4G20W4rOqarASt3SKn8Zj0JYVBJ8zTck5nrE8A8jYV+Qsscb/N6V6ngXMXpc9mtB1dahS1Q5qFOnyLvfp0jZygEnStw59nQ8hvwJPAP1Y0Y0n558aN0V0R0AKm3UXNUBam2dj/W4ifLf9VRaj7eWIED2PbnIF4Xvo3DaQ/YJB9HM3sC8zWtQtOY8kvguYis+IqJVlUwHd87e5majCIikM0HLWpcZIE5YNV3OtJZU1x8p53HY9B4ysrcFtghDnEdIOczKhXcHaeyewgJl/Ie2V1V+dLnjkjEAsjpbSHHQcARhI98e0WX5O633rFD+CS/FUpOOasO17SVqEbDv935xKIbtfc6Q/hT34I02U5UJyiQf1DsoxSET1c82eCfKwSqCEVJpJghY980w5Z++LpI5jRAUD1yFj9O4b+W/Zlca6Bdamudfu/jJbHuaVJDQlYm8tdOq1qVvzuO0QTQ4O8hhcHD090ak3YnEH/DvzP+S9hoXVUgq7fHsbn75SmDKF4C9xBHKkwpTQP9f8Bccq4pDCoqL59qElhmvanb9fmnhnjLvK1kT2kxeGkztMsCZSlblb0ygz8PTi+VoJM802lnkIma/YGM/dxphZwVd+zLuy6CxcxG6NTwLSUKhb+PgiX9F8qMQKVMi1T0D5XAqE8JZ43Dzjnsyo/E7vcTzqAGc1XZr6DdmV3D4HyL34Wj2qPf7d2XZuJ0Dy8T89WO4nunZDQG8T/39/bM3rpZjm4jth4jnvV2ACtFGOu0+Jh10w+wY0l/pbP4b6oKjdhLsi1xPmKVrBuFgOTxeC+1yeHHJV9kN1wUgKW5e7hkGHIMGItlwREFONSq/CjFaeJKmQkfVcclvL1HUMAhRTFsHRWYMP5hDXsUZ0RoCrDkC8gYCDAt3dZOldWosQtmsfcFu/QDL5e4hqrYIcMfX8DhQ5u5kqD5AI9f8TmZq/Y/DC6W9sIQaUAqjhfxL8FExmC7Sa5NqSPZH3hZ4eEEN6M1ncTkXR550aUHiEgOfeM87dPnhKMSiNY0qM5UClMZuZRdH292fC0ZHHlEuMkxsT6/O8bA46ihNxRVh0yEjKSq5LX7FppnWwSxOoGbTR39AgNHgcJh1NT+nfRxTDTl1dYCCcFj6ABhQntssgYLEma0BJv9AXCS/FJjPk6yJeoO/aEYPX1jeNssR5if5xZNH5TGgHVQo5SCdCOY3lXIx6ySrH/beEbQAEDRijWB+R3SsQ7l6IB9qBQef0UCsygd49Bm6vws6q9FlSHT0N8ZQbtEurlow9XyMaHs4gng+4uLNM9FiTc/WM82JPNsu1dE0C5nBSdTJlgPWR1SU/Ew+gGEED9oXjRa9uEypEKlwIfyJAtx7+64ovgmVj8HYXaxsYV8cVhCCmS5ENpHn/Fy3W5mbjAMICQ16k15nJQm5bu4RvdeuVafeoDvhJFP6foSfc+gyM8dD5Fa9EheMUHPgwDoyOY/BTanpgVPyRkFKaSNkj4OXN+TY2iovAUJSZAKNM68VpRAH26XNmVenIhaJCU3Gk/swvGe7crPazdgiRDf6Rl1Gd+IVaZRtdigBnKGlDocCo/SZAdQB3bXUpjGO7DgisOj8k7yHNOjS9wjkdOBOn9K8oDmqWXrDbXUcR1/r8HOx42zTDYJPbtQD9Zd1G5UbPQB54vWaoP6pcc1UdR4InButZVqispNfOkGhjKHirXRgG2YcQejDS9FM8m/jmBRMBEJAwnT+Dm9KdsNIaFdoCHvQCi8NeyQoUf+mxM221M77PB1RHBEgHhJ0SRtaFPQ5vgxaMKfe77L/oMRH+C6SXrJst67TuqQGztTr3Fmcm9h9oHblE1OTGYjstejKcbXPRJ/6JL4dYVIZu3lsicJHmJ4KmeEHC8W2yivvUMkWULC8GzE/eqoAurmDxvE7wj/txe8ImcF32LzNDoVAAsnHHDcOFJgDitWTwAiDIKjUIaYJLc/Qn9glpRVsIir4i2gnyP3zchqCLoP8CX74YA13x4DCvjCsuGx4h1/q0WhLsyJ3XLkrtKZVneRGrqmA+jKIOEyjhg0MsIC59TP2orQnM1KKAxgNbzOMdQwispP3xhKAfUXDOr/YTqLsiw6Cl6j1k/mnaOgEReBU6Ko3Nb3mG6mR3O32JVAqAXW8vXRKLXSvaY2lRratX/EK2izvtQSLlJSpJFG9AbE1Gcba84gYvsbqzegS+KI1qjxwdw75GY01GSMb+tGvmgk4ucoCj3J7BiejLZzWBxQ4VuqkmfOkrALoEMI2w0m6jht1MztGFjvUpsndTEU12QEnaBgLdAXCh0Ngqt2kWMZM5a4S7/D+6E7QJ5DEbKAcQlB9QPFWcTE6Wa7uMhWwrVKEjyCT50HUIdzIA4MZ0Q4ngwKJwmOpTOpIARxejiVlxWeNQjsbss257hHyaLzoiixguZgQIsUQjC/dBXWdiKP5UV9Zpgaa2TIU7SpSqxn5ipzXWhKhIsDw4uTRqxu23Q9TOJYrnyqa09JbhOquQskK/Zdej0w+PxxDDi9iwutyPPi98L1KIvTC/twn9cm1ld6AI138l8LMEiRHJtzTzx9p8988cBpjluP3FVWZFxtiThTcXulZCPJd6Bcmmz84eSFpqIab8HSjNh0Y2x6JfOcirk7MRw7WwelcMYD25hz8DH1e4mqZaPiiPi53iOijXCKBlhJBPxJX+uStp0aGuiQR2Ue0iQzPR7IGCPAZ7uJD5L/0bzrx3P31VwOu+fDYU8CTTV4clXNxX5A93AjgiWkldeVCHOlBH7BQBhG5Oqx5pFK6txqNs6B5E9a2uyLJL3FPrmoAaF6kqDeo+Q69+xz02q0FFKmO2Nt5QkIiEVvj5iGvQzeRt8f6hBWAVlKXdYGygqsyqgUL+1L0ciAmMQ2/BztDtgCo0DUGVxy8viS9SjwGt4uFcu8P8X95wvznZjH7fHXQCfEjfMHCQuFQ/XGiQTev+LNCcgVTr5EMnLpnYt0L0UP4598Rt5nt3C8PLf7+vwleqPXw9o3/wTRts06ldxDoPdzijxxMHhOa759Y/MEbye+12VjnTEk70p54+wFysebTF1B/oQj9oQzb//sDz6OU/BW6RvBwvsA/fLwRJwxlGpQ66F+oSHftjGV0Qf7UBrSKAZ2g95SIzK0xAHpelHpkmc0hNHHiwtLNhsUXK9xlMSzdYQ5tYkDs1oozAsUzWJ9oFvND1fvBtNN1+AceuRhIjZ4O0ZviPcz+VooybFnTFNP1AW9JlLzYOw64FgQQ6USeUASu/TfJaAe2aaQKsB0WxKldVg1sBe2dCWwaMfv0SRJcpVo3xlcIJh9SPkDsBo64ZXtVGaIkiKGgYO5DarInPVIa0txyOqgA0XR5jk+6pud0UL3dEuv+hwx96SlSXw9M+VLWn0cTfXjW/Jw60e60zqIxL4ydVDDq+iFP/0lLD8fPGc8aC1do97hW3HKCEVXUCiIM624Mn0ZOWkS4Eyem1N1iPVDG/zGCUQc/K4zEiEB1KS0QzOJspdP6vM/gz3eySkqMT/Y/G1zbxjGZ+fX0iP1wfCyTnLJcSeyUXf1Oyc0WAtzMMvRYXctjAXujNSTIJwWbdylSF50HSPgPh7VBTkC7Mci4Ilq/BW2YkH7JwAbxeJCtqNLUgN8oORCe3sy4BjElNjMADoGoVgM6j+I2Y2cFiJM52kAHO0sMezfzOKk77IARawrFPBq4YOm8cD9q4Xfqo93KvIYJAXpqabm5H8xfD5cKD24HCuscBGpp7+kREt24iwuzTQU4dFE2KX6/CCuERy8FGATJYOR3hcJUWJdShmhXP/vRZAHEZuHCy5jbXeEt55mYC26WkQBJ9MFZ5NmT95AIEXECKzpf8XWS/VNh/1XKL6oNykyfxFlvBxLZB/doynoJngZN3K7865b2AGYvYl2NmnYhp5gribDQ8n89ujJmq7Z54ZeE0/vSNt3W6vGlTyelF/LZXOF5b+Qt+gcBPXh1tLFavpYkLhWQ34gisUQzha6XFaXXT5bKHGC0kLyrCAz6oBclryzaJ+pSaF4dYe6tBfU/v56iPUtp65lV32msbB6GpRtnjj4TM9KMLKL0Wlj0QoE4lZMNeqP5WZu1k15wHDMLdcS045ABgkMyZA3+Y+qs9KZTjXJPNdXSYze0ogJpvhaGuPPQp8PIEWiAXO6i8muPmRi4oiGgdDPXVAeiJTuee1q2ymCH9wc4tILCT9oYTYX4swBwRiyW9SuxkY0fcOFNd6gcmhpJP/EAydD+/VIrCEiOyoVVezWfNtlB48oL6jZWmDv8PStmAm5ecXyMWErHj+OJr1dbi23wSyclB6LWOYXFkTQeWRIepnpib+865NlgKh3hr7WCqih4pNQwu9w5KqmyIFZcBstqvOY4WlorWQ7iFeJ1SPPOXADZLUqpb6oDsf1vduQOZxqxg42t16U0ji/NOmAyxaxVmxCfbt4d7Lp+yrw1CDvNAhu9+z6oGTctqBr8C229p6Kir8xIDqQZrX8l/ytj0VgaCsjf1hf94ZRMDRaOh1EM0fvzLvSQyXwm6Yzgf1hKh35HTBvo8Lmbzeo1R6TnnchzAu+4gSgh2hj2zctek/wmbw+LAlvhk0h9v0Lnb3n4TntB1pZssWbf5Y0bX6nLoRXBaj7LKVWuGSbV/5WHosjANt+xsr5ZDcwYQq+wHPm8xD49/+d4wS5lTHi/9Dxv9+8WaTUtZ1ovjuai8V+uMthtisusCIpa0W+mmWyLY9rinVnQYhAvCQ971MCAeAS11K4dgG0vvYBqoLjTrSKmqg+hmVvOt8aoQ94JqLXuyGpJEJb4idAcaLHMBIrI9MXOw8hPQFkMOq1/Rs5bUBXjdQjSS4vcRgriz+UEfloDJpajNIggErLxoEv/fr8ZPxEcnBeZeInn49Q5dD8tH57+BZluSQXfNw/9Go2DzWiq48MsMV7kbaXXq/Ro5SGaFMub2zwHDHrCWdv3dO0/LqXZvqBA99T4L/ZWhSPy8kuoMjS6irbHwl8CW4+7gdciLISQAV8rA27GzKz1tMFnFYjPhmf2aQR6mjtrUAtOSIetkaBhXwFTCcIGPzIPpQoCRdO+d2hBzOGjQkIMSk0mfBIn5+Rmsr/bzQ01lL8tm4CoblDW3J6jDSOjQ9mp+uHgOzrMHPdusucWi4vMlCTGQ8si6mqa6Vu4306f/SxnGyvGUWN6iOXu68dEGnGSN862uqTYa6RYbSZYKKi30Z1+htzWxwwrXW6OvFD27cKvu7ozcRAssWhEZQYSzwwDZw9JiR6AllZrQUy3aftQxd6yV9oStboluwIy+Ed3SyD31ftAdJjoP+/zLw/xPz8GotYJvIIzZnDR6a/VVY/YhyEwhtyQYOUJj1ggY5XqIw4RD15PsD3HP0m0MhgOISheOUDOdZGQ775W4PLvE52c2ES/NIIbMMQoXLUueOrPaGHgOixxoo4p0IaL6pmolZ4OplTEuLDMIGpdwHvOHEsyYNKEGdqlR/2QY+zKvQJUTQ5mNBgc6p9bx9RH1piYLo7cIN/WbbwaSqE1cctlOMEBH4mWN/JZK1w3nhhWq2SfrJ3PMoVmdjcCdiWmb+ZDuc8H5XuUzs7+lrak3JJ0gfpFntB1h3bkZ7FO0d9Ruvq/xyw7vUpuj3FmJRGKKC0BGm1wbMelqXmjy+04RLXi4VLia9cgSrOfotWoUxoMihjBYtz9uvIeucuQPoLzPjtO7iG+4669lBp9MShXtH2QOCzI+gO2iMFtrrX4bptYtsD55vEGsfpas5dSx/yUzqSrZ8UJYVK+NN+b0TvwHMzd08nZYw4FaNSlPV4aHs56HEaFf0A9EnOK8ZJ1H11DcQPCkl5JKHqCwyAFuFnAdHFCDan+mJYRoiFi9rjfp33t+NGdFlaSDql8wr65sbvR98+SrM79N5saVwwSsodXDbu76QkI/XTwxPseTZ4yk7evtSgoWCl6QtUxKD9qUXLUQrLe+pP7dLmSbw3aJOqoFkp+gmZFM/9rNyxuREl/5rXuxoQd4j0cmHtCapa3ok881A6cuSTJW/Q3irzwEQoX0f3l5n6zoBu8NibSn9cGFrIZ8qiK/k85QG01VDoF+2iTGVQ4ajQidPPuJybxCnz2kQvtxVQlTT2qsst7MuHUikU6RaBpjCupandp+EUNOc96fm9dLvAQsHJQ/BTm8ArjTbLDDvsgqmd3GWCsp1BAsLHjoO4EFz3dVKgM3iPvb13cx9FBbpSBTJn7ZI7KlqvZxS8Mbty4yA/YsGFEqbng9Zu6Y3vIXnq/39fCPoZpdZXKVPK6ehnJZhKF7n0OhPryHZ/Qsw/b/tRHEt2mXaQXyT9izqkiCjHQPTVfMZNI68oE4A7SPzgLKKrbB8hZZI1o4agoeV2hxr8bhl3RCXkB3ktqo/QO/6+Fahuus1H3vIjUBqV/QKFdUuKOK8g0CHab8pAPRDP+WevWP7iAXD82bU0ZCeR+9bfynGYNW3B5DGM9lYDHB1BngffVCRW2itcjMapSGSzyZecUCWSksV4XihxWp1wVJVzoFu8625bxn7kHGQq/wNBzv+JKgZX540tRMY/vPvOP8kRXuizW5N9f5DuQFCyJtJT+aqIIwfUdRB+ovl9l0IOj+vOpTE01WUPmaHnCM6NgIW4L7SitNdPPEQDUuVm2x9F0Kfezy9NUO8ToTWOdkCBY/aAd5OvlKko7ewhF++NvU8FB8UsSrYsNj3FvtqPvpZLrLtx6WnM2hi1nfrfNewcb80SiXb2oQA5yNKIHJbv2siKBsw84qNC/q5qhJXqqjYYaJRPQDqfnEAh9f4wUeUXga7NrJKuyclILsRCVljKJY+lWyvmjcTS4YaX7+ORZMytBUCySzU0L6nh4DtC0m+iDWy8K1E+C6jqHgJ3UIUjBuBjY/7v8jAQrH7YjqpmjEoNNOJ2NPKJa43XMjTOFRq6ELjHTcLsmecxFsVDbPg9dHjkmkle94p5yLA79w+Wil6w8edCYJZSvHaxrBB6tp1QzFKOFoHWZGiUhkGMZimRrCCprBTmSoK/eZ0gbmMau/PHRXy1NZxSusyT54Rkfqs1D/hXdTlNOOgIg0gj9SGG+l/2hYJFvMfC88w1h98yv8wNo+3nTm9AQZb4oe/aBNmPp/o7N8najYOEsqQNUuH+LruCuhpYqcca0JDD3P4FdHYWM5arRv0ndbQy5c/GOyA8ThoiTkreLM+8hC4TOq8Jkg7ehioHgArCOzOTtIFaeWZ8oM7kfLA8r7SU2DuL/EDQYesXRfAP1QZtdYBjsbL7HxHlae3DsQj+kPEnVaofBMelM3uubRJrnuXb/tbZbk+eepLV+YZSBqelXEo5FtrYz8DbJDg9HPVosBioawgMihhjlODQh8e36Jg3o8DE820rhfxQyo6tqVF9NwznjkXnsY32HN+RqmGyUx704UhRFvM+CEsBW4/goEi52LCIrpq5Mql6ZKdM6tL+T8VXTcpM/NXpAdHv7dIzSyYDR4Ig7EOxN7pl0KPuvZAsf4kiiXyb+ZaejbJo02QtqrwN+8SXufOA2ZWx9iVp21JnhzZufe+AtNCD2/oGrcETF3rdPppeAjVmVSPzQnpphtQU2ItB5mhg+X8CormP6Cp70/MZZIiC3FCl4wk7aE9Ybg67pC2/j442tYKBpsMfOBdEPEozjnqIVfuu0+iYc8WsRyLczfKTHmVBAAbYbM43sr+UtZSFFFKCx0gbU5+cPx5zOJiG9vjcKLuI9v2kPkFNPOwAh2ymYrjukGRTp9iyMDFn0Jkor8rIB8BS0AUI4bJl7L2YsbgWa2aJHbF7Q4JaXdK/wNU4+yk+5cwQJt787aJYrfuBYNLV1y5bGg+btzWmzb86kDLW3rBTEVH2BHDGVZV5Txaoe3j1z6t+cRfqA8O5GVDHVwULua14fon7wh2RGAPS7UWgrJ7X+YVUVdxuVK7a+wjsxQaA6xQZ0GildDVxoi7CtWtQdye22WoB8jdp4AzpFfmywvBOYkHwVvpKPSDsUtmqtcTR8cJkSiqBrL+Ki7wb5gqg0X2nvgoqlLCDARnYVKw7z5BH+uZengIiuOcI7hqm+N8/0eLuw3XsL9B/cTmmhqDUTmSogwR8pzosih/qYjDui9RGma+HfpNNfeiN4yQxtcBGFdsz2sxDOLTNyblB9qJ7EHqmE24ytAIgU0HJA21PvY7xjF+ZjU3CgbHk5rtBWBDF6CRmH8r7L+gKqJf3KwXig+7di3RpHkJN9tEk+WMw8TpTTWsQvbtlNabrCxG+YpRrwhYjt1PbYgydN2kMW+oDOjLq2TQfZ1MZBFQzcOO8vfvHCHz8vIiD4qJ01FwTSIAM4LNwuWPCQq6fwDQ6jS/+nQ/MbjouoHQOFSXStQJnaLCuxUUlE8It+ZNjFUXGZGWtkH8e8fJakvhWIGB1mOZXR6d8wDyz+zj5QoEQ+YzZlAYYTrL76g9K0mbegciOmIg1jB4vYFOvP7bJK/WaHzJitzwwVDkg0rjsZBhYTqNyOLl2Hf3xpd2/kwCaxZK5gVzfFT7Q9oisaI/gvlJKxDA1Irlx6vCzW88HTlWTsjw1FkejkxDdzbeaZi+vwnL4VxmCDlldlQTHsBNemySQEGpPw/D8nNUutO863BYoG7pM8O8sReobpmOgprdAbyJN66+61RlIt+oA9aZmiHTHd1fv+zMPXpscWugL/j0WQpxJc2oz47bZOwbxU0/3n7ee7qz6P0K5jTawMTpYeMOsg/fiZVYKMPIXkjnOnuSZw13ahkZi2Zh+ep61cCfNnvAHiHwtFqYpBRz54WEj4CdUJE228kdUrDNRjlSRD+WDWfFoMQ3VaEwSnLMMuSc3M8Uf2ezsYeoqIHNSJHNDxhVXDb+e/EQRUD72t3wH99PBQIPu/jUR9g31sf/poTuDh3bRaNNY6RFEipGqDPvAh1VZGQMRcw2qMI4I4fAopgc4eB5FlkOMT69jOes32CEQhybJJ2a5Pbj99BV4c4K4virB65C8cq5C4nrtaj4PC/nRy/4QMqGtPIZIxVKNSnmsgbgOT4qNENeLujhsbOKQ1r3gTLHXnoZyia8XqqXIWkdwB25Jdv5V3PGun3a3zcz5U1DFYnVQmBa+ZqolgIVdyv06kL30vNgege1xoz8avmhlU9YBG4Ff+nx7dSfpL66OAcZcpFe1kevkHeH0kpOOSbPh4UaAQ8J0G53246JufxsxX5y6rF4Gffa8UwDhP0ZzDhVBzcdO1B+Hd+yldJmQuWxSk1foqI2o9Bjm3JcFsqziUVqEC3fNVHbVkpKL3BUIiq710s33S9oi67GnCeqYTjTsHnmO8pA6JDp+3LJzhIiKpkKLv0N482pC94ASoTyLGXWLN/kJtgLQkF6/Zhq0y8dZqTb9W46SOCOWw5h9JyF8j+y+OCthd9yjsvgoqoHTlzY9fu4f0zMtuYyOQ2IOrPjkfOFp/a9jRjfPHL9xsCiG6eV2LFB8pWX/E56LzIWIaRDnaRBFwWJKY2n6bBCVMPO/wbCP5xeCzj9DxX7/cj5rbUErgfuClEm0OyykTbC+FrkQJTj1u7dXcFmviX1mz7420eGk+Kut3250NNv+vJmBs0M1CzrLvnMSfP8Uyth4Xs1sV5COGOZ4ulvoOnpT/0lsG79vJY4LwkGhHl4o4U1kJ5l/S3i2f9mqJ/PMe/J6bjRfj12ypoi10n8f62ZutbpjlvUTKM+DFunAsx2YW11VJYWgkoPt+Y6mkLCLr3kyQE4Rztm/nafxYhKgrOHK1R++Q4G5tTDijEFDfYBKvhUMp66P7hBwwhBT2gByjwOg3My8h5gHj+PSifOxKVl1kJ8UstU2uvIomFCTynP9gEMn1dHXn7qdVMRfwNr1Mj1+qJwQOi3z2PWi2bzSEyonfv6s99IUExTjVzLsil5d3GJ89gJ1kLDikuI9tkKueEuXrcM6upSfvv67pBC2eKhyTnamvqjlwa2eSaYiyNGvdKib/6WbtghhIqOSaYppu1kxulaZM4Z54BIkWLUXkgx9eFSEVdwHkzs9jsHXZD2W65WZj2vaol4niOmNL+Ett0U/EFxCyG95EFVDINrxsg4lP/go/GANchE8ks7PRw7mxx+VjIEDxxBa+vyP3TKVz3VAWxeEj5OLRMHwmudmdic+UlhHO8bKH1fUmWS0L19a4gZtmf54z+KYZ7DWPQtcGRWhzhmdm8iKRJkkwtWlqqWsR7OQw3BTZIfiQZlBg8o3Cu9rINIASqiOPUt6xA3G3vX9w6rrx2hwN2osAh36Gy2oV+6akR6dAqILaI6lBnZUZslRSYOhb2/6Fu3p464Tn3hxi+JFJouKxqGBcrMwbBV59rtMc4IMQyXR5tf+TWaToZL4wL+VN0hjffKukToZ2z/VyA+s3/6/uc72ebGHJNDoJR4HAtzdB/vDGECFxRYJyEP0p6Hn1Mbl3x4utkx8RdN0CLxwjCFXVO02HbsOYLMp3aOwdtmqLzZVwvAavH2D8NOBL1RJXpspHj+aheSTnuE05Y5PBehHnsYEb4FzUNxM/Wb2F+6iezcb4oa257QBzFVpF4UaUbCl5DCxVHqw3D9Q/GCUcJzhxDbpr7EIsWIfvhXPI0Rfdzdtxtb0DVg5NlPgQm6b3qxqHqCxrqKhw1PV5F+GMuzh20U7ewLqN61vP7WNA1Mgzu1LMoBUC4glOpCF+/Fy1YyvKSCH9Fvj8kV+3/+wj8hZYOheIkTDNRjitm6DS6tJw8Idr0naUGTBQwCiJUd/WJYIJUR//Kk2OVejFWLHGlzR3upiH8w16jjUhrqnsZY5RdR5aDfrc2tabNxX/+CkBRUyhSbW3abytlHFf/m0lyCmYG41VNpDc0AM2HlVhJC9evSnFeT5O57ytQYegjv1Gn9vNFTDNrri8Lamwm0sVEa0epKxKh1S9PXHvbHj0PYBUABSxs8dFuILuld6N7djT62m/CDC+zc56fThm2/Toovdgdk+tLtsY3PyWZZE6yhJ88i/TOqjvhWSwgFhxG8AIeVDWfEMk6/61Tby4nKvvfaoA3Ai2c0A4TCSmkIhyiUYsucjs4U7gxQRgqw9GANpKfdo0Ut/2XJuFDHaSil8ijCungkA0uaVbAvrgz8pG5zJaXUNNigqmSvug6av5LU6j4JBIyDEzunsrAESHErjwoF5L4AEA0Mjz/AVTKHDq6EZCiCJELng+dpkqgPJa34vQ79Yv8zEQysyJq4x2aZ+UI9H9Gcig199+PqLQsUAGQGPoTFHb96vWTmpZZ1KzJWfFdDHVX1SaivRP8S0T9crQ98cLMuWBcAsI0GjbXTRqPIcu2LsywRca2OWVnJU0gP2Y/Fr44ezCMjs9nseBZG7uDP9kfnuBZOlxiaomL8PeDM8L6WpLmC9fShdS6rej7k+beJoZIcJ74/KV/Y4/uqZuWPKezYjmlRi7dNyT44/2t8xHLTgHj4u0F1QSrBU2eNoxli9kcsP5JS+6mpyutXpRMh+PRofqEwWEg/bQhqIGxjESgPYWiw+rYgKZknEyrrvtGrUL7dikEGqWampH/ETDu4YeIwv5+KdZIDJNMKrckezP2nL3PeMyaP3ETcOZSTLYhSgqRWdD9ogYB9rTdnqWNFwvhBvwHXkDm4mNPqiTOssIQYSMS6/zUGcNmU7UhBKLiS/jvH8jLQML/Z+5hRbf6zQX3Sw2hCduKFTMJB8YMU8NRoFLoR23ET9m7FtxD+Lfp146PD8nPyYEP0W7QQ2IIU0wK5PFbEJWXM70Uv7WLuvE2TeloEIZozFD6H9qckTdSCiczsU2UVp6Kt5cQA5DkKtufL0iGEZvTRCPAI8KdNSTC1aOQYBRjRPBTEr29L8EBX5LSCXPBDsCVa3+xK7CiMfLkpOvTfm0/jVTvUmjOA/FN64AJPS/3e2uX/j7atxzZSu2MddPg7Xzidven8rRdft8hWSh4wqWr62QNirgzrago2TTcalvLSZP6YbYTsHRT9HBbBGm2n7TYX5d3qhxNz9RVPSAbCPiLF9hhepcCB9R8yWtW/0nIwhAesXCWVfzTmIBkGtGiUb1G/OipylhG8UgM3JcgbIIRMQOw6jAcvvyfGW8cM1qfdnONWmBaIb0xo2/t2ubwT/+B84T4nBJZN2Lj32mYEA+/a9oxRDLxd7D25XY3jScM6tLB8aD8BgoZKZLtKuRVkd6NIdMFaiwtoeItX7H7DclZhgeRNJHWy9ylBAB6YVzLMNlsvz1bw6Adg8QyqmmKwSpC8DWqvwjfhjKTlW2GzNYMEZGtPP02NaOVpETvsI0+E8nkScAfhVJFRVBWOmZPUnJb5ADojwb8/3LWocUF3nYemQCRBCgTEmOrPHCthJQ2LQMjeAky468DZ78kUJmAUBI8Ajgen1IQ+6JaGU8HwI9ZihbGO3axs4QJ7BOXC+VQboCsfeOz9XcI+MLH01YBSVr+tgNqniK7z5zp76QbKofDy7UImw/DTBnVomEmI03P3E4cdK4klGwf9Xh6wsW++y33+v9XaJaFSdyj0ppKSRvYwcwTdOOctZLAUunBteiRrNc1GnrdUT7CAw3PFLRwaIwW6q2qZocxoAK82DkxagCZtL8LsO1TZnb6+x2FowRDOFReA2ycVUv+zwPlOTSwTXuJysMwm+iPF+3yTOLGbC8XREGUGH7IrJ/QprTGraei4FDpxp5TX7oq8ACTd6HmJH1c8MzrANbTA0y2ygJvF5Rzw/iPvbco2WqHTXixXEop7bg6C3TevJtGPcsSH8RiHEOJISj3D1vTAuL8Scu+EzifNmNhEhYML4WuPfYrZVrC08td845r3j/SwBTnXpwBftWyj9YWPcfKaXZWRXfd/PulvDmNDX7zJ7aAH0stmW4lgk+hv3uPb1VuFnbOsn1lHjxMBKYo+y1UCqvHh/LPJlI//ndPyIceu8LzIkuXICyrOv3gWkslWb5k9V6QY+UDofmA7ajcxgg7ZcodMoIbOfxX9/Dq/GHWHbVpruli8cEs8UERle9up2H3nCvlKH77odi3hGf2bGqKlq1Xj4dq+SlZ6nkGszoNjGBtqsk2uhMJyke0rCtIfg4KHz5TK6L1rptUaXCG1rx+tTAucxYkUuE5nSW8XHyFnCoWMYjQEok5o+BzYaS6iwhCKgcJwlkN4e9xSUDIavR1mtvKIsqvFNdovJmhP7anR6ez4/Qg4D+H0S5lR6TylqWsOh/tXOPSvJueZSLehwXOjK7yh5ktFcWTBa2X8FakMnuwNJzSKNMm9Xs+khx9JK2JFALSR6otS6ECv9o98slyqG4hF5diT3L2ZLijSTfJFoKvDSOzCisjwWMhD6XsFwBEUl/tD2/HsGw4gh+jhN+bpya1So5VmlAsBLWRH2wpisXZq2dyOqUrwQInsEFRf9kGZnYoE7BHVPG17LcpRnF+ndPru8xHc24ivvPA5pfHwrLPtGSMnc2W0K33eYJMQdRZmSdtTTuVRVkfO1aTtkfsdk0Ebj0ZwYq3oSd5ojUABTtwWk5gEwGO/Ll7QvjkEQkue+sCCoaEYDovR9Yg9Uy5Y+PBaTd+EZOvJ9rXPw7zmvD3a3D/xulVXqfNCBKJ/rbvcgmCDNy3p1vCFHtDQOHO8hsyHsBh8QyQbxFX9qA7t2qtf7nTyDlnEkValQc++7Te10vYRotuYimBaTv5DaQD9sj2tSY61TkPhjmwx4KNCslDQywTwCWLjLSQloZB1qoYI2rlIszVC52QLCxDLrTQN+k/oGtWByXQGhW84z5LR+uuRSW7zb8cZ8aP0dyioQ+Hj8LWcvK2icTnHFOPQxH5sKLVTfrhHONx0iFLFUGAKoOT8XkfUFhmRXgsW43qKD2/Q6no7GN3fqbfdzjkctcb5IzyJyRoef5Hj2eHwQy5vJtSBrTQjTQfr4CiW3I5qDVV7S9qmhgLLXC0HRG/4/b7e05xZTXJV/VimC/2wjNTCaSyqHml+7FTdbb3O9Vl8k2pMdqXb9Wq8J1nLQ/IQ0O8sI1v7544Nh4hChi/cl6ds8ffgH4bJ0Ute9Mz/1+/JwusFBUiIqELW7MxRuMuOuAAVmHhso3Ifldby5dTHWjVGsEyFzDD4PmeYPsG+aLctN0H5RdgHR1K3MVK8BrXsoiTenFVNKmltp3bnmIvA5N4cbl5S6rA1pu2kkABl7HzEwx76puPonM+zyHeXBqMwqryuGB/fTByUtoH70+HZr6W1QiLgtOTZgWOGH2v3aaCT17ptgGlWqaSQW5/Po/dhLL7U51Esgha/HWPtuQ6JAq/VkhXEInzcp43sd+eTh27n1Pc9loU3BuX0yQ7LEVVTfifnUq06+SdbKABnycNCyItAR/H0+rQHgIn0bvq93gXvpzizrf9FCkBRQ2JMBlOJmslA3ZHpPgKGIOysfcKJjh17eah4H12C0vxxl8pvzfoAhswQdlHZ61FYZ4CQomN3GWe2MoyleYlA4jnby3jsle0IdxbMqEHdS9Xne6ke6JonlpmOD/ABruk4Vj69slI/jrEu79GdodDO53H5iesSLEan4VjeXsN//pD1Ua2halbZVZir4H00peq7bJsAliMC8XSyO61VL6NOjRKTbirplsUgJdSCgYqMssOQk4/XEc9IUgpqkgWyKXKx4JkPg+UZYgz0thS7JE4la6PjrgRe3MLunuIMXx0JBr7bapdnRb1C1aW2TZNrPOk34/K09YBbyzXbl6IC9E2SxYOuaf2HpWJEVfPIs5b3VaTCshCgNJ5lIyWuIoSDuMLBKalwGF15217M+3Kz82HnFnkqrYYCvvh8GyKMPHTgJGB9saB2SYOUFjbgu9mGPpRuqeaXlSsaaMI+OLNK1BM9XnS04lyE8dFiTZeUDxZTXNRpyFrC89dCNmi1VgtkBWuEPN+BHvRuAOv3eSb7WBShLxobhWUybosa70763kBvXxTxYKxyzKbzeAA/Ixvk/c1pswsijIP3xGGssq/z86/5j4IEEsGKld7cfuuWBCVjHe2WrUV55zHeEIYE2/ovD6eVj4Z9yqb9D8nOL+LJkq+sJkOW6B/6KlgD1BMB14NiQRmzXJ/aEyyb26JrPMy44wkTrdDcBfQ+YQiAVtp77T5hQm2Xg7IoZ4yhjbyA72D29qXz3fsOVxCCBWm05uItkLnWnZmqhvRVmOBNowPaVU1cGpwP48153TemCsBQTdPuauBG9u/Tzqq2ERjNYg1CWVrhYmxLaoF3TY1eeEbqLxrUgR35ys4crxCDLiXwzLmd+NGCucTGdONFkWW06Gz0JL7ItHbU87C492U0niPmyW1D8+NkJ1NFxgpr9zhD6PidjGNpboK7F2KuUMzXV4JHBGmA9qKctUkuRUe/wNKTE+JuDVWoa+Dmq5o/Sg4QmFFaol1iDRUMLpEvSivXLhz7tpsEftHAsPsYFjQWgTqJWjMWlXrnu82peHmUZObnRGs7tFcU2f/awZa/GRUNS0FSCLIpKYbTR8yvLfCvl6Gq7WhZqjww5Gft6cIn8zWOdcWh44/htMPCOYDClk2YX3lVPP7iXN4IrjboLuz1r13Gw8NpG+NQIcPukdvMtj+vNofEes0RsUtjcr+06IOZLyycXBj/euxGB8dBtpGClavan1L0pC3suL2Qj8n/1B8vHS+gjmT8mFNr7hHQUUOizGScaMrpeGYYyFyvf1QG3uDfFKPGapy6IQvx7QH9lEgyMnPRuu7KIw28VapbaVEVnACsBlqGydF0B7r6+g1WTMgXR4Bczv6SSZ7rXAznj0mFt8At3QMpMrTbxcrwDuGdfVriJLAPBUZ+67Oq/i1nbKoafIVWRnuViteOxe5Ogbu0d1I1RJb+Q99KYtxYTL7thoQUhfqUzJGj1hKRmuSqV/hE8DCkvj7+GPUTN9OhylGavcuGPQnub1HFSDSYNHA+H86LL+/nYOW2HMv6+0orXWiILLPOE4+0DMemb1k++f0kU0WCHU9d4nG7bejOSheBLG4/YUtxkvhuBdk6gKBlUm3d38EpHezjodqAKiYvET/11LjGq3+cZ9tMi1M8/3VWSQ3HBofVv37OE6ivqQdNy/aKcNXnBADL0LitzL7YCOQ7K8Gu47tjb45GUJgbjIzVecVpsjLmZXsqnoFrAommzrV0cn4SsZPxMeChE+FjHE6mp/uiUbbnjaYI/Fg1tq6JUgfx80djZpLZL5EboQAEYslFAbyYHJYMfg+rpp2H9hJ6IhTiGOqZKWbSvxVEf6Krui1kGEYWpZc6lEyy4CZJKUrJsrIo29rUFeQHkHsF8b5t3c7ebwHP5E9S8uYGLpthf0dv+2DVqkVyPFrhgEIU0yZiJZLJai2PeQv3cYsnB3h5xZtWu/yW4urjSsarMK9TE4HVtHwJco31Hol7ztRKfbSO5Y32ENcVgCPJqXom2EItCP+DpWnOFbEnhji3zn1a4arkorZJb8Eyuwmw7fNJIHbi+agwjkbZKvJYIi+XiF7rs0ls4LK1lgqwMp3rFBtcrwNAi7TPQxJHGH1vIZ241vE4cJ16POkxV8kwmlgAsLBDi30Jk+5JlNe8plU2iRS6ZH9YhsFnLbuLjMbOl2LCipI6gaTS/oHwImKJanEtDM0X53CMCW2ADJCjgiVT7GviXIM+wsi64IesvPcfH8eVSs19JBKwzlfGrUrW91rARjuFm07fnvLk/Nl+Nwg6gcnsJ4JH5KeK3fV/AfZfefbCFrv6+ApzGf0WHr7WtFr6T6/G5m4chPjcUNtskxTIgq2GwcfKkkt1Ois9kRFuhRxcRmgGY4PkRUH1a1lCM991fM/BM0pFJqPUKfb/8AoyygpH3/ZzCxvucBbA7DHxhn3J33yXLIp76+vHXHNuBaoBp2VQog5j2IhPUa+GLAfL/XXhPgzEccs3bDHMut0LcoIApDkxnkk3rNdNLp9/Rh9ZPZuH8GFIuZQJv/JErrpSLSZSfcXIMN+JMTTnLou8VG3eu3ORnzpIETSujYYDNInEbKOdOaWmyr388N45HsigokgomcV/GI9wXe1DtGhjNAGHQd8WjbeZIEd/uJ8T4RCBOS3MZoyaOcCsKo+X8+kb0JYddfD8U/eW9XV+7/1MVSAtLh1q4HimOSQjWQklQ/WK2Xdd5o26rFZjpGr2uM51XrvHPQcnPhSqLbTU5x+EWfBnAfShO0RcggbdPcWXZKuw3oPbT8+ZPGez1Wpghy3kt5AwbQwAgVMcOipc6NLR9/jRZUhvcEwPj5ZPxq80ZmfBujQnFC95dCHkXhulfe4/8uP5y38hUCxHz7awHme3YU0Pt1B8+5DqfzidUXqoDiCv8d2NvXzJgl60PYikepVSDMd9XgNeV9qqHSnMxuIZo2I5G21Xvbmb6ug1edbzL5qMHl2dTIZCn/YhjQF6RQMcsXl7sm+K5M2P0N1IKo6WVcSsflXkcBUOxlvxcEDKc9AeV5+5RstUi9/TDy1rRNoQ8RP+E5b6oB6+bqaTO1Kk6ysTzbpVbbukbccvTUuE4XPgF6iqdJm3GmF/nubv8Hlv2PLIJTGQYaioytHFq9SCFQtZGPVN0gE2BPvMVzjjCdI9MwqMV11QYYCN84wKHHenjm+rKWRG7umgFoTLvtd1QnDXgXRgYYJtueuesivXWpbqlhBGFbJLBfNHp/d6weF5WLhZTEHSAScjG2joNCABwDTfaIWlIci/IJ2dqh13uutRlTpvaLt7eWJ1cKm3ZPbXXHqSwPHn1iLMDuj1/BGUc5AMhBqKEvU3WlYrMuV2cp5NbNRK7yRcRXWKEvmZau4iyblc87xb+EaZW6KzfcnQBjVE0BI/jacNvVV+Uj7TjklT8uYopnn327iXwDz6M5HJK5/z4sKcTEH0p9x5ssbJqSfviDi/ea/l3ROL7Ch6TQv8P9GF1UbjwJPfP/Fk+/+gFT+msqz+kzdN/WCLMstUhilvYXK6kDxUz5OHMGs3tZyIx7Z3se30twzl5h28qskXFl7LeRvIiJTijkyAemAQx2QPAaPg7f9YIChRx1ikZnwDrME43Zp9LdClzF/YWNkzNja0mJks5pjk+hScDAN9KyxWhS7KZQnPsG4u23ijbunyNELeqpC2BP+Tu+IFFJjQvM+GQeIIjVQN4nKfFjKPVG7eDfNY1fI4lNt9d/dU+YYYn5sWD89xSX9GsHoOJnpYqEO/hF3dcFhOmMx36dqPuJUNafSy4Rn6qx6lRjUikppAO/va90GOE6qkEr28hTKLntAfL3sB+D3fiTDomxnHNeyOFcC5QgFcdBWB5AR79HOQFDJNVUlO5chOCwdA3T8BUhapJsEXFg6HuAl+dwcfTQdfrmtPpWgESU2mlj8uKr0un+tn9PEpOePVQlwdDJN8SRsui44peNTfoUsNAgMakFDJGemMXAwFLAuKXilBKNSAwzLfpZRhR41KUNX2bxKOIARftdbldyZly/XHlvAaeZ9Zx1EBOrCqXOB4eIb/L8hXkgLCh5nH80n+OJ9Vb9D3+THgHh1buMsA4tjD87kz7il9Qkx399Nit7tXd+zDTwof+nSndvhc+nDDywyXEQZoO3SqVoq9INvPs/C3JiOZUSQxFNyoYheuhturzOfOwy/EO1Rrd25MpJu7ACKnfuRkx597guOtRzOIaEo7uzSPe1ajR8nrsbVIK+pmCcjz3rmt3hy8hvLDXZkl2rZGU7uUw5HprR7GJpWlFylpEgfdwDgE+8ZWuVfx1e3xyiuWZnnoYebeAZP6fY++VdqesApz5vyQTofFNymLqiDzb61u3Fobmezy6u723vCacaysH7Qki4wPL/H6QnnOP97YPjmaRypXgloAN176JtTZN9lotDXlIo4K4LUnoeZ/l+T5KKNRGCgL89d/cBR6604gril7J110iPa0hwlmbymrf4KpH7cX1yA9IBg28O3A91JpcFKHxXHCsy7nvNU7PgZZHBcHqTiknsI0zeLRG/JWQRd8v2BkNjmWeC4OnXQzmQoy0cLy76yXeC3Gbl5y49Jb71Ct8L0zCzl/51X81h8VAKtIZTjLav5UgkzPmYVUCRHXfocGT+loNwbjdtwpCtC68BE8psSi4S1E9Z70wrMkgIbLy/t+WNWcwKZnvSVXinlzdEUvekIeqa3K5MzF2JcmLa/qLtIn7FCmrlfKP9IVFXPWqbaFpkRgngTQyT54SwPbgBdbCWOhte6R1n9eAIgN9iqmbX7ELhuCcDJRnQkbHSQTkPc2sNcPciKXDVFTOIHBkUJJhMZPi0na5ml0i0MOOqzYeqkiK5d1usKH7vN9aMOlPUP682EUvZ7WSvQ5HXhygPyalHTYmrQOjhiR17c122MWzuNxXT1Ecjg2CYQeozRebztm94d2tSgCXeHQrYs77lbdEnPjN7NiDe9RNV6ZRtgeOZ9PcTKuYlyY63q8l2DOu06IRDojFH0kGnV2TzjaYazJC1hUMa4RNqtUCfsq7RK9iiXO+oE7azwEhEpyXtXMZxpMLROFkPH+lw41M2V6R7ZJOtwnwWwLCDSgQdfbgdDRcaU8OQ2sLNzNtcRmyEOCidD8fOnACAnlsI9m/sxF5iz/XsuP4h3CfkkHSJ/3EfhxHTdbhrKWBBz/lb0g2KE6ZejmgPhBjpu5Hff28l6MIHwsFkjMPzx7Z1lCN9/fG1qdjBgSUZjYlQFBEpcrWKbA/7lbQeIEsq6dTg3zQDIPD4QxOLoXZjsnU4QdrzswW75jjpFzVYtXI2p8DDBItFDa9V4tvQbHg90qGZwPlGiBq/8ShVOfitVNRrka3PRB2nU+X11Do/QDtooj1oprJJfGVK7MdSEIx31zvOoQaMhFcawjsi+VUGpECf684fPGleLwTzL1UpaG7wqaOrRQTrOr00DgMWtEF0tnws0BIdCo1oLRz5+4l88g9k+oDxSHAXP4QxIRPAmCaLQtS9UHqOHB57eYJL3gC5on2MZnxPGWEcEdfZnMIVzdRzw0fCxMRxgPXaJw2AlnGXxGrCi7y+fGdT1EzZrMR0HFfJhAngFCP6T8VMqCPfwG2fX9O8ksGqIj3nj3idscfivBbr0y/FsRtJh2ZzgaUqCFPJrZoplUuM4X1xPX6QDwAI/cvLpWvmr9fW4HgLdhqjUeqMsST0omeQDlJOIfOj+/+ZKyNv46+cJ/07sVBqV/qsSGCEnpkHVLdCgkAD95itMRslz6RQmYFdLwMF/denCCyzqp0XD35WR49yMHYSsVUO5IuIAvw0tbNSAT9ZzUmNVH10nmaDHW5B4q1e0e0Zm8yojKKCbHnI1o3rwQ/bLKKO7z1Gkong0AHdmahs/SuEjugbriW/p+6A3xDiOdd6S9IqVqRNOM2EsF1diF7UKLgHvvgld7T5QBPWKM2dGJh/SQ79mDsj+IsSGxOZP1JQ5BHQNPlOn+MZqGPom0AAiWGcOmCXjt8qQVXqeoFHv1SFEt1qzcwKoupZigPqpdcJ0R8TPPA0UJWuoYHSUDFtwaaMP5SvRnJBJlNf2uRay4I2zg2wKT7F4dSQ9wMVnA5KACcO7tFibeYJBql7pFTk2HlDkjkhz5WA+2U91VQNnoGgf9eeKc2Nh90h5DfL56s0J4Jlgeayv6z5R04OhxyqSBOd+FS0S+hpeVAQ0IlLhonztVQeVHn2G1+XPP47DkNtOMYA+OVP2QiHsK/N9V62X3QSFcdeyPt/5n3BBbK3OBODxqxyogsH7G+Bc5H0GGb1PaZn3F53Rm+E+EMmcYPyLbl0Hkph4Q8geTVxJq3/pbIfTajyQWkPKrQcDCkWPSPViJ25Ik3rEG1dAf00xFIQLGR71AiUcB8NKGuozpXShu1H8maDorFlLKS58F8hNUvxbe0pW9IRIR2ACAk+WYqIJpAU1X2aHZ+quhEbllokG0NwOlQPPBmxvDnPZ6btmFrNZ+3WaVjdLCKiJiNUThJJyWTKBXq179ujK0P/+EAv2IkpL7i+kmYOcm+jN7rxXKzKBWIRiS8lQag8ii5pWqwXqRMC+RXBNU+oQ7a9RCHFPMcaBIsCPWdr1hWGEkkEHaLFLmCapaUkyC/0cwLh1qyCqtwLlQE1waJmLFSyO/hxPY+XGQOb8POEENWj7ldwG/d2ppdD1uE5abrkf57o2p39Sd5/Wd9kLfvgfKeYz6gkHcxaFTi/EKQt43BNHaEF4oF3BE5sOrQPqTHEyMuaGs3v2FJIxtm0s7PVzllnPv/j2VzKIW0k+gGGipFkzCAcmjRfxd+DsnnoaWHGOjJpD3JEJZeIHZArN1hMd0eTgTkcPZArBoX/a85U2sAh+8pBZRuzDs1nS6zBFQ6vc6RuBSQBJOaAPQEY04S1AT8p+83gIOPYrjjDzAkZeBcMe43AdYsi9++8TFPHtTuk2OztKcaqLn2qtGHphuwA4msyWuVKCDDz8SQ5H8DNQIlIp2OIg/O79Jd3WAuGCXyLEIRKB7r9z3ktJRHkMLVG9Fe+OWrC7PnqBnNAKI1eSOfjrbiHN8Vg8jJF1knmgOHVSBdlKNEzuVUtSsrutYnO0ppuGxWgVBJnf3GbWnvOoQIz80k0FN/DX4o6XRIk12RXHQ6MYlwoVGWBFydkc1w6xs2V99y9qo/WmsL42CWdlTcM2q8c5VQ9JwW2xtGUakUZZ/h7354LLnV1I3ZuqZ2aHubNSkZCS888ccYBhhR/Gb8fLVPEt1f/5VdxUWuPLEn3gDfHWZGAJZMJcvp+rrArAVaF5p3pV0dH/MxmhFDZ7Q/bJQRwTkrxhAgo1DIoSvwqjfD6PzA2AYAJfM+pR1XFh+QUApV1VxRJNPvMw3pr5es3RwX+gXLeYn8vARsicYfoJDYRJifEZhXYgaq+xjcaIoZFwsGYRf0/axMjUq3NMRR+PaYsXvpjY8bRmuP+E+2taP+yuMmGRS6reFLcjiYs59GKlgKqZKhfNgON+ZfTipmi0IYAn2Lw8GLkeY6mlHIYggP2dmXvOLh7o6e7JQAOoa8AmSa0yS5RbP33tsBub5JX0dOvH0AMTkM0wKWkVRbX8NLo2R1SyK2+dqwzhCsfH0U5Mzfbep7vngPsyFBsIwc25Xejhi33OemCNZSz/fNqvEG9wPvLcQjJaaCLZ8oiDmI1x2TwdN9LmHd+Ym2rCdmN2qL5jaHLSEyVWuENlYxb8xtwb1CoDoNLNT17HUd0Wirrg4jrlrl18HCuOSmXUHnlDNtL0TI6GJqwobS0Iuo5OMVrSd7J6+W3kUFBtQjLTFJ6i7XA5dbdV6bBZ8cHaIdDxeZFHGUELy1n/yQqF2CsPXJ/sGkV+jnoQZm2A8IBfCWKiR2+tU8ihxlyvBBuRKKT6O3Rtm14gKK2f4FT7yx1eRjp9/MY7Ra/B4j9vF7zGZmxR08AJx8Vtl7OAQSLJdOFwV8Ro2qHaeWzDBCoiZmg/8UEoEn0qg8gAgW1sxCZlTUMTcdMzWUxdIlcWRO8pv1eP22w0pq6IPv2F4PdyEygAbw9Hu3+mlFzVzsetJuLTKx2WoC86R9bZN6C6Og20khOcPvYhMMjsKqu0UePXN49fnD+UkK9vWOZqoLtTwGapw1gMIVepeBZbZGjrl2tSh/sostULLgnR6bxdd1rNbaI+cSySMjhO/jBdmtBU0FBITYXae3vpL2wpx8wpOK6zr3errFGYlvORh7bX0X0Zs3/EItHKr3z+pYbYe8AMsQlFhamNXiuhPbl+C2sqJGBitfGY1GhBAH/sde5QmzkRsZLbjbASEaMgU8hkYUgJLIcc0KZGzmMNcZQKtwlLkO8tpK6JfcOOQsgYyarZtunYv7OLCcyBEwgWhisVa1yHYxytF7VtkSbflHM42SqVPDe+OlGkV3bgOWfQFZbinpI2HeQTo/gJFmmZVzdNhCKiDt/kFWRTzLAsnKFHzjEdP1XV1BDdliZvhQTu7Xv3DqeK0MrhD5Y5mlALQDTDFJN6t2fgbTQzFYlwXniGIJvsc9GJcV4ZahyLyUJMnfpn9PGhoC7Pqw7II6GnwdrA9+UGI8Ngsni+fFyswJ+oe18/Mz8gC0ADHoOsHGc2ZCOecRUTHb8+RBmmYOz8QO1SciRJ+DMWJ8IdmWHlUQDJBywRFAuamw/UqNq6hhobiFEIt/o0+vsDj7QF4BKDVfHOqPTpIMXMMzCQJKadHAndol3ZBSMHGsftiZEGTrl2b7CyEW1v5TphD8Ply3k2vsBhYdLbn29j6oxnJnKDfTPxqvl7rYGtlzVU26DXzg0zlxcwPEp6kD4A2hg5mxp4bxIWjTTAuRfHVjM5k0+inuD8zOciazzOYNWyx3ApKMXVbsqIDgLwrTDw5H6lWDdiooyDxjarrVw8gdDPFYRXdNY8B67lao+El2+Y/yJNi7Xw52ANyGuXyJUX99OhexOyksS9nnN0fbluBWV8oJ9XT4CrvrRP2RZqqlFIA+LSC6E5tRLUGExQNY3pRRHlYDgAhVROAloWJ8Pte6L5gIWNr7qAN4sP7X8k3sAtxlrfl7Ptk9NTr7Ss3ciDT2kkY3F2+P4AQFAxg+NHcpPDBcRYfqRMgWJ4b5epgJrwTRkjOK164151MVDgHWsL1zsxSYu09MQbZ9spoHnkypH8W6qG5ZAI7/v6qTEFJuDwGkXvc7dmu6C404dBwsIPIlA/YbfsNsz9Gl3rlzaNHRXCugNK1yPGnT1z2TmFXCAXK7tYICirzORFLXWmFBPZL+EDmPTXd73eOe50g5ZrFQapeuFJzpY4OYNFnU4E9X67SrxDCAGEma5sAmDVHDbiWaPavnpiBagK3G67oAa19I0trOm4w/N1cuQ38PbHavXCZo4PWF96+lBQAI2Z1MiSTmIGivsGM0KwaU5FfaQ+LQb9vrVoyetIMir1xGcATABjlmrHSnRcqak5frRvvMHweleaxpRiI1y52RBIJ3A1ft8y4Kr7YbI3NTBRcRSVa+PLd2eLS0ZngPtwMqaI9WCp+pudkIFsQcDT8jVoI69slOzWKIbOzQ+5Ox/RAXYmh6YqW6j+esRql882Ba3ukP29XsUuUnxFFpviIOR4Y7HLzEIsre4jg3MsI3JuVxZHH2CXdClbclzii9DSqkk/S/QonfeTHRrGFxTVpqi4vtYoXUT+SdwHc89ijZNWpVbcpM7ekdQSvpPhuXUpEQaiT9viQWsI4JYeY/VMa9Q8tbxrixvNOOJv9LKwDqFmwBX8QOlGuGGzbE3iRY7xjvdNxEkD2Hvlx/qgOrs/hO7j/EUy4pQVm7ntBf9mly9+EY+2r4r4xYlcQNnr+gkiYdBloPk2KcXOal4iZj6HRHGg7lkygtJgPiSgN2vf9FW/CodyQpGg0r+ylfmOXN3b6DvPGPxp3QyMyU8Fr6dEAOIbJTuClT+0s7EeCLIMPtxqLymmoWIlWuolfsBCYn5QvjGLBcjNtqHai3Lf0qQU2JEUf3kd6IvUpQOz04/ULwISZhwVNrYR6T52fLZt6YS7S0mY+A5zWXZJU9eCBliOYz9ePMeoOV1f0NfXsBgXcJiolI+sgUXhBnDcpLh0/NjddPMzNIKpPFU3G6B9II1R43YglpbqqC+7Mayq8kam+UkW9dKYi+peVVDex8cqFUNgHxZ6YNR8v9HH1aDmwzG7oAgU5ZayLXS0esUA/h0YngpiDlPuqbIPMqIgjPZYkCCzDmDWr2fbl9C9REFVIttZy9Q2WdkVxWngHaQYNUjHhLoTC/zD6D2lbO7xHDdEMWMLbGjjGiOPDoqVWtg7biwmu6h3k3UembQxNA6gNrHr5eOJn00BPlkVV484BFfmrOiFrsK1MLjzSOY9bRg4whlUkIRtMVIbzLaq1CCk/3GkyOd269vuoFJrWJen+HwZK1uHHuBw6lQgi0nRzcHUysQbhCFGYZPPgG1XT+aBYACoAkE8WU6u7953En6Z+oi+IcVkuRPp/oYZ8SStzp3NbpADvEJXVzzW6x765jhWXGBesfjeSM2ny1bcXGjTbwSF/XH9ew0KfcijrY7rdGyneWzhO/diY+BnwG/EMODQMHNNo0Owsv2cmh+Bctbmls1cfAn9N/9SvTIRw26LNf7cb9YKz6PQuCR9mXiTyRsqSOY6l8oYKMdUH1l5Kl7gd/huAzU7TWO8C132w3DUya4eyRUpforTOEtDuG1PF+RDK5aLuG6tnEqhFOhNDrJQfBWDHb9bEHfo+q8fdDpckfkuMBGsNprnfQPqlnUYLayaUbWbSBfOsk6icdWLygeDX8/YcivDL7h4xUosQkJYyGsBhCVJRMDjCpQ2MLaEyhjUH0ZTTQlcjhQeBStts/PVYiHBFk+iAfsqS7FLLIF4SPIO0Y72N5/zLAeOR82MnHq/48Cuq/qgcYYTl5t9ujk1Ln6gU7etHodddkra5qQZ/UXulJDeIgRC+aijC3ppGjSzb4rTbzPbRGHQRkBBklMPKehj8wZe7yO0CXRb9IzCmwHTZ46uvVAZ68Rk8iWfX2BpqgkQQjGJomMg94dFLpIGJOK7aPuUZm0lu1uYrF2AuMLK2tyPYy9szu18+AisOdE3HNE120PIkRZWygKunYBe/RRDUQ2HB/jJ8JM64dRIWVgx8Pvg8W6+vKso7DogrcfVplV4IbsoaPvqrZLWF+jdrPzte8HvuoO2V7jdQ9H0RZ2d370N5sk+3+5Bne815AuBO7zgeFszCu4lHep79L0JZTwf4QiM8v9088RxLK8+xtNXldywv0eqUG33PAwVZANQk6v3yAG7HN97tOsl8aM2Fb4rv/mrxlglhW32KkgpiJB4PcaTMLIcRHyjNMKx/iJ6hnksg3Vun6nJrJ9Zo9arB0secP9FIxyw0Sz1MJhW7rV6bnSvHWlG71gPOSGdeBrT2NAsf1e+a7RB8WC88mcJmt/a+pKrJBMB4AJmKKM2xqgq5DjOeeiyv3bGwsIiMUPisyKk0+AnvocjvoTVm4r/xV02fpd4jA7gq2OHO1cXrnInZrjXCeeEfHYH/wEKqPMDchxZ/Bvn8hneJOH2ydh9I/ZbBK/WiZ9vxLMO13dd9GzkI6Ti8U3kXuIXSHGeIWZVSB2M3c89I87Oq2BH5ooM+cTc9lOkleipx/gvZJyI/JdsVY07pxD1Wpz0qJhqF0cqHevCMmBHOTKeqQGAKt5hnXzKZW/5I6oPQ3y3QS58gwme+nZoUtilUyb7HlfjgPQGHWp+MW7k94e734Ja4mRQmiD9lyf9EbvcYvkok2g1nHbrx9fOQ/zfEJsBSOSUi2UPXltCb74BRtK9wo0Zlz0luEi8SIv5eN0vCYAHmdeolj6ofDOVWOUdXPC2W8xkKaQTqYI1833jf9SytSMHjGzAeOENz5n4B8zcJ+WCONV/gAKISFEilgiZDyy9lAoHY4w+DAwsVQNxhEOdT6JP6DRkh4VTn7siPPRZFLt8ulmxHYHWlr49V13zu41LuKQlaVjbNvlGYBY/XVWYvEDaAaH8czcRprXEfVlsYpfJwnRHyIXRXASudl3wMu1d8FegVi38I96nQQEF0I76CrYUvRic1/4LzALAnfNN9AJ81UTkT3fbmRLKGBaO1RDDpsu3Ca4WUoFnznLNz/6t1A8iBo1mJ5FZ3MovMjST/U0DW4/kbSZuA/fX21MOQHG2IATELAwZ/23/PP5a2aKHMSiI8xe7oCOUZTYiTVk+nFIMig88jB/ECVACItaUCobwkSEjZLgTwvB7pxFmEFRj+Ta+XoD4+2vBL3ucN/2TA48RMa7wC0zc4SUlmfpJbGG6oG1M5NJgYvoqS4j5QWXP7XF+G6oaBoolEL9tXJef53RaQY7qaiJ2kkMMx5TycsYQXwFGOVYvF9Xcs6uonMojQJnccGatLvB742oVCsOjlYkkCu6kDT4SmgDrVZHxn71jkTc1ACZeP2ZLtO/fy1ecKDdXwwCLn3BcASceiaBPFMuVz8VAO6G/tc8AeOyhcwzY6EeDI+xAvB/taDtWqRqO1ZqU46f6DSuuftHI/t+hdPqb/m7jARDg8FVBeSVEyWsJKy+CzMtv+dDZ0wruDPlDd6YDGMcAaGoSZaGkfy7HtWRBrmnT3ihN+T8X33C23m5yrSgmjdZSFO/AfU5A1gSZh49/yqXL8TqmVSWTboYlgUQUJunJ+5mUWmKnDNGP4UN3X6JDGL4eFgAjEZZQl9oOsbC1h1Qr+5aOd4vw6B+/tv3bqN0Z+TW1pHl8MbR3SvUjI79uRIAuBhDhOp12wKF5BaFEJT9obC+Q6EUW76RwP6j/41mwq9iXcdfe6hk8QHqxvHCJnIBn//EWkQ3WFMstTZ3zUXfABPu1q6WyrDSe3UFTjf7FqjAWYdulkOONpq5XisCJj0P/pNpfdSoJAFBzpcujgEAdQ5y5yXqCOxSvXX0G3Tvd6se3mtbWcRJqBhyQQR85kw0sJjhAp7GoJ7OOq/Tk16yv/WSNe9NJys7gZmYOvYZRAg1RLR7WLseFpIgxWdWFcv6JJwohGFWPr/Wj+3umPH9RwX0yQtFDDSNnkmEWpkd0dcTO6ozQNxBNYnGBeHjzcbXxxRBYnbDQs+gnrOOKhcycS1KksYpFr2E3d0R5JhhAru06kOKYOXx9HtMT2IvAfsr33ej+FfoCEh2h+z4jRI6DzF3Vxwl447ox6qt05wK0MR482kaEhE2l9uf417wljP86dFTzL6+LPnNrvH06ArIuLYj+XnzWw5PKJCSQ9FvB2eQxFYleG0fDjUVvnuElpbh79PC0I67nLlmkcKL5/cQg+qPl7emlYHcJK5MQu+6bQVdnvxHh28LLpqjq9969ERIG4V0fXtSxEUHATewjgKgnb5vQNavxT0fk7thE5XP2xnHMJ8Z65FQu6yTFpzwDMA3xb8cWWzN8ll9KTBCzydpOhr6Qmp7G7eDh5lF7dinKx61BqozSFUOBPTX8K6qQwK92Qo+uN5sZoO2ZLzw4U4xkvLu7s0YcTAFCEkq5sZEcn54KicFAzEsCm+hyBE+ED9l0nufeHiE5p2Sws5M7mLl1AQGlzwRKe0VEO09qKJ+WnuFjVItRWlKGJxHa67Ul3M0+rVIeVRzLqiSXSUMZmFP1jOWUs97RCpL5/vzL9zlDuE77J/UY9OYdZ+O1PvHDPWA+XmcXRZVncTVDdhoiBCDQ7annr6/yYURv/j4gliQGFodLnW4mgHzxcrY8zWhgbTV1BZDNqpKDtr1SnvTUCz4efUNwI3XalkL/Y0BtxIE0qjN+RMTKUsQdniQYhTiGQlskHuzHEyTlaRwuknQKKT+U45m5c+gamC9e5Rh+pmzQ7xR8bZct0m2liKTIhiAOO0uD1pKtCmdpPn29CblwabxZL81cgpD2Rqd97PYpyqywD6R/HAlWAFB/J13T+3XA8Mvid2/MNoAuBUlHGHt4I/0xrvRIHL2X/49NyrRb0sixtDKfUTQ2jj374GeEN19X1Y5EDGp7qOqg7aItz7F4IzLiBdQBs870uTSNdSdXZfz75Rb9y0hbIZqO4g+o9foiXdWuL5HzrqV6nNNwwZaXSo9nwbfzj9FHJ6CKJKxUyRGVMNSHY+ELx/5l6SrjhdHdjjiLksSMY875g++Q4Jn/GjmLV7aHfOI9hQBnGaqczJYChazIixDpXEkoJU/7B71WFI+HdlYoSWmNf3hMfPZ2tUfphPwshn8rsTRc36ckFwTvRwb0KNX/2NyLHr+N8u1NAOLbo9O7IJW3v3jdan3dIvqQ5I7Lr8KXmoQZKSPOl+UrJL2TfN/VXOWtr9nvZFm1KR+QR/kJ0fmIp9cBKLw8VJ3yCnp+dvepKk7uVbvazgyZyNXz8/dx1xFix5BOCUF/P/ZEwiAqdS3KD8LAlUYISRGCQBkCQtci2+dwk/ljc9ppFor4SrSsogcD8oJ7zrNXESaE5I1U5YDZEohbbwUjBahUN9YEYZrCJbX1O1vAWlEf9A8vHivAewQ1MR9jA/9hZ0peoB/zHvh7wXOVdYozlBDV9py3t30PDy02VNEDsby1XV6dWXs0FVisM6vXsk/szC2wK9gwYy8UOmfrrf/Lw7It46q++FEckltOwtg1adolQs3BWTobLK54J063LBW3JEDIemFfdDU+ZHKKMasVTGW5U6/rA+djqr40+YUGDTcC8V4uMWa7Nqa2U6m17g6zA9aNpeX88K5lOyrWCreyad58yw7mCP67BEsdV9r69muCAq9FHEE10j86YOhSHJgOFURIzwaxGtgZmKCd3iMduj62XSCBaneIOiAB/cfMTi++3imXhiP7D+E03A4s36UtYbSqAhnoeOiOh465KfJW0QuRNKMWal19LoOXREPC38MXrwtTbQpfPCSn8mlXXglEf9U9OpVK9JCpqoliAPPrvSXO+UZgyjZkDwujKgBDrUGfyAOGSZrHIdgABNRA5XfufUNgtWf+EYZtHrjseSCsTWMH5k9F3NrUu86otafoL9uA08qHIMXNwF+NskkKJk3WhFfj8MTWWQ+mHAY7qNHIAuQqDjZ46ofWf56JEirBIgtBVle5aOcqd+xzysRTd4y4QroELEiB1btQvLg2VsUvl9gK8mkI5CjUEEjHpd4+RF+cc2dICLlvyTBhBpJfIe8WmtWDGHaxn/RicbYQhcLe7NsE2wUj6L+53edmSzQMBLhUqAXEMDmmXhGL8rSKfn0PF7jRTanlRSfLcSo4k7OVEbjFBvs2RRvRpf5wssM8DcDWDE4ih77PsfKDeJpH2iVVYncZ+qg/yy5RUo2fgIuU51mk/6UFemXecpKCitvEUrf+F4ksIr0o8TgScb/tCkXHYv4E0lNG1E00EwTsER3SIA/Lq0AqS8aYD/H9cEpLNq+gdm+dCbhMiLF6NwnI8Yz3Jg1HYI/MA5/e7zNws6Eugu8MasitfPsL9wX32TICeBUJfFHPTCNy49aYjHa7TtkC7QvWQ9VRHliUSgqDyjij0A4gPKJNlV3NNV6MDugYnFZmEUEzrL8OXyHaytwyLXYM3uQg/7N4Xw+bpoPuPGLCpclP0/wkcp5Fb+OovNRNSHjfZTRJxGN5difOOtVVamAUI1j42ohuzVM1GNXdDlYITCMXVCSsf4so4xy30nuS91nx9qroCeIuHIHtiEMKpI8oTTNNjZ1qn4Cq7U9Ih7ejcajbsnQbrQf0jluicZ077RDGvNsm4pou78brDohUBUs5pKiEO0WnXMjtz+5nNwIa/v0I5QB1oCWF1condTGUZze/b3lXj9KwkHITLFpfllg1DZW1DbU8jAxTVnFqzayn62hDTM8zC/z5fwYBfr6VSA18YVQBFUL1O1gSocARk31prUKvhp5eXAEMx5s5VCFQWb2VWlCHNkIdDpXVUY+2XjdZFmiahAI9oirDQZ0EQ+uqqeh2mnglI2e8BhwxiD/9r+g1A39NTkkE51kJw+Z0yUjAEzVGe/eIzkaefdnxDaKlGgQOy7MNvYNYNIgGg+l5HRqVx93V+xkTA71rlHI+N27ZsApxqpx/vm2k1v0tEyXPrThth2/JtgyvRVCyn0i50NDwbZ+Cyd8jhlKLyzx52sRb4BLN5jBhRf9FbV0sfDoFKM/UAd+pj6E+1+zfGIP58EetICd0EBnu+Iv9/3SBd6fJeTjyyQYOVDg3Ub+grccEmHYsAGDKO9DEdQVNknxXgqvEyFpl7iMY0N+mEM/NRTrcrk3pVnJg+r6cxAR2o5TPH4/s0W/GKNipu3/vJZZRj6uRJCyfD4f5oc3EsCoMjodqucj6j6KRhynZw3TfJL5FaDyO0PD2G1FZekG39NCODXy4ZSITy0fW7tk4+6c+2BzPxtkyxFAkKIsicDVeXuR/AoQZmcwyeHZAae7+tXn3Qa3scOmuKmVt0floD10yBAWtQP5lD0kqfk5l51SRgPADM/ltCcG2ihV2OmbXo7mxtyaNVwNYXvx5id3EV9XmPtlbXGzr02gVdW9Kp2K6qxS8nH0Gw3uykpjf71w2LxJrNJ60Iw31oHMsPt+biol2iN800Ka10K4V6Fj3VwCE+dzK56pDJWV37fBvq1z+UndbyDlIH1jYJeQIlqiu+k25en9nCbKwS0KP2Gc3D92ndRYD0d6nnkRTrdv6xkbBb2D+0bGxeFCLK2bAlp9LTu5CzhS/3iSyBrl/Xf59BjTSmdmlvPFQyb9r/asyMQVm0Yl/YZT7fGg2TvTFHH3t27ZSEzxI0Sev5xe86DV5soUHduy38S90O1R4IuKKV2cFjsEWMVzQlqHBpYY966dG1Aj3Rdag2DFQ43imZZe2Li9aFpxv0+Ee2zBIYcc0UAfLdAsJKcTxGCbAXUHQuCvxJi56LuHD9d11alKf7z76NSBpdT1YamuypgLsvQxJWyfH/YdFrCpwzhextTg8HjrDbYAPzvGLjWfzIV5Iq8ZsDKT0q4KiNfVoYW51ocy2ZsJUS3poFYT+2Z+lZ6ilZsomaqRDIAY1J6vpbVG3gGH/Uk2Zq3MEzzmcfKrGQmMZvl6mw4Pb6Fcfdm9Z/8mBTD64lri62oR2jBAaUPUUpGh+8X54MAjxdeW8K/D9r8SiTV1NzlhNl3wJqd0t9DC+/uuNnd+wrL2YDfR61gNUm+Vfrg8cyIMAxf/VJW+2TAYHCWETBKl6qNx+Kpp5tLZENlXmG3X3TFv+nRm2A7BF+fIi1wgCAFTRxLGXgCEfvZ50zH/K0v6TCkiGEde113kD6PTSUQyFvZOq77sU/ZGv//IuSKKyCu8iHDeDdgk6b+W2HS3sMWc/zdEKgqHDYC7Ciyw3n00xeOXHxojXSoKFdHjLgNdTKr+zINwtj0CrrDmSS/AgrhmJql9uZEaBTTCfb9voxD1oMteGueiWdKR8UtlfuxO82VtGCm2BlBEmPNSK1J76NAWOidb++4kJeHdmc1vblQpdobcyDx3JnWKGciFixAUMTr5W005YdAjwkJQEQPST95LQpGNcUAgApHon4ZGRO7XPySFAEyWavLprYyLWIoEmD1oE8bp1ljw2JpmsNt96+1NO6R0wLCymywRkfNr5ol0k9v+lly4q5Pj9+YRtFaLpd2z6ZiMRcmf5Z2n0jjUhCrXO39zNJBR/uQOkOs7kC+xOH8fs3GbiIWxiNXsXAh8Gh0+k83RTpX+92YrRyUIwWDzwIlscLXo7RkTfhDcU+EpQ6l22lWyp90w6kBvztDe3CPimP/uwjZK/Kq6hLxBy/DPak5nwxy3xIRk4Lae3/lsAdWVclVxPg4z5wGoOFQ1TJ2HnRO+jv+L05CTqlCTV9ZfQ+hhjGuR+tQ8aYUsZroPvdagw00q/KB20LUVnrySMbKu6f1CViCJN4NpMjnqLACOXEt1k92Ey0DhpfzpfrIDFdjEbOALpIJmobajduUmtASCNpKglRboRtL6G5uqAqDoOvwNX4ztwTTALAU1GmcGMWJo/6YXDb59aPNOp0BXxGS3L6BzDtJpiZVvPB4lIffID7mnh0PomTPVDhZA1Mysl0R1B/po9EwVWj2D2uY/NKgxjaKpRCSXQt0NDBfPFklh0Sm1iaAL6WZJwMyBlK4NwPlOsx/i6zopH60+XP8dsPp8noV9Mmq6eLkHttEV2GD0GQm8sJikTUcM4eCRJxnsJ8BVpmOIQ6Urr/JL9515nTHZxkox1rhIA8ZbtZLzsittyXz1HT19DNSwbzaCdGjBFu44wDFW5UfUc6A4+OuMFKXRRRdLglx8F1KhIBBPmREXPfVOPGZ8wgc20YuFVCy9WU3otq0cJQM218DJmPmV/QlZClLPKWcpoO4ylxsScqqqhkxABXOm3U892ynuKsHssYbzMpaIOLwFY6/pkeo0qGs2SHNNIx+pBWIrBRfDOl9xfMBAedvwhWV2W6+GwVwZmha5tqy4p2CNUnUDMkUTVvyXmN1gEb2q/CDKq30zxR+LDedsWYa0yWcFdo0k6u12m0/g+n2FDZ2bwxx7UWQ75qLqOKYrcCGRGUd+VZHZb+OG0gdycOI68UtIqrFHwlrRUJXXt3lpadIIgXyyVUlM0dRfRzshHr5gK9XOqOVeOoS0nrGdMvVS4f6Qp3Gd4XEmQUz8uUuSIz+8gb7Wa9FBf6Nk9D3qYh84pk9DcOlv0IyZGKMWFT4n9VsQvMUnFVfPAcJoVfQvk/DsEMGmbbwfTwoipn0YzW623EbmRX9DsWT/3MtSW1Okyi9/+5ECyCgaG9p397sKt7tIxA3qPB5x3gCOHjfSiDXIURMfz0E5P5wRIG+65GZaMttTj71CXiGF325xEgBfCdjBZ/QKZ4MQw0zftXabz2uLNYnKJbJl0sILhdgR4P3/OczKGnWQStuMJ5fuSnur//MmFTCbh3Xx8KWbNQHJhL+jC/uVf8KM9IWsgcysRiPxXLuwVk5kAcfnKoGrS3ZSEFstUUJfpdBJi6NkqM8fVPjbqgE31yYPjT/NUK8w5AePA6FYDaqzHQAE48JemPcnaz5BEIUUl8s5kZ0ehPnZT3gFZLB65j8BNjv2vklho3xgyx1jsRdrmJBqwzlKbHL70PSuR6jInLW80y2pIYO0psIByMVIvsT+25RN524vTOpkPFMEqrQTipQB2AVAxFknzs9vT9kRDtykeRcm5sk0O1CADPk6DRsX/ls2V9gasq649OR8UFXU6I4c1WNFph4MBrK5cP/4im3KmyE1aF+y2C5WboiYt9HauvAJOGsvUbyoQrI+y37vCer5M6Vupt22QaOOvGSPpin+FRK3/2Jq929vp8sRilbbB/PCLgtlxJ3T+Y/RDhj0eF91GiDgyk3i/BhzJ1Z1XMEGckcVhkeljhLfn5Yl5YYRe0Hc3Gn0e0MmqcgsxpYvkNPbnecuTbPfJZNS1Rs4tzkGrPnMfrI2UNJIfGnPXGt/92TYTUOSpbn+GK1Nkd/0pQyfY4MgtSjBvpCeClOiIbcGoRAOsWsBpLxsjVmG2SjVv/sef7hhazMAuuukkYWZQdxrjeTSYJlrQn1L+D8oUuR+suPTcwVLcGNtwt5N+5tdCiXksXJu8ffQk0D3TpB7ep/xzeyobA3ATndhUzljoHURMhGUG08MBBu7wsPFWzwnmIWEkcaCX2TmtNYHNVl8z0T27xmTSduAAzfO02EmT5UyTb2UgSvwbqGjnOqcy931lEPTh1Jy3sc2mpbpg3xR9D1+YChRkQZcffnj3JsMtZ/tNMwxo29kGHJdP+Q86tWAtDyKCYl21SdGt3jNCro8br1FLCz1NbmTgyKZ6w83AwvOb4068q+XJBQ7IMS6WXaBGy95iUd9SMrBZhdn2/JuY4Azbm+DcLCcNt1Efy5tQhkoHGY6ZggOa/yhn2UgAm02WQftQP9NX0jmf/+dDkWIiYlM/L+ARHIJeujR+RSBvfJYMlqKpfYyyEDCYc/Cboy1lNHzFMtAWsSjYueXkdP6zawrYMmlpuSGWTcHsLFH+7v365rasJLnjVg++3CA1stLgxXdYb3gaOxEcmSOfb9k68rie7eJk86ac6PDx2xdhpfIvnCTd1PpMfy1AwpYjftk21EjnQaeF7igwXOunYR6JPsFnhYEZ9ocp/V8Jkh4thKW9UuZTddXUsEJlLLLhLi5umu0YE8hNJeLf93i22XHW60RuHlbDtSZfa8YdaT72FOSLBjxnTEYnjIIYFoj97itxmlSvlSN4neUSbyQ9ClVPZJqGwAUlU/0QWjnsGtB5/HcJQLR/iOgbsXI0gJB87fOyuXJeCjvxX00yKv+y3kEQbNkEu6gZfuBbYiu99aBGoYbjawX9ehms18sPf1D1Mh/l4AmsPm5RPGvPEukeqTS6w2dp+RLQfvBT7KT854tWIWxESlBJy9vhnjZnuWgXHg3Vc9DELIpC4mDsgpVKTrPfF9hOHpAax6bGNoPNHItNYRXWl8sbgALBK99cTCf2DXEBd0e+uLZPYLxwXim7mig5ITSPE9DxTvi3l/r3DYzgCWqPcax0/PFBOYqVWIePihwpf57pKkqUoMOdBhETDJVweka9ZFkGBIKgDAbGTk7rvQQ1TmNJ7TjSp6qVgb2QxDRorGfmV9TGJ7aY4N5HeX5sXBSodjVptewNfWHtT5dIasUDujUmc5wqCTGH1d8/W9nuVZvBLG7Uh/OwK5/yr3cOnlNdPSQ+H/IF3N0/RumZFC/oexGAGIuOPdTkyMtEK9SUokA2C+zhloVVgY7tNjTcPZoNSjVrXgXvfN/Nsq3TvJR9GGZ+VaTAnTQ8deYFH6P0BM0UraeCNeUCpb/H2BGsoVgnczOQky7qR8MXhhjn89Jy/Mj5rFwoLg5w77ZGTwzvJOu1eXa3Ke9BcPvVfS66eTwQFy6mS8W59RV6GKG30jocgxY54exiGFfPMFRCgjJ6/vU9zFYhHqZOKjUr2yRqJrTLPupTYe6O03vKgzRRfBqHiEtL4QeRG2v0ZGWhCAJVtOhYQfq5sZs4K0TNneCU+Z95erUugEnfWueFuMoICmlRMMbaKTTPjiaMkXfoPNVx7i5/c9iyLuiHAkzE++fjdfZySiKEr2aLZx3ubiLp/TzsXR0F2YoSmKMB1XzugUZenPEvkEQJxt2twveSuIhUzwcpbQqHI8Gz8pg8X34MdAVwuXx4p9LSNPzmmo7T33Eg8osrg4N187RUOCBVhQjGokX+JD9AAa8XMgB35FJVwMUDqVL71iyM0UzdjDdReOd/Vdow8kW+hA8/rO06noLsNf5oGdQlwBlrHmRwN8vY4ELuM1vnkaMMrwO0tvMDJDZ2jIx97P+aQmM9IC59i/bmtsRvCh/UGvuBi/rI+Bj2M891IAxoGbRa6umybkT21KHtbGQ5azToo9awxL/ZGlIKkHFHu7488PIQoyaoqj/nhXRWi3L8Hb1C3QK+ZJtFpZIBa4nIGG3zkmf6bG0E4kwtiqI5oMClK42wtnCAwjc2pcLiwe2tanuz9FPRsf/5ER7uaQpIiXx/fHzJ32tLZRpmNEmjsXHB+Z66Pp36NvEJFG9cML5dP5o+raHAi7yS6JnMqO+GUIORNJz/Mr6xm1uxOfTDIn7hBQ3x0tPcAFipYa/kfkEJYNa1WDA0SXLNNbexy4ukAwNEJguzz78unN/lPq/14N64S+s80GUCQRdXIKjY2XnIMuf+A/a8ejdFHRcTN6jwgY04+vDKY5M6bdcGo9JtMHeX2MoghS3kn4wAYoRiVZSKcyXreM/O+WAyNLgHnGwlUnRssidhacykyBV8pAtBDbaN0/AkWKOAVhNsPumNg/TKYPx7ltFiYxS6p5xXFq4Jw/yCU9kyoR6yFLvEWEYjtPCxoBJN077DfmnlDgbA87IMW0XfkI2wGcfJ6MhWApp3DuvTluRluRwkXlzLMpZrh9LyUxJHo6DOvfryyYfjEvad716wIDJ6eHiooK9Gr+vp1stCyoqZyynQNUxp6euT9BelPnjqitaJq26tTWGZVDaHSqNJoh14MFxnjmSiLflvpLETn/AON+gCaWsOy/r5FccpzO3VB81l8/RZSNV5sgjQqZ/xGnU22AQu919I+QGrbghHCpGZX+IPEY2lk7QRlfeCQ0YBkZrnhNjXd6lwhdANyrz1lgGhiR6J3PrtJHRq2e5JX6MmbC/vtI5Gz35IZkmazNYquNZFPbqrzUpfWYlpVRMQm/lZZFvZ5g47/17St6u3xZQWGTu+pEdm8Fnxfn248GZ/JOAd99GzZ2hFiqEAnTan2ke1xv3XYFUfEB6RPBW0Z/s6l0QgzJGvWrVqPmryQqP6p0tZzb/GtynhSWUG2SMswkNVyTeiNFjilr5Q3zPrtNsqZIv4/rdbuD/SmzNOEY5g/sgvNw/mQvvxdWTTA0W22nKu42eyGwATU+HldJevNnW1pd+AYn1orRdMXeThs2+32uREWXvYaZ5U2huriOIcxsWtYsTufwSsspZLH+bQMkgAl9RNAodEAiM9neC7eSB8i2Ej3t9b/seOuLp8JD/WTqVEcRK1HvoejlJiy4ugzy7oJhz33PP0OiqLVmC4mj7tNCEMZ8cpMYInfjRrA3JPyeHa0TlfPr2NBdSQpBB2vd8XEFRsP1sZkd5XaUz3ljZYVzPUgiLC9Z/L3Ww2OxeY+kvRRCcVtwovXpTnzEog5bY4Z5P1Bo/WNN0ONXgZY9WKrMwYGM8QewUP6ekEdRNLFs1j8Thq6sbbiXJUcwubGkxrHtjaaw73J/TyUBWdT02kVx+0WMuke6ZTQ/04kIwHE497ldBlGPYqfIVI02oRbc0SSvDbZ1d/kxQ/OT+Zj0X90qhxLIm4A1Bqdr+wtQhSAonbeUkwx039CSHt6QO+TsCXnwtBVsnyZLrKtQJ3OWmgqYydJIhHDOJUIGT7HVWPrhTCGUtNRcUgc7hm4daKx4aTQzsUENSDKkCyX04ERfxXSPuwkqm+hFUOir6Sh7nClWztqy7Ww3S/0h7thhdTYg+M0JqCjbkUw5U4W1GC4aiVe8Le4J1DfgHhAJoudG9GauxX0dTAp/Dy4eRSjW3E78YP11oAH9zkoaptZC6405iKGYMWefT0OWXn6wyHrbY24DJYCXCEgxtUqHNxiWWDH8JoMKsXe3ssSbk7Rr4bifhiwo0ENFwt0od4CrB/liOOjwTpDBCh2fm+R0pXpMcPK9oBQYaxUInFYzMZDmo9x/D3/mu13XVxgeKwlBna7xGSdh2a+A9kyPCAuUbFnAhZmHEmTEtXHxWOFjw8I1nAXWZUXrwZZ+K23XULfy1+ARQJX5XxAnyvc1P7hwZsP6addjvlTJXJDdIUJ03QsBadfB2ZEZx6I9E6WgMqAfzbC1VTTx/D1NerpAUBu1e5RVOKjkw3yeLYW1yYU7D3KilTwqeDLTfVff1T6NV8GzSl8FMxxCnCm/t71I+m0uUZ/IzOCC2k+shLMLLTw3qRYoVd5ity5ryU4MUg8S20wYLZqEoAmeNiNXGRSnhFOiw9XYSPJMo+/lPnoYuziHSZg7dDEcmsmKilg1echpRXk2fikP8ILcQkyj9HH+gwtXnXkTFr59smSJHHNd6Z5Sob8YOyHcakuekdHvgve/Qp22ii/04b+Fp+OymDvpxx+diQSdcjPOkgOOmKSBmCk5GQ/eSSsdNUfimEoqVHGuVnppJWpdxGZ3n61pzTbRfisipMTVVuo7f6axZqUpvfxiuUAZESCa+aU9D8FXIbnptQ50UvGp+q1WSXG60l9pRSaO/x/kgvP9vMlYPhrKhag6UVhQFtQ8lIvaD+sQ/EEZoR5QpvvdSOMUU9Z3VYM/kYVmUHvyDB9kaixDLEvtGS2RY4sEbM3xFrH/4I3uQDNprjHlezI7AftOqkPFlriZtfpBUw0zSTsv3DYpZOW6FekXmvzn+QmZ0tuze+OeYcrYR338Da1BWq0MQDix5iuWWG7iQxK9j5siv6dd/cVOqbfcimxxird1GU0v7VbPFQIVSZwsubapSBq8/SZu4rq+1yvXWnc851VW0bG7PMjbfQnHJ6qJGYnnFxbPJ1TVyWiIFGZSIdh7hklfJQPAeZt0rDCPDmqDOAb07vlZT7XO38roFx4M8JF2ZIvWETMCEM92vvl1Oqi9jOGBQjKWKbjLZF2LAAwlEB+7Ld3c+bLdZB9y0ata2h3q2ZfSNIqdjDmgvlso/JJzNAFyMP5ZczYh/pgIH67puL/3Gp66GDs/Ul0StWjxDxNW5uZ8myPxCUh5cN5UT5pfj2+qlGTnTPyE5nCDRXHZmS8Emdi5GELLvQH5kZJyLCPWcEO4oWq3vqaW9IYE7T0zEreUAIvo8cPx1hlV5HKmbN4nAJrgdzinyRfNV+DX8jmHwJiQMmZHvHpX4VqgdGJyLzkurmJjsM7gPNR3ZkyYaqj96UiKZnGeLrQ+q/x9edvtIs/kiMx+t6FAzGORyGFKVJc0PeY0S+5KabJIzJkVtRgBmnqA6cUJzNJwpIvsSeIQ2Jizwoxg0hxDYM3iQ1lMt3KhACUPjZ7Q1530FqN9og1aH65MbqwetDwZ1hSyhW7QsUpueFcd6UsgY6aibjyIkEKUYBNMAP69HedMmy3sI80ImJbRxUurfk51SqA/RQX+BF3pAD5E3NqdcGEUGIawcSFXz70uNPF6PSI4SHuW/HrD2vwRn9qJvN+aub+BjsLFckMNnQggTNO3qeb2TOiOiMpkf5MRABJc/zH96kG8X+yNKzvA+Gl+/oUbCbqChDoHCs6qMvIOHnK5tkKg8XvgpyUlGhaR69liBeNjVTJWz3h3N72irNSh0WflmXgzPO6EuvekT6+VNYHxFCG1Q99qMZYL9Wl47WOeI76niGTeoxGPLtJId1D6WUhq3h35qnX/KLHceRSRSYPkz1v9kQvvX3oOsGk3QqvX67KujDXoFKk/0clkI2DYcBe1XravVJvfmnsoUuv7naYY2BXLs8DmbxBY6YYhWq8JiwwK8Tq6mz97mP26sZNJaRPQa/hkOnMciQME0nFTq/8gvKZwdG79cHCmvzPK306AP10gWBjTvPzcg3FGbtCjcwgNT1CVkfM8BDnh1IngF/yncMnIh9aN4CBNwY0akF3BXxR4c9hBbo2GamKYS5kyOZcowH3nLfAdDKOJXkugbAm5yGvvqk2PbFEn04kaS2ZVwe5BeqmdeCc7UvqezFUoVIqdB+Q/M7caoivBYsBnCu+aR1tsg9u4E1Ps2U1P2fjiu7D4HBk9AbYv9KwZsiDpPFHRfJt4QsQHp3vp3R/APdxqVduidzaww6C9fP/MfDnWv/M+Hkg+SuFTRRYn5GKTwT19AZmQUK9edDJx0GEP4u4N0qAaDGT8cE6gAVsIVU5fTyKodKzy/qrSqSMOiMRz7njdhxHJ95Rj+sPwF3v424c3NatmLkDrcojV3fNguheYUIGML1/mIa3qjnQ/oVDKKDuSf8WrLuzP2fPhle3FHWnadmfL7U/e2QdovHAFK8eLE3KjQitgkD/I1y02IN0Yv4aLkNugCJn+8vr9pIa/nAp4/WSW7Q/bERMSqe3Zorw8b1I6PMvsmFrRY/SpGF1CVCZvylVdy1YIUCVzYidbtFxsZYJlAJ0fb8VXSDIb4RJSX+9jTU30MI+uMUUJQ6he/Tp2PNm2gY94loSsjBfd9I+Rvt4uwwRjxKZbFX8JbQL1ZDQHbVV6nyxJDOuK+8IFS45tU22pNx4gjHSKiDzC3WvAnuZ/pgzxMgng8vz4j8Z7GaWqaZlr3uLIXVJz2YtGEauFxDMU/iYxXcB7ZZro/gbiIN0cJO9NPzzFFGPPeUcy8e/LKzXStJosT8y3ucVMkVIUO6QrAERf4mDjav361WaZORqakahqmEscDF1oFZu9vBsvDNcxpTXBE2+E2+GpiWej8wpyMpMfIfdK+8GlpGgQ+u+v+jwkHUinbQISmjmzdURSU938Fa5x+lW6x6FnMn5o4HlzbBqe8ypoovQBrV8/Mj33XrIeRT7UunTZSnLwZnHMvrvo6TUtKpMsFaa2yJRdz4xKKkGFDZqQ8oTjUP7R0xKi+zAjNv7OdmZ7PAOHPXyWMT4UGo/1zXkrW651LwqfkN9tdKzTQn92ykMODwo5usvdhNADGssmrHM5ywtIuBHjVJGZhWg29KGb06LPLrT1byIMutUHytYPmjGufE7g9jeCAVjfF2z3XLguDp+bQZenZC4Vgz7Yu4HXlXMg/CsvouOAz9GEGzYL14OIID/SxQ5nUyjPuL4S4/YSowz3LOiDKQXgD/1u250WSbr31QfcI358Xr1Q+Sj6FpS47qqEqhfnXTYZICkX1pGheD5Cv5sdfjX175lm3X8078hpe05YddFBjIWf5bfFtepwO0NigbAOC0E9DgtErp936CwW5QWwQC5FsPC4kdtGtd1+N1HbWa3ux4BhR/ghZBEbBN1THmcopjlYpR9baxwO7M2qJx6YhYPhYy3WUyZtM7wNpbm3mj5dChPI9wcB967a9i7tlYsZFWE9tbbvKOP/DC3lTBRiA4kfBp2wv4retAsVTm4zfH5HIb4kDeNEOHemjBlSTdwtIlLVOh3fJxBflX7mi4j7VLgllohab2gpHZ7ANVLGvtM+Clt6czeyyW6N9OtQqn0ifVNBQ8MaL4Gy+xHjUh7E+pOBjHwSHvtTr9KBTm4YbTOPjQIScm5tH/Ff11ojzxY19dKphB8/voAOQdxYYhQ4CoPTcIGf8t8Qy6MWWXgNPdsF7ww3lz33jHQ3iNz7C5xnC0XKiXEwgXc44xApGxlI5g+anjrHx6VsxJpDPsEq3GF3qkC2+dFymmzZBNdzfg+0jP78lvzb7Qkc6EbHpfCKwhWQ4UM7/yb8e6xKhLiapVaKi03y9twi8LICjAbNJ9VaAgMPkgaBF9VqBQ0RUz6VndjFyZlRSkHLPXu9rj+J6oCa5L0f3pG87OcigqiKFkrORYPo2xovH+sITBGW1zPq0bpuvE2UzLiXQtP0HUBbAxYMX0ocrKHcZHdB4fJfLSLWcI5y4Rm59B6aIYsvDYmoBCHVBAwaT6H4tQJ6mIoiED2hkIsLPvz0VpGOlacq5EF9mnOm4HXtKTxIpAyBQDfqpew0hsUtYMXynu/VUxz3jxuu2NIKxopMAZ76VbLOqK2aiipgMJSmbJYYWX2/Ca+bz7h4+XvoSY4E7pJ+Q5NvH+6lrfx4hMUi88djk6uk/R3TtreEK342ggr6wGISAkwCkE6dK8GzfJXIW/WNPyLDcIoM8Y8w7r7MYfFOvyBDKCd4bdDAaMdSBGmS+AjIQPOFb6qR5fJkxb/sLvMelZaV+i9op3oaOH/5/U3QPEoxod1yLHWUsXdTpSOQ+7XWsQ4Wo1RV8vCdixOhVI7Skt3G7oqqq5QXIi5923m7MmEwLJCd7VKqQIS/1HFpj21yN6YmdHLAXmM/st5Gs85oPWUYGUM/3xag24ALNtOPcsVplrupIrQBZpJd5bt0vlETirrFz6IKfCoQlfLzBJE6SfBZQQOzz30m/KPNBC5VNWRdBC2hj5l8RZJ+XfmRGIwW35vXmkKFaJQ83y435RUL8uIb4fqtnOYzvL0E71aG82q735jTFSIWrxpIv1Ylh2Fbx1Ei4xNDYKZbszLIUPLiTzhESd5NdnM7/1CgJ0YxczRKh1eNaDmvHKR/yhOLLEtq8IIcq1ItPq2XoMla3S2UmzXgOuXHJMdj3nU9g2nOGwlJV/o6mMlEtSQvxaRE2pPZj/LoZifg4lllZ/pt9mzWSNlUrZ737qY7d2qWNcDGT/CvvVXMz+DJ9j3bIjn65Fa4fTAFusnaQQ+Ar1sU+3mZnF2CPh1hY0H7hhYokjAy358IIFktsuxi36Ei0z60H6fLVohKZ5ZgqTwDQXYEAPTwJKm1s848XC2uVngL4g9RyzU82sk4q2Sjo60uNFeHgBYe16aYWle9riGXUpDeDuOPzSFiG5Owm8hqwvuFxkQoyTR/VPQNv2XhoU6n9mk6LgUsGKP60dPnqc+UDCjS4mFsrA5KQZOoEbKaITHWnswyDqgZW+FkylXFBN8Fg6MAcXZgDmfznoOJZhkG4OeakKkgRv+BhysvFvvzOxxDLptJfW4aC0d2I2MX0iqjoAXW4V+AHYvBjLwGNnmWB9aUqfs0XdqcM5MTLutzUYvpd/x/Zz0N7VX8a8nIIbUK9PwWeV07OFxiZusXzkSS8gSpuazyaPAPlobNQKigL4eQuXrFQZOy34Mrq0KynbcPo+khucZ/8GYkNQ9u6gfFZ22WgvRMOgI2Uhoh5UuVVGmPHkZGKEZKhM7I9jHAkAOY2tFfQqQLqLIxR4uIZTdNhaXWU7LMFncFJsUoxDgiya87zKr1r/KqfelaM2mlJyx0tljcEw1kjTIdkATg1u9DkAG2R7z8WNrpO2zQ4VjI7/Wz7eA+PAu8xBG8xy22cfTaHIJQEYATBWdx7UNcIWPbG9TpxXENzmBkqHJbZh72WNECBDrffqHErQCVMRHq1zPpSqJ5NLV+BtaSByVaQtB15ZIb9QbNK/ZVypHUUHj4Si/WvBaiDrEkDGxeo2Q6/1yh1uZPucOEQNEBvb5Ruhw0YzJAMt0XHETMUPxxzOav0nDtFr+FqptFMlm/cppXFqvS250zSO3Aq2dTvTAGy9iceWJVtrH7tKDNxRRy5lYbM7lKtvvcNFk3rxWXJpQ47KKv8D2vlbBFzuYTVIpTgYxc4D4ZoNH6yyd08s0r4kP0uhRqGOBAm49oIjKAzQhDLSLz76itEYufdEp1CMAHBc9r8NT2Osy1cKo5hzqaKQ5D6LXUhAY23oECEMSsKg2i5kIVdKMhcVjmCfArf6eJYOK0HsH6Zlgvj5pTCq4ihrlB77MRw7+DodV+CuIhNIkz8pFNXKB9U6hIRxY30Lq1718FGpXEHzLK+fkMja18HR8SZR+rrVs2TXiymZiApn1StYR+IxzZvcg4yx+BZa22VYDMxQTt3S6HibxgVWfK1SEoe+0tUK3KdrKrcKXO7pKmUgHgey7L0aYwk7aJ5KkjPj1tl8gKX5BFhUm2W1OParrEJA+kV4+F0m8r7JztuRt7mDLV5BPnD6mGe3koeLHTWmb+4/Gf3XQ0BFDC2WZ6gLnWWV3JYamug2SfEYf90eDX90bRvaobFRFfxwDDBNZj1O0pnXLCvmJEdKx6eNDmZ4tWfz6reQOiFrywuer2QHrhtHXeO0ciKIeV+GciOubyXYLLOTu450uXprTMU+Np+ZyTZ1KNbdtn75s8N8ucIxcm4eEuHKSY5gslA+SzH881hvc9bzcKaOcJR+KHKqzPP8o3l7cfEHyWU9BENNUzymTaW3zZOKf7Nc4+nwflmoj9XLuOa7IbveRaXyrw4tHgqsEqwClT2+zX161nXt72idWnt5aUU6zYfwMTRl0wr8sLx56J3zxLcwjxtVc7VrvF58raG9eiwzUZuUatA6TsGgPBmD7OrRsKRxQBSuW87ct+Y0d88tRY4Y6AB2KNAUln+NpHvY3MeqK+UG1oad77W/M2/2CYlnap3ny7JAMKBM7ytTuJrIYa+mrT3vbG5X6NaWYI+Uiv3GYrn7/v2GPhs3gohyBa4zgwfWkAZIaBAYN8w7GlRyg6Uzepu+mXeTcbp5cFGV5NmrXlphm0mLmkMAwHukY6WfezRV9Wqm7a09iigQSucPhufRKH3Ylzfi/dy9X7pIHXDNX0IKpKBfQf4TW6g5FvmRQfeNkCtEFEGTxovkkhlfvpcxhMquh0Wf4FmXfwxy19VVD+tkHDxjuR4FVcUILoiU0k4fqWUAGRFrhA5vGi1w5tBq++5JbqDMascl4X3SOemO2WG7lctsDCA+NMPVkiQZAq1nnkMTx7BQchaCyLF/6ywMGV0W4h48cGrmWva50EEU5bztKsXt9ui/GDFO7oh1jlPAuluwXG6fSxdOLNutHfcw697U2Vv1xQSagFFwF1kHmyzrSUWz0CG3MMIgxngzkz+WY43tcImFPpWG6QUZXGhDZKtdyueLdNLWUS6GUuGkE1VHHMVlYZzHdh+deQvEKjake/pObW43TdX89bjQxaTXeCliD1I9pTDIce/nI7TF7qyMCsWCx2WnvQ/DKRtk3eq5k8qbmWjkZDHOz5rnnpFm3sUm5zgSjr3N5YpG58q84iTCQU12MIOUskCzoZ1CtjlGuZEvOruAmJmNNregPe2zbwRh4erorLMggLLVru3RoGdppaIS1I1czygkNATy+Uz9HGbNytdBiCqIa0J3Zm2nuHz5yEj9HvZe5jKZxnefzts/HkCdMb6NvU99bTXG+0FYh0HMuKPOh0m6jjPRJ/i7YI/AGvSCEB/L1kpggKcqVlpMszI6kzSYYfdSQfael/eGUJLRREs9GhzJE7qOsyFkYyU5Y64EEtnZjblJNsXy5ZF4qMdS6lPVdflEpsc+hZ3S70D/NLmMqcsh5e92fhpIi4vZ5xCGkYZhyyw3+6k9DpkB2cAZuveCU2BTYZWvA5kzexJjs70tytBbcNGKWf1gGku4UeXiDdIEx1BCregzS2gQcaR6Q0lD6ay0nWXrrLtdd8x8tDC2qLuorWasABVeZXY1JBogIA8amlNfITFGNLw3VjEYVXQtQcpvBIq7sVBjsNc/C1RgFjVpC3G0Qn1oqF9zep24dUWO8aNnrZR1ICNcPshg7ni5202KBm3NpW1bdEw42kzQWygDVCTr5zaaUP7ttlw2IQ3h19gm2S3mhztqqFWysNVeBTHnmgQdQXl4oWYsxF8vNj4/zu9QHuNanlJBwoiUqFS9rdjjL85q/zmzNJcFu/zw6bnkzDEO6LwIqRPW6OcXufOFRXA2OQhFKZ4C3J9/aLDTsKfYKYremU8AWEqoTkxIIZEal74bSjWt3ZsiLC0/D3eQzXeVD9DRc8MhuU2mV7YZbg8Xb61WlxFz9q7AqNy3d8zGE80KpiIhZuOB/foeji+DQ32bnUrlooEfpGpipeRO1ZJ7QJD/0QU4NnKhoR1XY99FsJVvMxHSMiVz+oIIEUvISAu6LHq334r7J2ZAXl/cZKJLC9q0y2LDXnrbTf7ITajw6nC/by4FIgqWAkUlhZJVnKHgejYbVu0aNxQF6YrXZgtP9Gq0c0xklp4QeGILHL3MrV52XMo6TQbPlo/AorPs0cc+15C+pjMiCBNlQvHXumnN1eY0jlbTjJweVgzNCyQACyTAErDe0dMKwbhvTIEpHX6cGblHQBPqAMvhT7v7IiAOQdhRYbA9ThmF8N2PtYK30KJJ7nHxYB/BdgpMx+wufZIreXsqFLlqhYmON492xybfYiXtecR5P57GXiCPCSK6oVRtTGyzGhps5WaR/AKrrodAB6UlS1YqcTZjtvcwNWCMs22SXxCW5sDQi1DbGoUlFdqkhepdWj+KbXaQajNgY+k2gS8oPw2Y/pkDIzNwiVfA/1b7rEZzHwjBt9ALm58LLp1QMJaxOVRw4EOCpeUph0sQKdgo/dkfZ9QzQ0JhRzA/bdye7Kj9jUpxER2gHWAOmfmmqgV1zcY2o0UeKWZAUQ7UjK94inJavp6mYf5y8SZNQb56n6C3kUPkFPHdS0ufdXdBjLP39KTjcVyzbIaGDPAg5Wmp3FJzshxdd0gXuVuhYmBSzOQTAcwkdTXS9/F8YhKG0dT0wh+loSIxG2YldKjQhtnzh+dXCCun5KxxvXPzB3IoPnnKDphDgOjfHxaGRRC4x2sAgquz56DfVxjC/hku1OeW5Xh+xyrmyAZl24RLPBUrSlPUKN+PPw5BQDiJuVg4+4oXo5oCqLZbru1QgwSbfYyiFcwjR+tPFOBxRf9cORbeXO8Ya43WC9U1eJUZbhwOcePBrBGvB2cju8u3sK2Ta44M6IcevIo56esI3PtI8Ea44aCnmYVC5Ovp8kpB7TWCCUeA3CosCJhGBIqiyg2bMWhoyc+lkIMOqr3rQrInYUrw2GMxsq4eFkdGf6itImDdYXLTrseFMWNT8mVri2PZoqFhnLy6gwQTjkT7HN807T+SS2piAbnKX4RKdYc7M5M7aqmFV0/Ubd53wuSGvSZCQct0OwHWhi4oFMBE3gmuVkNNZsrJ7fj407F8grO4CnRDAsLomd6aZPweGP7aDnxnMLJEHWS7jSh7wLucrALFmt8kjhFx1uxIm3iBk/5G2fHO0SPiAt6icJ33cnTp6usJGYDvxT094iFqYrZa5amtauouPzqN+cSpiuDMLumBKrNyBXF+zxc1OlZXpmImxcoShNMN5Nu0HofHx2L43AZBMSoOYVECqunROZhgGhI9z2K6OjpE7oD3wS0PW3DE2TLS6q1QP5UgZ0r77plCycINqAuqaklWR5lRaFTgQGZSiNqnodZurCGX0x1aUpge9IjGQRNO5+k+6eH7uiOT9ws9c4XU/KVAfdwcoudOnO2G/NxdxHfmeTB4vWa6QrAPfs7yWPx1Cive4iu6fx92p4ju7pZ7ff2Inx+6xwHFCBy1LGtMhYTQhlH/t1UGF5rSat0mwkD0amLPq1C6nrY6Csvjgb1rqeThkFbjQSesRkctWZzUZQMW2kxR+sdWZELc7bHvvmrNrFrJF1dvf2+kqgPxglQb2d6t27e9iJjTHJm40T0+jho9J2J+Gnlq8XRqgv+/sQK0VVi2vDJL2liddDopvY425VNMZeD5OjgiG4gjg9wj/pnXBGL1lTJS6CvS0vXu0Sb64J8zGr0uahNczERX5sv8Q3HA/llHpNOtmNgniSPB24admqpCMFkRgNgaY0gpZpHz/4LuxypGOnWDXEjmAO8qqJEnE9HPBs3R3kPyGSrYNZxwO6J/Xg88M2A3KpsuaCpLbCwjgt50782I4erNSdWi0V+xTyGhPwQofcFeXpo1ytcraMrKbufzZQFZaygmRvb/9XUAQ79ASJ9kwR27US+WdQPkyPxgepqY1uMvEv2gZRULZrRtvIg8EjQiu0Q9veUY8F2bmpaUQFhDZ6FEyy6vD2FvRE8YE6lGcqvGRS9j+/g7NVON5CA7XkoG0n2l5gOlROt9p0efk8ZAeajPyH/MDU7PI8iPXyZoJ98MiisyYkpBaFDSr+LexGEQ8F6Ot6UAVDf3V659Or0tkNXv+kUdKwYuypqiLDJLaXGX9Ix+D7kA/FAu1Q24K59S/Q5uU4LiLmZqyw9J+wLoK3jpK5uL1oOi9w14CnIV9McX3PJdR268OQxxaLhSfdYaq56KZeiKzodHrtdw4RKquqEkPWJgD8Gysnq3X0EMFbcW+7YLjO1YhKFm3EUTA/bTkPstyJwv1OytgzvQBo3owoZVaL6zCR1mVJl5yfq5eR5BX1qTRv/lqO6sgNV+/4Eaw2KflrFKoO1+HwXWajzCoNMgMSWwn+LNWulCq2aCgVcin1oOnfUNwBFOyym4skfqDwWU6taMej6rXs2SQNV5XHMZivD27nX0TOCOJRDPh6lAb40ZhLRJ9KhIKfnJwm2kz3AUe9XUU7skWMclxnINSSpQULtjBQDNnZN+ntwnsq4J5Y9OiGyew/qk/+NpGs+9uHFbFN5jWEOaLi1F9RMzf5rtIJOPWzVOixEX08T/s+eLbpryMFr0MlFr643XQXqZK/ieJ5s1pO7EKKgO60arcexoicm8hiPg/nOyaD7DWKlYA+KY0pVK0xgqIgLUo6SL7Y6xD0GE+QaJv+9rCWqPpqughjLgxA8KGRdZwPPjfz1EDaHjd85aCgkyUG/+8EY1Pq3yzKZwtEafQNeoPZTbA8x0GdCAiBU0aNjliYOqbrpuVYQ7AA4Qtr2HT7xG9kvKYrDAX5PHZnAOyTNO2IjNEJYaTiT3qadxXQAgdnbuDxJVNuFn4escTFQszz7BsIFcPkwqu6LjwQsbjA8SKRAtBj5A1xOz4Z8Ji9wY3u0r8PzuIyFrfXruRMZu4xRksJ+HT7Ec3+g6inuRtJfWBocjacVVZBFPDk1NYK8C9jvfVZKSMTdvrzpYQfgtz5a4wR3k3pd407rJwHQK2u/4ZOkZewmVeyFbUulIMAbtVsaAk2wZD8ln9z7HCzHzMRMAIfSmB+7YVcjaS09IhqUWhgaEXrPhNxGEcPuAxbmI2mOCcgZdV9X+QEwfQL3srgZJ/ZvepTQbtIBTBdqC7Xkk9/a2Bg9w/KVcQUzw999uOdtXqyBLtzGLs9ygvAY0UE7cyGzKMexFgOVDlJpL4ogMIpPr7w9XDO6CqVGII1uLa/diIVOsXyqpG2+cxi7YhR4BB1KC8Nsgs6AFBcDYhbeyBJ9MQWUdKMeGJOLua8aleRlrPVr+g68m403LAvCyo44Hu3b/FfIfNr/Cb8BmLSO9QKnjgSe54DvZWC5OLdBTy3DLt/3YYg3jHYetkE34EQktqale0jk9P3Qf5lE2dNjIXNRX0Bhn/mpZPaapZ9+klElxSfVOyHjqku9/p5qU/rJyKJnmZISfVLfZRBeHm1vvWFac9vGHw0zVfRy/F6bVEnKlOcJGC0KTZe3wfAfGww6MwziWQ1LDAd+ydPoK8q6ppxC1TgkU8qtaWrZceImLQZjIMO7t17/9YfXxD39c2F4NR200VKxoIqNst6L63Hzq1vzqtAg37WrXRS63ndVE39y5d1NFOZA6CGUqm5aTLbOut35ob43zMTMtgBGSbvKy0s/zevn3qQcEAhUrBrOZJOIUCX07QGRhDkufco+G39m8tDek5V713XkMfjvRtLfZTU6Z9XwVd3NWuQokoYHEZMywLiDeQr2nO2LByFrm0zy7ZBvIYPuwnMbCuddsHD/b90hDNDmBAyl7XGyuYBaUYoIlrQ5+VRINT0X/N6aX9yM0MBlm1GGvV7iLm6zkzVXVuV4u2PSUmjQB4g/RMax8n+QOG8bcrKEWlnerMaii74CJXwD99qj2ZqjR/dJ2+92nXPKJv8Pj4VxtmXLNT796b5BNo+n3oGcSqTgnokcFzSH1vdRKz2F1Fn1qoUHmQTQYXDtUjYNYIIJO7hTOiXPltU84kQ94Acz2G7ZHPSP2yzKmA/9wH70O0xFEiWlVtXUcO9z/whoz+CNxEW3B3OO6PpWltszrN2Pz1Md8DCpfIulHHIIfcXYwr7h8TnZ3RItMLU7PfBpLnnDgQoklHuzU969JpXrDAepsSfDwvfqaz24aQjVFFvQrcgaGDcEAXlDtjYDy5VuOAYRTsYmRk57+LdEhvyHHz9ig7/0k6AmV3fzhRqcCISzJCJFqB0O1wPoKQY0uTWpdOzOcNk/o1VW8YI6WIdPwity4hTr6iQkYESAhqhG29VeJboeksM0n2jV+WnfHXFVdru3gouAlJquMOKJDkl9pmskQmFGrVGua019qMXnCqxukoAuaLM4GwemR9kaR094d1sQAG6IA45o4vS9YYjPaDbzFPBFW8NA8P9EzyKqjfN/oEEjw9kKLk/73XOesVFtUu+Ocn5x27pXCO8xEP7s1QlGhDnJsXaQZvKJkytg1/A/59wIHuwDZbSrvEeUHeq4ae2iHTft4EU7asykIy9TwcIQ+/I8xnTT2B6yIVgwKA57F+pOYewr8okQKqqgjoKjjOIkv8Fj6RN0uEG58TVYbLOXnW6aiswAK+aFlKqUSLC8vzBJkpsvH37tVU8paaap4P5BeTkLC8TgdMgsRYeI1crqBVFOIyCZE63lqH10vECOULjVczo1mpT3FeONZM2pW5JVZfUVwPJwZJ6wb43XIljqJz/Vjrlj10+pPhM8M8utDw5zpKyzbvYBlzgrE5HTss4GorBaLPS8e238843vu2U8pOEpj8aRAAnVzLr19BWIfdtK7cK90jgg8gt3QGR/0kXwnrjK5yMXnNTg36DdKpHsMVEYvDgOXffQrV65WKcXj+u6PUpW/2NnKJ2a9cN8uNLwx5BS2mMjSCBlp1Gl94ixI2Heo/b942ROmytOlR902x6GHSle6duUUkBWRXbpiTy8tLYm0txiZyn1axJrhUOiOEgm9n21HcoIj/puDXJgmfd9gMTT+YAO5bi/9tqVXMmrlW5iGwxB68zzl+E3r+KfSX/TJhcQHnG/XXEYD2UrJd2M9aeosyDVZni+monLYCDb1RNa5Dxszvn5PD7kLt0dXm53Kd2gK1oF21mp1lI5SaqTfYahiGcMm93bmXa2rf4fG0/+LiFEEYW6EwMS1wzb7IBX1Q/kq5zdEBVRtOfDUoJ4e/Vp+u4c9wJHZbQ83TUY/ZkyMO6jTGVERo78K05IKRq9geTBHKUdtwkmVqKYEd0zq645FUlEXiKDig90WdJc1Ki2kwskXq2m0uWxtQnBkuK6ESPchLE63GSWPm63G7v6aphlzqpwRN6/I4cQkd7EE+9To7TFHTOx5ElE2RFu137rBCQC0zuOgUxFgKsx+klRYYMDCmcFdDr4/aSWF5mzLsqNi9lSzQPeXS9eGhoaEzXxn4pCHrLKg6bGzvFCDGDq5oYaHmCyR/ADkzBrw1GKKIlZZwzXoANGSRVrDr7vxW46AMy8Ze6AgNlddUlSr0dCOjAt2F457JR4ktFw0QjlvH+xCVEqdhGgTkYcdTC6j04ysxnenLlOCm6tILalPfNASYU/7udr4nF/ZTWxk/TjFVFZnW8DrdpBnyeR6VFiWgT1/JxVpDiPV+xluhMTgMEObKNp48aVlc4LiJ6h/vORwUy0aPI02sqDpVaU0fdJ4Z+ch/EiB/kpmwWwZEwZqKOCYjSal+8HX/AaVNjRZ6DOuwdFN5cHTxFsG9Caht+PY7x75ukVxIqgCo7yLVqtchi5xpmTRvz2uPP4MQHUM5w6h30AzfNUEX9rF536pgWY8ipkC9+1OzT0wuhHdxtwBj5ha+SBj3vjIf3/dlreONZpjtZ76TNnzOqJ8DqFH+qv48P29log0JXGQqPspdb21XiGxtQcyofXN/7sXRSOv3KOYFSXD+ArGhS06h8snvGHBlKaKvKig4PWCLvybL8rdUtxDr/fCWhtOhhyzqUeKHMRBNBTD7UCMzQiShGF77P/y7dWiVKmwlQyytjEkptwrkPovXsr+AF75tZQnwy8cBOD7dpLfuvJ2iKFMWqDE8i2e8SGaZHesC8ynxadhYe/Itee77OfKw9EiptcIPzE5cmuMG11s3Phi44eVfMTX9/vJp5qPTPX0TPMIXLCiHKeGmp/7GiKb2oVikSOuubyrc9JLMfHCGZwZuEfBN7yX3LKFAixi9NqK8H5mwl0ApmvekhSi6U5Uh4vRPnNo9QdRAO4CV5traUZ5JrQ0D2TKwRKXKex4ishzND28+zt+9rEdv1fbJynqEKgqGOAF92YvRnuKuHZlprVGvdHT8ToImMmCuxxew26aI978iqQNPRf+gcs9xwsBNz6Mfn6qgjehstuDofEwxq8k/5pAGcVGm05aLO89MTjVOyUoUP2mVHL6ETFg+LYr3bcRcSHraK/5zcULf3bdDQehczqbE/+v+0YOui0l1Yks09hSuCRBz55y49BFUf26HrQvqb1EPi6MVM6HvIxwMEIYiMOSXh27olOadIXNgKoq+PZu7aDLbEFYH6jKyXUhAVbQJbysuEVpg60/6iKRe6NvZb+jiie2wDTM11iaaFijFDd/8OBrpCFYGW136qkCfi98hVG6fe3RwE2c1RszN/e1wE9lcRVMFou88QuEJX0Eay1jTkUPIb7sQ610peqQ/an/Y4jEqGJcUs/q7eOVDsubGxLLGilz6WVRMu2bdG07GI5bVfyyv954WsKNpScu7UN4tL+6VeBzoKGnaFJigqM/8W3czkjR5esNgXZ9aKsQIkKQHSxkqgwT0Wlem8Bs+16Du1HtDHLZy3Hf31do0gepHlrSjGZnsMN6nDYyOU+YLipga0jtmSWQftiAbLLkCaDXFFaRwGvkxPFk4oxSofan9odHSQ3sH85U8R3aDweTE/v4TLJGoFkVgmCBhPgAuvrFn3R0rAUFkUtAiGz9FgIFfZl9J5mALhD7AVMrVZX/LaE5Jq7bEt8WA6+/WcIPAJyl1WeMAHGnQx7Qiw8JKRIpLh4ouHTrjXgjwQLIZVQdg+izt1HC0eMp3CD7lFOayp72w3LBRIRI+PMVZIMI8EW9TKWbaKafQDFnmVgBchB7sZnzP3sxIgBmOB62ka3qEV3sXP5MLwhFxAVFkXHS0ZWcki4caRD7mftUOuR526eJ4ap4+EJ5/SR87QwCfTMRsRogcGViNb0LQPd1K96PLlamGO87QJIU5eCL3etO/tnSY7nUpYjxU2UASJMQBWYKKiYljlV86w1w0N9LkrttEviX04M7QpirJX+Gdt7T2+QAcDmT4HlYLnwtdQikqp1YPGeAcKw+nVKoACNRJSJsmzWOlLr+Auf0p3ZPeYs2Yxqwwp1DGQ7IIm6zKYTMuwV39BxaqOfqVEeHN13kUFamRowRfj8XRUaYyZMzZqXxgDf5xoMINmFH6BAulAHVu3kw8AHlZZR4glg1igqLHIXVQaEnx15e6e3BcX+/DilU9XvEa7aAsAFAis6Z+RK+gx88hP3xSrgLxt7Eyj84BDl4yF7SdEiuNIgbtR/lim2FwIoy1bB7lf7JQc/fhFIJQJMNi39M7eAyo/thizHJQU62AMTR8m192ErPi5zY3ihI86G+l3wdWGNWWVNIqF8+4Upp9UB7qqmN2N1DbHlWQ6Bts4/kmV6Jk/fzyI9MpT/r+2u2EqB88TWedPGczIipNbWqwFu7hgHWNKGvmh1HkCk7NAKj5XtXwlhV3+ffzpqBZRyq554+0T5le6Ktm7iEat9a0BEbJC8mpvGRTPAFAfbt4D7KXDRctzYUOr9XoGkXNJi00P1FvUdLdhJnzwr29O/xseoU6D3zCy2/0rar86xKFYC3M8vk0rRD5dfwXOnvlIVQxY6uGHzEonfS5HJ/u7945RVjhncKegj4K5tKYAIWcI/aA/lUOiCvSRUo3CaX6ncCPZagaWTvcyqkPbbNrL5VEHRBLdcRgiR5u2fI8/W2zUZIj4T79MW2UM4v3dKNChgFsnqoM4sZcAs6lTI6sZOax+udR3OFNQAkTeYCJVWCbkvp1qhX77iEej1nWXboq8BwXs9PzC/lorOO2kyCW5brlBb1VvnBKqXsmdEzvQmIYqvRpQWp5Dv9xmEcHRH4hT8DBdgJcQ8/VXnm4F/Db9wlP18SZ1bIJ394P/4+AJCvsWO+Od26PJ7uLFGt/5LCrEytp9bUvz5juv0JdS2vcIZuVU7NoJfU9yGiDqWxBg762glA1+hvFxKD7o1Wt+reSVfjDLDbtqGr+22Qlp+Km49z+M9Yyv3VjGZXwrU7dt9sm/ygzsY4MO7j8tl58uwenrHlRCRNj3kavwPcV2o/mRTtae6umoWhi6JDD6EI1CEh5pyyiG+3/CE6qoJpSvDSkpSJziNqp3HirYScF2JkzHxGHknkQnlSpP2eTVCqLxr8fZOBLv6lt9JHXAVw8990xU+T3esZZbDhcCR1ksgSLdp88YuUshTtecA+k7ItPenMxOsLvQN72xgdjItrUFyNB+YJGxJIc2bp007t9sBmhI1nn+1q79bOwYWi4Mw8pAn0aNPoIqMl74D6jK19E3ZH3d7Ifno9R8OVGQPwrC79es+StwL9lVRFJEwlLiQ726IAKg+x2S74Y4rhNcUp73AxEk7+rZ3M6msxq47ZxJ0oDSgjX5DJJZokuYKmudLe8y5IZpvG+Pw42h+oMDSqr9QToVQCeQb4v/Ne89wJQ928Soxi8K+s+CUzsMDbZpNFJN/YfnOtF/Kgyu/O4Bd85A/3qFpP2v7k3y16e/xKMvZp54Tqs1WYwix8GpYSsQHsGhA5jeyDitC142eybVD9WA9EjFXKkvGCS6k3bGw7UoDLRT+w2eEp0BnSc2asPhQgvyVIT9Sjj8jiojT1NtK9xpH1oL13lne7ATCcHohX3Q43c9qFIhNdeB5+fYOFVcEx68AqNl4Mrt+YlaOqpqZyZ4cDouq2fhXnPp/4FgaFdx2Jpwgb3XeIeBJVUMGgWJKZApyoYmgt2q1zSvB7U8FPAprVUsW6gO/eioLuDTa91AD1C/Ar8D5LEXByLthC3G5oCQL6O6HeMdCldiSaJa01XXDkyoR9+jvVTd5mCYq1v9snmfqjL6aidf3Y7nDokrBWBIqgoRyBBb6xK19iIc8aDmXahS7KlAqpA3zZoD1ianPp8Ljr+BR15t8xXdncDNdkDHGJdiwhNPZwL9SXFovYVFhyAT6S6lmOnARN5BRF9EwFH2BqhiWBCBF7qjRoCSjSvJXmdOOm2y1m9HiHWvEMMFMt1UKuMxkMOT7uwr0fB671rJoa3juY7Pa9RA4WkILMCG6Z/FShv9DcQ3SHlU9EPLbENai46NoBRaf/T8KMs8xTu9DLc/Yt1sBzxpmxMCPA1uNgrrp0+6WA+L9PI2jT0ZUs0aeAUmFycIlPGKOVhs3tKmK0hVMjRcNwsu/BLkIDkAR47hzkW44XPNJHTxA+C0rTOqT1CPqbqNrD4ihHdfnCvU18IEdQONQdMNNGyZ4s+dwnVKvX0AsnqYKQTCQgd2AZnOt38ErX0l0QSTWkL1axLumTJqGbdLPHtDFaoJiVj/FUMUxBndoRwajs3v3z9Rfd63sagSbRhFpVJfPOUAnw5Bk869/1UNi9m35esS43K48tkwGG/uAl968uf0Uk3xONTRc6VHU/+a+CAVDi5QPReP3bN3wwF9aH+Yy3gW9R/pdHjmkF5G+cmNclqeqCC/egU3oFUsn1f4g7yN7sdJnujq42WA0w9yr9+BZ08gsyWEFYpqguqagX/LEsoYlHbgIEjNyoHjIL+6DPFViPeytwDxlPKVlhARQRDmvVz5Yh5W5weByVJnItUUhuH5PYjQiuiY4Pyr8XAfDXDeACkOQXgG9jOp6iWvEN4dgRX32pMeaqw0XcEFPf1ONcyI0PEzQ12MWXJzsKIaqRKJyZ4trB/jRusbzFnBkD2nDLCLYM6VZ3bLJbigSwWoV5hHodkIzJnnxJTikYrYw47SK3Jy4JOg0hwvE5B3N+TFtVi6UG0SAwpWPVldYdEVXg4QFX+4k89w2+uhufaF7Zfi/ZMK7PhHt+4yXE/15xZogr3+N3pDpLBTyIP+OyDmUwU5KHr1msySsxQ+WiM/t0zXKx6WNDr3LPiD+xSJQ9Onfs2GaqxE2YBFw9hC2YuoGGOvFEUIrJA56ZwJ1P0pBpiR/gX412sJ64haUZVPk2Ckz8QlMwNBWZjw0IP9JyexLv7SeECwMVLCVN9KI43oQ5IvR+0bR/oajonh3c5I+beYCtfLzhZ5ArWEByT+VQnJiWGEnyK/eGFQIOrOW2doSRXd1yhKyzTWPjWQqsVMqkmxHuclxAC3Fq8af3M/Sx52I/Ld5X1W+3j/tNj/Go1dnmvqALr2Pbu+bUHoE7U7HYdc4fmSsPCBShs7hpmAY1WEqVr2LbFgWOjWhBZiUNySJkBU1Hjc9sgYLYb+y5MsqOBmwL1nwXnPz4drwYdIH2vjKD1BqsjlakPg6GHb4KzM4zBefzvbw8sQ4tk9RV9h/aiQNJhD5AaFVZhH9WyFnEAgYh7NdiM33IOx+WzzHltsFPmp00xSPFVXbYkgh9V8rUAd50Ry+WJduhihKj2ALueSJI+cIa4nK4whMzgMjwQ9PgW/4rO4312ilKW8GE+pb5cgpO5IaMuqZcSGO8BRu31VFpXD1SZpCeCMYawwxZXzr9T8KQR3lFo125WNx9eeVnOA+54FSv9WAC5fvaLrCY7Vg1vtusjEF3w3xYyv4c1X4MO/yefD52XPrMGzLjuE+X5Hc9iHQ+aIGZxh2HMYwchmOUDImUGN+2FDmHjK7nlw7CBanEqVBOCYb/y9M1tggJuWx/DiQnz4JGmU1ooA6UNh4w731vsu+aoXI7gqLadcrnSTSpEoHw7GRPooeYca5qApqqsR+IvzRXu9WJc4426j8BItn9m4v5LgbXnsbRCtNme/0sNmnpLzFpcGugXdeD3PrMykJuOBZM28xSw+3jakvVwl83ItG3br4xy49qXAb65kU98gOd3oTld1JU7ulYQcmxW0uHK8ZlLk7cCMjfZza9c8SYq3WvWsPkRIEgMDM0dsz3bDfSayhlWYWt1IESJQAJ5/S+9f1VeqeEkZhRFNfIHu+7tE7RdsFbEeFMKRthGaI1oIemv55nbKSLYueqAofbh0D+5V5F9tIt+R/9e0C7csCydK5PvH/8A4N7OD/OtGkSTQmx4Nn/HTuBwo/+J7EJLIJRjwHdoGQxOZMOPAuEEr6UbVR50wimx8b2OFZpGwhnLGPkP3FO37ghqgOdV/KsQbEwYQi2YKnq6bnHG8uQZLzZINaQ795ddkQsedXjpmKLVTgfGFPARiDycXNoHO7UfhhD0qXKPKnjyXyxC4moxlZvIwsYCXYH2XTpSDRHvcgSLNUAoieC40Pfq2F65XY94urH3UIFiingWrmHGVnvO1LPPKGudiLVe1LtujKlFr54xpMel9XKKHw4fktwJnFBlqOmJWhE9R4JwuKDv54gISs9SL5Z1EOK7buQjd/g3iygKcbX0iI9zkiwdQs0mKPSSjg5XqysXpbHAOva/wXSzsCsIOSBncJHIwGdzSWR3bIs5rVyqWs0yKMof9PP7Ogimd8XJEeWRaUZw2XFgEkiCK1mSCEmh4TcJu9um/zjhtYeaM8wOz1kx6vkXKB6Ayz4MMCxioCf2WyTr5gLzjUqlgCCBB7xtxpjY1sTwZnT5VjPThkDHbhKgPxSWVNi3uZNrD2R8ILKsloaUen40khIvzh6X9uNc0DWCw1f12nc7pDRpX+04YunIEveU+w4hn04UXe4trppzGmlqV3BL7vFy02GaGiRnn3EBGAvXyKk49oszNgy9/PRvXT0+6ZL6GCM1EYYI7UikslXVB7O0VBSMbR5Be0dXQYnBSQvbXX8bvLhGojDN+gt2uNzoBRZnQawkm4pyrk3ezdh2edFWvYFNwYJWrQW5jg2oZYOgBqOhMrFFOPj9uGNLmp73bCG2N1fA27DeSzDwp4cp2jXPvzJOg/2Gq3Sdc8C3EpmHWhy1o+liEKP9pfzc1JdQc0j7gP+bdfOHcurjirdbVaIVrWQk9SDIWTvGExz+nSq4p2XvNPjHuPk7UT8zEdUEQwPyEcT1qi57taUOQJGZt/btVYHP7pHduQQkZovFEVtCI4096UMetEUQHyhR5tLctH+Xecyq1O1iyrUw3yTDRnuGRvaWNXseMvnqp1NoIRva/O6MC51JZP3loBVdGSDnw6ALGHwXLFGME2PsXLjfHRqjedCbVWi4DUtWgU2LLF41UhuZFmKkaWXnpv+tVG+Ge3n3/O4aKD7fuFVTTi/PAd7TqVoUQbe63efreUJ1AgU//GYbm7KS1Nshuxo3odr7uwJS8bxaPRe3bNs145w5JWJdHb1XFpvihZv4neXF1KY4YrremdBHxFrJSYA2e354YWW2M2pYCI6erQUeaqE8yTmwQZW81LjKZyRSdoS4vrpNs/VCOmABj1BVyKl9XsrUSj/q8JTov7wYPLMoXHlmJYkpwVir6R0jaQ4wiU8lLGfffDazMHuQqsmWS9qXLDd16TNEfwJAkm8G4ZQeEV+2H/cA8Ya/feW57ivn7eENU3p2CSABWCPGULzg6w5JeevLQ505l1/hJcHYRfzpLaHAUXEOeljzjTEomp90UXJxO8vkRIOWdXoNG4IrB3q2cDfq1enjS4PgYmOtCOuNia2ae9b9+u2StLsvQoH0X71dfvCVmYeba9cWFTg3eD8VjzJq4HHavyjZ813I//e2vjpdlEFIZNuzEke33spnfMf5GWGay6CHtWYyToxSAsEi9VMiBl+agKlwybn3rqcnUnK2E22HSLX2xBPGaQZ88+jkT575WvfkamNAkvh3NOsFTQadey6cDDTRE/ZimOa1zqRgTlqLGUFoR3T8QzZgB8A3m98o60J2lQzbKyA2bEOmPbu3R5NDz2RJUvU3V7Z0KnTyRNjAvOLBQe0ZSuqcMoXGo949QNefg9MHQ6ANKx7Q7n17yUPvQgzUtBcYFD8l4hy2huASGOMzad0rm3pQPCPx4oios4UZ6hY6SCo5gn3QQnj0qI5NahGhjpeYupmUFrZEUFoMTnWS8D0FqQGRV6pTDygS3oagNRAhTaFhLi6hIgMae7RMdlww2xUpW/G53pz1XZ4Q6R9irlxQpGO1qqq3LnjncrcILn4TT+oUZUhr273IcSlz/eMCYOTpw8526N2IPV7GXhkLHSVO3j39PxlOWz9JtT/qGEe5zrLCYezDzvxQjlvHhJ8YWbi7abJpRxTFs4LMdga6Fwpg7QU7IHh1RvQtDW0QT9XAbMtbcD62h4El8LjOMMwFjCFwrALKRN7ExODS8D8TmcnRArjnmhATANLHpVwKdzXR4DMcQI3r0M7ZijZE79won5i6SGqfyhMApBtbsksTsThF5H/imuEm3GbGt8TYiU9efqZwrA6794OQwYjtJgebeZE27g++yXf2Kbf5dJ4OMAvXfwjseHWCN9kgL1ARCb2SSMz/8bYdTQg9dM9Yqhv3Le94K8ccsODk7ykHgGx38FHwS1Rgz9r7pn0euqGfyRUbnzDETtjjWnlCqltOsY/zo0aqd19Z/IZ3hcUrohuKZblSOSXt/GfLypmU+9D2xnqQrG2O4t7zYD+2f8/bZ2H29xva7qifCkaQL0+ijSi1AoVoPvcIVGD5T/2qAa4e7E+jGK3QBn6F1fv9jorUI6ZMDW2EqSHkPpfxUEEJv4a6hJv6vv9hxBKE8EzCDoY5Pzfybvj9p13++ev87sXcPqJGvxV/cfVlN/dbEnmQz1oSK8q43n9QZ0rxqeBEilml5E8/IMiQix8zJtCM2Hdn2BvIqfpkXViNwGssuyUyLeaCj9Zb1f9xwOKFRUElhTq4vp6N7zrOmpJiB7QuYnmZ5F6q3qZVj8Nf18/zZO7GGE7u/ZgRZas9PGg2Xg3SUhbcGHYoPtu2fzusAE3Hn0vnnUaTBSV3x6gJc1afzI3rCvFI95jPg4YH3y5a0jzCmgWH3q/TBRjXlpNfQQi4W5lOXLGCWvgCxeSC2oHjntMkRACSt4ZXwmm3++3oe9j7WPiHhuwwvuAefoebb6wQqodtDTmzAWU0P2yg04c6gOw7dGfTgo/4Qu6gLGQelVFChkJ81zNLyy5JxI3ptMek6v2L9lacNdjn/FFuXFTVQySPOy00BVLyYgMmm6Wsy220g4eZh565pu9m5CBDA32ULoH2Jd37JfDjbkJSovKj7OyOWNGtj7d3+wao1nHIqBVz65NW9h0q0MNm77t11kjjBZM8RHhndu0fSwKYWnU5kdrxo6Kk5Mmo72tfTG9VbWmtU+HGe+g39iIf+B7nnYar7EmCVh7dqDsNDhQ9KLGb40sd8mwFvZvgxVrcnYjsdyE2iEN1sSuJGbGbOV81SAsEcxyaKHH2T01psO9KlZFf8DbBGKhP7V4FZ1JaGuvDJUWTSmEtjjtcYNnzCumrFCv4NnlA5q8hnHagY2s6mdMETgXnVT21Aq4IfZPofBdBzget/oRIrLR7Qe2sg9Qt625oYx31DkR7UYctlgZkz2n8dEn1stX7ay0+TIjUl9yQ1cKpdXOH5V3TWbYNWuJvupxZumgK1T/9n3MWRZP3SQYyRI72O8MBR6qZNVlAl6THa7xLdrG1abN1drzFHuRiKrhcPCycDjwYZUJMedAYnVYbRlU0QcWXtAzfruPkeOQ2hd4P+ALsyz0hsjcHQNjRoN+zpEy/QYLXjeHv7W1fT5kc/qFPYUmfuIqDBMZ32031TxmdCt8qkMdH6tme7EcNIbF7yqkUAIMQatrztB7Bh6Bs7ekuMYrUtagkWsG5Ohc2hRLdiUQYFm9awOi4yJtgdtN6asp14ZVR0N3hUkkeocu1JEkSMMDSyNS0XDdW85lZ6jYX6/iHMQEE1XyA/bOL16wg/aAUPa1hGRscWeB1y5qLlcXh4zLcLfGe4VlRzZ52qfj1Qr3UrWja56JgM8Uy+S7b7TJvczLunfCGymoJV7cI8OSXMhIJ/gMZtSwu4wNWQLaP6Fyfg0qzoGKg41aWYgY4P9rRKW2nDXSRXZMgYN4HxPlJE2z3i4798bXpqQB1Sl1UV2G03R5CAqsEgHmtkk8WCZ2n/uNK2KtcHswY0g20Bb/xBIxb0Wvmobktu910LdDAJlS5Pbhn/ZXdN/eKMjXE0EMTPbGVm7bNWl1wIxwlIr9vvXJDLD9msTKvyUIvnfzazLr2oM92TmXoIVdOxu49lNXd1PLYZJkJ4vzTTMdKoEBdhw9R+ujS5WmbdZwC6qON95hy8KcxCPRddSArTDTxagw0rBDuY8f8yASOspAzFVkxH7PbJDutTPcrWgjRckDE4KJ0AI5e3lpYkJmp35duoGyTPBuIwli36aFle9F5q0e+9I1kv/14DU7lm2q4An7FgyonJd5OKkl4CXinwZHlZDuNbXDZWteK4hpxcyUHeLR59MC41FMNnF0se/amleegkstPZsGZWTtkGt9/YyLt5bLvAtzA/OHV0MGzltI4bARUkuVorfxEayhg5R/6F/fADF/pwlwDRri9eObIcDKbD84sLy9+HerbukIWiFg1HqPv8XN08NjEYiE8rpI/VUfUSN5CohwTWtuJMzTc5B4KLR7wIngIcjXmMMHZtwZapHv11FHRb/hjzrWFSyEtnwQmvdufs6JZA0CxVr8PI8bZWQW+bBLhUh5yqxzreVArVfsaBfeLez5vJomBZLq4trwo8iOuVJ+4B45pyMHkSIvI0tkvGLCNTGWn850SziHRRuSRcKeXH5Q21odyODgCsc32MDqIh6JV0IyDIevt4Kk9NQxoGeAmoyC7jlqdnesudYqJrjZqrOlzYh01z3a7CccuiQSU3haJZRyPCGEGMn42pvqh2gyvb95bHYskTdAgGaDoLsKoTsohZgk91qguYP1wWvVKN77kyAIHL2hi6zRlcY8t7AR4pUn0vYZd4o6IRlf2o1bfQctnQDrbitaG4DZDs15jgzBM6DB8Db7PMm6Sxfnn0WnBQZxawe6TR9m0r6TcMlfaP/XIIySKIdDYlbJeTob1VtIoBnje2GMNbNl1E1j7J+8B5blvlXGUpYqVRYBXFQBODvyjXA03Ek489f6edWFOma8DcKKVOHhGLGQ+eo0/3xavI2v1ffFSUHKdJZzVFTlVv5eUlo+0efaGlyyfqsoJ/emSFt9kzZK/iU6QOeV6tK1aYpRrZ0dYwibsqZkeNOohry1xJJwX9oQDqG8eW7CY59tX7aHn1b7BR2OiomLv6axAtIhFYSmXYb/+R0IFRK8ycda2T84Wcfmn1dCXfinbqcta4U/CXr8m5ApjgDAiZhSm8i3ruCMMZ441bWcpb+mnjweVYCD/qX5BknfNyh8DHHd2y4bpFnXps0o/GJF88DmjhtrududJNo0azaKPiLsqqoaj1wdUthBunvHkiw+HKyZGz6CcYctojYAJawl47XXw5njYBSyTAT/Nm9TfRqXXTLjm5R+CbKyig+pmhUbW9Az3ZCzkJocgLZTyR1JUOiWVWGwBQ7jVQe/Yqsj1wqUAQC1hrQSjYBRx2ZGZI3nJkmaynWu3Qq895R88fDbfr9LppxTQC35e03lug28dQGm1bbtixQINmfbXMCryv9jdCkcsbj/84uw8/hv8GktQdd/O4vJjYJ5lhxGEXm03kJugBonaxyep9JHLnVz0T4xiXf/EDMZ35CGTGuSSK8m2lmRexT2GnLFQ+ezNnLDOPEc9gV3J/aBPVS6OqFBCEPLxUcXDsv/SqfOO4uFlZQN/sj5NVL0vsHB69hONhmasV0t7JY4lyJrqKRKiV3UebLkihUyiKOu8t3WlgqCj2N5wis+WnBtbVaY0vZnBBEvsqVP0NdqK+WE88yB7Q1r70ug+tUMIYPzXpsQX/Y9vax75BsPDMfyc6u0LE/oAbEtjSSnaI2gDxZoTkw629xVxGl5QhrWaiFyeuCzT428C61/iH/Ew4vRzmbzdveHj+62C+PLUwFn4ja3JP3INz2D9B8W0DKlFBNG2/vIW728wogWCxT9y8PyVj9KXRK02MhbbgFkJI6p/zVvWNSR/OgnDokr3kDHn/JD3hBC5cFobM+wXLAh7lqz7045TuCW4jUIuOYFtxWzj0TBRMTnRw4+JsUDPJ5UUKMst2X9hsysI6OaV4FEG2C7lMAUZGvUCiaTo3u7gzgGA94s6Z9+IbhPBQm+ZG0ZDrFxavWH/uRa4kPIXhdddJlMk/HZ4F/nJh3orUU+/n1ZPLIkYzdZrbf7FmXPJ0TY8xPyt2ObhOD4l8OPQcRrkaM/+0ARfzLMnM0dfsiMXkU8eMAgEOgdYuhW18KTBUjwFPJEqE8ikh7aMMklsVVNnc00FY/gnNZdoryQY+Y/zJ797X9kuJXRDAjLKbjUslPbRc4qYUGnL7POfvgZ1CzqOJvjzbw+YFll74n1qKQ47H/7zC6tkaT1QemwZ36UzlWwziDq0D/bm0LnssXR7P6OWfQkSRwc0elDeLxxQ8PCCEXhfc6SxzCilnPuCqu5hd1gTZHvWmHdi0McSvzPiPedZWbKUqHLC9pVqIrqShaep2kXUC3QEad2Q6GUNglletJB0xzBFCSW1ahQHws2d7KC/dU3MEtkd23UFS/58FcmqqggT7Q0WKNhDXhpHPbbDWaaHlE4AIv78qfvbO6+Yz64XsVw0CQprPczjMHjNLgLgyq4cp2xItLzx5J87OlmNQ6J2yGVnL2NTDY5NXGllst3gYZvqBwAJiq3eUNcAGgRCm3ceqkgYTAcC0/EkHHFk6oeP2A9gWYgMJGtZZa5hqGjaXCx/zDYPRiSzYYR+Sq7wRgb4usUUeCZHqwIAIobdQunp4PFCiojOhRAohVa2veO3v/6RSVOU6u4DFd/ysa+JWYZ/1Co1K3znzcLsNKIq83x0igDOzNBAJlbguMbbC9eS40kfICEQBSx3brftbtNNuaucjE7qk4Ti7gf8q/FwZYz7U+plOyb3y0Z4BYE6KnU7dk3rrvEcXw2eUxFSxy7v5jVEIukez1yNI/ta5cT5p5K+GbjOfO7tadw0+MInwSi64KXKklU27GY7XxevNLhqbrtztzXNYQMewPUJgD7PP41dYwDnNUhD/xtCb17skBbGf8YdH/lJCMIz/VjujslaBm8zRHG+k/vWH5+/mmZ8Bu4MlcijZZUb+Wh9r5EISV+W/6YxjtMKS5JPJry0IcIhvCM7vPUJBQDK4UHZCyxWG0IfT1UAu0s+Of7a1DqwNlGrQ/Rcy1D4iMEt0kANbJDwLCUXzNwNniLjjuszb/TQipyXlyTx8AQfU4BS4XJzIaY3DWxHwd3RG7lkB0AvmvmAS5+W8CbG7pP84CDUXq7DRI/6T2RGfM4jy/SY26zwJN8He9zC4HlszTdHrC7VqAb6827PjrzN1W6jPBlcp+FSTJfck96+wmt3mhyp85T4YWPOqFecGu0Y8CrU7ZfmDF9nj8ILsfCxLHh7zP0ftF/fuW8vbNUx4SDsNb/UEyDoW3i0JhkzU3x/3EP3vGp2ZdYV+XeO4PH41fBoAvG8bL+DSQpRpe29QGu06Kpre0eGgqa+86ffjujKarPXjCz9XTuyd9/YDzKfU0JYIaCDzcYafkQno8EoSxZmB5qMoTLSb4QXQNvGkOpLJZ76SjJ+4GRZses1lanN1uwt9qgPW8RaK73LQklix6AIKRO3lo1NbDbjB0lRVZp/q6rid0XLdRWkkJvCGD+VRmDEY7CYppjWQIAAOftKOO+6yLHtTFRk3h2HMJQqSZGN25ulV/BSPacAX5aNN8twwLAjmMHDnNkHoltntL1/ktIjd2bI5NdO5lY9p/B3vtHfkoU4BLYpjiwyewk8K9cRdCdq0KWiFDjm8bqy0kVL4fDIfMaikmPmvcNJWhFPDXM9a8IgNDVGR/8gwbGPLy3x6UYw0BVxVxXzhw4DBF1jpK9LQ+VdQji/C+A755e5q8mkcBmp8hdu8nIoi9xRYCdzPgm65eO0KSFnMsr+rl/aSWg5BXcT+0IqjBOoBc73Dxe5KZBqENrI17n7znZXC7WAlUHuJYlg/GT/YTBbqc19gFbmyNKOIUEVj+e6ogG00DSItvL+DaIEK3vm2Ye7kC7WgpUEMvMJsyXNUNoQQw+SZo4CXijMIlVgwTHFuR6CVm+PNMmDzAY37isCHs19ecCGaTdNTyiMbP3hPHiLGIz8Mvu87WQTReJYAXH2cryEkNBUG1gaRcQ9VFVSk/5PP0/61QYvlPXW49EPVO+S0Nxuc/J5IMDQuaqVJZyvaRXeEEqJhWjM1GlbKGpJCzFwEQSL2EpLVDhSGCOP86q0EP3m0DTITkbSoNoZJsuVnKgq/Cp/a6fG2oX761dJBmGytWjzwyZB0Q37gZEQ/yW0UiDjt2Oq3/57xXYEGUySruwwjX4v0ME2S2yaGr5kFwOqkwaomMuWAeexQlgQsG8BoG6zHpG7am+O1ztJ/eKlLxPx4P6xKdI3FiPeAy34nPcxZ7ROCnLtiqn4b7hakj0GG2uTCt6wfrl0YmgpVOjnJT+WBhKpgnFbtYuWCH60FNOUKVG/Q+EKrwYa+E2z3Yh0+xoEPaTL02nG/IqHZkVBs3ORpBtDA4IlMhcw/mcHizD588qeZlKjebfLQKYJBePonLEfLaR+6Yt3ozB4EU6XQSDYAutR/fQGL3DsP0qPP1l29YWBKdi3snn3Jo4+6AfPHwxjpbAq2YUY+4aMVgm+uAYswLzq+nWBo4tQMh3x1/TaqBUFc229RgHj8zZp265Gr7uUnkMcdRvMZ51W2QlM3f621cM5Q1AUlnZ1Iu6UAw6ZxWuvpyyHQP8iQShSmh9Kz8kf25gZ9WAJsZD7nBjCXQLMRVO6HlilTbUvq66uKQ92+HhJ0F2/utd/zbx2WLCHRX9TjMOwsJe/7hAFqjR4yv13UJ3JQv1ifDVXJ5s1zTY2igyedq1ILIajy9PflA2S0sM49SPytMgHjhyRCCxn32gitzdZJfs/l2Qv6dD6+AfZj7nmKZ8KYlVhWpp9IZ7MU/tJneV4ii8Q1S59r/ivXKbyCLodf1T3WaUvszY8gUdR9dGxPZL2nv1xXG6FrRANGZwq0rLlZg6PoDDwshOA6IH4mfsAGYcQhp+AETlIB/Y8sFi06Wthdq0+RzCb2MZQYWgGf4hKWYR2BdIUfyKUW1JnCywVm6poAKgn5HnH01qJRsXKmTmEf2RVSNBjlrHdA9M4+lE+sSoyZOyALqAnSFvyNWXeptBV1gKK+Yk57OmWUj7V3tr/wnViO36PuVqV5S/TDAg3wUjpfFTIg5Bkzj5T22HjIkNP5Yv/Lqxo4wnVVmarRyQ70/thYU0hNkyQdMVnuY08zlaTKhyt+9HwzjE65TrVgpBwnDvEnkmLgneGdpdj82UEgjVAsD9ZgCVEKMOFeixUwSeIvC5pHJk1AeawBdVr3tMAxDxG2Uv1ENnDn/0pyN47/qA0LAtZ/2c6CQA3lhmFMVceN/BDYuUQSdVnxxcMVPvYRvyFPdDgHhiJCyU5QBsOdjLducQgQiRVuXuANYs+ncnh1V63A+tgNkBR8RtEK+FCispCydySYX+W5cHan6U9jdZ2fTH2ZyX2BKKDlltamSCQpxpzQehHuvc9gN0BZCM3r5ZlMG635he1W9J950Pbey9AirkpZkGwsIMR2WdV3JSvcCzExko9/9cF1qExL3fQ0xzOCL/nCWW29eUPUwX+eutrwE3rv3zL9PjuM5SgrYKt1YW26rp/xuqkVNdVb2LflBRZRyz3oQ/9gzUvyinz0LEEIbyDGzlvMHKaTqhuZTBCp7mTb9DajwZXR2mL89dKH7JBXaO0mUqRGo8y/woYFmoAnZ4dpVQNSOTP+6SX9H+v7+yz9Nkrq6jUCOa3zutznUJi63aXijcJQJmdXBuVmvskldeiSOQf5wYgPlFXM7QlZMMfPh8mVWNfQ6czUDzs6uN9qVODbr6L5/4iHYWjxLg8xOzPSmmR1CSpo+PYQ/8vjXq9n0eZflrSKrvJKuQcKrJ+GL2gg3WGHQgv9lpI0M3MKcI61+Gzr/pSWi1/15co0r+eB86NVg+wsmQDAWMY01Pkge1kqis9wg2BfS4xJyxAJtIfjmsdMQzCT1FqnAWKGYTlxpeJ82SixMXV8128Nik9qenkp4a3kD8Sr9Kt0Gq8eCOkcBXX579xe8rBZ9waxWV9z4VY8jGDwlMZV/daa5h6EduRMvT7iwGsMM3L+gu9iw1NbOMzEkjWssv816+x/qDupMUhpk/i9Pec4UmcF6f7UVRv1ZzEH+niyHXD/46IgA91r6AMOAyNMrig06bhayeccd5VUMifPqC0T6KW8VcM6NZER/C2g52XZEY5NSFCtva/eb/xXwTLwGi+qi2AEiy2306E+5v0ZwX6sdqohzPKhVlr1KMBGEQFqIc2z2YzB+srLL2+3pFnuf4j+GFjrIsE9c3HlIcDlBLuMGu+xFBaUS5ws5FzoVhP3BiEFhsuMk37IPdAAsC0GBllSsvw0jCXLkuSiQrWp7+1BB/4wiJON2AwoUT8dEwA0DnYxgeepNWi2zQMs0JSVVKx4mhhSmdD7JdCZSqPSvqFR6bXeLElOg8QTYspMMXcrBzca9xLyE1HIeaXO9bZ6NlkJNKjNixMIw0/RM7PTUuiuVILS737jwzKfvdxz4QZkHnN4F+NaOpiTVJsVPzUQA5qskN84+VrJL1NYD0D02wSwDSdpJylm+5VZAq+i1PZh008VHFS0rMZ1UeC5xfb72PUUhfhY143j3SNF0vB32uPPd0hjLld2Bjoc2sUMulOMoX6xziiTaGGwoqZQWU0sN7O7KaJ/sWEmSidAu/ayD9ybH9j/9FnFU7WVGxOdLSMUpMS6YlxjzCX13A/EWKVFv2vDrVNUKPn9+eE/JciChd7vtS/Ldpq+ee7lEufS0ocYpjs3TmRGJF14MqlxILuSCr3nGe/mWYgihdXnWWCCzSVM8Y4SJPR9qO8GW+4kBLM6S6VbHYxDk0E8ImNBcWLJqmBM9SB9PnYqsgA4PYp95JadP8Kmy0Qtw2S5/y7x+Saup4ChwCvGtjPWx8WvJF91Nd8biBF7t7hbr/SdZa1v6Cwv6yllT6yQvW/hv4CpPPPun9lvoVPupnIBK9g2uLsmp75RWzNWTqdz9Bgwf2XFJop8gg5OBm7rOIysM2VTqZJnijT/h2i+4Wxg0w9RyCuFoAmMa/DXvLXI3OvhBuIgvYpo+hu5uYaXRLJihlv6/4u7vSDYcpAbl0qs3rjb36WyOUwd7FRfsP38x/TjeQIi1SbBLgcCLtFRwwgHPbmkzoqOS7VB0zIvidrAa5IHytA0utRDKptLIl252srSIhdPW99U9drxKfJXzbTnVKV8aHvceCR/gBaZajMQXhK1DMx4Giq5la+1e071TU+WztG52rUqLWrJT0q9THc30Ir/+7/LfjfJsKiWNIAJkH8npBdiG0Myx5FXtWngkEsuLUAQcejMbqZUsofuuypGs/tJ16ATMjJ0B4VuWEUMy4u3bJNNhQ4J38YUxwVteT7myjdm+nSx8xZQqwnljjGZbwrrDJbdYovImiZ2f9miYIfQalGTDdBfKsapC5aEHG/6LGD9lkPJSJ3aVHmqVdk+G1uqxn7a9Hy7qUHSCwKaCLvayyxgMFM/hne4+OAWjhJ2WcHqasJ+qdxbZiHitWd0/oMpqwqkr/mXFj+7+8QAMjvu5e+GuISfQPguaLViBSTUS5FFFOXKV+gtRQC0XeOY30dLNcBS6HeOCS1j6ln/JoYC7HFN0uKNWS+I+NylJNwByyd0vIG58lvZJIH4fNTFDFbbYSLIgJBr5oHauGOsy7Vc0wDAR8XaUMT16oJGpvsE84Js59X8WiZW2cqWhLXtsuHBaaTvLzhur0pG1q6RzUB3B2Rpadx+pUt5bxTo/MikSvfHpFu/1Cxa0NITsWkvwCgYeUjXKyh2XntWm7eohW5VAbDVl9LbEiLSS4xKWsSe8kZ/1c0C2rc/sM7F/XfnXNnFJYLriuEWiNn1vTCV7zT40/W5on5wsgpvsyNOm5i6JGGMxDWwdPjPMadyJcyiU4KlA7DVXQxEg+b53F1donTwouCKcm2p8w3B4BC415m1axLOVm0kUemkkEbkVPJxDCN6WPZLK3uB9oK2J+KFC6GfSIZnaa1CK3AweoWqVN5ja/1/7/xRD4IROzvwDC1qQdUIR0VV0dGPn+WpmpLgw6WBKbcoxQ473nAoR6KP6+SwrEVumvAT0HLECUWyugXiP2q71DB3y8a2RHpiZA/5EVlLNUhqedT1o91jOuRf8kj9oBVJ2uMfd0D+ZhHEnLtr83FpYKCwJ8WhbOK9oifECa4Vyd0+yOgjrLtWd1cwH4yKyQ5qI7S/A4R/JdwqbaTz2VD0960Asxy5NKtNv8V+IAo4YVAu9k/0si0HG8D0puj5ptIuvxsmd1rL2GuhAWkOobPOuiYf8s5syKHaErHcDZ9cgpAKHvML0OZ1cIy9WWT0imllhMTNRO68hcwIOHuEUznwlHysEoBISXKRu1klAy/UXriphHVuZ2xrPWp75pBkvkfJz1w9rPSAKegEZ8RBxCdqZlwIGsD7W94qRSgS/gOH2XpLjZnNmKk0EslJCrXtGBOZi55S93tDcYHVNVWt/CwGgEbep6Tow0I3/C3YYz2hdOhjzQwri9P3xlkjadySA7kNZR+QvVMHeXJaRl8VMg3JpsFLH3dUxT2hstqpel4a9F2zPDeH+x7+hbEIf9wWu50hmLUosKdQZoFHpwew9aKz2hpn/sH3E7OdlY6uqR3hATIqTXl0Ft65V6JjAEtA0a/MSgme+f6tZpCsgzU6LxZ6UAfVNn5afhApi6XK1g6Q93n3P7ekQddShuB/T3AAnjmhafInS9E2LAGbcByHKmXwPAsGnuyJf9fqEh0kad0RzBSUN/17PMXitM22r9OYv3T9MBoFyNj6USjlrKKI3ENmVJ1o3Eslf1By+2Xy7By0hjbefP0J3T3loew9j21Dp41Ejh8SKAT/3fmPN0+OxAj94esTU69wtLhlvNXvrciAGHKXaUb88CJIE4kaWTcJMeI+7eZRkzsnGxsvBpeXtynqg89nAlaV48tsECuPCNV0VFBqVEoc+Phww4xhaYT1QoDvufPCHC3SpapXh/PT5xq9OTpJYJoGd132HPg0XYqxaVUc0qW9XxUeBc8hjdin837v+EAcLpP/cEguh6pXFG62jqrP4yY4qYU8kSBumHGVi5UXfrn4oW2yYs0MJVzleIPFbu8j2OEzRxbnUQlXnQxYe1Q39nfMc1gExbJMeFGZ3N3oDGzX2cW2OyAEEAPAwsm4Cj3fL2X/TvSR8w9XoEe7gH+pDNumxbMJrqfqCTGwlaR7yUgT06fKmNouzI+nhBO5KPwQuKtEUzai7K6TRdQtRX5DwxKf8LzBV+IxwivLtXpwNrqftNS5LtT2CEp6NLzbVmhhtkQjTDwV+g7qoiq1IBwT8Z8cfnVDK7QiFrM1IY9lDH1gkBN2ibGD2YfiDMSXncxDSPj3umgjPez8rGxPptUK91BAPESzqFFGHfZ/ws8RrAG+eh1cfIXTHQr4z/MdBdXD7JUtlAM8m4Zjtvoss0/dBV2CtjsjaQFTBBrpHC7jWZeWrsAehSoZS4q8FtRdNq2xgC9QJiTe/Cd03QXrDp57hEmJx7IiL+1/RGuhVrRjM2kGOyqPZ5kK3dF98xpcI0iLpeesNdeACRfu+CbmvAQXes+RYe1EB6m0syd5ySJStW4HUy5oKDpJD9NIPgzyeZSE+Tw2FzgvABVn+IiDskOxaoQIh7yLRPQ3Lq+1ve3N76YRz92NgGfiUzwFfpLyZoTa9evWtxhwcqzUxAV6lq/T1wHa9v7+FVf/FCC+9BLSZqsa8Rh8Nql3DoINABiANlyJGjfj+r8pzh4uiJo7iuUEHgFz9DRjCrsgasNATjeUcQKI0XmMhLZXN2L+U+Prw6tbj0t3R/I+ChE2YSZ51XWbcTTVIAXO14bKwBPx0KHMX3WEWt83n2x9nx/LlTNGw37wrnAHGyhSVzFWY6q+Nn3r0BRq0oUXUOsqHyD1CM8+9A/4quLRUsC363W4y5O5gM2x/+mH2tLNLjskrwZtdtfGgVBSJ1LeiFTMjobqlz1CA0xh1gQf4iwKBN6OwMpRn1ldKxnpBTPQNdkjhtQ4xvAm6WCDKW2ja7QMei/4QSYBA8g1z9+mJZVT48jQ/nCapv9cbRxydDppTPu6VSzlbzhL+k3ncYmRtZStDH6XFErtcuSeN6+W8Z/mcZb9R10DFHYjNkydN2XblGkxOFPzxOFnTaihKRZ/AZ+1eJygO/KdSl2JB5G/fJLQxmLonbxdjSayTKiOpwl0JC0EhFNg6OC7VtoAO6ZhQNLJCtAVVxtH2sUdAH5sdOJu6oSRuHfE9+oiVvAsFC8uktNPcCJzvOQkB6Xw8G5pjsWlTQuDW4dfMbVh3lxyPdSnbaf47zdqRwP9AxRhLZDIqfpevymiGRZAUfS9UNwkN4S1f7iC5Y002O6OXgDrY/obc41i+W7qNUHr6uGSI1vtJON0c9ldbauGon2128DzCCKSFlaIVMRJIGaOoB9jjQbfs36EkhifR4zqF5KZv3jVIAjgY+3ZrBCAP40uLjZhEqJ4CL3qjzjvBVvf1NIu8DosmRMHWpkwRrQz/IamZMLrKRnFDv8GmqEJ1bcXjCgSk1GmjaishWcB0hqb+D1cawfdvA6+F0sdw7EeZoGaXgPK7JvJwPv7O9/Xv14tmiUCmMohfeaUUReVIuRLF3g8Kr1maBnYMwwVMhG/Nvf5jgud5ZBA7uhuqI44ac7P0kCJD0XIxhXy+hJFCMQOQ5LHCfuz3Yq83+8jrNA+4JOwwIUN6fH77yXJmL93hS+Nh+nwOjipdQtz0P2qSjQJBS2iZqvvZyLVZVUgVOlwDKqRDcBygiepQk/y0D3YCYwBIhSZmgG11z0+VcU96Yu54A8VmVrSo0wpGSZ5Buy6C6+rqmXudEq6XUQDUFec4ID7CqIZg9ntneqEyM2H3ZUc4dqx949mDMZiKGN2meAenHA8GclFs0fsS+iDu4r9wPOC+O3UlQA5k2kE2B42F5lAhxQa2q0ZsT85bysEXW4OpWY/lgcIwk0+ltWFq0DjHDWHCprWPu96/xitrN9423FPAWG3KkxE1/IVP3MQ6J1cMywVp0is+AJWwQIIZc0xXdW45GckOyyYoFmCfvtEwrD8U0VirE+Ca6KfQ32e1W963X1HCvkKlOXoMPfUaE5FNr3ShxS1UVWv4EmTERlX0mlgpJeTmZD4unZMZTcGcUGcdDeFPOFNPkfTMdM1PYXXL2Qv7PvgPxjlcLq9o1TCSjmH4CYpOXAD+JL7TAS7rZ0MkGA79l2AlLBI+gw5DQzU78Ptu5rjn9Urh4PlVXn766t8+p1mnJL818RI4Br7yGn7/Radu1KwJgI+a+JHIwZQHW2zbUSPAS9kPJRB/rs5NvqkCJVbkDjsSXGF1JYlk+FxrerHOCvlcyT/g2S7ely6aQomwCqNscppaVjB1+Ji9kNuXerwajQHGj6mn+EL1+zC2MJ0zVfCG/wCnCGwxDzh+JTJWh/fFtMZ+qXIcCzIm/Oh8ZaQtd+BMZMQZPt+ly5x+WP65QGFx0siKFxUU/K1NbC4V1PyQeImABDPKzjHKLTR4oz+xELL5dSfdWqdr1PgBVCBakihvl0X7xLLs0JEy0EgTicJdIlr9l+85uGnDKNnQcxE07hPuEO+MZoHKohidk9UJrBvGFZMco6FFRoZ+3a8MNR83Bavo9/AA5NGCqNne7aRUAGVo3pt58h4moXA6NFblAvzii4p+G4NMm7o8WAbWkSreED80uX8j+Zg/KLKMW36+cb0bZj8RFZgV2RVzMq0n1NBJbiWxnQwglqz8S87vK9/YGWBkHEZgvyQcDLR/yqwdf0jaCxPsjYEdomUIScOr+nRwIcIxpUmCsZ+6i3B+irgIXOz1SgRx3CkMaX9fNrMECs+t2IJ0eS5ubz8x3nvTZtN74NpQVXrTjvI5sBeIOp2TN0GGhIGvjCtqwqH9poXUB1/ZPGYSx2XZOGMAFivoCFkZ8yA8Lj08SFRKPMhvoltFpUD7YwueJ4ctjTaUsWyDUPmXoMY1/DOW/AdBIK2OFA7wVBkceUtwzsPZmDMiR9MIoXnQnO9GdZVEhYLkYeXSS+n+H0Hcb/rhWVKb8sH/wXjmn1x6K8o737JBsbAnLV2pN5Qu+DtTdmWcHF+tr8zpAtRBYwUxKWPBJ4gj/DJka9gnjP0Wor0QDY/YiUmgkBDClzb9D4SBXR5eXfjvf2YfR1FzldYJTJfOmTPEZG6k9lZfnFDkRpNlpjMIF803Er60gCkTrE4I7dQW4g8A8TW7P2XX7rXFKvC+r9jTYwcvCPaGlPazTfyBrRlL5QlJeLWJ7flNjbr+pgqE1+uTYF3+Z8cBuM6w333sx3bDHSK5m8OktwZeRA83GOofr4spYnlXOESD6YVtHYNX4T/SQrPZf8nRefldhlk3gW5/yf2/x+E2F6wXR+qGOf1EDIAKQ0zXjIfTcz4P6kF7Rsobw5E3pe1kOSZYmGiidieomi8VacVSwEtjfi2yQYqCmt/Ikgv5JLd+5x1UFYRAtL8GBuJvWFeEZ4YsjYFes3iaJ7+8Swr7me27rHqpt7u339R4I+xQm1jYqYA7FgOsOPi0Ce6klX6I2RRgQw+Gn+FIoUvmZrQG/olx1p0HJ3hukPVjN3XWHM7KyCYmuRiGJwxTv7eSUVHIkyjBpukPT3HmKcvQ/Vdl9rGddu2xb8bTmxRSjG58dKLDIkmzWbwzUxuFcABt2f0uBduKaHt9QlgYJf9a8m4hUeOBoIU+DQ37g8TYbjUqXg+l5cOdODpe2604AlbY49iWzGeTG9I+4+QwFYfw7Sn4nI9hWF0bIBuQBs+0nrpu9CniGlErhO8r7M90MZcFjmhK9ltaoamr3qFkdd9p8LiTa8DKDdHxsKpkiqUlvyYZVDyLQP1Hv/XyptXuEoo8KX6tiRJncgZVrmvdFuZj0pFWHNyCuXpDVHojn8YSLeZMS4QAYlL0MpiNqAYY0TShAoc8CikdIPX/rKCG8IPRbqmAXBpkCt3JA1/3F0qF9z1mduSdBs3aRhMicq/fuWN9hamNDuD2kZWuhPwemS3idv9JvOEaxcUT/wRK891XE+gpkWAGtvQuqHi5/98EjK2WXIHZALYHydIc2aqV7/cYUDi5EMIpT10qmGKOjYrU0XlM/KJfFd+/EHALRJV7b/8M4Ev0RlWlQSzpNSCEt93gjSTwDj9uPtCKNQoqoZj7W1AbDUSGDk4F1rbIDX+NWkTsMbLToWutii27w/7+QydBoDsa5UsF31y6JWV1vvrEAkDUTqPKud3ZbWt2uP1fUgr1onbe3qhYkBRR+FZ7sMO8dj6gJsX1b5RVgINCGQDVqyqXflFJm2e0PRqS/5mPuiK2IGwxOzRJlA9tqDcn42UwMRGEu8AJ4ti784XBegGrAV+DcKD270n6XnN8+twxetsDKTAZa671S94iaFJqfI0vHATWvmlIm/L3ltFgKgK55tCUOG/yC4nPNrB3eIcZJkH9ozd38+k97WLGZQlkxvKN4jDAjjDwi5+zOl/HJSWIW2bedGEUSrJUV7rYkccOInbatyOenqhNFfs/22qWaxpdp4xh1sb55SmPA7GkFCqWNEW4i9Pu8Hy7OaejlUiHkPc/fvsDArgPw0xeTXU7vrb0pZIaXxyBtqDJ6g60cDbzmWqASZhqoGYiPhHDgCq/a12fr7tF8QPceEFwwEe031b0k5uWVWEPrE30+mmc4iDVWsIUI0Ge1JfY3RAjQqZqs2VfLtkwoPfhwAYqSQQ9dFxNJtAyBfmlbCfOQJIB0iLkMb3n8wNacWbCNBDq1tpGwotmKQSd7kuRsoE2c2/GrlhNhD2o0yagRRJkcPaAWAGeHqzg0Pw3c7VpJpgXdaXI1ILijj8Ce52IYpHQx89OafhBNMwWxX3uU0Bs32ZdidM8FnP1UsjWrfkm1rcFuDFMIBY6BHSH4jgYxOyIIjPJt2V/CbEPo5VNN58ZA29dimmzfwcSz/WVY4e45W3mujbPRO3i5ZKpvWmQJ42Za2wmNt2wQYNZJMn1+VKfhWYmEt1Rr2QEJCWpgzWzYBX+xRWGeIpDR64vApIfyESOOpkN9BpJ2sr2lrZhFAsps3sed+rtfZRx4A5u9F19oFGP8WHIHHLO77jFBniz23npU5M1loYRQX1ABh7crUpNq6OMQlFpgZopXoAPuTGOPgRSRSEPhkn6OfIG7JjqBjG/etEVVrKlJ0gLhaflJ0Ses8NzuDRigC8cfxNOqOLEwFRQfC8n/qsNbe6GzPiDOA6+8liBI20LlxrdnhVkOWsK9mJZ5ud5dVOQklazuwx20nCGfOVaS8LaZDbC0Bl6biTN9QstkWp/MPvLbqt+GqOj8FUkE7sukNXBY+1f1m09vSvUyCLebbWQdi0SjNegFZJhQS3sCUNGiTcP1OG6tooBn1fe8NpvKFEp2CSbLI7UmTCSx3a68vkRLyhBckY87yl8vIuJP7y5FBK5+LdL94cVG3JH+ip0ZqN2lVRGyLZOBvOiYO+4U0zBl46E6GNZlSJ8oJPxlHKQDtDN3P1ZqCbEiOMiD4JXxrUQieZqVwuSchmibt4qHz8njHDaxlhya53YuKYdmZYkeWHnG5K0SWMgrAT5vLll6SBeJ/CA5woPlZvXWi1dXRmduRYEy9zw6bmxecw/yPAZpL7T2rhOb+Sz2XLqkPgJ69ZD0IIsK7sk3uUfZvdleG45YPfx/Jr8i3p8+6TxQAjIz3DZ/j0RyvfIKqkMiafrs2ttfdZthYyozKX8AjnhOUBq5afpZs3oa+RSnPNVUc5rTQQH5MWr/AWGIF/jN0pWJkBcIdQ7q5BcaGORBG4veJ50gSBTF1TsjU4rfH0kc5PrJvk7h051q3Z7W0PJUtCJ+YB61JeeHWRWTQY2rltfByyVzzJVPlJ75bT/UKfceGtZ5owVDgEvzQoO0zSUmdJhq2fK8MrTIO4jT4+CMXY74PXZ7HUxim6jSD403G3v9Fxcj0UAjt1yZHfuLGXaRs7Nug/LU2yU3lhAVWdHQhaWD87pCD2ulG0l1qAeQmiME8x1teuEkrip/oR4u1B19tt0AlVqrzT2InkU4wE0eh+V2dpxAahhXDbm5aJeheodXIq48xG6VG8j+VhAHFxT0TyLAHXNO6zJKffHQiHJQOE2kxgHv/6ghFfNgBaXZC6oCRdHr5Hu4u7TnI9UUciYF9dS78ndQtkEn6DTQfcBsQ+R/tOFJkuO5+omzoWHfhv/WEFqV6xiiFfLQObeQ2dLh2Lg8WiIyxRs6PpLmn3Y7dnCig6VsCvz3iI5reKdGrfnNW90fbh4Wulh8xJkFitY6wBYI7vT40enoSL9wt2thPAJ9RRagylY9D44atMz+Ve5e9VxNST4ZHXtJ0AMK5E4hMLRFlGh8i9+t8w5o/vFovkf7sn4UH6sgbQwTsf56GYARO/snW0Bx84T4Wnl78F2YHwQQLAj7EEDO1rUZ4x3L/zMuLBoDkOGTYQ7nfT8eUZkD1JVpW8ttpSzxaA6ypPPA4ost0HiPgu9XgAOCeXsi9Gt25EcYHVvRr0O3AlkEmrEK537I8kh+vEy6XzVHFvGnCDSQrK221Ryu8GYr5TcjPb9qaUm9ogrQpqVwAaRVXrgHErNMzCznyknMr7fOCIJQrD2++EyeNHgHHevL4luP2o0PD+yr10UcNM1PxkX8kxMw0kDySUQ8syvqftJABCsNXMJrD2QIHvMq+xUzcQF5afvaMmlb9E/F7mhnZlKs21yTazViNE1Xxf6dqizc7p6eJ3+kHS8mievKRSE6d72YVF/olDMrhK1KckIvClqwftYtD7ssB5hrn5k5CdjbalCMly0BDVKGFIH4PAANUEar9j6ndQwva15M7KnIWkEeU40akaWEL6djdmHDrExi+JNct5wwbxRHUYvxjFowA/QWxsa5jHE5h3te/LfyLdr1WJvqTOV9CDMSWvEq+MWXpDJIU4UXS0XulDsFF+es5TbottNhYQFxmsUUIMuszzxoh5mlwmEe52C+4Ht2vbnqJqvsmULHPBynfH8o8lgZGfMfd0D087rt7DpSTxBpRBniGBLOAn5xIDigx5VE5PL3M4+BuG1DYNUwhPmel5KXfLqtdk2warW63VkyKLu8+TLgZbXciEn747DYNNPMp3qW0GcXdMACes4fe9z2K+nUSgesjgfWVsdNCOBvsdRrYfhG0YAouVb7aiAc4sMn1WCW6z0IG9SfQVMzVOCqYm8ASxSRX2srAepGWQNJn+xC4mjMsAkjyJmau5j2Tclix9rbB6jRIJsavFLq7Nw9BpP7vTca0firhd2xgZIv/dj7Llqhu/zKC2xZ5zYuK+IenZe8dRukXJkuT+T1oAk28hkoQhoXKR6ft1iM+R8Cjf9Puy3B0yTwCrGAGbo31hZ9qjplCzDcarSo0XcYCP4LOunq+rjHIR+wbBfhEGwT/0C5sX0mA8roGHtQEHMfUA+VPbgsOXH1q76qdenp+e2TKmPhTML0XJ0BFGBs7wgVmBQZuq6f4aw6gGVltrfSg106Yu8SkWeb4B5rGxM8futcMHnNBtVTT2qeZzFComMc82/i5iB7BG8nnKc90ASnbwFu/ZLT40kagY9wwbvP8s9aMR/Q+Nh9ymiIatB6PimDsDKxyXJ1U502qcr6thigfZWdC3AukWbgsRf7vpSC8Tg/dbHfaVMFrTPnBj5QBwckaVAN+bhpUPamk5rHKrvUHBAuFzO2IM4g+3DgkZqY0A1bdrrLq9XuAtWep1oqR/Qdizwrwp0wFxxBPVJi0c2BK4Dtp8ISZtRxx6NpJNm3jRtE7Wr/l3OWZvRcs6K7DcPDU6neEZ7XWDlex6DkYLuQ6mqPOpjQ58NYePevqtEQ5G7EC4SKY48JfL42gzh+ZsdEOW4ThDEBTj1vZ4dXR/hK73eijFzMs1mX7mHkBz7OEZjRqcLC6d3cMXKxyhpeDJwfOYaqYce/6OfDhcyBHE3Goo6hkz7SKA4Dt+Zk9SIpSLZV+koFFH57rW1HCJNldA0abzPePfT8n0aNpyLqNsMfx1TXzpOsYquyGkSoCt9MThzjBgI4uBzIuUEp5JXVBDOPTvIV/QMpfcsqtOmbLP4IGj7UCZy2uYBDiQ3XBd9zlIYG1qdMrt/w8ZpAmuJlk3cTz1gNpgw27oTfpIos0MmMUvrpNWJt2aPhVZbVCai8SG+CR3Xv4hLcblN8ufLbIlA6yGPGxKJqtHBEiaWNWzGquU4faRUGaK+hSJC6zXpFCQ3GQKM57ciHqcgzJ0JEcJ57940ezEQBZqslHiGgh1DyDpOritotQelrGidZcMQZYkd+1M+nx0BkMcwu2JwScIZ4isaEJJcsFDis4XajCh0glRtxQZ22PbgpByKmdEhhgcVXw7VJayyFO/hW+AEqv3oD6E54Qn6FbHR83GvxREWQAUozyEinpTsu4+o4+tUQK4M2pq9exeA/1dfbi+qHVveD8BT3/1rDIERXT7hLXWrx81/xdovSX8RjxjNKf84/8D8Q83ZywNnNOaJJa5OpGmahp/4r2bLVE8OoaK0qoe/ta62mKDcKuLUBqWHcNyf1ve3X4QtewY1RkeejOLt5oqWhyDGQOlkI0/yqglCNe+rILJKBygWxpcffIHccwpMaqfFtby0GbVKldmdLXA3ByCTdEw47LKGlPIkPy06+cnoPwHJn1+Bi6Vw08HLsGIOMwA7OUpUbFA04226/2EQpdKbR6R7nR7CG7bRXR/0gcSZ+rrdr2z7eu/kROS7ElgCH7HIHWziCgZJy5B0y0R5QnnZx7pW3Faw89WZojZRTlIMpYGK+GDJaBqtnmeFbQIiMXGYgV1FvTCGzUzZi9t0jC86doFqnluLmeochlZq+maMTfg4EdBkQRDfuLq79UieT9p68IqFmIoOiRUZgEuqTL1J5idvuswzxs/+77IARXh4K6bVKlF9cwtiLh0/QhJ88E1ZYsv/gnGSn/jzeRQMKnavlsFuuIJaxshXINRJpM65TsMFHkt5OcxGdtdoJxQmffS2/fBAoJhj8elcr7uxCBcxF4W6EyWyYyYtcKAtya3u+K7AqrZna07YMbXcfXtKspCJ/OFG0MB17uVuvFXiaJpBnmkZ4UBktcTbiqCC73LrI9eR6YKzXKWEwvgD+1B3wPfU2VgTBJo9O0/cbCQMgQJ54FHXZn2iKeeMCc8r6Ll+OHH8wBcTVCj0Z0kl4wmToUGywyTQrhoEycJx5LkvcYKT6nbP2a4mfN5Q74b1EI9zuXRQhEhG1T70s4RYTSrO8mkXQXvQFuYmCgt+LWWpQmageTThF7aK6XUQAABh2VycdbOQY59IWXwVtEtkoerHXSxj1o5HKssN6wRrL5vXqkXPlAvzLHtCA1g3tEPvxWeFZDArn/9NzMi10Wq0GqfMcDKYILtzkbhyAV9EjHfGqNNyPZQb47dkm12UUAhSJ7P01lplhk6VVqlpg8IDA46jhDKtsalIaZPQFTxFAcTFg97fD4i+gFa+yVlOESarjTCFIPHO1IcAlNUGrfi1pXZ53fREua7GTWplUD/DbpjcDMJA+Ugsu0AoLW9GxmOhVTwV1ZJj+CjSUMniadCgsOwaIlI64nQ7dZWL2vaE7FGjIm8iH5tHnIJcmX+/ONfyks8hCxYfUNWZ0tcf2Hui3YyoICFO+ScgEOZSCwa6b2+zphMBaK/C+xnTRi377XhKjpPI0DnXjjmEu1dPQENtQFgGZM7Ln5ydMcmhELrmD2//QOntcz5GqTw5ySA3mzdzhFy886aJIExvxvl0Ed/2GtAPKHl9QIc90D70TyRb00DlYzctk6OYyR0Xqd1wY9jjCxDzzEPoohiBiW2Ktg+6+qt+VcLX0X2qkpBBmmerO/KWay0FPRnZH+5LzjCy7Ad/b/lmHtnrdAKzjOoivQFeAP3ULwL/x0oqltZ43yL9GN487GbNJdjWPhMFTXvYs0XJ01RnITTSsxnDaaXJLPD/nsYpift+mtLTsyfXevt7m9GOCFDctfN45ajfP1cN+N3Uv6pfjAqtMBHH328/fUZAy7SbMKyJIB7b/OXPJrqfFIlBgnT7hufBCM2WvqiOZ91n5j/auO+Sh2JOB9Cdh9VWhOtGyw+9agiFeYXfc9eZsjHErEdR6C9oUWLwvrccQeCMmilcZPl68LXHPHc0WOOsOH0qzVmKXN/HuXF3pI5Cm+vHt92H/2K40DL+NxlviOLuStQVh9xVUwBsJI9h7wiH9UGxXhUrANuUSuHLYkd7QH7MnPbH3DwAY7RnbZ3bAvhJMZ5QW3TXdZwbBWeKUZvhUIlPj7srXtdjzm0g2ozuzZFbtKFV6o3eebayNKg0fp5dNsTnihktpmKnfQ5P11l1N73DPz5d3pckQP3x4cOg9LQr6XeaJXlcipbAOMvDAwdy25nVZnNzL2jiEK3A2NVC9uakfb2nAcV8lot82PjcihLcDHxerK9dDdMVIyILVWyWN7+sNpopAB2JF6G6kAiuOb/kfcvkeqPFV3TgiCQICTOWGgsworq8ejDwvCBeMzg6HaLcZGkwd3TrYAsHrTPL6Zm8V54PRNPkcNTBO4sjQK4Ojkt/sasrk3FunQWnVEIiDzDvT4AnpyAImkgCEZN/oMbGvh5ztU/2LsTpmm8we0x0RzdJeABg21GATjAv1vwKVZw/gfkx8/vKB6HTjeCnvlr/SUSgTzUJDZYXUj4Tvo+SRdimjGWDFoxQf7+edKC9U28VFunPzDL+x8kaGuumGRDAoHAQssWKWvkMDLkhdTyWxMvf2MuIknLMcl9mFMa7/SZdfoTujsHvlw8VkIe1+52vfkoToAS0plndabtgLItSiEVLU3tU+69YJIARBQh8QbUO1Wa8SI3RIkAt42vsfOFh38GlbDkjL6K3TBoPCiNZtbJrrj4IqEYrQnP/HZkMhDcvUOBELLh5tL58F3IwX3+aZ6fbKpmZqsVyrB602NBNSqfNXkikXJ5EEDlfAvsOr8ujhDYiAmy0TVC0wxGdA/rHMWgURob9ZxH3CuUSrc0fr/1mkMfVCE+H/WaeDFfo5al7KckNbwHHXlME+4Plfp9dSS9Xp7vM9iCiA3iqvWD8QEcnyBbTFG4xDEDSc7uRumHkBpAlIFgJxJEuX4LgFfjoRP6k8u76Zrm05BPfGVNjCNjpnaCfbekhomKLiqHjqcHEa+W2bVfaC76sMvP+GA4hsPJpMOslIRdg+LN8GxMGVtJGZMkblTtAgGtc6OKh0CA4Zew8CHYuCt/gQKxD4s4+mqBTJgQBP0EICwTH6a13xKO3I6nr5IEKok3xqpxSDc/lV5KBE4eFPz2PSCBOO6SQGHTZGjq97QpV2T/9s2kCOpIBatJXdGqwf5DxExNhi+GupKfucmEoEgRqoZArL/cewWU7WVlqxS95hNMTdlfzhwnS8rvXtojMxMN054i/UPfnJcip3S7ogm83HCo8eATlq2DehUUZJN0aIV0CUQNuopBtW6toeRuz4GlTc1RWJ7cfNzll4IHXfx1Rz/HFuTGMs2jKn5aPMBux3GiR+ji4jCJj7/PxWmJ1List+ieE7dxhJkJXjeoRiSpooZUuwqo2OKAMAthkYUKSuc5dJxe+kDGnLJtFhJasOHuYw8NbEJxMQPkW4JVpmc8zIxqN25OCJY52I46dADjXL35bDYYbHS3FKqkI606lSc/I6MSJi7dlbdzEmm4ep79Mj42JZ0cfzaoUxoZwwsjGrIK5M7yfVx8+1Eu9DaHsoMBx46Zu95yD7hNkH1owLeC8uBe90YbKbxgcj7LEyCPoqELceMwa1K5SbUK6AXqLYOvAs+78rKCCgmWimRRr7SSeAbavsa1GZbRa8VnIRUmslGqVINu1z4CAjYgbLyODcEPdMYCDYN9gYGq7tOD4Etvrm7MH2x/INEG6nLYfO7jG/m5vRoCnq3jG/wnG9EIsBW2vbsLYUDuIDiS4W3maOlq828ibmzkrVUqqZrjvcvihdQnfp04GV9JbtTIIXNhMNVad53oi3wxse/BCYU+tLEH6fChgoH9KCeCohQ8VvV4++PbJUyrB80ZDMn2NXgSLnDAXB/GqSz/88+h9D0w3OKhVAc/2+QwIMKED2PLTfaLwIFNn+UND7QHbT1KcpQT1HpiGSbLcXX+I4m1SupQOK+dAFfIjtmBY/rkAwb3aWqLYiWosR3MDyngqqpUvJOK4lLBCxje87VKi+5s7x713qhE9NxUR40pFGIfl4FcLqQg6DeuZuC/Bv66pgq4x8j/NBWFlGf1ZuYsma14YqwfhXkFHYhgCg91w0dlAa2iZkvsmqEzeNm1JbiuRCYzlyn6+8dMaaNk3FSK9yqvPNscAJbdJuKDDKkhPNCRVx7vKB/RkEXRtf/MmRXbg+5XtHgcjHl1t/m8qDW/U6Y8ELgI9JTxKLikPhsNxtsA63Nh1JgwBqUyAEEQ9eyWSsoJtjcVszAXcGcy32K9fJU+dxq2RHemi/G78HFHuFxZWdNWLCXbflp1aRmhKWskPKZ3CeDqpYXlz9CWmAc6v6teIsv82AyMwkQG98aVrv3XOgN0byMgZ/uC4BeNImcurVSpKKMOI+H5mG+l0tQPSlyOoS5B7OrG154+XvEEV/38+P7lSBhKQRo28UHxe9WSKzI5hrCfcu4GT+4meUwjRB0R8eAQVduKSM6TUfbjva+0Q3ovSvFgNfjv2B+3UlKH2R3i3OQT3KRT1WcyP/kzBgpu3fQKCh1UXy7csrSzJzh7/UmRU8YVBlGMkANaNsco011DWddl3CqCxnD9k154AQ5svBDUB1ia6X/Qpd+KW3Pt3N19CBYkUOZ05e8yvn4Zkkubx0BSkUAGh9ZNyWqLWytbmZVMb8IjG0evVSY5/ZTymrqjAYe+31WxHgIlFsO1T4pU/M+Y5iodF65fGQAlU14Op0fQdu0MtF9QdqZXTeQ50kaqa30Mk34TOL9ttKRLpMopeYBS5lUvOz8m90pm6JhhYLHdW2drSqpaa7sSodziSZnQwqML5IDXQZr+uHvzL5lqO+Ha73G1bALpMlncB53wgOnXiA9H1+sQwsXEa6n2sJq8PRWy7aoJxoFvw5lxD//DowbaG7MROVilWD4dYHQt2fZd+1qy2lfATVTVhTRsVbKIk6TTVvp27/dnovoo16wa0EJuvDNzeRBJkuabbOgwXsXEiQpxyrLrw0pVEnc/JLH0xH9xF7tMGlo51ut3AqhgMGamSE67v+ih+QwojTZ89rMLwaSgubvGUxvYMAARTZI7OmjEQX1N9Dio9AchYnkFgVpAOl1B1A7KSBPEU7PTTtzUks6WkHzEe4HdXmo0NV84ta5ViTpFz+2jS8caNMhvFKd0tUxQz5QPzbrh7a7XLu5UE8ci+Gkc+q5FMjejntAAwpxZSnQ+jFe3EMdy6ZorZCrll5hH5AivFXyN9Rte4l+kQJPgAeaHyeHU8q2f6HW4xMocN8R/rTb99oJhVS2GLcx5/xNC26FVdPTXw65UVr2Yq2fN5MdX608W2/sVM73Pbwdk/d9uVAdlviVxdmtFiCvS/k+PgwGFMqDB3TF07NV9pEpb0+Vh/D5iyVoEHiwyKXG+MLqw5bcrAB7XcZ+eNmw2J0jDf7RmXddL/WjYw9hURsz+ofFvzec8UOU1XxlgtW7T62v/aHqe/YDyYBmChiG6p53SQHw6eNHi8p4itMhDXQTEkKPnpM2Q91DgiVeccEVZjU8gxoj+2JtTNaoI2921QJx3nVEeZ5WqpZlHyrFS+gvCyNcxjjU4efbxVy7EHj6boSupsRfuY93SxItPn/d3JRq8oztn3nQ+LX2f4F5KTTugGDeMRDzMB4xfMzzf24xqBffKmsvO6sP/925yG7Nw9OslZhMFi/quMMEFnxxvWZGFyrLMGyXm9eFBKykRgUJDE3a5K27lfy+mucyjrkapBj3hBify8sRhPOnaGkQ7aVPAeLxU4B/B1rWQwzQDExrANSotdMFFg3IDabNPYvFRnDBfT9tBz88y1uiWt6C5HyrsciOOl3DLy/EdCQr/79Mh5zIKjyvV7R4lKONwzJ/3RLlJZuSDHNcREtPBYZjTG329wHRnBv2aPIMTkYrmwTFtBNWDYoQfZ22rEM4oM9I/cr8d9096+UWRGgUYoFD2/PJ4gwmgKvZsVOpr0Hwa+Ee+q5FF4VN8H5PTyZuTT0tTGALxv33ZOZYDvtA7pRMb8K6ParZ07ghCXC95KgyIU7aEvARJl/KVVpxByvryS0V16TSxHPnSL02dJ6rVlmndzVN9xWRC0P0numKkUpimhmP/AYz5D64iW0sT9gZm0He3jJ2GbkjKKk7DZkKaH4zeySF08GF5ZCYhf3vzeZ19UmPcCL05Ck6+0SQeOr/JiSyRPscTCqjGyUJINmVHJnVtquhgE3ehg+j/jCvuyxtZUjOR2QftPmPpBm+luJe3snQSp9w+K0JcoVw6aGXlI97jVzD6RNcyUs2vOtrlgFf6GEFYT8WqXbD9//r4C44qOJsykqCjVUqGxwvP+KjuMSA1Sg0UEtNMzEi4I13PYkH6PRUiB2YhPMZtvRehDYc9ERSc8E6Fnhbz0EFSaAw73IJcuiq1G6sAjhgMwAhku2U3szLWYPEAppMU7yr3xVkk4G3vvI+iiOpNRFrPhJu0kT2OMmrdn7+XhHBfd1CBL+YegX6aN4EJYhdgfjty8m7v+SlvaSEtWZ6IsWMLIeZP4JXyuqmhPQPqOcZdsiybwOcyx3M7MXfTiKiSPTScxrIwHl+pyzhojomJB23/MaNJdMmoDzKjUX2BXb6sIAYFv3rQf+qrAy4d3gZqn906+z28oGCGImKhym/RJy5acxS8eD62kZD+n4lf+uHQjcIiyjfLIJgJCyKusVkwPtzpv5Tevoo8MN0i96Ewayp3vV5VWo/90drroSCnK5GoNH2dhRsIbTJiSX54IbcE1eX+c8T4bbsmp8in3WvD8s04ggc8OQsZ+sYHGCIZcisoZsyQxkxaIBm3Hm7Kq2ZK0F8aWUmeJRNTR1PWq593aeVbSYSVo19pX+7MDc3u5SVe1lcv8LTsoMJ9BlgnpaplP1HdLwV+v5IGQqvBVDm4/ZNW6ru9T1XZ7ihJNVZeefyZUMROut8aW613E11N28aMixlKCgGNNXdiPTiOBZMmHygqRehm+QsvJyh5zgkhRJA+mKrmKq+PzJvzhKV5bKa6WGLv+V/0v1LaMOnaYfek5CCyejT88WENxEU5pf0DGFNtDZf78zQyg1H/Gf1NDfI7MlTyPl3PyuwqYsz/EIfwom8EFpxrHQJwHyE95u64+GiLe0owLUNl07BUNIjsEihAER6Km+gl1CARlTUrJ7v99eIeUK8v+RTZoMgeyNHnLcAV9UOQJ2I5STlzT+PlTP5TvBAQNc8L2CK/NFnrb7RCrCCLka6X/Ts0K74qZoK+cBK/KErOm/8SZK1irjTc68+wWdgJvoYfHwK9CaY00uPDJaBqaPewqU3WnigvkTg9K2rt+4jSPSOUcJtXOurPEf5maUr137D7uO3nadQBzOCppNaWL85WfDx37h/SZ12WYxEVeyznPKvwainEkn1CE7C8M4M7YEu288FXhp8/tIbFWi6Ye99TWRHce5Rf/BGXel2r25db+QYyUVoQ2pxqy4LojeMIFlPZt/HKSEhkAKi+CNSrqf3S9KSHHBy4ay88omJ2JpDECQ0wkvT/6TWVPNuoHzgIqqxCS+ONOTr2hFhrtJln6WO+pJ8Kil7DK6HGBrL8vWnXhYP+iTfnafoah3ipz3yruEwCLr4M40KIzSPI1DkXnRANKD9ExB37N++eL3oe0oyc1SEhUYy51MO5xFeVnP/wN3wJnDgCJ573Wn0tCTK/lnaFJnu/NAzsEUJGI9HjSgqFApoQY16UPTev/tVdeXGlcg6dzPbkpiSHFpAXcmoJfJiXPwQHI1qDJYHJX7FvJR8Ehl2IGmGL354giGMvAgIBEN3v6qFTVZYREd6DXqAYHWdpuipJWoYXDLk9ZsP+m90Xkg2Cc6g1wYBXmEq42UaSCuTKnvl3dlXRuzTKztZm5xMtH/Z/L70inbkYoRfGpn6tGwFR3iTjdmW8fCtOukcdeQuQl2ZJ01pbJUao727nB3wI17X0waO/f1/Pv0uq/RjLujOWWIEBFprLaeNzOdmd1WRqtuGmOFNatt/hS8mRz7nbSNWER2SVHBj3G5TAEQiHNSVYzZP6CNrBb3k5LUMAlrt4cefoABeBtr/W73zy1I0VbiGp7V3C0lL7an7+3/N5o+dOoGaIl9pXGOotW0hrwzCMkfhtSf4mLzro7rxUrnBcsPC7SvtuFW63q3lYcsrPlVh/CN37LLSjn3hboDj+1yzZiDiMvueWCIgNNKAgbH0Q2TwpU6A707jVoVo2dlEWIhFRZ3QPF3CZJvLeGw6IOqkVxvXZlh/MjYScDdX5F8Vrg9l8ldioMPn5dKm5xrnVKT2aGXQiAmMF/XRnctOPj4Uz4fcSXnGh43PZ3S6wvsqMHRuF3hnznFjYKtbGpUVYIiVnxXWCKc6veDDV0SeZRQwh0rOIUala7sNRsqMbRqSAu4MNAYkuBIRyG6kFNXRsD7I7cnZYq8QyiKH7VpJUrB0hTn+L91Iv+MJEmP/rTHIaYeqz3MCcz0KvgBGnYTHN5JGpEknsNWEsszJOoEft3D40D1tNc2Pu/XU1BlIaW01U5TcX4NjcJhm5zdhiW4SRnoxiyzQTOlFfTX7u2Ld4ZNyCh1bpQtz47QCidbu19g3NyX4jAsP+/ru8XR34tJTjq3PDiro6l++vrCtkvJsIiBzbwvkaTG8h85riGdaGK6/7pJzzi2B/xDMTAUPXFJJ58QU8VKlchNwY4pkgpolNHhOCccFhEzRb9qwOC/j4UhoBOE56HqYtTPYEY9msD7C4BWLmV8ACbrxwmPRiiOiqI1Hr19iRJOVcea5atoTG/9Nq14Rzx25CvPJfWvG17gExiLM3vwej6k+eoi8JWJXEn/NcilGEQYs2RcOPHORgcHZF/lmKiKijK+oC7Cod4JuhV68BANb7OPPofRUHvCT1ioN167fXSpVM20lBhrWl2UwA0OEDTFf3G0trF2XFC928P/NNtyNvGaOup/vjWl03+NP1Fd8tm9wvypPvbBGR4t+i8mD9vkXVgt6010Qt/BmMg6TOmPeQB5NI7WzvhC5RHYYr0m/FrkTrANyx4xO/erk1MI9wK2ENkI+stDF36mcQNE41gKJhqEQ9LfVpnp9wnTBn58pW0ET7Gzyd/PYVzRzqvx6AjVGaJWtXfLrjXmjkpcSmsgFK/im4dd/k5pVKfIWw/93pYWvJO4saC61EcaQ8ypyvt3ygpucNLJrDXLFqFqMQf5fn7a74976zhJMCQ+9p7yHO3uuU9Au5gqaUxsdpqGQUmFLbQrNyyprm6uQ17gK3a0Kj/5DYzsBGH16o5Bpazu/DIr8VMNL8KLMcX2OvT/MBHjcKbBDrBS1cOOGIVnET5eFMl9OO0Z94I2BbACi68eMu02GDHhq0/3pC/tf/6HxYh0ne3/cKtRjlARG9YwhLibPsiRIDvcU4HbI0LP6E4YqX+yMc6OJfD4zDqpLH5dKdH78vDHpKaH6+4xbQnpO752991NTrgSDNKyiB3T82azClw2pS4SS15EfnOi0WL/b0JE9qkEWsXeoVxOAR2Wn21igxRQ0UIYsavNmHAO4nQc31gbFpyVq1oh2djabMPN7aUA7ZnpF/sCU8p5A6FnKJztRe5MyL4VOfwhM0tEBerbdvwTDDuFRj3ziET45CXBrhOZDyj89fXakcoudpn7If1uIzspoIj2iVWHH9m3QdfyCET9YY83eaIKqbc18zAa+gv1BTFW6PagYKzeZqK9bPkJ+XdoCK72LOp4afJFtjljYXDhTQ/HsThdj6Z2AnOzwodKh+J91b/SgWsFbdGe9hRC8/VpBhz1qMKMhqtUhKDx+RHJiPUJdwuWKgI0JrgO8sUiVmnsgL9cJUW0m6fVUWtEJcZfeYg+gCw2i986ZP0S9k5uGhFcZVHt7n3/SdjUuOVF2FUDzh+/tJIw2il68KGzKN/c1gLBBEPQ6GrrvItURXRIyiLMrZN9mPUIGZZRX+hADeAsrHq/NkaTZSt131zk+6IL8ZaIUwyLAa1detA1k37zjN/O5JOVBw71CFRuDxKsjMRARFvrcvOc+Xk1katyHx4kAxpXkFChUqlLJH4iJKTNILkC20a3g/yo/B6okkQwC1FI0FUZyvvTEo2p62JcZo7O3p508wRdQA+xGZFQpRmK3lVy1AqVv0MRQDctjYHTMBKUwMUybFipZTV0afL0JbT/WlINBHswSl9F2Z78kIcGx/EAxfaqZBE4s73U3QUx/cApdK+ckfeMd0RYddvRQkSEjkqnaMiZvB63hSrqAYVhYSgCejbnkb7wrfPkazBKm4/4h1CYJ6rrXfGLZvIa8hZI2Fbz4Usn4jDsDoEpvzKpEBTn2Nq0MzrFqdSgTtk+rKXTbj8tDtbrEIrcZ5NNLUSgwgqRdumZuajZZ7N0SCNXDgg6IPbTIwDhWXe8F0bk/sqkMkgD+1ujKpqR6lpSqYgSbR1qUtNdjB3qEZEr1rkfD5inEx8RFnv38X1ed67v5G+3R/Rxo4syjKRlLd/WpUI1hLqkh+V4e3b/GBmhhz/sVM1Bug4fHEgXY3LzIjgSIRweb7oMDG85kd0nXUUTl/QKNDWhAuDN0rWrPWeszKITtL6wysMBD4ISy4UFMMeTZs7RTwoZBLuoRgc6Mp725oKkG51sVVfjxlXFrxv7lQTeyAve11N5xSGpxtvkIWLPWZr3XyQig/GbSpiALmOBQFaX1h/qIXglvbDKwfH3JJnUI2Y44uz+2OidhIvSJDvZV+bONe065LYFrM/9eBPPCiwBrdA9YuGaUOXZgy8ivm4wKfjaGUIwnTCPqzx3RjBrD8O2jK1iQK0bA0JnZKEf4WsZpEchtnNpUVADqwH0XPj8axta3dlYyPS/ozCsWoUmlpa+cnlS5v+O5DImJVhivCgqWJQAIXFCXMeecFVR1c0bq8bAvZfmrEblMX/zX/68zDKQHJ6J515gTY8W0d2hiGytQXG8dzsXDyYxg7S1OQz+TJuF+sNrcvt5p95BjF9gIF53FF0ZveGeDWa5ZFeKMaH/m7BXT1Z+IZWX55gSfACV+nnO1ikhxVMYNi9A6d2YLo9v0bIwGBplupeXFchuxj+OMhUHm6FbZtnQzE+/LSJ2G1ycgn45Ih15eLETI+qs2qOo0ykA/PonLP00P05tfe+4ajv3uydPBhdu9o+16FMSyl4I2kH2IAdZfQA9ojxGXhrzNFuCugdNgFevNB0ck1qzYPLvZsYlllUCPP3tBp6UzBg2bhDU9i05jLLdWHGsIjq+supcDHjpTSe9mAlNiMFLSyNqtVe9XCJErZ088k4C1qsLU9Dh2TG7q/sSIJ7qClkhHOSNMiOeMTxlXwikH/1ZIwF7IXhbnYCCOVL9Q95xc+DEuLGpNTMW4Bmna1bPf8Z9kVNuLAj/ewQ1AUyAYS4g3KKIkU0kCLH8hRp+bo21Mfk7uubtzLecRXfdKgkBbpN9WKF2X5vO3IYGnyREHEqp6JbX2GZ3kbqetTuWHpCk2h1D8EzAp3/E3Zrt5UNhmizpcVAQ2wycrnc4vJEMS9vr+tK1lQCloUiSziIxZc3A4w/MWL25B/pX2i94bOaOkGaaNCrj9r/xY18N7rqp2/IsLPwTaXYoxFqGxW0GcX1fOehlVgr9uVL/jLLByCk21eiMDgRNJRd6sdL/Psr8RIYbvVhO/HpeNjVut+D2u6hZSL5uLKwjSAquXwzZJry0g522jDbe2A5jND8LpYX1d484Ij5D5RSsfZUSCnn1A65PPmTD74TnbJ+VndI0AoCJsuXn6VgvUhUvVr6BO29tGxRHV4ZhgB7P5p607fuWD06WT/ClRNsHD8Th/Q/HyvTfBEjGsDtNzSKEeQhRS8xs0yIBIydx8O364ms7DYc/VeTkBR1nQdxDnZs5kNr0OlhUCxgj3C0HMRDX/gocpxb/FQ7G9VQ+zhYrNSNHp4Dk+eaS6AQ0SiWAgPgo3ia8Uoy4kcaOxI4Bqww3TtMoZYkpuB/JVrTxBbny5TuxMkta5r4Kqhylhkuxc+jYwAvQa7XUdXQ3CEvLQOJAIxDhmM1VEBwCGEUvqLxn5OIayi7NY1/Wgcvj3ZCmXE1iXBj3US3ol2xGqlXqJl7ZMGbhEUgAMmb320zNLHYphNW/ub/1H5Gj77G+ApnJysJkq0IZwvT+xCq+ITlr4aIPmkACMfNcveM60agP67KBQqzJ9h5QjakoOPJfxlDQzqJAFENQmvjzWiTHRRMP5RT/q6LXPxFxKb0hnDggG3vDndagzDk2Y+LFE8sRo2QyeuiA4/Qj12MpLbCBR4tJnqutF7VLhLvKn6Qb67kMTER81fcgFGcw/dXx4G6aqTW7Dl54uND5RRRNZNcU6Pwpa7YWR8crhlMrLW+iVC4KJlDMAMD+WILbGrizvVkPbOnle6Q91yr1HsDytTv0cPEvS7okr4NlXd6YgjQo3bsb86Gl2b+vwzhwUwKA0dafJ6GbrMeULEzgeYhK6HewFPaGX3lBzdOvYzQU8b9bdevJ7Pr3lXMPegTxUZv4UE4q1A1/AQ4coboixOP1+hOXewA2n6pTrhpgjyUMAPDDDBENklghopSYj0jFDsXPCx7/jeCn8GhnW76BBL0waLYBr4rXrPVKnW6/qYULyxFmGgJfyAV+6GN4NKnnXUVbOdOFHEWEwiSN32NzoBtVzyIs/gBSMv2vTEuvoBA/t/QGwEFJAH6mF0zzJYyKjRgUEzAo2SBjhvieLhewS4JVH1JIcPABt3WqsIEwKyLsmhehVMeLLaP21Ulw29vJqF3BEBQgW1y6+Zgv7xHCVA7vbvSDOpPzvR8TCcW3zTuwgxkSmYNbM3ZTVjDz2l29EURn7lwtvwJPNruLQXY0xTTxtKMYuhR0EM4wewip3fWR9v4jxavtDylbrf0FXCsCPGMFGTEQyTPl+PRVkVZbc1fBAxBNVgau/VtHsFeCXyPmsiX9tSRXbaXR8X1TQOamlOdKInR9gOOUUlSZIkfk+k5Mr/RNKgki1fk+bYgCCnLI2MjtKwIr+JlRpYSdMU2/R6ENb01tfBSblFUB2C0ZWGZJx6u9IDxWCFnR/9Zvwvqd6pxfjgLMSHQh4q9Z6/qciK0/eFObbXzreXi+TiqjK456xyEVWiWsGrjjy99zBn8wNeDfWTM/uGyCtk1h+15VtAfEo39g0Skx7BNwP2Qh7VB+lpaN2QWKZ66z+Y32DwB5eKoaA9LbTu9ecbeKaepQ/ZChZH1Hlu+G27LJuKcQ6pLUoQB6fAq3sBATOu3eF3NG9ODiJDFmYoXUqRwjaLaDIkeWiLbCF6hW9DPk4UPLX3tZM95U2zvigKcD1mLeOzP7VislpFj3uetk8M7zYMNCQL8ryuLiMVHhueQ5+eZBWBAlNuBFwWT/RcW95e2rImU0mG8sescjefH2U/kiscKsjFmnmKRZroL8ynlHLIcGPKAGC5o59X5AMHwyPQ7vC8KeO0Ap2Vqm86DhlUSROnwmMaKImfC3+4wPg5fmZ38XrVy/Ldh0sJDveObw81vmg2ke6zJfUCQh4qHdtAIcijxhkSr4ldD6IVkoWqCiQrMPu9seAJIAqZq2ZqBsfpn3HE3mRGYyFknMErpyu8nnvVSsn8NNqmaSDwGYwzhRBdaNxJUoJVi9k9IjOUN9DuRLqUnLdP+ZmmR0v52k8b4wGokKShlHlv1WJQoCTuiVz9fFFUteGlTj5Vn8BpsVQwNq4P0OfjmXTkbxalVuh4OeNNRvkBqBbdDh2bygQjI+hyxZPRJm2+jBiFTi5vdcZcwWTPpklolVwvFzJvDlCd6iEXzE1LO70eNc1XiTUim3W1chiyDtPlRECX+AfywG5df+TjVW3cOAbrlAx+mIbj/huMn8EQ/f0b9dJg7D6WQF7Zoe1il5zK2LnxMMi7kpjppKvePQG9NLRVTXVCYF0T38DL/USUxbPQIddcxRh9bmJa2vbT0+uFSU03n7P4Av4WUUM1ZF9Ep0dfhBECrd8cg0XDI0RefGXi4tcMqBpYLvG46i5RP02PYQ/YXKes/JMiaZFwE+77byuk2uTj+E+vaHGlA+5l90VvvOJueS7c44YLCmd3qv+vsJuks87qpkQvy0FMLX2C/JtBZPn5qTiiE2+DbXGtK++icLt+VUzvKq7IpEGDMFatriZO935tt/wNyGUWIeWwiryi+gFmdSsC2TjUo6LrOdNfRct2q+xHl5kCJBR/YC7CDkwkSdJKG5txD+iINzAIwDYpVkZdOqGJlv1VHyaj3HqQv0VKRr2md4/5yaPYYWR+oLlji/cjt3ifMDDv+VY3Kst66X79nXSZR7MS6ZERB9FAkLoxTBX2q5hbcR8ZeXCRa0Wb9klArvBmEknfc8vIyhCGW08x4a16eOCYB7k6hcsHWMs7kaog3KB+NAcOKMtT9bsmtU9BHauNDwtPdNnQyftbt1cGKTFvoOUSLsjahW75N0W2N7p5QLAY0F3chxSxbmA2Yi3SmsONuZa+pXJHkYIocumGxf1dGzcAp1g5f6qheiZxPt5GA9wEAAlvD36ZLzPCcwRZdoo6OrF1bcxq4YrtfKh7t4EDdQhzuytxqDZtrL0mMXsR85cIxdpx57myRHIbnGJfDlFZqfjUGXLbkhKn7N4w3+Vr7dpy/BHWrLKLehtuC2UCCQ4+GOmHD6mJjpKigyS5ZPlKpUz65poTy/JL6RuPPKfNCpAqbf4rEM2YTR/L8/2BZFTNvr0umKwZLP5oYoySOCTNuXKmmk78rPZYaiJNORwbMAoffa2c9q9AEHweaGqQuV3o0+MrGYqoGvWQaB5NHJhS2xmb7QctMesfeeJdl8j7HSrrG0zChlZARRrY8aBVpk3vSO6p+imKCa/6kxr29c9jqaOIrjp0UNXXUz6GELIvfSwLIGYwiFGUGy3tnbwm9oD6V7hNtqeRUdq6AGNCa1YtFcljxFlRPmwf9BVLeHTJviFEEdeD23+8GcD9RlnbcZR+aJ8IgsMLn54hfLAiAGnMGVzZwFB6HlZrBNCm8cMUlxt66edXDLzcV7l10XLGTSjImylMucTwdOv+HPNmOumvIuVsbjcJifNkdrbrQ14JKTzLDg8zZlNel+v2t4G2M77kuvkI79vuU6t2GQVlImhWnfxkmgl/32UOuMYQbeLcNmbwqnD8y9T1h830QuGr/hHbJtbIJHhP9jNVK89Mq5UtgdQzpc5Z4mi0PHA1bN5kHkgDmngOnSXRyNdPSu8P+OitdLStgElMxCY5pr+0Nx+P9rRp9ehTgeSKO4AN084gqe+J1V2B6tCFK0IMgEP8rU18i6kcjv6SDBd3hTBmJPXyv4ZKA/PML/9tJtTA3m5CyLdccyk0Eoht1ovF1L+6IMirg4+5nz/vRvCIgh3dDQt1Iua5CSoM0Cs7idMztuxmicAI5rOKfEBIqtTyPNbarat2ZgpVp+icpQlS+bplkRhF1oYDCv5jPK7dN9s5lWa2qpG9h5micEWJK4IB47pJhgDF/CrgRP85yZ5HnlNs9RNcLZqS1o0uZ3w+tHdeLOy9QpwrCxFpS/PBQKxlpqw+3eJIk9Ce9+49me83aIlIQkOvp24rzrWCQKLci9heBVQBsDeJsYIGmjlf0wHMkDXtb8gM3oBeBZPIDKCIjfgyCJcjU4qxeUhdL6m6+1XocGM1hiz0rgUUCWfB1ACmvzxKFNVP3V72eSRDp4L+1QA/hAdiV4nlFAjqFRN7m/LkUDdQBxPRWI0vbtYC6tamnPPUDGK2eiU4ie7tjQ92RQEjgOUs3mgz/E1PdPugj22sG0sMI7/8sRyBpAPWJC63wCyd4eXALLo5TA8qImfKyiuh2atu1hqGAJUuHYorXqZ6Vph2onXhR6Az6OU7W6paoWtc4dJYwkUskBfSXvKSS39piNx5Zo5rsU7vkozIN1KopcOuPEp9dcWhZhVtkT12PqQMooymNikJmzg3FmY7z0pkg8stwwVLtQUWG54zCGShdgsKLAC8RYFkYahxWXZ4pIIdZkXBoT3SMAmpyWecjjEc+NLeuR+mg9qNP8rMkmfTwfN51ISzLK3uA+5JrtyfWldWd79UAzRCBa5uzdlguHm7OUyrmJAJOQG9EevoglHuvO6jx67lQR9EmFvE3abWsMYWEt9D/XSjP7hnsQxaUREkh8BJwtrc7yUk0tfbkqoUvmi37Kb1nv9hWSpDrhcOtJ9A4ExU9MAI85GVJNfHwh/DRHPhcOCY6XScD4eUhnQFJstnKrNJ3s5tb2gTHzqz5LPuV4/pZSXZAwumOoHerx4t0FrpbRJpraDr9Sq2mC6hxkqtE/522S6gan/9nbGk7nJM3/vh++1+plLcHqjN9px2uqSQSsVCVO9Kq2KBZbzxJpjIAPggYNFuVgD9axQZP1riXVQr+kwzPLu/UymSpx+tjINnvIHWyku5vVPdlN9aFvlOljme+rbs0tNjXy09EYNbBfbOEG0hiFtEE11odhvSK8zxmdXOuSXCaZYgy14rkJuud0H61orSMBrMvxOvMJUMf1OT4cuY1q+GfmPKASkRNjenPfcOffNubWlDhO6VtXZvKCUEc5hRiiYwFxxFR/DDiy9V6kaooGLbp/0W73+C3ngD51dwKCDJTXohwmjCkEQECU+nGth2HCVoMqF2kHq7BSVWCc4HRYFWRVhA2fGyn9XoXi3gEHzU3Nrn3eeUDZLwoAzzcha4tmfa7iU1VN1JTt4gM0VLGyWpr9slgGrJHw8au8qWO6o9zxidCGLpxlU1jMbXfEGtRdnwsV8Bsh0arFsMqTIS+zUpPdgXOmXxWy243vDTUIkBlzQjwswQ0UNkbL1QtRBWx7IaIAzcdlUYCFizgYc+DL5lJueprvd7IVyNzbskymf5kGfN3XNLqDOAhlsS6M2sSEf15bRAcPtwh84uUOpjzMW30c2569sHX031WU78qhXwDjuBDEdZxkmIk23a1ysXibmYD0AHr+Gf2wNPtzmkQy/iBLtOQYSUFxlTgXUi/DglMay6YLgz046Lo5LBs6uYS2a7IefTUuPkFFXNLVZXCJra5bDN3O7Z9jPnH+SNp0o3ub81OUBE9N4J76dCgvl4CJRta4wZgitPRy0l2l+Towg/sVtY4duZvF1zeNPo8K64qog2mVrxcFtVZb8Kp+5ly+VUdcjBUQ60xWzUi3GTqVSn/+mv1X6q+VIwpFyDmitbNHwZGZDmCcEgPDmjDByWEvmESnt0eZpF3Ur/eZjsvKUe9cssFhoBFSGC1hHwflQ7sPFzMmh5RQAgIf2QwWHVj/DQMIOoI93ierMSrsaJgJ9MVAnlB0C7CSYJbofFAHn7pyG878DkIABuG+PqL2aq8Cxbhsui18pqduXjfNcX6KHKwvFkiu0LXQ1U/FBTmp4ojOwUrmPDdiVUSBG1MNZ2CJBp1usAtY7FeBmtwDGthXK3n+RAEYaC2HScOlHCzbUW04cr36HMyEk/m9Yq8WNGG+/f1ms+cPJM7y+Sg7UiNO+ZPeZLlcKdig/rQXTPDrmGFrWrYPltSVQRMkbIf2JT9mqKzzO0kLwJlJ+zdfLnKox7+eqpkgW685nT3NV//2pk+ixbIJrcdLlFSubkb0t1aaXcvjJ9r+lqvsubPtmHFavNDxLKRHXj9Nc7cWnsrM9LprejZIrcaEB1fzepE2qj9j1fkQNwSOgO2HrLdz4KkeV4OBtQuvMnYL+OzZeUxxTs7XQu3dv8gcC/VuG6WNJf5r4nuHIs07cxpBWidCKoF4ZmDWJFNdRXqwAhSf/zN3MKKXf0mAAue9A+HusuLOey07fjqncw2giVipSekVRurvKjN+oyphR2/QN53b4ev5EecwXn1xmG6WipLeM2nz9pbOpeGmheRZ550R+cUmfQefboRMtkJZppPhFIKBpIosHIAe8zwVYwboT+hY6uRFIl59lZFJ8Y0QxdnCW8+zy4uFj7xxR/A3AYrxTEQwYQ3XKsa9DJG3VZA5b22OWwqe5nxCz272Aud8aaYPrEsTcBUPdZDSM+p5nIweV7BjrxwrF6KFz4JcVTyrebf0RrRYsxUpf5eJLkm4uBMFWyUSoyCSQoCubh0kSzAQroASC0ZeaqigUlVeKZ94qFHgDmsZfgS0mDptJs+Xwu2mAfEMr1JC5oMkTqWGEistoe2Nqso4C9J4XAWcadPPB+BbHbqw7LyRWFQzkYPArJnxsUhEew5xWkFHh/nx5vWFtcQpXHf8/N+SzNCS8Bk+fORaYyUrNO1aqNkk9MWDjrpInFDrlFksMFpeJXGiWxDu+z0LuO0W4bPBjUxwLVCL8zNAmYbe8ZHGLC/NCEcdAYkilVSE3Pm1ncGXfP9bzu6H/vU5NqpejQTyFfmxLn8oyiQBaD+X3OX7WAJNkFzGrG56bGvFIQHK60QTvF7h5rSwFp8xRxNii2j/Z8DgEiHrtQTQB3AH8sMIdPhPn+OcyUBGcCJolhaDD0BJwQJvpB1jhgUeIxZ8lJ0B4obAt9cJveN1EzYsW+6htwXv67StJruyyU5bvlfrCVa9Nem0mJ2fTMnc5dP6ZHTmrifVw/4+pYngTC9OOpZXu+RPCmjFuOV9vNV6pq71Ufb0Az2bMGkjlBNi31wiacN9ppnMVy7RGoU05lIi3GLUVqRSfYAIQOaDrKnrs9D/OxHi/HfnK4WUdo7EA/UDrO8RizgmmF5K7bCbkIiAEXq945BOWmhBb61+uKnKr3lgdVIyPzUTRcidALe1Z+vN3JJK/3gkECiZkdrKY1O8mGGKww3ZTS4Xu3kD6Z75ioN9a+v2UCDNtRukuioxdL00NGF+RCHnMkXA5BABUIf428213RHDNAHGv9Ykzk0G5jmR29D5fNy36aDQGUSyixeHdQeHpKl4sO5YEBys97IfQ7LIe0ft/PSlVZI1c/GsPUhnf6TwlUhs+ZGm60NPdZZ03x6K/q+taDPcIipTmRcTN/7IUbLQ1c/LCk4K2nJRNN2Chxl0qMXQU4pXY3j4PIwMqmg1xALDsfth0kTn8b1gigKP6tXnlNWXXE9JmbC+7AHYMKkRXF+xwbfFyAAgLD/sYgDTkxjAbFmNndxZH6tfCHgna7EdVS2HidOZLR3fV4FKRHIq8jzagJHDf2pY9MLggsNiRZ4QykyaRLdjUl6QXmi0hk1sk+BNngzHGFaTZG9sKcEVuTWcB0d5dZPvrOWXQHAILQs10M/Z/LFONOaHto+MIHnrmzJ9k8SC7zh4crM22Mg6fCRqRP9HRq19iLq8H2nsxg0WlmIsHrr+tL6ouT3Mr/RmkWOX9ArzaGjyabH2J4sF3NRmrUWllEzRCcizL5VSLDujFssjZPPvOYoWvl+uSAFy/Ttkw0fwPT7Z4rFIp95gl99/CQJTQrgj1y3qxiVbQwTvI9Q1OK2XFqo6/LjWy6BdYK372m9Ub63bJ0HMyZ5RMBDYML1yzgY4eWVzASTRnBd7+YAwdqup7uZkDKccgcYUHttVgkvQuCujwJNPHMumb3Z3AS+mdXiAjV1u7FMkcLBqWSYWCW8g2p5mEiv3oQ/nT/wyJDOQidfMsA3+rit1OgCWH45DrhNve7kl+/gzqsCF8eUo5yvEaefeoai29xh4HqCok2fynPE9HS82Hat455QuHXEX/grY6BElncg/TtU1h6cXoHvQ6XB3EppP1xYax7Ca1tVo7Yl3sZd1f4KF0J/zya1CAr7B7RLBOr+er6Xtm9XTCGt64v/OQg5thq5sGKOB4R8boT8ZIoe+pLOjJmtpNRhuYrX1dn5uILZQtCeYG6W5Mz4OdJPlKRaHsgPCFzR+cAaHeoabvh3PHCHzUlCCtQenE8MgQ71KbaWs3dG+y6wv9EYaxHo+zL3kmpWRipvc43q6ye1LRpIkFfhs+8n+ETDlUHqZrIf1DZSu76V1OgYzsb4JpnQmwEUwSspYJnpmHEAeJGRDaXpHKQMLzKP2SoPTAPJVeebp+0kQEiM97dIoyVqueAUHlC29bTj2plD1Hx305h4PvTTdu2eJYzCM0OMyiZF6Dij8w4jPLMNlMJlf4ZQmivyInKnHkluVNJapFrW0a10E/NDfyIU5y9sjg/G9FDX5HqMC81RTrDYIRwSe6LiNSOe8/lZAAf281/bUKp5hFlhI28qyBPuwwQIsFS6zXLungLFPK8oM/K8YECkZn5cqyNvLNIgFyn+OnRbH6kKW/NU5aZqhbhGOs2WpnvN+y9ZaYMIHPI7yOC5rPfmdVmV5LkloBBmrMdgLHeBybpZwhOu8IkYitrpNpIGawPgTmwUHxqT4nK0XvuI28GpheUqGjF9MgBRRgoD+FkDR8Ip0/WRI5WvyxVfM66XaXSDkPCGMBP3Ikil5KSMx8OZRRWUWuuuJU5hZM8tIAAVWZazIcoMXULHMEngHg6KLPUjELGOsoc47kfe9T45Zu+VrIYw1++35D4gZSrJIzVyKcgWii0eJe4TN21hEqNSHFaLOLUpIjQqQ5U1H9QgdPG37mBv2t7+zamClODuRheGgN7HZimDZdu18UgFIcjNLuHqYoVXqaUiT+E/8gEzYv2RgudetUIU9xF316PWoiCawuDYl+67PoRW3P/4bNiw83arOBA5zMon1DDpp9EGfj2jzm9KdxvkxbVZeTdM6mfz5jjHXSIbBLgpg+RMXE9PQPEZcVmUv+lZN7zGafK1NRkNkGDoLci8cfPjRk9+umr3kEaMePeijvUaUBflKW7qMSPicpfGbr38tQGszAWOBW2EhycKo2Mb3GGU1lGW15ADlcG6XB3NCahbJQniU4jAjmKocyQ9eZpQASbK5NzyBVgydgvOpnUD8vizPvqZVDITDuaR8Rn01R03cbCQ8ewA6cEeK5lAVA8nEMVSWmWW0OL/MKYHCDFmc2pQKgpHWodbRyvo2h56YPHzAoywwLYmfGCtmUsNR4oAagn39AE0BfThcWb1FTtWeNpZdYaVPY4uOPp+QpWF3HsMItls/4aPRsYwAioDWQGrZbdkrJlVysXqWGnDYU76qZ12VH3MKHhiTL73J4pbiuUoeCPjhm7AxseidKsJOkePlJtc0lbrLAeamZLsnrFDfP6Ec9+XRgOC2EO4RRmBXRgD29gVHwUkmz/ReWSYQmstE/eDs7clAWbVRSWXSos48CipJKndc0dt+qyirMEP7uGXPYjh0cRZep9EdVHnquWo1vcI7CrpHGqZBZGVvEt92d/qY5g3i/MwqiP/8EOjT3zQ5/hcHuTgmx7IiKEVKtqr+tP1IFgVMWtMTpKGUNpDiJyVdttOoNl1bUaLVbgNVbMl1T8/YLZnDQhDLm7Jj1xMMqTLqEJem9JHoI5yEDZvZW38aoFO+NxFCN1kN/XVClQgPnqC8POZVEGLn0M5UG81fHiANfERH+rHL3+XNPItwWMzs8NZo3HIrMDsTO8NXDjcyX+5ukI2wZU0zvjnpo97AqLklEgWTfV6Eryz3XUcOFRFOA3G3Xt3UA6hpbFaXrisjmKGjoHO2PO0HJEJmM7c5uQkORmjKRg1g+9qqKgPzH5BHzaQESlp5106LDfaIo14fQqfqIPprxdqyH8RGzAda+/S6WfPhS6TFwc3RDSLwvP7f++UYNboWr7w9s0ruhY5k/l0HArRPszdL/pm0Ds0zbaCda8Cn22y9PZfINS58o+Uy8BiDc1e3jtBo8KsFdIhkidZGMYJPngLxp1Xf/xPIrJJ1OlOsve0Ja2DPag4bm576oB+QtDklSN1aom/gAgHJKnSENDC1mwIOozGAu3qSCxE4XWFxiE5gEAwE5ux0d8cwrBsf+ceQqczfrH/rOJ1/m6vsIjXemDFWFm3zdb5AVbMXu36Xf1FzzhfddZHB/rD+M4Dhc9jo9jYl7A3mM7YdCp1dJX7SzRzLQKCwwaKwesl8Efpx2Rptblqj1KqFjgFvBgQnI1DGFy2eEcjIvRIwC4brNdf5jF4+vwx2IAsxFikEAby8dliloewwh4Hh39fbhi2jpeSarSaYAF4K9C73IIiBquKfEde7ybz3vVHsmjnGr6SqvalDeY4JaF31wu6JPXJwnl1y4mV0p2XmCXJKvyyb0KKRwY3ZQp0ALoYm8HE68u9kCfgB/UG0DDWPUFCPtx/tImoKrZE/gJhaQDvy0dfk+QPR+ym+Wd+PSrbZF0HmgD0m+hC/kH4NIk0tS2pheIq9BpYbieax951nde2FjGHG4OzJpqn4qiHeQhnR06drykksyAybQ2cjJS06UGNXS/P8+2jGCR+u/QTEswZwDOXBmgVizDJsHp82FRxPdATcYTF8M5JhJYBeWQICNpPQlNoM0YLvUh/2l1VZ6lLAcFPBD+UvuWEcRIDt3yyOeosUpevROV1nlXLNSHufz0g5bIf6CeZAh278JaC/Wp5wEVAlzoWh27PzwBjF9dT/9fwtp8hxmP2tHVBJiJ5hOBAflpi1gYDHQge5M7PC1aRF1h3CNEO9nP6jevyQWleKxxrQms+VHds+l+lUT1YACvCbNp3KPfCFr21M6lO6Z3923PJImm4sqsphDdvhBv2iZ9R5aPDpndApilLcDwwl25in7md11SCT6qbng0Szlo8Ye4suzzZVM3GnUokN9wwSRuI5ma0S9s2QKkXtSX0XLkTJr/tvbyYwq9Q7mlc8c5eScm5gPUkyqDXP9a/qHCJGu4d9uCkI7ZFn3EdYgoUOIxtGkFXrX3lLQa1jcvk1eo7cIRGg384aUslDDRWBbn0i1DkxQFWsQjBUxS2pEbvfRD2xbAZwInhSGwOsmX8BOZq2laonU5+PvHi9jp/sK1Z5Dz2n691AcmRIFP8sM66lMnwl3pFf/SAsB5ky+Mmce8UuyoLvl6ibsNvaeDmbxEDW0Rw+Gczx75XkfLu5bkdLmOl87VlyyWbs+WMKKpTekusA+8jDBDSSV6GYkPRDrGwB83FUgqPLQeh5Pj48MtJ9s1GvGkl1Kn9QyoDPcx8oAZbeo6375Z7f+YS3vi+SMeGha+5T/uSEBp6f7HZHu9q7FXWKWx2Pby3MvLbjmX5cfqqgJoS8lBhxmf/7UZKo2gcaCWyPofze1ADn6hSLMUpHLRaTb0n87OwXGgE5ZId6QxpM/FFCJ53iClWbQBW2aTeoCkfmGguMXmHOH2BGdEDlTgo3MpAYoLV1MfGHHC/9JG/xOgFsSxeA54uBIJD9KSz6iZb6wDlF2OQuuKveinLwM97RV2aSvGbEKSt+5AHzWtzMHnIzb6OJOa/inKhqGMfeQKGaUWEIPbu80qiPs7669JYW056hlvwozU8dp5b7anq7Hmqwe7DFV9TjshMIhpJKdcISCrqPdEUI7oJF0tCuAq+1taIaLpZDNo/Y2GtwqxhaaGUKSWFzWsiJAMuJQYD84Tm++PARwjLA06PlXd81cVhpQ3SPisUa5JNqmKolulPA3DHtZUUlaXPJ0y2uoTVthWbkRZzKckGA1xhMEIM4Ztef5oY9VyV6ZEGP9S71qhjxt13vNFkKmq9arRTeBoooVX8Gx7gcF7gPSuSpmf88HFVXjZhiCq+itClFIaWWpopphKPqAcPBmZltQISsdvGpTO9pOEsZld1LGigvf4x+59FlUY42OPCdujWUMpbpVH5h/rVy6usQN2Xngap0masDXEpPjQmY6og9uXi0phkc9eumoJuAB+e1N7qUNpm3EV3HTDIKgPpsxQiXqgfJQqyU7kZ/ulDPj1ymEHBVPPLsiI8rYp1zXeBfShf+CH6W4rU1MOotlT9NJkce8L+uqHv68jXUmo/doZAlE0NGqnq5aQpcTvkuCw1fBV1dYLn+Tvo+QjSHlJLIWfmRmIO/S+/JC20laMkevWMIjsHp8l6N0sxJx4SUy04HCnVLDV7N2kA5OAigNecKKX1uNd9JECLZFQmpTidi833Lk0sqhJ2FPTsAGYzis/5xYd/XS9VifA+bKvH0LKrHpfXig338EvFRQ0MKSrl1LfaDs3xqyJOqFBBaTpoQpclXTU2ShBLMt6rCPcEQZfionJA72mg+iXcQS/GWSXWD2bifRPi7vCVpZuB9T7HacLHHNYBTpBe851c5oPHYR3CcBrBpiOOVj/9gGv+gIDGaI56fN4pRHmE2HZR+G+flh0HrR8vs2r/glaoMyzElPufQNsAj2C35Nw0NsP23oSeoCAZ8Hgd4Jn8ysR7UNnveOPrn5k5FwTIZrh6oymRF2KBIkO7AQg9HXSJ9OMehOCF3BQ0GI/O8Ee+T3ykGQYOJI4D7O1fbxdyNrhxc8rpKu8lqZ1MBdwvD39kjUT4oLQp8SdnnaoDHMGm7+PG4xEVraBIUtSALjM8ER+1rDDbE00vAeLMtWZm0ux+9dgpIWbnmNZq7A6qVBOuk+aNeWigmcVpFcFNTAApWptk9pWGDq2+sX0i7gZqbTWixIbmhCq3cb5vDD1oxhcLtrN/psMBe/QGxH7kkaNPix5CvVq/zgxSj2pWA8BdWUIPIH5zJiG4cZL+1A2ziFGrYjf+3WvE44Y7MasuZVzRIOpnCzrKhWNihmZWjTJU0k6dX+0ZWYes1clYnfawwC0+2iH31VI7kORc3QIF0Wv8OkbbUZ605drcNnfjQHMfsTEIojH9GLpMnHoph1sHXAmGy8LVl9yA7DuBU/4rnvoswxGPP97FhNej9FtOgLkjjKEy970g1JDo5q9QgIsQ7zs07OsDHBgZMb+iu9H81dlqaFQSKElPs60fvWWlV7bwMmr/jejwj6lmojE7E0jfeJSUHvAxgz/+dxEiO1SiL58NcEEwCXm140PVTAhG4UcHOgN8QWON/J4E/bqe2cjdHIbt7TQpzcdfaOEuQDnF92hDKKjPeoE9pbzPf1CdnXWGIk6Evqtg26l5v8PkheDxkEfFPyFsdHfpWXTjJvGQ2mqMNRCFYs4SBTP0cHVeZkoSExVVPvxU48/PVHRP1VzktfWOOyxsAeWeYv6cXMUxY4p+eQvgeGYgVQIh5PKSa8Sg52MTNUBKGG6dsKUxVNpUU2UUvAJKVHriSosXvd8CTg5qn1K5/zDp+AFkv+WLBBQqhJKPSEJJBGaRJYTiiyRLQ/K6phkmLFzXAYJLEGArMC5BHeYi9Fib6bvcwUYr/LUTwsFuioPQ6Mm7qfwXqkBnv0096dsHJPUOFibJvnRvTcEhV8Z6d2U/Dn9oAMATbPYdJJgG3cpz6xxGA9M1fWeyRQzbOqyVkYBe4E4etN2to256/tlJQaZ+74N+W/HmKkesPvvZaDkd6pO/7y929RBpnW4vcBlBtcBP29dDY6g9O3lLQFn50dZBInfW4DJ7+Pks3/GnlJoEJsnZAVJ300Vhuysx/Lz/rkXb1eoKt8vizFr/+9knUYHoqzUy4qiBUrhmes0I/gmYkM9BAJAx2BId0cIMdwp5QIRzT1gK+R1u6OV78EWjOksqpTWTWZ+Efwm9Kp0d76b6t9Xpfssz8/aCAXuJ1cMwm+D3Q3rRBmwHiwqJVZNyEI20mMaoZK1TFmmexfjTmRrvpuqALkOdpWgdt5TccJoi434YPI/R7NXP0Www2VcCcUGzqsqzhnMmLcwVRjxDQN1Txj3QftbmT1S6onX6owU+JhqoMKmHR7M+giIDB5VJk8QWOTsRl4+FVJZ1OQQ9hkQEttCZFQhDmP7ZLxHACjG2C++ZWzicU15Kipg0egkIqwhPJ1J9q+T1KbVNtyiQWT2oaL6/lckPOsbCC0rVqRA33WkH7WbN1fH/poUC7b9QoAJd/ltAVIgvADoRbFtBtL0GiCZfrRKyle5COGVPxLg33+Kn3OnU4QcRLb4+EFdgVSOQgtlvydTdVZSx9lF7TOY3Ofr6L9/GHMKw6Fzpk2JPbs/S92b9BUgNlRYFGgbtlTIIsc84fd/SUKowhV3dY0QCJJaTHLKV+iA8q+vYDfcqFgkajdfvzWDxqX3hLqOKj8fE8lCVI07wqN77ex2ilO/9Xom1eQw+tleTBgh3s/zpi/OT0vbri7tGvM3miIkBh6Tcy1mk/q2UI9ZmR2zr8YU7cH3wl8ej6ia9gW1HUoF1MgFM6igG2scTeQyzCqE9tH7heblS94nxGhcu0m0MxC7sbSeA/9w9np0Pm+2sffSCgCLSzJ0TkPJM9EWxvt3wbhTSf30Sc7JxkRE6Cl+XiCmo7veNh1WM6Sfpkgf7Z5dY8f1QNnjh5azOrJWt0JL6LKNDd/3aYyh88U5pV2FVknP9jeT0Mummd558VK70pqNsv7T/2OWQbdkotQGwXwGnUi0Sbl+Elo/hS8QD07LxJtd7Lm2BEw/I6YXadEuu+c+SbB/sByjYaS45pZlzbD3bo/dqLVkluiq+EvZW2wPKCShM4ROYy8tc+ZuY5H+dN8WgxECTqHIx6lSY4XjVXC6G7DNVNEYTY706ZW1LOTKAzQo3YmEu0m88VViJWXAGPuKAWo+EIgroCLA8BU8DBL+1DHGnR1XWHQwb+4E5JhdseR2eiJ9WOq5VPBeT50QXqA7oNgHH4T6rYyoGPQ1ZgySJn8ZEevF4bqgr6S2gYX747cerP9//qv8z5s+BYmzDA0r57xUR3jToGRhF5TQDLg/6ZwQVf5DfECT9pAHTcXmw8QpqwP9+S1dvKIupBIGzTcKRHMQN0k+AI+NzApHdUHPdu23MN/NKFU6BMq3bAKh/H04EMXq6EVxSw6m1MLKmhEOU5/1ACzuzbqRGzxBF60vwhCodMOMgxCiylGcvcP2KxIp4KFJhecym3s9OEqEOVenOpHgO2hTCisvLFL+kaDo21agfFJZNy4HxTMXmCMJruGXO8RyI7hgnLIZ8hBF6uZddzcdJm454JiuVXZyTiwPfzPMMoEYk/NmvlRrol3MW0EHsRiypT5VomIaeQMPFDhcgcePviNtbM6+q68zy8Kzpv1Q4UlFj5OehcwBkibSOU+AZInKChCXv+CgFaNm9oohbhQSxHzU3xXNNu0/o1x76zUfqF91vJm97SsPI8T7U7iu41SD/8gItEunnirHthBTgv4lYrOIllBJ3mqHRqmUFdMrYsCJq2HLPax5IEtRd+PrLbQY4ZM3Pk+zYAHxKS7MUKpAJmEXKaDsZwHBLT5rkNG3qdh4VRZSRy9+fze2hXKD4ObVsOhFARX/+w0fhE0LI0Aayi7RPZIYTCUJnpA1pLlE9/sE99/msisiEArGEAmjNuetvehBsM1plzs4ZPCGsiGV9DaLGAhRN25UOa0TpcijzqV0u9HX44fVNaz+lcqSo89z1xuAA4C/JeP/bep9HGYiM+87rl9ikFn1xvyWwlEtj5fORM8IMwMas60BknBx4qZwWniggbJyfzmiUrG+zPpICCGsHMpxDnDprxsD5R3s53fKj/bogqLAD5J8wFI4+gBIiU2FziIkhhDHqvwti4RioVw/UmS0leFknXBogf4Htt4LSRtijFVZBmP1z9dKq8etHaOe/ram/KOU2oqEgGgTRujkVmrpHc1Q1+tYLbbxtkq7wOSzc7kOnWtcIKc91UCQnDFFuErk6Umd3pitX8n4cLw8Y3EQQKHq/ONPw6UrVpRYSfoXSxGTg25aqTDl138sbXfp3gOsrESCwAeuQMHxdZzFtl4+EWamMjKsfKUd3jdOqieHu6DAjNbSoYRXLrB4TxgaErfr7WZbVrJTrzHulu2t/ypzJ7f/KcXsadbhLOmfiGcW60xYa4Xpsiy8F0B96qU2Ncnrwbl4wkHqVQLR8woR5R2dtnQanWLdBNvl72FkWWxtCVsVOimAFBRHzJKb/vOwtutpRtfO6ZvFNv4kbty6P5eZF26WFiDr6JZsXL+slBHNPDGC67Y56n16woZMOQ8VGyvgKaCd8UJrN0J+de0U3IA9o7n0dnOEVGDeomdR1EOqfuYxGqLLqwysDkxvgKqc/o9fpbPNG+gWjyTZsmNvLzi6KBiBQa9GMUyGwS9ZboGpQciLi9x+XCRLWJjMAqWbDizvNikoRh9eUU6SmuR+nNr7TV0P79JoFuyJQUAZyXLn/HxT8YQkbeWpAwQ92fuaFxN6PW34s2VOWwKmENKhTqmC987H9apuJixuVjIRkDz4sgJ0U3nAiy25WzOQ35D/clFBDZq/CwwAxqpi68UPcaJHB72RjRffU8osvd/bQ52CVzx1GJrrfEZep2ALRCvelbIYLiQ1uqzTQQGDBSnK9YDl7RcyVDaZctP6S2hrW2fz/YxiJ7y2EDquE2yXxGC2TOkOPXv9t3J+n6xaTCU8gkd37Hf7LTKFnl9rSpU43334EYexMtTDhmjVyx34JfYuDOOCPfO+D+Qjp6L2ruQohELOQ8ywEvc8C4TJpJ+vT/D6Mi905izp+/SAJDghVrhdAO1TNNwqqNFiDu003cQrL+6QFro0QRTdDPUufcduwRM1jo06t5qf0uXQBP1GWvX7d4Ldsx7wrvXVyoQEHJDtxRP+v9+uZc4TXQ2Eb1zOhbj7lWsnvYyfw9s4Ujxt4zzOljj6/8JeytuXrlyX390jR7xppIWDLRwa2VkZvoEkbS6VMlsrDbblSBClQfhU3KkRzqoAsWoFGxma2J+2fRKzgTftWZqLYbbE+YgQi9LDCBrWDOb7ieHd5b0AiaBkE5LEvc0gFaP4zHD+rIwq2sqnvD8/E2+vuqTh+u1AFCwCgijYS0Kw4VeM8Hq+FodsB0Y8ZMpFxTfExbUHcIzN6fIWwgYpTmbKmvxNBXRpyT2kl4LTIvNWkctNOt0b+9HxgSA6OMkJYDUn47PdFKNm1yk/445nCI9UqogQLtCToLCuK5J+PezTl88D3dV3gO80+Ox5bFJ7JraBOdaQX1sXtnlNUZV7Van3yJW+4M0zh5fxx9ilY25FLsidEOshXGoYnBuwV1E9r361hPMtWT/URmONNZxR79rJ2aJuJtwna49UTFgL23wLvA6loEYOi/UUI9cdNmJh9Nx8mNOlyVQxJvOnZSdspqqrN8TImmMeaxOLaKbZhj5fBshh9rdUBpD7+XU6XxxtA8wFiSqz62jDULCcmM1QJ/pX5PCPkevDJbcW1X9qbbvr6FKHPAXgGJLtKtw+jAI+rWOI5YutFv9oeoEWjbptpy2qf84/r3T1PcQ4zZ2pCqBnS8vpd8F5KMUpUFqyCgM/ShR+wZOvWPbDvd8anv/Rg2CWVA5+j4e1BKmKh5eYWVxA80HuDeY11nqpNa+NmpT5jmp0pj3kAgFls2isoNrkx6OOlyoNJ/7M9dj69VJ6ZKMs6mIqXs3xxFszrXHJf8ZZlX8v4PRV2Jb4+rlaSgwt5d14Jj/dRTtuE1TV9mw+tqpTLaiJQnUaziTl7n8t04EIZYFreJ0PDOXeNZKGgUiHT9yoARM4VknVPqxjdM3pdWIgoIEt65NGB1vaNVl/MhUx3H6Zxb5/uMCmbwjm5x7J24V0P9trMFAs7CDc8kp35fDhd+kTMf2lXYOvVzU7acJnfoFmm7Yrt59E6wOFH06UtJFiZcZ/7ExslHrR3ESzSr4/vgimjyHQFI/LzyHqSypdnh1wWp8OXUA8KM9x0ZveGnAiH6ClvwiqkKSxvRHHS7ani9rdSSOoBmUHPURdFBwX6BfxdQ28TW4Cdqt811VWIpcMracclO86m5k4zHEswsGudnVIFKIdmR4rCJ4aW2FqCHz8JhhjHOwYNMEbpQotTy4Nfk5dbs00qc9chcRElk6h0LuMnfG6Kr6C20Kfej8xcIlSHFpbid0rVsl3gBoAmCL8ITSs/a+RDa3MZ4ThEb2W/ushHMb3JD7VOTb1D1IvsBA0PBVDYMJNBGuFXW2Z+7p1K/4C0jF8OxqnTgc5LRTxV9A8PpIN2X/ZIPbqA98kPNPdB8YYDEoKTnI5V+BqdSj4oMxMubpMWpBdlX1pb6MtNnMURviL8VKoTxVhLh09ianJ02wAJTKhlqWwrk0o4o7cOMZNbL9hExRoOdNBeCM6H1itMUYE05mHRaVJgUq4Ek5gvVFU/r+cnXY2v+1FhCQX8ZGQsHltGq1i6yXb3EsT4mWCEMtcEFhDqyBbbbOMGr+4wjEb7TDClFe5VzFkc5tKKEnfJ3Pymfbf4dKAUoJTcbEiC4Bk7UE/WgvwMRqZFxSCjuwIW+i1SJwKpanLNfXJT49Vpyc0hj+2NchfvvrysQ9aDrULhuVYBSjajx/xirgRswu5houb/bfc+SAx0BGYr19HsZi9a0JDfq6Acuihhee0nwzkzz2ddt+AjQrkbZt3E1RKk1IHIEy9eTlQYEloRKbJm+gA5m41a6787UjUr2KWcvrHCK8SICTDUDUMlvZwW4sFs7NKfBeU4zYfTlL2K7nEYtGpUKsxQ6Hxefk7CZXwjr6nwKEPtfV07OdkyREcxKRvQOXF63WqVeUQ/xiNC7kK5Pvz3r4ioQ4b/mQBbzBdsu80wGydHsUs6ou5GozmG7YLze5q6cJ6crhIlpd1QUDkBhUacSOCiaKDn2kXga8VWAR2Vni4LUFfeeTtrqNubtgqf0gUGq9B/LzOmMMVXJOKNOrtGDwvHzRV5jpAeSgvE4iosKnxdGe8ALb7+D1yoYMCI9kaMK8CbCi8XN4yY7BBC2oqWyZn48RaQstyxPNOcRQ76deUh+rt2O4FvrMQDGsLAW08p1GwnDVFtQgWYkcP3ZmoHKsUBCj4CSkERk7FaG4hY4LKTrKPyMm+SbRkQUfLNEcKYLYpTYqCTNi6o81h1trx2FUnak2Wanhi9UMrdTKn5JYUGNQJC83Ccr93Vza1xbJ/kG6htPIDoTDxC02ypsEYs/hdgP1a49iGOf8fqdrqYb5IFw2r+fO7dxKbnJ7wMsDdmHJWFpb7samVyCBRiAq7lReWHQ66GmojweEQpS6hWG1WDepZYurbyxktlSv5IeWBucMzBSNY9sf3iFK02FiY40no2B0dX1pqiGN/+Njx7SscZZmtss2v3vIkDUh8QW4VjzlOf/JAhNoSCHarL7740IvIjKHWdCSjHO+eTUV4lyeSRWrmtaD2ZUMdvGecE4HeCwC9fyHLmSJLfhjArFP3kenvHuxF8PBZgTZt6mk10U9FkpxBwtmqenhzvTk8PZoE0QbJ74BIVO+LfXsbWlC/oVdGH8dRJ/1d09gGY7NCeEXA0anbK3QxPgKlC60zEl5O2hNvxVjh1IrZcJMR1JUQeIYqUdTRuei9vmF5LY9ceL8SfGxe6mtUemT21TKlN5WOr6jGw3dRdEAdt7kyk3pK9uP4WM0SWAAhoB5OzAt0bHtEAWoVScEdDzfIAnwMddb9Chw3kHm/MIFJBkHqJaLI1IWWluz4fwVZDzOD1wbDl8CB7goFISeUMdHvzkV4TOonz2/BWHju/RHG1LjOdcy6ErRLohqF+/PENY88Ov/Wdw0C9HoGTAGNXyUSBlTgYY+WAhtWGchSq0CzKFm9/znWyVxWHf7ZXDBM1IKT7fctDnPJ6pdQ8vONeZRqp0nyptAnxGSwuIVPMLy0tUhCKUJWHhCsvZ4Gz515B3NqRx37DNHysfpCUzluJjVsmwmcG06uI1FgADN3HbQXTx1qaTxvGdw8ohmUl1u0rej6AmmhZNcf0Tre9cEO8dnsMp1AYDvkkP8rcMYskG5GpYckd0D6wYlhYbL7Y0ZztcwJHTDqoEguNUYBxij03qjh4klJq/ySG74rHQPhW9K+qw/0TOvokx1sUpDqBeiCucEgGcyPBQ8puTLQufDU3O7VLK7GcBlU564lNrmJS6Og0/R12MfvDnyKmBEbWb452pRAAPCUGX954VSPFFNQam2eb0OmGolNTbXme7RuO5sLl0fkI6MYKfNcMWB0mdKlmJhr6PPyQNs28OW+by2NSHM1KMfiA3dh1mLFY+sEE3AmmXBzALkftpLKGjJqqPkrIy0P5c6cmzirNzePzJr2Ejp81bmkIMMt2jxZYeh0VF8sxqt97/MZYvMaWTgDmTt5RA1xm76umfo6ob0GPIgoXUU5Rrq7ayM8UdhnRVUPmQNPidpe/d2Ul5CYZWObp7NqTc60+a7ADjyMLEcUAk9yO4DXG8hNgft2Crx/u8HW9mSbWfP23ZmsZgZ70PD0p6kF2cVt4KVulCegvRUSFrvMynvE9kVSbqHSDmldx3kXjrVeuOBCRfqTwdgWm3uztJk+7Av6UeMH/c0kFYP2DZEUfh5YEvXe7Cnfs6dCsxrwcPRdNuZ9qWJshoMIC6p/WM0UT9H/G5Lzv/lXhLIh14RUysi1DcDKjjH1nHJXDopUiXEkEBd4ZqbHat3Vh8aqUtti4BbUAzoNU9Zyw8F7wal1FWd5AsNxhPmri6dNy9NnIAR6DA2vw2W4zJ1+f4MtMaVm7eWnWSa6BXA9W0Cc9bUdzvXbJikVNiqvTvc9ZBpz3cn6Qe/w4cRjnDsPfXQd4JmcVMrxQ0tXY3OtCPSDSgjWkRuVq8VmPm7zqqvbLfkyQDfIWV5TaNWaWQddDVcpbJ1A4Cj7/zSHIjsHF8DvD2zSpzmOvzute9XsP+zjw7F1c25gS0oSnoVvRqeXqa+Mx4W9Z6VNyX2RgN3s1Noux0Tq6c/07uXgMWJxsWdX+n/VGFUHorpAerTHM28ud8/8oMp+VHSI+eTOlRCXiL0aW46cNf2TWFMN7J2oivGylhUTe6C0oveTTf7ctOqCQ4jTFyCpoTQyb7lKmvGggPtBygSNPq2B//T2ujbLDTREn/GY52XMM7DJo+OvIkfk/VnAs2PqWQc4SmtPHmngs0C6aKMT/3SSkij43MnYihIjrUPZatkO9JBFfqM7qT9CeYn4d9XfPxvngCRQ3UR2CgzYj9hX7Si0HsWDqrtMBExFX4+Vtj5yNBXHr9zT3xYRcrM1OUrhIlSb9N1XddgcEJ/WoGPKvq4noimHRgJsHg/UmgfRNHJFslrWnmUKtPV5Co0giUTJjAAiryHUEnhz2/5KOtwtS3lgxVRMm7YCVdmc0Lodu8YRzx5CTC2OzNW2c+qRGbKP5c+onYUKHzjE+aMA8wpoiDLLNzotjbeHdW+ViJoOUo4OgZYPksHWO+rqcKtGclEB53B3i6HeBxDMFOl+9t5km8M2SmCUi3JyoakP5HO/+nyXaexvwaFV6rnSjdYMAyU1dPXFDIKx7umG5h8ytNfcnK2IpN3hg5a7Y2ahsGP+nbtd2sO4r8XqPjuPxiUBt6kBaFTV5fcJjTNt3ZJVbJzwXeC+mgVaCU1VTbLqY7qgBbs2MP0jP7sNs8fVOE2srNE1cLivLnRJH8FmvDusAsRKIO5Cb97vkNvvvJXbFJH+VVb7gf7g4y9j7HHUwFOVGhBgJsmyTtc8kC0vjewv8uYj6l5O2ZrC00RPojZvJ0epwPcjIxYXRs4+2w72aZxSi49uJijqhLXG7YnOzDLHlSmi+i6IqJ4/Fal76uoG51u+lIV/Tarnxuh8pkhzs9Gwj+FH8lYQoRd6lF6YQPhrpV0hWC0VQveViej4UJbxwTpQ9bxVa125h/actyVFT1o1zpu/vh7NCGZiKnuzhMJfml7d6p2AZp/Cp39PejjLdvBH1a4nKe74iIDftsyZSpknCfvNFAR941czW2uhZrsE22LxLZ38wQPfOCgdoEVkgjvl2U2fRZm98hEXiQWj0sPigJSK9ySV/zJ4onKnIOubXHu3KkRePBguWavhLadjRs2dgHPRYR42KrodyEB5osKTzvP8hbrK4MbeXhLqSprWb4Ud3yEs0YkjZNsjtUBXyVDLDaNd6sC1c+91muY9Nzz79d8Q47zQa0aWnGWSRimV3O8qApQMHsv2jWIYvOtj4MgQMI/vH8pmbjd1Wj7bF6KukfnzCCtSAs15BWfWXu35fUFvYR/a/BEmTQyKOUJXDm6/FBrgBK7R4vj0vOA+6Y3BqzL8Es41XgAa3ryuaqLMwGRE9R5nJ6aQGNZsxA1keY9kkoUtJmfee7r1gTH02PzVwngFXpmTUdrskOQ8QjGNVdT0x9DuvR4wPri53OeQsCFcvuK3NIoW+VQSwJkenXM31Pyex7FriESuTalu1A5Sa2UEx2bsbV3dernUecpXVpw37GJZ1dDiitbeklmOKG3vpz2e9U6ZV8nVpLSDhctQduc62aD/D66W9biiKRcwdXIL6WOCoP40v9OFqduDuVPwgvv07skNM58Kx3PKDX2iIARwDu+/CvcdNg4r/GjB30H2SgIATQdrKjApN62s0KZtxEwlGyaH6ESFsXj8+T9QOhYrYoBWrb8y0+o9IlAmLFZ1BH2tUFmUpXr6ke6U45WA5lZVDb9FetQe22A6AXr+s1X8EXCOxobXLtBvS313/gvvfwHW8hDxNZrfSalXmnAvqOWUskCS964J1VQzf3K+vkarrXeRbS7E2ohsoALK+6RRIESQiS7Vd1Pu7mBTzU/Yxr5TFoAJnYOTiQNPV/Cco18zct1gbIBl0sr9/j/IZ3rPHxgwWcJZmjJtunzLnXpx/b//dD1QFUmdBg0WrZIoholY7GLBGIblTnCNc1HYOyPkw6o2EjSbqyEFdm0xjbf6Ovn9LSte9G43maWTWDaZoOEe7iA2LwzARe61LIv/tjPT4bgoBIC1iDZV0caiXbb2zfDQoc68DrgNj7mj68IG2PCoNCvjfwfXtR2lIJNKMGp8sN1RhJ0rzl01/pkwnlTZKqLqSM8XEgirwAlv+ikwmK18j/PHkArj9cd5AUf1tS7m6O0Y4xVrztISjd4VJGAIA/njV1IwsA5jCF/61wDRsn2PaPQUHrrBxIFDPuQJ9U4ZMCQHoJWXGgsEqiJPwd6vydTLmwRW/aWgGmeFkkb/Zmbnfk9IG4lv64iV7HsEUXUs4x0Z9ugnAph6UofgJgFTIMDueZcJIF0kWQp2x9xe5N+k6Voko4H/XUN2IbLaJsitbcKe/ZwTmpdb8wT6+dk9OU8u+sl/7ikqmcaiHQ8nhuHIHfE/O6tHbayJWSpnm4CLPZfLdBmK5ANGE0/3JUXCWvVBzp3x1thsXE+G1SOViG7lgEtGdoqGJDbPUokYr0q6lCCFr815HqIb0XiBdJzObQJA/u3GORfFx6r5nG606gBzIo5UUlS0Ao3HTDTPPF7IvBdZUJN6+8KgdCr+5juufDV3Y0IJ077PCRQv3yhGPV0lORShDGoeiQUTB8pQioscBKsd10GJZFlTtAd7Y8r1qRkTtvrqdEyny8sPVy3iGwOEBtYQ3AfwdqvMqpGsdkcLulvltmn0mwPcs93Ey9CMSSCjyuWSGKcOBEo9VLiEGaFVDnD3d7jJaGqSoXri2GHp4nSCI+TRdT0UZeSFnkR9RwLVJDHTLvneCEKYV5onftftT9iN7BeiSNdCEg4s5XbqtDYMsvHOYXbvykuxkPkK/mDiEuI5vh1+0umbW0C42v1fkzdocMLjHHQ35ge636Sf7OnmMV/OLq0BeDnPU/IZEn0BPRIQXWjWL4hlU4anuHaQBUI3aS+rUahafgunBnU4LyX4k4tygukGyK0LJ/LBIbBMM/b6udUS+An7xhpX2OFBkdThGWQTmUB+KKBz8+GVZfaBvwGsFJ1J5ReT5aTVI05C5psrDkYAU3tYYA7QWvfGWw43aWDmRDrmQAYCHnFXLIpa8emkAjVFoh3Sk0tK6Y6HGxfvazcEdBwmTQUssVPLjhqyo8Zp59LbRDIEiftbOGYX7pnzQ7t10qNOW3+xUzJJSQPJsAc6/Ltxq5Yb9ESlcu23+XHDBZgcSy6BQyGdEmdZCsj3cup8opGdF2Y7FZt/gQJxAi5UYk8ug7AANJT8P3Mr0cZw22Rk4QPPkw9IijHvvi5c/7NFkkmWjLpm4CPdrBjBe64dVb1aTZWJMXmG26FE2JzVPLYOGz+/VIPWJYyZE3/0Ns7FVV2h3GDL0X7NfDLJssmfAwfDQHaWG6iBzI3OwSgFAmzdhfEX+tHqxpNwJzSMwZpfPZTKqqa7rwFyZS+YtcAKXmSLYIU+hplf08LzE19dDahJJ+StkG20C9wd2uemR4PK2toaGF128LEFKqMJhyXNnSlMA/iILSdO+jOPgXc9thx+cM3J6WEvf0HXL92r2ZDPjs32Z977F/QvYCJGSed8BG4ddmMwd31VdM4abFeVwQIkK8O5MeM8pgBkbUTTYKvVLc3zjbrxjSwoN3gAb1P0P81fXI+/ALAf/Uk/ANqrV1pFTekwK3p14WoGU1KL+T37YRCgJhVcjGyffor7IgUWcQP7Kt3iTNRTLE9cBYxi88gtS9btZGz6L9o2yhEjsWr9zeM/IpFOEGKAq89Jar/HpQFyO0qk1MJds4OWogntWjQ+P35ko8xoEKqQ+i9mXbWLseyU6nUWgq1fGJk3rx2kmiYkrfnQqmo3hnOFzAW5KoaQNqghABn/aTJwHUHD2IcO3RbGsIgtAPt1J5TmeQfGNAIPTuxDfhLygOaOU2JIAkb0X/7CXb54vq+OpXws25tVBS7LFt6ltHOo/TPXhQdlzaKdeM+QQpkdnc4E0KKPQgLb8L2zdTTEGO4qx+MNAa1W2bqRFa9FwEROklp1wsC1DpUSDyN/WxB7EcGSOEsuDIg8V0cO7QIEuai222X9VOnjo726qHo+fsjR52So5CxEEk1f5MyJjKgsdI4hYo5lL02PkU6UiQrgjKJ7I/SVIyES4TgfDmT6ODSHzSm/e4NUITLEOHbk7AR+2vzvHgqZK7V9oenxrYsEfOnsE9UVNQ4hhkhucX24FPT3TKIU/54tQE7g1ruvqdRrow4DSYx/emKwwY49Y2OXdiSfMaCcnPhYJYlRmY3Ua5OQoGEWtVas0cSXHc08HBEbY5jqh17jcXZ7oCAEjv6sjVv+DbX5i8RUEC+UfnWRQBDnZ06oTW8/Bw72ScAxE6MeDQseuwBgp8qslZWf3qDZayRkcaDg46/ax3EJ2zE/mzbT77umOB83KSiOVHM20z8UWI7cSRtrG7C2+L4s5FYmo1QShms4doVfZ4e5cPt0MtV8ziQtAFuEnoFL1WCk6a0AZ0EzGE0ZnOIWONno6PFZz5F0lOi/Tud+cQRhNE/1muOz6muhosslJ6SUiL4AtJsZCCmbkBabW6S1ltPchXX6Z30fZ4BnJ0MzXOFrFwUhBCWKIt+ULqT/ZH0ftVBJRIxkDl1aAalMDAAduFRcL9Zy7FnMG/Njexo6cnerVG34P6eIlKpoG1BHXczLGR/wO2u/wOA4Hu+3W3Og6H+bEcafqQfgbK7hmqBgSRg5Zqg9idEdbQpIr+NKfyLTNzBH8RevxiwsnRoW8CiKEx0MPO0KooCWtkFgzdkCjKJMQbn6eaSK/1V+KYzCTvzN320uGhb7W60NlreMQxfyV5He2h+QFXY1qjzEz/JZljRqGFNTpKnW3v3T24Mh+klz5FmX4+Y+DUxlZ5Hjm7H7t+8vkmxVw0DSvMs4JlLCroBnrA4ayhPbYKj8YPbV04jOTnMEfCSwmt79PVKywUoE0B+niyXSMrkg4TT7o9SDDZnfpZZhMu0t8Gds8eE8YDuOSz2Gb2L03lIV4yKr/ds0kXM2dkY6bT7O1ILu93BOPHQx0QG9tAK3FPrDPTmd3uxHFv9lnidNpFZlKofGGYEbAez9BEqslWNoH72I+njLDtjC4dcnbpWlTPM3LQIqaUOXb3hUPJwFNp4rTq2vLZG1XiVZGdiEV9eGntnQ/tLnsbVnmxDQmuBHaw6s9iAkYw/jxrO2aDDnIp5E4bOMCtYO2X9BLtA31H4XJKcHnRnDXEr6fs1c4LYfLcoRXJRrcP27fQCoC0OWheUNDebAsIqRqQTVXuV2IC0F/mYQIvJPkmcHizT0qmhXwNLJuR0Y3VJMiInhy42T9mKesulkj9T4LksOgdhi2nSAFRn1zWSL3njY4E0x6ITWBoAu+uPwyREHAS3TMWJWP3BITtlI1ntw4/C6GV2uKht4Y1912Px2RNGR928phuKv7t+i6Q/I/LC3tXIggiDNggxD4dWi1hxgeHTAgevAGWxavHd7Fb8GUbzY/8KPApd2IEEFXR0i3QHRFT3/NVcPufiBj19gIe+EBuiMl5Im28Daywyai6ypj1MdxndHu04yDXaKTg/lZ8eYjFGsCwqf6Sjlj4G0a4j3cel8yDLvFUsJ0Vjz4MuW7NyjkrJxaCeX7ZtmjVEPuBAU4dQM0I0Ctjluok+xei/ynVgrprvTVW0qIQXw72F9fN7heh0DpF5nc2VdT2YWP9vjpfPo9fhCOoNE3nyc8CLFnDRB3f1CrjwB2l6CHJgGXf//tO66o7bgt6wIfsAZVZ+/svB74FD6dUHlfrELMFxbXcRE8ExAVYrQyxUz7J/NeX+uenkoY868nF5KgI6kcUUie/P4rV2FJuItGc6ejRPpJVwcgSQ5kdn8mC8W2msjbhNle1jllb6wZmUF9s/OgwbG/EyUpUI9AZERMSG8UCbzfCBNDwrxuVgOFxoUUVIiXfakHWv8bvBbDMBcihwC6d5yvO5eBi870FMfnB67s5ZdslKnKj9UNQrSucj3ciQeMXypGE/pCqgaAh3vxgF9TrCk+2YjEyJ5qNzDnhTflP8a5QMDy1xKaeAcJrYoNlibcQ9hYl5aV0WJRGRGtVeRy/RwTZxDlqGD56dyTaLDOsxNN2k0+HBQmh0T1UOx9FXhEy6MGvlH2WUzgunH84l+3JimPwJFfEQxZOddETPqmmaTtyjlj84qvdCosfXZeAZ6scIWDUWJX/pCEx8D3mEPb1tOnZXqqNK63pELOAQigg7rPyJ9KmnNIvI0p8CmYgMQh986a8j6P3qxaeg5aGV+nE0kaXxzCkx3hRBjV5h+Rg5zY1JdTmpIF6AfMdawXkxH850I7AqQQkkidTCnqCmJpH8TEslmi2Y3NWMwrwbFOeAey13xqRot/jrKGilbCTE7VIY3O8Qx1vAsFTrN8YFSRjO5EBldMyxPq2gtM61EV7FEbcNcjkjAt/GOGe4CwZHRiwG1YjSbiQlXCrQqMMFSVcH9Hs1J4lg+gRUootia2dfJXBHrdllirXaqM8PBPLHRJ2GBbnXTHZkpP7ioqybdiyuuW9Fp3xm4+avdxJOKU9gBpIBoxwCHz+lu4nGNkManQsAfyBoAVs7Y0LQ6kklAVrOR8AJztKGh8ozhUCoUv4fse7LWmeHMj20ayBGFFNfNU2VweBUhpQrzAzNdC0tz8v7gQ9XNN4PqYugyTpfRwkGFfN0qpv5IUrFzXNQL2Jy/eCzF1OhzgSSyex3NCKsK2isYkXwFT1STm3VDWd8qd9N1rzh4xRfneDu8POkY1y35Z4YFdS5Yo+mPlfYFJ1sOF51R888txj6LfVJZSx9xbETOdkunYE6DsQkj71izNfRElZ+9UYPhkXrImaUqQPosFhreGPrlviqGBfWOF3+53zxJVFU1YeDXxjX9CVcrceUETNdB8EXqyZUhL2ItW9S0coSaqP2gOprW0naPyCbGcG4LLaYG3oDCkVJfBQEaTwh0q0Or5PosLWYv3aw1MQoymd3BvihDepYUF2d3QdYXHBKlYPnyjwixDeTDclLABWddwyzNBttHH8Ra6f/F2QhSr1pPkxFC6295YXCXPTf1yc4zt3ywP8rFgWJmRwohHE7RkKuLXVB1Gb8HOfazSgfTuzLMiStg8wn/+vOulE/Frurn+OyDJcv7bedpxvaoi/d/QGpXBrNp8CZvRgx4DqjBdjecaBr4UeHAXFyOdduw1Foq3a7e3Xp6LkkmUwVOmHTPDRJToqYZKD4462csz5WrtroThmTA73eZvTeERf+QEJvIc98iU8l9LfbEOTv1+HCF3IsPK2uxevKeCLqlUkrgqQdSdXB6hMZHg5zPta0YMJl5OSG6SHGco7Ph+wrVfONpBNfqxk/BXA4+5YoE7+d3YzfWJDdGaqYIaoP9oMHvvrkY3YVIZbKSAMDT1ObrkfGFzRBYY1SThHHiosETc6jPLzHeVrPebcU+7OgziNRW1lbzhjSMBJrC/WCBe7RvuOMEvQz/67wLVfXkpupcmfDef3JXJxZhgrr+QAdz92GCUN1gI1AJyPThR76uj+TX9e3BMhXz6TEtSJ8b3A6/tLrf3RPY7ErLbA4dxDDT6hUige+u9escPDjpfgXwQ6eupoeBTJhq0IHKLg/pbiFdv1toQH+ugpzSdoRLoRuUHWfVoAKrBCFKSHsSeQPzwrgiS3y4meJkv8XnPYdIjY1g+TB/k3HV546IzKOumhBMXk7e66cxulqu6ccEoQtKOl1lMLXAfCLfDCpcwgVfikRPQhDLqJzkXgc1MEOZw27Rrrs/4ydMqJFxr77CNDB+X0vF1M6/JFM0IGujNB0wabui2OEwQ/Of2BNA3MjrqhzD2YCbVauo5GzW8rGJDvmqG1TtxroeTEcJ9V1Ea79+0LqFu7n5cWRZDVSAsoNxGZSsj1f3zf0x2GHXY46Aknk/a6J/3VWiR0tGrCfVIRmgqlxU3Z8NRab4Qe00v+fjOIA1WLCB4K3LNj5zDh2kYLNV3oEd/BRxhaub1z8l6ykcWBYSPA+ixGFWZsBbY1KwC3WrKnNRrx0ZBlKucwIdCNmjxoLkbQaGeiqL1Kq8gn02PZWo+vrKqjY7NNuGz1JmMdPjFOiv2dFGqfAoxsahVMRxQr+yr2rAtY8fDZHrGtvaMu88KASOwkL7rOeDm9pzLMB6poT0/xskY5AWyXRziLqNuI3MwUc/mLdEZvslEIrOrT3Lz0AtWgiRHW/98MVHeKq4t/d8EN25Qx/nJauGQXoA8sd21fnlK0oOkz/vFgW6wX7qOe5QsqkOzK/pMyTqMRQDq8n8zhtkUqzWfF4XT00UC6nk3NV4+dS4A2AqLdl2yQILRU6Ri/l/Ja5yj2VzrbxbvaWQH5uthpyHykLWwddh+5pQHNpGvtbuEvyrvG2AmL+SEGFic1BL1PhdkgOsJ/FxiZU3dP3SIbAf5xcAefXcdrcjr2kyrLxRBUZv1hDiZ5dV7wG0jIst7oX+qEuRsyx6E5Eywe7uVNI2Et4zW7b3+DWf4Dech9la76FhA5U28C+i8YJj1jXcpJ/aeBCjM3HCOTGAZymqQwjwoZUquigXIEPFsyL4Cl/ucZZM3BkSgP93WYsxOLACasi5FQYZTxqwqON2zZSSS07tnwrBzFwGsxlfa2a8PtQih3G0ICIm9L7WMzQ0I57z0BYJ+c9K2A3yV/cAm9d6YUGkcg+M4i9S7PMNnw27m+rrZlE9OEGQtN2sGbzNogSJzjr3Bg6dmdiJi+KbdXw/EFxxu8c+ACN2WkuAKWki/zGhpwQHpyiaW/N6ST+yHIMYa3jcJld7llg1vNDDQ5MWP1e3D1sBOVzfKiqIw8JvQrNSOsGmyuOEs1b2wElB2ScODatL0/NUanebqijJmkNrWFRdlQrT8XmzA/Pf6LCI8dF/aBQP04yILjgZcvq9+cNXLS4BpYF1nPoGq09Bk4hTmqDCqY4dvbBB8ISDNth9d8E69QKqT075w28n3eIo1VwmxpTtK8zWASB0VHIl0HRaJeAle1c9Lf7dCp37wAow1GZchd/d9fNN/YKZibn78mF6lkrB6Y6XPK3aNxMcTa8dp5JAxiV0CbNGbCptGBO3Gvwq9WAwTvq5O67BU/Mp2k11WaIJwUhD7G2wD/3nc6zrbNj/P3wiM3nhatN+gVrIpJccZLjhTpLnUdBxByubtHQy5pPAscs79N0SGcLM5bVj1a5I1zid+je6zvKXWgVHjM43fQNgJbWm7GIoLo2fmapwgOrgNpKdVjoXXx84t0wC9uTzt9QmXP1ezfLnzcXDU7TxT/vH+6VS7mTaBBlq0PZjR+UsSaI0UZdS2sevngtayxj3fVzfTE3+IhHhzxrfzPimMq56DrqSILW59CCabilDOhcorC227vUYStefmGNVi9vLGJMl/QfIdb9X0gXuqGML0siFkLatwHybTxCyyUjG9F0m0FXplPJ8VOBzygNnbzkCci/f5J0I2QIEu2HVLTgqnzuaI8N5obut54Fs0lfS2aJYH5D7lSTtJ0Z1ETksvzQUrBKPVdH3Uc7gMvElVnpa+IzfS4QecHG3FmXJb+UdkrqcR1/KfGbA6Plmxbm9lAYQItTkbEZW8NEN/Bplrumtwca4RFrVfzjJ5PASj2iM/gtmt6LTL+cMCuWqRe7fywh5I2os/g+fX/hB4kn49q89a+e4npeLYkRaK6qaS0T5N9rjpe8nh4beI6in2dREWpI2Dq3Rc0G/OLO1oWkUNE7DOLFjhJ/l8v2zfIEqfabzDj4PwhcpcCLgCtTOMsR/Cv4LgKzRWmq4RwT3mp/UoUUXkyw+UbBDwEyB0RW/Gh9QPDxZlD78FfzlJWEbeoxmIFhCTSjxtrltRilRmkCIHb2MbYHJZiOYU8UoOBPlRV6AnsqYDo1TwO7LA1aFW5ELBGRQNQ51GfNcojBYxt9jFjNjtU3f0gQo3c/bLEF1qei7PrzYBZ6lttC0CTFwvTKNNDCHgxo10Gqe1F8iHtfvEWk1R5w6xA9xRO82ii+D7C6VuZ6XR+Yy78W6Zco3os4hLU1vIV0XqQdmZ/wXXGiKZIT304FlM6e1d7yn9B6iXTIhJn0uEha+ZfeF1gzdZ24z2JeaGG3dPZgUliOSD7wlvKDtyyNoI7vLbiOOjpUpnCO4dS/ZGj8dhL3U8C/DvjP796OdFxKmVV0GqND9OVMESPGHEyfKJNbN3c5NMfdZVwxal7xyK5KRKwKONo/IsYuPiPkz+YIxM3CcjeDhXyfxWSHH7wvorBYs2S5Nag26EPlAWrnLaHd4UvCg4nrtUPQML7VJyQn/J3qVIIiWZbd8Xvy3cX+4HLp3zRDgEgHI0gQs2btsAgnWN8sHeoj2N1iKM+oxAAF1uQIQP7H0jPUO5Am/u1gCAj0VYXvDXygkx9WRzO4jjnf9j3UrQLUUSvBiprCfJOAlqmbKEcX6ASvIkfHgf97fHm8Dx3rRBllnV0Z9vPrkM/3F4pRw9SLHEsJdpN6fM+47N366jdx3OtS3skndmgzj1K1GIuzOUAYhFw+5rdthWfWl4o2PQYOGCB/XO8GqvrQE8lNyWsPdMcmntehu9tv1vEtNRMXs/J9Tl07/M11vGRqmhqsD6eurMmFuhU02f/xX5rjFzv/EiZVc8TYMSirKrAZkmL10mm2+QmM0P5GQJ3rXFv2Wpc4wdRfZ9OLHj3A5wR2ONwssZbGolz6cUT6LbdNuKiSVMjfqQbvT8ZYdZeJJEJTT7HERUqXSqrDyUKdXRr+ht1+nlnlzHJrbLTjQy1X+MU6dRQ5llNVwhxm/PxIiAUhS6tcYxoZarglhgFl+6jAKBLiUDw+x3iZ1fRwmJmWFVcKh2Y8KglT7/IgC5BmsGw1y7lpUbELXtj6HU8mlwfeGQX33nLrTc67W6sFl5Gr8OQmk6tpmLGoy3THkemEZ7xu48tvWLel+nZ4bOo8LDUOJ+jpm4zPcd40X215IGXPVJkcw+13yTxvfqVq19PkTsw4ZNN91/w0g2aV7RJXwqS4ZayBefDTFVMTpB5ztqqyiwKxpQEJuhfs8svpA6Kc9ta2BSk9h2wjXlqVerZpVRdt1eiSQCib69mTNr5eW71c6DdXXdBVLhVHpoCt32iotHMeN8XdFdomMIYmKTGT6SYqnUd3tiNtOiGh5NElHxE95eMR0rBPqW/XMP9vgnEYUpEuULxV8wP4E9xlnokMksnJ//sB/zHsQQJ1vFQ7CHiNSrrg9B5zK+VEVrYd8QO7/EgVfQiRsnR1G33bDFb/2bunYO6Syd44EvfJpagK6eVHLViijbgR9HM1jXToF6DtXwjJ+agHfI+9F0PG7C9NypUp4TtEU2wK8bbIlx+Tm4X2T8RcglI2EEXjEOH+K/k8uPOkQnrwpnb21+AmeDdCygrMbzPtBJn91Z9/OhEiDsvDIAaycxLQ1IYW7RbP4hdf59AR/TWZx1u2hxMyEKjhZj4lNX7zHaLJrQOqBHnNhKjcNY/26VsnqY3A2Jnr/7JuEHIUE8cSrGYa/vlnVvVEBZk+Jr+OhG6bT/W3O5b5RmIEojPIc52JHu5u0LKLTMPMIo7DSOgqUBDCtNRXGwlO/KsxZHHPoG++HJ+xk4U/C+r7qtRpq7ca5NLVhkMMxoGnQ4CEeRIuGxYaiTNOfy7UIxWqDrwXiqAVkkmppcMdhtg6b4Y9eXtdOHERbYSteuHuriu0iU1GNdnWmwgZPTWefnIVDqHRrEYCt7kLiWc16ntvXarZjXW+7nM5L59s75BzKNIth7ueEc0XLrUjOJZfDCpjuH+w1wSPuO7vWtkmTLwaidRjEKS2DRfwkwj/8MJUSDmNvBMv8lxAo6hRlPhBUEwonHYN81gYp/2CI0gU15Hrno7vY3UsHcyPRG6NzODoZ9zoXhn+vE2b/n9kUVMixMq4xfi1nr/mgKx/RM/K3YaSY32VP1Gkfbq5lB3QoH6JVnJfTOY9eF8SieeKMjjgYCrDfkNxmRAng9viDBZB0NVehuRZNQtK6ljGr25vw1stc8l3a1JXqaJuBaxydpyO7b64HpdPYUQVK7gJcV0I69yr29aAWcd7qlb4PwTQULeRSrAzNaA23hZiiuZ29GRQVHvzQ12z3FnR7VUnRb1Q3K/eQqJ2GvQisXW1d4wT26h22/IyFHeRbx1osGg/ek//err5E5KDMya/QWlYMUhuRtmGFh0J5/08TjDF00gul2ZZkS9EtzjOqCIAv9lVUwIy2j1ItTKKREalyudFgYWrWEw7FKMizBc8ZMb9lvd3YHWxocpoIkJovACSWhHpn23a7Hpb4Ng8wVP9fPhwNhGDzMs8hGxahuc+2PEqNjAhhgrRgyRgzZ2dhVa8vEvpV5ZAjC6wT0xZ3qRs/giOvg9TRhH33d9ZLzkZ0WxfL0lx1SSvWGlflEqz1sedtn4N0Ch2YgtnERmx/ZP0Is3mMbJVTPLTPvgOmhTDsvSAUY3DAZBT7lJP4TSCtNbWzTm9/z8M1WbuHrNDC8J51NAZCdQiEhsyZkt8J+z8mYy035V3xZnIcO8V3gqdB9ePu/W+vNu+0A8j+23gpfTSwBN0YFkinagTanRkrlcoefhstxBAHBIAh7krthC2qPL5ziYrRb8ciIqOPpb1Hb8iB4jNHWRmrPscWViuf7+iAePNiyeRpw9Tt+VnkbPqvE1QdBsocrzs/AaJg3ul0UYeyZgkgrbInQ6pimK05Q1HL4pNZH7Yay22UOh/FQqreQhc8YUwXiqzhEb8FOgufjuNNdwX6JoH6MFZcK0k6UlZYG5KPQnJ9UWZ+rg+BAKGvjtvR2kuFBQSC+i++eVd4/h/Db1aVaP7hrrVsMHRgpancvA91D6odWoNmYxEUmGHgcFrttWM/RDTBEWpkoN6+rZFJvjIMvw2W4jJ+GqP7XzI6JrFW0yW7vlL0/KYeLVx8cvhBpTBEi2UMLkWkrDW/FeK5PhqziJpxko3aZmY5DoOFUaqA9qquTW3uN/jKZ3iANxhvvKqcopQsjCbaGZrfthW0L/Qvz410ExDnYiwz7eWE9mNzV3PMdQglKwO/QlB8x/rcWXln4BUVxbETIiYabEdhwEkEHRtR8VqDkTpNMk4ExV+7IpVWl2mbj87vd/LCTOzoftZ0nJCn/1CprUO4vBUa0qAZcBXsoj/VYCp5JH/r4Ty7AALlIor0Rnm5FvEjTjIxOPvk9WUSdqlu05E4m6p/j6MXrXqDQhOP2vQaHlwzdpJlZbJtM2CPsVfMBdyofEprgo8fcM1cQY1ZXylvnfH/XDK/pmu5ENr5vBq0XTRs+3W28LrJTnyjX1OjPY1RAKRPPFZ+rQg9bg4jI7+U45dV5deT6WDnABx6rwkBTbvm4ZUjPY4BmIKhoO0xnjPBB9VgaI0pekBs923wbCGizeLJzUslb4BCnp2nWb6oABuMs+BMCGXPBmdfj6bYvMk9c7Mnoz5AVslbWekG7sOTmQ4zx0RKpAjhi0e/rn2D4foirWTzXe9eJQ8y6Gs2au4CBKF4HWXAcU9xIq1bOmprQ21dHIQ0BoE95kKSbW2j3Hi9YZWPkM5xLqq8z53CC7BPYZ63xPMAD0/P3BsFC0YeoZkeq+zUa6wBXkOR5qie3ymzveqe5aR3PuFJIoitz6phSAGUunRtcT2EN/FtHVnXZI2S3nc99eaez4YyM58+YH4tSqjBWxrh6KlgpXXjJq9uXZWrx8impdOz8o35BBXTjPw79Wi6hpYuajavIcazTM3Q6jDuqzbEgFbccl9/3ZAHFaWMq8l57/AHYRiN81/2Zr9p4cy/PspxbpZ1caiRcCkCP/W/bKcEHlzGokgfzxKzBAavaPKzA2Ucpo3PSy1baPb/4oN+00Jvnt3ScOWuqT00fgXOIGMzXU/8alPdmqcjD9H2DzbtIuotJP3l5FsGuNyu/E0yHAMjmcBmhKII92jbyxZKuwiRw2RUxykrGQlWiXn1X4Z5Z6rRq6uzdsFD6RBJuH6Pg+gqDOcGky6CYPMj4oxSq7cChvm/CQ/euHAguuLDbCwGF/EYV42vo1Mka8X32pRkScYqxCNWwalQW98usj3eAEFPDpNEnXvsbzcQvIhn4eztGIZwdbrYKsJ472hhIAhNXO0R17To1icUYmCSTchjw7eeU3FpfCohe3xN2ehatLalLc6fI2sE2us0cWOKM7TJiDJhGaW4VQHJXgXA3Z2QCt9HOUIyQ8Rk67qagl7aPm47KYTGi4IeRt/5NLG+FQsWPsnW4pVQVizasl9zXbOfbIq2krpXxoqBdrOD66MG/no6Zb3VCt41hd6mrb7KI0nWD1wBGUfpjN0rSC0e9ewRzypjHz80b76x/UUo9LlDirEpIw+S2H+5roCTabASLJi9mo8qt1X7zoI1AXblok8lktXAxSNx2CKivrRAZ0Le88yINlJPcya5+n+CCSB1ZXbtvStB41ilCrQ0Jjd6tQu/rq78uW/OARriwGDk24UJb0h/XnI6FtuFka+7qmlFBIJsb2GA9n+2g8I9M2lYfJwPVVi7pbDlmGrLc4sylBVMDSvGGTlAzgL4BmW0alKmnXKOrXmvfDwfLH6g2D872+V3U1XTIOVOsbXxUcYKX2RJ7H+4FBTKU9iohcinYdQjNkV6JQP3EI8k0DNR3xekxMAkcBCwKjniH6XmyH/6trWHSiAd4ICzXF6G8V160Bb3WMrlzv+S5zoVsg4wZuyocpUikCkP3uBbyBFCMn0VGEmHv0qGvcogipImGDe5g+IttoBbAiXeqTv7qC3/2ro/zcJj+axlGlykdHUahJYrugWRDUzAIULQgk0xdgL+/CYnO8NJ9TpLRVjprhjp2Lfs6bZVikijiVZNgvZydAjnWeACUZSLZJZGukRJDuW5YwjALp42zvTPecSyhdc2EIpjRQ6LUr+crOGg4qro+GK7a1QfikuL1+Oz4rYlIKH8IL7JAGDGTfDbi6uKFi9pB79WqJyXs/4DC8GbTWWDGAtQpnfL3OkKvJ+gnjlHBELf90rOv3SedFZUmSOBgR4VznMi0xHIMUotvkWBzL6RigHUzsZTnkmXcthPsmMbHzcNg1TmRMt4dDfU3ILmCPx1QeaJiPmesVuQ2OX7HSvbeICf/zcWm05MlIzDTaJspGHJtUvL8jBW0kzfPpZ//PfHgZ9R4NklbTP+tlBQgMDI2qhqlHnwTST2QKtBIv/Y9Ch7duj28eTolo16yFtrWV5SYv1TIMT4NObw8Yv2qsQMi+bfqOXxR13nsB+BsDs2XhjFbXr5hu6VUp+9idJPLRrl9TKvDVO6n5jn7w1L4ditjL2giaUZvxaXYysqpSOM5bP1FfoWOdhblO9ZAeZomkzB8V/CeVTmdte0CIsvqp/IAdtYljIL8jreQDH/P8axKNemRykrBs6wJzIr9erTQCxxQ+ROsu113gCWNXWRvT+8hA5u4TAf9l0rWe7BsJVmmrgOaswt5EesgrzgiwHg2KIIq4Hfs0KaxZHuY7r7ExX8VEH9a1rcHDmLHip/PEYPo5NGqQFQWh+Qf9RPaprHYs+L2pkhiZksjaaI5uwuCnxAiv/wiWCBj7fSIPClCr889lkFFr3k2s24d4IxuigQD7IwUnOdBxIauEJuENJ2pHJyQX7ceSNDB/mVv4g09DR04uG+BYrq/qngd/IWQFREO4XsuRwp6NeXcAoN9yNgi1vbI6t4eQQFyWWa8Gq2syzYSMtgdupErf3wTK4hOH9LYOG5ADZaujJ9lDO0jGOuXFFrMkOL0uLY3cQQ35C2C27yvUQJ3c1dEDVrHQbNNpV4XqcyqcrGYY7XLZzW/jD2f3QUl6zc509UZ513CsudmoMtKwpVobik49BaoBubZdxrM/fzd+hmXWK0vOhWn4pAZHrIZUVuIC3Wc/TFztjF27GQg2CyE8aOqDNciaATF/JkOZA1A1IIYXq8G/vfUwwjGGdtGbBJBZG+0Wdur/9QHsi42DqiVyjMjahysx+1W5ptr2gofdkhZhQu3ycAKn1yBgaUMswQT7CRsbCFmhJjf5cadJaMfKskXzQ9qzL02nKsp2xQQROOOK+cetKJ/1dvYepsnnqCIWD8x4bc2GK3ygTjDlPNkAxCgGHP3QIO4MNoSYxiiAB3Bs0JAaHoK8+Pa91V8txLV9LOcPFTWhFF9qfEZ/SpYJsmHADHgRYsiK3Om/MKvG45VI4YzjEvjXV20Qh7m5uT8Y7lZ5fH068SIrnZSIC3t2snGhta7nCR5M+WhYrjmZktZtPTsD15P7aBOJRL0JlHZ70U+efdfeyHrbsinBWHWLOjVSFkAm/wgED9z+MyYBWuO6lwwI6v3S8FEvvy+yND2FO28KKBs2gK2lbl3EjwM0PCOsKQFsk/ygUsjuzGbYqkgx+hYLB7fvuGZ8VJeqyU2oS09hM27SoDz+nYuX/Nrbfs3eJrbcfBo/EjUSbXzFZhYPB+wFNcQVF2I8vkQv3+F5axKQrWoMUkNkEiLOFZpgU6Yes7XnKpQBLHzFVH+cZg8ZEsM4bpQPO7IprllT2q+rp4558qxd+IQjpfaID4XO9a/gWc3R5fRCZHbrV2mBHW/6EDgYSKQ6e7uMb6U4ufPQMp1O9ZyIzrsVhgyx9KRObTzbwzubA6NrM6i32ZReqB7w7wFO6cpTVnnX3XH+q/5fShL3RY7pag54eY5bNNpdUVAYdiT+1xO8/gvNYpmKPQRUmlW3ZWDRH2VNQmOhyDy5MsDoT9TMaf0CoBVpQo04euFK0BWvGYQeq+7gO5PXqF76BmlkK6nxyEA33RuycaSOl3jrzD3gdlnH5qMAbCCPzIxVjutwl1yc+MgKrMbqZbWtixu7IalpLVlQtThsDpcIMN7tt6ZUhlWdQyATtBv5ip6Vrx9PnDyYaCEtRgmphigb2Euy4qfQGaieaENATEYjkrYMRH8O5TwhYYU/J1pRcQifwps9nqORyhmbN5iQzj+z21f3Vyazz+T7f/pD4GcXxNVmep3TZMa0gFXC6UaxPZS6sxs+ki3RxaeIqN6+YJREN7I0zo0pFuxNWQt0gj2LXp0ZL8lMEntyBQ47bSyOVnw+LUSDG9rjK6gwYBgZGYqcT14ZcWoE3ZSiKi1j0d4HVHjtmeRmCwkGnXFDWwZLQyBjEucVbSIxxyUTbo544zc6zFYGwPXWQXbn//q0AFLlINyI/kpJQPPM1zxEMG4VjGbZ5/ssjVXkRhsbb53ifTiiI8hUxPe0nn/c6Le3PL15XEt7WG342i9r4vOTm1Ig79rPDWLb0Hn5lLKDkNMjKUhyu3vGkNGJzNqPBg3F7spuB7gNLaaHmL38CiyZdfSb40Y/cy55JR0N0bqc6TOKoo/wFxXKjD8KH3BG/3iptdTmJ+ooL1mEwrG6KovtKXK7O1preMboGk7CkxAk55htKJR339EgHBq88q5QDpS2dxX1beTECQLFqehjQkO+xoVN/w/GVCvkMmStR/oFCCbuFBD1myoFR7U3ehtSMlT5O1ii/3VeCY2/vp1lI/vRAKMCZ7BEJHJliYPJ0i7QwT8VSXU9X0dKhSKajhNaiQ/Ufi0dsjiQ8gzbQyfkV+DG509DRYXcVreCgHCzVgRrl8xrsLYLiN3VvbIqtIG6IEg5YDBSbuKaskh4Lf7wrIc4VE0KumtZGgQFzbC0xDyZ0PooYfoPBLK2LrxCPjafuhd1t5xKBTms+gsOgZmql3Fg1BiUcnTtArAy5jr/o+yoGwJlHx8s1npTV4O6T291RyGBE2Ju7t0CfcMnuqKQQMmgSawNWkqSI9SdokK13/epNzdne6ZTYqaOBd7HSjHBnvazY6F6qqSY8vGpM9m2ivhcz6t+wpv2zmQ2JXjMx7ZcPQqpjv81NvVi2Qtblp/Un2J1//mxjqBbybqRzVhZAE7P//MaoITuvgGU5MIyirOa2VkNfECHj5zZ4A8vyUDPyfgAMaAh/QK0zUpDaMoywWVBZNmGAKwX5yBGJ2BejReNQeciACuUJyraxEVOLjRMVv4D4h93n54urlzsOroZULSVGjGwYCmExV8/TchfsS6wF/I1cG0lXtov6K9bUOXEiBKVNsbu8q3p8J5n2xyNU11ed5N8DJnpZ7Vv0xIRys2tzD0XY6HJUEhXBlCwjtuHjgsKhNoeRB753Q+hkhebwKnvV1madYUvjQLDvQpdzsus7slH73jXLKfFsR52uqJw3moz0KWIq/49uSespz8qv/f4WdVnSrSo4uWqQVpWnahmUuKtd8v/G5XDOX00jYNLDVcGRpRnB5JuGOdCcto0U8Ee1iJvK7R32HRblrm81pjBWWA3myOwUj3Dd7U2+XTbJk/VAWZyD4Xdgh9todiDkFFYZdsfT77K1sHuf7eujLC3lttPzzjSMnbzruSbcujRj4k5MeBwjZbiwgeiNXd3sBlJxymDG8XB/CVQYzh34L8hveVSxUqFZLYi0rwTessdgSX2gpzDuy7U6MgrSlYk32GLiEXFTtV14dMVrBUfmZFwNxW4uCma92hGCUr1NBa4Pz/zeq4sxsWb9+loM2bESs2kTwRtQ4Irbw4XJlnWmi+wC3ngdIOB17MHOJCPuhHjBuPj2owZ0xhksv39PUrIiBgIHQXbfoMdvvCNqLeOXq51UCilckZOp0KdfjSiA6Kvzl1akauM83MaktABiJRNaNDxfASuo0U7G0im8Hqe05iOPxAeIKs4nnzWZ27ruSWov4V1gr4C48Gy3XbauqKa8Ca/rOVuYuBXLF1IJlK+zBIGTL7Q8OmKmom0BFaEkWv4yGJa4x19r3fxSFa41PKuOLhN20MQsNzCzJi5QvIRWHzqZ5yVTZbGY4ZbQTL7xKGn/oXgB5QG2/DAMG8w67sMcmbBZiCaFZB3CedX4WiJSApLbGLdpuWTCRtBnx1TZ/0BQYnp38OJL9Tq7MFGOwizYhyNGKFSn8BJtNoDpb6mQL8zCWiOJ438ZIR6zXkj3Nlb1dkllGt0PIQ3BxXeCk1gI7T6H3wfG+RnjK/HXK6dO1p1IJSBuhqOsI/I/x8HbrizSGEcebZM3JzkArFS5Qhw8aZRdn4OJ5+ETOZzxjJ9Jz7A1KTIKrgVUN1IKPjF/mcU2XjuiJcAg/+KInWw1YPRPUVm2w+FAxC7vxs+GAP+Ni1AkY9e4U2D5kIy5jYNgUp3xGKeWT03LRU0+blkurNnGqIHBx7HT0pbnVF4Kp6grqazKFgNzi1X9IQHBAd0Z8Wu4Clflj7O+9ph8kn/ocqUWTJ2m4UvYgnG7HUKRq85K6FhULheMfsJazV2EPUz6qgDc+H6R+nhUfhux4BIAPaHVQFX+ityMnnME6EfiNyuhGMHbcZRe+YwCCVYT/hLf2qpyeH3w2M+CCaimFpi5WJeu1cYxAzikiqGivhae9AAYdqw/bXbrlu7ebBeUnAltjRLXJaJrq52TNEnUQ6mOktLeDt54G73s5ReaN5wFyNg6AFSX2VsGrC5ZGbSqbGZVs52N5we729wYVbLm2zzj/EE2JarqV3iul8z5JhpAm69H6oJrA2L9gpbzdmmPRkp05o8pXT/3rcAIeXfyJq5ihh0cIifddz6LT1VLWba6TJB69Ldh7TnhA+luW3hH7a8sXIVq+R8En28BA91RGzHl2A7aOi9QB1YU56L/5o9sqlVyhpn+T0dW+QAviy9gE5/cac34iXvfCY+4LSkHopPzEthqtTRLqasLHB86D2AUpN5dk79TXbqpZK2DOC5Y1qBq4IL5NnI5WzdCZ9WRyv4RzumGeWdL+V3DQoAo3wkw8HDLpb0k4hjbj6u/Usm4sW4n6ewpQZwGRhTq8tNBnFJNiBjlE6JpBjyO5pCNOT8J6ehFMUlqcZ5uT1pQCS7XBc+/XAnJ4DF1Aw/dKVN1jlRnYWIqVTmgodUn9MRQFeTrVfergfw/FU0f6Qndh1QgbR+3S2MpuauKOB9WvhLF8j8WasvITqDKdp6jQBTsAA/xkICUOz6UuxBxRzgusE40Qxo3M7UCSt7w9nIkdUazN88O8HisnYXiIezjFJmgw5BDpV/0TXtOw9Wsr+Lt46nvzTQ1jiZK/8rlk7V2/G6Z0ZnlBVI71t1nLlbKPIoDFqp4Larg6m4ktJJfXiJazLtm2JC+BzO3avTXSTvLURCJPJU6OSK5KIyjm1SvuaPSoSp2vzNj8nhU8mfeJ/PMe3JRoDRllIVLWB8Rwo9NJbctLFQ9NL5EB5iH2eAZIFmtWsO+W8JAtsGtyyV9/0MLG5xXelc64CUBOISR6V1xK5g2JmSxYkhZzTXk6czMd2Oz8/ufZ44AVQjNcoAMAoZgOJSnTXgaBvevrf2Z0SlY4WXZnQWAyhWZn2FO8DYwGycP9wxKpuMO2QVLMxkAZSH8eVF5nq0/uCHK6n8PFqrSdtWgxRV8Dv9kGpd3t/OTfMa3PiFT2P3vftIYAUGlElqc8W1kupFKkGLb1LoNdMWTen717IovFtlSP6cuWUGH2Ko8fEtEq+KNkOMi1byqfKPxgVtLLdNYBbTwVi3viHrkvSUjrO4QKqE3ubU6LNlbO5MAxCpx/jerl690cF0E73SdTJYNIJ8VZkPw8SD493x8z808k4k7vkae7zTNGxmmT2RhUnR0uP7Bh/gBzRrqhO00F+W4X50yGGg0MjGCoftNDH1bkVRhhY34RECTDUnrNAZcpktdrYURWLH/y7WCTxMmEnZBaQbPJhPR0PPfiCdrZFbbp4X436gSSEp54dMUMQGkIL+KYwDh85uUlTx9I0p/f4bwFQ8tWiz10y9Oq3sKJfDCEKX8AGDSxnpJZjRhDf/3fw1toQi5u5/1D/gSEuZTTaMIyw7nKiXc4LMmYJEivHZCEF1fE7ncaeyc+j7yUN8c+HbqerWi/ZUBhdFaxnCA0NX+6kWHl96fZAInH87FNEsUih/AoJiCRnJleB+cTvKRXJLQW4+BIEYrrkeYLB3pzA7KiacorhoRdC2wtc+yuBjq2VwpV8oVwZD0v5QIs0NRmkiq7JeDXLo21Md1CMZBmar4reN3/LQn5CjOURH9FWs4C7E46e6kToCf4Er5TR/9NAlNZVjmXPKHnhYqDBrEOnrHLGyP8ydQzAtqNHbX1Y1pO0IY1lmbK5+dRHrHgn4DvqOgGQ3amddXknZubhxoy8kYyr1jPXrnTZxZxzppn69BqXvxjP4OQ/T+wpsN87WQ0T38rgkZDB5lRVQciO/DOgKfq3/jXNuGGEoYCJwqt8B8JCYr+CCt9VDOdgCtCgjpqBJ/VyFEw7kQRmIbnjtfO73Oxi2iH0dCaYPQj6KvR0fDerCWvbnUq9cmFg+XkNMg3AjN19BRY7hegrBdPsb+aOSghXpvi/WDP8auaaXKBp4h6D6+f3x18NI6e1xt92AFc+nkmTjo1B1+9R7iIANdIiDZ+fFIkX7SlbjEHLp88P1v4s46WkYOeEVI2w49ezUhGsg0mIHdnCVyOxY71JZxfN1QzqBiGiEGXd4A73KrJQekFck7iOW1GSr0VLL/46BuBmK15TYh8sLgPUwbBEbanPMngyIGeKQqEAw61VbQhvbYAeKaUhJ+irqxFdnmVUwSVA0+O4llil+n3e1SaXZvG/VVVBsACiR8add0INSFpWJ6xfFPN2Xs7dyraPlNg/WisKbRkNg04bl2WAafiwkafnUM+mYJA7K2NUTf+26eXUcqcNnI94R7Kc1WYyjvBbWg1wabu8Fg2D+8NoPgUV1mSBsJwS+IFUdfMYCjKQwUnbLVVGxpA1WXfd9TPG/iC5sIVrfcfxc+do7YvH+HF7lE4J48rZW5WUnS0Os0pJVV3IL1V5b+FD3cf7rWG//i/mdD+qKdsOPcq5YE7nKOnSaygW0Kehwk0oDwShEARqSdx0PsG9lI8rF8wYZKcxB9OBDWxOIFn6FEhX+ozmbJoyfmJwAus5uTbWt6pkco/p8FzRECZv/4AAu6zVRFgk27SY3WXDptMEdJhYwccAGg+kg6nLStQvMNDZNFUU4PYinUidmnY7r0CXaSBLgMjIc7lJeQcL8tJ873hjBstLQt+A2Qrp/2CwbrZqztt4bKSaSimDDEIxtbE8f1dho5bwAiMld6wOXCYJxbJkVqsVdBAYDM4fYlvNiGdbCvP3oifQz9MVKP8TkQGHyUPp+mSSfEgaNZ0RKuHS5e6zzISG0A+dkKNWJuvUPCU7FHTp9OjNbkSBDIGzopJh3VSeDcbaSsVHeEN60mnLDgd29mZkJni1rf0byPe8/gtlxtHvVo8Db16dCoxQT/O2eNUO73xyJHzBf9GKtqunTdEuZyu2l7nLVFbxfmN5CSnMePJ3MZ0czZKHph3nDyjR4ePKZ0GO0ITNztCTUj1/02INxSncceGgj6HHhJgrw3rz+ExPfRBaKCU9Nfa/4MpfGEMSB6vWVy36S3wfk8KT3id8MvlW6j1Vk715QgKpl9/3igziXOLHFJYUOvUY/+JAIzhtlV2Q7U3/nW4hCxf/ZHybXLA/iw20tvPOFA1AO1sXA/6eOOWSB0pQFQSvxyhwYX2XUlC/hL1SJu5w58kx4eWhMjOZS3MIaPnhLb9CtUogHpjknR8kCvEzFubIfsZKTiQQKIaU+ymnkxnA57mZgaFp3/ubk2wlrexcI7YWrE1QC4XAcx2PskOMJpztR56GIxCuHXmsCqQzQdgFvcXi1dj2Z1B+YkRNl+y3LsHHr5j1ivqxD36gMAC0Vem+mNS3YGOE3p+Z6OH4enz1x7B14FcF9wcOhkyjrErU0uBF3si664Zw92K/BL81OWH/TfLX4WdOxrqjQMfKY4YT18fJv/GmS2Nbsk2mAPxS3pC40HJuXGttLTVrTIvARJyAFp0VNjcHWJXgGKCe+66IM4G0bK/fpb13cSzVegwshyNNUHsNwRcXtIi9YJig+CyVqwZWz8VZ3bpaLGDSosoG77IiZlJEFCb4fJVTF22hLs33m4Weac8mNQdF/tJegDlqgQhbm6i4LwUXhdxf/6iXbqxUO+jB5Gm9S5bqJC8o7sz2KECexTdrpsReM3q+ZWH04QDr22TdFH1MSC7nKKGWsCavSOv6g5t8dcbkr1kopPMG/CMuXQH2O/eXUje605sbipbEQSIoVoWXl3x7eNhcUgw6Ick6CfTzNAew9ZY6flUuol9MVaCGbPJW2ijMtLdyBDZXCJm7u/R+z1XvPCWGI3UT/PwsNIFl1ZCbWnrGM0tkum1Eec2+qINMDHwvCbawbjH4OKYRu/AFUl3CWzRU8GAY6ebmRjCtczYn54nsfPTw72uclOQZlJylWYyPAo94Ottk2M9VtxvuZFFqXQQmvDTxg6g2H5O9hwQvHQExVTQzDyhqWVJjT1SX50HLfXK8QQ+Q6y/syCCl8DnKTsnOgAELlb5aDcL2kEG6jMgs0hFCh22W79NgcpcrrUTJKMji+S0ezW6n4dxjNqxmoUyFvqTSKvyZXEvH6nV/triX46Ev+6FNW6pHPjjq1pxMpp+OTY35mNx3JABdF0cfe58AAYqrFHwxg6i/DeC7IjuL31DWCexnj6TSHOMU4UHoPc/C08bRKoTqdXBfN7OpmCM6fmxPUXoAKRjyOtHnsqbj+rHx2gG24Fkz5V1vEfaf4UzGuU0X0nl3Q9Sop068+A3rJ0oILTd7ejRjVYAi9p7Grf7EGBHr+JnVAGOaeaViplAzCug12yeTD4tJ0APO8dX+F0OyhXWDLGmd2LTOR38e6eL6SYT+/dRQauLSwopIFOh/U/739EBHERQ/rCprvrYf20op4IemzB8WfNWhykrGe8zGULa5rEcVXIj37FVGufEl4DJ0cqC5NYayJE0DICghpWn10IaNAnN+kGs19huyUKvPikOtACTz3XNtBYsxBe9nlNpdgtqFPWAz7KimjvvR6qRbgKpIsRot8xoAGooTbKceSXOdf8pvhlj3JAyrxNgb2e/8TfdCoU8FklTxZV7mFABCMDTKdqae8/t3uAdkhsEUCjTxAeSgd3ziZ+8OGqYUq84/RDkPJ6FSj0WXtYSDjc6/d0wFCzkls7PspO+4pYeK7Nz1QF/tSuYMn/ZLeTna1xPOFWF2x6OxAadjI4otFLRhfsD7gfihZ0K118pUYyE2gvCj8sCD+1lbKreCz0z1NL3vOA6ZOdKLVM+jgzlo2iaKgoXZOxWHTlpnS31rQw4jVvabp1XRNlYXnryZOzKNQNUfuY/4Ce7D7Nm26HNgVy+fprl895ku8l4ejejwmXM35M2BSKMkv82AFPfjPF2n9d/TeobJD53lA32iyVtnFI4+fjfPkxCVSHnl0eQIc/yp4u6HULWRqCYmoC57P5zBNZmMC+vS6gWLp+1fusgjayW4XV68aQxRSLOkz9T6s+HSJKsbffrF1XmNZhZjW4GJAVDilMOzNB/HuhBDCy/hipjq8HyyFsAFRbOmAWidCg9/J88jhxCmnSLnsPEKzvw/SOXN1vJGQRneyooApNVJeR+xkqtd5g2CzCaan/2VQGvm54LdOYc83OwvfSvohERbQIARjPGdx5gfNSrNUarpoL2Ze3EruGFdmgATJXMyep4UKimyofvMQweITXuwOVJooqwzVUlqsaDB4qW0wQ7YbbaxfDlRLr0oOEMLIOLYt+gzSMy1R9miAOZ7ucop6lnxeYVi7hNr8aHzYJVsfOazuza1WyxSbv60PFxyeN47zYEe53oG4mfQwSB8YpFZtPOnjlxAJVpdW9YUVY3WFjGkwBXNRKbggF/FFrSm0f4YVzAcALrDEUsgPMRvcbNv7IXNQhG50A8U+tyMJjIqS5YVp32SRl1VFIU1KT5eU6RBlfbT+Mt67ShSC7nwUjf64ycX3X3FZKVWErSRkfGIGYnXlIiNW2aCV8gCGC1+u0KTIxWLYNe/sYMmU1YjS8JR7rBrRl3GCFwCu//wcsW5G4zUU9jI7qx/TD1OhbnFpQwE/Xjv8aUckOzAuHLy77EEXCgfUSX8YJJG8KKo6GtYbmVNskq68VTEzG6klrxaSsupDUsO3GGhJhGgsg4K7QJzqw2B90LOH/Vh5ip50YPo1LvoXoKDFiQ0ZfOFegKKcCnbBZ/9KkG/STaXoZOCgH2NLCq7pE2PPhtWyG1sapdNPAO7ota09OYaoeqZ3tRMGX9cDiyMhEy0vAqlGTcP2RTua4fZhlrn2RGLtli+xxy04OoQKD1SrQGf1xnqaWgSF9AOu+pRfmGdx1BfOmtwtJ2ZKpiMCwrf0oVcZRT7bTOA4nl0fV7FynNqW+jGx6b1MECtJoheWmqm07y2R2e33l4CkRH4hC64YurPHkD3mKMOVJ03H3DtIluj7h/L3/VFa1i83o2B7LmrcF6A7XqhDNA0oYuuZgfbXWQ/VazSG3NFjS7Y0KPiHWlBTEdjt0UpCH1djJ4EqQdjUyiNaK0q9hwRiqhJaVNWZy438ULT3X0EPwat8t3wn+GnWOEtF2bFW/Z6v519DUeJptNlh+5HUZbxJCNGjwT5qH3YLzXSR637CEE8rdjmk+N35QWGj9ehbdGKtOhm1lZIY+icMcqruE0NZcL3dz9MIJYhHI0bKHegCqOuq1CUIdwclB7+IxifmatHWueW8pH6GxAvB8he3FB5qqtQW1uPM7qK9smzW4epr3gHTSqvefsSkBoswbH2TbDKnyO6BULDszlemfx9SbqyS5LxUYqjYHIqqKYbU0dB44zoR4QVkbJDJwjGDjAcFhNf049l8TlOa3WnV2ZfFS2SZwMppSg1WKM2mY+zmPfKvLWY9JCEUOwYJy2Ik/qJNIQmDCvm3qw7bKCL2Zn2Xv77+imUcCaKoUUzlwf6sGiy4oQlVvRrnX+mmXoRFWzOnU3tPp1+Ws1kHpn50J2Npu31X8Oy300rk2PRkW4SS1BP0LP28L5pCt9dIcZRsRxGuEYKG/pRVFQUjFYqCcwNOvIsemeNfJVmju7wOQmNor03vO8eGsmEKmKX5DD/mr8I1ymg0LxlinP8piXzQlFjAWmWoKCmhFMVI94l0G0Ck+dyBPBwmimBnTmoqPRdXvwc85YZd8XKzV7qOFWn1HWCJk4x8qB366QjmpNJFt7eLWV+vwgyK/kGxFyxvQFYpRKPADpc9VTVjD7OgdaQLViUbBJZnpJPjzJRTYPZHkqq9s+yO4scd4nZqR7pun0vQDlEwBjr3Suuf4rMSzzR5jVY6M8KjmiO+O3QY/eJI3rlZ2WpIVN2j7i+1Dng4MoMyKUUuiCBTDwAy2EtwJl/ZX30LkOazBxxZXNfBY2EVqyQ0OLqEcMmmi0INGh/zs9fUT+ry1s0zLGS+Loe+K1dKUzAKYOPptpBm6ya2B+rP3eWinQHA+dOoMXJcKdmFmQmIvfKbfBFM0x3jkGxNfbscpAu5xEz/p1GNgY6Eyur14gePtonvqLL8s0l809UTp+IY6g0XHPN7/ZCMQkDinI4FKxzyOLb5hsJP5HJ4nXleTJCAQfBGENthmRNKqciRDK72FgInwtKDx8VQCCqXvJMhvNoetYgNw9kKxB/cjlDmvS910bUK31wVDCeKgOTDX7fenLPCMwpdMxv/AEwOONHy+BuS3H+Ia1iZh43pxP49iEtUDiyCY41e7rFH4CEQkxLnztGS4Xy505Nf73FEtnu6bEP60nk8k7QDjXdyrHAFDhkeqX6aAisALiVfWrfPZ6b7K/90GN0h4NALTwhZb2/oqTNLfv6dkwZHCmXE3IagJf+rRsfc4iousnHYE24ZYK3bMpknuLh5apgnTcc1ji/irq/qJfTSUPV1X3DQPALXSWMuwTdiwedu5ytjKREQIslF9L/1+v/cIULz/LmlmT5TnM4HHJqf2qasMGSLRJAF5uDToZh9rYLW6Le6LOMjBYBX0868BPRwQyLFexJlieWAba8SFfUmNqzOn0bsWoUgULI44LZockqZyeWbTufCsu4/9nvpHogI1NxhlDBdk+HyCoz6EdQTdC2c4Jel4TOQdNYhJ1Gzr6j+MI6rUnXWo2KWGZdkR3EgW9j/jMn1qVkJWApk9qtux/OXR+NJx+GakYFqv7WtOGbgTbGAFuD5a8uYqvA/F1mPHCJbNFZDErYa2t22TI1pdhibhqw1olYldGblTVMmCoYBtd/aOYbgc5ZfGR4CFNZM93E6DeU3i2pPsPPDKXe+gL5v9bgCt5D+cEWuoXb+I8gqnDrMKQjLtazPwrhhzrrdUsL9j9piqqB5Yd20NxDL3TJRYxa2d3j034WPOIG9nzKDg1fe8iYO3AyWKr59DGQn1is22zrxti0q2dm/cLb2kPpzIgHoI21R9JDEoxVEzMkOYKE3lj8DYrsJnaO9m1xB0G2BYGqfa8eOGrdrpSUSTvz1GEngFn2wNvLb2R25gS9n/PNAm+uzqKE5BHSGPYQOHJk6zT9KNM2laLbbMi1qw583ehs2ck4ZKEZwvLIK2WHGSzrUZ7SEQFg+ZTNoQEfQvfeNaoViAijd6Q4MHmfGoBXdM7aRHl2wuPj3cBsc0BFWL8JPN9cYHa6vE7GviiWLYGgeMXTHnPU3+c8G07XpORaq0i2BDfiLq1ESTM8zomMECCbNGgQ1Ym2KAFrnQ0e4Cs1gK9uNgtheMh990Ra71u+pD1yilaxLl3hZnTBU3Cco/XqVUg9KekCenLtDqa9wNf3k1KKpPhnlkM3a6eHMTPOTox4dULNkTKFgG4OxoiJF3FKlldlHo9fKZz7cPWj+Wun1LKYaW9xaQjHLFq007A5odcrXVMYyQNOlg7qv2Q9Xc8j3JpzXCC72rROXkwc4oiEYbfKgE4xm1hMran3xPAbgknOPCkmPLpaoj0nMg+veDdO9SaUzBB1t6qlb9wflbPCj5/ZZ388ROMw2LIqJmVTsF0R9G6k7V2d3w9T6X+eEvexj+rJUqNYh3V3BPbc4ECFyOUXo6JCJ31eYNpRfPZEcBF0Cml9QvLcgOw3r3EmsUsQnACTC/viQNXDfFnK5yBmyGvOwDZ/xNsEkR2YnzqYjhauaW8eWqcJyzZbOhhGKuKnGdaZ+GgsErK6/5NIkpvNLWZIHoyKuKwn2g4nxnsBki0PgftZSO/HEjT3W1aZrXYzBp8dkkgq9xRvox3OIX9NdsZ41V8PmabOEErnmVoHcgIk14ZkW2bMOVBoS6aUBdFnouvRKvZVMKJ9QHwUd2vYW+Ot9Av/QFTbkZIdlyKIXi/cH5rObGDJrGwKzCwzrLpoPi87G04h8hOGv+sAOx25r1ANnGUVc0T5YatMmOOdcdOc5TxFbWNuf0PcqOlSXoVr4IwIJAAazziEZ4LiBPxMYe5O+VoqWGoodMv9KgLzWk5LHrPYHBbPxeYIwl5RwuP1WVh25y3tc1UIhSRCKLJ1WtuVyU4ncC1NTRmNzL6ah8mpgm72e1n/e8fmZ/SnCQfd9oyvGZCwVC+mvnlathu+pWHn8Yccs7SXsRPGxh/6Qj1+8azkEp0SsVwr3X3e/PvCTaPv9X1Cne807eC1DqzxeDTB0fueQoea1GoR23Tty0qRsO8/wkNrHSAuOpZp2lpOXnlbvWR/eBuhT5qJxseEIM6WgRXJhqaJPxSFxYj31C15YFRJvICeK9R/q8k/AgjJvbcpMT4qC0ucCiX2fhhmJFSIrzVO1ZxapiFShHAS74i0LHt+15eag56cl7DQsTKjSMe6IhxzHXEFGBBpYgihIhVIpbp4GoQQLGoJgh89rtKZgn/JdTenbYf1ZkF/v6i8METUeyCuXM5eZjikj/CntrAhowAFF/DRENDwkNKf0V342BLn/KPeOQp0YoeglMpSvm8zLIqIjhVpDMmsebd/KPAUWP5dFRu2GQlMAARsFRraRcM0GHuK7WUM1m0bQ8w2oKUskgdaP8+kn59Igheqg/vNgXUC3/OUr6puGfqbj5oFnuDPb21oL5O0ACHJjrH1ZYzqqCHTc6JlzZwtfMA+zcoDKLvauBKaGzrm+fCp7AZ+QBQETYmhonVaqgTC1N02XCbxVGgogqRBRHadGsuhpRY4OX28cHAwoewwQRtqBr0Uro+HO+V21RAR9u3Qqc+qxoqm4G6vFwe2UaQwZ4deWyN7MOnmJooXqSrH+ACRUxnsO1sB2Xq3p8uvN1xLrz0nDQ1bvgiV12XXqciiEEbQCzotRCTWYZtHLefeGfPwC8OoANaTpoLPTt0MJhJWG8qivrGVRLGLsClOJGLGksalsM7JmQmt92utW/zF1APBKmLvRplYq25/t+i32tuwPyze2UWVabikp5pvOZgEBCRrmtb30eDRozgR2otGYTMLSpgqYg9p3fpZJZBActIYxY8Jbw25sXKSkCB4iVTZOFFYjV/Av77HU5QZvmzDxcZymsDmirmqrUqLR5lVZOL7EiTNcqkMCZ5cwfNZPJ5x8f3dU5seEli/yixBsee0XrI7ANTq9cyFhmFRFX882FImFpFvT37sFhgy1ygfUiQ/QIsst6jsOdSgdXmwjWsHQ3RLW2WLO1A7vP4Je40xTwuHWTW5sOlqklrgJS7E5xgqd8OS1K1SWQZs+UZ/L99GUxlnyC0l0ZxuTe+71knvDi3fM0EUO61Jvo/1TJJhbOy0BBfhL9Do27fme64BMDzBlIoBq5sWgxMHrwfYLW5N7O2jt7Yt1W2LeavcmPDyxNa+8OaK2iGhA3TBJsnD9NGKTVnNIO/LIoK2yE64xHIBwT+znqgEFAeHiB/FVt0q1m6RGQRm57GeY7PKK/u+nzw9cM0eRqO8p8xPo1HQV7cSpxPyIeCJq1S9M5299hPS2BozgRk5lEEmOelY+Prhu4drFxhWjpYFTO0kRpeMDWfFhHHLdvg43IM1EwknPlLy/JIoH2NhERpkdusoNRZ3kZVLIT4UoEI+dIoniSFrey5LtK/k/EdJVBzhbbWgQtau3MDjBWl5fi7cFyYhy6HqSK9r2u5RchKisQ14E2dRLffDLKWeq69aujLaNJAEXh/TKZ0GmkD/PQJRvhRAFfeBMkcomp9m4Qei5/nmBoF24fDP1kms05nPlyUNm0iR36MYG3Ky9ZPEOOC6mj7qeXXpyMoKpqWsMMa9l8xEPqhHS20Bcc7npI3ZM2GQhkIU8CSytnQgU2OZLfV3++QCOC3tVWdYRvU4kgNXygcKyu5a3H6S4BanMnPjMuFnMGf4Bgq4dN6pdPlYHPhUXAKBYfmt5exngtp8LMwNThFJ6PF4If+dBQkLXcRHCRSddkyMGsuqWGQqHwCM4OqclngmU9MTDBV/d9o7mWYZIyUPEg7rXWTegni/ehyqQD8JcSz4wvNvCOgG/q271va/O64PlrK5WZx9RFLOHQcXa+h59oxJBXRygE4wbdn3BwRp+a7537Gfm2/ffGpbYzWdS7blbHhHmKZ2fo/pzBst/PRJbb0jheShQu9UgmdAQHz2NrQ6Df1aUU2sH+NnvJBfzylDbFqajNhIf6BUcM3+8KxQkjlc4p4WLbNNNqPYu+GNUqLVrGFCiFZ9fLPyCL/xaXH7L0X9vjLyousO+xdVGiDb1IekdGuSVwnIybADHfFu7oP5C0DEQL9NHSvuvrwG0yp4P8nr5/2jP6H2JXse9MKAEHr0ax4NMtlhbiYETTckVI7FeMv7k04r9sSnR8/1gDj9wef4rf/BpXgmRJAMYW+Qd2FYU+iteZsVFOHhJs4qqHQ6OuWF3i1ZbtOUM2FH5qJt1lDAIyhBJfES/K4HDniQU29N6OAZ9HzRAkoV0fcMZbFH/CZO1GEDO5OTXolWitVJ6rdOMnLxraY6g8TZClBrwZdxy9gVpGyJK3vcCiWiLGt3yRpXCk2eFSZJ71ncHMFtO12aQIIEuw3KQXmddNYJHuzRUavZKSpNR5qMJ8G1S6fYu12c7pQAZLx6PBp7clfqqwf5FNWjPG557XoHVHPhhZabBClgcwZbiRo8B3U/3YkK9nwNSCcPHfk2OR2qSDdItWQGIhSorqlYf4m1csBOXQpg4fozVgV8Uf6AECenrMHkXVF66L6SV61oEKKtHrYkRZO0A5wdjKsHY8I+kj6KWJBnxFSKPItLsvsO1ibAzIdTMBDexRTG2hVIKpwpE8u20RGOK7AcWrVqDg9IoKAKm2RCsLqcaiIdhh2YZ6Y3hS860WQiQHSZbVkjn5XRWlJU5bkFtHz6aFDTvUu8yAgI6PpQ3KOYtG8CMXPeS8/0zfRegs7M90b1f/XIrOyKrS2kcDBZRzS5mn34BUuYcBdinQUUpA1C9VQjI52AvYn5Oog0o//zUbZQF18cwctBmNC/hHfSIpqabK9H6mkZAiO3tt3MW5srtZBc1rYAmT/KVkDDAMQG09S/vWftheOOBbj1yQu96o976uM6bd0TQLSGHXCr/EeePYGXOw6HPv1yT6G3+zZQ+sqw1Vnz/tnjZRwxxUHM45eGpKcwW1IC4VoLBElkWYmbZ6ABXZ8sqdtGjh8c33snMJ07EhAcKbZhmLjNj6d3pvR+eHpMXiOXFpnUCTa+xZourWxytiyblFW/jb754HHzn92IK54zXBtzYIS3v6zAvCJT8i+5+nwOlReU31xL35zjqbqIgLsAkO4RP5jLZjLd+lN6ZIwoPbOyoYHMRoUMbpCZPTyibLvkExKXNFzVAj3MIyBEOYzO0wjsm825xZNILzh1awKT4ecQ7ny3KyBQAeyZVQyKuaiu+HQygpkvyes43xVeDM4Uai/QBHrUC/Ydl4/ya/lkj0svjF480uQ+y3F5o6sK/hpKCeqFZx4YF5KW2DQJEyWdBFZuiD2fYJgckV+CAzAf2TA8TTTL0BIAzcolJ57C7sCXj0gQIBJga1lX6Ahy4fuOgiaRSxAcykz3on9wgdglgdgrQQZxamD+fHsuICvxc8/euBZe8Xrzyd+rNpYQrlHGzvxSdM/cw2iM05qcMElOvOOtC3m+7TrjIw9CBqkKogch5YaarPqTMAs9DEKC9vchamlVoeYCOIVpS338Abzq9S2mc0bBOBU9rOYmQylVU1QL4rrStKLiJEFzPJ9I3zO+JPhKkHZejq/x1ramcD1uNrEKyWkQoHIaFeGG06PTo7f8yznUd39B/kBYSZ8SKXAuQOH6d24Ramv295w1joMK490bpd8SuBZQBaTsgfzUZFQ3XagwNDYevsDd3Gv4WjTTm50Y56E4HY+2R0tWwSbDb3df446/04vbkRJFwIlxGZXMsowWg81HmX7VG+yJoV0SjY0XhNucD7gHwTxdtCMpllQ+73pC+0QroPkR/11d1osGgfg0S1f0EQGNBb8no+++yEzGi3Zbh6SWk6UkyEiWO0Dh8X2EcjRSWt+ASQJGMxKBCdZxmdg0MdJ7lHi7YRuShx0HOg5KRs+HXo50/O8xk7Uz5RP76Zh0KHD2ZjJ80VaCzqXm3YOozyh9FOCnDBJW3Az4OdiCtznXbVwdxB2DdSTM5LKR/wN9fqD1AchuupCy3UxJe94a1zRMlRO3W8wmS9DIH4nP+lAQ/4vGrogPbp/ekxN19QOpSnBGYOkVOdSwvaOt/C1C6WhSOHJsK2d25J+HfaIi02vWWndSJ7cjprEbsYtBholfeKhp+O15z1vDkclwsIGNi6jP50ZtfHdDiN9GjDqU7MotZzhGCE/NBx2kwVxQGdBTRZDjxAWBZa8jSS58iYh+w+tT2+k/FKIMy3wzbP6+ZDKB0QKulEHn5ZsjlwYVXcdgHxOF76LN+JeYAx8X3NmigpajymC304GAFXky6gbXSMBtF4Y9HMptqTEO7k+q7lk72jElxkO7AQzhBTtqgmVpfvZPgIkh9KZpdy5ufXbHtVXGlPZPw0N8TaiBo5SDiP4WjwT1mySu8sV/Jb/+o2XKq/NrJ7Hpp37HaFxvBHHvk8E9LnGdOYl9lmLxly8fsGU29w3EBEMdIsubAhZlvI+cjOXOGsODaj5dYsRuDM3LVoqv4hla7PBgdL5hkH66q1HanHOindvz1QUGbGzyQvjEQZfzB0CPjdlUXUXqrs6P4RTwqNtZn/3808YrHhylLcPuyM6DrF4N+UAUAKze3RiiqzSRYvZ6bpnpumhoo2jXNq2vmfLTJ1OnwXG9nWxvEYC7DOR+bUbi+TkHfmcFQhGl7XD61yjHmD9rL3xoZ5rtfl1kQnlN6ZOCF4ceTPjOy2/VZuwXe8P+hV+++1JmOTWw6O5+4V+jGHCNFFKkkdFw4wfIAUGff2yE3tnp6e0c+98VxDNULvTwyryFs6X5Wxm1vOcc9RQ/sYJ2ZH3sctkp7pwoIV+Yx0ht5cN6FAiV3eHCDlp4rYIMXMqF5WztdCu0gqxjsUbXntLClF/xU1zNSFsr2wVhbJ/aIfq7XDDikmltNT1ZFfjFTDgoCyzpJBIiouj5LJOHYOzVxPKNK2pDwTwhS7ysRzLhI+kuq0Px7Ka9MqzLo/I43VPQh7k6cpHBOEX/YKOuS5vEK3ViAupf8feUNeSnb3i2oZgwiFGDbqoyrRFPoy4AWAyHh10rSAq5Zq3q8jPzTulVEaukg160q9WhUakSPZk/s+Hd+KIIM9ObTMB3nFft5TSK8H+3brfW6aodAhh9S3FpDg6Mjq8bCJNICVpX2iv8GzOEeMNq87Qv7PcYF3RpgIZIOOwSo1rcT2K1DwwW2WX6y+yC4hVU2RWduFapZdWagW+6kezqnmbE2PGhi39u1f1CRpE+M/34Iod6iVooIqczJ9/Ph733fP+sSPX9chRltjPkfNXjnthuXW+vHCkiiQ0W8o5vIoYur4BzQIbNmt6E9Y7veuzZEkF6EtyYWdq21lHYVblkEDU7MjSbLHAnprip3ccOOWtSyVoyS7PbznbmO/ZNvjXjElGpLMZBjHH2YrPWK3tmHI0m5j3BbRAm3CYrfV4+LLuwmldx0ZwMoiAojY71QjYNihXBiK1fnTDquaoNJjHpvJRLYsIQNgEGuhXdYxhryUIiBpSVTdJrYczR9jYEonL8E8OCgAjkAWkxqhPek0hIid3J3I9NbObO2jh88dosv8Oqu0/YA+AcGfhYadQZlt5zRcMQ8z7hkLV5mCMXD4+B7Z2reNpK/ZpmJ7X33xQAFeVfTvqr/LJYJKAMTvFICx5YQP/mKrcg4bCxMa3uIOhthK4sixXHFlUgzZUSdSLhph2URBy5CnbyqsYlZ2DLTntXuJwaE9ATcyuZqDQrcinDT2m6G9IEZ0F65HZITxOsqqj+elKNK09N3pr4K61vUD15MrPEKEb/q2gGcGOJIHerfl/ZlNaEhU4a7TQjjh/fqiWnlyyW1XWkmQhxQbm8MiuJ38J2W3pUqMvb/J1Yhwa0BRnsg1rdrLUCAcL7GpGo02x5xVrvwil4BhOMQHuPK4l+Trwx7r+QdB393b2xljWiB8fJFw6X//Guw0Y8r5vgDql7O+VaDdBNW7AsmLTdb6Mh/HcCHE4uC54PqEvBBnHHz+bAN6f8ct+O7LMj8pt4jJuofT3MsOCkw9XO/98y2RbkVRSJp+f0qmFH913lmXJsMilPndUtcwqGgmZqHeNOk6cHXNrOYY/dlHassWeBfUyLkMCuj5YhYYsXgYoMTorvKIOoQYZ3v66JlBkBj59uQ4paEM0ltxKtOyyQy7A2cL1is+zWKy1dsFECBEUOJspBKgJZXIVDNq3t14kq2Yb1McigjIRmLvQJOILerAZOQyJP+Ymloq//Yyyvvq+bK2zA6Uavq5N9UUNtzgdmKpiBhl302t9Da1Ik4MLD9nsP9Ay3ZTed31vxwTSRvU2Zzz2Ux9M/++lI4PK8qGcvnHUbUKb56xgpl4VMj7pCkNgZX6hA0rn0DDgtPkcH7tY+nEZkeLJ4vLPNDgKc8cZcL9YnegXgRu88D+y7XcMiZU8o80J2EhPpPaxcluV0d0aXnVWWmpgxxfrUj/u7JGD1jev6KE4eQWsxtAshKsAfvleN7ZmjiDpiTSRssfAa6fPwjccuuS1S6JD27rYqnw9vOUTUXt3mMGrHyPN1qcuLZQoheXy99HuSGG9u++jixdJLwQt0YhPQpZWvj9HwiPPEGk8tF9SV9vetpRO3YR5zdPedX4/qEVHd4TDJYBTKJz+aEPbK7pboQRz/yBH3VH8VlTdO4hyvCNL6Mc967kkb5+9EDt99roTQsJSiFt8gXdMJvVAAuLp+LpFyC/br2nAOfMeA8uAazMaphomutt3DefZtvywf1wgis79IjpI+vqXrt40SsAtUQwH95duJ9JcorRh89rTotYJvSsjdjSOO4H+hMqyEwk4g4vOdvbys4St5xjK01mTra+PxzOu7NG6FCt1o56hONSXhQPbkarkXlR/0YyJVZLTWrt8bGRrhQuf+8ZVXG3cN1FODa/aPxd3iKmJB3qcz5uhe4axKQULwV+kDYWFspu3c3fkYq7IIR3u3RXSiNTna//mqIs8yeqpjeGBDMYH6LTqF7jx4KZ4xWK8RMAJTkDUoM8ZnePApQRvii+jkShIB8/XtxfkfC039RpWhZl+pK6LbL9RDaAsVd/5CMb6qIVdkZRhbHJChLpQ2VgpWN0wTO0ZqzFsg/zQ0yZ2afrSamVOwEcXhdx5taHBfgl2EM11wNbw7Mp8G3fIb1KrQxt6i4oWFbtUMw9TzrOjb2Mwis3HeThwaONDn3SRRwwV3vDdw2g/a7Bck6Corknuod1hYliwZEwqlZEizr9kYt55ehMjG3Ed1GRiz654nNk8t03zYABnpg31yCqFNgYw0LyWbGfjrQH+MXRErDOj2mpI0Ex0T3FfiZsmMmLdiHn3D5PYw4NXVp1V9vuAd6qd0TZ0p/BO5hIw3XZpCZXeuPehRV8on0SelIwAFLPscAKLhdxXSNHB7XGwsaS8IhHlJe2M6Jpvhpflgvl5XLO9O57KMfJpYLVkdcPv3wrA3qQHuY1YdmNauRllmtsdxZWmQiw/Smo7e/BqWIFOVAVxGGxJ7TTQCT0foQH5w/K0jvZmtFCRmyrovfdU1mfmq9sPextCc5Qg5OGyIoARTHj3AeI8kGM79TVd7tHSx8oGvY9t934sShtGDY1yqGOWoHBLI12GhN6fgmopt//fidBUu2V4VKyxIj8sQcvWdWmQAK0JjVCbMzRRaKfSit+sTcuWoEpApIUbV0Dlr3Ru5ttBUNgoUEleTgeHAZfIaSszxt4VboFbOW20wessAeNglVMn9SPQPSUUOMZENWETJEUAfR3cFYS68hQwPuHkN1CshSVOdkbvIuXDyGpd/V1HjgORM7nP5Nifp5xGckIHFKt0cV5YJhH6ey6QfKgrxylh19SEY5xHoXavDE/+ShQL27KAzdx+neR+GcZuTYp0eexjgGx+9lnVZX3KtwFFu/nX98sSGQqLGLEr93cbjwHCqo7v+cYV7+3z/p42ni6a/x2KlXRTemR4n+JHTPDWclN32bRVOvswAWvLL1woLjij7SbQ2xGzzjJF8a7rYUk8lFQKbX44FcIy00c97UFX4n5RepVtSEnD/K15c6akBly3IlGa9hmHrT3nEISn/vM/4ksq2vzt/HtMYWcLJRFfiYKEpZAksKJypK8Fv9iJCZfQ8CreEbAtZgbaoR3zAbCKx9ngavFt5LH0cKkey4kYRREgYcWJSFwMA8V1tX7yaC/DjdT7xWkci/mxyf6EkRf4r58hKOIY4fNpZm1J3b9tv4ix9r7RjuEP4UOCY3RznJsgf5Sy4hlmXe/gIonPSVDp/AT54bW8vA5d0BXGpz080z0aTYHfgkJPwy5gndM0CA6u5pGPd5qjHjonUX/dicKAjQu2TsdyvPVkMYB4NOMUYT8ChExqzC2DWBsoXOOpz7g13o3+KiRsBG99PdFNSsKVythlpDgQG8B5o1ojBsdRN6fSVpa4bJipge0+fOz5Blckm9Wl5mFBlCG+gruT+OpzvOuBRnb7Tm6noehLCTcpGr+qBrn7WLch5NS4VIlvWGQE8x52+JxGER+06avqtVG0qBqlFQy0KMDit2HYprFQzyKWpYmr3MBx4qGgk+L953utqwASlNV8nuzKy8Ad30S1UebS3q+bO8NJWCI0RQETtKFEpn6ZmRyAL6RtQrQoM6pXP2Hz57PcNeTYVshMqtIzGX7/w/5C+yIeRae7mbXpowK7oez+wUsutBsqyybyBfHoc6Nlc6qgWl/vdT3qGQyS4kK6HEC1dqu6/bK2ms600MvdXbrc2Jyu0PAWVRMha69TuOZkhk50/O3EdnFFLBzTBAZm5pGyIVJz3+QrukNoduuaNJIzmAOosVFCswM+QfFz0z7Fo5tU67E3k5sKRm1/WRES7u+P/yy10Vj+qMp1+BiJbIEFQx3q0+2QoHxkL9mrkUNi9XsaGPrLB8Gw2z1oYA1uil4Z7OSbfDjNMbWMPaHuGT44X2Z5R8NfewZefRDcXDjTta1syK0hDFdMHyqB+ygnh+2KF5eqvdtcmB1UOvrmYYcIonjdL6xKZYtVz4GNwALGn5IOD/Kt0BVXMaAG52TpCDa6Ga3IE32MsZtvSBLrev+ANhR7VOPOsWO0KDmInqWp2NOIyyOW76K3fLMAyEmXSstImYY1z5w7u1oYMd6EwXHRzaSyrLlOgA28+28uoB24ibh6crghTOpCq/xaH1Q9jQxOabXE1cs5RVd14E2+xWaoNlTEmzVhqc1RFEdmedQ4Ugg2H7i9elHBK7Tm0tEAR9bheqVxwiol4O/+KiAHGl1cZ12SSRDJba2aj1QEeuApwb6fXEtirdyzWMFe06hU2sJTdG2E/Tqj1WwUQBwJVAsx0Bagn/ME3Iz+SdDCOcv8GnKnG523uBStH9SOXMrJYZsCjzuvYM8mc+vqH/1f/+alOS+DtGWLRugdSL1UJkMGekYqsGPZNW1t3FkYA6LhJ8kLcfGNe+8HpOXuUj9S/5H/Tw5R52ZbiYWqMvqyFi8aiS1LxxftwpjwsgacdPzsF5KkqOuncjtECVPxPKduN10u4hVHPXRwReJ0ixgMwcImVcTLxmIB88JJlCA8zFgWRNVtxS+stlHxWkdi8SJ33vwJDvNuq3jYPiOrQ1yG5X6APl8JyCgX6nsqoedXDmzKn1Iz891ocN90cZFDSimvOoykUFuREmgW23Kk23jspu0A/+IoVPJ1sbnPW/SPlBdD9lVsx4USbp+haP+wm0WcgMvCRv9QWHhTsfwI1P5UpsMe9KzYzs8wSr0ix3j3bveo4QmmJtUpeCt7asvjw2EQ6S/d4ayXZ4nBYynzdVYrWWoDlDwGuJILJGa+yefYWNPAY4HDerBb689nAHxWVctFx62Nwe5/KNADm5XXajCwQvy8k7NGRUzLRnIEMWuJhi35NTkg1B/4Lh3DZ01njunW7rDS1zC1FX50eYsKSMbIycmZQvTSePck+Rm4ODqdzVvOuqzbW/MFDnFXAdp+5Ps6RBzIXIcJRQHmIQt5dCimwTDtL4EB6dA1oeeClbWy+xClborWSdPl4AjFbXjl1GoWfOGts0AFukCPbcmdCErIegrsN9rcsySs3AyKfJGg8FY+/+hqRusoG3pwTq7eKkIcMrxF2gcG5BvwfNEYNvIuUp5cWGYIaxItVO8UlojsBlPDuxReIkW+5SZLEeTqpUYWT8L1fJpKrDRqetuog7sQe9YHqnpVioBbtmc8hY505ztiWpXa9z5fLhoWLi3hA94cyjTMdxhQrzpoAQW3Ij7Tc1Fb/c1qRgyDN6BF9lIT5DgZVOCVCvPZ4MHY/dc3Dx0ryXa4U+mmNgsLKvLm/Pz5B9VBUOUGlHE2l6aOieTy93+tBOvWsFHAi9nm9MqeIlGGTyzvD5k1XydP4+2Ik/6jy3FiwATaFSSr8vumZpzC3MWK6JiJ0MK1XmIYptXPVojEP1J8MD04ym3qjXzb/eOqpszFe+7xxvhHg3+7FDGgalEXzQtAJNRmM8ecoqc0d7PDStGWvrZL2brxi3DqfI2gI6jC9ITk5ZWqEOILsV1psh1NYuTbfXWDYrJQChD/urHv+BJ+yatSLD1x9Us/s5H3TwTb3GogzXjf6UBrNStArpGnmUcq1CR34bDfsxBC34SrNQ7hWsJ9Si2EWddVnt3InvTiUDqwwaGWyRvllvmZuoNAUe/ZkDopiuFbl9fH+M0qu4GottZh3+h/89cd9rXIekRx7QXY9yRrHCrDKmk3Q6sNd8CbZoFNjbEgutZO91+iJSZL9N/uoHxxkwIQEyDX1scdzUg1f5jQLWFFpY2EPGbGxSn8/VD9hueRM/O9XZokyuV5LnzIxJmGIqfy4GqqexYHHDPw68Ew5DpiHFkntLSzKII9QIeswE9hYd/TKdeyFPsRn9Msz50lEaVFpC16u9BCEJ4BAz0jHA2817kkDey7RMukKz+Q9HXGUYzJ9CSWbS8hpTn+r95VmPvYpQnEN2bBLDAHAOrZQ7RhgBQJoX6A6Rkt0osSPyARGIc6duLjkBdd9rcwmARdJiOxYFQnZP/9ciAH8WqFSaMHxo/7jVPpdkMxZ75VBbdcTH8dHgPdeo2OC89CvM4JdWw3i1uqnoT6hixhniP1CyKXhRHLaJqp5aDkgHSEqFSFE95fUHViM8by7lHQ+OIpAi5hpYFLvpvOlM2PGdBIAUXTbJcThHzgzBRl5Oy3Pqy262/Lswh5pcUN6JvNkPN9MclIZeK2x7kcYxX7d796Q5n3ErueZWZnxaI8gbxcbr5cfrZL7pJxkvieXGOR9gEkF33AXhNrgL+W42WPWXhEMJCCfqZ9PNbCtwKZ+/Nut61YJsTwzJuA3mLDTz3/v8F85AJ4O7ucNdpMkQw9fH/HDg68vjmVOMDqKWctqn2g9L5whpnyEhneVoUq2/fo+Pj4sK0uq6gX02GHYsbnG7aNuEM89/oQ88V7ko0I00aQG5jcdVo5s0w5mx45Q7sZV8+MOH0/GZHW32CbR27QY9tZhlT8ag8PqhTHkMGAeUTO4WGB57U5+jRDOTIyT2LQaEC1QWYOU7Rbqp63nv5iw7eCchor8riTiiY3uz7iZEMA9FFMGOKnzUrko/RN2AbMdUodrgHxnJj1ZwZisD4DnDuXwlPWd3Z+AeEpq20p3eji2MJU/l6LaKstJtsEINm0p6kvKzWRHRmgziHfoxc+INBGYLYIu9WMHOdB+OMbWTMZ/Hnx9LEiRogBl0FX62+/cWxviRKL5nmzrgY5AyY8Z2lONLx07D+mvFWg8B8EC3e7RyggOHUJGZiWUx++7u5ewK+ffhZw62ox5E5cHo822TjCOyT/CyvmwEkgmiLM7GG3zT0ixHNP7o9NtO1eeUFPZQ42GdUO+koA/NxXRsHOtwOEV+x/ja+KGf/ap1861opqH+8wK0BJqLz/eeSuehvB/Lf1pP1VZ8wJcgGz/040rhmi7WUeO4Ji1jI7PKQaZJhWkw9fzQL53UynrFzThPGQHLhQgOS9yVyAEhd2+avj2Pwe2YBKifnReiR6n6pCiXX0ckoQ7oDqBWBAYXT2qxHJO6lWWnf6dG5WQAon1a2WsXAD1lJjTZ7xYWR+oa/0iZ9fEOpT6l5Z5PC0+1us/QRZ2MVHz0BNrE5m2axa35jUqP6QahLselQSajDIP1ZPq9vd6R4a4BUgxssPAFBjlIbsfnAwI38wugkVLCnZkr59y0LpixK5xLEZsfEayNFaByaV2tazJDeft2tDeuKemkplx+eu/vXysn/WF8Sae2NJlQhFuSt1GfeV7uQdJi6LzUAFtNcUbhKsP+ZcQDdbEl9tIgW0tz1aOgbDLtqvb8Au0gzoUOM5fFeXpvWHDWCdh5hEQqqXzopdjHD5ffhb//f9vzoN8Tv8Rfp4bSeA0KxMmSMC4vz9wNobxBBsqLlQ/vAE8mCyldRctBstGOigU4y/od4bF7Q2MV4hrlsZxwu9RkxS8ssAf+p2JlVQ8QRhnmwzdzYDKFOX5pTPWgU04Lm7TPzh+PPgHKnrjl/hJDpMV0IEOa0Mtj85iu6o50CuWn18lJmLfZeVrEa9vwXQUuY7+t46kaO3OvLWmnU75NWrt94hQwVO7nREQbxy8Wz3eNDUyS2tDFC0Fdc158id/MRkJedPEzzy18OHV8ZjFP7BTshdyDtv7Uwl5sk8dUdYL+atMRykfkGOPcZfg4c09ax+fFRsVAH/FIjzA3Ty0r+Qtj8v4ncoZwOdEcsSkFNATuIy9k3dCrMoLk9HulW55OexbIcmyigavmvHJYshlcxgimOw20Sj7q7d0GnJ3RkDkiQd5jcYjW47+lRVziac0101J1370QVlDAc0MbgWyz12aHoAu29A04YZeiBpJH9d/Pb2mp91VR5xRyNXAKQrmHvg/nTc4afK/j3I97Is16L7rD+KgZ8Yw+rgqNTl1X7Dj1RGSObBH0wjiQ1qwxe/g6BtCj1BDhdREPJkKhtcdeZcmjvn878S8qq3qSOYJodiYqohSH9SUH+aZYNzUFPBQzbTDCou5WrCpkxV6sr09AtMkWSzNg/XBZsJcxra5JzWQ2JsgzTXkLh+A3hXWHb4wZI+Uy2JFVyjKWHaBzcbV+7Hv/XA64bJ0VT0hQhfT6sVTocI1EyNnG6VXL383YX62OjPFtFCQgJbRWaOtH9S8SRitNcym2RXv5I7jlHaKM2b6LA9ZqKgFDdaUHky4ley9071w3VdHr7A+yYrZWEeZV/tDzSwpfvo5mQ7rL+EQmRAHWgM8hDPYNcgb5TJyodYtk0AChiYCTAIsjIfQHdC0Uw1M0D2Xosa1+7FMCsJB3/ySLSOnsp/mhEtQ6OqNBtQAsOxS3FgmJTMsIKRHUbyTUckn81q62cv5R2MKccJO8ZDLL9+vprHZJng+yVGW8CWeigKRzSfKUjXCLW1TVpt9lhWNZH8pUFvLb7Vw3NEXJl+WEguYZCsuiJpPtHwZKmhqj1V/yaak+QiMcCO18RkPHsYvJfpq+FpRQkSy02CutcNbUUSKdFgxAORXL/0BEs4FuxOfhdp3rFsqVMZ2T+IFIW4TJWa+Jzi8zNNVTKipqJ1LKjoAdkvFI7HtgnCtVmyE2hjfKMInZ+jwMGg96B4LLLQ014dbsGZfN3+kLi39Pjje6BKpw4YxkdiDz7ix2D3q/3ZdRvU+46i+DiWNaU5PFWKtF8wqBiT9p7LSFo0In7o7xVdXoM0h0wmP7kirYVS1Rti1R0Hk9BdlbQEDuPisXY1QAV9h34/dYOePOjeRpti7e1XRPSHUNsqfiHiFEHHKmFTDQWkUg97TaB6+wFQdoNW/wEM5mfrKdCt00ORtqlmz2vLNX7zZt5gRc/pM21pYlzbwLL8PVMOCMWpZcBLjZ+M9rCRDcJjFybQQMfnRj7B0vQPBAitHWE33QbEaiSN79y4WbPI7jhWPA+6+yttbZmnDQKT921Bx8hLywSuhG4Iwui1E6z1yfFxb6S31wnbUaakLNPbDJSsjjNX5CHfzksD1zA+1vRTDw9GczkAo/rgCS6lDfb0PH7iQRlkYRUnoyqUn0qHMmKzsBeUo79ds/qi4RPaneNjMhNir5Eh2C1KQoXCu7Aw9WucMS5GDI/vKxzqxzEKV6otdbuIa0mL/zeRMPohg+B5x0imloCBLdR7p3X6XJlQq88LHUK4su+gai3LJQdeiPF81E5RYX8BXFQtiJlLu9zWStlZnzGVai29a+A0qyMq+aH3ZUhpI0AayGoLxPxSMNsILLmx5+2GWovy2GMeWS8Wr+Xh6JTd4sYkoq+0NMGCwN9vP/9Z64Xs++ZYXTm1uNwzFtq2b58gTVPIkhys/iMAyuUsks5nkzPvPvAl6drsD9UBGJIpYHGnMfEpsWzqnSZdrM/WR1NvEo0au6m0PPpp+QfukWVlv8iFQOC1940CRD1mS+nbA1cy4+LfgFWOad/ouAL0K4PNYUsZYJ9VN8cPcynwfZ3eM8ae0e2Iko0mvgLlA+prCuCyQ7/7l33DZXiRGsIw3D6+QgGGDYRembmkJD928ijFD73ZkhKKzvHSplJ7dFAqM3Z3DZLCcLyXC1ik+Inr3RDHKfijmvXK17ddIDBlT13ykNEEvWvXWCWnXIpCGawWTllLfFVpUWgIAtN2T2cqEL+HTUwAxo+E8+mv3C22uDrm/P54PAZ+psaVFlkJIMn3dZSFbdKiW+xAg48Klc49AC51AjNRhmIWRGdxUcVYR8yapGLiz6Ro7CRRwW0ng0ynAttclFZqvDuacJ6/xZSL0eVmaeWdDpG5BIkYXDHro32PaJcIwl+xzd1F1NRLtv9vj2GuQjR5fAhymTXLsGwIaBSH2RqU5/eEQ/G6lxHw1d+zCgx/uMfNLhjl2zbqDpEnT0RritP6Q/CGEkDv1i7ZotvvysaEZdp1Cd6ulgjPajmDkapZScI113BJQ29wqqOcOs43oXUM+c42idGqqExsi8pNVhinCXprGlmKMC2TBeWupbWGZsyugFX953zSytgLBcIRX3mqdKKkEEKv4Jtui84NXIU9Fr6Wff6T+iv6O/GmpZFJ1TW88Tv30JO7jUjLmvyhu7If2/EIsMShsoQxofqlwbpHcflRFRTl5ObneL+nQygbVkwnEMMLOZ28htAVqFCT8qGpIY7kQsDiEqzdyuKyez3anYVRalpRo5q00wvNc2HlfpjLS1HeCDBxEQgtLznzTcgR6ovTql+vqayZOQR5TPeZFpGt19A5A3bZ3tA8cmNDy2LugMG/u/CY1F54atVi/TIdrDZ36XmNcQndZvUjfiS6mQSOxDiIBGDyMMxCdjxxrhnHgLQxLZSs+NG+PHFyfSfk/jTTYmyCPu7DSccZHEzKy4iYEBrBccJjn28m482Gf62pS9IXXzmK+T/3m+rEc+N0f3DNPj+jC4yWg89by8EpbiYEqn2icJM7QrddLJzyOCwwuQracl1ism4Thwe3v+URMvckzyit1rKF623EHqWbY9DDboB9n926ipGXjPGdL89vKhC7cyRtJGfOG1AjOwkBgGYbjKcIRQqW/iU5jphyAL0bPvfQERdozM6AJmhvqcpSxv3A+mJMVpBDLTFAL4WQ9nC2tQl57/cFmtkscHzpqJWBolLoLWIzhJWTa9Gtas6uemZzikoDge3XwxBLtBS0lIZQ/2EvsAcJRPxJQDBnKo5qLl1sJx11q2RFm64PU2Hk7SwCvjn+zSfostzxxmlIKDCu++cKErxQd83RqODPpFdFQbym96D/3DPU/9mqVp/eNHfKQXeTifjBp+mGBKZJgEVZ/jJ77wSJ1l/WqgV6DMYn2kbFdxTyJL7ewdhz3mKOhhsA88cm7JMqxD3QI6fcHVevlw/BQTl0WVZMXw0xOBVEMoMQG/Lmbi1ICU66Hm2OPEOKtX5ChyAZed9fUsSqAaF1qNtbB/HhREIpT58j+XmxWP/usu/7JGdhgp5xEAkKo2LmjPZDd5yc4pSeL75c58Dqn9NcdjBwPafe1CB6+59cDNxQkwoWXV4/7J1W02b9hC8UtzUL6U/Us5tKHEgwSb7AI9EHxq45BWvSTwxQTUNAKIalqSa4oyWk3eP5lOjolWiPxI7B7vAwJEQ0uh9VClrdRoZ8gY1E77H9UpXYB3onLClYUIjPa649C9g1nK1u5N47N4gg2AXWJJtEmNcdgRYefhjS/60ts4ITuoVlMNxoL0CNtFDof6Q8C29JeZdqRGg62Xk7hd9Qn2c3aWW4tPSHLgM7EKQkZyhszU7VyqLxCLZbx9THU8xPuR6K24S4Nmu8tvMB3yWUU0jRV3oKvJLQQ+dadeYsSUK4POYTIHyyJ0SpNZ5loY5p1uiZnxgUDEXc85TXvQLn8DTgNFfIflPDlYivV/h4NakSzo4bwOsW5DYLoFKE4FJB3Ro+uSosrRu55EPrivny57e+v61ZDu+m5CHVSs5rFevh6XIZJSPT/heYP6Eh1MP0EkNqnmfSPQRsFv33zw4wHdecOuKaeIKuRL9w0/BjFVG0ekw9TMJqzQy6kAH4FHAvoNW+v+6XTGyqfNEp57hbFs6fn/UWIgTFBmfkJ6JgZaD3FiV9UPejuoCrvk3jvX3mRIBomNGRUDvWcuSO3qHOGD5udfR+WiNvbUfZRcZH6sBAMGi/QSQQ8g/seOD4GsnunoIw1dT1KQYQ9AfwGDT9LHpaXQYTws5y5PWyFs/QWyWxn+D4TrUf9Xd9HU5b2471gMvvSFfDXMoXRGTi5qThGM2JlDiKJhoQ1tBEQuUrTOoh2GAxCj8DwMojIpGrLqW5RzJArm4BJ34MxfnNEsy35kA7xpVWZQfH8FGrT0/bK5NBnjSRvBFuMBG/18DrsJsWGbAXIN/u+KvBYkdoiTX0Qtz/GetTHitcXzOyIoEWX9FzQ+mxVcNC/d6Gl64xlvC4NYNpkIU4FMDzQJIe+fudcKP81dQ5hj9YYIpLUx1Je4QM4T1Yi628rm52mJailP/VgAplAYMPqmmyA1SsH7FYp7EpO63fKEmAyvgwFZcNzNio2kAdjPHV3SaM+R3I+DQoWFJ1y/jr4oqxoKvEYGsGsBzn2hD2kxcbJkyYa8SWjx+ZSaniWheDZ9jF1qR/FJTHBxpManiYjwSdj0lUfFa//cicV9JKYi0jaQmIKg7lABzn+G3hXkeAlJQxnbwNOHUhIGn8TJn/VL+oV/OXPueh7le0GgK6ToyRxoWcbvBz0b+Q2iMi7Vc6GocU0Nrs3xE5ZEt4DnmINwiZxeZPuwpGzQ9SuFfRj7Zwc4C2/GUAS2MUz1A3sd6CXacbl7B0I6B/TTdaX3hYvmOpKo1qD/bv30ug+TkYvRMf3eB4x+gIFAydqJ5jAvm1elxZTQ5d2hT3CvRhmugJ41ppgsO0emRdkX93nL8cHK2zUsn/J6dQBh0ZxPoy4ei6P2BB28uwP3ihvQZyctzC6BsWfUjbe5AtjU4e+rofj4Q8PeOguOsUAY1IkovTaQJPj3819637bJUl5wl80so9RRj8efX6nEFkSrc3XsdHYsZXkvxU1Z+Wkhm4Piy/S8RnyWaBV1zNFwmlrgadTMgaE27oCBxRVmw4GIIAlAjPrhgCnXsRpjJ0XLGcxJLW2wzBtcAq+O/tICgRvM5T2/9pd6FaVHZQg+ZLDt7Cdt/dJ3BjdeYftIqLaEpXVUw5/BYaseur5GW7g7WyfJmGCFjHxgvEk/Ox+ZhFfQmvc+mbgY1ZaK5/auoh6kPfUQfnVcQ9ABMmpAT1CbiXMaoVEoD89XPyqmIR0RuAXlKjCZZcS3TzvoS1lDEL9N04Z7IKH1KCf7KXglOyoMLopp4h7SWE5QoT3DJjuApxBrjVG7CJb5y+SOcZU5Iz+kgNqhIWOpraPhtl/LK0KtJLSOSEK5jd/7eeJs0CZTYeIUKO43aWhNy8EcgVslo9sYuISTXQNwhSeLdmEk4c96eEt0TtPsv4tTbTf0QpsDxXmHgSi2f0zVKsufrYf9lgknWprvHWzOZPojHvrg/3lZA6WwP41AXG1j8p7pvaHZTse24uztZRrAeFb2/+bb7y51PNaGuo1WkESfdTC1eeBujxObLWsuh3C6Xu8NwXakMYdJDPDuqCmPkKA9w0Pcquzzl8wtE9Aa/8Cg2lc7gMWaFk/l6JdjCDpxjcDiP3R8JkSz0uMhbu/LTfBtR3wYNpY5xKshUMQ+LlQB13SzT2OHF4/1vMo/ukxx+tVk7tmS/ZD+dLNj5nsf2EiYH6+JWA0ARDHpgFuLTTuV0kcX6/uhW5grtTaUEuETedoZ2OKWxp1bvQXGES1KbtLf7T9ddwOkRCtrWdo1jrvtYnL4riYcShaV4KhIxU4YWMps5Yx4DXjOZmlLigm0U9MHWGVvn7tEYWTs8rUy/MuIJlXZqM4A1qugPuTbaBJypekUvAdG/Pb05Q8zHylivLGDjlY9io0s12OmjnrBkHf/BLq/BmOsSs7RxJ0kGD8qi1eM+MPxyrFaOYCWuNqHBwft35Opm+BaEBUnOVW7QwVxeh36ImL24SQrA2K/Xmx1WXRhpMIwShDrftFBVxTCQschJTWLZAz7WtW693ZSXCmXgbRjjc9cUEojGOF5DH4W8lsOVHvv3unBkUytMc7FDeoTAdaAzP+B0SfN+yxVdrffb10t0EFGlS+yJhKOOURJ4pCt5XLbTr0Zk6de0niNrIHMyveGa7O+LrYm+D4aNj6Z9rMKsCm5DlEWiMjfLtxpi68b7+o1qZzqRfbvbORQqYRB0MnBk3LWSK7/47nCecjGnm6qJcHgsT36e7u4laAJH/rMmeeuGlNJiVsUI5AygY0Q8/hyb850deb5uR1SGpJUDbaUzXJAI9imT+yrEwnysTn/GkeYEjvksZlTEFwr61FQcu02HhMRX3AvYj7OSXTSq8W+ybz3WvxfKApYNljWs4t9TkTKO/HUh9cWYrkmJNWxfxH857BAEF+OfXFi8ZtdaumwmO7r189QQvdB8DcfYIM/2PA5V3vRQjx1dMXI/JLOBHgrS8GwIqy8i6v50fvAXzx0PQq4WkbjMimAmEa7XuatJtGrTnY3Js6kxn2mHoxb9k/xlw2XA2srwXq/wmz0MfmuZc0k/0jmNl7iaucfkc7dqSqATUcR5NwkvfEsLS+oCCslWm1czia48ZhQQeV5DkTOe/M7HVa+gKUjkL+Flmf+0V5WrHJ89XQXGBluhgfRycDYUCjFx7GAXj2Y0GtOxQp8FfoZHuk1+BE1FDcjbQO/kb8OrXWYwO9M9j3mc6TPiqw4DsZLz1RDqZhuGi1qKYcvuoAa97HbS3zXOZYMdsyjpvi5knqMGhWQSX96/S1Zg6Uf6pxp1P4fhMoWDR0JKHP65Syib42VubQB1XV4OpDfSAiuGd9ZB7AhFopibw+uGaAVA/m9kiIXsvnkSvpiEJHRQ8boD39X1dsKgZjg4NEE0BAF4kMRkK2M1sxrXyyKdRGlRDQV1nr/KdeC/VzlSm/+eLJalMatm92RwHt8RT0Ny3BZ32eRtKlGnKz9H9PBtAGtnKKjvMsw93+G/l6CeWAEX5mGb2hLToFwN93xAsrc/L99rsZFbZsMVc1whoqKYCMW/xfDQ+otDYaOJPLPgcTXw/YTcW+H7E2aD3uLAT5ed+7OjZvvqyJOFqAZXkTSGjB+M3wLnipryrijBPbwV4TfUoRQ6+xggC2bOU/DtCU1rythG4YKIn1plla3mFSOJcMHi3tONrAvPXJr5DakhMDDxygmPv9/JxkEuT4YcXm4Q1NfJNGbhWXZS5y4hy6NzMfobEfK82s4OA3b/gMVNZ6ulkzMcpQyfvGXOUQMOPDQY0UAgPQZ0kG6Pymdfm1v7IB6nVYep7XbL467pMGDXyVK+ZRlXwxN5Z75ye1wgOqbVAYOFG2QRTomvUgxCF1XKrjlPW0myxHpW1IDkOwnwBKQgGVsXFOQXw5uGcmCUAN33HxDdG1WyaYemwBOl3/xQFwMbXn7OWxiyqEw6U+6RjSzq7pXb9Cx/zIg17KHCjfiVkZ7GS6Ga9m6SK1payIrSo1ePxB3Z6d/fcTxdP2OqVqL+dBTCTJchbCoWfKT7p/qLtcp6x/699L0B1wz7VmFrhrrFYt4ASBOb1jUqrvcZoTBi/VoKUSq1ENT5grRwdY+oq0oHuM0diD6T5WULOfhyhvNzVYrroxVVlz2BxCOZVNplY8yKe4LNQ/WudebYt+ToWOAsqDLoslPpRlCvmXYueGPXH9+Uwd0ewGwClapPdXC3PueC81UrssJ9ksiq5/u/iamD0rtFvyko8YGFYfPNI0Aejpbb/jFVGjTB/IEBvuSuregVjx1vEywDkGPoNw2i5b87YuiYDujo8tgZoV+bI9OAOFPohHDSLy4/mYnl1SQ/APV2kiobxn/v2NYP8U4xD3Q5YuYfEMMosWI4CwOw7W89w/g7VcyyUTpD0OHVTDsR0IYV+dk/CFvgFbK6HZfNGtc817XhxvtqZHi1cfTUOx5rVKFi+O6DLP4v8U+YtyerLmz5ip00gIeptUUL+JUgzAmWPTk2jZ0t9abU8ronFx+hwc38lE4tLt2HoqffQ5VVAwfoowbAfZWUF2pV+hOay2gPVevTJixP+/Q+Rb02HZh0TZSjyxU0/XUM9u/AjB/moj7byBxEdw5ma/QhxugxbwxyfKpMk92aAXe+QFuScyAc8siF0Y4wh5LV0vGVvlcJ/XRzokUjvzPIrUXBXBfroyNa8sx+1ia+P46uapa9hDaACi6ejrp871uqrmSbgIjLI9X+5cFSoVNRNk79sht1KsUDxi21gBcKJVPiNzvNYuYeyLGOkCrSe98ov/2fs5ozK4QYEsHC0AeRpPDXDRiLTPtOjKhlr5zLzdJr8uBV2uRQe7NVidzVa0IPAirQ4UZVSMzvjcupg+iw12tS7f6CHFU9zNx8pCTWbi8CRhWKh4fdeT0T9GpNjIBRL3GPJTBxpAeXxzyfw4hNBjKycYED8x017WdD2/rvTGGeS2Q+s6NH9Gn4NU5pRLXKG0hxobavSa0RenT9tcJHeJbsjgri9G+ccPS5kMbgPIElwOweJaUvl6vCUR3bi60saXKAYjraYBCqjIbo1iT5u3J0FUKTKEuyXUVwmSNiS/fOGP4k0wDBGWkAECusV06gGApr9TXc5IUrjrEK9SkItOF+nVFNJ2AMdm8O343aMr0F4ouDu0eXM5KCHQ40R04LfyghAx6FMP+n3pWCk947YwDMDCK+203UpHsLgD2EQzE3DkdQ/7a7sgA3z0SSvKpWfccJcDkslZp9YBx3y+sb8luoTA4FobKVynRVuD2MsGejlFjAmUcCTQBJLC7KZ8p7Plade13Sm7w95syifGWoN0y11XdK0W+8bFYJ1XTlXUucp6UsLzmK2Xw2/FNnoLfYA7ZNEL8SijxI/TeLUgw3koyN4dmx81mtWI6Ek87L4fTUDwQgCCqPe2SZNkkrUiG/okWmpAoXMVedH+LmVuU4owm68kEjeJ2bA2+n/FQdAiHmpjKDLgWuArcnIQ5RVIz32G0N9Ji066iqQg7vKW788bPabI3UCrYfxMH0suqEoyxhap4E1NTa0DOSckwfrGVLvv7gNkwdue2RKOUmIVXWWWaVmmQovhwNgYHOmip5cB0DWvBCMWJojsIz8656Eu5ZIhVs7nlMnrZrwmqcKecINOHF4/k/R4sy9HJUqiP5Z095nofuZhGLAvxyYAvoql+DHily+ZE2Xc0lo5cNAFEue8EVAEl606Czp1YN5zABnY7C1Krkrr398MT9nqey043PCmdvSFdXs1c/ymeM30NVBX2DmxxkIo0VypWpiwcMShmwfuoXW1phY4DmYGRnn154X/APxIKl5FuyNkKZRhssuI4TWdAGTjdlOOWQFp6gOrYNDq4qVCQrXmGqQOWGzlvM52Wl8vJGW8B7lGUhBGBN7c6MNAuZaq2O3WgqveSnnnjwFBa3HocXvZGzIGb5N7cWfLUgQLuRuVmQvDFD07R9/a/sl6eabxn4PHZPb15apIugqXC6cBlbGwljxJRL2F1dL/V4FjQ3xbEdPD4b32ircJLk5TkSeS/DoTSR64cBi1WT9o790ZvMshvFO/eBLI2JqaTtlhPeVGGCIjxFt3b5MmM+bhv753ISJbVBPLA4xPKe6JUkpwYk0bnv9WKnquuTEzHi85ZWi0tngeBXaRQc6kWrYpm/lOJXyKrwHyN2GuTRcPVveQsLIRIfZAztXWHreb1iA7qTSgZuDysSPgyNTqwtZ8CQymntx4RG6i6Y3SPTN9CDystnUFCKMrQPpW0LbNtx5TMaU92SairfqHi9piCKQB+nClkkCqKwanqetmQaoejCU9C82AJdFlQoLBbnhR03UoWgVc+2YBg7nShrFKS8X2RLyFW/UZVsZRgJTbUku3bqSrZ6cobZsgj53PKMJQ/l+yV2AjbJuiYgoGgYm4wTAgXCnPfSVR5J3laqKcP+jZl21qYdoaMN+lU2YYvXFoTvwO2R703+Z+gjt0YY5B+8tJPGPnqPcPT1NH0CaT10fCkJqkAtAn97RSJZmZg2m1mULuIKVrP/XKP5NaFNd1GBhoQ8H7jkMpjowArRnrdYJ7jm95zm6dSh7YXJEZpGISPiCZce6C+bYEqP71xMKJ1scSfv4YHmroLA8zD59hihbV4TSILrLVH/Q8MaGZbtSUPGixn7HkqA7zCwIWRzBJjKz1dTcypN6TRegwY761zrwmJRuf4itJnsTzI8tJ20RFb6eLJ3z+oOrNAqKPlv/74kT7YSph229V8n1Qm7+Tw/GOtzH+yWvCDpW9jo4w85QFoREbJMFv1kROz61HhygIpLXN3/Q1vvvSe26Dit8I4o1OLgsLUErJGQpyu9gm9BgsBB0144dNBYpJuaTiMENdooLWzCvww1eBx5qIVPdhHcMvx9xpQWaN8ArhpOQSuG19M/9lo8JH1XYc0dot4wRqSoxWixFXgkA1BKc+ElKGA7UQZIC2Lkyoxvgw7RCjdDmaEVJvHLHG5Ot0MILopjhWxz2RI9sFXSLmieFURdlb4ijUVmw36SAinZ6S7UdQ1YHx0/Jh+YIzQypVkVY7ZOy4jTOasO9UcXw3v6znjLpvfRMLQURCc6oNljrGSwVrbfksqoAp0IlVp7GizVMiStAA7m76e+m1WYbyz2DEzV3clvacWJmBHtA5MUE6YQM0CyW5UP9jQ6OTiwKhY8yTkhY22VKvl2x4OINOne3dka5y/4J+2W5rvpyL9rF+h726YOFSy30o9MFZ+dUd/60/YwVpGlvp2SynTnqATz4Gn8yBCCyhKmnTm3VJdH2XeiROOrTmEMqhAgLrDiWcN4qrLFTWTVedvJj0+BmJcWPO0StYeQl+xtRpr2RXAOAYM1xrRKy77YJ8S1CoQLqGVvFXII2YfvkLTW85SrGw5skibvtaHnFRBJiY4WTakFl4L8rrgV8bjfWRBNIqd6/51KibvwpTT4gFYuVQ+w+vq+AYPJ+TWWDMPjrOKGJgmgLzfTaXHosOVbFLoRo7U8vcR3rx9adT7Re8M8ursgTysEtE5fl3c27r92qXDsAnxFffFFNjlK2qsaqRgpDlAzgoJGJCogd+0TWX2ds/zgvS9X7ZysCUraUreibh+R3paOJ78ZaiQfSkA07gxUTuUPyU5XlRXQAgwwX4ufRD6Ty/3qYnIdWilIhOvpLaCkH39zyu+Qen/Q9RziAQdiz1pnoIP2eh4uboBwke9fnfQRuhqu8HF/2JeurW0dYjyg7vHTIDAnIskpwUw45lhS5lwdzDg4t6mW6RzyXyNUEBBZOvZRcg2qMKF5+52JrqxwUXNlmpDGA+SvMETIunWTAB8bVJKV36qHkb+gdEckOC5k8+fablqTVgtgCxHzk8WkDiw01EWouRNpwSSyGsDHslLHbMmjVLiJp9P1CMs5Sza3tjCZU4dPWu0rk9AlAyOh+DthjdHyOvAaRwbLuKu3YVUap8mwr8B1IEn/f2nh2lOYdwFXQkXRz4EEffKtRLXayKCg4vuG8gthJ7UOhiMB6RW4Ry0AaQyNJh/2Hms1IzmsnPmrGDgKEsndPJx1rOh1Joc0FCsOPpOolk0flgUboORakqOngSrfzSlSkJi7rqHTNCbEW7LKSjcdEIn0Kr54fceJm07G6XAxUbtnGIsskhfIYYgtCYVuf4PfibwlsThFAwfd1DXTQDj40iWVz2OKPODIklSpJ1qbSEnJL1yl72YXBbttwAH5aD+DwaMO5dzTYbtd7UIo8pAmSCi+GhrNiutxb5RQThpH6iKOFiT42F65T+CAeQ8Uh/TCYfwgATjNizy0qrUN3HH6BH08WaWYp0qlO3lq3fEK/lJT8Gmtu5bdBsfiEbxPBB+JVZ1z1Jq+qnLcvIzJNKLCXKKLEa4dFZkFPLGF6X3YnOQrcxqRO1UQ6bq50Fm1thrZ9614blvCe4rHNl0EIRF/dniNWXreJ8ItwvPONpQ38g/tCBol/owiCJ97V9m5FsVZuidEedd62Izt02HSNE6tmKogaiQ/UwIsjDk4jMwuKtfTyrggMwXc7qRA66VS+awEpjUNqw2ogknb8Jm79KUNEMt8XZWSVnfmGSm/ygRs6FsYvBSmAVkqHupO0IYpoFHgXN4o7mBMHQZMg5dnOGKk+1FkvuuS7fW4uhILAbfaM04HuEt7fDrxUIg3qoj4x/Opkjz3H+jmAebXdJpIEtXmdf2lzervYXE57v7qTTlw6WcR5EMkHhhkIrqOx7ic73WLKAvah8DkxrisDtIhzGb5DfqLrsk/IgGgZX4i+wz9t4E/M6fiBCGn1Akf/BK7gW4g0NliJTCchMrorZEYFWtUeeE9eXYmXdqi6dGmlg8wK30QsOAYZrleU8jHLF6GdT5ISvxiGduQCc4dz2qqbPXUpUGU2fJPpo4pUJlOxAiOAwtMvEK/a2VRf/Z6wnDPqxc9NtUy/PPhVPAczMoPh9r9Jze6f767sqKYB+Uwnt3JSqaBNCwT4XNWBgF+JhcA8OyVHA0zVwH7GwcVLnAYWmr/7Bbb6AL0M2rgqwf6wXM1s5pfTcEarK6FBwY9/qlSDRpCu6BPKKKBsfXDkAKZlbSnKHZOWRJuvHK2Nt9I4FQ54cQVOsxuyAaJhYgzz6HcPMzVS1ElZIb6GVtNQo8i9dAcobZDvLDKZNRxSsIqKKhf3lBpwyQ8Z9lrSmH2HrvmNvu9sJTztpeavRqUDjQ1n6qAm5zghsk6KfdEb6Oy5dYDGR6mRj2j+vaLdV10/YvPGj+XWkxNuiKxrdpBoOz63ZxVAOh1RsKl55KEa7YR1QAW+a9DNi1HKqcp8i0t5UA7cK51JZ+d7YJ8dH2OjgXoueGUN66k/FP7/SpImWWoNvPDyu9AoRGMEaH0I0miYuDwOeWclyme80tw8H5VK3JzEMPVtDUqeEfM0MoYvU3o7r0pQYVqxJJ9MrC3X/Tj9O/vkIZsGlCGS171rEmoyO7uxIKh4AaGLCkqckouSlflyDhH83Shpod3OvjjnWueSD6Rz5QfgyslZmwrMi7ykn/qZPXm2jtfgM3iZFESbEL+yEAbuh594TGlJs4UAMpz4AeHT3xwBYqPF2ApMWE2ZMjg7ysUAt7c65xgJELmMqZ1nZ5jiiYQoPGc+tcQFNXQS3MMf48heQITXoO5PJrUY4KQdUyFlCOXz9GkwQ6cUExPMkJ/7CYK/J56rXW2gQ+LtWp8lPIrgAJyCFXWoS4vLKxIvbZFIKku1YT5PHp/BdGiZKShXndkMCSiBjKHZewFDzUSr4LBQKMX0SkaCnLKDDEPiYH/kYw8dxIOSa2/b3a04acFWVRINUakUU3TMDr8lZgBlxuMyZGaGluk+XxlZnBcnPEPdIRoX4iupW/HrWADcWce9cFfus+FAwEsbUraFN03iBqlkZkpqHHGIU2a0KUtzNw9bbMitn8deH9Bdi5uep0V8zBS1FCXzBvnvzXCPQiAq/w7kvZriBi7O0CDxkmYEfe43vHArNLFpRhFFXpAIVoR0lWK1RuC8U81mRjrEC63RPr8dAhcAYYuo1FXUDXnIaWt9dfjA12TrnGN5BJ3/r+2s/++NomB/mtoFIf54Ub5XmejtpJ7bDknb58G6BaR8P0b8HwsRKeLfDR1uCZDxDRMfO+0x1ydZ8dlYfXHlp0iddMsZE6RoqRTb648k8VyXTpB6vGwoWL67qfNLsYiniXrnmxViH3H0YfXRxp2aqIyiYp97F2vy8oBWmDKn2dNCxZjob9EDgwhVRKlP5cEgMPnIpPsfiefPEyV9P8WyAyT8SdLExhNdCTEm7CmXH3nqmzB0FinT1kfiGGAAJxHTAZvw0y81FYCt2hYqKhgbFYfq/S/stAbPMk20q03vHNsAPqdjw0FUwBhSvUuv75kBcVjdVpozAo6S0QFFvqomwEuHqRBXRLKD0OqwTt9cxZ+8A+4uPRUfJCjGxHkcwyX4E7K8pB1HQer/NGWT0MEEMf6xAqpCNEIXPz3CuvCZxPgqhz5rR0fA+uGS9gHwuBXBtfMK7XFZ0CuBG/gCs0u3LvajZ2Ll/AjUS4VkQkxjCwrSVrtvuvx9uSCiuIDSm8Qb7DgknQtY74cs1csYeczancQGCf2k4Yr5LyWaXcym631onslWawuNtbCKppC3PApGF45qTaOFzFlPtc7Q2y1XW+dlWx0TjxkPh/B5/AXudrUH735y8O8SLFvoOl+sbpr7NA4kxdK1cmAiC7EeENQf+3CrL5H98PcR5CQBSl88okyAofmzz4WcNelLuWxfeZ1fLGg9sQfSaZXM9LQ65u1NLqydhWGFxyVwv+a6ZfRJo4dBhWuJeWJlLP8iAI9XX9B6+fezR/VY7+2DjVUXsTwBDTiuC6leNY/j4Xm4YiQgLNmckjn/B2IBQPs55p9UoG3FgI5xN+MruqePak0PInRzfoFrsp6EGBp8IjKdzNIK2rwl/T8UhBiXvh98DBU1GM6gnyXj8A8AKmcnvyqinuY1JdkQ75p6Q37ekR9v8RcxG2Y2WkvFqBTevuDibfeU5az/h+wdsFAdajBZ/Cgl//yElZhrTdNYi0iLxPvEw523LiNUsCrKHZmo2BCRGN81DSMWk5rNZB0JU6NSVE04Gmu2UChIW//v3oGm/Hyv9/NH4xiMDcV7Rae7wnUKY6m/CVDt/Ld2liLtVaAqYy9n+Gnw8vBVFSkveCZOliqex4FPCBzy1Y2B1HqXUZwjxouckGo5OuPJe4tCh0rHk6ZaCcc1gI8P0gsrO1EN6YbVMcP08y4nn63+BX+akOyfDdLrmvRYshvB/MxFeUHzN7ppc/Z4Qxazo0NG0unlsYKz0Eh1q6VQhvqHqh4EJMvdGFpQz9RzzzkHs8MaG2jr/dPTA0GKWGLFRohjGur9CQMx3xMl6xjenW3LmEeq++85/4zW+nu3A1F2gFjBT1phPNeUuxgef971+2SUObAACBGYBawOVJD2cGtp0OusYoXP/uPrGU8eeZwYEJe2Ky3DUzZgBX8igiUhL3qGQtzSE54Za87mov9Ka2BDOADF3SXUOmtcfX7K7qXfOv+qCL61/SJV1qGLK8vei/ETrP6mkge+82iyFQLRlBINL0uGtNJGUmVcZ60LgKfH8qXd4copHPCLcO/gOPqFxLTOBeqTse6FcxV3rvwWC8HRugGL2LWJjHGZnS/TTIwD+/Ou/kjiko0MnCzocSKWgETzQnApl8SNXqCa2N9DI/qA9Az4E9bVD1/mZYqTJsY697i2EeZJdPDj/duAkTD8cN/ElxLSTx7yOoUad32onQY7hpJzJhSaP9yAfZM7Xbg5LTrrGKxUdhtIdeI+h6wDPKl9XA9WKSEczHHT9lTjEpXjlqtUveuSh2qx/P/GtksHNEikQ0VRuiGuHZZUyT2Ga5EzSC8As0NpKXZ+hlm4o5dUpXf+cr8oTpEFZ+1cJA6TEaFFHmLlZEru0OUdUAPsnuQizXXfZJbmAdW5vLLyRgeITH6+qh5GSZZmbv8wL9ZrLiU4nQ9d0I1KAD2IkMSyYdZun+oldML2cClKA9ZXebljQUijDLIVpP/9jjOAVKVwD87Ia+mbrDpdWiNLJTapl1Z91ZAwVSEXs0Rr0slFwqlkCnhNMk3/b8CJK9XgvRXqRPODeDDrxVHj3NjqW1Dd4Gy1/4pv/jPmQLMdIuY0mRTlWOb+nr4gbOybUUt0n4v31hZ/2YsTyZNrmEaC6bwON8XdZZYZ+I+vr2F/WRlou2NtHKoG6t0kIQUO5gpA8AOtxMOFwUorFZi2RSTthSY34hUifOcF51TX4xTn9Zd8m592TomuXWb7qxem9G3jhY9GoNeLUxL78lGAR2g9I5VLr33VAMN+4J3nMoPBjSZXInfLyREmcYihodjMPvC5+/JnYS98qpXTzszChyycbu+iDF7AgR5x/2l5eOJ+Sng73eShYwZ9vYxxsUCoklPTh57Pe0zNMb1hzvWBmceSLhkiBynt8/jFh0nDH/iga8dm7MYPl3fFtkSkaVCuBPA8GdD74Dw+rYIROfSdRmx0lvXL4+3KdVrR8NBVqc+V7hJAoHS3Nnf7c2CAguUIKR3Al3LuWY3nzJ5Oz5o5/GRinc0Po4U2bKM+2ndKFpxFvnJMpZGjEtwtgpd29E6a2ADQ/Gnf9tfa03HlWeoR17oQCgVhKLqaw6TaFIKe4zDAQex4bAyHMzwCvoW1tL1KrgmCrB5AZIfjlx+ok+Xn7A2nCPUfcFJYxdad5mY7qTHDNbqiMg3ZUNzLGGVjGADj24Ok9Hy3lAudVsde6HNpGHsyB7+EBMB2GnROxA0AO3tUMg7J2K8Iq0ZiPMlqfs1t91bbzZEN0xylq8xE31a5J9zNETjl2UzbzNuuJfi+c4rEyL8czAZPht8hK+Hi9zxODgM2m6oykdTJ1t1YYRgosnZ01vMrJ3lUseYiWbZCYgHQ6CuzwSBwYDaC+JoZ8X0PB2QX9nGp4lAUmCBDkyELrnNBydyQ6SaYVhVyoKCEp8cfnTruPazJghdr2pvXAKkRynLVJ609O+673Z9d+4qwp5XQ3uQc7LEUdgedBNorEA2a8h30NlrzFvX+GRTkXrbPbClzyUN1XAgObsN55D8Tqp77uBluf8zcYDKpYgNh8aMNUuoo25LdjJL+21+wmV1c4v2KWAcrbfVOd9LfUlZAWJcW1N70Aru2EXacP3TkbEfdWmsMbQdZQ3FIY47fN54FDFkLcK1D1BtJFAyyB+M+1SbBRObvfP87fuGmReQQLQH3M/wI4aVfM4qOQvCB5lkAtshzdfORS/Jrbi0+SYZ1VMiMlTLdj38kWsPQJcEym489dYU66MhMimUpHhXFoA5GD1qBNRYcpwbeIX3M8PTiI8trtfuYI6L+Hgo/u+VO/IXGILMyc86Jy4eyEN+4AHgNrPxoWcHzMSAjTceQt91klKZ7Rr/WJjh36fSheAGHiUdJujfzRNNMY6586qz64kg9Obk9QK+JPPSSjwJfH0yVENXr39814fHlXl8b2WkYjDXig81W0Xv0zwPO8hkiXMJ+hTyhMW/b3jEc2SmyOewcY+k9+UTK+yHsfTW2vr2kY0soVhovbgqELGFSrmTcDUNC5nosIrcVrvIgz3+VU1jhbhz9ADYDlSKYYAf6NOSAHMUMVb5THR+WG4od7vJa+A0KDtR6iFag5E3wvVGBkL+oiXnLeb9VOKCl3/SL/LffeJJ1oURtyeEZ6JwiN7cRgxZu6zGSBkKT2gQ4o2+0kCCUJ1XVClV955V5aqF8ZYToQDa7qZ+z/aocs447NH64AQoGBAoi4Qt2GCjsSj0ZJXWy7qhmdQBPKlPNG0Y3ndKBKpIKXs3Yyz5bLsP44/oAjNrixlU55C2k0YNDMsdkFUISu6I8L/UAcPMtkpP3VTu4zdovFYbqMUno9BtU3RZk6v/jN9HMeLA/4LzCl8m1T/wo4G+1LLS7cLeNAzsynCwQMe5NkdrtYRa1Fp7TO4pew57hBse8zDaDNX+bgAe45wFfIpC3KppV4Po8oZncoQbybHKcKOcFvunSQ2xaKkbymsqwRbllS8mC6nOgh64TaYmrFT9EHsvRPJj8cCp87N+VUScTj+EPSBSjtdnHvuNq3yIYeSRc2o0Zj8aLLh+O3IPAXYm8HPipuxhhln+LlVp0KMdc3QmefSG216XPLu29MmVSoWxGgvItSPfRkBC4gJx47sjgOBY+tFlaZd9uJmX4/vuGlbmGVaZKNFrZ2+gGmsC1r/sq2PCpbFeRAeonfNFYGxvdadctlrBEF8vZHCrKUaKJHtSfn2uXp7gTRVH89baogd5I8CCtcCklO0x7w5iIIE3pZebXg5OEk8cph8iXS4pSqZR3MDjCr2IbEdOuhJnnc2b/sI5yGfTgFQX5h7VF6dejIYCWUlIOjaAaKSTHNWL88vEgP+DcEpOrCpcpK3K2yE8VYrZV0tQJ5SYN1FCbHbGRxkE5E0i+xzZZdElEOQGJhSgDbLWONoNNMIeyt1oUsyPciFvlSl9k7mMit1G7SMsfz5xST0oKNhbAuipn50i1VcjZF8Hd5FPZ0lr7/adXmqsUvlEw13tYW5m1xiAudE/b2vPL7gelUFdnlaXJeIOoq0LACUfPv0aVcyi9RyChWxDB71r2RvhCtHQjkAgpqHZjdOjuZmgYwznwFaEbLdfTCF1U3TWtWGvOvualIboeD0+DSahscemqWoikySifw1USX7WHwyqyCkzFUoSoBaDcSDLF7QQh2KYdJ4CiGG8EZI7CU2o9no1jKRoGZrc2mefaqcDK6Ektxb5SadEdTlfzvR8FRPZvykdrAXS0ohmxSfCba0latX1IE6wCO7H3syBKCGoa8qdd+69ExbL8V68jXn0Y90DF50CtvZxfiXxXvXZEB7kRJaVipe3E7NZqJTvTsIf2QGAGy23RDrgoWCwfhDWjS4RcGt4n0o5m7kMThY1averXW1+i5lDw0/cBBf85CVvrBhr19qx+w55aucIOp5xRE0xGo7QpzI7ZiM4nTmGFVfIRI6bHDYfschCZ6giWtBSHoLKxUcg33F41pG3vt1zz1pLvS0lq6yFnw5MW84eNFSybCmBlU3WrZ8AIlgnGIUK8T2JEKEppprABjOJULnvZqFjZ2t951G/70VJuYCR2dHMuQ9FN41ZW1pkjH7eBf72Mw+Xd8rXVt8NiVixFsRQpycKPh4aTB/m03tNilBsovlckznUX1AK8Xgf6TL8ZUGs7MLkXhipGMprPFaqyqCHpD/PbI2O9hR1m49Mp2BSBs/VHjpC1WcLsoupmcQo93chzD/9VTCUIqm0dhJ4qtoPV2BtjKt6sswHCZNF8n9iKSj60h9+fsVfu79A8xjsc4ctjBvaP8shooAmY8KoCTy1XWkLkWQiLLCT0WiLCWgmIwQHWg+lBkIk/WBl6VrDgIkEE6vhlXkBJk2jXZIQFUjp9OWXnUPkrVejT1E6M2buCIKi//DYfTD28UOm5Hm81l4Cw575A65H56X4topGj/29qSGH2kFfTnY5eZ2LrIkIvlBrn4SsROoH3wTnY0yPWXQe7DJ7GKmt/VOWlzApnbnVOQnmJDKtYrrKYlwVc2pv1mZVEGaMqGm/rdXL8CHVYMLRLruZWl3XKeLYLFN5wiRUpb1TtmDim2/wv6mvy2PUgREm65GWuMCkN5vb1Br17ynrj4aXdJTY6lk6YtbnteRnmzp+XQqaCdOWsVsfb+1zvC43aPEQ61JHXlS98bo/hDkH8Xc1cAmwHzDLHjVnRyHq/XKTxTiDpYQW3dWR+q87N1EX3HKC9w1CyOtnaw8KRi/Fb9JZpAbpSZCvPzucZ6D93ZEM69KZzIR/QcPAiAfShBHtPkapxSCovXnHpm1u3mjN2uXZAtxZoTTyK48X7vDUoBdf1A+XFREK9lHqbStx69N/A2LFZ06Cy/aPVzUVOHUQTbstjn43pSpnDlyxjPp+1ci+MBWQg1b6MQXOb4Qeth8dkM25OZdhITTgzIlENpZbDr5x1hYV/d4mtPAaQoUrr/XebwFTllChQFkys2IoHJIGc0Z1gyfLyc1ujksJo5DmRATHLHEln9SY0ndo5XuchMPESTc7wj4p0Vf0tVqkKRQmWZXh8JkUoKmTk7C51oJOfyzX29YLOvk5JHXDMQ4XlF+2VHFB2znKgQNwlggFxg9Vm13m/Cx6Fv8ki5aW5AYudbF8Kc9PLtYji6B7FIID7R/9t0Ptjhwm6K94zwTOQ3Rd9/jeXtA2LAvox1NNN6h0qoEBA9C4InYQdt2pvC8bwL/7nEWOoKelApbTRnNcoo7eLmQ/ex0ZT1lbf7QnV+qWrzeNWiL1TO22mVAZUZ+kPqarFE0M8UEA1MTtLhyIzZnh+l6AMcjMPzwbpdj9oTJGJG3YJotvKArUozxUdDjKwqcSfjHvOlX0ODZFVmDh/sVMApHVZla6oUi0vdcFMFGB793FdqvAYADC8HppkiZRyjSHoeKYYOzLMLxTZI/umGvzjjN74BZWcJQdcbBZV0NXeP8vB9917bAfnICQKnqq5XZVi5NGoMfQDL9fOOJDbJ45flqRYVB8CtZswfCKcawyCMx2akTWCb4AEmlSgxxIRILTXlUzbZ4iQk39RRMcLSY8mt3HQD34ef3fcxmnyeCeiE9/MXZdUsWt2gVWKx2FpndG4TJBlB+wSuSaoSSMY90JGd3cOkCLpNKCUcpRXFprPLqNx98zINkPi0dTNWT8k+um2MYgNqfTY2KPGPr78nHLVnnt93foNIZJMQoAqhoUFTKgBO0EvDvzNsome8J3esQqLrc53wGV2S/YluloApKUaw52xOAduhxtcG61bSae0A73xU/vIO0mowOC8yOKJzM3nCPtoVGXvWyWFy1/n6ZbWspbydVO7EwwUQDQGNhqDCIKr2sQN7IfLwNnaakwEQKh53wJYc7WdfECblEyb4K9tb/bdSO08n4f/sDpyDZYL7pzyaCX2sEJUZ7UX0yUEnU779dUZ1PIUD6T2M6D1PVinX62miHYrBeeBFxkhdJsdOFPYh0KAMTmJ7csqtNLDsEu3Y1auvAFAXC6NBkJzlvUPml2K86mhjY/82h48JLqGnL+qPyz+wBj5BHSy6sbxfNdkgxc244zgjskYfQgUyQT6BHc5Z9O9ut+BZJZ/YK1IkM7GfCYxLwu8J0qxR8YlW27L2BKlqz2XYgY7Ull0Zhi4G306KrxLj5tFA79Emk4fvgKUHH/5ffmAs6VzDJbpvZ75mVHJVADYwxIvvKjA9mK1/sY6NBHgVvcHpX7USeM5zoc9PcYKBius6O5HhC9Uwm6Cj7bjxfh/r5yVmdqKBtac/97oH2bKvcELnd5uVLzNsHx+vps4V8q5oXBDkgNS00U8HFmbdgk70jzaunRBghU21/K4Oy+NmAL4dmttbJk3fU/dSu2DvYq81T+k0jWgp9Rkg1MsPPjvz0qKFUcSHRp01YvUKVRB885p11Z5U6BozgBr9/dSBUOOVErwxPSlZPl7egNnzIK92QLs4jVTtju5HFsIiOB6lOHm2tS6QrHzFz2OKXFeCknpPyHgJdCaRr+6Nqcr/wRqxpWk3eQ6DHu3RWs0er0Ps1dqS99X7FqwezZLcpOw3ZQD6FGlRuFmUC85knUDzRojRMaCZFiXIB4Y7D6PAFPB7EgYtA8u4GbMbSxzTo50KWc/DZIcEnBr40G8Nfi6pbuKfosQvStVjA0YoPStZv/mRJE6zDGux45DaFipqcOkaUmVj+ZkA0hQQe5NvjiskkC5GOoRzdBPErL35I+0xXqA4urFC/Z+6mnwHAgyoOXmrekffNBt+XYGlbdUKpF7f5FmGfUm/wyq9APrtSJZLJj7BRBeOsbXYjfFUXTsCL+ODjP+K0AjvbXEDwZTa07o5t+ELid+dTduDXBVF+gg4kIkkjeRqxpG1G/TOHP6NNnZeUh0iD4mKkjKAAIMPCWDJ9H3d2rG9r5ATjjKWbEdBgy3cYQREg7mSR8rl7OrU0rXHO0o6uz+PBDMTPvejMHfqS7rtoILccrDTNWsceMHLvLywIDBy160wcN26xTLHIKF2ZWmYEhDSZG/YpIEdiBUzZ8mD8sO1ohbefRDTZ0xg4dDV+DWilnRstXwBLnHkYU+KIQWFX2SzjuWSEanPRjQnOsreQE4g6PQwVDx37zSrRe7TQTetisxRvC9+/SDX0lPybT+AIciCmpXJypHjPHSZ30RPU1WaS5yMLHmyNhKkfaDrTMa671AC9zF7mKUBCmyuxm+JzWopSG5Hgphgc6/N/lM98qz7rm6JMAPbcL8jLvJjNYpocEYfxp4dS2Fpy0aVqQtjd7yOtCQ0pumO8X+P1Hw1YSxg9oSfMmhSArcCP+a/ZkZu/VSqyScFyuctAEdxyEjMrEOgodxxPA0FVo17r0TvCA84x8QHNVLv0E5c6YcKHsUEjqGcs+KKHMdO62PcGNRns8Hsftv3qFilw2sIroVxqaO8+NBQ4yHjYm2tOK4Gd/F/mOlIlXqYOHNtNZQChfiJdOsK500zSX3GR2ps3bqyaH4GdyE4IurPACTfLVVebOkIUBa3k4jhhcrtO9FnsUlI14czNuqABWOybfXi0IRYnI8zq9/O52oTifGhtud7j13dv1Qt3nsq12BVkKF0GSTrVcl0nzWgWxOBxSZcecuFFDivfntDVBb+xHklzts+xId4qSNoV9tBELHGKk/7K9UPHySvY58RRq4qIB+uXXWpCTs1xouE3dmR3UGFTMwQw/xt/DahcI92c72OItHxjpCYMTkrLoLzbz/4VuhH1vsFGDc4+unlG5KJ4THfPLd47PI8bTFxI6BgmVLU18vw6bctMxOalwJiMRL/9E42FAgtDLbCC/OdcGVFMR/Rlx88Gl1lYzsadbKWmW5J1VHJbMSgGyK/xlB8fsT0n3Bl2QGtsY/X2n5HHTo14vuQiv1cZHpdsVtHUt8Vx80/C/44xlVJlCVcvk2XGaKLXI4LTh9zpIexiG45H4+aTBrXGgMUZIlXVayMlAgkHEtHHV+9c5G+TeWGneQaOZJYA+Cv0BWbeD+Rv5VJ8eihnUkuD3Ia+wAQ/LXj1L5lFOPBCmPutPjgSojyWoVEjKRlZXoTbfXV/lz/F5UDwKGIL66Q6awNUNddodDnCLuKLX3it6RU/b8tiRgjR5lVR8vqE7PehcYedL2/iVIySRU1V618SPhGgugrJKP+gnTNBqTuLT31mwNaG2ocPyUAjzXkfZWQERl583gGlkp7/x8CLTNw+AfKGOQO9kGcsdAYKFvU32Mf8dnLId0OiB1apvoJmnwa1Z1DJ2Qu7BE6gRxRkW8HtBsJ4BNOwDJNRztuBg2GHOhanDxrQd08jACLJ1G72qfDm4Q+68RoZrPzyJ88tWsx6BPBsA/V9KBYo6bZjEOZNtQjQFOTdeZNBkCl/gdUJ+ncMwgyYT2TWlX4k36nMztm8RXY4rHTgSZlyk1yXbPzgp8RJPHQLveIUsbA01A7yAF00iIgB45AvHatbpQ07MZ6bDNvbzcCYlyQTRmvcANWH4dourXRlyElckn4Drl4ULBBXNbalrfzLcXJ222Ty36pH+3Z6a0CDkrVhqP/KAc2Orc/A58LqbGwNtmT78eT4JKcjX4BhmJydbP3ZR86AZDehBDTlLQjq4+p32KV78WrIE3M8Ev0l1wroDYqfVf66wGZ5mjkQbMFuKE9SaElsQhBEE7hYGd5CXrnOwSDTO8GxtRv9hCNmnc/ijLpovViA20gnZXsHX+q+T+oXb24Dnrk/exGqJ66pq7QsvvO0UbvrW0RkvJV7rMTZC66IkI/qtlKR54bE2IoHsTTHlm38eMLC7JB+GZWOE6svI/c12BzqZ2KXSWRDoLS0DYQ/jFXLIt3DZY26inCZWLbCkR/shtE3N+tZZ4tJhZU6fld6kzjOrLp0JYdC8T5oe2xDIcOSM4khwQbiaySeV0BN14KXz3PMUN3TKecMhq1qb9J0Ri7Th0Y4jdjxTzdDSNF85oA5EJDqP0gH5Yugr6M0Yp9t7HPok6a9OpEY8J2gGKUrzAVjYG8xlGWU3OqaGOv0tndK/1UBs3/Nq3dz+8tBj1v7KL3fSw+ysTLa1OHV8Ul+7uR4PBCEcfeffxOsIkBztrKG5Ca27oKP/mS/6bLrkF9EqBgUALT0J9QYIGbHkY5r2v/GdsBqxGqqqpLLHv3nnHOqG9/uNQTL8MyJa1BOWAwtKYeByA9jKJS8CcHQqvJPLzZxX3PkKEQ4ovZVA5WHQXZtx/rxZj1Kt2oesqx1mvGUNm7NfQseMEiZ5xhrxMWhkoWeYriSvyUwxqqNzb9vDYaB5gbR59VD1VpfRIGNVVGiW5OWyZF50eI/FA/p9J3XRePVjUNoLsPNwZmeqfbqkiNjQWqeWYOGeckAN0X/XzsnlSGkSd1cSZFG7QA5MLDD7hWZrQbavVqEWsmiyC13IlUgNmPbAJZwfDABYPX0h853jX9VT5tSCEX8vvsmDpo0IJKXjbfpKIUtHXVd2AttDKIAgOWGVJYLvGcwhOTJa2B/p1uHPrqrw7fahpdMP9mgea8LE26QX9pKfvhc4QuYQ01PV23kN9URyEuS0hAeS5eRfH5rCanalA3EHg1uSLIr+VrEpTNkZbcHO24KIAgoo3R9hzeVekJ0rr9spV6N2pvXconoySquOqYymMIJ5IBh/+GazdZpqj9wUuiC5lYAUB2VjCJYNwsmDn0I8V2EU6ZnARo9gvnaHynNU/3VNg0s1ZXmXSmNQO50euLxCsvha3QbnuAqCc4S9reoguqNne+78hW+ymuHSxoYxwyFVbffFOiCIhsMQyz8apssy5fuVo2nu40y+MaziXHM8slZP0zwCgSvf5l+TipsPXmxgVu1kFHTAG2151lcWeCfCkyfQ4Qkgw9FPqSPxUeJchFm6HdijHMswxwAvvIZI21FcR80FSKhNgDFWkqQ6m5mnaEFR64e9yB2BlVvbM+47fBsqK2sxZ0AsvKOI+S+ZyjaQ2MV8L6XeRiFvJheKKUScMh3NkKtfXvnPygCtY3343kh5GOe1QmnuX6hLum+HM+koLr5GsCoqetvQOnMAiuVToifm0+H0ps1G680MB/IJP0SAIzo542ztbuHVfp28Vn0DmesXZE9Uf32m6Xxmq7MPc/l2X3nSHDsyA4zW7RnLeoBv5F+763iketK7xl5gODlMDxxqJ26lIkPtC47CF/uHMuIXl9RLpJa7MSTTI+cjRIoQTcQm7AdNa2IyYH1I1vXDoUcbBoGDVlw5NECRqL573ck0UZu1h6htKwdtBHMv4V6PzO014ODdn86gWrHe7qyrhwvVUKUcD93NgEy2inoOSnmWjl/FUE8+sjAqmfyt341pYOHRANKW96aS+9HY4fULbPCVTgOLznOHDPPPDB+0q0vNFO/wLsrB72kLLL3wKQ37XiMxzLcD4LJ+6RdD5E7UBzEU9a8kLEwI+QXrR9TpBQ2PIPYYcr1G8YAkd04RrmG0KTEywP1so3Kqkk+LylZGRXsMBsNhb6JgbyZjRu20ySySusgsWJpCJu20Ym/QNsZQ6EOzKi4smfHDwEwn83SUWCNgKvSCs8Q4qf2R+li7XjNUF7oKQu5O8WKCIcVq0sxSiNy12KzmkFudNKOUOeR7uAoUOa2hPL3vQBXGBWzER5Dz2emA3cSK6nvZVxN9VgjEMxjFZ97S5K/95+7fyRz1upanKtLL2jNQ4xQKDPV2ybtfFApZxBEHpUllc7yz4reThvMTrZ3y7BSodDZfK77zM9WSpQ5I3KO6P3c7JtoCpC6awVXeSgf3uI4AL+d7R/Zu+WyCvQ9faSDfUMOlmPAwczB8b2bKIkL9NLCySuTKPIdlvg4GFZ2/QS4gyXjFRlOcVXq+Ji3njQrldMNIPFFEvh+aNDiJEJwPxcBeUo2PqRREnpd2qgpVbU9kpU4dgKdv5NqWwwIR3/UFmPDdFXJ5F4WGF2bK+viJigCWDM6yG0kpriovzTmp4W1z1m5HNhSqIQ3LMi7ECZ85vSbMCmj3PExwh9+DhVv0ahP85aA0KTnWkPXy1lFpq/9GW9My5OBj4DpaH8TKQwee+iKoo12X2KKtERLT07hb5plz3t/0+XmV+ryKNiJefjhFvLF+CSOyFU5d3vGBOZUX5B6WE7dM9r0QGKgrqlhvTuiiCg5oYqAHq9A4aZwLO0XnoiL6KP2aFwmpQBvnF46qjJR38RDgsEKSLkACk/OmVYXXq3S2zIQnIndKBEq0pJ4INGnZx3r6HZm7IxHYApKXfPkNiLyGJKuTV+LdYbhgV1z1c+LZJMsx9xcn9O3CFZ466K2bMkCwaX1pLFStoPKpp7TC/gyHFv/ZkmbjEK2+omz3MIbrTJjDKPyiMJH5TtvnsRqqaPlnDGrdu7mPXi1pUm+9++CINHOtXcaDZ9uvYsqDPU7mhDLmr4Rrxva3+qfuNxU96tw+y+gRijBc6tRwnp3R16MRNtw72OUtE56mJ/U/UFrdXVjcep+icMMCRCdHtKUpbxIfj38oI4FzjOtBltgAq5yQADGAfRNwA4RoibsMjShhX54X3BPrMs9Ukz976ZqBVowKdejH8ttDAbfbezXz7/ka7skCHjCcEe7m4Aj6rMSwZY7ovJ9To/qToc3w5oZe330qv8+Sv6r/pz4Fn3/p6dF/jtbUs9CfGTsls1pAxSBqVBMUKXebh9ieAd7MnvzAj9DI7drGAEDFIAHYhwyHrn8S+uBGpB9FQJPptPhbRAIrVxDTp80SXCF2t6Tospa1b/fo3azQ0v0Ou6hu4rs/t+QdUw/IAC16O7twHCQo5h4neu3JS8C8MPaCxrti3u2CrWewsMHMpu0lJdYyom87ASESZXitkhoowO1MooFvd/niGfBhGVAg/iFt+A4TL3LQgTCOWG0+243SbchX7dTxhq/eXa8CFzdnBrfA+PenFFA9xgnI7lj++OTL8fhNvzMXtGXkfJCg4R8txeh/pioOyWkp/uAtsxt9bp96jAgd4bW5lGwN9xdFCRP+CJHHiicpm2b435pGqn9Q5wRHxUV5PAuc4HjvEtxAjzWrbViRx8U/XbFZG9QxViqDscfnUBE+94iZY0vvNaAAp3v5Rwt5cgiRvHguvXwthie8maVxrakrOByizeZADM6VP30vZOwdyoni/6fH/LyTlzBJEhDl3/IHn448fw5n7tRMhjr/W00MvEJN+uOSVzj5DR/w1aQ2qK2EMGKkojcVJphcyYsafQ2R8eOgnTsc7lvHT+ZsXx8kiuk0ANJ1zYBPS2OlrtgplmQsXTmq43q2Sg7YhWnRoBcpVNXWAYUDkswll+f6+XJmlgDjXC1sI+9H/yD+p46ot+wJ5LUbkL3l2IiYPlLrLzvKui5kXId/gwBFc/oEmnrhQlbbEvCGSELB8/XIx/Cesyu7NPVBz/ziUdrxvdA+HMXiQoaDSH87nesbxGZ/WXSDrAv/3wod70I2y/aiJB4tlDADqm86LpVQhX62yaidXgDX8X5h3so0iRX4uWDT8lVcMU/ZIKpB3HuDGnBigXeIEbOJWPz1K/+O/HnAxQysDN1c7xQzI/6l8NFt4IedwR5WLM+bC+Xqh3xPwLy6JaTIMU6AQkFvRgB2RKqyi0gsD7a9fPOkod1yU6VT1HBPQcU9LCXV2cmLyfk8AvPtnWHNAmsgopseH1sbyrz6wNoJ4cBSQfQ6kTGDZdSziuCPTccwfzenUWetSghdIlwiRM5y4oq8wWUB44sxTGphIg/jAhToZDDY/9z5LJVXeTLFzNCKZThwtfbAzwN3z8aytLrkzLCwZANRKIFpHjlWSiGkTkbJaVEliXdk4mwuGFlBYpLbPpytqmBQJImWkIAIXfzz5267NNCfN6Tx/yoIWOmz39d6Y2Dj7toAF61rsEbgVIMllna6EfrO/1EFNWlmBrOc1Fen+pHwDgHlc8US7ymStMyFQSRjnIXGBG1ZBwusrhGTrROOhcPFk98euDQTirjiUO9ox3wLuLunCyS+RBJV0JCeJDgX/WCo+WLbE3kQfshOjjUPesDyt3mJpTgFp5W6gvRkxyZScmv58D69JZwkklf3huZF6tzhWFNnuh9RIuF0UKeSVPy9z2gsYCTIWBkm0o+COoTkYhTIk4qtB3qogtIATRZUE6q0n7bjKOeDaD7xKR5/m1Ftla1EXaO8ABK9w/Zd2IRkKeZOFczBD1lLV/gvSG0pLddluWnabo6xABh+B+nbRiKDq6Y/rLNGSU6AVoT5FmPBf/95G0VinOijNCubZ/6bxBu4/f1vFAGtiNMeogNmeeyTuTDnTEc9jTByxK40NUJ26gWsofPUvtnDDzbf9J1xa4hrPPG5CIDmF23SveDlEuiqywGUtrLqkRx8TWnZg/x7YyAxxe/LkAExXU1zScXCZ0i5/O1lmFaNvUd5gjYmoc53Io6zW5di2XQcYGwEchlLSjQt7b5CZ89wDzCSb9MNrhaZgpQEtV3MIpvGmWrYaJ0gtnOERfJ+rQlFDnrdqrVhi5D8hn8TICfMIXRi4TuF6o8Uc+nfp/vdekmtmIAN2ViceEDT6okEqgGAPYP2xFdG5kTwxExJ+gyLlLVNtc415lpX3rmrbQ2AONO4iIizrZqOYM9lM/9JXg1p9PWCvLT2YdwR2ZOFHDrxEpBvNqMcNYUcl9U9k+PWq/CdxM4+WmpXjxF0j4hna2EqYcBvhbfuAoUCI7j7zcT1d2lfjOT/FgbEKgqta1TwQtR14vUr30WSASlVNJxsADXDRrY3TWfiP14cwaIpCKqCPecrNwmb+MDuMCBHMRhkN2KlqzF2YCCPyeuzxrs8lirTxspgxgj4lfjvCYDUMlcKESA2INStWD+y641S3+OKU1r06b1hxOioRQcXqx0sqruyhgAiT/RtGPkp2IqkmVNy0lRZqzWryCKO5aJZpC7KXclxRHGEWUd6v8uKccRhWWa+L3Jpb2+X0P7FiMEjZrczG6Vz5ZAtAYnFPhdWnt6NqiYUZ7Hw2u1OKX1vHDoo0OJBCM92KzprUr/AA9MwqFL/GzbP6okOW6ZAzCXEd5sAht4FtfZ1P+Enuz7cxlDowoEgfM0j3NzjzclzoSfOaqI6D1xKeetnPEi5K/pcyzJKdtOhP/q2VXU/Qrr3zqmWkEOJjBdCtDGDGbD9Nzr8wQioaxFz1tEi2kdOFeAeZmgobsv1s4rrdXADJ2rXMG6jAjNg7LIRSPHQpVFPljPIvBi6ygS+G85aAcczf01+glLqCJwWUn/Pk6U7NdqvqPP7obm838sLIaSQs0lhQ7vFRTcdTX5vx2zXdCK+JSrhMhA462jEt7aCR7cOugkU7m/Npy+XDARwYTCPzOu+yP9i3AADo2b9xTZuqtMLjmmu5almMcEKHW+nRQf3MSpC9LFQ8q3vhIoNNJtBYpNMr6lmPV7IMcnZNGTttJOhVoxHJyjyBgH96YZadRXDbTieyzMZryCbhdrJ9setMMc/UcsqNTRIg9yWGN8JvE5PAxl01akCE+c5J833SkxJpphUh8ogRrFTVGjK75LSRF8+hRs7MVJwUO0UCH2zteSCT1ugorco/O8qHR+9HCeStdA5sJEqulGut7rVy0V2bByKUOMSCYBL37Lh0YzwLLElcgteDc7nNkvVqFi4bacEtuhQg0ooPlwq8E473BwF7eS+7CuSxZ0odiHkn4USEjzzivEsOQ4rhVJMjzooel7xXHhduUnJnv7Xb9TlYOhMvs+iG+RVrvU66TJJ0R760II8NVO4wGlgSd6GTt5hGgs4zhNsHj2I5b6IDM9XaeJJrz+X0ceGDuMjXaV0n/9pNHAU6hB7C5+2zwl2rX5enga5yotUYBeXwtRTMTy71DAaCXy1PXMOTZLMHSYIKBfmusW3nIACPvBqACbuB5HFowIj+k8c9ll6oe8o8x0Y8V45M73F7yywqAyqz3DiuvRtAamxEpRBJ7IoIfiiGY6Vl8x1MPQFEqwx9I2cP0hUhb23C2e9/cKi7LVObzkyosGVumMlywUn67Ow2pT2u+0lnLq8sY9oH65/nDzxlXyv63Z9GrRAcx6lCiS1mrBcKGqsoZVBMXtUwMXKmPlIOVVVrIuNoP+4u0/68O+S2Y7ouDJPchskAVyD6vg3EUrckmFHCTceb2LxU4zSLcxGq1hUszLK7cV6pyJohazfMh4h3bf4NHgaIZLLAtpxuJ8g5THz7khGIOIBV5RDXxbY4o0yfj0mysC8o5IsUfqhwpeHZdAWiV03YwQFkH762pB01duW2XANCI4u9a3SSj8Ceo5WNoTlzM+HJTQcu4zTSlOP1GI2rl1cbLJ3SIKApsOcsuyu5TtLhnvD2i2XjCVdF28d6twS+jUP5MZnfclzqTY7TgWvy/ZZNU4+MS+kWv3c/61fU/MXRKTnTzVJHi3AuYPHgn8iizMCDbmY7zSs82cNpzDzwJWkTTW6lRfTZ3pTLNFWWDLG6FpOCjDEQUnCD6WugkHTl2dXG7Mpb1b1WFW/gJDXuupuOLO1e5W+pHip80+7dd750+qsPuezQ8MiHBkAEuhscmmJsYtu7rpLTE8k92JVlnGjZyhU8WJou5LYlDxHghQw2TidwfOs9JZ/mkX0Ed6IOjiX1GQl+8pLKwmcVd7BoszJDdb8ri9O3eiJJNw8oWa2LT1vOZaEBGUBhrv8aW1wzEX0XvHQWe5Ji6mSsUik2XystfekY4bPYyUYrv/hD8bEAeJvMhxJdm9SVNe6IbGG4QxiGtehOPlMlQ3YR4db/bbZYjloDe2SwD1UQzkl/K9xp1VwboxYpKCrCq/t+LMiu94niR+nviiD9EfCYFyZSmsf/OmZnUpJCu6kmryDhr0BLWL6J5/Nt5rIbTkGtX+m1YtzFFJmD9Qbs0z3kLiFWRg2Q5AWX4n2ibbemIVhIuIpgU0nPu7MoO+gDUu+LYd0UfOCceDt6DGKH9s56WHkyod9uJeLneHNGBWPk6BhCSeim70KSnwjfvTePXVsZ2EiZtin3rAMUjwFzug1hbF7F/rq8pHe5qcXEmZRTmDpoHuSAeDz3CJbGTVQOubNfISiyd3hMilHOMx2jHUMj27+AUuV+KiN4n6fHylZCzL8gZXvYeDpWIz/XTB4GB4/Tvsx+iEJVlEAt/euKI5CIooUerF0lpMyI3uOGeNq2+9SyXHbgrLL+heXWuMtbKRV0sVdUMbTPsItAxM4Ur1gtpk2q9OdWYJsWRvdnhtXwjNrWAaRiUhy9FehXj4eVTv5EVKaxcnyofBagXksEJL5ThdPznwA8Hc9BE0SyTsx94FcWYsIjCddGWFoJJG4IZQDgzMu0ezA/mvEVuXvxiwEYL+PbaUmioX9whRsrQmsgZ8+tCRxFv3TGUOleeK0n7W+1ksY3Er/V5fu48XBFxYshSAdyNVhGmoFSdrI12Y1DwMuf9z2mAoDuG3xQysrUZFeda4MyOUcp85URcht93r3XXe4fiFHlIAnJU4b3HHtfjT/JjNQ4QNqkLQyXTAU+TpjcrLh3z9n0xW96wpXR1zlDPhpHtyJnib9JtZMqOnCdKhkItVetwCs7N24Cz8rKMJiVX9w+9WC9Eqcj6TVIDY/3laNgm5XRR/CgoattutHGIvCVsztWTS3vFkfhD9Zh9Rr4uBsa5IkspqfNVi2rE7J20uP6iXNZTkdabCsZPV8C3QHG352nhPQ4HlXQVJ8aoec7Fa4Mc0ynzgGfxf+1MfZqbBArg/GYSl2bG3SRJXJNv8OOIgFXJhD/+RHSU1xMLvM4V3IvUL7KQqrlgrtqsPp2HKs8LU8bGGDk3joDmPrQh4n/Mep/SOpkmmavCKV68LfyqBVZ7QEGuuKfKoUu+VsjRfcq9d3wdtG7arCvUojypFtJdUKHn3KkZqqo5W5WVP1PrEswr2LoMyuuyN1/5aQq2urKP6pPObCNy9DPe4KHmRqSdZWr8bv5gEBWo6fCm6pJca+YQU7hfsYMbli/JLMmGy0JGf1fmrJ9U3YAShijsLzlED17k9nnBGqc6zcn0NEp1esvPYivoTPeXc9aekU4W5yRhf3nAe7WsQcdOzBljgvn/51e5d3N3M2KGmIIcg5Xmhh/HJIbC/C8cbe0CdbAj85MW8ZIvGPQguHooXSY7fEIAq7cFPS2DQK/ruvqc9ZnTPUQaJUfQ2e2lx6JNINo3iIJsqvpuFw3K6uzU4J4/lq2NekfA+XztL6olSyexEYmuxwLLhcNq9CdAmwEmYGBJa/Nnr1gOKVyHHeTvmRHGaWoA+/LI2A9y8VEKBIy1r9Wmb4QKm4H5EnD6bMn9ZPlEDElfeLek7H8nqTULkMpOEQ65yoIVm+hPq7e9y92m0ztbr4w+daPTgz2y0NbBF7fY7JNaTq+yeQAtEukvzqNTEpgowjzkc5wylrnzxcw3YfvgTCfbXxikXpZuoVuTGezFloe4I9na24p83vBx2m5ZBM8l0LN4P3tQQe5y5+egZ5RMM/CRVwhTbUQ8fPI+6aN9XPIw9mEiOMCBNGgR4lEBGYDj/cw5JKAUnCme8hzexSgsbiexWfdSsi/yGhatmv6/fP+TbLelpU/pDybvsr7JTtjUHyssC9tY6hcDDX0PpWMMBHhgbZ0GLYijiSnukimplwcjfWW/Uxcz+pEoUB/BiryGieD2x3g4KT4sw67ryLYA1brxBk4n/hMaA2s0HpXQtrg0cYBGRTww8alEBeQwwFR8uLSyAgR6+OCNTy2vjDfQY4iHWODS4Z1b8SlDpN52lIWX44rD7/yyMJPcDB0NJFTwSwOOUUjLqSVuKU4rPkb6grO6QhBya+01boPd4vA51kWZz17Gz13VZQGBHgZKDt/nh0wdIY2PFr1nJ2lzK9iNs1nTHc9Zu/RFcjwN2cqZfgUTNC0CbuXUSqtVcPl2HWfWaQwH8Gn6EHlNX/L2/80kT71IxSgEuKUQynICG69WybVXUe6GdeYq5A+P77pZTD7Qw90kbdZzaV8rezRihUR7MdVo50X7yiE+S9LAlnDG1i2SxcXv7s15zKwSEgDUph3yrOSSyLNmgXNg8i0Z9eyTlqnX82ffaG0EurDtkWwiAf5wLA3tVfQEce1BLToIoA7CaA9jWEgQ2COvPJeYnuceJ1W24YUx6mnZkc2qAzajlO6DiPlAPe78EE/yjMcoDrLzz1IUnoD0HgpiCoafP39J1Ak6IPfu9YMDM8I7wRXe7JBB46OdzNntn6gCovguW8UAf5qKl6jwXd+dNjHXxmrq2UYeTDKSkknBuIOjSWaye2wI8jS/h3cvmhfcIe4FB0q/umcu27jren5dXEv8Tr6tjttIdOaXAINrUHOk1+ndpogEagydhKfOh08Y3xsr9eTAuK4Yx1ZRNSikGD73eUM7PwDk27XuIDUy94jKvzycJJPUj22T06LYeVxiA7uyRpVFo0oMdM8JqMr0NcG90pJZH69H63i9gOhJLN5Ulg+20UTCkKVo5k79lOh+QiLd85Ua6ys/oN1UPk65+VSuEZox2hWfPZiuArqpwzQOyn7E7yHFSTx9iA3fFF9d2s15Ocz2LgbBGVboTP2XdkDdEkcmcTbeWm2A/EAizNDh7Un2bLacdGwve/GG6zCcJwSY59JbkzK6NyNuA9poK+0X5bur9M65Zowr0MHrPnEUtQK5+9LuVbMv+UD5q42xsOhHgl4zlwOwdB2wF5q3pyXXXWriFSNzsdWIOuMm2fnEnxAncBWO7wMt4CLYezJrX3r5vnbgppZ4imXndN3eFUwEa2axXHc/XQUV2BPFp3Zs1i0QKRFk2gcGfvY/xNyL1k3msWsud6iITNPgUVuau+IyhcyVifVK+11LWIrvKfqYl/o4i5d40yQtWeCX7z3n14wuAgbzvkYDFoaIZlbvTODHjpqkq1M7OjKqa0yohmAeEWtrupzILXGEQUdd7LE+eWB8Or//ngtBSQmzPHQw4d6oNZqo75gyte/juGeUQW2KNygb2Mpu7akUHQUHkQIuYm2YIZUDpkay2F/prwEKsTA7wUAosn7DVriEm3ig5EpfeLLvWx2QI3ruR47KSeRkEf0ok5FaLBkU9Wknuy0nLbZnIrHH4P7lSZdVmWvk6jvrTW9HAJlr9Ju80/VZ4rxzUGyea0LRFU3fjfiLtxJXq5CNQUS5D03PpiEIfwXhyrfEXobqWhGf+udmPHIimCKzuqzMIa9JkWK2/EODJndVIpBBEyLD9mbo6v97TJDDqT64s21z2MnWyni1Qi0JTDtQv9wx+UTQ3B0W7Rsg//KicP5mr2LU13P0roq6nTFXf4yjzC3uan5tZDJ4VpwYxPaIE4hJmEfffXjciL7hiGPLKRA0Vhde9dWC/dEXSirBDUDeJrm71kZqj9Ue0URqgmdKFGDSbc9NnCaR5lx+OAFv/lTvjQ5f+HQmH0gSEJuuOzuJDNwWJ+bH2HxpdhwTS/Dyt0C/1hItXRPrUqWji62fm8zBGGtkEF/bicuTXrM9xackIrbElUAtvq6cnlhYfVDhg4pEdiO3iFKw7MbPUL8MQIioqZgeCmCMmrG1COqhMxgQbNN38RMOMHpKceLzOyuBX65KtuUYmkkv2Q0U6YQo18yg1eV1dfLPyaehugm1mtEfj5fk8VveQuJYsvTSuEyQQb4VbYZvKXJu7vR5XPcAuMzfzyQocAc90Vm1cmXt7dZbzvddxZUUXzzE1QkSCO5y0sWYBNKG6WZ/WZxp6OrPYAJLm2ycLR1OcT/xdviHelcTdPBLkO1w0LKko+RfcgbWsZc5JFoDdFClpJrpqRQBNxFpB3f7jadkgdgPr087O/5NGBiK118E9XoqesUauCPxecFuchpYHl7EmVPkJkGN0kbRRP4bpNXuKUdpUrBi/EAe+rMRhcF6TCGj6B/mXDp+Irc97FeAavekOdRDZcHPBz3AmhzhgbXzoImQ4qZl/OP1NIPymu/ys0f9fzKRl7CNwemCAmRPmgZmXoJzrLA78cwNlZDgBo6f1SJCkai2wNhOt0tSssTSuqShD2d0Z66e59GRlrK2e8g+UifRDkRc+w6ZwsLqFCZNu1mAET18DjDX7wT78RI8H1okVHlgW/F+rnUEFMXWoQ3v/2ufP+uwUi9ZT/phxlpK19sF9sYYChSKa+6sRF0trAR/49O+isREsC50gv03zMAmKav1EbTsHeqdyNY6oeFeYS1JhYk/vtiqFqGVU+MRXFlcueJQjOHObW8z28Ua8MCxVHRXX2y/G7rFjsIkZ7lEUCMUhEWtOh3TpfGVqkO4w+m5rhbnHNlbq1zcdEUb8nUo+tjkVgrE/qxceATTivroCW/s24DmzHCj5XMg3yKBPLl0Bp4sklxNPX97q9hIql8tCWWeR3/qiMRoZho8NEmUS7W+eBrA/ByJoVWyencLMOop5ZytqunFBb519MQTnbAlH4fpJoFIxgYd/n2u2SRt7mEHaocaqGXaoriCrHOcwHAcza+7As9wBoDHjkOc6mZXlm+quh5a0tRFkcESZDJMm8k5uL9pqM0N3hXgmbv/gHSt20Jywonm+sEP/W3n2npcq9WKFd2wg+4MArReKD/kEK6kGJsfS8uoFoKYDvJ0DMNNtC3AXReh5Z8diJjoRO48JAVgD9ZZFO3vyviCx9M466SBYCO9LDiY3YK8rtsFmMCm54f5QxGbNTmP2nZLnODF+LFA2vNdcf9NWYKgQH5NjmLJdFgdPuC5BS+IF8ph2Vo2o1ubzirCHM7ugc18PDA8YoR/yZLcOVZwWFL+ElDvuB/GOeY9miI7dWhv5KzvYV194dXPPwv1YIpJY/ILW/cxgixWCxcUwgt+6MKmwo6CBPawQTkTf1rJnlqT560a8fjcmd/n/IPsYVU3eXS7DmANCQT/vN7PI53CLdAg8xDWjYB7xiJz2RPxWP2usY4y3vJAwz6RuTilXsmHU55EYtONpidp7VS1R5JpZVuA9LE0nrkhuNawe56pqmBZ+WdxDeT/1LNdPF7BWHy88huIqMiu3xu9wekSwjxHFMrscRL2wa9TT7LRwigZ9aIMbYWdn3jdfS3VFIDJ07mBLsEqg89duSMrfnBn5MRS+Gzk82yDmgNYvgaZGm/bIf+BPciauCeH6CpK7VyRw8nk+paUSKVh/Jskec9kuc+Y/iv/Q8hk7iXWvWMQsyNvrmkkbBiduwYbtp4pSOMGHGb9H8t4/Kpmq1XAEEatzM1DwwtPpay4vcFfMPrtpC6E3TvyB3IhpuZDnttIkZ5Jbk/Ux/xhdxi5MwppXwgH+U7psFrJAgtzg13IWqWrnilsJH1I+gSw4YBzw6qZeU4mvBZ0s35r1/bUADcn+8J5SN0o98h3jbwpnmJ07LmZPMKRzWaJPqOTKqp8ifxaxKpLQl8b14gbO0KZnSEdw97pF+cjCQJGiHytSfVfb0p22OQWjCfZmaOmwwfpxndpy/RX0ActE7HkXEZ/CuqYdo9IwB4PclZjYjzNbBxdWmbRbZzVG9mdmdOCuFEZFRw87vF3irfPAm/auc9hnmSSGuLBdmUcNkYI+ieSCigItwXCzGAzzABj1ctfjQNbJBO1wRtaA9KoTkDSnWSX1qn8fiHZ1vvrSQdvmSW0IaYnXoU1jZNeuqN46WCKdYJHvo9wNhiIprvcM+cUpdX8G6xqz/M/mhaO0NMPzhEtcKBLpbP5uqmu9HQMfyxixS75D/lS94Gs2T+u41QC01xdqAc0bfe4vidjdIBXVajdldqV3+8789QR6YBCmPMCJjWykc6OkpkUogeW1SVMwBJrPoX4k7BfKhb66xucN9yGl68YT8qADNCJGcClqDzULnCmnQ7uVe7BIw53rYN4Zx2nbTnCX+oYI1wBtT+ZLENuyla9fUQdgkJGgdeT9ZJh8TMFrBH7KjqB4RhT2bEJ6VB/g7mEdzSJjnpwk8p0ndWBQwUorShPy9I66MVM83LlukVLPY40AmCeOYAB+F8l7lIYem4Fi9lm52XLC/Fx93E/kNwFTUC9AZJh9rNBrTJPe/rGmBam2tdEsAAdZx0jcEfZqzHaZZozxk9EtdQHryDs1awMda1bSIV1f1x100OpnPKFs8Sc8mDsz87CYdOjlmOKih9ID3rHXygkpawUX0zOc3uAHk0PvzhUlDhccrS7EPxvDXvNk/TNNF8f6yP1HgP/iYCCbZ5oqS/IWEQ17gvyYzdoRn0pEGrnfSq4GrkkxIf/holSprMfCB9RB5jLCBlr7SoynJlORYkGdWhRnkaxn+y3NNsfYg4L6Q/Ll7V5gXMyVw9wKfpjrO9yDXYHMxJl26aTUDvCzua0ZwYxW8S3RXQTmo8XyloaaBwGFpTS23I9t39oUElIheJsa2QBAhqlv6bPUHEwEacEg3nuLT6pRf34/qEbbScXp325n2/YzLraF8CSjYhuvicVPPXU2qb0IGvS2lnAuTdWVuaOPPC1n1Mv/x6jctc6hb9k+L+bOvVjCz322bMd9L0yulonc+U6nqcva/pLzDS8CwjWEG2+ES5WA4y/2SpvwaoXpcL8bgRuC06jA8mS8AKR3BgDH+8+sZ+FgTsAe8H0H9buMWGew8N3i+Jwn9Zp8KiqVBECJVFDLnyb0sVyBDZyWyp9HAPtZ7NSQ8i6hlZAjzqZ6KovJcmm/UL7hXQHcQ73IMK/OGPAOLPUJfw207W9FjJ9JqMU9eS2VG5EZADc9kMgzPquvtCZ+oae1+gPukFjsCxVrurt0GyAAE4okyM8qAvwmobOFK+oIXzvZTAUApfoGc9X2aUvbM213lTz6CsqX6/MTvT3T6UKM9xPtNs3VUhwpc0+QTkmpVLayF4Wcb0wKLFipyZgHQ2X5DqMDHhTVY36ZwI6JL2ABOYYQWv8QtVjWpa6ZS8rZqDtGt8gE8/RMnD5YdRBf+duym7PAP2EZC80hRQL5dWr6NG65UhOW6NdWOuR7k39t785EcszGRfPtjh6+Y4Ii1+UxqAPe/UBKN/SOPblKU95VqZ3taPREEN6kQK5+vQcW/cZsras9xiFn5f0HGtl6OI/klGZbi6KWB+bXGf0DfpykeCGaNf/eeMjC357zipra1lvPwLavy/67Wj8scPQi2wRKfciu6PW1ZcmV66fbdKrNAxHJRKPd9mEs/yK7k7XD6DFd7ZCZaM7KmA6Bh+YNGGenN+G6AcTWQ4AApDiR9RSs7yjBXw6P/37GJdOVJiJ2SVbu4cWRQccy/+z5VZiDr6hYN6AmzopKc4D6SHOed1mJxkAIgVouRtIxEyECDhA8hjxfN9DAsap1bj6BYP3pbCh1Nmbi2d6obzWH4lQsv9sCIw1Kg1+uLlqnLglUXl4AW8CjJy8SHeSd1m1K3u7CuSAbvDvq8HfXvmN4L5gX7yJRtfYe+WGHb+gT51EMAPkRKxy2MDmJPwCgjAC3zFozxLl38l1p/cFTt+h4DEEETWKWlODoxg4EIEFubOSVof02KAgh5COo2TqxCZQTD4LkBDDsoqobXZmdULad6wQoZMH31B+Hi5dpj3QOUG9KNU6Ml1i3iieWrziu4PW/jv8g/HDXJJeb84Bx2WhAwaqupAg0Fdu/Nioxf0XW62sTpgsmgHit9BBLV6mJxSP2N1upDCpevNoKpgiu2vy2ehTVVSDWPdgUN44sy34i8NewbgkNPpu/N39v5TptM26nCd2ZWocs3HgQaOBojmHBsFsFrgbPB9rQH1yLm/oI7Rubcnh/TQDod1o6iddUjCn4hOq+28qcqO4eA8DD3Zet2YjBxzvA42GVEAKkGSX3Ts/s+bC3371TjAiyRkWCK1vRzgUFTmh4jfSaCnHXqPR9qcVXibcW4YrBaOVIRgaBSoLbJyOLU9ntN2xl7KIIgUE7SHS3i/yfbuTwPvLm27xH2bX+eb4hsJFeRNBXm+SiFo4LoylT0ovBnblXKREu3boM6FaHCZQmfPB3vmkG/vG9QhlKp2bqVEH3N8OOnXHHsdCv41M8dBKUx0oGYx6/ymDP4a9lzdB8tfOccGaBtXSU+BhADxFLTzckPpo/MWhXtDawsX8STXAVMZKkKzwpKI2roS2si3JeCw0zQVQNaoegLua9NHbTJA2SZYB/k2e6PjWKMic5/p8F7ABrIJ2KWwZIeiRNAjV67H5WtlevwQ/nix4JkhIPUklW9JYgWodD6brJT1j3m01XlpPHQ5YR13+rJZLL+yYXgP/KnukUnfYkqclTZ5wjRPm936nznO3X+8OZ2Gv43OeKoS60HosgyQYKpVfmjYtoru1v/0LQJ5qcWCQopRqODNYZ0zL20+LJgMNWAcc/fJjbsyS2ySY5hG/DDLYIsuFQJCS4Xjuh8k/8lnb83zzjOJHk/+5fj3X+TSiQupz8Mo4mBJUg91SxkHHyBTRAHwSgzafSdBMSPwwUsJLx417qoOM3jySyMHVCusauL+//oDvmQBA1Mms1ZQQTV9aJuzNt0/Nt9pxTCtfctYqFAU2ZjA+PvzbAnqKu9frP4YtWRbqmkWrdlkubFrJKYKJule4CCU6pLmcKcNsNwjZJeAXUj4MEcymkAYa3vsssWOS5W2sAASIDhNplnN+LIySxHhwzJrTJeY/Yzi+K+2HvlZtBGYaFx501S7Y+dehllR7p+DyMrwtuAq5EBhl7QjvmBpnbbOyR7LUi0+Tbs5StzoBEqVPHEUWGC14EMxio8VuJvvLTB9hAYyCQVHhavTqOH+/ZXKooktpcAphdMBrJUMd0WbAFghlRKemMgPbpsRRqSWovvP3aStLTNva/xkjK21dLtShY6HSzgeTBf1XOkac6xZMtB+nePGCYCcWL7bbwC9LPLO97+Qfwzmi13iDIioQ6fMUa1gT5P/Z8RQvvwtq9/nZx/yrYB+jVJkj0J+neGMXGeeK6DKS5e9IpApf9R6ELcziESqHRzO5uCCTvlbl3eK/kUbLMLxHSskjebii3bFF82VUoAv2yZ9JboKnyS0Mhc6JdU91jFq5OAEfktHZLVKRLz7lbh+8mpZe+zRLShbPWRf8fIuL7FPt/3/rojhgEaIrsK+Wemv9899bxSJVO5tF/OWmSIX6oz98HM36pvVpMPqikN1IAMeRI4k8KllV1MJnLXuIBOXYlpj9vv0pM6Z8NQ9anFdFj43ht40/2Ej3Wp4CA3V9PZXodvIbZ+WxYL2rbzw0ev69ixUzkI7fIXTrwUs6TJOKfvkcgH2IO5d0Gp8TtwVMM1/XmgidXhBjBvl4V/vHxMP8p3PwMtSdqC1KXrGzdOEyOSHZT+8UCWuW/Dz5AS2Q/6JsIC6euGaYYGTAcdKh8CvjcUyC/cISZWeeoTlejLTvWaC41LvOdfJJev+c5C12oQf3Zvg/sbU6DDbisklZGUgdBMa/M5i5zc0RtGoQNg0UC3MgH2ooLEqBnCNNOEcVkEQ8K68Wwv3yq0Ibw04Ei+G0Ou0exPokUwszlicCGoY/nkrBkU13GWmDxFbKG3qXpB1TQu0kSOcje69R2Qp2PECVqS0NcPY6CVyhYrgm9B5lhgMW3nBwmyJj9GmjWAnxk171GsrDoZw3SzRD/DhHxOxOfZOLuJJlDIQqo6hiv+Qcc+yQ1mrCnTcCS8siMOkLcCWvSUJQZWmTb3YKBO6aFi5R/K0y63vBaW+KGM/Z2B+QYCDsVJ9rE9zibWLvVxC1vLLLf+TyiB+6bHq9K/PQXsmAqgYgZ+YyLDCNrWN1vE+Orx7JyXkZqY+uTbk65pWSrdeDGZolhFkGoKsrTvmGvtY5jLcqjmZ67ovioOQRRY1tHA1utg+2jEs77mEhOBpj+Q0RljzsdQhPuzOfppUH/Wz+3vbLwZ6FMzSaKEsLYzhUyqVR1gw5hxxXa8quJFCDBH3Xl0BpgBJtAcLl6TK2LWhkKBvYJTM6QQgPUrZMMgtIj8vtvtyymIzUAcohVSepYqRDgvhoTjCEjj4HQYOR21Z3hM8mSIKS1zdnBJ8909Q7LhU9ie3dxLu2buK8kjssyv3eNUzu7jh5hZbboajjRFy0DJaLo/r1kNtpTPPoUNDD0RnH0f1QAMeigkYp6l0NWOEiPOx6Z5ufPYQ2i2k296lnEdgXUmozBKPyNex707wOmQ8zg9gYxfOQTNVwo4aZGHO0FsrPYps0fg9tc+WWF4u0TdRj73ySY785frIv94OiGTnoY7T5nK+oxSgLU3EcchKvAa1NQH5O//tTPhDGV10WFPmwtInHVJTI8ZFayGjo8YzcecfOwh8NlLjnG9wJfmDo0vFBx9B1tueCfO7n8CtrMKdnNwzG+QgakwW/IyhoQbWgX8+pM1GZBSPUKb8CcGq5V1CANNt03vYYcrFeMaPNhaGDw0w2H5iBlpuZ/q/fSA7VOsxUgCE/ZzH7ApLLZF9GIXfw0ldUzerx6IBoC3ZuaPmMtEpnv9+0iCVQYYGuTJLjEe8vK7tbmI3Ys3Z7OWdkAr3Qj8KSlkz+WA8O5zYUOsX/Di8qoWNDnasV5dRONR3MQKMb428jWlKGRWBUWOjY2+ThhlmYv9TVzNffP2ptQd4Dz0giP73ql+DbmRfJyKDSjyGWT56lombS/qvAEohrGhYV6UMa+PFGeZ2WbCK7v1eptkFoAU/ozApa2mLcpggHXXruJwUDOnqDMDOMI17HIG4HSZsvsA76YsuFiHaRkGU7cYurag4CVWTtuQzXysiUX87UX9bmxlBG2XTB15z0G9daNOwwwxVZHNINgRLIrUO9nz2U4OUdpriWNofq1pe3TuSmmsKrKsFGx20nXm+t7ypWYsYDdN5BuR6/SYlxSZvR7Qz4/kgtHKWvlJsExQ7v7RWjcPxTF5H3oMoejBt72Qrc5lTFDR7hxFtMDrG7PKjNWU9U+Z/QFaNSxpnn5nbuHP8vq5TZp9ig1xGKmyEwGFgnq1xi9YttXAXpE6Ksp0Zj8M0b88XRtUCYvExRPmULbBCtdn4aO0u7PvgPA16AP2YTFooVNekjrSCpf7sdPl+7Vqlh+isIvcQrbiCCnWcs1/Wud+TL6voFoTJ6SqwMZK9555HJ3Dep3Vs/lIPdstkmJZ0uU7v8VhHLwkR33BFLTdGFVLumlP1+LVW7roqa3eMtIfHSnJvTrgt7bfbisH/rUgCQ3HeT5dtkLwm48k4DKiZvGTJvxk914kYad8ES5xsIvXyzZbC2rpLnuM8uqY+A4sd878K2DeE4+3AiT9Lyv3eutxN/+OeAOw4g9iRuFeYaskP0dRwmKb7MNxUy1u5J0ZWlVRC39UMFyF/wv/FrxBZ2YUEfDUDoMDO8JuLXUoEPJPlcuG0kuLd94mfWOksy+aAITLzXmMk+qD2VqeRSVWX3Fp8NO9BIlCWYhurBhYuQ3t/JCEKAyNiBoxgch80wt9hN9KHrn7jYzo53VxRSbTkpCKU7aYNLsZCTpX4wknguWKf17sRbWmOXH4Fb0E45IbaazGj7N3XesIs/emkFGIYEuIQcqi1PEYgNPlKx0rPsLtmQxN6EkMbIVPxDvnWUER7Nk04G2+fqFsk9N6K4knp250y145c6rfcxghdz/F1dR/uOGLs7qeESPLnaAbZ7B53AzYMgaS4HylZ3feQA/DTcjPizqaodo4nt9h0nX2HQ0BE9+V49fNasYWZ6p5aFKop5OlKg+nfM/wk8xXxWy8xrQQ+D7Rmklg3j6zhdjLwqPcKmaVA86IlwCHv+ewt1RHxZsNc7AgTC3UvIkX9cEiYMDozVQ52CkxNss+H254j76IVDMAd1pjAUGb3cT2B3eHqPOM6jhB6eiT7aNfiBuuivTN5csb/JL5rEfSrHNvhxSPN/9ZmnGWer222ru2rFH7TfepA3CSeUWOpOgCroWsQ2t6EEXBHkTPz6i83vosbE6+ix7KMbK62aSVx49AQGsBRjj0sKkjv1YTgcqEWqjmqVpanAE5lAFE8P7PrRxBN184bKtZRXpte5tENNFZX9y59RXVakT0CHjplrNmsOUw7baTKP3MAk+cGZTFwfFNsVES5VEnEPTTcoGmCZpubKtuiLyBtfgdvsMUnayWb6S03K9RM8gfZzJei5bpPBISrKHP5fOKL7LKFcpY18tOTNBHNWnSserhxdntIK7gxMGMOsKp/bsAgxX80UegpwivMhloejBCKC5klvNzuPM6SBS14AtJEqqMDQIMOUiFusQhZv3oUbxnVRNXWw+X56DYkRJETrXiCKx/xv4I3zXUCCIZb7ELXeXGyhIzu5f2ZUs2KeWxwXyn9Gjxxp7XJ606Ru7vXJUvrv/uvQrm2NF9CxoH3XPD1LMD7gp736a/BjP4D3vcrQWXrQlMXSDxWRKn6AOFkVVMgUAH/Bk/rwSrPPMMJWASblOVSlTKOlJPWEFoEYvRdfcNNuERsfB/p+dIgncXXolb6hZC6GbjIQY2I/4zFurcLHYjMQVLjsbz0LJ52hypG6qTWSqNC32rSWmDceEvFaZSsgPyNoRCz3jYIFu+1PTnv8sRtKGZy9zBArcVOwQ2GZLX2MAh/lIfoPH+Pc0z3RmjjDZB5tUao9csPcFGIqc9yUoZdWoswxsCHFMQsdjefczvCWKJylly5xRrTlteYE6bNJQ8yZAX/mlqS9P8kzWyjpLC7IMnIM1wba5NZMLcM8RHJh6e5dkxeq9Ex3sio31FIei9dCBqOYHBdAf9lK0yrtgnBhhfGVA0umOKQppXgrVzHOOuEJaD+SRzAlJVUJ8hcEGC0YPWKSSSfRvOAqJ3qNfCsFPEX+LchUobHdW2Z3CqrHV1y5FoDL5fgmqoZ4LHxxxFeNDWHZB7YG9acqntlohXvFIdYGzwCy+JYS+BDXQ9it2zqWzZ+jhizRBcuhT/w5jb0mQ9V7pSKJusCql3Cuy3LNsSO4GQIeLDAy28KOBXlkWz5Qme6yc/gS0KGbB03HOlXtDVocgqq7AuzMMjESP4pFB9MfCEOtJqiiMiGnUACIfwX9IC2vFZX3aRR5R0hF5Rg+iH7tyDWupqiW+Nkr0vVbKCCB3O9uPY0TciE+Eh/dz1T2gqbFpgH1KX11s1DmmWM9QqturNlPASdc3JNk4khg+9oFGj/PKvONk+g4FgE+h/3F9W9d2jWrIxBTdS+ffQAW2LAvJYlAN355Sls/7hab/OHpWa9yVx558wSRrNU3W8Qq+81aE0c/pkx3fY1t1PpbeeFCC+kT8ayk/37Gi1h4Z/k+fRA5wQEacfO9/R0ANe10KBeGuc5l+YKXbblJRdM0PeD+15BXzWAi9wM24iPd6EhdkGF6ZuTVlzXkR4xLZYXaKl5Qtu4xFwWWsBX1MeMkRw+RViTUS+13YsiB8kLNCQYCEJ2txNSfir37FO7SiIBtj0HtfgJehPrE9B0Pf5YIF9xk13a2vJFDHYEeZilpLoD375Je8MghJE7gK1y131VoeOpOq3zm/ykfgWmfOIW8nPRXjQ5R/K0kGDodVJYjd94EwCsMDZEYEXdZs48/MHJtOUYGFGdSDxWMRmB6/LyE8/74iQ10O5YzdV9cWesv+DTL9KkQmMRubVTPFmGGqJWujP0dnBO9BRd6gPxqAoVPVm+C51pytvHOuT/MFTv/1Z67NWmcktcVZibWYr/SjvxbEbKVDvYoyR/ZqKugAOije5DXZrIQLDjysEIKgbP7tlGFQY16HM2hKUSzLIO3EQAZM/Jj5kTPcpd+oU+HB6lM98BeGDfyVyBTfsZ1XGayX/GL6eMExl7BsafU7QoV8yAZta+yssjsGLXDxIiJK+hUmpi5fjHvnS//V/CjVGS1e22N9JCxIUOWbFBXd9wnaMr/ER/d65xgDQKxnaCLPNFOIx/lQRkn19kCv8vf+drStKFmff01QWNVMkIvGVjnnKTB1w5NKDpINLNhVEBw+AhN7t9kxpGZbMouyjTFHOZkI1HfIMxZ3Rri0JuTxIXIe6ZL7tJYl70URbDt+vV/7KQ+OOihW3jkaBcu4br/OlBL6dyG2BqfzCkzdwNTY+0VZFB67igcQ0G4cmlV1Sj8tIO/wIsr5Gqs4K8SzP6xvroruloni4q8y1GL6T5dhW3/5glYkPBXHz0h/bP3pICd1rK9jhUW2pIHYQiYAfX0/eobLM2vdC1kYpNIGj+88P9dKU537FAkDSgY5mwjULUj43VoN9rCd5LBluBUuACfBH+kJ9pjomUPBmdd8TWGaDktSjU7rR2KYd04PLuralF8vRg0k3KhFJ6Ix7XHxgXoV675yZ5JCH3jStq2oM6iGG78Fz6jh7qh2IfYw1S03NATGNYC7NMevO4H1E5WY3fV4trOwi1nM2Dm6/DEfw+R8CTmC5KlTOw2h1MsFos4JzeaPIXycq4mmzJvLUXJPnfqBagz0LelC5JkijbM0IR5PMGTL2m6caSPwGig6eelGFK/7xZrleExpmvCGmn1RqLSzXLYyEg333FUW5vunUCUwyTFnRXjMGyKjDVQF5jYvy5mtarr9Vcccracmvl03DWrO0YQUZEPbAqvOMix4GQQPBzoGb0iTMhLnWVz46n/fpIUcAf9sUx12cDuKIOegBSnV9VLXFVq0mkaB8GPOjkVwjmpDwcsZC4+x5VvpszgBroKni/x7w30WIoWSQeSAYdwB6DZzWeEu4sY//XvQcM8KhUTv4xvtbeMCSNLYSV9nh61cKKMePkgCNXtV5xolKH3Hns9bJQoq4UhB3M4RKZ0CiRo6H36FpljGA44w1oWKuISkH8n1+ha1Hn2UtnnJJ70dDJOgqeC/5b7HSaRzrcbD6XOZeXlKL4vjsXgDSsHDXLDMLKt2yhTAMNiIGQL8XKWparjDBl/MAexDIxM4FgYA9nAvl+J5HpycWqidf0b3PCEq4oFuoV9Uaq1PcChArs7dn59qfBMbpFwKf6yDCFu/eEkXw5zkJodciTx7i9E1f0sMZdHnAwb1Ea4I1pwUJakDd1zXBlNaRtef2MjKgALTjlVnbIXM132R7h6xne4MTJLr191PAYobNoucd2X4A4xGpLKF16QBQfVNAHvjRUjI9BBsjcTepeClhSHfeLzEOotw2fwS9X0ekd3/mdidEvQWrGG7nvkVyA443NtpAKSvdssv8uGKY1kbUYWUwx2jFjtIWhqj1aBvgkJSi4fIVDZQ/k4kuWoIK8JicgVlzdaR9G6Ve6+CUtjwI28Taheq4gJc7bDt5/+WM/wqe3wmvUl0epjX2x65WaJHKT4OVLe4OZOukxKyqTLBdBAteRYRe0BYEC2m98UIRGiS/e/P604s/FCYtCqrMmJgB3KA3eLK2lbc9edarV44Br/woPpvGyvl8SWRKS5mjmLuCXx0mF8PzoxESqU/TlmtGNlhS29xcFhaT8dlnt+0DLyWlBOVoqE3oc5Gvv1dUbKljCFDYFdMz1KHx8uTdnpMFebidpleMNgObyLWslobF4rGBnMeWu+0J07ebKF3sKYcWrmEWv5ZG6nefmFbp52L7ybRDVb5ci4uhuF6iUVto14L/vqUfIG1p1EIVB5x9yvaFU1TKQ9e6o/Y9uaGBk9l6Qpm/o58g8XwYw+ZJeq1w2KTAi6t8Z9Bhh7k2rY4m0Uqj0W3fLLfF7RZKkVSFfXgioBYtredJJp4C+cjeumXRUTYkSLNSgM7LWRge2fBSa0ZVEzUWpchdgpls9jmGYoWUxIQYw8rw/4eg7OeaHPxyuxReKJ0Gy6oqaTfyQ76OuuC0ynnkl4u7azI6CdyytHmDaD6QTWUaHZJGBfNXwNllFSaKYcYINomSu4mFx5zs7xF9Gcfbh5ss8gbSA4Z8ChsbvgUBgbMGlFoFev9LEcOE9Bln8h/EkOMF7zJNUdSrsl2x2VMBG6LTs1Y60ppB+4FghRn6qSRH4KVB/etUnAibEXSOgkx7bQxKGA0FTCTwc3jSnL1oahybdbUaOFpqhl31yd+Nn0uUh0GcF6puHnUVLh6wBj36lRkb21wOJuzUvvbna72NR4BXq0+exTvJBzPQDjYVkIh4I36opDYBe0Tf8o2qGdsH3zwedkDwCvMJgK3huEG/l3LVKr0ARVL1/ow2gPW05HzQ0/Gfeg8wxhfqTLB1KeQJVQPVqOMIXjsWU04z9Xa/5gxg/eI/8j3GOshqPjK5+OvY7M9bsaChEEkxXcRIdejZhAALlFWNAdla99SGv3P6vO0Bh0+ASFTPsHRYRKTPrFvI/9rXLO+CxgJTuC9hxqEVomXhQgFB3qCj+5IkSakLe9WzU5+XYgBykz0SHO0UDoY5jW3atNkP1ip3o6xFmdqZToRBgX2yt7m7cgFi5ms+gh5XhjiExNATykyBYZOQ3eheNCd1dL2d+NzCEhJoMuFMNOZk9Zltiy3G94D+DbZkwmnBVp1ZYCrQh4v99ACf5YgqLNE//UOweWIh1x+LmIFE6Hq1qc38Y2QtlsB2WaQodNijuMdGne8TR4BOUtEPQVcmKKmrLR6wMhob9qIcqfNTTLuU9UB3xCSOImcOBhn30lLFnZiCjDsfF1iSqwN/CSmdj3/KCbo0T9fuxx4zXDnLFLWKs2s4Gd8FuolQnGHbUQ1kDx5VLG60QOcHYZ3fh+LLN7nxKeahmJ+AQLl51aa5hMXPcD2NfFi9l4j1IIQKxk4mRUZjGpInhXRQfM8lWvl8fKgEx7aceR0liJlWWRtv4MWeSBOdX7DyFrkUD+JUfAxvpUPjtApR9YiZz5993IQekzbr0DktlmeRXBu2xScOSqq3ezGUsajNfwE+THDutKkHosFQEV2HJLmfoMYsuELjaaRxeQznItE1vpfOpJzRWtplUBXlSlSVrJfwZbCtHhoJcHVrC8W7tdeWUhstv4lMvsmep17uCgXcRYEadNflgA1FUJDNLJvkDIHfmobFGHjLNQUD/mi+ewjUyWHBAQUAvfv7mbPB+kWYe4G9GFJ98TT4a9fppzcPQFHY9jdVu4NL7XyQJrl1j5m0REf0FwNN+IkysUIjZ+KH6qd0wRk9yeZCwhpTOIKs7hMMFNwm0JDPYpc038WKLdvZQIq3MF9hd87YYdbXZ15A8elXnbIPLh5T5/uzCwJ4RtultROdROOOPN4Lr1+mN+tLGs/3C+B9o2fmjf/0n/thj9/2l3X0KbOlQk0LE2eVMuOhcZORbGj1NwJhhuJ+pBfL4C6alVZIsPTZkUDa/tDAIJ9at/j7kni+6u+I6f9x35mJzaEDuTbG+/6exirRoruDrxUv71219i+PNjteU3/97ODFAKzSmKSVlFWCT/yp9Qo5G2ySglCBOKIi8Yu9C86hHe+LD37O/ZSug6A6t1xaWVmsngJbe9kMQqgNIB+oU1TtjLr6ib8fYxPu0XmLmBCRk/yr/9x9GfczIkhpfDC9AKqyH0K/LxVqYxhX+Q+B8/jVSJKckiMpo120qIQ/Us2U+0vHWY1MklbGTI0O4YRMzKXaYG3y5nPXGQeYm7rRYmpLKQrlN7v6XeGyCpj19FPbmDzvme0jjbAxtMjnxmQsA3WVM8sGaRoIA+D5n4mBqJ1fXQEDaSkJMVr/3egHN+cAzi5g/IFC0IQYYKC5HFeUn98M+tq6Ad5oSNAgnIW2m3vLft181SnHYpf6ETecoKtgtGXW7ythr3GoKrNXyKQtWLyjx5O9pNcLbVsla7yBIFMsrr8EBIpkf+6HHIRPoYd9bSLxvDR9bVm5NEtCG61eEni0AEGVfpKTg69a0XznuuzL5iT1tkkNdnHIq6jqTUYQsiHIw5aw3g/jCyX+ISOeDXT+8Ps4btL7VWGzVryhRwyBVI0SwRggiXZPBnTcTjEL6kNRUO1AdpbK63GruV78I1m7zdddwbyDkk4JWRtvd9eSTLJEE7mMzwZdI8mxhxF2dhle+aAPL7fuDiYCZZPTwmofABtMT5IWOAiTp68abku2k1v2LlOLxgKqwQb3HKWoqZR4mZtT6GIQ7UCYY8pd1vNyrKb3W3B0pPr8PUjfe5I4QHs7wYAUqBmYU9hTEXYqtjw/gS3e6ZsXIMyqD7ggAwtHmuBB9Eqwnnx76uLwoEonsITNCvkt2aYmya00h/rySD4e62DRUDDVoR+xFHvODbmZHkacK2xLtFH5V8jJ1obmCr/i0H0cYbWvGiiaF8InJstHkP9GWzZvU80VqfD73RYjM6LB8Vahfr0n7hIx0++bFistXYQH3GmwwBAa5hkvAlZ0U+JgtIxAmeDCkI0RH2JfJigDYbzr4hmUJYWUJPh5Ul/R+11K1K0yWldjRcf58DwRdVAO6bhM531Z/lFP5S6ZQa6E74Ji7pXVI/4zRgnKgiah7p+wlGEQxHgK4+5FPKJutku77/PlWGLnE5ncJ5DbxDDgClPD2L7X5haHhncvBD2bCUpWr11lscRyghf8OrjJE39R1YHrcZt2LnsyRXFE0v+ZI9Odh8PML1ziglklOP+1ahQyu7fe+TlH/H4QE1AeGXr+2UFEGiWfr9HEQXmwYb9v3csEy/+hxEweShDYF32/T/DGgxlhHytUjMq2pHXewu6/WuYwxqg3PGAi+JVe6IccURQaaJIDv+h7oMu7E2qjFl1+icNW1e4Nwwt/rLn0reRg/dziJRuxX+TD9RTOqSmP5dgZFE72NDrs4kfsrKWIsD8JqyxJV9nqexgm1BXfYdorXIQAAEyKprMuiuau5WF+kniNvM8E2zDbK3toVk4W/X6BnPzVWqaPjUClKzhoOrn9fcAxjBp+orennvjgYQl1b6ydE1St9duRPCU8151OAY1UnmFFEyUEXZY7K/01/lPu/WPLREDNjV5rqg9wemFI0zEjsgxsiUV2LsWiShQJJZrhfgFJJyvvFuKPkWhBBjePyHAhQ1hVzCNiJG4W2K8dE4hYQ+cn7X/yOWZC+P7e7hUC3SpYZEvoMsfkRX5d+0dvR5yt4JAi2+r6gbOL1xILqPHntZkvPj80Dob2TQbMZ/snNd2Gof2Nrm/4aa0PVrG3rw3bBv0Bk5HE5Brgi2Fi8gHXw6hY0pU2ChSFllPcZTHHZplmiyKzgHPT3H+rRv4CsxhlX23zu8JxIdhe6BiC5SoYHjvyzFOCcJUBHPpCehddDBqNbfDWX4e2jgKvd0IiyB7y4f5l6ApbTZDU6enes/BvUUiRdX46G/Bu4YV0p7JvADakut0zGcZiwzvP+G6aITaSh5Eg8RiVqxkDAEVkARnb9NRIzMqUERL2sG8nzQJoyzpKWfyfhsLnOOw55oImLtKn4pJ2btuT8oA1OHCyFnYXrIFa3SWt5jv0FXQb2tYGjI6TYC87yHyJYvzNfgLMioptp0E/u8TBF1gqi8YIGR6oXFCXB54LOSfBeY+1jhr8m0dBPAwHxoDHMksjzK56o9gSfada2Oq6JlA9WkINJl+3yZC8CYhXfJDuMRtsAMG7Hd/SLQ/TZqYGOOUBfXIMNSWOAbS3pf7FW1WfkPYXa7HqBKwKHpjtndZxS29qLi+QNurdC6PY4YgJVUNBZJ6zwhbTwaVkJb3WBeulNa0zZYQXayZbTaKn+k66NGGZAci7DQ5CIUnHrzbEDjQW1mMts3HUwhar5SEKpUeinMwDF2Hjji/FZyGSJfd+q8E+WFkw83l7zxf/1eufsfMIA3iMS2EjjbziSKFpB4Z1DkIClG9kMh85JSTWd4+KA2u7/bHwdpBhw0ze9fTK2foWwwfc5qEJ9nzXe81pNOh9VIdlAL0EHqmqpKsyzHx7PUO1vY1x9tpxIwfzClnOkY65NtXk2vx+MhZE0ZlJKSFVk7Ea/KQ7V0y5oxTHbm85yMVoM8/3A4tcf+PyPS5DrxcqOWExDWKmQ5jrrlfzk/IXQpJdxCT2R/L1V/CgiSjqNvHcSdwH1QlowM3C6laiyKUXWBYFEYr+o3MxyoleyrNnUBASgJUTtbPAWF2RGFyZxuafg3zMjevb3GgEe/TtpVLhIne4Et8ksP4w7jtJbD2UmAm3l2AmlStcLBuK5f616ZsXWauIZG1pCZoI7Fl3y2YKy1NB6FggjvjQdsBWxxh8U6oemNd8JfJ4idv5faCt29K9dyx9Gxe6xutIL5r3mxbS8ZpGD05Ff8UPQf2IeaJ1HQInLymI1mgNVsdmxMIPbeq6ftQoh9AhHyAz91/ht96dOyZsyH9O7e42QpnmIputp03yiKOD68lgOtibspT+mDpWZj2sEMobYtniN4OTgwp7trfWhADRI3FXr6JtwtEFXVcfPg9MdUCMkDfJGAEZ9zJUIlyIiWPHOjJLXaomvBPbJTwpvLXieNQZdTwDU4kHKPtuqd66kmIALPzsUnCjiaB7/+xF8PFTgNvxPJmukJR7pJpMQBg4/EJqf0f8GZENObw0XEVlE9lEcgacfa/dkNLKDr/6pPcd/th9iIDNBWIEAYEaxLP3wDP3RPn8SsT/DTDhd4BwhJ+6NJj4EuPp1KI+6mterrjIWw3kNycwj85s6K2rGQ/OP3D7Q40yyB/hUSCp5U5kfweYuCe9kjqrGkFIRDRTIPFNjBlaRraD5slo0JBbn+oInqMNaHBNgQczdzkW1ssY0wislRLFSF+OSSCRJK8tBh/rkwXtLhx1ANEbw3e+B7nJGdGDJL8BLLSrRwJaLG0dBNuBPDSdSWpMuQsPn9dVWI1BuvMACph9D5CCGTrasSxAe35Hc/sDYksg4j8fpNRW6/ltLUd7L+p1P9VOkxY+YDQ809vpqqLA/ESTMUr0zSqmob66MADTXN/oSUC4iweSTCwM5eYu++AythywVhX1A+EqzNozCosphqHhV5/wBiFb9dMkEk1v3GPPtlqJVujD7ONusreLjXMzuT7eLCPDTt5KTguQtdL/WT6lDmIwrkdrQExkiga77goOk3mJ5RwxXenLa7ltyLmkpMGHWZ9NGpGywVY7gbBx49wCrKZhUeRrLH8N2Qr+wNh0068QSOl3aD3VENEOKjU4JPgqczWuQ66I122ysqUVNaqQ/DycOdQAvsCMau1oaqLwRrIZk69h5iU8aqASva0G98ysPLFTuxGVPgu5ob/57Qtt3JZ4RU41rOQKC52eigFE1k/9b/DR2psenFqmXgE0u/iUz6f+RvgAUY2VgNTuhCeVSfqlEYN8b8vRCmkniq9XU5rji/9ZgyKCCErlt3UuPlAy1iSzZSjsd14D/LMl7nMgzN9ED+aRbYyvbAg8yuDJ5yvDDt8z/yem7OWisyF5NGaLM8zWUKg31As15vIypQGwrADDpaxwSQ11RBtfkoYYNBgObAunBKkrgWIeZzzCRXwAkN92TWJdDlflN5MsoY+iqwcpBcw8/vLZgft+/IVKkicII3j9yn+jUGMN0HpTgyKw/y/v0X6vOVdRBP+eIbNX7FLFNs9aM4d+buWGsNKGFEGKdPn97hjVPvMqqoI1NwJ09t06pT9cpGsavjzNHo41ndAZgDSWcHjfrdO80VVB+7+z41FPPcY3ggCOxFI5sAL4Ju2L9Ii3vr8AZiS+2Dr5viIqMPhxI0rEhSVci+Kxq+Rlnbtco8iW0FN7AZhixhL9gux9SJx+EX9zlj4XY5f9T7lCIUBwZy4rtpJQclwFPoDqt2REnK3cr8KX7h77nVs20fcxepHaxrCq4WvdvWCYi+nH82wc+DJGGHw/mCYy6i9a8ktMEi0bcsejILoInTf3hbFDlKW4FsLbVI5a8Wi+ruvueQex+0502A5Ssw4BJjbpRQQQEvVFqkY5IqmFBs+x9wV14EVvsVW8zt1IW6ma8bDXcApQlS0jQikMDQUoqviwtpeds1Z0sftL94GKOk2CBlqDhp2Oj4IL1G51Z/sQC9Pu2n/IFeunL4kWB0rfYFMmML96j3lyz4OtDviQObi6JI2R9jcswjwE+EDMxCkBfkayvfDcXfOiLbIx82TdGOqsBZCa14se9Nj02k7DpIIL28PqnYSfEYKvmjfH4/LkNaixqe82oKPL+6JFe9np9bDNeoJ9QFGPQEN7f2fSJom3zkG5qUbzvrOq0FVvjGS2SSaQyYT58MwpxtH7vE6lnOkWePQ5tJOOhVAZYb4j5aJ4xJEqYJ+IG3Vl1CyOJ2WulsGBWA7UEvq8pI18dJWX4oNtygpZHTRYwoIx6KX3YRWmvRu3L2IgZD4G5phJAEE9lzPdUlf1aqHvivLvaAXmw2FslL/5Oo1Z/60Mzgvg+3UsPs3p5KS+N8BsbpamzMTmWGWwGixpJ+TfEjzCvDEQ3H9NtWDwkIYVLm/1wW/lfOe7yiDuTPZfWbggQh1NA6HNy6kRku/l9BbqIO6DC/ng7wuXeaV/yb1TvRGT/y84QKOIRE+4TB9TOcWK+yR57KWYOqSJmzQl7eFJTUIs0e+3txEK7FS9J09DI9pIPb7MARB3WXca6eNHolcXHfsqPUaNfURc2WTOeooDzeWhLOb5SjTJBnEwThsu7kvUjo34wskpeKHrT9RIy/npp7ZAwY56UqX0Jq7kuOxcvMqxs4NrtAarFstWEXUIHrhd27jSTxK2z0aigYahjXeAe/VfXZkYktX795Q7OTygaWxezfGxkc9E61nFq19E896Ndu/A46V4RJX1zOLKcLlvaiSQ2nMCFwh+56oGYf2Zsr7SjsHKcPFTp135X9X7NlVmtHeKm5Zii2UcQJxspNlgiK6rhV0JHCFx8Ky/fK8i2VG6nT9Vw136Q5xfsiZX59dtixP31aRvdPHsEVABOQWJxBym5X/AwG+8cNskAz5tX7/kfsWFsCZvuuyrtxTCfWIgC8HXUcSzh14+mvmcPfGoBKoD4acaDNM5dmXyDZyFNsusuDSbsTXhknwd4O0T+0S0UimXnlkuxri9ljMf5FNao8PXkjgn+Rr9zBu85jA+S75xuN1dd1H4jEPWLVEZ2x10ynxyUSOo80cGRsWsFwz1TyEj87TufZdbi3EYH4Znig7C03XR8RWoq65j4IIRFg3QjBCSzgQFTllKfhArvwOiIy9+52ISF0Z6RPianNFYRsb4YOO/K5Wl5Ug725qJNYzgBQwFCD981/3B0ErhzPFPq7gEL+74OCKtYVenP4JLEgepU5kZJSiMvqciYzotSgflz3T5Y/zFNAMYKgx+BG0lWoaG5Q5F0gz/P4YUaPxWkXGyhNWPT1vf16gc8xU0fFy4pSB9ShrWn70+FIKyMfJT4j8GPcDNXUhmtfhuT9JnjTwya3+h2xvijihA/7LG+zkyZq6HwYqxRne5ddql4xUYqZQUDXF+K3e8+6MeOjmSZKUyfoB1gMSGsnlmA/X68Tvh1ffmJwnFyS6+QC5wpkHOBPfU6OUpgP3+0ODijp4NIh8O/OSLI127wN7Mk8M2FCp5NR3JdXg0/f7I30Y/S+kdTS3q3xujq58hezQmuuPvtNVYr8ZrUIFdI2Ld/GLXt2E1lYtpFZl89sni2vyn3avlIBh4jq9cokoJKlUZ7ivJkEnHGS/QqwZ9sJbGIWFRtJM9/3JT7N04Xs/9XFS/wIG7GUdyK7gav0puYh2tGMbklEP8BnStrtwpFLw6jzl+i59+2EQ0LjnD1zlwvckbacW0mkjv3oUObgk9AVlvMy/V++PTiwGTMajuIzwmuTjuKJ2j9HcqqL4/R3HJaGmygpNQIkuubOJjE0211+duhIKL/2b8IsZxbDCJ7v9Q2tdKM/oWVZU4v9Cs32ByiXk2VpVk6RF1gLILnV/ixJv0k25dIpyTvq/HyO21yePnceaRDZJi0E0CMaTLzRN+OrRwZ5Sau/15pqpvEGv1jwquAIp1BrtZtr/63s1IcNlltDvphNX5Q7AB7LbjZl7GNQX/qOJU1xPixmtTiGTDzDEsSHC1jQYV0g8u+fSMYnDmWODYHfzHBpiMNmwXfHiXa2seJaoDZbHyEO1Q+yK939yCKiDZs83EuWfZKXrB8/298XMvzwctr0g9AFDamAdm08KBnI0cn94j4k1RFU5eCkF1j94FUXp6Rrc0lT5QpCMDZZqqzNUua7I4zHVt4KZxHwsC0gcCmYOWdrYrhdroo+OGPfFTUP1XSlKYjVz0bs6rLg4e7R+UVR4M5P7eeyGwY9g+75ulqN4RKnFbrsuRFIBn1vjJ73Cng10kgdbiMG+ea212DGP46lWvI5uqBqSOlWYmxgDcqF4apS3d78n4NDm0c4/vq0WUV4jyD+juPel9yWbPtBMssVnxqBgobVOQMcHvbOlqOVwZe73noi77+ZZrTpPqSIdgT4nslIlMRoRjaSSQW9BXsRzp1jtsmwSOO1oHGN8cF7E+LHnGfg5vTnstXkJROaEWwFh7vAh6oBmp4m8kRUMEjVNpvGNmTPYEMzjdmw5d5z5L/PTI6tQtyr90mhMttsKuJ+zUR31DLZWNSCLPDVUPMaWOZljybIRSaN6hCOEqohdeoY9/dFJ+EiU1NsVpEGQL5V0WVTXWk3ibqnV/u8V7ZT9++ClMcgcDMbW6k/AhTeZi+/0QNKoq2dB49O3Dg7tPCA0Z1cQXQVk974zM00rEiHyFmLt3Hw21s4RbZ4oF8by4MmQyeE6rFi02Nl9Q0cRQhxuyFCgJcANNVcSZaN+CpgKvKXiSBsWYRbInF4d3wyjuY414tubYGL+t4yCkIfUjtnuJ8byTbFiMQrZhpWNER7xRSfbw7f+JiJvv63ap/utKpbLwgoo3drZ4vYkM3S5Zodd3IjenaMrsmMALD36h+MZSP6uthYdK26iipjejpiRsOAfhPcIe4Ry3uaQBg/4WAa7d4YIrujaf1GyY995g9ou4zGWD9C9sUr3ohwBdzBf58diPBtzL7Nz3MCMcdEylskeu+j3vpuHpb4e7VnGlP+/HV9x/wEmLqP+Vth9oQi2icV5UwtPbcyviSflTtcA07knueAJ/5bbvy4/umNZAizbaoZYmRF2P04vxyNGYQ5nqjY26zWn5jesYnRY7mNLDJBQbA+hg3MfEAFufmv8txeJb5DpIPY6hnoA/ctWRZW1Wzh2C+vT2kA7u5eM0tWoB7Roq0sUSXzJe78pP0eykN2sa7eviAHp3+/Rc66CwoSXamp1S4quriB4HWYDh0ZEi5H24SByTP5k7tfXeZ7uoZzO5slHaL8h0w2ZyfcrjSeXDcE0lny0541ZFB11zwUAf00K2KKlDV67M7RWG6RW/vizEOuuB5gbQ3/txCVp2e0W6S47bcHM1XUvt5KQ4IbXza3qAvp69Bln/ECOkzek0qK7rJyIbcu5jid4uk9mRd43qsTzZ9MTuzT7+P9Xx1FWwzwUamQXjm+9RdKUIE6rQWgKQ/0YOQqRgX9cBSi+2bYaQhqW/D4U/JllstPzN2EyY3ULRCT456J3QK5Tovdqc6qnXsLzNAfcxLTVLaBYKDt6J0n4CNvFAlg3gDgf29Q7nbKgR+7+Rv2QHtF2k0elfoo+yASFNs6GDsyJzRHQ69CHA7JVOdOvXu9p2dr0K8REhdf3FKH0x6uRpI5MUWZsAIM71D11y2aUWw52aGf4KXic0iVwzUZ2L/HfPmy46zWaKTmZyJdbh4RIbfOkp1JiFChOL6yDishC2WFn2rlHUeMsT85u8GpH5uH682I0CDTBpWhxEBVYdeBoBM+FC5d+wCH215Q0G5949Noe4KABfycKGI2GaGsYW+1qlj6cqjLLbf3gqY5zyMv34X0XmIpd4vAfsW9o4vbxwFWuWLHjELhmfLdQhhKDxMblwUVafu4ObzZhmxPUIcbKtk8dslWdZA7CzuSkdbv45rtEPHHhG+RF/+WfwRUf13hX5Hnir4Olygu4CnedR9n84KQJWWnLZlEnFxP9zg9e2OiAHhQT0UWlM6crat3tGd7F3InVjRG6slNPZ9nNWfnk7nm/PljeXFWWGxCcs13j7ep6FgnFE5bd00VLZMZDY+MGAYRtppyk5QFqZPQ7zd/TJTFoEz/DjRGdmSB/A547tWoP6julMsh2WYkYGZqTRp+LKuJ6vIL5UcLu15mo3eJXdCiv9PbWpfk2r0N0q6Vcs1IqJYYfWVviq17J78RH3Geh61xsRs0GIoqvXaocS6c6FmQjm9X36u2Bw0ZQ690E/thmcIHYTmszxYTam/+m70ptt9/PAMlq8bEc3hS4PVTi5piDoQ2DdkMokhX1gUXBhZkw1FxHWn711gvpMY8rlltCo1Knrci4mHwxpIxcVr1tmxxRq8EVQ5pRSXLy7twxMg86MlmvkbUPvv9VpJRRd0izVN/g0MtcHSMa8XCyDcWj4cz7W+jTSm/pZPPm6mrKBXKRPSZBTRTq6Q5i9u7kEf7ibMp1m7EobhQ/nufuzBB/PHpzEkDpIshi19NwC3FNcPFVC6xhDmmmmdukDKcZn022l0ww7sKTyi2XSyq2Purp/GRqA5vsUeA07hM71RSn8ICtznXzLkhrYvoH+57r52I8CrmqMEXHjoauyQOugQMwryPbAJCfWHy7ZXkOz9TlH3Wd4ESicTgs72WiFTYziK8jyjEylGf6QDjp8bovng8JKxlw8fb5DFgDJbhqDw8Hitlc+EZ6uTBySPrmahW/qLfOPEciYZ+WAgLx1rtkvRqqOfa/140jNqx15XUaWqxJM8QgwsBcJTgWcv56QZ20N+wsM0Suw0QSi90IyAT7BhX6CST4uK9Is5oQR3nu8a7mBfrWpltjiJIiZXAN4qncCQPNM88Tq0/JdQcWgnK1FGnvSdOCcLSGHDu4rUU9GxrQaONgjJnjQkVdrs9jW+nf/huoQ09fn0EeCWWvuf+fmUZHXwT4fMa+IoRNfqOwQt1zQ/oRJ1BgnQAwYj7f4T9NK841lIXMhK1muc1wyq0Xjejm5jzTSTgz8AW8x9rt8/xzXCheWaiYwilQWlAZrsxHtT20xqPyHhkctTjf/cy+n4QNahFRy/W8reCGglLgtRseIoEspyWryY5IKvasN0kltp7fw90UsCvD76KF4VvarQxaoGwuLL4UMfh/C0FiiLgmniyvqgs8ORzOIA8/ht/DD05tR2j3rCqyFUwWXPhZkL2qlO4dmlKrZBn8a01PD1T2sBBroJjyFRZMLL9bhpKtH2B0FNzCPXAgiqshy8CIZq0w0kO5R5P7NRg9/Pu9H+Bsi4/fw5L3rnAuIi+RNfAanhhnDOufqVGBt+jU1anmhROuhmv5GZ1ro6+GZ70A3MBdQByTcTDiAaUpcAab/b2hVK5P/E9Xv7DvzchTYFuSc0L347huKuGLdPthU6mI1VrVQk91TPbn6pyszDX9/xXJJZLowUcluvVg7aIF9J5Zlkgw+GI9M+sFneY4lrZe+1rieVfzwMd8Gc4kNcXKuIcn1CqUIMxkm9JKxjgsuId986w5Ejwm7y/ThC3Wfuf5jGUwgGCIU9MajBnt8BvEl6cxjx4hmJc7lhP3S1KnlCf2jBEvU3VK0JnlXPE+resgunFKHuopN7r0GIc4EU5DVtgdUhuSqAgWiIIvKFdj0DJLWnaocV3K8VvdrmQVBJJSj1zoi8u5lsSTZvMgi7q6LTT1kPoN2m4rZ0HMaCdGIqNhk59fRy6m1eUjlxWtjyONU6pER3G3wF6BvpO8CNw5L7rh7IB5NpaZVXiRL1++3s77NsCVxt9M5Gs8Ops4qXaZVBU3m52yAvFDiKHTOApNYtPeiOwFrLiNoAY+e3/fGpxJvqHJv76YiDZ5dAYzsvSnfBXf/Z1OUCYYiYAmp9UUgorEoZk8pKqTmZb+MoeVSsG7SsMoXfk7klVN++B2Y0jVCuokTYyffyR0vqKYlLR2KYFDIQK6e1q4t/whZdswPbLrp5KP9Doejwa+MF4sTTpa03TyJXZHNLFR7mGhDq2IiFWinsqUx5zSFed9JWrGfMOm8tG46F2FkBC8ySlUoXLnmvtdLZ33p4WF2xXNc5vI+6PQ8QB+5SlAVfAu14OchzfqFfE2DGvLc21GDlJ2AZ8lZ88hbEZpvRzIr81k+sc1zRtsDDhwW+D4DAXqwADLIGZePYwRyUwPkdfhBg1WXo+kiFqdidvnyamn51KDSH6zNSb7xRmPLX0w4+hAeHxbCpIdwpv09ilmi1e3LPmLVP9UdhRbn2f3KSqGRin9WAZ7kmjN5GrAKjo2mw70wL58LYEsEj1vrsw2z6mHw5G8UrX8JRnEfKdfO9n84peDSOIUunJVzDappJA1DKTpSqhqbGCk28Fh4Ohq/QwWde2j/LeLTsOoj5TPaZsfOAXiLIHB4GoL97qaLy2OVa1ue8CyayBBZO5tBfnoDihNDn2InmIbdjPI718St2P2MwmGLcSJdPw4argUky+HGdJe5kNzivUohtzpB1/iMQ78N37ImllqvTHDinHE4YVh1jS9URgqxcF6q+reh2+h59XnqZOy8Y5NaqngFfsAjP8+tqJy3AVR96OuWEGl5IRoClUKUMbQHQBM4IqTK4Lt7/Tp461+p+vgj4jxnHLfuE/w/rUjBuo7Mso2S60PhcBLjIVbSF8uvs6yztZi2dw1HpGqLiaj8xaUK8YKaWzQ3lGDgGaAA2EzmxLBYVWrHHwA54Gay+TrS5oBBx57hxBrGIcVGRjZMGgnuYhP79DCetQSOSbBbIPEyc5jO0QVJJmEZftGo0hplvCSHCcbjhT9FPVDSl9qia9KOhcBdwTJ/z9yb/JqYHKmgnDSpWdQw6EFvzJ39lBsEa7JNKoKialoCof7x2t13ttsEs4lLBbbqFBUrkr1o8eSGE5SvRC2kNIsPNtDSef3MHO5QSrR9aYs11+dEvI4ArbY2NsgPpjkE7TwlFwADSG//gkiHnWLvZF1tCgzSqDwepyHFxVeaXyYjugHpFMECdEMK3cOXqDM+wbG4fEUjV/T+t6HEN5MCLyplEfVF1uTOWKhQSvmw5dRXaDIjQdo78ljMApjwDFnz5MOutrQ07DTnpJT4SRbTstLUxBfiNvtBTYOjoucCjCxsK5T3ySHAh5NYl4dUNLOXsFkLBIVuLA1Z6fjFSndORqC/rdGTWz7sU1gLFbOU91RIc8nI5nqRCW1uC40+SNusk6S5iuK8qdl+vkgXktrKa9pRFUi1Eg3P75oKzcnTbFfgjZdkpRWY10WbRY2UP79MZdi3kzZ/rSmw5OkDVV7jVi1tvcRFspDO9MJNSnkpSUKlDFmNQ4sJCGUOkyA66YniwG6XMIPhOfubOEcjQifwyRj96H1G1AO0MYtuGrTYljF4pYocfnkCs93Tq4aBe3RZVUAOnVe7wUF81iTGhKiNi8qAKiBtIBC6KsrR2I0T8axKrF5Acdlgzufd5G0vSt/vifgafgBlYRIJ3hp36mJagl1PDKy4BhFC2TPLNeIkShRuXKGbuW6u7Q8nn6YW4aWOwPr7aFzup5W7yTTnzyBGQOuGz2Tc9PvvMm2dobiZryl+8hgLQ7btfFjIPfs1teOWj3q1w7wZ56B9M5I683qlFmSbQSAnnpMqfrWlud1rwZTsur39bAKpUYTQtkF8Qcrw+9Ahuo49tuMCVyudZg8MqSAtDuMNc2SlWO9ABbZMYnG5Iup6hvpSNtcS5GulEVh1PWXP5A4KmuHJvgdiMuYfywvwOa013QEuPkiynAD9Hw25jCq/N7qQ9bIzatVnl9qvYF1ZZlJnVzbFtZsTphmPFr3EufJjRbRmacWGa/t780/J9fuOQGwVOpuKgV2coejQ/byFeYuwwJBbMmLM0Tf16MSKzSOgu9O+o2V1uikzR6Jd4zoScUF3WiF5H61v2EQPO717zGLxY1PqkDpOwfUNjST+OXsOMivU+ms2IPea2Oy2TntITWFz+6eM0DcT9mIsZq6rooP3om/eWujlyYV/sEMZ4qAgCBQ/oXP51zlw9RT13zXrBQXL0RRkJ44eSypMw2GRaLYnUeGKhzlaTh/7PSyVEn3xo9VVwOi8xaJwC/wFlIVUz0VXWsfjRqLHKW3Mf25IIs5UIWZKc8trrtKFiGMZivTUQt3NqFkxc8sdXjtHCz2MHh6pIfRNeCj9YQtIFfkQX9j3zx8eFRVdHwqN91fmm+QW3JVwTY7MkInA3HazaiBiLScMPcuZaJX0OYQENSJ99IKbj7XQcz82P3eCCIOKQVgRJ90z6zcD0R2HKsMDZWfSIRTTQosev7m2BopXzi8ydpJ+Nh6a6XPI5NkRSfSjMLe/dUafBwZVHb922RRATx4WSZcuC0oK1FtbHS7wWAqPJac4kjJvNeYJVlQI273Rvh/GM6/ElTzNY+gSsFANF/dMHENaUH+zelC1OMDJFBMrmE2Pb/9FSk4DXGAtEBjB07z8YFKkYKTY+NxPS4KGS4cmpS9TvpT2bkMVovLuEYO7OzDX/eQTpNcgLefpc/7uxkiUDjZ/JSUf8IqHJFDrbLE9yxP8Za8ACk7R32MLSqZmQMdWSuX++9qBf8UpMiTzjSKQqS9hnp8POh1aLz8nSb6Au0rTyHGn26cJTnOp04yGrGCYQKE9LNufwnT1WS6K7uX5gqzK6t2HBfu48VQWa/CquRVJ5AiIm2KuRkN5+D4+JnHdj86z3QBfdCF+vLYoHPPveqxtrLT4YfUcRab8B5gOHuV98yhXemCioByCijV0vuRd7p16EYzyUu9NrnNXodb+DU2Vvzw/5ICiDuC9PjutGpZJSyYWZM5BsMN+eZkqdV1WyVwFwf341pISHu/6blaO7ZaeMoZToGeQiBQvkAdg3hy4fuZ/Wpt4T+un0ufnV5IpTxsxrGg2T417Z7p+NTItiavHg47m+g9Q3k9tg/bxSXwsU+fph/xugQeCVDYwWrRIsVdYfOGrJITbcdgZt4Ni8ixjXsdI4dPdvzbSz5GMfFIciBdqZwDl7FdkPfCY/twZ0BCRCzbjn0LprXhGQ5qZHynUVIlaAnErwCcyZ0GODwQ2F/7HKWf4Vm5PoS/b+c/Ou4B8Y/+bWHuPDhkvFFGiLXxlNgenxDQaZFcQ2XJTrRvyIl+8+CJkpHxFOfI3KCZoyuSd9B4tLk3MTt2IW0g7fm+8EYwNcZhMXzxKOhEqdKSqc3L/czGoY/wA43aFe9kMkZzdvLBSQYeYsx2X+gvo+pfxbkf7oi6hVJ05pyX7GNQkkbLqFTJEj9Ui2QLX0vVgTHPuPqE3T7JyY0yKKMAipO3UJjj/YEwk/MJcba+PCyjX0CObavHKK5GWg8Cxc82VJeNCE+1Er+X2X+bCbZRTnvQpMe5UkJW6FBUVnUujKr82pAaW9x0K2ewsQnuUzS3+yeKFuju9/F5yEWlTWF3tokK3RzyGOdukFb2gd6qRtPkuiqmJtssxYeFcNll9A0AeSJ/DLD5DgKQXlaRtxAgLatpdOpmeDN5PT+2sJfpv41mYnMrBfdK6SpzMvfKjr5OeV5fGAtNOHnk8qLUW7DX43mu1hDb0ipHTsGtIefJIN5HvAqtC/PETUPuwHPbCVocDtRgH44O73dCCVvKdh7Fz5t0Skk+Hz3yu+xaxHxnZcEfMMrasXN02UZEYLs45y3nqn2zJrAsPEpQY3Q2F2n8NzCVgArHfqYrQuh68NlIyLjwDhWijkChdpfjEqIHbzYy7MAQmmYqB4uJ6Q7egOp5aTfenT8ZIFcaSCWk461IwsNcfypcnhGgVI3FT14LC94+GEKhxPy0duZj+oxzkk3kYmobtj1K5BY7sNnVUKf9L1g/nXfrgaEc+t39PDbDf8DeU1T8QnoOjJQnPlq1YZPPewRuAHkE2ZeVHfPvTe3C4aC4ddqGAAbi8+X+NocjXrHLgrPL64SEQaLaTcadnGf23QC3zoT4dhz8Y50hZdlQMH/fulBmwVQXLyGYyT11sTYcUNInQrsfvVMLvSDTjnH+AP9JZ2cRaRRHXjaBncZ/ZGYUbU+0VAn1pDu782BQXGcP/Bgm4L50S+0sfkp0bMVfCnpeuzxZDNL+AZh8dmGQj23xF1xbgVbK2QIUkMYgGv7oaoQX6AcW5EqFVU2ddEo/8E/Y6MqAPaDoh+j0D/O40RL4a94VBPtUKYJ+Wm0CDk38WocPEWkNYf+LmA7N/NiAnV7yABG+ipsi4Yvp1h9/1LET0m9RP8wEeuYPfyeo1Xdgd+i2r++FcPd5nO/owieK8SatbEMMWQvULvjL/YUR9Arqw08+Nbp8Jd/3F9jyU5imSb9bQWUl2FfPX4EtcM+ognYQnM49ynYPzNCAatRCTx2AL9kZEtEuUtzGiyr+rD/DcLDRxffRo4X9rwbxsJ4KtCMAHAt87oHYvdLmpm+aJRpwB4zQtkGxxUH4/7zxKxEvpdM6FZGmoEXpGGSIsGbZy9MIHh9eWU0iYiigovoNlKdSlz4cvzaGm9TIIBnk6nsP1BogKVehbRWM9PVfg1WOVsd/SPDoP2+uTQKz3UoZBiZ8Gng/3nfgpqYuvkz/a49kLwqxSNP79JQxrtXINzy8SoNjgWhGXPMMA+DZieSgPqtaCysKZbPya06hel4SmHRFsPl7ylsJ/eKDS8+nqlfAJr7BVAfY6WSjWeYwrdO3x3xxQOPypHuL9ovKa1toFHYFVCOWL9+kg9ssRrrDMNUDwz1wyXItQx4d5d8EKnQFIxCXd3SE//JtZy1GUYlvjLsM1K24poHqYzGT4j2no3qkpkqltYXYTdpMhfCoIr34BPZtz/1ZYYGdNBPEQBFPubGQH3k1u8ev7ZUu5qJp6xgU9qUGBHGwkTxz8d2se9kL0rUY5yiLdwQN5CB3TUGy2+CQouPxFaMF6H4MBTcaL6gN6ocmpNzauW41eweNtJiOIPZLPBIC0S5M037BVuqsAczkfnxt+F3/KuairZTgObFloiTISBgWPSvxsFfahTA8A3WLWsJWX4qKFRT9KotosV11gSwfq8EgMm5WEun4fTXR/ZczZDRBEnTlzaMNWkFRZSEYg0e6xEsfZ026FQLek7Vr6e//Zo1LMgvTZ3FLm3tN3s48pnrc/diCAjPz+dQLkj72VKQsKkxosQSe1gjXJW8Z6fxdKqxHRIqSjRiIMcdwRE35hbho7YuTJdK2GEhubz6tIe2iCeA6LXIdHxiuTur6XOz+cIVc2cXHALQKFveSkSos7xd/LJrrLBF7/EnwVNrdGHRMDzzWfKFhtVpqON6K66qsySV2vzD5OGYLQKuRFlVmR07U3CUNu1bVf59TqZXiZJjL7hkzANce8KP/qAu0/Zks9HSFGo5SdfnZU1TVJ9A9gJIH0+ld2b/3kqTeTgDMHV+mIwZ0Gnqm4VGrUfBGY2xcyDml5s6WxdT4PNDvDBXtnx+pKiaajygkGHIgkVyUCjI7W4Y6RDBAaaoz5zgPKgXWUclT7KYhN5yCeDRD7R/Eq/IFP4Inpw4qd3ozeRtbVG/9Rtf5lPVR+NqW22mE/X42elqBRTNt0WvCYVNnEz1up03PBJ50v+1ppPsiVtkxcFXXByhvYuPfNi7Rw3fFaVz5NfIPqaqTdIivQPSn+1Lbjw5HPZWlNlROJ/NOy3IBGYchbhuD2TN4oxSmgIHdh1jtHViSveXhdK3ZOqedhbyvPv99jGDpm9FbQRRk+hwntGc5xEC4gAAFZlzMqoAcPcZFB3yjP5VO4bKGISPBsNC+yr+4J+Vawx3GBsC9uecsbh/7RHHsuaD0QbsevR6yZbVSJJyyM2AWhbVCV+dMFHc9aA2J3SZMBczGR9sOVLTk9GNT4FWNZxe4AYBwF97dj9ZDNCgyMw2a2OLnVJgM1N3Ou9+Jc1g0GCGR1usu2gnhEcAzTNUhkV2X46Q2P9qOIxLOz1M/MrsWOK4D1s9tm7KShsPOg5it/oL4vfoye069EnJt3pqR9i5sNp9wFJDOfKailU0lZGSOexV162w7PF0iFWwknZUW2hZIOXp7ItXixxhVRhhMjrf0gZNRXm5sU6c0Knmyiszh9pUcQ66wOJBUKFu8mbMLfz9+Qo0O46lY24hmNSW4Ief6YsWiGCwi9ixpE1EHnDOc3vGikRZD04c6sUYCqJLNzV9P6dntQZavv4D+lPysIFXE7agmMQEeXTGb4F/41iUBTdLvNwMwVSgZDgq04dEkDfVGQA6bH4AL3YCu7ZgYhPu4BGtmvggmq0S+noF1X1QAHbba75+qAcQFJ33ca6ApdkXbcpUjDDIMCVJz9XnTOo0y9XKYzdZjs8IrexI9d0fe/05P3zO9Rr50Pvo4/REOKjzqPkEqWwxWJYUS/1FOLLZ2obWKh4v1y8r76Dqf1U0P/F+uSp3xn4tvSuAgwRU+MSGRHQtpoiEO5e8nxuoQy/VRKMVXhTq2rAFvuQxpe/hnUwqmH/7nyrAhukPSilR7hpG1UpWxeIHeq6nXdpl5iyDq0Kj8sNQWSAhm80EvqQiETEOrWfsxYO/+p3QhsSB5NnjXbuLLNdDTq614ogvobQ9FcGxI3ebKyE5cs00bZilWQz+mpmSm6QMenmdgCnRD+UW0HnUfKGmeW1Duxwjxd8hlmikPphai/bY9LnSmY68wWxtSq8XIC/g9CpMzd4a1SfEUKeIL+rcE7gw3va/3kDI2lqRTd96o8D46IfRuar8MG5mAnY82S6sVBpUVyz0Wqzl4Gxv6ZcfOMGzHe06RqCBbcjcnSY8GurqJM+BpkzzqYm8r6IY7zFH/HMFcrN+CGjVLDXKGF5HH9IL0Np5QJL/tD0BbhGbqI2xei7zE6Q3S0opi9GL8TY1gb+YzpryWU2l6ZSw7/8WejaBfttZkMrnwuvpu3Agkh52CWWmSkyNrtE13znXUFJUtllv9Mpdm+NOnGUBmg3+a9EL1HNZ7rifD/0+YYt1ioUkCDhYv+slrkV4DMSR0MznAf94NJlYZbVMNZfd+95IsI9JKRKe7Aqo7sQtUGr30X3l3hYeqhPui0cLFlvSePH29OX9uA2SRq355fpldKaNhaRa4Sxjs0AtkICKlmduiPgMV23E7+vrtDLMI3bfM8ZhWQimTTcYYmuDULO41AGTK0fUrAd+bxgIi/RQrnUfZi4E91x9rVh7aeAMqIUR/6sKojXaviCAS/g+CYKrh/GnYHUISP/1G6lqs8YnRClDgpaJCW7+m4qOXwuBqgyseE/byamjpS/vDUUP1G+fUr1QTt8cVeob8jw9isr0Ae3eb1IV/HVceM6wcdYPdCj8eUiAVEhIG7qX6/VhS1ybyNJcmlmods1+h15ItUCNT9IfztIxl+sKMigKvJA3brCTvc8twE2EACeQjNXF7+95z4bWM0O551iglIahj1wRFQms4HYWNTOFJLYkZHZ/F5SRxo/Juqi2XpR2rs4e64TAgyHpjCpfJLMkw89tvjWvfhQk6T50LR4AVCa5/7alhQZ5eTeV4zn0mkwF4wPZwzxi3bhZMR//s9O51AmJMv3DyV6z1S99BTu/Y3pKmcGyN9YA2zAbwYNMa9ETVcYcYLNfr9kB/pUOY2TzicOcyb2P2jYGMJqYAJ+LL6cfOBTe7TEu6ty2yTbw85Ckr1qfl3//VTdEMXgxIzuWP0jDu01uzUnnEZXJTc3da0thfHO4ef8N8bBuuQ6RH8xjjCCJkAAd2Lgx2aA/1TjPJh50UpsgR9rk1+Vz4uNtXEZ5dKfkjw+gIaiYXQTRQTZ/tWo7j3wx0ErzG1iD3p3I2DWCDZNk+1xkTDQ7o1t/UY/crZqJZN7Rva26OezeR+yCt+/nE+BkZ3M3vPUG6b4J1F1X1euQG18l757JDO+BDUEdM5Q9o9ZLsWy0uInJh9fOL7FnXkdK1YlaZJKFKL6tJg7imJHswjqCDGx1BMGOqs6uk62wQ1aY24MM0NRgEYU0h6XNg4Th/3xpjpXnz7jjTt1Ji7uIsHVAc5YalW4ufnUnk5ZxxHUF/znZ/p8Y7TYRgqZ20hmbcS+kl+RKlS8kDMjRE204CW4K/ePldzbQ8Q4v+nXNJ2AaDIPEbNmFKfC2Fk+eKM5pBYk9RWIRzNBzCT9INrA2wptXKTngNHbbmdsnf9hmUS7f+vqRHGi50tOfpodrIEp4ZWJrg8GGhBsCHBwEVOR/E3txmNeXHUz2uMKlynHx8mFL70h36T+/twkHibh6dAHEtLoC+xQhGhH2DHWiANahVPHaMPRgNjF2UHlPqZwv/sBeDdVjLtIWrphnel0yXxy/3golOt3xfH68GaQfS3Gt3TdwofgMXVfE4+65nb197B05UWOjBlGvUovZoAnguwoAA4Who7G668Ql9wMfQFUPmJyasurE6SzQaXaHJOqH4Ub2rOTBxyf75b4NQMts1cf1F+xR92mHkbBrEXz7VnkJqttSxvo/qDk39RtoFjJmjLulc6mFUyVKBx6cBt5TIu/x+WV0dwKGhKfZ1L0ZRfKi0W8LiXgmguHxBfcPzfUo/IJhi0yHXqSrlDV7Zfm+VbyUOIyrpctRyqPOV5fUNRG+VzdRK2cw/7CRDQnbrfrbCUEWXwhUpdzawCKS2Hg6U6C8N2RFJfIN3nv4pHnRCYkUs0PFlG5xEGv2YdoY0/m7YB3QhjT+FlqPTD4K2v+KJPlGSxiyuHa5z8GM3/y9x756nDHM2CB93jpteyCs8TPz2TooJUBkruWyHZj774y694NtimFUgPEWTvgHDiBDnmfbYXefR7e5r0pI58/QHNa4bWms9yZk83rkSn+hK+VzJ0/ipd4X4GmkGM5Lclz9sv1paTyjxd1qKC/Nj2+t85TIOkeHCmlNFarCEseP5hdIvDnts3JbO5FynlyELy5XD9DaBGRzSGXCq5oYWGgrylHMr/XXx/8V+Awm2AgVy+Kvf/h4FTATETqkUx39tCXsgvD4wsv6hO6AhlGD4c9QeM/DRkD/BraxBH9LhkbZ9ylzARAnhlajLoE+ORZ0W3eGu904ViHgUddJnvVcST8rbsJ/Q0oPAP3drb8tAk4CU33jHN2cKrZWf2bPW3r4HaoV2KPeOEnt1+MfC2b8WoopQvZrkAp9ohyzl2ivRln3eFLJrlaAOhikq/DH0nZNNM64ttS2IPk9c8cuxKuI2zkyt0lerbAgy/voCUAwVfnUZRaSAsNHjXTW51PeDVx8Mm2rLXW2g7YqiNkQGBu2oC5HcjAluXDYegBfE+nxGNp1RLA1y+r1ZyIDf4iz4yM7uGy+AZbCI8bT6c/yevm9ypuxqk4FgHjdepNi8iR0HsMEoRMI09N1gPHQRRw24nSMZkiLBgH6SoGI29sGKdLq/k580N0H3iLyb8U69ij4UCN7X2Jpqa6AN80UKxE1Bowdy3FMIiNskypSJZlJKKM3TfTa4C0pHBnXP/nIaCNkhjzGCgInsbZXoIgFppHzZggYOGxkOhsiMO8X5indxI727cfVe07HVv9Y1QH3ZJ8kBLixXGQGe1xPiHmDhEGQqgQDvYarsDobqryD+9V7iT8odEqYHzz7BrICfq+cEYQ4L40dtix6GJNg0OtkIAB06jTQLMdC4aKHFOPYyj2K1UFApl28AcRgAitqQlOQIX4vq94ccEd3v9Ul/lgZra/Q5YzsRWlXHfgUVHl/dfiAdMts2M7YRYrRz8wf1mokpNineZEuSH0lD6C4CnAHYqypRAD+thCgjeocTeXLi4XB9zq4+KqEbz4SwD+KFA1LOqpJrYdqSGGIwp6N7I6419QqYg0C1T5o0gOzyhSzbvaxs0MSthpyYCohDX83W6/NY7Z9CSoL5WH5UrBF7atRPOMlkKs04ZqM3TOI2c93RG5oGu9Yg7wjdl9GifqTA+9R/xC3ZZhLSDGV6d309bfRMPRCXWS1GNktwAvCJKoaocDxv2uOxaXI6ABUfzT+s2xLLZHJJbXoPD/QtmRZZ3ifCM8s62PY06fVmrwN5RpwQ+qg9ZtnfFkpEypI+myg36BHx1Gm4JC/AFVBUtUTJEpuhyUplUx2FWPJP701Wph6xPoYxyKofHDbM5yICZUJX8iE1DBgBg/yuG9DGAVrKzJzIs6fxMEUpGT7j0C08lwhE4Dr7l8ndVj9NnxSC/i45ghBXAg2lvOAA3v+5Jgn7ijRgCMGwmeE9rSOKM3KBMwiMay7wY1YMdlYckFMAeGsuT0uw2+QoFEbnMw5NlOy2VXCawCftu6KnYd3pFl2hQRh82qiGNeeWkq+BOOv5awaMq0ehgxc5UqjR+5LBgK6U0DtsmDQvCDp3gW0pHlXPCKlLFuoavyQZ3jshFFj+8+RNgPrMyA++hqxZeqAEx0lccTU3/cAR/uMqpdSQzci4uIsKbDXrLsgbwJSaaPO9p34LfJjZt5Nzixtjbk5/P0Vg2xVZ815tN3RvDdIOOgaSOWJK8eaQqtbaB8wef7tfw6pLkIG5xboUys+cCwVyfLW509gIq+axUjGu6yk9RJoDxGx/yZYp9ETATi6+8Mad0ZP4vY/AFLxu96iYohGVbVyEzUZbx9D2nMSLQ4ScWovyUHOqhDMbI0tlQ9u3tZghPBWVBimc7yV7ekojIfxuPEHrOpmkQ8IDUQ+qR1BtAum/drsDqf75OMLeAH18V4aHfo+awwl/xxYggJ3MrjzRtrqititBcbamY8jT0n1w+3ik0itPYyKaRpKXdsmVgAnVhO0E28xltNpXUWb/9wjllHigoxKAXDdGTTzrS1IVVdbcB34hClMofiPr9D6eyBa5vldmHcxGCyIjbjbbag01jfEjGDw85oYvfbsqv5TiqdwhJBCKmVw8Vs/UByo5kgd72PteFDgUZbK72jSMFnOTsSpRZQ1wuw8C97bAv1/IFIuqbA/Y4wpIM1vpxocER0cKSG3o+GpYlmUblA6QqZnBtmsTJ8WDpFd+yRzzi5A2a60g/IwlwR8NYqrn77zvwfhqV8FbjYdsUn2toFjh44vF9BiiHBYe/p7nK4v9HnjGriQcskgzbULWK4FjoDI3n2GVFQaLmo+OzdI9Ke2lBs74j/FT/Q0LZpBiZC+l2Ni8eZDTT1AVG6LFuaPu8jS5PobQ6h9iCQjkEA9QQsSg7UfsBdKlJjx72d6p2E2UGuKXTQYQV8elurE0bKFqq21qlBkgayjPtlczApH+xzM2GPnzLJ+3dSDH9u28kN0/qOaH7vKAtfbcKcgknHuOyE4NaqEwNTTkgsiCsd15A2EBh1knD48wGQkI/163OzsJL+u0SiEnod6X0q2RcxbQqrulU2vKo1+TwFVmqQOWsb8DsKdPkXKjv+ize0eoex3iqB8HqCaok28BQa2eyLWp1GxFeqCqmyq6eQtYqbeEL93daw6p1PRVlRZ3dv+YOx+escJ+17MZXOmGTcdYliPmYevh/sgKvAUlJDZGEWrxPZSSSgNKIXlxqjdcMKkQ4TnBQbBkpIB4k1fPWw8aysgNcsnDJ728S1BPmJzVXwUhL1jUpXeeQsIavpfKxgsLrG6d6KWEM/LmJtMnqpYHusDDRTHWsDsE9xyBoFu6N5Lah3o2xavw0BLk/Gs3Q6WNOdf0HUIyXjs4pruVYaY7Vdj5T4qRwk/pxVug3rFMUCszN2s11xaZGQWR0e2U0cd5Bf775lDqJo2nqGYiWbbiDM4ak5kkk3Vvkyt8y0FR6KLZAEYtOY8/bnFOJhYvP2R/187eEmrNb5gFHkmritDmJMNtu+s1YU6NJST8e9+qRJQcoY3p2ppBDQo95xBAM8KU0WtN3kWRej+hRrKSQWX+vnrnsQ2IFgtJYeSo5KHqdGXFSbuTP684bS7ycxIjRR+VBdH46pltNfjpwFx6ABL5bPp2jlBpmxbb6l6A9Phb5iRWXfzVTnOdoKsWj4cDQPJZUwzcDhAA4ufdD3k4KrBPqY6fNfSfHWzFJZ/kypU/iv2la1UofYbIhTC5LLMZTdhkLIuJoPFFnNvpFjA30GTRVtdoFkYcsg6APYRJ44ovDu3NJFYuk7eFTLSSKEZ09B76Jga4l4FbtGFeCieJ8eQpR7S3+EdOGtq1PULBc/KaAz5y/2KR+6d/5S8HfwDxXgDOPcn6i5blWHAV8xuyj2BVUF0c/vp4ynkIZpebMfTL3SXf0BDzfWBouYeKPRMb17j1w/otLdRs9zvP58Pf9JcvSUgdaBkjruKq9oHW+MdgqOSi8dioCPnTDBIaYP7vWoK6eUzYMYxksB4+f38MPEFnZf9h0LKs05CAjEEeZbqESO2984NzBDtqIRqA77rRZ5SNPntlHbNggFqzB8oIaVLfdaQEbN2WENHDaqQzsd9KhaBcg1OpErOIKhZ0G7V5WuEoHlmlh7a6cOnMqgYggxTpYul/60zXobOY4lHP0449C0z74PbVgZB4uAJ0gKpnzuoy6okTmvir5tzOm0Gemy7US6htmlcTIA/oJ9UGGypUFIl7vQBXuReKLqGHiDu2c7OApIF9kVTf+2y82cE3t1FESYCuqqn3e1ZuyeKUjDpOS4bFYClv44xHW21gkPN7eQlrZ8RIyXMypp0Sr6qr3zmI2fpefB6l0x7hfNOYedkNNc5ILWoRJmRvEe8bugzLOf0xJNjreonH1qhntqQ50d1dIZ08FPcmpD8NUGUcdYyitEq8CxlkBHn0EHU+9ow/1pUf2RpqPKWyuY0297Yu+0iV/5WQNBLadk8jNmiYMtuNQ1jQVQYLxf5QZtAhKRp67isnHRnX2Q2xdEvsPrbIYUQ2aNsk9mSbROUzoJAyGDEJaLhF1tdCLw7EA5OB1b3PtTKjLy25sMzHjOGWr237byc0c3bop507aSiACbZi8b68dLUGl18hwTjB05tDJ2uNcKKFo50ZH2keiF6cbKcCJyqF0P5vPWMIyPq6TrAnJESdtnN+/eoAWBt3kB4oUM0CW3XFRiN8UWeU6ZmxauUVFM3Yp3qQrVmxQxygt9sxsLCRpLvgI37dVtn9jHW//bplIB9LeKqFx6cASL8EJgLRTyKoPsT1W5Lht25DGfRjN1bEA2c36tTxfhvF16xg9Dw3SMpCo1ElzbICEpjfCUJeGBQmt+6zJCPLPSH2PShILO1mJewV3aczgyNjw8rQtswjRws9jUgqJliyRodpjpIit0AU6YHSHG0I5nzyNCfY3YQSWh6uIndOXndYuIeBIa+XypVvu0DMWD9zJpiGdSTNv7AYJygj6bZW9vxJfMtdBjlyloWi5T760B+qeFzzGmXatUJVfz4L735xh88cv2CHBpuEclpOK8A2jKJPZPtsHV8OPCFGryY630IUs7yubXPKUTgbZtkxKgOtxcoWC5jhoBs0db0iXuoW6HPP04UtylyvY3UGE5itl3BM7BCG1ET/sAKleXj/Q/toddmIxIIozYrnCBOfJBkx+YcqZENI7FHIYMAGqPLTnbHmMM421cWwLmAreujNCeD20x5VS/UghKTvE2p63vGoPvj+t02GjVQ0d3062xe1FAnBVXmUwzE/O91+xQR7nLNl5VT/e/3+thp1Gx5MOSTgtMW5acgcQvZ96wveio5LKroS42v9ecoJIqPXtT1HGeJHD3tu2m74zbzK3DJIReDdZT0ngDMLXD+226leKahBXsLxNQpG8GyndIsJBTaJvECWRWiFmsthPc7qHWVDUyi9B2h+xsB3OQw2mu4VdLUFwgdApEaBjadeet2SSc3P13hkoJfofgGM1MUBRLU0eR3501qhfZzBWasrQftKeNWjkYdIOcVkje9aSnbmaLfpI2KVn7p639HrPyUmjq4DEfD8GtxuukJMWUhQxkYiJhOlutQ7w2ueRNyJckr+EnU1kjn4L24L8nL6LY1OZO5yrxqW0bNkCHWMGmWH9UOGCRFNGwtf5GH/SPfVdC5e0ccdn/d2XnW6EQxPP6obl32sGbAITMfyU3SbtFcv/Unj59hI79x5iM6VfAbczAJHK96AEv9UWz/Ys++ZqOm0CgwQPdT4WkURV3+ochApL/HqNGw/uResux9cI8zb+1zZelwwmjtNZZF8dIgWCIA3xeR2Z/wHtF2Nt2Xr5chF8cqJi8yKfMuxQ8xgUNxhPklB8XPBWwBFHF0z3TQyHsEsztHEhecM6wBKKl5zDaBvif5XffuhWKo3AVQn60dY2/S6aiep9WdbdjvGuGW+GcYwKqvDpGdG0wTt01JzkPmnSpVydNvT6cEnBsqXv4XuIbnXinNXe31fzsWGLJyAKOoKDhVrmxPtEuaeXUCeze/Loo0hldYMVH89jEyjO9Bza1lqoQ1+IDI9uzc67SBDz6leoCLUMizfolPtSpErYDrEHwuGp0DIqXs98VHXZn10cbnxPjLhaqgrfGs5K33tAIMwwlMZL5006uyeliPWlUtc/+qzpMqfEw3UYFNB9PSxIucjc9gphwlnVJO3BUt/FaNJJrc4sDm5+ST1DAjYEa17skewfzuZsb5IMrus2N6hZeyHeSlrEwufuQun1ylCm7BBRajvUqcEISDyIzAdNE0ogZuhwFkLLgaI20Z729WvOxFbM9OPW2T1GxdmL/GnMR35Q7FkBzypOtOJpXJswq8yCK58JmVNFAU5HZeof/sRbFGz5BRtH3PaCpsu54GrhEvTN0hScUg21ZPUKgjcWX1Qa3PnlngHt4CkqSlLWu3sVlLw0mDY5+EN61kAjhEFOHsYtFY29ZQzEVNOTHRhbQJ4vF+AJdNoOFGPtSG36lYESmqKBJOS8nEb0OCjllpFBkuNoJWfx5b4zjbrBTI02+0g2qa6VXoBmRbLH+111upERW3NRjO1U7KFHfNBZqFLyL09DOR3h17Bh1O8mA4j2mzhc3glOBREuOkaUrnrKSZ+OQK62AcWnT0VfJ6mA/LQcbW69SesRoJvQi70YZAyja6HB5j4Mkf1kSeEXCe1gMIVkoOf1cUGBj6XstC7/QVrBuvS2JUYhPtoiRyimu5EDaa65jjHdmdi62LVL0ok55tqaMf6miEqr0b7C2/o+sdV0JFrdnHeUk3DbShD3J7pXRGiMZ9wZN5nPDmaVRzBSKo9XPb/YxcCEbAvHeB7hVAFw1sKIEdfefNpqZXaTxTuBzSR7hQphPoYr2imRx5rCjIFelTHvckeen/6TyVoxAC+PIt7PxKPOR7x8vBNhWu0fQVMiQjNqwDHSv5ka3Saj+GEcHW2wcRpTsgcDbEJKSy0tz0u74z7mFhuydlh1OOQCoDu4Z/1V5dCnjfxOv/m7+2DjrWZ+dGp1DQoKV/hhHn9bq1Chnngo71od0A7VzyfAfls2/roFhFL7xPAXc2IoWpHvTIpQW2vwZU5jjlHPbc2Yaq2pIVl1rmr/cWaVHEMUdbejXmsXHtJna7BkEvOvtkNhl6MWt+TKs157pi4bl2KB5MXfMYm9EW2PV3IXmJLXxyOIMRorE1/FxPPFun43G8o6fZCyMk3Cvcujo1Mmkb+YJnK390UwxzQJcX9Xg/FVEEEuF3j9froBBMbkD6J/qZUc7bPprh5gcbAs+MGQ+4RVZiuE0KZV+3U/GNDw6goqfZQso3apcC3pzYMerXUmTyqe9mZIIQaVu5McjwjyaD8VnHUtSkLx8LVvEaOMPso1u5EdwFq26A3R7Ehqgbo8tqDwZixH6SpUh7b9MUoH3FN5UhlSEzEAdLrATHfacCC+zVyXEnxlBEfiaxdSycQmjWXkDQztl36dBUKecOUF4/7X7jD2Mv5SVU3ILKzjmpVpdQN16WoqgvwkiRnjQReFTSmMAKQkGC9Yd9Ln/KU0QO8DRGEkhRVNLeZqSxX6RTXDvnERwbsZptMF1pjB2XYh7ICIZxuNYlyn/M7QOANEEVXQhAkWoZprZq+PzeizqnvgXhw9OwDt9pTdAukefb62epx1mRrbiqtZ5XlIZlF5RYd5J+3ZfXGXgGWLlgszNThpHLwAMcSrWUDyh99NrvqfJHN2eNeq4Xa5g1p9aRqVneeqEQxO/2O1HUtIrTdZNNRBpy/Ed0U7yGrvO3NIzaLNy7QFwr6KYQBKELCnAmHIyb5vm+665bD0sKprE7erBVlHiLUpoOtGfmj7bKWLoIIr56VKYciu3idW9m3/Zx8rpsPRHMYb0SLOHNPjjI9Ay9FCZ/fCgS5or3HXc33gjCh7PHsUIGWHbFO25IS/tl3kAqt2OnYgYLW0vqITAHiwp2rFysxbIwqwzOQbu9FPVJGbo5/6C56ij73Wi48uTi7A2qRLRu2i62eYpq8GLg0ohlzfZHRIerAjGEB79WxX2I7jMt/C1o/kgHW7t0qKPR5R1vbEcM1/f0HgixsUA1XwQ5HNI1yvgX4uy8sM69QT/XYad2vnCw2ByhRSVh+7Hh2HHU76/pgDjzyklV5zWqcpcSdzCwfmKUJgsdWsas4QVLGVbmhW7kTnbWbkMGin1+7yUREA/l8OZzNq+3JWRfV+fDf1nqMTLU5wx7/L2rLon24JR0781oTRtaix3RO9rLotIV+ojm/aMn4430sv/XNJ7LRnq25cqsfMgsNEX1kj97ekfMn70ty8IB3CyHyX+TPjsysOifyUrjF4DxtdgUoHn+9ThJGGleldftWisuAZAlKQ7cfeCKqNnLBVfLEkeEzqChZzeH9HHuu1ZIBCPdsAger9cYx4db35HhPs0S9bikYXPnr8LyTxVcUuHAmpILJhebZRy6WU2xpFWO03VfOa5WOvN66FO8ajIyAX8dDhTcj+5jDQP0yIEStCqOyO4irMmCKHV1TW32DwIvPvFW27y63Ki/fqyCQgaNCpjxdr2gRgIlyRbvaX//ypeDq4D4L+/Ue/EdSHRcXgY9lej+Pemb2InaXsQJiyJHICHSvfDzfoh+xA7fwjuBXRR9ShFSYwK/AIh0vRyQQo7hJbgs/Dy1JMYdpOXVX69VUF9aUQ0I4MrU8XTFBl5NX/j3/gSrqbmB/4pPB3bZWEBTAu7DyYOdlpgc8iAh26draIGQWgYhSlLck0UTgdPu04/dWSGE9jgBZ4fBgCftjErZpNOTTS96t8+mK9UWMHY1ZUfE6q8ZuBzKw2U4gWXTwu14Zn3zDGNPWaFnBtiX4uN3GOtaEugn46DpJgrm29F7iEuB+NH6hNQu8YayViknsuubZ5wdVKRpQXGCM1Wmg60ouay3Y/eGixygzqFNiiKlLLz/BckoWovGDTX9tbLvUKhZWJPpfd0kXd5G2EYGbEthn60xf1WksAo2CQMTBLmf7Zv403k6IQp+qaU+KPr0QmXJnurAZNwW1Mm5qsFp96wVrfobRVqC3J+lRoayBhQ8hhfpfGmDF1eu10iuiJNkMnvG3+7XAozf6ROlAFt8yU42ndF136JMPDEZ9rk2UJde7ekfaJAYtRv13oxOjCX65s519e9BXkAI0R7A/9n7RJ6B2ACeaiARVhsEIjHEFJR2ZvDWpEKoEJMAda5xxSMEWfdi4Ebx2W4t5WUm9lM4q80XyP+G+bTziylrQliv4ayoszoRsFBuqikBfglrgWNW4xr61qiSJUoNnkOiYbeI3NN1ZZ+hyKecykapdQGBsGsjKHMiBpobpj0IRO34JvUbkBVAyMweUfGgKoJO/jUto6K4UD2ZgEsKHrWtjIeHcDUGd9qn9XWYsxBtNhijwNT1JH8so1Oms1hfD/gDT50QEU5ACMylbIHOyTNgeOcecXyIj6c1Qbj5KTr3yiAWnmdCPFIuxwmb1mOdXFIjQ91znWgxQ1ZSCo+5m43CcgStt87gkKxriNpq2hyB7YQ6rkFWvb0ZHPJjb2VhTvnWrWF28oM2HXAaHQXW3xbhEH3iIxalvoeKGPwUKPhbg3Q83rxm8QRKfYKPJgYrrlGTWr2oIaDKwr9O1rKbtF3GutjuxyvQUNJqzrLeAVVGw4xtD86eSz39K39IO/RSoaG7SQ6+RsI4BHb0KD2r59Z+7eMcIq6jOEEsKDPovzJkmFpD/jfOX/UMAI24jSXJscslBezjP0bmeDiDRcjbcukJcq2mTo1xugN6furdpb5PVpMohGol0JZQUnzllhH1epB8GWQ6/SmRp+QRKGBxLzHlJe6HO0Sg9EI367esKfHMyudqXj3O8D/gP6qvet0l2pf6Dwu1WA6tGxNEW08HaDZruJmhpDmYK+8dD4HsceGi5QENPkahb8/CHXBcuJtKE0xCkhpfI0g4tgL5GSrmO3xRFWyhGmMfPvxHTlwejwcRKIpupnnNFjbTLARygpxJroROWZCFU+GF0vDXah/9+r1pETUxXMSTIeEp3wza7pYEdVELyelU0AE37O7Y0LBU7Gukm4QdJvqvvM4cQJ+U/pGKDRm4X6OvOfmup5ip8mO6HOFW6kSmRXitgV3+e4sA4A4L1f8fmeIaAp2FXvgIwf6Geojeub/ppr8buBW8mQGDPlMn4ub71GoODlGhArTBEwgkVMyXAbEUcu8J0DTSsvLIsqhPa3oopF7cWznwcoLVb6zkE8Vdq91AKHxssKi9ZQFj8TPp3WamtfdA+lALLE9MB46WE4hnLEjjPtA+wYrn6alL0cl7shvhGg1rJTgM7/x/NEkfrLIIbe1Se4cm7WF2BgKC5sWyKC9M+93NZYmSn5k27N1tsPyXo46qA3RZZq7ytOyp0L7ebcbyTiTM10xD+ybY7vttFQ5lda1XgjXXObXqy9CW4wdV8P6U8nbWuoAilObyf4nsRPqhJmytOEfvegfSVg2W7B/6zSDlVLK2Yf8jmS9dLywoTXIJy/uElVlEcn+xY9kaT6rebal7PVFLSyz1FW7fotf3J8EZo0kjLkO9vsTcIChJkgG3SGEsPlP3GNNkz++OxFiDRc9opTHz8r9S8NIBrC5K6OQ9djRbRc8fBn/S5mjGQEJ5QxwITO3HGsNp8YmFVktoVLVtpXTMF66b+a8t2xC/d2v0fjwTfBE605VrTxbnZBlj4P4B1WvV9iGWeixWe17hp1kuI4s3QqONPHZnnbap36jWiK4Vme8Ub/ArmbX5IusQzvMpmfbTb5CvSxmify0K7gNl3SsfboQeIWUKKKL9EmWJ5MwOd3yH/vcqs89c6WLaURqWQEUrobP5x3T9/4tPmeeLDNQx5kTXggL73SmgRu7UCZHRfLjSjtIf4TusqrpVpu5CVwS4rDKN9q58mcjcYFnB6QtF6p6HOd/WQ8RpWP6yb2QcGQQXJxiS232JaFrh2xp/HOitpzCTGbnZ82VxFpkAUcwmjR+aTTvutQ6zYc2MECP7tYeQL3/Y891RX38EJQvFmjot1u1KZCQtmRnPov05gf/FB80j0j9lA9DtmkwJfpdnT8S74+NAKvJ+USX/1oV9cwag5uq0HnI2iWG+7KYgwVivm3Vz1B9xvoUJvyA6lAKZgPib3x6TYPQnLTsVKoIsg67HgFglubnQl/Eo/ZTBb1EyeIXLH+uELUQ52uuwY39fhEUykm6CBqIZQ0e9ZBTDlrM3HwH+OUAiRPN+j9frjAuhr16yYEubmFQwUNAm57feUeZK+LYgtRfB85rbvWgVM8NJFRC8h3u7nk98wss5Sh4TguaJZ/BL8mh441VOhvFU4zwrsJiytRsrGgqkyOgGL8U7W61vx7ZkPcMrKPzcmKqJKRpdT5I9u96JkHY3gwaRgOAnbBI0dD6R+jJbIaF77QoGCIqTFlYXSCXMCbH4QpWB8G24tnfcI1bY+vedM94ntQUaGOf6sX4NBEG6ywCbe50RT+sy+w5hXwn44+B2UmtU77kFgDnp8L3fds0vuGpb6UfhQ3+prQYL3JLYGpPUyLnnsICIq83+kT7h5oVrlO3WI/q/wJrWokJ+KBXJJN8bz2pk/e3u8NyskWkN7oKJW5J9p3ZdMv7vrkvWvsCGfZrWU6rYqSObvg8Ka3Zjop18Sck7/ZEitWM8f09aSTwKPmba5MXr9t1JVmqzvqLjn5Kq1foRBYlfT6repLi4l0uVD0LGSNVOVWLUnUoNYBTvWXBlSLC+Csz3+6/HSHfjnTThldeDgLhPyvXlozyKfsUxipXZFoIpWEriKFSCHRs41AxcEtlfIn4IMFfFM1bMQHapQk2crMPn3jUi/vLAjYq5GZA0asyObFlHrSoNVu3uSNdV67xsmwhcSWmQP7VIDTFHuxbiRoxWrd2AP69JzebxSOfCNRDW+3t4KAk0RCKFLvstcG8QnJ14XrqKFtZE7G73hy5YxhLV5OxU8/+q/fn5/z8+r1hA85fbwfiyb2fBqbRfmWBLqX1tBnxiAm0/fUOxkZMoyqhyFfcX039HeQNnYoMYyADWxVft6AZKs1a8IQ8osPSZRhO4N6367xErhbevDsDIMmBEUVj3YIj3RnnUzxlOZzZpR9kGgVmClIRq2Zf8x2xW15ApcflPssACXpFULvZew4AzFQK2xaH9CN7ExyMEJdbKHgzC41qlLcpZeBuT3+HbC/B1Waowy6uLRqsgQM05ESlyblE6g8zx51I+m1R42/KLDJim9lVzgN3gTBjAyJS0z6yu1gd6XAyMCrR7JW7hxwbBXjNk3MDrEzn07a1QDOQ+emTbO6IUuy+8VRrkOJxgr+9gQgsDIte4XQRmkRLKDzRR5d0Ck6mUnGGpC98JdAgYIXwozIXFT05Qz2yT1YaWrzWCR3yJ56nWBNFLdGyRk16lN3bU5/ZEpnuvTt654xUcGxalvsyGmjqsuN/b6hYASEZuYIXPNKTUB6xtUZjj5n8dm2oJOXQuBo4gzmGmYygIzJUWIzToK+di6l+BDyoOVqyXyyvQfsaGbU1gjxRhjWOXJKcmeIlF8bXSUAfjqouqXd0yGYQ3ijmp+IfIBb4H+MnNo5N9ygiFFYn+Wgi5oatwIIkPPRVnLaf8U6OYMpkJbb9+LDLs3ydSwEfe0n+1WDKJp3KMholvCFJbdoz+ccwTFuMV75WkXlbQj24+tnLB9IrTJfGdPiTPO9jiTERQRwam/KT42gy2isPh/sy6xDBxxGU81cuTUbFz7FDDAadzasPzULxkLD7a+1XZ1tKKTkUVbEWByVTmDnahkjrRhYcj7NbftxnKY9KqAP3PhY11ZCeCg+qqwHGpWe/mc3FoMkpIAmduUYfKoApYSTVFT4VqhGyqoPZP79etA+/qQuWBayP29tP/cfr8tsztAQ058WCmqDIjadAVuoWrIuiOGlw8nsUxzknkIn8TLfSsScY8gSeH/eOKDGqeH8SZEeI9hoTVKDoZ0tFgjfHtT689ukGC8Z0xbVszPGsxvl1qsk9d0MhOQee5uhd47achPiNn5lrMvwfJnG4unE4Kuk7IYOdgEYd54AsZHZG64SvxbpJZv35ikqnpM1DL5sP/VsvWGNglggDVdjQUz9ek3eu0Pp4Hh06j1Jp3ghtjgLJ12k/jSnjfLPYcm53EfTSvXboV1anBWq9uzIYOwu+rh0pTutSY1DKUSrkUCqa4gcGxL6IfBQgqctapUkd0SNEqNf1vRocgkQDEncl3s+1D4jLYs8BWKuvjXSPFBN9E96bHNyBAvNocG8dQK6/1EhWFfLtBoHlCEamkarqk0Af7aVLqLjPv2+EYQq3g4HgXZJIrnX/oOuJ3/T6wGOVXNpGe6+EjlQCZIaDoLS7IoIUaW82jhu8QVug3IxdbLhtfFanDH2ohHY5twd7IQPwZkxWLiPk72nByNYJRtlzA2x2E0+6TFlBlpMdAhauUB+ylp+ijfeIj4/eft0fG2adGfqLYfVAQ5+VIvqWyMwBc3dCjO1Kzg08pYMWnNC4JYOfhxGvOBdE4wSp+GUMLjLvNufWgBPcu322Ty5LbuXLDv/iabx+gbSc9l5dmoOETM6t0kGZU2NVZBYUi1gt2/iheASVDBoB4H4P4qA12bZI33pz0jsgU2io2s5wIkVhL7pjZf4i8fp988zoYFG1RynbefU7UxNzBkiP2OpsGq4oRTDlUXOo0XjgPu9G5Fl5X+zTvpvQDGRg+s8Jbu41qZy6mzqrt/dwtEmoYJCeJeH3x5/EyckwC8tPNDYas8+FtShgDWAxis+xzl56uCRroPUTqXq35uOdr4RXDXNHHRX3rIMbKsuaLwcOJjnqxu+vHp+1iCuzM8eNvvZPzF9lRgfxqfyAXA62Jl746erWgvC8dbsA63J+reE3bfwBBn2dkoWaWYF4nM13YjbxfUM9/rLlysKeqIC0NSw/IkJ4F+Yv8RJ8NGCwyod8+UzlMn7YS4c4ddQCWKU6/2/3WAE4DxaLQQ/9VXll6y8cJcaGSbcDHdOY2B3rPc8ljseqsJjSQHN8vE7nPw2F7Mo7gAYbXKP3iBUhJyA29U7vQ+nSS/i1nRyLY0haF50n4fDZ/008QjHGnijHv1GchevLyV5y0WjzB/9tixPeCkusSK4WTIghridB1OYHaVJ4STCWyXETcn5uNJ5Df/jqtb7x9wPVR2V6fdZo1keNpKHZ6p80KlfQu+Yv0hKPF6UYxol3YtOCI1PljMKBPz5goyXcdzk0g1Z0mq93FKTkxyWzmSCvpca+2mYLvp34UtMGe2gsfXp5BnYfvQk8f86TJoB4Itb2d24nVJgs03CMY/PqlfNw/pkpTWb6TdMAM1ppDlLkNLUfKz2BwnTCAYcTciJFxm5pTxS7Jd9QJdLBGwuKU9TnE7z3+quCJH0BaT4tnuF3dUtzT02Tb0X7ID/dMw2QaD9QY9tS2d+R6Jdn5ELxVnkHZvhZKD7rVvFZdrNqXdJ6KjLj2lRJpKHdDtRpwMVxQhN1GtnJiOJa1TJmYjeMvlsjGQS6Oy7nRVTGIIKnhJSZYw/wWo1BOD+CkxIKkY0APRqCx5Kuxmi6NQenSVkRP3ILvbHaFBtnjYfqLN4p/RP3Z21tfHlG6L1jdz+Muomq+HAJA6xlWGFGB6lg4eeWDf0xyBhXfujaJTBVGlAFagikcplN8zPGSD6AkKf+B6dB5tEtDg3+1mYKXEP9Y6V5SD3AvG6KQTUDgU1s4cgztmofj65FZ6ZHunmtHemTDNl14Q39TBnB02+QuGS1Dg8zwg7i3w1PQtmXYXPy5ulazApJkICLCxIeqBfgM/PSPhbctt4NtUS4NL/NhoxgN9p12rmQVHjY3fDU+HHtIM5Cp/99F3iO/73UPIU//Uj2saTSSPE7kQK4m9mcZcmpaNONQF6CheiceYHgrpCdgv8b8D8tSHeCuYZAfWUipAwJF6AunpCo5vKs0OaY/RIOJI6RzdCkWZXvkZYgJ4JAY0fFmGfa8ZjpHcGqPgQCjf8se/66ssijdjlHOdV32X7LFqBC02pjsZNL75R8Cw74z00mBGfdhcG5ZRrxkiduZ6Vtw1ammUxWCH8Lur0VIpgaV34c6dWYDjD+rexeZ/IZe+ARBDRIeveXUK0af+Are/UiOFvBfsaNdKLUd4COV7dDTzEMxGzImzDYkZp/lQRluZuoX8utWzcqfBWx7/3+etC3V9Sa4IeP8ETcO1TMQtWgu+RurM9Zeon/QGbI33brXTFLhGN5TEOPDgYCHsPOr8ao1ksX5eefoLUDYtrVOKaauVG/4wJ9vwrDQVC+E6pe41E3AyO0fNs4FheELaKo7zhv74YOv4d3MOoUw1iDtgwp3suI3zHbOO2eROmfW5FdQAlNPWpTvOoU+1okiU0ev1UuqKska29Lf5USHVkO8kMCN1nFIeDEj71KmiBLEUmAkriaU7EtvUmiVXbzBxL/xyYSBXud5JobAPWHR1RL+5MvzPizMbic2HoMheWPr99GfNKQCbSwN3iCqxPeAQuba0/YNXtErcB2rfstpiGCCoQus/KROumW2u0tw/wFE0MpeaPKXxNVIOeljw4kC0BNp9G745WWQKhkA4it4GvJhjrOPq28FT79jkd+69kVaThGEynLVDLIfWA3y0b3J7t0I/2AT3BrU31WQoHwR+YbeWHf3dYDiIIPprKRwj1vDfjjwR3USivJdEGw7H2ifod7OKtBO3AfcU/tVByM7EkXyFH9qJwd/QyEsU4QxVQt+JkOaTyh/ni2Fm9pnKaVzUBDlMFabL3cVfu6dlu1xRZ7D5mgZHFBZoLGs0BF866b5mfugxdXTEJ8a2TVIuy1JSx1F+99ogXuaF8H9c5InX8IjunCJdKOKEnio9SYt9btfCRS4CRxntAyh8NR76dSqAbVDhRuRj/kcG19XBmAoqsSeKKeHys02VYOh5nGpTFe/J9RZiGtUaCejb9FcDxk9pku8dyM/rYNXdiah0PBL8TOzUzyBZ2Cf54UHKevyF1Qcmi8+tYl8rLu270FrCs4doKPokivLbsCv0MwWkFGHonBgVQWSCm47LH3Cp2yBhlYcz5BED9q+sXc6HWEjaxNCefkjvAlC0MqnXT23HWSkxSOSgDng2cNELIY0HwWBdj7Cu2KsCHIsaa1et0dxQKkIo8Zr3alYujUyxeIiLtydfeSI513MvEpEWdRKTvnJoGHXf+UxXlo0v4B/qwe+HKE3KTT27ALoXQ6kloo/VddHUzRfGSO4zbpRMdzPvVYZzTXaxLLlk2XdqxJ93Wcu7pT1O4CfMWyYWE3JrwjAyVfJyjkkReItmvgi1kHDDPHoT2Oxsg9OqwYzZQG+Sbw3fl4djLG3CRcl2wsdIIUpy087n+BPLB4V9tlXMOrPw6WMSnFilsQhY5cFy8lYyd4YJVxYhZOuvjs/lGJ4V/vECGcr6uFWyRkUP8yVTc+9GybdVeHpLd+UA23eIAsfwJAEv0HVUJx/tn5l/iRHNHgYk2wAMpuOYMzTxqwXQdjVcEozrcPDa7jIt87WXlUv72LjSxKqHws+UF6O6Ah320P35QwDbRL00OUoYcSM4xPL6nwQIZ4edxFha/PZMXeurJiCuoRmxhxc49GGGASdfpymQVwPg7mpFxQpsZdeV7+e0/Yw3EsV1DuWSjFudHFs/Tl+LbyefpGjxO5kaR1AXGyYqI2Efqoag+2uQgGRz3+YWPZ2wF9ZVh/v+rrRFspL90Gfb8Z7qBYqJvV81hM0FrjTYiKJ0TJHcXZfPel/HHGGFjPkPVygX4I/vD/NkPohQRoV9uGy1kUZ5O2Y+ojpf61+3gjhemGwnVhIMDpZmsdAjnJHbi5BXaQ9NpriaXq4jTBUeIx9kGkCWVI6cTy+OP40ebcX1Zh5Wpo162i5JuJIRQ8dHmKNASTpXT4f8zM7rMJs2y29x5G9eiVpwf9h8blfL4A2JCiTvWL+Cvzs5pFBICurD2K8SZpBQr1+b42wvN70+E40wPsksWoQ7Jn9ZAsCSrCb+TGS61UTAtaUyGDJDvoyo+XqfAgM/DJcKBIbpzghfh3CgHmFMeESjrbO/yerASVayHUt+r7on3kXG+/gfq8l2GZSRbx3GggegIitw0aCBXaFn65slSrijVhIdh2JL1p97QsXONQ6gtRaMdmHj3ggoynPSnsV3I1UYjb2zlHpO7DJkfNKDeL5Ih1fbZEaDh6YfmdkwQ1O7ekTV1uSCzZjo4P/lj5WTohUvQionWJ43pMCTJI2PBsd+I06mz55SiLFRCLmJi7UscCLcwZ7o2rOrdnRreuwKLhOHicdCemerQLVufwZF5nSVp061OtG4FaoJ0FYUTS+9l5bhD9xI2RKeaFYX7C5M8vLWLsuNBYsYtN8icbMhpvyryByy1QAgWrDSgXDZ9WdabihLGs9chhHnlzkrSG1Tfkgc7kn+pDiAoyBEhmeGoM64Hyq6+YcKgeJRiss2sGhTbkJfJ0AOk0AFij8Wmvxu+MO4bZiJZU5GTnKZkJ9kJAdgjSO2s+Cxg+0rcccJH/9JTKxzoqLJakBHwOIdnB08xSm4nAp9o6xHQqaCy1ZdFlgOmKvQwBDPqb4d9BdhiTHuW8qo+kW3akrmY5SyyYAmNaaESnCsr4jrcGofxwQc7GiQ6qDEQ79T5zBKE/CXNNyN5E5O7pSOAfN4bfIUpj8l7+f8wwWEsbSII7Wz07h2Cl8uvN17FtjYPRmg500FHGwX5EoWg7Ref1ww4AsCi08oaDuaYoC/t3CAFhHSLkQsqHuAINzsqn/dEUGoOJXoo6oq2JiTnDFcT0vIWVWT1GAzSDJ6vSamWpgygCWTFIwa9SvtNHTXMTb9FqIMUewGRe57NYlLCJAkjYIiFXP3/dKp/azTRmoMkVbpEcIYb16MOBHlPgqLgnbr8Ap/Jjtan9+jujc6gvQ4+N4xfF2J+QZVgmJDJiKB+FLhWTJKndjofoqN2MoDy1YhLL0i0Gwb8zHsHSX/RtkHvRTXxgRVGGKWliD+zyxj2zAXbU/HSpg1CPyb6Hb7oL8BkhRy/w8bAKPmBEwMJ8STW3v4jG/2CVmbqk3UJfu4AB681OE+kBt3rzRm/mpWofQVw6n+WKT/6digMzx9CfWYxN+gWdgz+hmBcYERRwzxb9+tXrzgdQT/Byau6AfHlmPvkJUuhbAE384/7yp7xuaXtWulqFMmCpbq1lFmcbEk50B4S8u7D06jG3OXVWzPYOf9SvWFO/v5GnbDIb9r5nYRvE3UnqaDKC4SXPt1nE7ThIT+qDHrF5MZ2iZGLHe7SfT1ImUCIsYETquKKv5dRYa9MJDjVlAMXC4jl0rxQ1h1D6qd1wLFq0i8BOEr7WfFQR5ktfgivfAc9sNvoNg+gzTn6N9wL9HMqXVeevRih4siUxn9ENK1bZvWztL+N/5ooCkJWjKnepXp5EpNKjVQJG60KOsUVEeL356nAhrjCpaJEeLEfXPPVGLhDlsSISLzK9C2TI6EPR6rjAmgMKBPFnJ3qOoHQT9zNJEZRudfYWK6yR3BieQSiLVlHT1NYVSxBiHl72nEP7pN41TqOiBjmxiXMWQppYrbN4XbQklh2dSInD8YGnGSQljrTN1BMkV/sWaNw7afIySqUPkD/FP3bQ99ArHczPbG82e5+bEQney/3WXHiCJEtA50tIHIchRlAgZ3qg73wkfNyS8o8Hn+6EbPAsHv5yntFuzRQb+5rx5Cjpezm9vPhTni6Eeb5ZNgv/k4HYYxGuGyeY1O/xMdq9XWIU0LIV1aontdVV7ShN9iGp0CjwgvWPaqRl/h1f4zUJkJ1r00CrCA3CzasTxPzDy5dLbk9EfpqNZoQVRbZ3OdA+kyL2elIWpC29LRz6r8lcT/sCA8ZVgZ8v2ICgNO8CVlUt0wdLGCD+nzCgk9S1U07oy+2VZJ5rCbG3kgBRtIiIkBaO8VfyzMy/lEOdznCvRU+r+VvIV8AdeIbe62zL9m+AF4BvT5Lmf2tAX93mZd/pYxobuouJ+JRjFY5lnA4iWlKdPENkDphDms9YixCgmCn5ivdptyX0l/Gi72uCuXPuYK3Fpl0KpfNWpm/feVsLHdWUMsxvYj9rRTQdQanQxzW44cCTXBQDKoQMUqkaBC823O4KtGRGyRVA0rliPrUGYTPhXRHINxV7K85i3cpPvX81Cx44CkqsdoV/XcmyhqecjG29iDjyD1Ome1LqL9BIeiyVA+xn3ISYphGC9jNokcVu+q5iItOVKz35CISgsGgaOvFPEU0cXGHF4h964aCZlpOJ1UmF/Lop8fT1GTq9Xq+VzE/ozm4l/83OdeZP9GyKx399hyI4bITmME1qw8+v+jRsdbrkx0AsRW9ZLU+Si896ObrbEU8JKaj+Z49a8try5sHEKPUHHE9jI2LzUS/A0GPV6396WRdlU/e4wRsUabvPoeDoLvGaUdwvCNpahRsCwImxKts+HpnZ7jmrtrc2ZRO2gPykBGmOqdaV4/FfX8l0e6SdoKA7as3GNC3z/aFw7pZy6SS2cGWIhCq11B/cD+GUatAhUO7t9jRrCCBV2uXN+xaMk8GVCkh29aW8NLP5hD9AxQyH60ans5/E7TIKQfBZodgi3f30t9haozR8vjxgirxqehEh3Y/ApvbXRBoAUb7xEjjfOfk4CAV9WiMQKJu1bkHXiTg68tRlrEL5bpEX+eBQ4WAOss877lakAv60Opqd4ilTJ7FrpWkSCvNLLRlbqzrnwK2fiN/aGNvs+hk9z/5/9Hk11k8uyU7sqwkmN1PMELM8NDa4DBcO2tZhq1qmgZ0kIGgw4n5Zdwl12uAaVTDIvOrH1//HkfQkddWUp/SvlidzlQaOEPKiEMdxgtWw507EY5P090wJd+T4hTczpCS7k0r+i96L6Aq/bS8aSBUg24DGq1Q0KyrBLxjvOO8zsUYz/dQulOIKYvUaCZ/Ow4ouO/ArwiZXuvFZRL+xwJv/4RQpnlXwm31VbjlktQARRSp6Lx4N2mTqa5pQvFTQZ7yoQsddP8/hxJ/4g275vyM7bTNz1OxvxJoVkDWs9GDV2z3J3qXObqBN0Am4/ddgEa9iIstJ7cUgj2IqE+zXFy2NgDNSuqfjaLhxrq1X3v57MwG4BncX1YNAz80JZuHoXAAX0hkr/WbJk/7T2DyHxH4gyouF1Os9Vk9M8zllpALB7sxbPgZQ7gARoSE7rj29ZOqxYKsP4x4/mDVQzDBys+5DpHkTApCN04qhWBWG3JwMlcpkh8zhJfahsmPcl7h6TFGknvw0PfLJhqIoLS25pf0IFmm+r0uSJnZJD4mDGOExRjuvHoR+9tzTDg0L/oSc/PIVH2IKr58MPLiVnp/8BVV4bFQonX4/VtbhbkzOb9EGGsNQlGWfwmb0EXj8QZpn0mcFglFQfc7s28F/AXUy5lDta5R8j9RFbyDs9tLByLuNq28w3JWJzRJbFBMgDDtNh9agOaz2+22wVIWBXIVgiMcjwvvx3kubJNGSXhl/3vW6uwwjCaqRGFkZGQ0WhpqS7YsutA5bDGnluQyowouhF1Dk1qxymwQse7dTqiWQJ9VKt9Bwvnvv4X8CLzndH4Uq0ylg/60RH2AKQiMeUlCsCw5HyjFmjkQpwq3HIr13m5Y+PsnoUy7PQTiLGijGUpHva4Nz87VU6jUY1pcaG1d7yD9UToFZZkJl7NjuHwUVuDSavr0/v3rCix/cPGuA2xvzfj9y7KftzYefA/RtpXWTcWJ+IJ0GIYW/qbs7Z1sc87tSxmtjPw/86gB7b+lHoEcozcNdQJFX43gVXmc5eLNFRxeLd32O91tC63pPCKwH7sIj8oRrzU39Vc8KvF1oHMkini08zlhYtvtIM4TyCg2rGUqk0bHpyEK3+OfP+o0eq6lgnU/D3DQId5B3XJqUkLCMVUzx0M69tbx/L1b+Cx4H3YahudCiHw+GIJvCVp13caMcHq+3qpMKQl5FiwZpj7+J6EQ98256Z/V/rJMH9ZeORwrkxStkl14Eo8WMMYHTmfaGjIQY/zJWGF/atYmi2j+VcqQBfiErgnaFxHZmJk5B+XfuPkxS/bSKSVxywvix3BS0KFu75pv48HA2l5mQAKiZbFT4H9OEsmoT1XSp/O3oI9alCe3KI3Th478mA02Es6rt4p38YGZkQIrWTENTh/gNoMB7mR4UOckUt9cGxyqzwBdQSovwUHzFzQ38Lr5YZ2XAME5M3xA/8HlDcMiJoYKREKgIxz9FDeA78ICYIZYxHaoPwH1bFmYoIvLPWXdt8iR4T9vcgDOOMIHrNQIx9X5xluAG1cEfYgDT23vLGSIMmD3kqkZxeZRwNrocO7OHSeFXE88uj7cYhiMKq9Cx3ywFCf9jjxb622Y4ZgTFhgEU/NG7HuQKYSfArZVMfWvWqJ0wmV5v0U/LfEIQCn8h35sFuTYRy9wWY+p3eBc88S514xQE3ZInZOGKsCFrcumeJ+VROS3HfKN1OCYJUVbTb/ozAX12atqcjZxtilIDkgkehP58AP6b2W7oqh6hJLLkzrFEpZmKelfxHCqBWuwWAPHYGpgce9H4s13i2HxQw2+/v2OvMStRWdxbykAW5aIDKyVoX6TyK/vJHjn4pSVBqYUlKBXUwdzJXtHXiezYL4JmwTaMtIJ2VVTXmresv5L612IwffcYOg9YO5scMr96hyqqllfi5+xxq9mwDVXFrl/ePuFopyUEexY09iG363lsqVYKKTPRpCn3a+4A44JS5/7+QtWUoxTsSb1yS1qO01Zi49YNjmBKVj8q/jz+Jq7d498FNCU1OnnYmLv5O0XeTTYLMpqcY4Yv9CTA02jzS633ZKr+eCkmVaGIxiN5akRAWmUkjAx8NKGd8Ej/9cjMBxzKscuuXzA1dOzrFiEe8cgwG83CBZ0fNE2eDq6/Xp2mCG+AZcpcKv39VTCVFkILPm/4eEJPLkg77oIYEZu7QZW9B3fQvkylr3LTaLUBsYOZ1DXi/gCEbs6YIrK4YRqrZxmDOjBiu+n1yoeL47moi4S7q4Aui++bl/WaCDzg4RHbrABQH4COM/hULmsW7XBCZvB4AnDuOBaHovSSwF74W8OfS/F8wvq7MAsn/sefv6ZLdwV2dedwVMkEc1GW3X9h8Cp4MNHSTFyRTHZpAQsO+NCKPe7vi7d41MS0IgDLTQHiUzkPbSjqzl+W5KVUYExA3I6BjNufw+mVQ1VYAWNfj9/AgqHXzgRtZzQZdsojQUgyFjHlQThrUDb+sLr/Loan14IAS0vOJfJbrU+22j82ll6JoBa/h39f+6K9DoI0ruyvWfjr+z0s8yso3rOGTOrxnffms52GLGO6MT8q9LT0SR3xZdvjQKW9R9xP0Fepo0t3G3FpjBTfmfFja50dNacwXmPXFGU3WBly3asDIC++IjRpjnsOMHtY9JsVEQ5VjG9XChdKjXw3bdaN+ZkIQbduOzDRds2TxRqEGz0HLoRLYVAkAAiDiza4Cb8iA3nLNeIwfZA59VZetMRAs0GtYL4y27tpatBBE3Wi81qm4BK3+X9M0m+AsC4MZ0C0OX5giTmTWWS8jRn+KejseB3D9m3VzJQKJYhefuD6kyMjizyCi25offdEJ6dS/+8kvCKA/sm98/I3nEd54Mn03Uxb5VhxU2dvSzhIOaIhMrqsnGwIPv84Q9ylQ6xbJNN/SysahxRwadWGYQu83KOyegTDiDfX8w6Z0ub5JGMmjY9xwXHZXNXe04INld09e41+t3de2fnRVHZg1JRFRzZGFORcc9WBxzbsfefosw/4YhlOUa81gueH3NDnul2/IVFAkyJGoKZdKK62aF6tG+rHDX6GpK0oBs1xPBBIkNXxRG5xutgTduD3eLhlgAyhwlTme1ei2bPJpeBxVgR6UwBtR6wLU91XXvzibBdAYysAgaFHyMjZnZzBRRFp3Mt84nqe/S6XaBha5yyuOeDBvVhiqmRXgzmN1ZqAyLgS33cJ5mVM10qVBF5n+y7+6XNx3kHhmV7miZWqyGHhrGFTAR8+09HdEs+0rFtIoxM4ZY9eHWwU0hd6ToD1C4CzSDCozIDEUEYg18XINygbk+e9ubKEjwJBW7GCrHAjpQuE0XBJru8hy4VDEdI8rYp5R51etRdzdskcn0DVG9Pj4VB6Of5aeqmRGtS5sFXXymnUYs2uBfxLbqhu5dkfoIRxpABR/xfw9mG3q1J9YuQrVV8bdtA9HaQDQzYPuSI53be7irAnhelgMhDZLn0Ysy2a1oV3r1zQL+G0Eohe9EVfJTfvRRmMBw1tOx6M1H2ivqe4qGDGDcdVvBvAevTwrpFCqAvp8ZXwOxKzSXy7/JMTQ6XQUpOJZZsIIac4qMzVfvhDvxi5aW7I6R7WAgkL5PFrQlt/KqeftcJqizgQQH6a9F+I95OBGk8aQ1po/DTo+2hGFArIIzHqK3FqRtsyvrEO7FAu22DTWt3vc5w2zcp2RGr+Xun0VUbnBZpwnTKrHj9enP8Rg/ds/rVBK4uciij+AlAH+zDF0pMGx8dphMn2RKO/S1NlM/1Y0H3ZS54viWfC1S7RiBTcAK+dI4lWP5CizuYiuiW3O5AgLPjI9FpjTqD54c7+t30SeE0CmFWEEWDesRw/euGNe7N7Tl8hD+11jE+bfBSdTRmdkpUDBthi/zU+XcTwemWDN7T1R5esogIIgpDA2VkU8dIRFTHhDfSYC0MKdhmuBhYt6p6/81lGTZ8XQgCB3XPs4+npX6x5MKY9F4dh54ijv8y5L/6Lcr6rCHxBsxWDuY9YhX3DJqrQFlVT7vmiU9L3B/tPiaCQ0hS4Neqr72Bqmg3z1XhuJzdg7AbawMCUSOxNqBSEnKBy9sMr9WdTZF0874r999NdDKnj4m8UJM9101lyw7vgrSmX90AdQmfF7wP2tMQSVkZ1/eov8GfiUVIkbX2GAfILtUqiT4OWWstYTj9miBgZW+YqUa7nNEMO4VdwiaLYiMtNtZGdgQTRWD95xnRXJDF5q5SQq+HIyukuKg+xIO8Qg5JPrS/EdTmFemlReg/lXqczEivIXuxzYdtE6aID0CSgcnBcQp6p3Spj3lNL1ljkz2aLErLqsETWswwvfcyAkqA0ubNZnJWYaqdHRbi+5s62fulAtSxf5zF7qeP1odYf2zcC54F9pBepeSfiXwII9MPTCy/qAnClwWP95n2aEqLmkisogsmqs0sDn+Ws4+KrVxctAeTqmqf+lKurWC+ry1gcPVfmUWpw+hXem9HnHnyvcIcEpjjvN8QdRTr5N0B2Pm+rFi60xvyq3VOMyW6ckg8wLzVFKHz9wOdkF6iWTlXy1+6LD8UGifemcVoQMn54NznQK9w9v22MRDJekvkFI4nsts91byF6G1aS4zxbI8yiMUztBaHHQT61aE4kFjF9x8xLppaeES/HdC0Vmsel9taB0GH/SuS67u1RSM+YJi3UlNflkC98c/Q/QWBbauHKr2b0LQZtKmXsIU5z4ESA3vf/7r4ZdkKlDBGamH3KoCELqt7Q48Ufmycq8F8VBUlHRs+9+RwbD83JxIzT+dLblvzyJlM2VAcYHQIWMK7plvFyxDgErUkKbRCT4MDOoNfQbDS5Z9PzUzvZ3hopwf2VFaQkU4nmc2ZPQPdQFA29OQuFBc/N/hsuNoBn2Y1yKO/RBOkQMXYldXfjNVy1PIWQfu8UI/lj94D6FOxjQgkAN2bMK4VGP4x3Q620UyLCRAFTfF9VeerEZ8149rduNVpqJSe17ft/zmWksBUR/dFfaXRD8/WDDb2t5647nuNbqkFn4cJ94LwZPYbHGr0bDTU8vfCqucq/2gHr5KHwH9kDri0NkDuW0JAXoCalUagoG9vVV2cDIReFA/gu+ph6ufVI//A/BEVxvk0nP9jLqoGLyVaAxZaPVBDlVgn5r8G0p4EYQacBKFbMZ4D94tcI1wSAFExYmmVZ6avgyekEdPBMNDVAJfklib8YxUzrXZiAZ2U+fUd6eWBPpZPAqqSwmL2fMA2cT7C06LD6im8cbaEWSsOE4Q2kpXC3hKPDaxu8cP3O6v3iLuHo8t4XPkEJ5UHDyk4VJdPkTWEmZztW+itmkI25DEXLF/2eGW2LSSB70gGK/ySGx5T1mDrywdWZZ1a1vLmi9N3b4dzaJi3c41EzOjWk/6WEssIbNFUyS++0R10ixPFmDYCb4Jq130JtCSGa4yEnGvfnxS5SEKIxkTho6lsv/yehtW0VVEg5gNS5TPGL0QIeOPiHKk46wIwnfJlMvRQTOTqPye3L6vr2W1QC3HGsNvwSYivqPIr4NJoO3PQo0X92kEKfvm3ztoFBv50uiPDSVACiAAN5F2FHvznKSiUkH1WoPadTtrKh0WzusvhBhqommXI35yyVxW+dFBiVJMXCP0FhGhxA6eBZbQv76hFUTLLiIcM5tpTtEe+16k6xctlhxH4cCnBquuy2SG2jM8H5Cw3DdmyVgxz5lflbRBVvSV5pm4SGV61+JaSMJNq5DAsfjWOcFPb0cvKZ+WEbPgaSxs6IYq6XmyOCoo8QXdqYfmI+gNsUCuCh4rk26TWyShlWHpkgyvyU6VbPAwd1TkeRhhwKInLvWh65tx5RHFYo1xeBODmZhh0smOkRzxdPiPbFr8FvTHeJTvz8inaWVayw1zDr4hi2Dks5wsTfBX43ENvFU7rTZKtF+MHrNmNlWzI1OZMn0rUwsbNCIzNdPXZ8QmvsqQeDMzxZf7ViQvuvOgoE37e036Xgw4ExKbJd7u5pBPlp8l31IuTnuayIrqXywpe8PKNR0ElFVduAGwWg/156ib1+cAYzD8Q3xBV7Buw0yP1ixei2uMGN1R7cfvubz2Egz8bUfB7zMQ8N00wKySxSCzxZJKVoOQxZOzHi7DS90V27FBTofZJt7w5+Qtx9EjQuZRT1zS6vYN80ItUWugxk2l5NmN6cWpWxASqXcp/Eumvz38XrL4NKM4LmD/NLwC/4L5khd4xjdwzKtlHUliIyeNPTU/9PUX6MYi6pCfTfyVwMMPV+CWfbAo21HaGLM27k4rpXRQ35YaOtaegPmDsx3B2SSYcWMc+ODNTzXcguDrx7Uz6Skq9AvX6TWlT4bOIGU22hBcRDYH8K+yX4QSWC+Vo/hBTT3oI7cIW5eJ8byuEqV+a2Y9ZRA6G+iVJxxm2GYngfCQHnyNMyO7sxFZtLmANh3owYZOJDPUjBjjPgDVu/lywoSF5+GC3sOUnc8+1YN4gF/mXmT4e+eRq7sU/+yMb1bf2W2a9wsGm19Ha59wGthYrV8qBh0Z/lWyHHPseRQvUw1viAaJPeZyzqk4iaRR91yOagoJVVSxErkpb96u3PkOEqfmII2BbmW1J23lnkHLuvnr+uIdo+3i4OpFT0BRqkC0XsjTyhhgaJ1/JD9lqYuQI9chgXPthgpvqOTME3L/t40SHI4Pnxny4huoJ7H0XIxxJONcIYxT55x9CsyoKeFaa1/Wb1GGESLM2FmCsTccPJ+R3hIubfKPUxpyB2Cs/YgVqUBvAw5EbuxfWjcaOV237g+oyt2BEkCoSbHWBTWvry0MRlsmw8DAGznSI112QeUAkN7LZwhrR+vxBviNU2z6rP45AkvbHj+gZIQvuVYRo5OpttuxcZRTnBylxpAEYfiUGAhC0JIX0Udi20veX/UnPDk85mxkiGASiPihdHbVHAxnG3onk+JFTqwz9pA0gxR6vbJ6uLyxKqQUmSFDtyS61VfIIoIlQyt+CmWQrPWzyQQmTwunkValq6jaMC/qYJX7GsCjb9aeD5LhEGQCCPnPaXBChP+dFnzzbs3swWVZpvK+dFTEpzCjDEYRoGGYn8dnXEHOuJqmjMqYQJ0n0MmxN/mhoVyy9V8UtrQFYe+j0S0BpvRBS7ikT5dXJTGafLbGJ2EUWLaNbEvmZiBKq9HRzG1wbeHKUYlDtibaxQGonx8cjBTWrxu3I6DxUIrPvuM3v4Z3ZAX3Qu6QS1J/l9iHhE9rsUd9St4mwT9JJMfhKiluzgKLZqacGT0rSkJm8ITI0mp2YtUty8zjvoxjBixTfR8dPThIHeIpsyTv9ydRkKYg8XQFynuJlSl+aftTffRKt+Qhwk8Bkm7wn249oiGftovkfnWxWVICsQrVwDFhrQN/jvYNJrCxLYxTszp3OnqIKuS4DyS/hWBkiG8ts1xgPO3lSatldrn8OcX+0Rj9BjD6nnB3JPrT9Xru5NJCzBZ52h6aIIDc40moXrmb76ELz5zT89N6wEeEs2VmQ7+9Xizw4OiLSxQ3qNHvSxX4keNTgSzTI4LhUGYUkX2bmJM7CPeaI7DHYhnQok1qu9nS538fykMaC+xLjIRVm2M5sS5WPn/TNz8FsWfEbySpMq78Q7NQc4uvLhtzNjjTP9kL3VZOk4GeynjmnREwYLycuzYKH8QbnKPT/RORVEAeMp3tJ1h/8L7DiDquw41cEkTWApzoFlwquFWp1vblLB8V4zJ9FtX82Ru16pWlutwj7lqbogz53s68tDJkqFjbu6pG2gBumzTkHjiTreGtWwXqCQJxLqDV24BK3jFvP1BIkONTqZVzjm1lpsRf00wEB0dbr0CqELcna4xX8DWAYXICrT/g/CRAFKdKG+NrHfrslGCT7cTySALChZp/eWAj1op0L1dz6ep5OMShqlOdKf8n+cs6GlZBp9sfLsq29HlIuzdmNMZ6VI0z3NKpqyqazL8EBLo61mdtnbW3XpfVIM1jKZrxOcnoCrc2LNA0LMLpi+9lE7vXUTehIPAMXn7r0dQ1mrLM34e+Y57u7jz2dWZfYHaj+hlZ+CpnZO9ahABD14Gm/kpR3Ps+ZBUMbANtMLiYpeaBvYNti4YhXmkeAVw8bd5uH+LzZjMZ2tNQTUKwEuiFV2hQBhGOlvn+a/EDKtYyBs0U4kpkydeXdxVaPpxquYc/RXA7T78J02DuefaVvSyuXyXSIQMDlmD1hNBCK2sXvZNhHbNmuthrARRSkrdgFaW1stOKjtuhU9JllMnluBwFQoSEEhJ0H5kmKMcVfw706/BchrIxoQagahOUWwtqYgvUwnWN9WzztfwR0FZy9Txg7rhDki721Ho64YVBU+2iW44uwclPjPGd51YZJ2kWYRpdjoOLSPxGHOkhImuzpMlA3anpZ7FkFZHTqypE4uUYGn1nWhQaD01KHrsYuUa8Uvk0wgUOtE/nK98ykrtHDZAFtUZedC/y9obQOj5YMDrx1EiS3+edaNCma92doy5M66ybgtSiCL4OueW858EDjTzWwAMMIqhQOivwakqB5b5T2tzS5kkO2sPizp69JtjwivxKsSOTplg0ErsNQ5CHTYbLPKVnNSM9o2R8JSxdq8oXY2nFlcV+euWUXHvJMvnKTftlm8z4nJ7MgWIb2dxZzcXL9su9KLvdqeWnqQtR5vjB0ahCXAqFZkewZsdrFV13vx8UheEEYomkV+DxU+DohGOJGS2kiU/ZbOjG8DIixIc3AgdbhjflPbHamlOhPYVMqE4f+o5bfQC9Jtd819TV/ilTj5lx09dscfsHvS+7bos5brdTDuP/LaAtrjDx5bhpyQ4PkzO4p1pJe0CAYmbYZWISlxE/Tf5I9m1ANHP+ckRj0eM4vAsLJBQS5LaSnIsv5ktLIRy+exuLgInujjjmeDWLcTTTMYAQwXWFZX8M73RytvkklINGt8p1jwzXJh492Y2M0QMSZ/AH0CL8kd5T0N+50nbVXpnK105GdPy4D38oPd5aq8Fgdv/8Ary5Vu7NXr26cN7eClMXYqsRN3LAf/L8OZ6dY4uLyhfVPSFRlWHmPDFpJGVTcBP7XBlbWgOcz6PnOzUrQJacF3AX958YpC0KgEpUQ5SOL6rob+wuKOUy73PCVucN3MPzTMgPZvh86jMpIAoleK+qUa9Gl7kp6ks9tCUjJPuJtM0w9mv88X4f5VTKkSQ3YRex33liSKUBgXYw4StVQgqF9bNyxi4YBEs2fkTUclIzOsqQi116jDS02Tul6+rcM/nllo+ZtgZ/ZKFWwoPOE1Eo2/Jg96S8ct57AWS2Dbf9gTW6kjuYbpnvZOz9A2Y8I5f4ubAVvvi/jc8+4/3g1F1BshxDQEje2g3QVmj8GlYEa5+TMrBwNZ9r1g2ykuw07ApknMbBXbXKqTxfpOk4QYPctUMnKFZ4lKrrShbUxnAcCbOF8UQgpXcrMLPxkjNFP0jnCMj/ul9WiFOT9jt4/Fdp/1wZLZI7pTOgU8ui4+SOWI5MsPNfjcjncBxvBaZipasztIkfURDSWEQCQFMrNgSxQoX40UGkvvTj/ICmn4yDThdagVrr22RDr9e37jSX4Pd2KiVrJHC7120M1H87XSExsXl1C4QAQAvYk+kRYLHbtdshNS6rOAZzdVUmIUJ7vvDptKvO/dK2CwkvAKMuwm7Fpln1e0Ag13JZuOK1VoMbCdrpVl94W64QHWcKIxoOVFh8x88iqXn0Ie03U7QMbY1Bp5aj2TRzl3dLJKbLluGyaW2/Z3QNkEuNfR2MUNsA+wyP+14COgiaCcdOMR6CbZkbuLvVzgt/LOD6cXIbY4hn9IWnTDflPjic3zaIgvDy7tCdXbH2uNkHITF4K9DxuALGVgCXEMkwAqRijo/VGMaukre1xm4i6oPcQVPHXyjvrBD//+9nRO8SZNEin1Xe3dis5IS9ZjB6y4sUmn2YVhWxND/vb+5271/E5iDfMgyM2fJHybAKkHdw85cATvM+aq9ZcVjIEBNyJMhjlqr0q/CiXBss1gJ75E0MiN3gWQ6/9KtE4VrR0EwaIRoj0aipW3GNHS9sdVWZ9JrIItudQvXgmgz8X000Cx/CCKO0o6d8lunMV/vP4Lf2hFM5tgB3S3izU7h5JLzh8m+vjzV2z7TkykmZiNnDydvTGIrRhPZb+6eduefw9hynJ51sSEFR+3lNRawlUciOtr6BTCYMmtDgt0mKCxF/n/qbH5bD7Uhj12w6dSMYF65Lr7/j+SLDcsBGFHag7IVx9lnQlgHHVR7Bw9BhHUrPCa/pweOW5gaO/xiSMUzTe45wR60fXX8wXl1gCDZRINJ+VneYIeqBvnzkTypiwvl23esIRlec2oTmm1nAoRjq19XgaNX3KDsz045WKTQI58Ptnrv+0CCO5RlmBSLTTevQKyHGgGoURmpL68kuRkd5e5A0cwCOcVvJ0X695Q2LwiYU9IRiIzuE8xscT0OAUncsSav+vlg92YW1JCRiP2c2MsvYwqyGcQHzZ+aUirtG+HUkNxijEa+QIZUid3+zD0kS3gV6n+LSfjcNlWRFAKwdC6kzkRqb8NREagsCSOqn5+5zxDg4p+YsdAIpV1xTaUtRDxZ6VZVl6GFgrrlor5n/DzUHF8bGtl1tbs6+FOxmDMZFJLS6qExWRj9AclLbvAP7lnGXhK3yt9kzdWgV5UGeQy4shrrsg8extrhPdf2YZH6KxKNdFeuUGZGt7Em/OfZNlnMInthcbX9zEeaZ1MInu4j51NTBlI1cZieLDuTiKGiQ0BZJ4jD7lHoMvqFf0p34hsibelfh/C6xanEX3mdP3kCztZRJsvzZQzpV3bNIxlzyOpmqenW7+nO4AAgkjRBvAV7+T+Y2rnsjiuNLWEnawRHZ/kaTLfonyuFhjRYL5Bq+hh1eS9wJ1Ai1eS7M+nd4hWroxX9P6MdRsBNh6LniGn5rwrU/CNgzLkShNZUZQ7dswLwfjKaYQ8jKIZiPOopqGfwvttEBHZvl2Kg7kLuPRUqYVX/QTCxIFeLnJcB2mqVTwcctVq9GXwnSBBC09UYY0xZI/3VrI92wTY23YipJzofAEVqDMkGNzvWOJn23ybsMMmKenD68hb1R7lhuk60RHAOfUu5liYE/5vELQ/l98kO4zpR8bPNhBvAUQGT1UESORRR/Sq1xOKAz05RooEpjLP+o3ROMNSKmXkwY8g5o0QQ1h4ahfq1ToO0cqJ6Wi5oBGI3g9kpKtCP+5ZMXGayvTIi8w5phCOyhMUUJCi36nAnnVnoS3ia5s+jb1qwzS0SfpABIJbaz9YckGLOb/jr+p2NRuIHkFXVz5j+MVUxH9XTE8jwtqKeDoZSLs74e8tPBBUzQfPiFAMWxRhity90JtxTebH/a5umhiHjVQ+UH+NtsgjV8FDoRILr5u8Cyi4AsgF172fN0TCiAXnC0Nng/BbJ/Bi7wktv2Na4HrLYtnZxPtSQzmi90sVpNY2cEDDX64zzMCb19IeddfvU5TU1gmKhZoFq5ItIkFtExE7GqSvpjpd0t2vK9B6dedmPJR0Ck9Gg7n7jUJ3BnkAfJ7cp1ihhowpEdDyDkU/3YFRGL21A+E9IE93P4gMeLqlvMUNX/hRSrJ8gzFm0fFepG9vxweEQNHzGWUq7Uck/Qybd2YeO5IGi6DfZ7ei6FLJym/bAWHD0SepIXjGAEGZr0LUMczczTJ2ddmB28Z2bewPbVQU3aanpQh31BvkzJJtg7BAKPVZpO/+54YC+/dCn5+orK31PmghmeWXwyZ1jcmPSubpA4QgXZjHiRpI+kVo9dVnUbFHjfbYlViFBxYXpMnv9azmC62dqYE4k9jMxz1ZV6tff5eA4wLNloqMLeQoYmbi6dB2cvYGJakW79+eHnkTuu6/ANhpYiBoAUN15jKYJoDL1Ep7XXa18UP5MZPyOwgP/ieNOMIAVixthd2dNoDvg+Bpv3BFdvbFi36Jom9MG64Cd0a5KPw7lw1Jawcimed560A5/rN/ZbR6GCQDzDsy2SNCgH/onl3ogzslitVeocdG5hBZsX4xc7QQPd5ZMkEnR+b/DfdvX7X0N9HPyvfCE2S1ALfM5U08DzKXZJznzHgF6gdl4RGcn1k389IL0I182QeqFLRBHRU6iGRJm+aaKAfomvJDliMCLfGDEWTevDSUERMTs4ClNHGKhjSST9od6wDhDHmZE+uhX7IUxxKBBWAOSibgPWVJmwJxsqS1h/7NFmOXJaUwocojs6wAvyVUKQgrfCaccTdHIZyZOHGqW1jhtgvA/t6Jsqobp/0vywTnIUMXtDJIq8gAz5o7MJ3NE1/gPzx1CVNRMS51oqS+1m0KjEzcFEnf0Tlwhj4ZOgvkkZU5NqI+whUcXW7k0WNAFuyQ/sTywNYruO1fD2vtM4D2/bHSjhAevHKrFvJ9MrPSYDJfjI9dr11h3QxXfUt8srAs4KqNEVDEJuNFzqp8vEK48t9lYORxHzR7FqeRuUoV7uyxRShbDG9EW81l8oeAEyLO0++N+jN88baQADWw/+S4ZqNzulOyID2MYXIQda6hk4pEFvZFVIwKnvmoKJ6kyxkcGJ+/cwxZrt14iSG7W7AIOXiEcPSEW2mhBHHFVcOdO4sPiWHRNj+ck3RLk9R80/MVxhk77qDNnGCop4Hid9YFc+oZhEhsERjGoOl5M0pVon2+QMSCAIMCzXJeEZQT9tDonMNqIsbCUPW0L0W/RuBHbmEUUeqKfuQi7jyKiC+OmiTgBNdz/M5oIpE+dNtvte4hPEe9ohdzYc7iPU/xqfsZs8E8qBa2wAl+768GNuioicr8SAFGyjCpVj+tpsZWfSNIQZjRGaJjGWCykc7GkayEuz2sfrctiBC+IS1N11XYxTbHU/Zu/23B/AIaFgnMc0o38AlJnsjd+tMi+YJOBuVS5ligH3ptEA5h6b2Mt63mhSBLsLX5ypRxBLPxJF9sLL2FLfYJIoci0p+0R7o7cl6p2f4MViFzJtZW3BkQVGYM5JwE9uR5WJMZ+m8yUaYgCQ6cKtBQbVbjir6HWjzxTQJUUpDccR4C3aBd2Pki60qTMfg0i7ykamIJ+VKVrgRY1+/uL28ObaPKDSroPUPtzsd350aa4vtOf5T/HEpLrO55cycrRCI3995idZ2QjXl2KTrbsnFoj84FO+XE7H2eH5riJi2ZRNlSiOp7EmV3+n2x0qX6bn29bszj+069CfRTrvh1bGoqPBYd7WPQq7pgAMslcPnRFwwFgeLxX52XLHIH+hZzb0KZCuT4hDGqMo7Wm4k0U1sbMpEbK0oROiKY7Br2sQCPxDmjR6eWohOFH8RDFKEXZmkcNXtN2/KGMPb+2oQaIFK8CY7THnjNJSpLqNOX/9qqfsgpHLGex243j21xRwvxSvdxfHo0UX8cyuL3aomxE8T9dYIFsRPg6s1ucsB5Wc0MbIEOxtSp58QEC64DF+D6b0KM/v++QkvrVjXFlkzsvLiRNI0LXMMMfbkIfVIlELpb6bLCc4Ba9AMpjD6UQrsxJoVsMbGl6YlT6SY84pdnFY3LDgWxyyFW9e9GB80/yIlXHyW4pwPaHYHkPhOdWztwL0BRqBB2M2c9sAvdLFAYmg6JMc82OtQqZhjOL+kraBMDSgqclsV3h2Xq25hJjNNrBz3I8VQjoX4cdd1Kj7k69Le6KIXN2QmA7jyHJ/7l3JqscP24uzZ7Oi3ibXXx0chuwb55vhlcUbLr81H7cG54BABsXMfPyxF9qODMx/0EQ6cUc4Kjsg82a3c6ua7s99eqIG4BCWcetXJi9cehDLU+bR+jVOTKSFX4220QHIFjoEZzOn5cNUcWXcpfy4K4Oym+BAPM01ItZlAn8Eg82UcyEbwghViXiz92RLyo/04nXsNY3XAlaWP9iz7a86ptO9xC8g3QLv08dQkRd9zI9CCaqK+5KRh9Xh6poP/cVODbiXg0xXnkmLqvIvMlOrNmH/VzPY82oMFwo1y1w9n/Yxwkdz8j7OtBSo5u/EkXjGS3Auqq3jOpnZkz3cQF2jVcJTNvI4Uur/sdTWvIlmzrjao8yxyUEnclny/nurtIe+wLZVGZ13tfSjHW3gFO8vK5YBx+HDBc/DiFMiUYEhBkz8aGwLWFDxlB2W3hc5ygWdBXAhP/neRIEHEfDVUfr3qXekTFwzA5FE7b11jPzn/Jjz/IsfegZDKBZAkOwoXhMzIbe2d39yIAng0uXi/xeCUZl3FEVp6U24AG1papiXhNno04MqipkDaDaZS7LVCUD9N6kXIKfMMHtOYahyjlTZ7hPWmFf6jKHUsXg7rLpCj5a5w42aLt5d5iDFLLNDw2sOvBvNZzk0FDVVK5oEAfkEouny1X0FWR5FbXoR+o/nbDpuv4rgZaAEU3c/OuErDc2Of4ZmrxoOJ5Ad1xPUjf8F4+aSRcgF6ghj2n1E30eGIbarPhwrGPAtRrQ/0x3T51GeeRSjGAphW6BNZFKQWIO5wH9SVceWuSqdNETpg/yR7CDxcSxw5lGDtqwtQuYUhdEjtXiz05KjQiRH+q31khqSVCshacbTSpr0gj1qFM4fJzLhRwHXNgqBt2NlF+p5vkPWDDYtRWGwto2SF/xbfzGiRy69geQ6vMOySjZw3wJKyM+KvVDSjlfWewpAt1HJ5v2H+Xq0uoPnP7dX3ntAPAHNN/w9brB9wesReXSVu0hZwKzBEFX/zLBeaDyZF2jJY7LxgyRzRHsfTD48KV2Pa8vPJJhtBcXyY8DkX0nEVzup8RtgcZNOaCdHrANRZL2LOgchVf4iVBNr6PxJIpdh67hPZzLbQ74PEUM5B/nQl3K78qaPKuS07A4vr0AxMkl4NWViUXkA1HStupxRrOTZmCxOHkNNW8R3+SnwR9r5VqZrCvvliR3SymuY3+9FRUfarPaj37E5xn88NEKENJUxf3AGIUbXetP+W28ZIl+uyu360/s+UGpr1dhEdH83PBGl/iK81RgW4Bz2+JLW/B2e5J3kNJ/f+F5wDO8bnDaDWxJKC3Am2Hj2SAMDUDz0an6CfgefSbiw87pjTpRp38nkdCfuRflJdLjuElTneSHlcl9yDtM3DHzYoQ/eEoc/l5/kluzrdZJ7zHyE2tGLM3avuvKsG63ILfTHZYRnwyIsQXSJARcL4qJrWX5R+lzgdR6UpSfZwjrgN04pl6HjlFr7RMKDNVSqy3uNTYsvJ3ptW1KeG6sBjwhApNRJBmJeFW1f1fVZsVLJFlKYGNc3KDX2JazmXRhEJmCfXzwnhOjUOmEV6rKfVtiqthfRkEFVoye9bAv3y6ojkEdUJyukUTnnIm7f63Ad8CPcuG7Mz9YaOz0p4FW1XFv8S8nRl2RB860FhsIEx7RM+JGCi5A463JLdStbpr24u2M8g7TARjXOY5D6Smj8Dp39WVPazgn9dFI9nErf+PrJUFwhWgo59b6RMWSgIvK3/RJoLs7HjUAKtXTfAr/YXRbSF6jUOL8IONjOPonC6cgxOdlwuJXdCtfrdnP8nzsFD8nBmrYsPzc6ANwzUi7r9tgC4e4nCBAmvyveu8YvjKliOl4KR24MW6Lez5EHlyhZixZ6JPN2d3eq5eZkxV4mgCl/i3y+Qbm/nqHb1Idfg4uWjJaDdU4TgW33ccC+ddgRBdI3138mICDATOI7NTMj1tMPudGR/mTxeiojcDX5ZYXRYtjpBdhGQK33YuzzdOOHXTYEMhNdsZbq3mGMrVbjS3tZzxNeg1AEHVKdvXJZi+oSb0hpeGtuT0SMUWSW4c2S0fG+U9ASJm4ihO/zvJlGQBsjTd0HTphTtbNsGKFDLlafWf/g/CpvQcdcNZ/TAlRl/0cTMoZ3YPQhJNLPYB9cXkLy7Kp2SZNWGOOUWetmcoXpm9W0N/XtE8Ke3+GIWzPVm1teUfGfvHcN1j1ogxh2Ya6M/b0/xym8yvEJdyTHVZqFRpW0RlGfwMRKIDI5KoD1YHoJSRTw6TO8twsfpZ3Dg/ODZBVVFYp3UPWDGsEz480qZg/T3ZCMLwQodJaDToS4WZoupOZMy96gCHGpz4bsNTyopTsFbL7U/NI3Fgeqm9K7U1+7DyDpMtVuVSYaJrkhnoZyw4hOWCCDUFomW/iOzoJuKVuN+RU85dp9XEHklub2AoGvgEgShDYHL+nEpT8V1T9wRcV0HUOM85WCnVPZNHCTwpdoCl8FUSu0RSV5UxJshIQtKtDk7sFwfiVs0sBDqHm9jVET9ds3oDtFFHZO2fVKdoQ9Bu2cxW9HQeDr7vpe+FBfE9aETknNtp1AIhibWZwTeyJsavey5VWB+8tS1WLNnEAQ++Hx+CEieeLXoPb3Qb/GjHiADmny3jV2ZR/JzVtW8/Ovcyz5XxZ05sy4Ig+aP1yG6LgAQrK2W3GlN8JOi6LurJ+hR9dVvb7iLExY+EaBu4Jj8TGMvm6LEv/+jtSnbW2tASC6Tl796e28rOeFIc2bMm3bUJpBuuTl0aHAaVd/s+nz6Nz3UakdXfTAmfJYaHA2Ne9C/UlIDpbtH5eF6mKOwU4bbCPtHPsUk+Ymn0ypPZM+rtVTi5IlobDy5vLasZnH9FGoPF2JUpSRLByX1KsM9h9Iy8G1WP79MurvaPjUmHk77lDZKZbu456ZALxXzjM6Dlr+4/fTr2x48qGWF+oF9JmpJ4Du3Bmum4QyhfqskL+wIFxd0LoxXIEBDJSBzloN1ZDH9fMM3JBV72jNlKqcruR8cKn8zYcHv3ygXL34kOmxmA5vigmrhwnBciEoZLey7WBgIb6stqyMj4/Whs76g/dCg4eAXPbsfLvR39yhIMuCgjsWo45P7Rv81gUDgMMqbtKN48S1DAmUK6BImOP8T+qXwa5Pozl5GcmCyFw9fxJikG9zEFNNf8qaJfrmvIvJy4amQ4WAU8LY0YqmyEvGqXwmfKk6i2G4L7L3KCux3TqPiTPuknmMcWz2d19Lkb+6JLqcZv5SGG2Fkk9OYpioFNfMuzqDz9PSKFh89l8j7oMoxhEFXQvOn72lZmUNzxGpOIgdriX5ZnPCx0xFMO76pdf3PD9fz+bxm4OKcMAi45Das9dBHoGGP74Zyot3IZaU4lmcCn9xWmezypNN9qyqg506LrxhQVay42lBHgYa7wGDHYsDGKKRYeXoc3JGY+cujlRwPWMuu+/nMdZ+ibWUZAdbu2nIIS2HJGHRpkl74HaMIy1WRZTvXI5QFI8YdASsGH0KyqTuzi39oHXTDoYfMEvpM9WLI1GCzNRscAtQ+NjsDISzyY0eb04MfjZHrwtAY0wEsLbThq0QM6DIiP4yHbbkz4intkAsDenpCf5PaSlKdXxMBnlkqw095a5zaZNTtvKcKrw/R5SGe3G+l9p0U6I05xLDaK6zJRj6JV9nLv20RP2eCL1F0JlZimwhSNUMOD63wrA5YRNSB+g2x/5yD3O1qanGU/wYA2aVyPfY4FuUSka48p41Nlaccs93cINiAHo8O6Eq/t5mokrTYCGJIdTwzpaSDzia9bWR56Yz6S2ZhZCi27PGa6JF9Bw22gbhQIM8+iKalTKhKwPUPiiBADZyrf47MVbOVg8A7H7CrssIZE3JWgCScyGM809Tvrmb5oL/ypyyFxFNfKbl1tCbZTTPhEt6M3oBsLtU+CsJah7OZYlncilOpyTjtKgjtGQ5+gmcq8B37UwjCPCI0JnUxkiJBkOLYobpCf9M23LWFIL34KWWwcgRbe/Jxe2d9xRzPoZJkU7rnjBiG8ZmT07YtvE+nKAX/9H62UJUS3lnp3K+9H1c5KQTNYLAHJ6m0wrtmmmOFLXlQcWPl3w/tK8/baubTaxgvZTfD/WoQgzhqR5DbJ4t6fD0Y/s3slezI8cQgL46UzH0gT3Llgbf9+8AEGueP6edecD9ezOvWKp69F/mLzahlYpBspWoTIb0LhLBMe0mFYYPebok4pmHk6Nb98zwvYmtuqKCsLOBwEIwDdy9Vqv83Gmq9QtPnq+otqJVWjuOL983G5SYOwagj+Dv3H6vp+NoENZ4Cki3WHGvmXmcy+CloB49Ek9YVvZer3/6SzJn28JKBQ+/YgwOli6aNq4xo2JJbk/hsMRJHkjz+0E4vmJjiUZGIvVBZGl1NpYh9LLcxaKd1PXmZPa9ST34UhsTllCA2HZY47kdZaAkuZ7ICeHKDUQmqa2xIYKQ11uez63wZthL39k582qfmqwwIdBVIJz28VygTWYP6LvjhzqjeWlSVKqzmj9oKUz/VcIbXKQw/Tu/8gXqcYY6ssCCW84hCcD/nwGoF27ZcDp4u1ExBuvbb30g+Ct+212WgyM9GQG5eVV7dfYNVP4vzXwzR7UsI1NCd6MeNhFpnom6cmDEMCXVpIQc+tuac/nzyx7zObIT2QbEo0p9AzRBq3mdmmu2sz3/Ok2DVNU5hbJJdpXrooVUPDZMi0wO/pyGDp/sLne025FIY2Rf5wJJ/RZH86WTmYYt2VnMr7yQM6eEpVF2zSTA3Ez3UU4s7n1b3Dn3jNxHdr4dg7+Rt6k9DU0v8BB/9Hg3xYfm/7moh779uz/QzhlICjGn+2BfEOZFhlDBkxR3iys9s91EoXz7UJF9OgzUs3vbOoHkX7CnxANA9ZX1lSSEibyv/k7D08eEIW2zw/7Wu5yOkP9cjMfdZYK47+GNfwEzvMF7o9Sy2zjA5ka8hDdS6rQlyCSgmc5C1RI2w3/C9E+gDwQP8snTRFKpXKthMuQ2MXEt00N0JTtTzdfLGD4wsM/2b+X6Lfdlsmpaxb76iPjQfr0F/Oa1bj5CUJCFzBubG41PNxvxPZMFiRA8wKxnyOjgKjI3G6HrwQntYq7/9vI0RyRfNO2yUxCirRMivGX6BIlxymRXRyvCynuCz9OknU/cAbvqhK85gMpF13O3mn+YxBCDNPsGlXGcIq3ouJH6HlmMkv7xFJBhsfXMOdaZ4jMOh9xk5SGIPDgdjQIq53aIAGus6MNb4uD0cxgz2tduRGEZeDX8EYJOMT0FkvD6yzSyLAPBqGqfriEdv5K5M2fZZ+3JoYV5QkfhwMYPBYiTy7tbjK2CjiDb9ul1xADBdGjiVK7SdFF674NBkCdjiYuhCDyi/mYTd73n/ZVh6h7NA4PQJ5JPS+jtEfDHad3NiIb64UD31HQAhDs0bFrHHmVBTkg63gnQJUwE/ev57lYvZ6Cm5RElYV4djR9YWOkhWajVnduMgJch0961wBwFkFRKoyLpXCcach5x9YFIPheCVMmxtE0uj10ID8bFEybr1V941+kkWeo2zdXRvM5jgZxE3yifnpuza13xTeDlQlITKAt58ARROdTD9xdwKgA0VA0Ryg5ZiFqJIuG/nhPGElQh8jF1pBO+9mJfaKA1x+NSzf1ko4swFO32i++6Irf2YfyWIa7+rH2XV0IeZxr+gxKpwk+KctF/eJsOVAJhmF8RiWtmr6T12Hje/+4OrINkaw6hdIzWypGdw1vB1UpRSJe0UoCDWsaNXL0otXq6x/XO0NDE4VmFfWD1sCz4pnVQPCz7TIIWVZpxf9dqep3FMkPe+nzNFbBvLSgAs3HwKQpZNCceUj+5rtMMJiQM003Rgt1btnSjyTvtDwkmyZheH2EV+8ClJaAOSq5ysCXcSDaC0Zl+TJL4esrw/O+bA7KnECERx7hAaX1nKO9xCWCCNiC5S8J0nKjkAMV4+AuqomMYUooW6huNDdUF5fCez/E+Ideu3SLrtnn/SlfwvEAgAjVDI2zbpakUKmjwVx03QHuhL+11w+XuzXqlT0Z+9HudJXMBgz/Gr2FPtExVqYJZ2OLFqCwnAtMOSZ/5VC8mexgl193q71nasyxUAjU5i8f19rkslXEKdca4H8VJDX6Pf1pORPxQAgrz2hWHAVcopXYCfCgv0kulE29CvFrEbvsrdXyRDvDnrXDw/rUDakWOiho4QdZ0DUzMOVbXN1IV5pxZAucD5tD2ooQgWAj9BI+AvT5EEV6tHYzqj22YwZeuuBqMwB7BrD0iUGdBOEZvEk1e28WayRC5OOYGsGQruOrZidkzokGyXT+r1Jh8ynpNULces3OFG26MTSuQRBjsRpq+YqNOOEyFptL2ovWwOsAxFs/tAprNbucEh2AgksagEdqjRu9maFvPTWxILXv1a+fOUMaK2VXamHPQr0Sjb3VyDDQi8XrWfGCjoj3gKPo97gaArOHWFT8p3SzvWndYH+wFV8RDZ/CwLN1l53gSnPhDwRUDzxecZMVwCbV2fUWbHVxlbKD+QVLOFSxbAiy2ypdYolSMpzsz/T8LgMAgsFlXP/w/OZJgZ0fh1o2OkfsGPb7B3TNcH5CBFBxiz/0wRx/k4OQ7hr5+IN7uwvha1CFwHT88wzwaCHdG/Yl9jHzvTxUeebS25XJgA5d3oGVwZV4rSVTfHVbb7k2xbTf2XeP08iAhWcEWct7zNYzfG0ME9UyRLP/6gvX6XLx/hFQk7RaFqPGNYxylVRLFjLT0KN/SWFV5GNsj0thezQ4O+W8oamWxNnaYB3byEqNe/N7pQLwxq1e/NmsuVlXfY4VLmRG/ut61/xt+hcs+nV3m6vAT317Pu+3+w7iOzaWSRogxhLThHAbyY+DmPhXCF1+TS/DmjokOTceZeokSGbx6SGRu7j7SGqyWWEByvhHBPrNfMKfd9DAScXDaXv8qHA9pUjoS2qghiTnZnoE1CvByx/4dSIuFpu6mlPWoBAAMcHDztnV9UTQrTTb2V1ZRsjCnrVxUVCjenTWrs107+BJCDY4cG6iSWIIxupOI189W53T5iIcqpCeYCw+VAuCllFFGsalUbi/hEXDwrrc4PCHr2UeZmylZD1l8pfgvSgOsRP1lSVWBcDgyV8ddijoAdwfBsnyoeJOcZJkL0fcxKZ42g/mS7NBgcwnG8mptZmQ/mpkkFZTuOdp/CrLNAMFWntW0TcIaS2bc0j9sP9F7vuPahEWJnX6d/mEjYP3esNwDQlAay4SL7DL6n/+uMIs+4JPBVtzxpCiU7XrVoe2TgXHoQwjMPajdEph2zvRarfG9O34jZbmzMRu9ykO4sECgGdxRdriKjfnVjl2onRd/2QZensBFt2mBVViXiM3kpoGXaLGJ0kCEbNgSa+eFa6DeH8DYKsXva3ScA2NF2NNXANMn36yDtRBUIj0nV20cjWrUV3QUGV7X4DiWwEzFI9aOwslhZhWg9OVAR6VzoRAt/0BaDWMKMvgjZbcHBznzvXeNVQa4yjVimIyOM5LIVDzst3V8oLJVYKlaxLq6WWEqXFqsV/DR4D7HLAIhXQX7kzqB1aGCYz9JE09GroVeM2JvbdRaTK7tOduGXfRHxKi9PmN0djXKxiqnS2AdusqUqQDHyZb+I72uS1EtdKSGsVW0xwNXBUUuq1oAM2lhq5XVllxjyki0KgzhFhGRBGL2DBl7eTEwSs6qR7vKcbdC1ot8hkQKjpme0IdnNokNta4doNQSTIJz2E4pkbyR988W2Xwod5nHhtxFq6BPLSF2iV7QCVDqUW7Klyky1KynuMF25DGiaB0QP+VowzKgOHxxmNC+d52qwIYUYSKSgKOR4JMvEBJzzRekjB1f6+mDwvbJM/xW8ED557qk4X/fZVqR23iu2t77W7syIkm8HQpvqzq8E+2fdYxnE1QWWvMLJXDSDlp5nSxeIVOKClhZupuYpy3FVFoTQ227E6q459JRgniNaBDDTTo36vp0LA3NZZICeRRpEKk/14kfFw1lSyFedGmHBEaYz0DOuKHsvJewjUpAKi/TLwditgQKbEPPRIJ2P8jJGcmQbI72IGAjLWLs68KtR4gP56p3LpkzAN/8biftesp/aVFygHrhar0aAgsMnFYMDPQof2774WKLrgVUlZhNhoYzK9uIZ7f1rBvk+VtsC+zvrJxVzMx3SHRYPYBV6MveAzjL7MoLx0kavX7qfXcipKSTCzOlC1VYuMUPCdSjsMD413x2Syxb4lMmL3Vdu7fMVfKigtcVIb+a9BOKz9Bi23sR5xlvkg6qVnaE+lE1tL7SMNa5Fgf9hRpBM5Tc2jM15SIC+uoLjEVH48hnnMvFbZP3lRHwJIf6YaFWgQu1D57zq1H7m8E9t5w1owV+sR3TxEMtMaMf55EyIKHZ0BrN74kt8R5VivVVrF/Dplf6XfCiTJpbQ1MjlJkIoh+T1xJuk6t8obiGDxx8iLYFZxDONMeJF5EU28ljzNayzZjDDvuN0r6VsGSeb8Fc5QCHnktCHesYZ2ATebnJjvXM+p32K1HTQ61RRr0z8E+blbr3VNshhgwzumbxK9gcppuW065VowoZ2aszLhlklzC1tc3ll+FMAITid+XUUz807eZNbUuxD2SMIomfxu19GuPkOw2TC8WI/NkfXuk0mZhbCwIGqXw095gUbSDNokPWh6E29zF8kfC6nBQdF3bxYBym2fSs5mh72bnQUheu9j1D307PAA7E9QVy2oZFgUDPJhTTNqS+Tbe91mnq+I88H3dpTnZLb5SNCXFAx2LLcPCzD/RBzTAMINMtRwzjL7heBqDDTdGUQUYIpOvhBTHoROriNFg08MPEn2yaEC980/dXnwFAhlqMsD+Kne2U5d04mUMHVEE2+tozOaOvr5/QUajb+SGBr5oVRT4T47o0GIFJIDolf7FU5Rx0tFNtrXdZJ0aNbK1XCpuk+I9ZhhF+6hCL7oj4S25+YhedIFFYmwQ1xSpnMu3FX0X2qds3BujT6bm6lhgiOxqQpFuNWcpAX3jfBqM+qiNZB+9ar10rSQO3M7tDcUQfbzL1zD4N5RdVeaMuaJZk3pC+xJJHKEN5AFVCc1FyYTazutmyXlotgeePZ0M9non/tGA+o5Bl1ruZuuB7ty1paN74wYUkMWlXZRgTqhgiZxH44q9p/0Z5U7C/ZCZAOMbVzCgY3JvWL2IsEjq3+W5d1LeS+4JpklQHCPhXAJjwVt44j3Ld3ckCzHQbx2urK+yG/RMOHHTfHo5CRoSbEvk17kjxKQeEBrmJffmSgFiV2C/tr6XQHadNJLlwR/Sq75D5NaioogMeg+RLkYb7j1CtoAB4vtXUaw+/8TagBfoSyRt228Ne91IH+swV7h8hkMp4ZY+2kX7E//MB7OdqC6byWAvkNu+tuwPBRoBQY7qFPNhD+xaJy2v6OHe9MsLixSp4BPdqvMTpLwDAjqdDPruQEOxisR4FXVlbzy5mqAAcYE4NVOrgA1elvz3XnY+08F19VMeisElr/z+KrfZZLa7YYrZVaobWKDdvo2GQGzeA9PVqjcBk9fuPwAwqNROGClYuffOxVIY7IAzcqPaRGJKotqDW7/K0L25P3u8amCPoDJvm0uKFI2J3k+41Pb34638LMifXtEP9KScTx8CC5fn5TlPjQ+QDPYqJpyy39aym3Z+NTmZFXLk2+ivD3TOA6nv+iN9d1GK0PsRrjk79FNjyzr9o2vZGdcqenBxUkTPym8rfdix9JgCiSd/F6wyLn2RDVvsRUM7Ous/xiQ2eT9/3l+fD8428+2WzTxmDzupm7oKchyALhzJIFN7dLbQmvvex9uU6aber31nZ/BaWEYe2IhIVvMzC+UHtE3gkkJLGXsBllsLKl9U87ylPjRrlakOhoB3INrusCoH0UjZD/JEMJ30WPZLAiGC/jSShTbPXr3Gtr7bC4ZHmsbm2uIUgv/EtF6Q5ky7XI5gBIHO/TS1xwHi72RCw2m0noPpo468aGcaT+PJNGS+G6WG47/DP5/jkNq+793+BIkRubrTCoMCxuweXI+P8bpOvtOcaZEOq81qggxtWFypuupyTYQnUrF6hwCcJbZSQlidb1uoDy99+g/rn8du7wfeIH/JpcSuyLzSwUp7SwaER5puJX6Kg5aYuHD2cBbwzan7wXAA2czBNxZEfIMqDC+GtIf+8PH/d7A/mkatAff5s6/8ZxqVfLwgG+7Xzkwrr3bqrsuC6P6FIjOJUhugUJk1DuAxtgmxqsQXmTWL4pd6GA+hdwgHs5fQzJYaTOhmC8bEJRQhogAVAZWLbfyDYY5SBoZ8/7raD8evoY4LgqCBtkewCV+ibKJ5lAX8osXLj0jIvaCTFGan+FbGz4tHGqCtElJsOWNBWzox9vfNlhVsy6Cb+NmV3n5TeKSpOag0B5OOH6gnkvPCGtWZeuGP+U3aoOj5riQmxwT/kmwsChdrUiF9dAhnLBKgE8cY43rrobkULeLnzM+/JdIAlX5/v419z5ThfGPJkpmWreXUANuaBdU9Ql7ILHgLoLnq9X75RhYwx8Kw908j0x/HMbtaoan50yEoJoQigh5O0B9s6kfiZhdPnBBnfw4HVnPpTzWly0kkrrJDCUYvRs6Fet4/qbsDdlBpt3eIv/ff+HbL8sXzhNl+B5Oyets54HU47Ktj32xNV/iIRSGy7m+quBzLD8v0MrMPC0AQCKkLAztblWXmc+RjlR6ZL1EdhaeZ4NbJUPiRZEotJHB9VYfnZcnWdJIVjgdBkkURwJEkNzdQ6lIrWCqK0SaDepSl088gtN0z2uK31SGx5dEQzuYGJo9RDrNSE91wiRk2m9r4VgzKbvixx9yB3M2u7RZWuPqgsyhN/d12Qc0n/SojKQnjUmGBFl30YKbmZ3P/vsE1+kcnEgWmMW44MxK0fcglCjaa9NedVCNcIrvU12GwK4yPT5mj9eNjqI7CA29dOr/OyNJj2B0v4DlT8YA1Q1ypCPNh4CGazB3KIrW9bNFzULvX7X0eSNPsteUNoij9Hd0Uk0mDLxdxsWQx7rzpNzn4oY/hutah1SKWwj3p8ONaUZGOzcpiY67W4+Xt2yP2at58J1lmBqNyQRlQqGlFzVge+f9a1UgQg3Tw5FWPqXhMDdsMIBU4IdHhC2O5u617jMeXdq8LNh1GlDOzbKcy+C/AlyVL4di3LnhFPTNFQG/tf/jEPRsf8xU5Mps1XWVcVfOGtZ7oaWJqMcWqpYBMXMQnuEYxIlmaZwDyj4AHUPH/CJ0xGik+egzRPgtpIXjbNkMKRpypopnBNrGRiv+SSw499KEcj7HolvxfEiZda0rDIY0Cg1K9ol5BTXoIHyhuz5+fypqGLxgmDx1uYXwjxOSeSjONgP5jFJvVlSfN2+yVYWH3662KKT3zdmcAhuXn5Lvgpkn8vpY6seRj6Lg0xPqaQuJN9l9Q6O4B9sLLuLLanYBtmQUZ12n4GS5VC0C4MFQzzxRM7+szCKDxTQJcJyqDASdmhhkkupw4A0WvXo14dHWWop1Grt1YUx/fQlsEtARym9VMLhTQtRUJcFGLzpg20vNEt82W0ptZTKe7dmKeaTiIzxNnNqffp72SwJCdPyzMcrigjJaUQhy6idcyBG9h2Tj7LSh+uBR0NeRqlKAI9kIM3nELd9WZN69LxEicbtMfUrLP1VBtQx+Swv7g5M1NMpP4fJadZMnLYfz0QDdxG2P9vRHfA2bbQKs9bQVREy92MuSGrJDfzsRLsEpdBKqrMik9cqjtQTWPLy8lQhvKOCBi+6Y9Iu+oCnIPPQfNxLU/6MEzXeQaof2EwHPMKeM3fDub988QT+UUDVaLxRejvky+hgsHQYJ1bHQqLCwEN0+nDdssCIOhJIdONKD+t8uwiqJKH3SJt3Vs/ewx1/jdPh7Uju3NPsrOt/18WToRsppDLMjTOvWqOU2/X8USD81xWJv2hfwy8gDFgvA+iXrgmZidGV+VJ9MLQJ2yVl8h+/uQN/ezfe+P+kXs0eZRH6ZErQnosXKSdT/eCuDamc1fpGiFfbwBacFY5p/1sEoICIHaOWuTOHpzp0VbfHDkPhprvvCZGj0ZxYT74F5xvx6v4QgHuBJl+p3tHBnYJfEuigLY02ygXIARSt8RxlXwr9/zZsCFnTNo1hexnrgbHaX8v8ta4s7fEZhOeuWgFeuSOvJJjXf6TzV5StAdTIOMoeX6013peKvAxFuWmbwW4KGynEU+Ymr/6jvv4jSzhZdiqA4GRHFM7Yybv3YlqpkvkFbMA5NpN4kqhkbi+ICeMLsagrYM5e5hHE90nwGHLRbpJDSc6S0mgwGR/btnOSmABhWLqPpJNbMkdDNJ6BXTq71WHdH5Vyps0PzunpX7ZDZaIp70bl7+UGNnkUb5hZ6ThlduOzHP81wvl22W5peqmPVJGAl+vpUv635vqnywQe77ek83kvke75rePQNGEC4g7vw+LwW3zP+JpDZn4mgr3WyVaBYFhWtjbfNtSlwdCe2Ah+rV5Q4/dFOuEK8cnnDYpBesnUVvVf6YDzcA+GEtcLX47SypOWyGW7Z52Dk3oZ2GDVDk8rOR8g7PzDhRpyjpYmYAU0SXocH+LyhHgJNe97K8HOfGNm7A6pmbSfu0cjBJeXpFFLLpqh1Am2xvFVR/W7h6v/osJBnD1bPhLxVlol5UqDFCDD+nhgqo/LF6PvKQi1ZT4NPfumyi4In7J3AFDMMBewbrOBqJ/q+eDOlEGKwxN7kLHGomfpaDM4ErFBKUW9UHHuSYOR7hUP3dXEBAMyEyU5neQBCL1lgHWhU0QQ1WBr3DZ+i5I6Thi6APdt0cDUr0MIkEcvf3WsEoexZLspjf9R6l3w6AnfDSFtSN3qjbljEnb7xrdQORF95rl3xfq7edAQkFfOHTx95xXwodnDP4h4IO1gkhgQU7VFNldiGyRoqGJ9iAQCnJfkCz+br/E62eqfgCySCi+DunJoyzi69IpEEjQlBz9HIsUwW0LQcSCrd0FdSRrSm+8JxykcqJsgOVjZToWOildRYWhNlgisYB8WQABtZr3mdwbZ5SbiGEaZ5VBa/d57LBqHhV0LXBElaPeryaxMh61kNPRVmG/FKXlGLYm1D4kuWbTqEW/oF47VmXV8JcEMOJrZgcbwmYr8j6l2pPjk5LtJsP98iHJ9bBdzGdkgaH6R86qGpLNrJl1P7UXhgEaCLCkx/FATu5wxEexNkv0s1NHAVXS25FlOGop0R45SCd3n9rf13+k0xdEClk9HeeUd9T5V9045LF5grdV1iXZWazFEku3h/WwhAYbI2fWPQoCOn7LmiesYY2A/TqtZp+m3MZlEJIjPJG+/rV7jzbcXDpjKsfBKxf4QRlD9d0awKg2ALH/7HDTYyr63RprWSOJJzv9w/xr/CMrICSk6SaFiY5ji0inRDzy+ziWi43m6VEdxpqQ2LpxHsUoAkB+dObH+z9gxFwDN6f1KkOaj/WCf2VYVvb1fYRnXlGkLZJOwp+H7M6/G9m9kEVZacP/8sdhIZhh6crvizEUG40gBi/iag11gjeYGSj3/XG3ChcZADrvuZjG+qZOCCb+2Ivw8YoU+9RB6hUWeIxaAtpPzHAQaFwTeqJSXq9B3ECMt+P6udI5EpGFrdhs6DSx7iTm8cU6jrHv646K3ylMJw7JQF+H3eHYnwgsW8ZjTyIhMTZK0tCUijg4iYpzhXehe0fYQhwtYaduifSajXijDseBjDc4xDKdiM+aSkwW/NoKZOEcDI9wGeJIOFsKKHM3RuLS5n7kNRkB8mTRBz32mJab1FHdbCfOXnMRsc7CDLlH+/H0QPFMqjyD7DcgYF6uqn0skonZU4SxbRoLn6fdVB1ECjTMnkZp6K4xEJvRuI5KrMCsPZyx+Vo2BvvGouDjkiWHD6UaisvaJtOCPSA4jaHVYRNGw/6RofCd9kYwCtwKsuipcwcEji3S39qr48BnUQ9yGEu53jOUUAMcj+ucoVXkH8EyZygbGw6rNDYqg1WQ6UBVgUsfHpvGR4UTiV8rwWRfDcqy7GfLAPgSC/32xkdu5ioS0EZEqr1xgcqFGdmbdihw8K5ElTS8vXcHh2B9htCzcnOB0ni2Zhbq8BLGA8OADuE5gvII4Jz2q1Ekq0KV+Z5cYEzdoU0jNL/igwU2ymgSXp8j3wm2OcWN3UseCsp7zJWBNoRKF2DodxK3Em2BD36KMQx8L7Z7lh6l3zSnQ6ZKub3caMY8z5fHHmtkYtos8mJaab1Tx1BAjOs/J9yF+8HPNUbotT4ruhpZ6J5rqdSiIVnBP2wtvcsWyLXGAbLI23I7iAVcVq90ZqMW3bdiRE26YUj1lLFxELu/urL5LXIM9BZF9cj/OEPqoW9IcubjWUK8G0r6I2ZcWIwsgW7GAqPPu+m7kih0TPi7r2wnXqHQsiMfi9rVRC0X4UnTftIeSHEhLyEnCHMyq3fp3xwudS43P7g7e+9ubRziBs5lzDmlLTg6szXeYFjYGILJYw+xw5vmQLGaV+5Dj4EFmYlnfuWfca6LcmGTdZbRPy9fDJTrAhpRZrVA+ZqWg+PPJ9d5emvgrYGSmJZi22Pkxi8Q7+dru+sWnRJvbGQT4OrMnvuv1ObutucFsJpXSsEqMoS5OcG/BujQFNRrwlBxkugmCwR5OKSDGP7FT1ynhMDsRBEiiQ4FFZKo6b/1kH2LPrONd2WTVJtmVJyS2rzdttWSajmN5OHmgvjWwg9MGxh3BO8xDI3dDIGfJmih7w0uftDHiXIw4IfSAfq8tkRbddmSZAcs7YXdBVh4g0DTlNGxqt7CaPYrJm7uSbUdDY63+FNk+cMab4F54HBb4X4TODqsHRNLfFtDphOrMi6erFS9Sw+NzmvmAErvrTsEAsZVQAm/6qxNOEatWWyf41uX76omYdanFPS8s65nEuh/nS71iA0UaviIcpuKCk6sK9AzTc9VvXFxtGJMhwW9dQotKEKYv0arWGJDLTYB9O0nwjNHIXlNbYctbQjs4RzXg0faueWF4uB0Hk6h1KfBYPTUfYiicUlkPRofZaNk+2uF2ddQ/dEHFtTBMERz/H8WAv1MtMIlednvo2MqCBqU7bRB15tnVQXcmXA2Y3YHoRUia0cnEL9uDoa38QJUy3yeww2oQPi3snzzQyaM7OZjQ0BoMU/norQPU/cJAylJoyos5Sc2mfuhrUHusnIpx+romCetUMcHEzkGmY/nz7DuJclsxNnSO8IfgeI8mlzitTTiczY2N1X9Kz75wHk7PzRBoKSb28KV9wI7G316vYMGvNWBUDKDc6ffrZ6Awt2VlRvaKfQvQObNGnOXPQVPkc5IoZlb9l9rTPi55WgqIuym+/U1Z60piDezi7lgEDi4863423QiuerNZCeU8IzUqLfA3VraiC6XRSG5+zr6MFjYVP7MoImQRfitpH4hPu57T/g70LHT6YhA9d2Ek86hRHp84zxh/waAL9VGJ0AVEAAPdzkRHhWSo6b+IxSsgY/cB/TmX59EnBs8gp+1p7J8MRqo5+EkoCb/yo2Lh1NGC4MB75M/vPpYspYSpR6WEsNcan6LX5chFuAQZ2WxoGmdbcctWLfN+8k6KKdIpYRzf93WAyK2Ps/HXH79RdD5300vllnpJmo3sThl0NNRNGpkKZtqOofLzLbaDWgahiVWMpW9kr7roZ9DuWFDArxoOJDGh7+Ps9VX/ugPcO5XW93i1qa8k5BFzPmFki8ideoo1FZkBDKAdUOOqFHbJazqsajMruUFzCv5aZhCnQjKxK7eg7ojKaEx5Gcxe9OzyoAXPagwCDFku0Z9l7XnegJjmZ+tB6t9nbRdeCyP04C8OU1TsrUy+aoWcMNpXAQzKQuZvsoK1/EBSEZ8TqzznkH6HbQ4oOyg9FejS6gKYbIMVlLqSQ7vhp5Xj/wi+hpx9WmakjHOjYiSOZfsopvMI8Eh2lJz56dPAct9nLhFGDgK8MT2m+k1K7yPHvJcTBwntQwpvxEaW88SPTPm6tUf/fNTlG9akKTJwQwNcFIQM1jHAhPV2YKnf9z1z6eWOxOfJ0iPx/8MQxl8XGxdA39x2QxVLI3d6416lbsFBhdOC+DkNA1v6SR6+yzFk57Bg8utRolaP2uZN7rodx9bOMca4q7k1PCeFPt4PGH1swCzHxJW7ThaaMN/zs4YIV2mnidalB5TixkvdNjDjG5eSnA3+uyahlGwxtXOUMQI76LsUn6gJoLc5FKF5yKVVD/s6qYb9UyLQzNxwf+IZfzBQ6uTImBvn5Dqm9S6qkKbbL0RXdvGmsxhHNlt0WYLbucE40q1Z9nsxET5fyj8svsrXPActKf460Rmp/y7IsbhUrjQi1nosr6V1uXopExLWqvnFQCl82BPjo3KZZT8sjT6X77PcvKInPd0ghyOxZGypqT1wfiO6JpNi4OEW0rI2u9ZNqw1Vmmm6Wsd7Tn7fhxBi2MQYGIXAdV+9cHSy6bt2BhxmDgO+8KhV40s2cnwgyXYxk4wCCezxmo+mXHfcF8gEzVUXuz52RVVZp6IrL677HjcJtMraoKCg1up/gdWhheIO4mZ7HlOCw3iA+3rooI9nM5wOgBADE1Hj1R2E9+pDFwNUlh90XMBSejOdBHG9oXv6AwxogVmtmUeTYYS4g0kVjsh2RRL0BOgfsZSBeZBCRBvKO8v0c2V/Ayd9zvspevTJSu8ebD5dQk7aN0E11WqZb+ihyVRB4lNZ9b6I2DDT5sqqcPDDQ7GF2Snd6K76il9CE/u94FO9q2t/NW9THHA5oLLLD2Bmb4YKOTlUtR8nTFbtOsAq2l0oL4DojEfUOvBCbeOlo9gvT7rKVWzForNjiqAwsVa62ORn9shlDJLlNndq5mixkcfEVSKd4hhD9WrjpJa4oCq9uNJIdYc7J97HgAlZ51rKpnOPydvGPcXjBPiW2GL3k3YXQAv1zickYNG8hn2559gsViTtMZTSXAITljhk3Bhl86Qv6JXqHxFKIfLBNSnlvaNNRUC3mj4zgEYW8Z88meDKOykrAg3KR5YU1WHO5+1xNWHkS7Bo884prmbxzgL/w+tGP5ycJ7QHwyLzSfrOJPxtNnTzr0F8UBSROdqz3NChuN2PhJkLEs+lCoGgW0VHbYTk7yHhnCMgd11I3WnF1c/Mfr7tw0ohn3LOL/Di9sxe09LK2xBM23izPYxzP34+ro+v7NxxxffYlBdCcsO2MlcCTZJN/1JHov3prycaM7rVntuIqHqf30FbbZcCMssD8zCvzXDvuROKbONvqbFkfBPWLQ8aPi8aTQ4XEekxmM+YczGXGdofA+XU9xt3mGcHuRzmBafxfkZjPNe+IEGkAi0lwx3H/iRbMoXl2p7n6vGIIVzbIMe2qigTGg+WlE8qZ1m1iRGh9tWaTiQlteEJjh5tMyesKsVL4YTx3mSM5zskzpvcPGYUuV1rtikRIk+S1XjaDibLlOBNVOhJEGLwwe/RCegvEedDbSmqJfLP/K2w8t/jmNtIsIp6Nr8Ql7gOvXK7cIqSjBW1kv6hiVTlKob/L2lA7dkxpVHr6+xLPRiPqDwqWyTLM+tMgHxZlw3Xv1NB9uaDzd8QUpi+glhYxGVYSFnZ8wlVAqQ7c/cMU2wBh6vUvywSPk9CY/Hkbbtc1pOWwvUFJHM/ZRqM86XOBoej54qzhZTqUsJ6Djri8N1roKExIUYeP+wJLPZMfgkjyKZ3Yjmmu51BK0DJ2JurH0TDuGFmDlU6rZAqIBnBGbtJ5YOUznsZkeMPuxJGUsaXcda7Z0jLYXykCOpRVkyCXYFK26JG/eZY5bNKL3CxCYj93jOY0wu/PGGrTBWl+q6uZIDn+m0eVjehT/IekwNKBgCm3O96yB5o1h0r1ce13p/S730tKFxUoZEwgHf1YLmjoFhRm6TPw5Nba9S8iNtdeCbUBmfnV0o4sU/PTx4peCy2vXuE9KrYQ2mFk3wHKlJvSsxzKGoKbf0wjBuJtsysxlt+WTc8vITtK4VJTr3MzGD83kIdgFOer1PBN5Wfcq0isHbR6B3bs1NnEtTzTSWg4qbIoksnZNVIum1biV83BI7KNU17TYwmik19fRkvj34hGzPGLg1pvKvDFOHfofb0o9wLjuNoSk4U7/LuOe1pw2ofYREKbe/RHTobUTW96xW7w7IvyjNIsWU7BARcadkStDF3jnjnorTR6QTbJ4bTkwum9TXRqDCE5ywImVRBi0nfBOiw+snnhIrHdYXHb+QOIFPHVGgrUi6PViiX0HjlfBP82sxqrfczO7VZFptiKcRy7PmjNHVQlzOAbV38E3HDEDFPV+1lqUX3ax3YTACPK+KQeCbWm2CAXN1er/lz5uSstHpXzd2xcg4Ja8z1Zq3F3HpqzJ18REIDwHSgXy3H8ABKM5HegJyMU318LxU7cETcyPTI3+2l8ntyQOIqjS2pKeYoCb/hTAco4JCMAtInhn5SkyMpGOfwvCn0bhyZZUaX2Pgq7WDIn9piCUz+SmJDV7mmggnnHygZT81aFiJn5ED8ya11igq5TdOIrCzu8Mj5lJUrM4ERNcbi7l14pDlkFhaZbBo53BZOvKeto+eYhAjeWdoq61cq2ly8Jx1Tn9wPlxWqmhkHmKgryPcIkZ9J5OLXUsY4A/sz5jV0zuD6YMqBd/SUYxoeQDCtF7e+35tBrKdvEduqXPCZgr1ZrsAXbfCFAO2zlTNXvWOHDV78PVTnGlaqeQUhQgo+eCZ7bQqWZJ3MK06NPtCnZNwN7S+jt2S5EPWI92z2Mjx94wHBJ3VZIRFOD+GOG/wMt/b2RpW2KJ6gv0rR+0Cj/AbY7QqOdK7E+24fVtBLISAF7rsRiZwbLuDp13og1i5QwGSsAIMYa1vYg08qOUlddLMTAPGo5F75NTZYdlWH8NVvDOyJc6+HfjR+qvkxRpqo7LNoXT9WchlruSF5Vm2ezXVsR/MwoUlUitR15hplNdAALbwbhz8U1BYim1NmE9IatUl/mCNxpPbKsnxnJbQioDxD0O3+OpMridbfPrrR/k5IG92VC/twT+TaiUW99lzie/cDZw5lA4RNsQfi7Lw2//rHT29RlAm3k/QXr8Avmcbhw28+5QSlDjsfVkxkHKy+s48lzo9kw92vFPBTtJMcP8UrAUiEDFs6QJRmRILi74eK1NUF0Y+G2W3pewo76WCtGG5ASkWjT+5JLslHBzCOBYY6j83pfTVfsqdItFAjOhi3Dl68hlthxvc39cwbS+KM5YRBfzGj8o8tvRBeYKnQiuqaAtklA9wIrJougA8+wejvS4HqmB6DeKMHztqm9yb1pIhuZlXMQfQeAzA8mdjmsvNPHRr+X5nW1xTpUJAp80SCNHjwyusZdS3zorTWaZh2mgujstvbVY8LAudpr//Ei9J/HcHpSe9MaEGkdpxl/sdEKmXVHfNoPzUfGUlzfO9T/bEr8Sg7mzr+ttSquoX+Y9eded8AUsw7uAMXDC9hxnnatQSdsJUd1gb0ZTdYu6Z5GLti/yWa47z2x4S2RbGS0gSvi5E47kfEf4Y0MUnTv8OUjKUJjRlkVIhThpKyvgjGIafekU2U5FBSQ0486F4+wNZZgANEoW+0JrbOoq5k85FakIwJBl6cggwgBYFvp79xGBT6pyUbc1VE+XfoOAOFgzXZndsAH8OTRtbeymogKXhzbI1+Wmdura/VfF5SYn16nrUMfoL0Iv/30edXZ7MKlhPLML50Ws+BkfS49GJMHjUXbVisPMDale/j+fuVNEtRok/fjWPgDdQxTIAqLHt1Wq0cHLSjxF8ewZlb/bfB2t+6jSA8gv6NAkUJYp+9ZCaCdZNc5O5DP+1HmOONDn+lTEsjurIYAK4KFxRRwbZrNPD3Ig4IiqhEGmMiS0GxJNhgxmabkCUnkYU0af9ifuItQ38duiI+e65beWQhz67AjFolIG9Pt0isGj8oANB2Bmwy1oQMDNy8sfwjHJkVQh6lNGgSrRoJT/yzlbU6LPOpyDhABntTMTb1VVrJQjf+r2Tg1MS5CQ4BAcedR3lcHx1I3UX2K84CkzOMPunFZPe8c1s/0omKYaa6HlTfeIul1W4F8KuXbtrL7YJjE/BSQ5PT1jSrG0wB5LRlsPVfilxQ5LMfJTKtg6esH+NTYgwISHORjiZFUtv2HjMEopolLg91djUIEanRg2eF56ly0hdDz2gipvcoauyHo7lhpd8mrb3ODt/yuA0EKwN2rEc4+Zp7pCmPj0RIlO0RcnFv7C/tz8v4paAeFGDREnSCCvCyMfCNClw+F/+lszvk8qlPTOZkmHawnZ6Yxs7/gfgSn6f8SvJFjEkjHedHwaOVAJ5gs4cKuzmmCeYH9rWW/vDs2/r6ZSjAAwSe9qQPQCAacBcOzHgCy8+3ZtrqxYI0D311U79O6z7ou4Q62/c7aqjYEkcNe8BuqowIVzC95YJ7yQ/cgOrDqLWa1xf7/Ow8bV4wjXyxNQO59LpTg9ZhYMDy31gB/rEKmP97NW64aZmxxIp960uqiEiZ/dslR9F45EAzYF2ECiers+U5pPnKjRv2mpS3I6XMlZ0S/gDfn4KiRd1CekRMSihbDH+qPzw1GovB/I3LpjEn/5vrZtWdnBwkzGR+Q6RCMmOTKNpECL1IVuqLdVLZtyjqg3deO9fFWCynLpvn/waXS53EmoigBE5109dYMVlOhFDgqRK69hymj5eZGB8Jn1vnZrOcLAyinNK4nrnVfQaugqCrAZZaNNM/RqZ82ufs7vehyJrJd9nnhHSS3UC4Yx9q8a5hEHAIn6PWLQRaNIp/HsMoIw8+s7rpNgyahfePv9ATcoPskE5zSNjMbL/W2T7WcU3iOHjoOSlWqKKD9ylHHxIpiJVxT7EsVHF7ChM2XPnPCmUwVEYUdPB25cf0lZXgWC0wl7lxV0nJ+h84XY7ziWrdEKhPoak3LTjj1W9fuzWXuBjvE3hio9rUOUiCJu5uOanOwMTtzXrNA+ytPqEMnahRUaRgS5R4ffsuWpky/5jAkHXGCGDHpk0Z+48wiYZhljJs2AJ7EJcgRoL3DYVSLOsEzOfnyNRN8jJHwJErtpmWjo+/qWoCBtVAo3v28c1wDv4nhAYwIcSgzk/V34YS/L3wUJg9XSdtibTQzPY3ip+W7uD6plba63E6Iniwf5RYUWm3XDmVEmh2xpDKcRFkerfJnGn9yRh9L6I74mBqiJtoa10dOrcYTbUIIK7+K4/90gNvzZsg0VXuTzoKLVuVr4sBbUgG3bFIBbcB1EvC7gfbAGGW/WGlECsxjTUy0P4OFS31RWUDmBeuDr1AinQR8Qb9vMMV0WnFA2bA9eWI8SApB+OeeOp9gz+gYRAInn6YC4zJoamfk28B7MyZonzij4KMicfbd+Ql+JkrIWrkUf4tWbvryFgCcVi1o+gqqtoxfhoU9fYuWfTXMV2Ylk9m4QXP+poNERy0TjoFNwD2QaUNN/0UqL5djAxtjS7ahc/hWWAjQaATXfnBBTPYdGGXQybiocNgMAXKQxuq4d+Vzg6Whgfd9B41pGlv7DZ0FqRNOZ44e8NrY1+yoSmg+H0b11DIZ6nEXstoOMaqB3dlpwUHqdAxKvWdV+IW292ioJ96T/nISQMAcxEWbKrety7+liXaUJbZ/P4RQGaKtOHAeGk4cfsFGogMH8vqhce2PYQbvXWQWlLuea3AbEDQFCym5aiWK2PnwklZREJgmgXT6diHpBY3SfLxnliWBCL8J82F5EA7JqXv6jNNXskcEMDSBrRvzZEK2kSrC9IiTx4n9peiKKgDasd4y0Z7N6qo0bkb3+vRTuAik30z9w58qK0AN0X93o0pCHLdkHI/lPFrRKvDTUT1P9rsn7WXofsEDFLkE9eu6bvum9Opm1m3sJyXtgoazmx8nZwJcKVDCLpUhuVcTNuix2GA3syFABlojTr9uROjZjRXGtUTh5lf95N9S4kfcUDFfFnuy6xW6qYvomYyO8yMgO47ynU5Zbi0NU0RX6wAP9rfGVSo9BbwJm/y0d87Gl4yPGz/JBUD8X2kvptr8wLndS6HsWUO+1MTPuxcA8pntx4vXJRyaq4nk9kIzr16C8qjyBnoAw46H1EARbAWNnFuMUdX37aLCWP5dRK3TjCV1KknwWTbiiRZOtuL+Em/HCu7wGTpFJpvkRIJMRqk6MJiVkocd5e9We60o5aBv8ZOC3Q0FaEdBH1num4roagVpaUnnz40gyiYeLyGDudSZgHA3xJ+8XpEHScEmYez3vCAPE5EHKRu3Cv26GA5pGroqf6SfpLeekwkUa0V8aJc4KphZ9fhQRGTCoubsDBAXNi0kX7C7t8LOoWaMNWs3G7UXgnqnMtd7ONx1Mmkhok2aA7ZeGjKMeKuDXzzz6So9Q5hddIy4qBCb5zOAWjaJ8Jlyd4NrlrsJWxKCaBK38lSCp2Fqh02pVm44E+c2P1fPz2stud85khvX1RccFPEcbvO4SX0mmkroPSiPtc54PkMYC1jd1alZ/dTl2DAiPONaSFSO2TYm0pzsTRqri9KbinQ1tgJFgWGbuZhoS79wprMV9eFty+xngQ7kqvdFqqf0pwtC9I+0Shq0HgXeZxP/1s4qXVr9OITC3DZjYlCdY90opkbO4VJFl7IisWgujYOjfofy+tu5ldfE/h0BUg6Q7YIy+JS16YUFtI+A0qvUkeFFf93zniN4GakjY88EzpTtWuqiX7nS5Th/3R/udg0vlD9hBUS97Zlfcc0gjI+GD/dLnCjSO//yFRwxwRifiO1AsRuyvGh2D/CaHZt67UjuzB0YlcDEGuh+hNXrk922X215muMyT2ILKHseHQEw32LOWYSzTtUzmczInIfKr+rQ6izdvNc5mrHNJ8OTR8u6PbtxJX9MQOT6GU9dIT/Bud+EcSY8b9gaZ2VKnDLFMN69VpuyRWtHv3v/b3M6qPCU2c/NAHSb20yMG01zp1W8OMSnL8SrGf7Vt8aHMr0C8h4FhBty0J9X7z+MpA1rMOk6tpzATDfv0vOAsoJPZWVZY4IqyJhkb813MB1pjT28KpD8OUuM8SxwbjwXf0eehw6gIpvpUnY1L3zMfR/vGgVkrepGEAR+rgxbdia1XG8TMN3VYHxLfIrbPQkAAVvv3It2T+usnlvBjROPU+byzh/L5nu3TBZDHa85j7L06AsQRQFU2652zQ4eZgOQwj8Mxz5UngivmrtdGBLDli4d+ghsd1wxx4FYCAwathnMvmG6sLWyZS+PyvdaPzdN8u66CIqaoV2Wu6jsmaYOhhEorR6d3xfuQ+BJHV16vyxLyDmPgPnK8CVLwXsHTDsYTc70QSoefwotoosgFvhF1R8YOYDgaYrLXvcXLRREe8jJrN2PoH5sy6BPR0VbMW6CndsB0qw7IIva3rhwTE50D+9cvIvTpbtxY+zSIf5cpiUu1PHfuypYidpRUc0GEwUufKF+yK/dJY1kIYvyADAvTc5KzRQZHosnmscpqccfMKenHJMtNvD1qVxPPoPprMwFagsKXAwIPTLSC71k2zAdFahnx61xZ3lNXL1B6pf74JeWa2PUFjiDxGOWSHTx5mRdKGJXuAq9cljn/WhVL3niU0Ur6RRhYVJL+epUyNYWaF+JIkkc3REKOG/gPOOFXOLHVUptPdGpFaDsN8b5DzCjn/ZD8WiyBxTWv67jsSsswFhWMrIQ/LRmppzqD/1X378RRTM33Umk75ApWWMD5HAxAI40UWL7nJWR9YfzHJXIHwstTDtejR/61eAkHkU95MiV1ki0zasF+mBpdljmkWfHSm0km03L7f1HqlUHMZdGW9p4FQpHR4qCgqrCJy2ZpORLxHeMPtJ+qPnHc7EgOgu5VVbyEVp7eAjv5Xn9czrdoIongXkyEN/Q+c4cIQL5b4bw5LtSQHI0Oq9AK3vvWGonQ6ZD9Y8wBt5zMaeyvCuNBXT0ijrEHu+hc0y1yuvpQ1cQZn53LCeqCSb0LL6C8t6/l/FSfScWIoxgLMKmQWoJRITO2hNn17M9b7q9fuonKyztz3gg7DXmeEEcElSRTh97eRzNhRpcdA1wE/JMo5pBNl7Luw9UJKTupMkfMcgR2Y+YO6pQnRxYBuz3nzLTlSmkgGws4gdGvxuuaxLzHDHijQ2UoIglmGjQfBHGpCBc7clJ6IaodDHSV1TZZ1Ir+MkXfblSRcb0BWMucdvAFPhO7mw777fD5giMNpPDaqEhcY5wUkTw/tJkXTOibymgtw2/dKRcErrG/6oTy0S/dE3tNFMND6OIt7o9AKXDEkffQY9grvWk/exYOjF+wj/t38ATaQSVL89vSNR56fVMgOqdUbtQLolXBWMmMV2rURXxkFIYKs1P/xrMurVidIMyGVlBbwBuunqRlYEvWi5eAik254Cq2+2exQ1grSbVuSGXotHN/DgobrR282N1YZ89nAZPh4CZCPPTiARhfPeGhrYU7GJYzW6UD33BXJXkaqsqUSFPeiWCBeRv024tuBH0is/63AYMuMcXJcvb89qg/OHp/bXxG8MAalAWlMWk935h8ooRoCnKRq0YZtADECwvbo5HX2dsJZAowa0oKXIvllyE8ONZ+hv4myHQdsRadh6QqsazeGexX1ajc8QBsQDyBlnUOn8NeOAUyyelpozEOX1OeCOR6cdQzDCgZhNcaBzvcQ6RlDBy0CVdOOGG7zboufFwcUBgsGWglEqJp8TukQ29vCN14c11Xb9HuG1PCL7umd6jx3lSwykAoPT9/69VF1zGEqxk/3HKnRf8faVQ/D8bXClKRryb/j2TBsvxMDv8ZYKxyhv230WR8NhXZQSk6KHveOX+6LhMm3BDyk1XJulcFZtxX9Xdo+IfznTe4pK4hxDE23PDgoEGq4x5pFWNO8jvhpIoc5zO2mIiwTZzb3aPfJ37m1z174CzkfjxPD/nkq8tEaXYcNqEIBBMJLRKKLtgIMPvlMQ5OD1OrNisqlBH3ThV8Inmn8i1+hDj4wtV8CzRqnIyZY6A/ZdPL61bOl6bfHjTSNMYWTRkRtHgkavHAnDZsdSaaht5Llnhcc26AgRL6ZKntHhCMWapkkiibSyG9uji5J5mFwDxGcYjl/Otxz0bPsR8T6PQCseeXSBK/s9hyWbJ+G0ZsehbPaf0orLwerVLPu25agPXmJAKix6f61PRX6kxWCtN/T6DGfXbxRJ9OeMjMCmkhJKUxibZLYv5ftDNZHoqzaF3w1nsDQVbyoQQzoz6yyq/H035tw46BGvHXJbMl70L5wa1GneTXldVZBciucEeXQtfLgx7KOSLMMSFx3RCH1ixF0RjQOCIlkzAL6KT129byenjSoV+VSSyZXsT5d6iATnld/oJALe/d7Z/HEQVvn87imgSYtAQWUwcHfNIHHn34pbrlluR5zHWegsFAYDHiudzplf5tDO+ICTqmejhVTihFKs/n85xOmnecMtZ86b6t4Aw0EcRzXifFw3e1U7pjXCCqa4sUrLK42r8MuTEQ3f6n4/tXsJ4dzhV8GmtbGnpKA/6GNoELKKSFpI0yoYYtyBTn1IS85OZb2rDU0PJk+DdjZjYG17Xi+Y6rI9ciV4K5LPMqsx2rFnhmfhW2v57MjABA5qJQretzRXewPM2YbsQ/pSYxiV8NRp6YxTy7mkqH14Nz4ld9AnkKPWcmoomTohn86dwFn215W/eLfUYQ6e43oqolYpkNv4dyRzM1XQXpz2V82EVzVilImIFrWFFrYzrx4JQr+baGHAZoKKpbNd9FZpoHciv9VKqe8xJHx8ICFwTfFiI6JuGX0vd/x5Ait7L/z3Eoa2c74vy/jqFL2jvybSGqbNmjfEBYppeomwvNM7KWt/DbW30qsE/zYjBr0jrTq34jDAX1ugKa27UujbuYvoiK1BU0Eu0CF47OXRi4f8T0fwYxlSXKxAn2MGWvttH54pAcP4mjlHziCYbJATSEFBFqxPm+qzbXG/HB1vNi1oMCo3ZGM6L57vg6DNM36rfMddWISPHL4IokrLGx73ruWAVu2nSHjsvPDcEbH/by9z16jEHCpp3aMco/nXCia4KKCXymH22VI8JrNmU7EMNLKhwdsuQam7wjpC2KNHHI24KSMq4J26CTedi+jg28O3p797oDRXfiSnFBcmI7UaOTXHz/R3d1gSgS6vH6KoVUJrjRchPtLAkTJVRGk7NWA/xGz0B+yOcB0WnWRtCz+0e5Yrlx917QCllQr8/V1eK2li83fiN/7oOqstm+ZmnsJJaf+8t/fuiHsgocBlSNIxkCLIY8ie/ejbuWhUGYSOE0NZpHi94daPJi1jL8aD9ZnlEpXarQdoxgxbCa6RCX0pJfyBNe1gCxlsz4mL9JbvwQVafJeAXn7DXVfv/32CTnn0/6nBwdjda0BoUf/tVA+2hRYJ+6SzEryavWeu9jEdmNCAhXtrqF7gH2HXS8lVJCSoPb23tiwkryyynAk82na7qjZFLsf4s2ONMKvd1dkOKE7Rxyfw1Vb/ldgW4n7d0vEMTeVUa7B4kt8bOSrwx1zw2sAnh9iliGlaahJkFP23WVq9ca/dSi+ILqhpOilLcAN+cXH6O2ao9bEbhL3itTl8DCeUn+UcHPuj3xk52diMnjm1YOA9dH57vLuR6YTCMGexm2MGJEJnYhCfJXwfzFYTf2T1IBsXOMmgiUPxk7s9vA0vb/y5+RVfY7TWIa9nMsHpTZjXQ1Bcm+vB8MctJFULQ8S8drj6YdOTEYEpSBQ0+eGiptckRguGfaAAGNjHwY78jj2CzFlhJ5Fl6SHtaQqVlLrCatC+lUrE4UR9adocjcsQF3xqxRFC3VHVcFR6bmh2dERD8nrWJxkKgsyukFyDkTEQPazUpXMCHG7calZrP3b1w60CPbxnOFf75X/FvgjOYMabDRId3S4q9eGgIdbtXlQvQsaatL0DR04w5EDXe618n5EYRkbzon/8BRe8XNU4wW/5bDJj/wy8VVS5jPulZxit/+2xJ9oOYpa90z6jpGBgznPidHfBn0QvVAAtdzJT4AOAQsvLy7ciHzl/DLhUTUPHjbkNN51bqlT/qLcJdQ2rmLh3HRxLudeC1JGuaCoev9ZnAd0Lj+7PFx8b93pCtte/WKndoqpjjmZI8yE9SMEGO6wZ0mnA37j71aRcliJoLoHM7IF2HDGZAt7sKEOdvla6vmYxbBjFzClZvniGkBvro8Lq85GbUA+OlGthw1YlURPs+jPeeGdy18Ah27nWwSwMJAsaWlcYNYT2F+IKcSr0OX42fHGOW9TkHG/Scsq11DlTS1Cbs2a9aB8yPt6MZZOy7BY7a3KmluYdEWfLhhB0u2+L9XDkPz82+0zc5Xi4EVQhPMmz3ZkalZpz3F3Od5v+cX6y40olot9B8d/e3BKbWUDndqT5eu+bvv+RDyzkCvV0nLPcOk1w/S60zA04WG1xRhIn284CP29T6rWZpSXPb7JmqNQWr2TLIUMwWlI/DnQ+Q8u2F/wNtQ/pzAa2TgOrf23x6Wf2LXOMPIotv0SufsF0pWFC9SA1td9gGuixKEGKiFe108xtRcpuqDNEk3TCL5XiLlfIPmWgmVwFCs5eaXJiY9G3Dny1SGLH17GnYcbUox3ICtr0HRINvGmhc2/avAqIsk7bQwrorP9GY9C2mg6FTC3kg/ThB/I/+l7U3SMrHuSDnoDHpe1MVI2FAqwBYM9UuCFxu9ITqtKR++9CesaNahAZNIsyQUab3ohladzwPsqQbe75itPVloHrzeGRdiVEye2vCz7P9FkwepRzcWPv1xgGeI2FrA/7m1mf1cd13+t3jo+WYOSux7E75gpBomTNX2HKl63TVtCMbfBBEMTBNdeCQ4Rzme4YFf5ki1g0xlySBJLpjFnlRBH/SF5CTPljLnluCY0WXng4suSvFLvuBelKd70w+dbu1QCykTMAj5T9hkNb/QviqUzukpyBtjOb2s/rzgqIY1PhX0AerIb4+CjfR+F7NNb7MCzBO0mvs0O4siMonr819qeuPuM9R+ihmkBcj0L/ZlszcG1tXqTj+tvQsoaatScU8lu7e6YsqswHaj+j4/xHZ+APHT4N6dzZcAUPFnimu5LmkW4aPBSNx93uuARIXxWeIiSpp0lJ9IqF8inve1ydISDozPn4gpitijehknmybTfgtMacqDOSL38ftI83vaCONoVN72dR2daSPwVZylt7SsXWOxdyayicHOd2+71fQYcGHrImoiIBinKz3rQuqV68KaOkAdIE9goInbUyJcJBe3uTSfb+hG/ZAR2aKnCN1UiZJ7LzF4MsOOxJZh0XHzIjdaSXTbO3HeBmzKzp69BDMDZq242LmKlKsVw740/y+kY9dWxSOTaYfK6urMxkbvtQzYn76VVZacMhQWMh9ahnTecHN/AYARVFMEnO/EXQHBSVWW0OqMS0U9P+C69DLmGG2oR9TCoKG1COOOIt7yYNWZswLw1D9UnA4BfszsbLYTJiTMWR5zUx4by/HGxa0wtc4lZ/BxmCd40JBM9ZgKMG1Dx4smQrNhXW7CZZJbtPJ54mNzBJvKeUZtJ7H7Kja9+LyKgFWIyFR4BGtf/3GGBV/qgjrUnB6ykhc/2Oy8yHar/KXCKqR1uWxfcdq6yi6QL/aJi+OtmUPcNA8WgjSzUoq2LpWaFeXE1QyVLL+TmxP9YhETKmhdt2D3HtgmY/r8a1K2TdNB4hqIQ1W+hXKxATC6JgawZntsjD7DvbbvYjgDecK1qAbtIiAnDmzADfXk5jj/4bGfbq56Bf7bDgEkzCbwpOEBwKDTxX6X90QfSS9cOwRx9aRx6MrUm4zyVHT45woG0v9xA6sYaLMwMy3jhDnmsKZO6+HS7auNAFEB6xtNbLqJEmf33BuOOO0wbvmRuwkNTrTkZ0C0POMTi2rEw8vynPJm5GPcv84KxMlJoFmKMiRg1qnFj+maqr5DIejGNwdOpY+ROMtvAns441Ys4komzJkLLphJH/3L5O69uFAuxYHEz1ZMhoG4wijwTDAk17KnwyrO7EbLTtHPWCG7Xe62fgx/4Fza7fBq8XMWk19G8fHL+ZBAh6JJyUjMlRXrRAuVIasNCceaX8AD1lRYMYgi9yuqcfNfP2EycUQw9wcXOEVohbwczUrXmcSDPHy4si9zHed+4rRysRMpDw1ROOwK8TSlip+RiqmNViO6+ntDtmIYAsUTO/RkSHAW5aQJa6qUAJ1Xzfv5DwI0Kz/khBs7M4qFph3OScU7zcG9ik+mdHIOFtXfsFZS0oJvtQp1VrqzZus+hQXbSPWNb2WXsRme3RNc9h3DXUt73agbNI9mUqICTj/sbAn30z1HBOjqmi1sHWui1viQh5sJZdBXaQ1SzJNzZ3wzzaY6/DfRqqA9elxbNwe6Slexk8wdt9Zu48pKeEUL+VhWgVLYVrff+bKRJ073CcVVGsMjE5Pslmom6PX/vGObofZ635bMXdMazMlIBWYHE/IJuwpTSIia/R2GbmuKG7TRpnt60589hSw9kw3CDeZAoE7sEELuUYKYarubg1j5/w46javdCUJ1oRRlvZ0D/ZfGqRCpTdMTFJa7oRfuml1HCMyBl0s1dtXzBbroSpqd/82wgQ0ODxRzEC1pbfy15c3YyUB7+KpLwkj7IBVRbBhlztESsdqAczn9C53BEJjN8Riq2paGkieL/jL7W4blAa9iK8wkOabo0UCIeL74cAjrniGFYyhD4HomsojZOyvbCns+AINFXonMK+NzhOPgQvpeZ8VISRXHHIaM1LFO728t6/7sX/SbnYs7AX6btFUUFCLdZqQQgVFpxseb0fnbWj2M0h+iAU6MZCIWRgIrOZPAVTJGf0UQADQ382W4QkKTM1SomxejkcseOQJ9EbiPTV6zzOvM+0ZtHPcuZ8TaIygoi47nQhWB2Y2ajB/r/Jte0Ut8yb9rj7HQJAP6vZ9e2zqrRVld9tTq5wrUBhEHbxqU2Yt731UUNhJUxN3/0r3ZIqH7h1mfnhIZO6qIjpR911e1oqylPaLijTUb5lkL5urM0BEfAtNgjmIejF19rHsmPjZNmXka4XlBLPOppeQi0WGuSfZRYa0WLomdMrfu9TFcQ99pTct9FFrkWqPKT91lLD6UlroaAMy9l4N62Hkc8Nst4qlYmhuPgq4OTV5bbGy2z4xh+XcfVtrZ2j9BxP94Ypsd5u2KdVk9ggF0WxKzC1ZxhAud/l0P1V9qHk6WMp20YC9lq3QfPRrOeWmbZBRvWjLjYeBYSvD4yun2xDRNvNlDp5qgJDNnxb/UGViIgD9wNEhW8XkTlTE2Ag3u/EnW+cGaKYtqkUfegCekUh+mIDXS1POlE9p+zFTjYy4X7lURhiQHTpKzAM682djvAdNOpS+vDuZ6G8u+L7SEq3Jxhz5ft+ctuG3pfIpCWc4nAV6mD5Ex6+WURKmfRZpUhTG6+mD1AU6qzyaeNbjwLQ9AUCSqQ5n47STfhO9NsezSniECMHN+a8BbVzxqzfgKTqMv14cE+76npfEBNUVd1eZnyD5Pxzjhpj1r/IiRtlpjncxCA6osyNiEvAKIl+0YgH4JgdMvPIFokSn2AEyQ+YOw7VONHpPqNSrkUBy5HME5Z2/RwSi1FeVVebU6ZB7enVAyMz6Q9ywn+4bnYRw2lMJZ/e2ZrtwWz6WOfNs8Qi2VvbAu0Sn82Bwh+FZ5JYyyCv45w0/SHcDos4mhcvL+R0cMBdzyoX2xlm8KZxAvewNVUw/OrwTLXqJFgZyu/69NKeSqGXGO8r5NyV0bAJLxhMM0x6ZSSadtdGApZ6mWEZxp1TaVKrNwsl8CK1ww1Ht/b8RRkETRtvyxXx8gpyuMfwMNF3t8iNeOlwHPFvyN7rIml1kVc3ejPvWAxOPIE5rYaEvgackhLYuHEZXBTmt8Q4hw9+a9Inl15qwUECxDCqx/JGBlzte+B52yDIggmmRIQquR/rNwAPG/yNtVZNVKqAowt7GTF1guSCI8Yk1dDexk6byC5tT74A8WkB//cV2FNZFXw9yvJtgoR0eoeBGiKcPDseBCK57mpnxab9QYq++diAK/4VtszStd0J5wvZ/Z/q4XDfJNhs35uuBp9mtl6TkYzP7Uqu3TAe0Agba6NA9R1jT3SZXZCe0qJbDrUWmJVnRIYgeQ76Lczz/NjWyHPbCh89dQ4GT2AZ2AVnHgcLx+zTSsa8z6E2dJrbXWUMjtPqgRkKgF/sFcoHaGwsv4vBpe3GtpJtiNSK/EXM9fp8DUY6zDc+ewD9r27k0hbmKb80eA9RcdjCx3V9ITIDa7aR5QnDil9LV1LdO6QmgcVCRyXY3anL9AN4CCtrKTbyStAP40kUBRo+3VGM2W6D1W9eiojDLQ5YLrWghhCDtatmszUoStzDxN/u3erbTIxMnlgq7fD7vR5OQuQykj/omBjbTgyY6jRblAbBiluhd5ymZyuGzOqrvxgX2ESBD4ll4/a7FcRB/dec1wPczSV1GbTISU5m0kmxKbimE8R4EYHuZM+ba0osqwB+vEgUtat0355ozutMrl6GVCvaUOYiusSEGxWn3PeMlI8leUnUlbjlVJCuzLWtemb2qDGKvlxrB/u/PCe1lJfVBymv9d7FCFqPs/gRFX6YMSBTqaTKpbe81ZtMZU6m3qo0It66vSJRBcRc333jHBpDxdRgAyJUosbvnQ57PY4h9cA+cdYGQsdIzhUSGhaVzsOdHCJyNrQh4xWxpw3PCGhSVBzL9GYnCA5hqv+JkiE+RH4btZjT+h9t7vtio/o53KC0/rAupm4mFRc0nmHSgu8k0r8G5gzInnREGrZMBVZGb0l98b0g1hbNOnGrcQb3yo28U+JS1nsAFrnxsfnoFJanXhHyJR3Rhg4vZJvrmeIyuIU6CshJrbAKIE8HCdeARWWAt36mYGahGPUgkUt8DIb0jF7IdvV1VDjsm4NXs9JsNO/X/JAE4vrmSSZEM43oae6Ghk29XsBwNsXVUUcWRCHewwC4OzpZ4QWmZT146IxODQ/o/PqFSpEYZmQr6HTKs37pzB7gvKaoe0bDEROaJVGttppEbGoaOFbFef07vQGIeN1K2fe5hFQUrPuv39jgErbJ9wV+Ap7gfhXspS4RJDM3YQvkL54gmezlIGnAm//y0pSVsY0tzrpxRT3DF3MoPD00D1snMbwjacK6h7518YyOLJiYawts9+/ePcDKxY4JCKkjXFwsNlodwVxUtL6mJHF7u2TkkCBZ0fljvBYklnXw/8NW1UBTaJ+Xu2SUNfUO7RMWlcPENnRuCmiRHZhWqwwVg+Pe6AJIcqf1LFf2Cuqj0qm/NFY96YYdDrn/jBIvCNYB7dseQA62qXOyyNq67Fdy0PS9g7OdEcVwJcBYqlaR5lKY6ERh6edbWzjrgcXKgU7fQeSylT/2RfwF7zUuHt5JuBGCZuVMu+jvUSAb0kJKYk2qPBzXHWZro8htstAaFdz4cy0zn1Nkw0PqJ6FYv08999ktVcK6c2EzRsk0VEJ7HtsIuEiRFcIFBoygtTaXzi9ufkTVM5oK4Qb9L/k+0arL2HDGznOZcggPagvwy/BQ4nSMrY5DRxHAW9syXFdJ5rZkyf8Vhw0Pa7xImZM015DqE7tWj9iuGD9VmEkut0eCabKfT0lIXJWsFe0lHQKPn0mUUR3D2Qz+yOZzzKb/gfCzY5YlOsF+WMpNd26FmELVBYJczJPHfc/LlnFRIVsdzTJwtk4I0FQO5FCxOuBEzlDTCIjZ8AtSEQx2q3bS25hV/hqzVbCCFLinDAu2+UWUHKPmajk6xGwPobpPgODTRWx1vSzgha+W0UI1GIXVvkvLyufA29UwSKFsfVZGBmd/l89+7h/eIK5deI81k4A9RDGI08XXsdNbsCwfxToe/Lvke0YOPry67nl1LDVTlWztuMjN6ZvGWxq0z5z6KAi7lrAJrgnXBVX7r3z3/EzinavkpZaR2kV6ysFiwL+B9LJLWd74Lf17pQ0YccKVsOXDpeWy/xbDPlaPF2PmCfs0W/S/unzhXhxN3rcHUJfvVNCs0A2IcqeMIKr556/XGj+aSDWk1agj1tfD6pjUgYqTse1lIKuoImo9VEoR6rDet+YgDF5vH5xENBWr4VFVtsEnxX32QXNNyo18GcZXFQqdfrjuBuP/d8jPK1uDOX38pc0Q6/yUcj2O/hWSwDxE+G0dHLkaM5Hmm8Orow9nmVxwQbr539wJcyyU8uUd+Z1wZJn2sBZk6/2UhDFtr2vWOSforw8T340jXzWulaSQmBYB0Bn3W+ir4+kY3nKacbel1BMSBNQ93Vrqi4ZdUnROHv4JzgiSsSmItpPj+hTUXVxhETkgbfWmyTAvpi0UDiSzCIEvZWge1uUiLicwZJE3tNi3cKPdMk2Kj/BioR7A52d7l1J2n+Pv8IwKnOqy74JAfn1YEGqLUvsCRho45fPWfvnNnVXsM1YClG0OzJbL2B3heIFr8D0zbQ8fKrbaEjFf9SsrSPs7Ioz34yQyZsc2r+8zpLiUgQ51C0XkGDqrBGFGlpY9zUA1KTq0UCl+rYhqY1L4O/sZLxbca0vuI6Pr5b8hSPNiWLrj7EtJmwBaHUbntTigGPVTlPFx0DP9whHAB5XsZTNeIFQMsyXRy9/7z5uPevEZbjEKOp5UTMnp4uSdZcwi1ZVm77nZtIi1KZ6Mg7tR84FIO/ljyIxU2i6JaTpqLpO5ZoFZ5g26EF8a7D40a5PyswGrMYBnrEELZgWkUm5uLHpd08GgerIocAuFaOGjApWIOUkhfj7Iq770gt0QkV6R74fhJUQVWm7x21LFNeoTXtQdl4zqakkM9EkDyEW5xI8Ee7P6hpdFsSt1B9It00kJ3LOucP4dV67AEbSBlrV8Qzc0qxPyvl6/aTPnniproN2aKhbvkMAy1cIYyVarhXd0+wBPrs5OSbUBh7FcxxPpo9hF1wEhEuGaRZCUQfsykquW+tl5MoZc5WiZsyVUJ/inNey+fBbceLFKGWGgEg/HQm8yguCrGSWZiJyReQdwJP4+YhVT0xR6YpWVGYcUqOLGQ8PyvhwkU8jbfCW/eOXj+TSEWhen0eny6JEtEtr0Ax7YBkb6ucozMob4RUZkyOOA6i1L9suLKOtQuqavhucSwp6Fg6BwwfCgcc6L6C0zYqOhwgwmqWRyUWEtGRrXZ5HDBDBuurQlD7XYlG4OyO7I5uxz8rr1lwZ9rJ2P18KCRSs5w7VhjSXiMReqp9aFMyOFbkWs2sj5JHup3mOBwwOZydsIIcLBNiPQQWckflevlHciDowA+0VKkydPY275/ChsCBSGstpIFMgxPfq52HeoQrOTNYfQtedOZF5oKwhcov1uAWSI2tQhh8aYNldV1rkoIKiwrj6n4a9H2MrY9VZ5G9eYxcRyBwMocmzFCsSEHCWQyl+vLjKoP279snnKevpZg6d/3qPox/XB6JC/SUN490oR5Vde+pDssxtVIE4O6MWPn4Y6BzAJu0+vOFnAIA1DzYzK64Ki4zRQQdLkN2+bVAFBAvEMOPUygp2luxtjS40tTTQrr33z6ziGsX5jGR9l+eUO8e6RyI1qunVURjqhiDgxRDWBCnSGGbWAe5L9f3TxTi/u57CyJ24adK0myQYe7aaMzcBriuKlszmZUWKwLVDj41oeC0qUdzwIreXo+jil2/MYH8Y6eV7uIDCSsVtHN1yRjnkStb5b7SFZ8CNfSebyjZKAWo9FUhk89G3Lizipkj3csDTz3a8fu14l0eJCHpTdm3NjI0B0MswI9fTvyTnFZxPDSP0lpk6JUZ8A+VKXXwUNPTVEobPdohbt1+LC6sof0+Ts1rpXN8U0+Ol5it4WXEvQ7LeHiVtO9C+bDvEYiOnrxmVDQtMGVptBCZe5yxM6FVMgie/qpvNQHoq1zscJHAJNfOIkGv/RBJvUkawLes62oXKfFPXacI5nYi04UBUa9235VycVerd8unffPAsURiimuXx9ZbXsOgwbmZtncMHF5ZJtV6Y8/NCRi7mtz6obKZjQY3T13AOJWWuC+mNqfcqK+H/o64mBXne++A2sUSQMz0NFAGrTu/YPl/vW26Rzi6Rych92G3J7WrbqngVkTXFC7v42GoFW3Z7MgzCYGLXZzY4bdRNJKeFILRyZGoXdRzfHckbO0aLBDxyvIpADd68nnqAbxJmSncqiCR8B94SVlkbIUnWasxCO0NrCV+37vhJL2kl6LBc65XN0D3hNZEKFkXqjkk0NmOQoa/jEfgnz6T+EOOJ8SZ6U+uLPNes6L/QFD5tid6iM1Ay1RTUIOcxvzW9tYejRnrqSjiZp5OjHF1SOrrmqLhIq5X68ItdTJTanUxjolNDm8yQo9zrX2MbKreDv3YFV9VDud9YYg4oIvc4O0E+ifOxHqF4F64K7Ih7rYTZxO5Q98G+RWNopzK1vMepirqq8jIH9Sfvk4551j9H2KOaN2ff/cg0kQ1LBWGMi35fZ5cU8clfA7xXTBDF2rL7Gx1mBTpvYK8ckfptpJT1q+VCkeQ8HlvZUBaXYVv6Z6fHbA03WHMuENrtTtqsfQAdSqstztUHqJ6qREbcX3B+qQC2h9XmbfVOlL8Xggoqlvt+sh14CmEaLS5lzNhoZrYRJI+sQH3o92dDsRQQjXnYXEiHxXN1TYxUnH0KeDc6FcaYN5M+W+5sxRxwwjO3VfZODs0Wya+elB4JTvIFJakp3XCa/wtsvdt5HkucrkNyGbJ4ba6/kt10RYbRNlN4EoSL2HTu/5VsrYUxQfOGJb1WWTG7QLy2fJB5lWd+Vuoqw9GiMQVa37izBcBnRqm+qRyGwuOHLOBYTboS60AFiyP8pGTpzP2VHeUpucOg5tP65/YYVtrXwnefznx+wAxQRse+oEduP4NUkZbcDIzFmn3dWcjubNW4rVJznTrbG8CyYoU6XlHzvB99zEpRrBrmjKR5VzyEbIDz977eBTVPgm3RxaA5m/GqRbtfFZJQvHCpL4NhBu9a3jZNNuHacTcpZu62UKo6Pka1RnNTzmTqIzfMOAZgFjF4ui6uFI7miY3NNrW4TGlfM65EgCmx6MfoeHy1DBGlTRwMtm8V1HCci1g8d3ElIwpiLYqs/pQqsZH9MjK1HhQtpv9Qp5Ko41nVr8ha2yWn/qFcL6+ugK5f7jVIMgSbk27KsZe24T6OtZ0da92j2SPjkfe/RRA8oNd35hwnuk1VIkd3eL31iyAjCaXC8KhPPUVxUEep7MNYactC3WD8YBK8DevSA/HKUx/DZu2S3ieE9gcPIU9pyV7Vc+3yR+T1aT34fap0zoMVYzqwImfyM0TcGzW2XW9jsdzbS4CPNaq5YDxHItgKN9RM20TCtCqs9UaPR1Ko3oNQQyBoNlXN+JO9Rk/D+DBEkFSYAgnrIUkxlcTyitFntcjyp+hkH7jbi1eMC5E8oVn+9lGRm1VogqBE5IdJnIZgMQrc+/fxFDL0dScZVlVOY9KeqZIKC3/GhX/Hn608jFpdkQH+uEEg/1BCda8aajBZZWCPssCk7KnP9q27HWJS+2+7HQtmiiNUTMNPAGv4IkQHkwqdIt9+7F692Cw5DFMRFFKJr2shQeEhpz+qnzmvejOp1lZUm8aiKKm+P+cY0Anoe4OOmMnrh75xGHWrXksjTVvOZpJ9DdISkC7+Qq5tl7dmKoUvl/DstEsuMZhTZ2jNpbarh4vgCfueWlE2Rs7W2k/LY2sV2LQxtTW1VlCqAbvMYtdkzzhaKR0lDo1B51jxO+ptluurtyGjylKK/DO/egMdr7Wi/CcVD24rdb28ypBkTVzuP1YOY0PyALe+VB18SSojZdRi+jk6g/fyQ3sFEtSOOq0M3mlMz4BVqT4t7+agh6abYstB2S8CR1DnfEi0grclDhQEL9DhHFhtwV00wu8c7noSljzpl7UNIe+rezT8o6YO4/1vb1FMhsvKlzJ33MFq9/X0/DkGNBJ2VKxVgOGyJaS5L6xd7o+3JPq4QPAKh4GTapNCbVHEqok6RqIOFQBiyFW8+HqaoLqcOTZvG/4YAfQzJGrOzfGcI892ovCrub/1hUNYs8N4NgZDg7qTRv8k/ndJA8W7EqMnjfnfr13pWyUMnR/DAZEZRz3+wmaUrlmkgMLJ5Q3N5D7+kMZV/jB53iHv28Kp8Rd/kf87fPbtU98E5TU1juz1zqIYjacE9S65rKWWlQ3iJzwfv6dLRnJ1uhgMnU7kQDaXgHsw90TSRN6GuOo3+gtJE2jiDukpJoMyBMXB2rpUT1Dk/GUPO7POEA8Mrkb+SwO0fm3xTssyfF9f+kyfmsLBrWi9huc3ugyeJpfk/n7tH/g/fevIM6t4XAl/sxlKs0CyiLxoeC1DdP+ysJns0XzDydJy6llJnF+5sWYK0L3yXvnrrlIv0jcpa2VSUwKH0igxKkN7fDUEtHfwx9dOVhM2D+5pmS5CFJGnyPy0KIowzLxlntJZGDhbg8y5TSe9TcBRshQW+QJFHJ6S52tV2Vrf5QCUTHMxMc8me+Xb/BFzBlgAfcwmW3XxVKxGjtQR+rOqGcqFL3hW4Ub0fn5R2+3JP6rrc34VKWmYfM7OtD9l3TlLnIpIAiTYhL7ACA0NvaGsrHsUgh+zoyi25Eti6Zj8V1RviW4yCjA2si4GSK9eYa8cMIra/c5dG2uUgYBrklRRQNo6ZDpCYQ82E9DA54PxPp/YBhLD8hAR9iIxB54e5uGCoMJrQtPE/FZGoifSuE3EBDno37Q3TOqh4l3KpKHCIJg6m4kM2tVJ0ndH6/IwpAo6Yke1redMRRc793py9rsvqpOk1Da+3n8pxBB70CKo1Ear4yp2WiNaZ3Jl5g8crvFSfM22FSiBG+w8LbvnGNw00pwCUgnDp++9ipQpaTiLnvhTpEMidB9Pfu1/NlJGfIX1fpuanXqWUmc4YeS3cGQPiksXfYc4y45tttAUt1qu/Slv7l9CWpXXHrVOOU6jXKmFoQF6YbHWuzjPk1pPcsxrW8+9NZnPvgna9CTsafn3sk1RHSDE/Rftw2O04M5/m7TVq0c9Y//1SiKz6shQx4Fi3hbgY7BCLOioJL+tmR/sPuWHf7Q1XHSDi12HayD3XJrFMbx4O4QJDNWaZb0vr5sLDWESl69WWwN5IVrFTLV61vt03ZZ7C77gmX2UbEuUTdBGv7wcphvTnWPxT5R6FQTqqKbLyq3PSzpiuqmOFdL4HoPBayzQNfio/N/3iLJbsXPmuCvJs/vsEIUQmov2TblXS3rLGWC0/TkcnJJ+39w0X5XMwiGCn8rhIHUGOdnt+PYVRxxvqns/YEtZ03A8hb5QK8AH+ERY+ajuRrlfVGYaA6x+C/mP06Wni6RRN/vhwBOE7dGgAIkxaXx/9rRM+py2tay91pkccFsvlYuDdZCtr5DTrus8LCWA2RMI0KDT+5YxeNRfgsG4KYXWcxfcE21jLVH8yUmJB0QV83FFXxFH+TfqWvPgzWj1SQDVFQjtvJGb5Q3CMySgf+wwjmSKuhoUyCFwJ2JXIkO+xeihNp/ZVGQ9jnVV51ZArHDzZmf+KcD4adiRnOt9PCb8uUi7MNrUf0nleRt2S5pN6dsVWi136LcrczfI3ELJ/JL1eByEexigx2tWQjZ90UMqijDpEObebnY3CKqyDkbKpJ8H+xoxYy/nDjFZBkxszP0sX1Y6wcFdxtQMCybeGlM17WOaA5Q8iA8w1DD519OzvFyp4R0TZ6VFJMsNHFNKzH0MFpvtzToOmvfj092RXdIRjrGo9JNrJPimsxTT6RhDpEanKrnovpKsNxUDuC6+1qG+L0IrtzVYhFLGa6KII4X4saOy6Auay+2Sap5fCQq4P9MYoyTEV6priejvh2nAtYZwluzrrnQm4+vsEORfX7tCte5ydpKt68BB+TzOeQYAlMC3bFheSBy9lJx+dm/wwGg+BVOdClChFPamtpqN4J23Y5X6LWJf01OthCJ6zWy5rG6n+GkZ5vkgyIUhj+I2//+ZSgXZydvR06oDGWvf8mZ7nZ1pwHWMiAxwp/9Sis/zANeTPQZlfU6hW81MEQrHHYN/XABiZ+mdIeDXHpZsojVZPGyeGJ5iSKyJl6QEySEISOMLO6IEoKxq1eJrV5tIkXS/jW9xNJyvPQWtKvSL/KLt8G699mN6Gc1Yz3Qx0kjGO8w1CWJl0V22dzHG5eGHEyHRyR7gGbCIb38bnbn63lfA1YHPcMqmfQ4kqFUqCJxIPgzA5L2ehSOgMtJvbqI2as27oWYG8LH2fBcUVSsruV8Jk/7QcgC5CLQ6j/L70mAOdvja6/tEu7yQ4uFhOK5YydzF5/aIwPyH8NzQmRLrGsnuYDyd5vWKo1mQezYotH3BkjFpU06AMpB8eF069tYVQdoqeghp9+FKVMrLJndU7OB039EN5Qirab9wNKqCI660XN1tqHmhoSz240APPKt5Xcr/cDSRM/DxcB0CPIDzH6EnM423gZxVVCJ9CjIwn0HYPTjBhUk2fPyYXRXWfMFVwdnUq8s1biKD/zGsLGEIDynfQLKZgRYB45NK4T8Ubr3hj4Z+/hQFQhqjcj07RNFNliBMZBSwsunI7S5B3p1K2HhaFsaXXqAbnxBOR0JTAGMpoN+Uf09ShBQv2bKnES9ge6u0gf5lvQYYNLXO70XqqYiQQ+t/fNx5aPZAj4N2ZtNq8wOlKbe+IdBLFyvUyibzu/ZFHS9h46QDWEylwBqJc6V+D8IEmlrVJqVKR/UQqos3DLFMlWLy70+KQ39/dt+4WX2vTbxMGLMWPFa8SO0yWXRTsLI8mfJNofazowxatH8xVkOfR/xnGkEwKudLgvXWW39Z8W7UzDAoX6S1T1eeeh5fGeMxTYlVRWscjABeiBg6AUJecR95CmRA5fBGszieFl3/DjTsnrcJH7naOhTKqjqS3R9A2LVlEZ9vh9Q6wT0jag6FnJrF4jljspwtO29Zo6wqcK3nj5bt+M/xVCv+gLxeoTjvuck/hlw0WWUTzTfOXZ4h+ykJ2CnF9a281PXhNtl18LWORqlN6JUwIgQgoIjNfuPUA5lb8RHr9tCox3txmY3RQ9nVH2ll5oUP97tRQUKo08CuJpyJZzcIAPcunVxwSjjVsmdHz0jJELzRFSWmP81ApCwHlwUNAakyZsN65JF1NnakjR7QtfFS/NLGUuD7Q6hpdOnbFY4pnpEbn3HU2KVAAJdx/tYh6+2Qu1GJvZUQBoI1prc+kcDOE1E1t5Sl5dK+fOBl/lBKD2hCa67Hz2BkP6/h6vJmhkr0rurhvuBfA2w0NKIm4F31SV09QSv23PVAgHGcmIycqhDvFO+tTUqRtHK4EyoWrZ69JlGBLrMHG3bblpo/IVmTUTj/WyKzlByE+7Kd9kogbZiiNslWcuJxbJAAnvDRpKRbIaWGuzGxuxO8umkHajeKdoBcUDm/XdGMnM4v8R8/WwxUouyNOeofNHi74KK8qudTHtceIbBY3LAnyGCIB145RkcXVbqLslsGCWbXOJ1XVWmfbc5Wj1nV76p8yaC3JpYBwcsk2t3P2rPyvEuoplI8lTvexjlGymJj5glIGly1n92xPky4/Zbmj7FG4NYdw6E3KvJyF3S60QbcATW+SS4jhVAcQ2ABANqUSx8JvVDzrPbYdh9ZguBeWVk1MX3Y4W7Sj0g/jJiQom5+uaNWRSD1tx+E9ahbfxoGIYrS9S2n37kAOoInpxIrjBLNFD8MvnMTlMw8QzepegwG+xCZfQjpAYsvjlq0xTfdYfodQedBJE+PiqLyWLoQ6tMevt+4yDCZFqoNWhs+pxpTqgYRxwBveqiDerZylMdAI/GbVAhyWPMTTnhR9rh6TYSVHwfEqHnUgj2+wKK8TsWGiSFAyFp7jZliTM3RkVdDriwi/T9/Guy31pbfug9IG3alJbEPQ7tgJEqtoyWWQsIsVjM0bwjRvM/MNu79/oVWyDRfyGWDu/w56QeaIPFK4j0vSUFezWI+KbX0feOS27IxPeuBfHi2bOg4UT1MDOAggc+ZBd/OHos/Rtzqms4H5zmXqtC784kBQ6PDrMQdTQvtSnyyUySzfTb8O6Uo3TWD7uS/3YPzGzl+OKqD+Cx2qZu1m1992y1jTNWHPOr/nrLst5uz+Eu17cfI/L2Oe+/sB3uiELO7ScTHNveJdzSK5bLNmjcehiKubHZoRxmYJqxAj9JsLlT8B8f3WkaF7hQ40J8aFV2c7sgnpepb9H+1fSbzx200+CRBa5GsEsq+Ri9/t0XnuXx2uWPKAKKl59Av6AY052v0trQ8QRm7p3qUD90SdY7SKarASwM7u0zZCWle2otBYD3wXlrnDUos+H1RAfmjufKtLNvD43KK1TkoC+5CFjBZemNUKy9PC5Eju/ALUWSHfN+HI1CFZL5en7iMRPjjR4kqtRPW98ixQ4Q/Pz7qds2iIfcuK61m3MvhDyOcidPdKkUWStLV4jUMByJU7B0yG1plIDBd5eGDHCZuMI9I9Wk+XHjFNp2Vg2cyShs4MResIOcIBHco76tFm9GVsyQRwgE58R/ERIZ8TWh/+N00G9aIzAHsgpPvYyXFDFIW6ZMRbRtH55EzXZXeDv93/bxKyrESUiFkAHntgLE7bST64WxMqCPCZJpkoe49C3PnYTWTGnbPZ32nhW1lM8Nr/kl+K4rbiShEdrjPfeWIzS0U5VCEnvgzFlGuxfUrkbaTXGrM1nFe5mA3/Vy8fjrAHutTmR7N6Zwb66SMhy/sUjzQ7fXFtJyO6TaI8J47OvXhOULo7OMBjC19383NpLyI+lNzSr4cX9qzjzguoT8PLG0/JJwnjUqhJAH0WNie1rcwnu8MruDhH760yjlv32z9h3ZHSQV9ue8KsqLiNEetz0hLHBYvPDROb4lGAdcLrGAK7yRGYNTuPMWg/LgC9qQeOsSICPLGQC0PkUrEHkABgcgkvGPogEKZgr5wAcn14BcDlvqHyU5VYXFlXJ+DHXEfYp6o+LzzvuvEjaLtnkIsCoYKCXLr4ymxw9zcCrMxKsLE+e1fsjxciE6OPzu4Ev+xYeimvwipEdp30IRIFPuzUfez2TrjPwx6tJ9PMDigORNz0Na2VSiGJ9hRV8oceNm0yHrxmGEBJE/dCVl/uLtXl95w2wmYDmuPYG/MsYhTmWFMCCQG5AzLsPTf7yb6uOT3SmHqPR7mtvUid5Oy+nnJmaKc8Zf5n+n+kWySEyADyiXNZK4wlKUvGDS4S/7mPL2ST+VisG+sdMqz4NwZlZz09Is1BUna99YzHoJi7PheLHHHe4vbp5bxBUwuQEsKgPvC2Eq3/W4dtyhleciEGPhUhz0bE+tI1FUSHGbGAZRw+TC244CnOgp/7TQwbla658vaNkhKwKqSpdWRR4VSam0D0/guG30nmQt2Ybq5+IYs0qEHnFVUG48Bf2WVJoR8/bAWGOVgVu/fYPzjDlZceS2C+HYKbBVqugAPG3fjaIPKgAqcJef6lgvFT+lXmgvKzZd4gg7qGZxQF+8JxDAtN3P3GABjp61IIP5lWgY/kpnZ9VuG2kKcaRnnTb9IrqAYnzmfCvSjm3Jn00lpvOnrTexcdpPHs9f5VcQQQVmEUdc/scPyyUMElAThMzpFpeZuqxO5qfpgVGpRBXZqwrOSzV5V7pxN3sRA6jfO3ZxRlwFQHfW/gld+lBUGGAdnhWQyKvnJvPQnE8jsYZ+NksalM9CO3DfYrrE87kjOW/6d9xivzGKJieYRPBjyUbJVskp50ZKjPxXOZhLDi7XsVvcUJ7BX+3jfzIJk8Qy8jGt51QOuv+/FFJxwxu4GROERT6F5BwT7msD68/gJNgEWExgRANfrAPbWURNQi1kSqTDtlfOV/jQNEsP6B/Jh1+sA6v1C+1Qk95quRGTHpW862JavstVTCSnOeRuz1Of2pqs6xaZld/oI1aKHFJJZp5a0miPN3MTalATpZWHc4JWXjgZxLJ0aJ+4Ff3MwkJG1rAYZZ3bcX1Hu/tPDogXcBsZ0AUjZ/hCgrtNdY9WxkW3TVb15yYWZW839jFmEadCy+zSFRDug0qrzypdVI2LrE2MwlVqeKaeye7nR4/3kMiF+1cCK5Sh1PLV7GZbxv44rRJqGx5Jp9pcrgrQgLYAVh2E3w70wmTz8EI2XsMCOKqnuRQ5Et3Sg6s1lAhudOCbMapC4K56H1FZK++k3UF/lI34fEv3ibAWxRuNCs+Ov7QEro8554OHqGcYFOkus/Q8dH37Q1sdnEearMDRsWPYglueEmVRo3SUDUVlP/SPbbwLM3pprIvLC8J1TfcI6pYLig5Lw/89Wyfal89IXCf7SRDSdvLQj9Xjf4vaGfht4z/qbcC0oW0NJbF/RssjYkZ3Yjrmr+H8uPWp2qltXih0Ikk2feOVe5ve7xJ5pmDr5fnIcncDe0WIuBvAsCgeBPpVyxA9Sh7vba4aUXXCXhp4K/SVGHuEQcWpOq5jWUYvHlUe4VgPWKZXOdI/XbIt5WTSm+LXwYvB7VAg3x9tpbQwrmafWaF6DIMQjXIZgryjmvbWefPqyWK00juN7Nm+gpLBDn2WFjRj4g3X2UhOP1Ynu9UIifv3+gcw9oKasqMfuQwAkOlUFWu7rfX9ODAKbzJrRKpQvpTkVByy0RFD60kYDM/dBKQdET61zYb/eJRtrSL9cCeM/uHBfpfDl2e9FUV2a/sVW0zIF92EW33wagF5brkeswfI+TTbO/tN6lLMZYEmTM/1w2uorebJkewz5iEmbn+if7mrOWnehnaQeTDW7D3fbFlMLu9ZvaEtwWJvAPw8CBq+/9HBPpLM0ESflY3e56ifxCSspNk0byVSVSvJQk65setkHqRR/r+LB65tlP6Ob5UoTQgRXbNk0AteSZoJ5b8OnrFZdNPFPRrAdrN2g1Glel6+qpTc3/wp+hMN3bdPRYId4zHaQETjEEGsuk3F2SEzntq9ksUKsuoEnjfVh9MYHW4DWntOF2/6GjdZZFYzTd4PplZjxc75eaW6A2QwGAl8dMXvSQHaZ2MLGW0cto/3iKoUsm3bSGvzj6zbHXxyckDmKIWQmNkUPNCjcMzHGYvJWNBqAAPtROLchV9uTKXVwOCQqjnNjDdhl/1LyKkjWe35lLIiTJmxQncbgFQAHmxpj/gMi2WL3CTbsCpEsa2/fGmLSSyHRynFcxrvigkRqoRoe5OhloxLDxh3fC99UHsgEQs9x/bwbZkEpPFEVWV29BMSjrsx6EJomW9YwT/tD1EdxxHZeayff2MpO4nYi2dlyHTXBV8679I/bzICZJysPD4I2FOTifpO2lpsHl14tTugisN5U1g4bc5QhD08ku89aDYTVJZtnVdq0SOLD8ParMEXVszP60j40czJr/3gUR7mSzWSX2ME+6tDm7eoEOiHI3BEHBw71fmUO3wH7amCBZ4N+Q5LAepbLy2bwbB0P0MeSIwqp70WvcxK+o81NxfADGLxUQwZDzYa/lX7F9ezfTtSEppTUOrZMYe4gYfYHz+xYFrWaciO4M7iHkHFKPbP/hzs2JzlLqza/PdgVH5dkKLq6kE0m0p3tXheDZes6q4YzBcEvEf4IfVIGMybI2PdMwpLo5bvaztIHP4FMXcG45XEll+4wY5dv1MfklhqWGwkyYE2NcCK2yZGjm/nobcI1TDJGqtTlMd9wEL5nFZp12wd+ACatGJz2umkiXywEk7bv5ZLCjs057VXWDCS7U10rQuthD47xuhIEDRIZRDpSr6XuosrNSXnaTh5Gt40WPHqKF8HoWMWihrJoYu6jwrI61VVeOT7ACFowfuLm0QYnydGuplQc1GSXEKEWm3vtuu4MChI0SeBcKRGz1h+RUatDYUCcq1V4D3SMzAAEZ+dwKur1aSJkva2RkWkywUYryXAOx0jj3xyLQiKKsEyLrqmjMvWIYFSE3LMU85LJY8r++gW9xJ/q/D5IETA4v6iXHVoa1S3bpVFiL5STD/JjKUu0yOtV0Yw3cH2XlC04JvVCm4HKge0M7g82naRYv6Ccun1QRll6hxley+fSsoN92e9tC68gO006WLrJXp6Ts5hgEwMI1oQ5COFn8JT4eGZsfjVs8ZyjZdCKtxKCCWBYs35d/PSp5CYrBiQuYNfym5Q2+dYDQA/buWdrBLQMOEuiiKoVKpl4AG0IcQlfBEIG96T56vXCk5zk1dUw5YGOtvN0YBOvow/UxYluUM93crWRNzKgcR6UGf/O56eLh7277B/QDNB6ntIOuvNxUozpqa4gPuqkwXF0KqQGlMJB5nAnVgMKL7mKORdysKQ+7XiN0QOARR2/iGGYvnXYUMPFFosvHQPN2UEzYMab1zZNF99k66pvAhE3dVLJBCdBQFDz0VFw0s5Z1hx30bgJ7yQyKSMwX01u39myE0CKcpC+M3vnq9NAEvZ5by7CZSE2DDQfq9LLMDMxpa7QfaRpbRCGgzI6x36aR9cCFO6BxCjXw+OPTmhbkwey0wqRXYx26XeFJSvJvpWBkQCr/freoDbf58v92x1tdGMqvi9isTUwXIAvz1sRGQwSW3fZleYcW78pDCcotD1Y9uHv7gwNfFwvFj1UBhqccRkVBqWX0LnogahAjkDsRtB6FRYPOoTkHutZTiVQmWLZIAm3zavo65AfCJTztsz2X20lsyPycmjOAhSo4cEts7y1qaYQ+kWzgEI4LLNniwdSvwqvuM8r31gyaoyt8S6uy2lVcq+OFhLqRsF2z2RdH2zzQ1R2xS8gB7+9FIu3uy7SITncpq5D8m4jLI2VhwFcmtPcgjJhk90Tzn4eFXcvn6z0+ZC+OPS01udqJf1SxjpJWnueVtAZrwEp+xTzS8JmXdjUPE234uQQT6BeYtVlIR+k3txD7TMEuCBfqhcf+KFqfGGO2VP99d1gpR3kWLDdm5v+nH9wJZSk0YmqsTS4187hJ0LTXYG63YhSrWOCdCugATV2JhVo1+KuqdMifwAuMtYn8B8ra3DZcCyYapEmQq0B7GJARRkhyoRhPDQBeqLkOGxqJJUZedpXS0tzNfZTkCPamrpAZ51dHGC6J2wX5BDProTmTU/QLqEo2GyLT4YlxkpPAbzHb5HFNTwtbJpY70iZf6nAnDUNJgT1nsfpenapqhtWPJNSqut9UqZn/cVsgBEe031pa/edfzpn3nROdUFJTo5GrYj5QOUBklzUSWqPqcCxF1e1o8awU+oyLzTUP13E9KHgfgLhpPLvbysJMRmFGj15PIxA8gwLwSn9vApE2BudVN/JV0o1q4ii7tX3b7I5njSPBCgDq4m/iLHoeXP4RTgCdY/wskD7TsunPOC/uvQCE6uqXJDcu6VN17RWG5JND18IeMWVPj28CE+03A3Vk7w/Ljx0lDTsfrdKYNGZCDuWAh/ERpgVRLIJ/XY/HiEjgm9kEd6tTQFmqnvkhiyImhqPeXGgfBuRqhg8R5Zm1+cLol3A6lb3OzwvF+AQdLljYereonVh/9T99CdlegxRxGBDJInm5HaL6lP4CDA5f3ZrrC/MgRvC3jZYUR8maBAaJXRoeSxwfvYTRnrVvGQOl9P+RtD7S4z/h5NnA+wZIxcil9o8Yf1UTfkHka3x1IRhZP+9IuRRt5NcAFXl7eWXiwYLZETtur8Oxp+nTYWHIVuAH1sGYqGtG9pOVHZfBjqR85VAD+a+Opa0CLz9W1cLCwh1zLDkq308NeI8NW7pyVzYlNF9j8ZwlOqpFTo2RW3QpAiyUOmCJJ9v+R9l3LpvVpqlIUHtFxVhY+1+ghq5iQRGylUEz2yxML7328Rjp/exw9p4Xla/LoZvdGIOrYiETgKnU4pJL5OpVRZOvRIwOP7X1WN4Wtk+LFnHoaxAreqj5DSSVHf3dpf/9NTAM6XT14icIB5ymytkJOLxxzJPnbmTH3yKFAGivfZYEDzzjOcaoChgtMvGXzbSlez8wedaMPcGnovzunl5zoEBf/T9UbPxuZQ/5rFCnmLK+gV/KFVkVmrCpYGrtbL2gHkUs4760kcQw952zFa68ENNo9kYE7QTobAP+QcSaiHauTpK5Km/qSwfDg46S97wR85T8DJeOnhjCj6ao7no+Wtt3FQ3en1Iv5CwY7TXITemvOfAMRKtzuKDVh0qKcx5kOGLCW5YyrN9Y5+5JcA2S/r04k68u2gn8XB3sMKYTOPW4j03JDKwe/OaiPCAooxnM+KSsYw3DZDyEKEPTlyjlFk1ymtPw9gNLHtsfGupdxNOakkW31AfZTD0E8tVonj2eIltO7IBI1wL5EDTwntBT0B4BuyzmJnULitY16qp3xcnNf5hN6XUSJ+NXbVfw1aNgF9yldnmf1B+8aoL0/btlxpyZo9ALfCLsdz7PFeVhIXNnBSASOddg9P19ISOFpnyWwvnT5IhBtyFyFrVy/uluQW1WXp8U7WQtDcru0FVo8jHreIWeKBal6p4BLissCiuUaVk/NLLG6eyxbAZtBQK+rFJRRZvk6nyl4cueSAuyT6VAsMnZHF0A+xkcuW6TqEzBLyII9v1v/ji73VlA7wbbalFNifKDis0jnKr7/Y3XOr78sEssSpPxO3NPRZ3Q2K5j7ISsXTqVdOahIJeB2WWkATMh/R4/MlVw24Y1Zl4S2IKA6NJslWsHktP3Ky37K0pqs4gClpwFW6h0oq8etuF/2RfUFCfTyT4UmeBjqPAkx7A4Q8TOtv05DOTK3pXcyAfPabOaXyVcBp1zsNAsVU1Sxuy4F6tpoQBMJNR315ZC4UeD9WWKr4IO3I0ch0G+U9lwmggDQrG5PcAE1sAvUqjv7OSjzIMPve1esn2QSsggV1Bmf5eFmntJ928gLuGI8g/pGwPG6i+n9gCOMgvHP05IHw6aTtusVXtNLwoIq/nFGmVq+505AmSW7YVu9Yo4CUuPD+x+MaKxDyGfzw/JcASot1YPa/im+JGcN+Gz3HYuJY7/Ru0mEb5uupFmPNCoxvkjFRCPOdARIdo+dcb/bC1YnxJMkjZgDPm6Uhl7raO6UigGrgVY50ubwU6bLSA9NBQIJ0ymE7DBB7UW/3GSPLaFU834GPI3KbKQOIfKNUDisRdvrVuhwMv66IPRgnP/tSu24blg2vvahhEm/C/1ioqAPSX0sKGfE+j0es2hodXTn7ljSsbnLlj9N2DcO9JglS8JGPOI5UumG9T7NaP8eJ/oMLQGSEGGzNFH5ePcnWrv6/VEqjXo3jzNXt5G8K1ZRvab67AWXj7a2eHTpD4UZthQ8NM9PLC4Nij1CKLSPCKAHcZJU1KpTyzg4jYGAZbrogb3dEHh1HBhYo6Bx0OFO02kN1sv4By9xcT9v3+YCLoPpVEXblBiX/UIUmhmMxZjGcspmGbMB/9lCbU3ooqWhHgdqhogbwxbPmthoXe5RsAP6SbAJMsINkHlYxHz/IveQHyLvQWxvAFvu2mwqiWxfU7eVgzZZWcECJuX61Cc5AKcTVpWtFinpZrnM36KIEMRyudAVPPKHJ+itnZ6yCJJsnQoiJBvhJ89c5OHsij6T01T0YrVIcPse/kxwr0JZK7hOCtTeEP8sbcdyMDn09iy/rC3sD2cA48CHazB0G0SBPJ2hmw5Weg/JqE8Y//PIGF/Wi4ibk50kFZ+Xar2+2KHoBw6gM9Zmp11ccEXLFU7sE9aZpOutL2m9DgokIQ2KAYsTzcIinP8EvdS8BfQGXtQg2V7uSMG8xFQSRQfD2rBDIU4YgZuLUdhaAgZdL3qU9aPge+4jMDJ+uuIbsenwAtcYJN1nfAVgcKUTwUhpxwge/AmeqWL1CLancxlEf6eoeXWcJ4e+2n12HHELFL3mHyea64aN1vo/8B85nMTz08CYcwpLLEhPybIA/QcLWz3/0shzHu4cWm8p5Y1QWVd4wuCibGJZNaBF1xXqOd1vp9zz/cN6NzSfka3VixPgm7SoNxVeWboAxUALMafkUl9+hEzPioLEPEgnSHsihTCvtz7/Mk0OIKGYpfp8Z4xMtefou3/kHN9fMHDzhohn9DGG+6cMFHhSHlKghefwMH6vHfjIPiDGMQtfG6QSHnWBASb61jY1fLN2GsGbC5gWc8lnt1PEYLCctR/U+xCKkZCRsM1kAzfc8f0KgbaWm0ofIZS0K9ZYqDgRNeCGJSrvFnsFuKu87BEyiHojZyjTHzLBO/fOaokwMqlx2GbUJJL2DXF1UoBkZxufPKr+34QpXpF3AVsKxMVKC7ddc1Sgmiin01taqVN2Z7dWo458Scm5+WNvL+y5ys+NOkWEl5++RUSWmMMQtjO/UPCftO8Ao5lzdrccsO6XUXkiQBBipHf1RAcfI72dFLaCqN+eiokRmmQEdfoC5TnSV1F+9ZBMheb405GDkCjDLJUgFl0sdTNpxdftlohZtrZlqz3PG1DbFFe2sNOeTR1DJjtXJca1yrF4N5vMsWSZ0q9Z6HkCWUNKE6sHi1ZpPCFPpatx7eNzP+kLRJy+o4ikx7XT6tGCSrZbVKthh5fRccnVhfa2vp0zoDRPkB8D5TqyYa3cGA0dhixWirp7k/JP16PB7pOmL3BLajjXcXib/QttusYgrW4FGh4VvEasfdY4UMjQOPvH8g8u2hwLpJrneQotmBpOO+H9uTL3PrMUTW56KDbCs1CiaE9OnVgeK8YmhWY3nWB4e3LIDIziMTRZXWX8uWAWlq7YWB36RnkFOktvc9E3qQx3JRv3Uovzttt370qkpmYXrF+QQrIK1uMnmue4msjAVTnJg/pNNrMnjfZ2FoKUHuraTZB1XtmVNHWJGwd+uMJSnF/eLvV0MIrFgG960irsuQz3fAwAhs+lfuPbs22OC2hhs91jIiydXWCpjTSalanlD+lFqhgRkoyXxW9pFa6gPKih6157ykMqJG2tzCQzS4xcPvg79ny4FWzGam+BngDIrBAZMdSbOPjQY2zua1Ni5y4H+e/RuJSKX70E8CCvFTX5lP6eULrSEuEvNGFLefm1fgsyYQIWj8w7/oRrTV1gu/tUX9QAy/LScTy6ThD3Bdq/BiAORXsSMcyC/aU/y5ULEMFBxknH7eQElkRM0yP4a2nM6Hgf6zlfbBGx+Qq69Z8YuiNezazgrtsfctZmt+/Qd7e3TVJYoR0iPYlVq44eklH2r36DpeVV7peDVlqaodo8XfQjav4wOBfcg69yugXIOQeaCTxxP6iRaKqlAyZOQwSu+FXChHhDFP2NavHnLqS3X5pKzvTY528ucqPTBDueuWVzlN1qkNRA9+5lZ8lfFycMm3QE2DwN9PIoJ4jNr7wLfd0+hWlk1LzZYXxAOpJDGLBCShMypqw+tlBycjx0FD2PT1Ac1fO3GEXlE14WTTfmOUUzLgOVHIPMR+W9NzsKvpKj/lzMTQBDiCrxEI7Gi7eKxpn57fnyI7b0Bluk6jVqpAYX4HHALdyTYzwHFKMWCP3+Bfe5C/hq/QQC67GAj4CtOHukV35CCRfH6nLY1ezWmQzqToWr38X61NMXhhM4akxCPDeR+rexhgCfW3PriG0puW5fY/u5jnTKRRayHfW2tozE8WyHF26e23/curvBgPPdtjWJsoJVh1soEQRYAlHfSfUYGh9mp1VNdrzvNvNoJrHhLpZimUw9KtnvmxjAaugECVVwULB4n2OTQC9Y/kNjXOU/PbvjFR/TZYkxg5hNHoA0p5UkDLigSuEukV8BMMrX9ibnIB4j4ymQ5XEDGHsX1sYLSY9EhJG75s2edEuKboCseotrKeX4fd5xsUe8o5HJdqu8nbHJIKjzOvvB8xTJoHjnLp/fw0woBlAidfE6mtjUm0CAtUzGWElfOXHCp0qHYBYK+ZZ8iADuC7m+8wUk+W6XE8CdcwKJ2CPLAvv/w60lZgQFpN/2CSrxAgXZUH0NDFn1Ma0w59yVE9JfSMv7fu8jgytIn6JNQwd17ouuJIqy2ex1ae5ghS2R9k60GUNnMXv/QC/1Gw2CAci4/ldtdFxQc5iW/t9E4VmaYN7CuE0abSAiWesEM9uPlAhMhWrmDrlnzeTeHVkx4Kd8yIpbstSicvJXHLp3m7jABWmeV9V+6F7zdSTrBG45cww9bnRsZvCQsOHm9GH9U9LiSDX34rP052nhU51DNURheb58xlufGdcHZ/otuIz3Z1rwNIlvEC1Yy2zYPb1/IdDLZawkiC/lILIFhMJISkCrX2SLR+48K9QsuB6xjrnB1FpzPgYimaVdUFZB4Vatn9iYQOGcyZGz10wmKcq/UXPltWF5uRbtuw24hvE9GvYXCNaQXhV4ULj36eg/Hm8WL6G685gPZfYutEHB2w1oQtAwrJfrmd6sBQadCcrDdarDf3a+l/8unvLpb8jtXOTJFbRX5Y1irNoHvtsQJryNcmD/xn/Jwl8oTqgDHQyEdaiQW8MPifdV0TJAkv48m9/a6kwgiOEugewgR81jiV9ZP4g90xWSvWxZ+yfDb2Aq/nsvtZZ/q0wr0PUMcJIdzdc+lraYSvvN9jdXFH+V76VOGP935lfnDLziyLftlKmCWNTWeFtBB8WyhBdH5F8Nnn7VTzPRjl6Xua6a7LHjNUzQf6/FU9W8yMNY6X3Zo+n2j1x6YulVqz+jkEJ55OZeZZVpu5fR9ipz4KNnoZlE4BS+Hs4+CldX2bL0aR9g7DHqxPpb49z94pPkEAX09Nl2y2ZOu7jObOpbfi+OjMoHmX4nJCMeTj9kMEKpj8b6OFKmEbn8+2hNY1iU9/FBaA/jtDqMe6Jw7Co+Cp2s4X48ysNcISrSYsyNxixlyLsiN10h8g7Kh2EoI79Pu1v/tBYlrFYhGKrMifLG5m2v3cB1pr/OdiDBPEqMQ89xI5CDQwDOFexIzxIFXJ5mPQgcpwy94JvaSVXqwwUY2yRQBUa7CIyPSOATqrAjuyVuZzbuG2IsA5n6iRZ6dX5CsNaVM8JjifdToLjAdPxgMh5mzHBPYl5/PmUiKqNZktN2aUw9rUOoXTa2/jvaxHjpUITJgsaEXA/B6yJjNi3/XdjRIaqZr3vXVisc2c9As1w9vpVICGI0m+c6phU5pGtwNgE6ixn76YsI1/f1yiAO7LWf+CY3kGgmeLO3f7Cdyx8bcI6TkUfoqLW3elzi5bFmrM4WX/RZw11W6c39vrkh0lrNyyhP0hvm31UPSgJPlvK1m10Xhv+yiX6/YJY1uX1IdIvBFPYf7sLjUBJZVmylI7gHhnc9Opa/pOcte2T2EEls79sc+i7GqnM0qO/l33uPrhKmayZHF3mJvbKQx/D97DmbD34BGrOZTcp2jkQymiinDU0szBuxxmJIcxXBL/Ktg3nMIIdIH1z6pkH4xF278GgbDXddsyF3OpEpUIaEv1qz5IzBCFv3SpC/zZ6t1Cx/XYk4cvOFfHeTgYlb+dWISwFG0KgPQ/4Nugxn7CPYxilyr7KcDivGiiNYNYjyphuwUzdvoi1/Dne+X0duBpnGTh3Q9MCFUgG9GQ9EeBqG37F+VB4D6KN+SXtyhKE+Ig/OaWedCki98q3blfuDwVjotBhdkMXH2ZJ0KUY2XbRRXCTFfAWSkt2+xIfT/ttDeZ9sE8SSOKzCj9x9PZuk/mDsxuMaaIRZDg3UcOWYwwx1JvraILwRlyuqeAolkaXMZIccwuAVYmbJUDbUMGjwG6fbg35jhQD1o6iOEOiwHHqqlxG76a5Sd8hSUPVf7Nw3saL3KrYZ8zaOHRn/IT7RJwvuSCIB6awMRjkvLqCV9sYIOq+X2psluNp5FgsR+FXrTNdtz37p3JShFta7K3+GAjfAcIU54SKzK6BxKIMq4j3gLGXscnIsdkfXgrJ9KZzsnxuGi4WiYPT0CMsOf9sBIkVOuumJRsNWrydQj2ljwUDd0+aeVNMKc1rZF3UKX/FsF+O8EodmrPCJcWGPXqKrKYqmx+t4uflc0uhsuikdjaVnD0f3c0nW0nyd9x20+XInlvtsnNtzPyKCfw6/TxyK3fb3KQbno63rvAszJBUpmzqE3z0u7KoLuKf/Wnd9YrAY5u9JH6ZLn8BwRCZDJMqzb5G92mxlnxwES+y2qT+pkyuZ3m+aQwPoKWhniog+BAKBWewcQziihllEVitq2WR3vK3Ih4mcfZVSbu5Dz3rzNQ02SL9RkkYZtYAvY4maCxYTfNn/EYoJPN0Pv47hcOMEFccg9u5egmDmc4+1rpjeRLTdA+tsvfw9INF6pYzKSf6fqXw4tBvSbZcKwB3jIOVEw8IdRuFWHKF/YRcsW4YOyFpYX7Ja9N7ZAf/GciOcx7wKMDwQTP5Ih7YKfqh2GauZ5OC6fRh0R8ifv+ar01WhmDYUujr3EnIQyxqrnukAXhiu+cs3RQ4ge3A5sEWdYqjKnV/3GBj5ECf6EMNPoyroCaS/YgNtLjNBuTFHE3GGqbDyEimXXB4RMLvxp7N3ad3hKBzzHAh2rRwlKz8UvKaXc57GO7wCtSGyoaZfFcA6Wp6kGdjm1MRVSqbPCSQRNZpWXlAzyXAUNzvI8wtUTj7skarcy43YUFgy3QWjiP7cli+PjJ3l8z2A24KzK7vjZ5pBtPWeIkSKrWHYGqRGsUiqfWY5LGPj1zUvaH5/LtKwPTU+8VIsaRLbN0FjlwCsmFeUJ/k3EMtApQ++7OCILEO5b6Z8u5TgQsf5Zv6Z3XaNsi/P/xuUUFd4qIbZCc9eDqhfksAVLNIFqPb3kznQdhmrZo7HMc/OMr55oJYXzTHbvoyvyrmAWguwTGCZXCeWVUaXwkalliJEeGGKT95qMIgu9SeJa5/eL0h/jks5+oAnXkZqHrhZS6wRAauG0LhI1SmmuosG1ZJ58rpGSVpsqdkm6bGswc8e2RuLone8RcclspOqI76pIciNFBJRnCw63yg79BwEV0xseTtHXus9+gVTEMkaOCizxbQVcSFv61V+NKW7bSyWXq3zBM6jzsLcWgCcdGsmIZo+NZrR62+ic36hOkNv948vIJKJGOcexUeDZw3R0oL6uEa10wWqqckmeqL+C43IHV37CoUvswshJ2HPNQ+Vg496Q3Ys830zFEn/fSt4YusACUHFIw9mM4HQQ8Pb+8Mhfc5KHVsAlTbs5lJDnM5HuseoyiYOzf+1vgVyNOrQWpmOrLwP4SI8a9umSYaa6EfQUaH3lfN4YgbNHX4+SJxGVCBlx9DJlm3MGmgm/XHMVkjsjPZHageRa61a2LRozY96EMpb3gL+QPvZn5BN4+WSdHSlEzhDL0+JJq1c9ZuHjhYZXKjeYs4YkhgQnpqkRqdpjlLHuvZ382VmNJ73rPb+FD95oBDmXBiYRlCdC+qJCb4FRNHKhnZnlclva+EdkA/2tqIeGKQ2YKaxsIjPLSKqhZB/0PAw3tKiaWFBSXYKj6plAkqibjo79sIrzWSHg7Z1T9ru0uwFyQyV//+nXM41zpxUZb79WicEUn7PCSx6+hRKUqd8pCMuXsDBdjfIMy9aHioW0W3VgH4zJ+PyusHx2z9LNlcxvEKnarwGESzjjCPpRwuP4unogpSbGP8F4zK9CIChxJOqQmLAuX4XHsEJWsQE3XED7hmn5en/UhWAVZkjRO1uBBuixUK+9W8aUa4ypRQ2G9WzhxOzf6zG4boZk2jiG0Oc2c1XV50kHw+C8367qtSaWH4SHLA6qv72plOKQ8XXJn/XwXBqeOKW4DeK+IIG/cs/eA+FlgA/QnOVnLk6L8EeZraCmb6UbLeusPA188XzT5QG4pEULxvBM+X2fIU8H1Q+K8r/BCr5PXfMznoKtsx+3ftM1K3zArygqdun+AcFQQy9A8wrXR25N+Z3DjCEUVVKg0EF4CHnV+ZqSzw1AoO9+AuaQjFX7VD0HWsuFhAjpRtc53owvxKmb52ihiBMZjnUm1UnUcTf1xjHU541/cxHuzd+vrXeP7cyVm0enpLq6eNn08qa2YILBM86hv9/N+xhJpCb9zY1kWrpz6cQORFIUHpwbYkHfXi4X6l9HwsNoyY8gQI70ZHkhIYC5CdJO+wR7ZR+UG9awEvvIn5NQ4rgmBTGRBh4WLHyPTPjJrjIrkcECeHUluZvUVr9gHHivwZZe5cZwppTQsQ/pzBjyU7JvbMj4mlEffRYoOA2zibvOystwgDlqM2d7UErGxNSSMnno5A/xfkSOsQAAkrXNTYIWT2P0uG30cXBw1/rtdoXRHwMU+1Jh+s+4ht+KTIHx1QsETkchu+Y7cBYQLUUr0BA3lON+Wseq9ACTSBustCn7SL8HP7KCtR5y+RsicTEdrsYBAr5644ma3Rr4jiKb2QKY1HMn5s8QvkK3iXnSlIKJW7GPWpy+F4nN2P3AQUKQA/d+HzwoAwn1dG+dHcBx2IFG2XwQ0Bfyn+8NEjVO6gtmktsyAX8ic2mFYfsvibX18NYZFssbWBmv76tJgsDwYN7vmPsLiNbgyqFt4QwVumWb+V7zpIcK/mNGFeEOG4I8uwd1+YLHqkVJ9p8uZLLMLXu8tbqQQMxSntHxFuQkQBC+v/eZdEZ0FpLB0iYIOu0zp8cIdGYmeqo8GE85wk0k9xVCOpFMmC7uCP1RddBDoSwonr8US4FeBTvVly/cG/nUN0zw6wlvQue3Vd/7x/RQeSj2YkgStaRXm2dtfNkXYlFSkM+9uYhRwy+1+E2ByFaKQMqo+mDnlpNXQAWIUfEqZgRsC5ilwtQefeuJxSqF7nM2Bl+2a7y7gm/x++9jydeR4f6fuuTPE/XGWa/yEe7j1pEhqHjHdv62NrMz8n3TfFIxumi9e1Seib7jpSkBljvmzZ5QbUdGga526lxVp7MbqUriHdX5mRm2jikcjxkpqp9ns6RpKrW8W4dq858WKBezqVHGt8AgC431RWjVIfFC0OZYKbdY34BdQJfxX3PliXy7pM26qrYD4u6wFkOBdhDjG8JWV2Evkz+MbtJcQhB82OzNwvHVGplw6Usmj2ivTiQz2f+642L8Yogl4nYZz2V+fctmpxzcWO5Gvk2QJTDpiKGZMjvjQxTuJWN2LLjMY8kF5RHMZmBboBCv29OyHBaa2iCjFwlgrzh26fQW/LCF0gAROrvpDAm/ISxD7Kh749HSqyMGe2Xc9daoZE3NUAM38nkqpzJ7sy75RhTe1IpP7ETVgYSh56WpEWZd7IG//BkL19wGERPjciztMchDIikRncjSzDQdLqGmj25PdFvunxW7y46RUY3A6JeAHw9jPS1ytgfh1WY0eZflD1Fzo9EMhVyHHwzjNJCGL/VantFkEy77OaTXngeI9jfYyBY/ptG6BOkQ4i5d7TPOBCqB2sHvEpWuMvRpIRtNj5ZK9iOShwH2eSjt9Od7jUod4GGIGjAxVJ8KJ8/spRLMg9vxdmh4Nm2CoY7hbbs06+h2LC+vZ011thHxmJOQPKADd+2L1Fhai2cAHUfyMeg6GlZVbC+skrviBCyqHIvciM4hqPNEMmJkvQRqEG5fXUl4/IORWffP2UaCnrgcCKTBsSQ79G2WP7jnVLEK3Zu4zeR6brC/nn564RzrTpl6sK9hmFujfxsXCJVVKLFvnCoXARJ0eETiCgu8hErcKRDprg2hAr8Z0fSgMMP49bcZ6bFfiI5l20LnD3TYzsnlkdrZ/b7/sr/gYJq3npprq6eodG4zshQXVRW7ehWBsi6tvJzwaP7O3W/woGpbI+E76zBtTpyQREquVNsXDcnLq4ZYw4QQTCqYXSQp3VlJwwGgsIA7EemGxdPufoTSlncUfD1o3smYbszYZ4EoVSuFNSpLOGCe7GUq9YGGa+l6jlhHmEQ8rQx0OotT3V5SFPI2WEPzauLPHqX1eN1G66B9gw2vX2oKDE/Ls+X13KDoQMWrnwDSlWm4HyqZiDhyKdO1jfkiQC63xao6OnlasarLdFuhbJ/B0BYYj3rpOCoyxZ27Cgcd3vOC75/BjqxjmVCJBDZsh6allPrCHffrfMfjM147gVq7G9mfiQ/mtlDw9YGwz347xGm4uq5mBFM0yaO7FWNBctHwxyHb8nkBVUIjwWm3iF3jT3fvX7qJowqnk9hDrsU7Yoee7iDbx5+xjRYwtW0z1Qajmg03kD8ZziXKMiqvH8qJ5GnJ+b50fTBwMFZjEQncHNFq3WbKzXjelNnTO1KKyHbvC7BruYhPsan8ZigKQu5BkN/6Nixsu6fznFEN6ciEynDyA8KuNeEW5iVSwxY8Ht7W+CIUEL6T4C6zUkVREQUQda1/jFncQDW8eDPt5epVpq2uemeWhKzZoJfnjtscnKMz3Roj1/2FDyzfL4QENMbVaFh5px06E+6vjPGT9qN5WL293+Tdv5DddTAlICUtF0+ikwLz57yYfZpvTm5X0hVeTUpch4tkW+QnN6bqOiur0GljTJOizLKPLFBVjAE5OGApws9+H0c6CFA6pmYwwoBmuIRNHqdtGrtEHpanCm/3ge2sAdB0cOyTWF7F3ad9SFui8vfMLJUgJN6gea9qGxcHEAV1iZAFY4vrZ8a04GjwmsU90HgfTkql/p3xqUFm+Ybl7dYoatEeHvbPlF55j1bQz/5AGqYae6hQUQM2sn9baudomWjMFd+A2k5z82JZX5eToc5+e9pQfU6L70iNWHiz8N5AuCMhmH4opLiUQ5NMkzvdehkt++bh2NveQCgMx1VgvAFHj/JWy9x1kqpSqsvdKdDcinn4Hb1PT7u44S4lusNmVzZImO8gTzORg9LkHJd8z7rJSMcNq7UUjCiIC7YTpdcYi8Ls4IhgCfsDGV/1RIKEpoC5pdWFRa6rTZQLeyue5gW3Y/4fkEoAlnVPgUEXKrTzOcHyCqywRwnSuO4vXw4nZqNnNfd5oZYOB0UByEH2upOkw3CHUWyP1yU8MZClw2Hwabj3nyv5DMPMXGJkb0Qws5dHbsedjA8UNkDEuL5nBiV8RHPgEXYK0bW38fTt7uYjZueZjvTXnzU4niczf1CqZTvADaatS8VzPYVi2gvPoHtmpBKyaYshZ+thdKF2vs10nbPkbcS03Nvx5bDnVvJ3ntPlWgicgHODPoPNjzMZ7xU0nbZh4w94cTjjKhMipO4ZBsa8VCnvYzeC965qreLzT7nZApCphO/bwr4qWywwygQ2uBqDOwNSm4vzjbYf61b4cCpXE+tzdfyBTbuOzOHCl5FnowRyAZQNhZzxSg6wIZFJgbMOAOpA+QIvZqgbQoO52RrDxEiIiJrJRZCdFxJeGYeh+NhIXyV1dg9rnZ3csSdwRPvzD4BmwLyqivX55ayTgfIWNt8FxTxDmbBvI6cxjKnirxoKe23E3mLIlde+bCX84yXugAswiE3xXnBrTwgrBIwWZUDqBeuKMKzdDFTESj8O7Yz2hvP9y8FZKoTC6C+mL0x0/4CpFLTnI8Ua5EMSPbHe6tZlXFp5YY/RVx2Q8sh8f1InBhES2oACNIoaRWDwb3pecRBV3oq8cSN1NgkeCyzFdr1ABLENX6DrdlsBJ6YSSucz+MpLAg1t7NYrFCMsaSAlWWm7wbxQNh11xFeDKQUFJtxGgAS8NQgzGWrdyOLDQkqZNK2nkbRUV35yjAN1yQFfhvj4eaZAKq49Oxl4KzRrYgw4oLAz/vFm5+I99GS5we8/KD+b+LR9kit3dqOimARRUIqpuF8zengfKjf4JDVJ3YFvlZWBolefNFKLgvwvu6k498Os1C205dh1gEnrjV3GBKgOI8pxGarCK8ND7PNaaWYmxPwWlni7g96rJsTu3wwjnJp/11z6SOeGLWI4EcNfqPJZuUNn8rY5YuizyOXZnlErW0amUhcj3d8RUL2S1uO/Qr7lz8It6PYUalZuHeZnKEUVo7llW4CstX21dgchoVTDWl4ib40YRylvNVEfStGws+2P6dcHnz1JXU/qN7GyYyV1JcmOBiMZlEub5+Bnko/cGrGBIeHKUf3y/A9z249ZlrP9qr4UdFvTMGCf+ohUvzRdg6FG99bjMqnqLHtXlI/eooZnxOYOsqbWyu5g1/EKojc2RvdmtF6f914dpfuEX1n0PYxOf90FwSJLE1rs0EyvdOnicxkHHoIjKGY27wezwwdhBCTLP6L1kSbGyMrJM5S9jbbzexs5WSJqgQDPJOWDfnyGGrmdvP3CXI4gs4LztvahFaFIW/AVZfkbEPWY02eKH1Rkf4HQ3rFmTXnARG6R5XCnlnabnhEVl823Xr4SxkjiebU0QF+4W0ur6/WCuxYrrw/9MHX/bHbe/cKlr5pIh+KjWUzDUBL4Du3ovXsGgx3tszUEHq7mu6k2XmJxm8fVXEfmT2acTtBXd/eJO0bHb9S9KSIy5Wp+SmirgqnicbPV1TRH88bA4gKAeFrV//kbAnI6NjA+xPCSxT+kPRf3ua972Zm3oMQT3xwnfvVYCQXAbooekWULfcpBLFhfA4DzE8mR4QcbliqUqW/0yxQa9kBIA9CDq1N5/S0qd8xWFu4dCSi5V/sKJX1HzTW+3Yjbg8+UtTd5Md8vCHUqBZbduYmCICBnoDBmsbafCn7EBBUcVbmMSET1vhF9nnb5DgFn/oO2wd27FNyRyAmivbIKT1qhftydYC4b4eui/rJxyrG9f7/hi58l6ILVUWA2HZWxvJ5cEMCzFoXX7NT8ueHtKzrHZCEIXa3pfbXhctqUxcBqi9WwO1Tb83ejL4BKyKvo6ZQ4NakpCUeLIlWX8AYh9uCJreT3B+Z2+sAq7Kcsnce5Xpfh6D+ASCiqd7vLjJ0fiiH+0fY49h4P/DYVrAvDUE+ikv0INWCLDPxO8nh0hZNAg5WQ6PDR903oMwYQX/GBzeDj/K8+BrqRvJAdbRSal419PSgZhVAnelsZNnoy4iJ5WvKq1rpgXTBA7m6EPcv6gk+/SlnGZIGinbZNZo3dNxwrh0xbE0AFwMFS1OokMv7k1lxWjBMelQk1c604LGuAPCdNUm7akP+f1H7lXQKzljnXe57IEjLo00nFvExCnARMmnE4bCLFrZ6eX9xHN0cbu8U+5ojpK3S30Tvr2z2J/kqpNAaAEqwDjuhISwLImV4UeOX64dxjCSojPbQNfhlpjOTEFFv+hRdDi5AppPsmGFJR8zEkJvjm8mSsCkbiuC6vUHOueQafMsx7c0anNkDi9iOSbDZRL3ZSWwYBUZpum006rcyQUudXEEbvP10dbU7vcjXn8NsIC2KJx48ENfECQrw5V7S4FwD6Pi8hlQLMZ7x9L4iA0458eUl0Bryhv2BpUmqOFcZO4nPF66e9aMg1RzCeGU12XInrZVgqFk4aJbQQycnYPLv1yldXvDKI3RWC8alciTX87iollE98af6UYgwMsq4qbTOe8iNmtFyNQQTUrIVlWE165yezwLGaJSeTnQ8cMUtIU9QfDmjE3cZuVaYq6le2SboWUwX9648DZGPsBjhCD/WNmKCvevQ7a1nvazifdcQz2rUxYbfUYwNaeNTPZsM2IaF5rpf+433dV1uajIkxhEYC0JcGSTu6G7BjCSAQ57jwYXQ2g2Raw1NaSAXnAVttYvEQu86ki1YD+obqpB+fFryCcRGBSBMqjM0rO6kTPHawxt4v3ZjEFWYNEGSUJhivspFP2VDB/YyvuONUw4axh+k5+GWxQmkdAi9fTy88PE+l26+STmjkpueO/kXIBk5vum9jBcK6rVRE6s4q2Lnl42yfX633tJQZbJAa/fWScRnkaNpPBmN6CWAoqN4uZsDQsy0dE685zrm1zy6yF1lyZXjJAsmZiO2SYCqaq9zmTxqgRlUtjASsw6BWiNrR/t5dsd1RrNRqB2v1My3L67Pwrbl0uZGpcaWtAAkQEI+LxTlwX+RWM1Qmkm1eh+nIcZ/6m2uAPjgB80LMDL4+kRb3Ro8BxWq+JKLuEGKi5CSS9m5+fTuLtcOm99+5s4P5RvdeeTg5yb3N56oTGtbtTs6TokL+dO43my3x3KUCXMsYuMbI/S3D278pKqHpT0a00V0+dUloBiIPMo9SzIuoWpitl+vZAf/9g5BJe7nhBdZTDYJHL1X8AuSar9uCQavrPeUTuTetea9GgF+q+yptAQ4kxcQvgq4j9ugWxq3Dc5Dx8CksUj/DxITfuxgZNEarqC/qbdW8JTLEHRiY0tflaYfF3BFZr8CNk2icdAHNLHZfnpwa299LYBGRyxHLdQlD+jYOs8b5GIQEdIfj2Ku0NJcUstb52ljDZ7ueTuipKgbLDIihQGp8wly94QFJgsXJxY8mtZDvUfM79D3NnD0EYsJZBuymz2cq6FDeGajMVo0+N1bWkB4RqeAeZWqaVjzpGNmDzj0jjorNCan4n9aYNlWT5J021e6mQgJPF+zhqWcNtIzkzBXPynM9XEL/TwUlLhDoaLTXR/NhDy5HJp9XxmYQCrZ0ciOxP+5TGoZU/zbeKLWUOT1zn9W0Qpaj23ldiOzJl61IvepOo4E9GiZImQgywxhmPn012XAq8UWizSvuBxdl1YqdCYf1D8mwL7AKLxsb3LptrYhC9rpnGjWinn4rrwqeZh3yYjj9RX8CZ7PpyqlfmrEm8z/HqhcF7RJmroxI0S1CsO7Z2zUoe4BogkcA7b9Ugi7SHjje7QUnU5J7cVzn3yceKFd1CIANbtO2TMevpkWrYgBhxtJ1DApvlfm/GgpGuGgFPca2Lxm9WcS2+DYasa6Hb03Ajd3x9IaI+AesYWPuJZ3Zw5T5Ho2/hS/tQiwC5QZJnQ2DId1Su4zn/0mJF0yyp6sMsZIakP9Wa8TpFnVRMz2XaJzsoMeX1vamHzv2VSVzHllR/hN8F7mjdWkxESkCkswZr52O3+SODq+Y9auYFY4Mu/gu87n/9IUvxoyHnZ588Skd6kzICNV9T8ymmhRTpRn+rnT2VpRowj/QiM8EokDLJSydlaZlChJY0xeRMYMZ4S3OZfeT5M0rzi0yCOTdELXlK+0WrYl1n2va3eBOyn6RsYYnOss9oQCQRg5SRds3/bmHPcZOrKWjbPJOTgUd3k0wQK9QtFr4jDmGHqvyeNvyR59B5zoeqLC5owJv+wJ9b6q6kLxXExobwsrxElO7n4CsYjNYNz6rdXT+dQjZmY6TcdHTKQBRxuG8PzYVLUyiIOi/NYV/H2AwOdGuqwDrvZ2l0MgIu77jB99YkOC5rItAoCCtpRZ1Q9AtytqMezH/mhMrRKPJWkQGkqF2oMYMwv5vlK1RU1wiAIhynBFZLis65tnmE3W7W/tjl/N8rgRcpY9Ch/dANpjsxKX1vjkmnwN9cd6tOP/tcjoY5k1z6Rx+r+BqzTcdObZ54wzpqFZVUSC1l8YratqDG6OJwVcPdSE52P0Ms1hwcdkUeOj6ol4l3C1TgmypfBWu0ZErBwqwkeuI/nzJ/P3MPkvJrH/tU5rLS4TlMJFnSsSkj1ZXoiCfb2PgUdEtm5M2jB+GWF/FpcPHm9Lk0PIx0xtaIWVOg96hMpNeIOqFJPw8wbHTQX/C5pabsC7Ay0k1Ybs/EhafpCz5bJrz3I8F1+Us2nYb4Z7QqJCCS8rzmLAYOBsaLIXFpuDmj4ayEuCCPsYaM4I/JbXEZKsg6WzhTFCLflWMK4q5bmPi5Gx0OsgD/2UUOVJpTbfGu1rZRplEx6pScbgrwk9RsWsNDySAejMB4G8XSMAp87KKXZXTtRm7swG+VSYKPlYjFNY08OOYfd/jM69og2T/qokVTOhIRjWq6HA3Ena0J+y2BGeP9f3g5SYa6YdNTDHKxgnr4uxCOol4aPMGtoJACTj2vVx4+9j0n5V2xj70c/xcSLCHcRfC+YwAdvg/pu837E1hkEHAmEYVZiSG3kc8kTmNpk/L2xLwYlJtRDUd7FZPKrjl+G2pui+gIEG2JnPtouAeXwkozD4+YPgKRlujdm4BYYXwXBdevpXVPaeSDMJFp1GJ6QtkGBxGfDFs6WwStNhjmYMOC/Z29CFw+aNAk4rG3yiMQHQYvHMaUrrAV2YsNCOJ9wBaYKOn1lzXaDciJJlTrAnNKxiJ8oHyG3BXP1GAguvPxvg5dJaNWnJfhslCzgd9ngAooVDXfDNwuSRcnjYkXgaKfFlsSc3QkrrPjQ1wS0WqvYXNPcRJGi2kvSEujj/K5GoO3AhZE3WE+6rgebjTm26p711e5ce3M43bz+zLgrdCXHKnTjTPsv3SS9t2G22+y1LV+0usBiGAIiuz3hSV7Qwutj5BSNV3XMDDWO1mbODyFAXM8/bbXVbD4XkOw3Xwvw1zJzMx/rXowaZWrN26hMhn327n4Q6Fhklj4OYQWETUHY0Vs97sYI6bV9vGZApicks07LcKvqn832v6Kpk296TrKLsHGJBSY7GGOff5tCNd8tWP3ZxTY5MBN2gdHE/c2WCwg+0fpqGofgBUBlw77NCFrcJp2FC42ch3JmWz7nUJUptxYl1ES7EOyvlklj96O+mxCcwfLijjZUnevseG4K7SdtlK1jkD2qPDKSntxBzuqX/27EGFA/T/ZvOw2vbgPVih+RVCVT1gT7SUQF62CtGiGtxFxeEBnIsR2LOLFSn59ikMREcLmaDpNy7oU5r3/zSGzV9TIFzyPCacL1tZhKddkTCaz7GY7JC8uuqoCuHGIwpbGFAg0qCCtSQHWpjifs6JWHkn5MdIxoGLMdXMCiKgsPOQURIu5aSJ97WN2be9gwkxNnIXXsONqkizj0LcLuRicZabP0Mgwmz341MouECynVnWRiTogd+XKvL3R/5aSzmcahCwNf07CVd9xRP4d/c3FmTv+2+rc4Pc3MkM87u33wBI7AZxlbrFOpEAAZh9a4fdPYPGphqv2DLVRJExXKhfIwqM/OGjq6QTGb+NMmmC6gnRG/RBI4m29FPVLM+6Em2uDFl3MfaRm19VVLA4BeE3EFTLLtKf/wv5NizI1Uy9bfE6wrFrSBNL3L36IFXP924/gPxyG/SyeNtNwlZTwztN4/7FYZed7EHkT/ZmpBhqZojlqeEhmr5U3ahZjZ09a1LtOhOSUX39vE2HHSl1gQvFTronjKD3TjsOd8ApyiDbFac+foJE4qppVOOrSRvN88P5lx7qvALQNTDDJB03jl9hzgZwYHGL5Sg0JXaPys2oBzYfY7CXmyAwsXQNybHRxk976sLNgNQ1sIxRgN4NTG2iMmNi6I3rRDLnJbdpbEK1oqZCuukbc9zlXOiqNFLU1cj/UmkeWFl1KRvBaamwO3y1MVraCX2yhJb/RIQNRaW6h8Q78xLH/T5wloDj7693fNZHdM2yr1hGe5cxthAgmHa2RBgeLBrfbSdenhSrJiJMKBz9QtaNBx+cv+Ts76qCgu7Df51ByFGEo+5F63VWcOEE2n4FcCjKJBPxyu9UKxR2DeSKhLoCGnma7I697RFDaGmtOE9cs7PgkyqSGP1pVKPiqVoy8llyGSHYuBsy7XGsBS2dW76rXcFrirhDaCLbTkX2mjwDyvrpvf+cmEoaRuWlGQY2k2M1cdRjZwh9yCHaqWqWWK82y8dHjmFGxR2JIaP4Wa8MAVlq1dBhmj2BOZ4iH+1DRefG9Nm2/QcS3AR9ziciHw3rPjOgW3fUeBZ4sioyEsaGz4cvUdgnBltEpPDynW4RhRRRoggCojNTYV9yKeXPXQffwr++wfPuLoceJkp6cqtKipEkEpbfLK/yahLObvXghOz1n+qqtjK5ruvxnyA1V3EjmmoYMhbqAGt0zLPNmQCAQJFTzgeJCFmOMYmC1SxBG8pQCLtyuaXutPvb+HYuxGwY+xoUnzKSDNFz7b5mgCUR8aydapzMBraShqWW7dDNv1saOrKdCUsG+qJmqMmj+ZNz7fiirx5AgSiTnKbzG50kHCr3d5eUXIm78GZ0GNPVZbRcU28S/yKQGdpn6/9oTpdCxfDGUjNweXa4H4DTryyKgQmxWJOQ31O0fmDSBzjb14UeM5Dpsp3Yf/3teWjaZNATxZxViOYUnNHcY0sv1Da6TzdAus3NDuRmgx9dkWKECAwFmKJDOVF4LZ0NkgIDVvqCNP1JBdlmQYwvbyjH58guz46uKC2udgLXgzHKfZFGXDV7pCrgDMWdwZkJvlmJvGJ2QX3dqimpIU7A/g40llr1C2yqtgqre5Y7tZ7t18St5u2OELSFOGz2BpM0PXjufPVkFmQqoA2pl4Jhczyc6GL20UbeVb9sY7nAwiM7mMh8FDeMjwrPVvZyNDfELqMv8QaI+4Lwhz26LzxFcqenJ3gtZZRQkBuZicRM+6ui7LjGvGHveXrhd3PBdZalb5Yhd6e6OM2J8jLjsRYgOXCFHvF2it2SCRkwub6ELmlCH6lYjmBPVcWSRIW7UXguFTXqFVKKwwSuqzA9ScwISsReeRSWWkbpe6zUc6dvXxI7pxVMsC7l0gATxQlXN3Nxlkei4//LWY6W39JKgUXoRy56fhG3xf3EZ80+8quVWqynv4L1sjBozuADjF1enYLunLY20YUvn0w23AvhO75YDOgOKoQoPeR+rmq+sljwlrPLW0S88YjCT5Xm6nE14hgc55sc8vc/eQpe79EU8b+HBnuHgfDUjcx4uo+kiV6EIUzXLVMeq4qM4rdnXJ9g3cSMmHjDm71qi0uwlyYpe8FUs9K2TdaU0HzNxIFUTyAjRy+doMzUE2+CxtXkajjNLOJnc+17gn51ahBO1q0+dpZOSLK21IjMUn5Fjj+Wetl6ozR+Sb0jkjGbt8frAmvtUCEmLpvo3HSZ6kibVv3CJbF9cQdwnozZbRQR0cyAXB8J9yqUk00DK+wYv/UUcfANGh4IJj+a7lfQbgVtmFK7vKAua12Q58Hqtxuv4G3XvqKtauKQbPhD/aYyjlGZWcw3uvDyYf4uuGQRtIHPYjl4g4sgjR7EKQwYcaPf1Cs39nitNVc9oD/9S2GNtXngsCcUO4jnhiUP5uOS/XYnGYgdS079VgjAw1DGMya+9mUkG6UcNAdJqdZbEg0qXu/2fp27/C5O8HuSpS8SJYlxiy5HjrnhRcnXZVr8nvWrV2prAP8pjdktNadCny4go5ifC3JJnPzfuUJDhLEy/NNigu3IIT7dwAXnrf58CFGJMkQifwZFFesZ5Uz56NdC7pWDqPu2CyMYQWf7Y0uBQMq4nx/A5puymmxn8cBSr0pso4SfAKSNVal3Romb6Qxo3kILAGsiUr9xAXEDwiasXvDbH1POqzaeQffnoFna/Un/FAees8ltw6Reb9IIBOJl6W8Bch/YfyzuTta8n48VmOHKFJSz8/4q+HS2y5nrmSZ6eJ6E9X3buFUHHSkg6Fq6MfNJ2RkuOVZkNwvAPlR5w6MWFIJ3igaB7rfAfeCE1wES+cXgl25Dlj4MYVwwo8g76tq2PBpUnuE+d4eotDTbZUl/dESCs/tkBeDsEnNzYfgrT8pKyykbqb9EtB1GZ5iHsdnUHhEIH8fDk/Uvu1BSC/1QQ8HS7uMJoTcR4Yb4KdDKvGzzo0HnNdHWEHQc87JFx9dqpIeH06SnwYZnTJlM7ciN/Wfn7zxznnUgQNea0rTU0dXjqrlbdJlRa3guAfqpX/ETc07AfUjpjnJDx8WmHKJ4XJRISObvsiPLkmjfyKdsz4ja8qzs40a5uty++al349Nso+h4vzHQAx4LeWQc2N+sLl5DxnXNzD1Bea9kIKgkXTmudfsht4+CfgfhZzlCJHYFHCzHFE+vtwCs3COT6kDBQ6oDNPZkHx24iIS2Xpm4b2a1Cs+oJKMaEtABnmPnzBfGgyQ4H1QyULgU+IG+FfjQZ3ozkRSJWx9snMQPDa8vMPHMubutui5m1pBKW2KNBjhe7Kumxv6h9YfeABMaf6B0x+FNrvmqmpI0SwKMXHSoW74uoGKkUD1iJCCOPRtArYKA54ysTEbDtRdkkaNJn7oQQWCdfRZGWkJgIk0he4a6aeq7/ajX+7Ydb2K5U9ufDnmI3aRUq7Yy57W0/XoUwoe37DgyyDULDiBE4netUbEQn6uHNjpr+FnFh51F5aMy8NpxiUVkDP4EU3zlbTZAu4ZhboIVbL+jf5VS8X/c53+8230zKGrgxKQy6Blwwzg1IDL2U5vYy7qSpD9Bc1hb6VqxmlwZBRUgUh+/VqRulLhGOUBqUlS6wrbyG5yiyx4OhzvEAiaXAEI/oICweojmtOKDwi5feJxqcsU87U/eCYJ75tww2GOq1wZ/55KKlZrn/8cjDM705BpeQ1gX0sfCPz1tQo5By0LnMdzoIL7SKEb5M6ydneFVzGs6Ez/k1WYo6mPvHWCqvyf81u7PnmO4KarpE4oHdIt+mLDLKmozxUz94ln/BtnVoZFderHJbMIvwc6qTodIPz4VGGHrWGVL8aj1NcSPyuA0wQPYiC+RTTgADyROr9d23FNpfGPKV2z9kzokOYRKbZWlullfrmMMwtq1195IBcZCffok7XetKiA0kcfto+DeCDFgJoE0Bx1KytpfZ+KlcPCxSUE1LQzCbMmtLMiZviQCh3L1FVTg0o7sT1buZ5165htXKtiQb3fpbslrbR7iAmLTkBVdVOP8jNaOzHrnaJScJnchnXij9+8gSit92aDz5cXxhdQ2sOMAFQWO2RHic7przqZUOTagASesaWVTm2WnSGIGqTOLOYHQoETkR5wP2onz9omxy3Hh37SK5X/WjH38GrXaXlYLRMLoRQRYkmaVv2rue0uZJlSjL1Gw+w2G5VOcilWF68zKETFvnC3mKMGDLPjfMRzWA7tn6RfcuLd0vQj6es3j0vIw2DTDDd9JvSbolNytCwQaQUt4aE4qO0b4Q/9xH0SfzoQ4i5ihym2S1VIoJ0uPOYsaQqkz+THDXH5vumKng+OR4EBpB4rwFIPf07D9wcD8aWR9yEf5tN9hnzAXHLtE322eA+suBha/vDFqdxrICkzuauiweTwUqQgD9xPmo81MkZLzj1XQDbkz5DZIDalyHdKURtQxvtycNCFJEcAih0fFhzYoyAuKhpyQ0MPpwR80swImpOsEzD97BMIRb+OK6IZ23kQwioZ2c8rg1QPzZk4Nndvj6vvegiLy+8MsuJDyRFwCg5/MD/FLxnwGkZCQbVGeBnPI+fk0f5bYC3BBUbSQFamptIplooi1CMhfdE7Nq7GYSbjnq8nNWkESmx91Yp82yCyw40EZpFrH0DY51a+r7vRS5+1GPVcRd9o9XmUQ503WjHlB/yCoS76GqkL0eM1IWRqGaYxVgchn4Xqhdt2VDaCa2A2Or6hHiApwt1crW77CJajhZDlBFkZ3u/974g2QLplDAPXE102jqxb1l7Gw1c+X/bstjFRuJPxdOPfbY2HFeexW/k3akeujG1yKtHIpGyf7hgqMK9ASKeef3rntOCLT59qh+XdvKGd27MyCNJtvx7LQHa+uDgr5QrdhKFkwdLHhDnibJrqLxN34inYWJBuicXXCgiBgtB++ep8gdlidAcCiuEaQaDh1zimi9zMJNdrvRKqffc16RDxuU5YV6mp1OBNt4xr8b7IdbSClbupi/RwwN0tB/jemX4dSxv8qWsuCHp8XHsw4hPylnrjcyQVFnkxbheXK3lFOGjPDDs8sCtf1aCMM0ls7k7RtPQoTZ/anq5AShFXeHtsidtql/iGDrsbAMRmxEyyejLgxmfzgOP+3nC7k5QMuRI1Mfz2mHhcyi2iJ9zgA1KUUC3r+l7dyAnS2e5qAY2kvS7IEnRpoZE5v1o78Dv1Q/w9UUau3EhYw5tL2wTBwDzYL/0cnU9TOUQuV1XfBWskm3XHWlmODR4hIp+LjjJh+1bSrK5H9Cw/1vs3mkl+AKU2UFh/Gboz7lNECV6G2eRdQtFwE+/lViotsCh7o6dnAI58Kuklowqhg0Iwtlac2Wc5moWmlffo7tOmsBoOG19YgAkdxs3Fp32pQMW++nSMrA6h6OHrBA3YnK+u+s4rX8vbe08ELKVc2k8uI+bcscjzPVqLLVOE4M3nVNmk9J5YaPP+Tiw3Y3/gqH5Pr9pKr4a+TX06OPYT0zI74RRGId2269iWy3eWfHM88oMfafBYhisZtFLORdB9o5jioUESKnaiY5tiJnNEx3n3nKxFHI9nKNUHWwEAti2ZzWLnjjgGsveoMCv/2r0ixB10B/tEkpOsQBlyTy8G8j9uY8gDu+5y0aFwjnXzQmoDl7sGlypTEfpgL3Kq+lZ5jlvyK/yrsOKdq6FdJl81ev/L+2OcffxYx1Rd7uGlZEiF0HtO26mYfL4YjdYI9eobN+N88TXogsz0XCfCEiQB9wPAGxkBjy6gJwaGzvFzI52JOhWzTacFVWJMVSrSqh3In5Qu1Q1ofyxBFqNmCDZwYe7bEvsk4k+whkoqv4yWdcenFcaEPfsJj23DvjIN4jQ8hUDU9aldxooaM8C2A0xKp5CSi7/auoYFXEQouPbVPOOnftem5i2ZhoQxMV7xeAHZXKQJOcXVGY5urYXBsjHAKsDbU00AoQrkNtNYNiWRWiJOlgsLyE1EvM6fNIIiO+5yaVY3y1NMl1YavJ97S9qdz40usrlBeTBFSHjEtZDsk5GT76BEIUhUwUftOKYsNdMgwErdwezMUCPuJFJl0ucExT4t1Kgx8IgCoHwMmuSc/2Heh9V+zh05J/MxJQJfackMD4fd+Kk49K4FnM3Cd2BOKF4FSAJcjtwPv67pi5aon7sCGXg7XjWW8Capip5ys3BijU5J+6L+qvEf0NaKexLqdFM9qnqinljzEg193T9nwnWlGNOJe3PxKDEfYdnq/FCtlG+5Pv3PrfXUbE0/mypnFarb+Xg9TshGG6yGHrFx6aaVz57TyetzX0sd3wu1RIH7rTOGS60CLnJs7IoDLwG0954qRLi2uRxtFdGvVEskqJXe6XwqrIYQxEXQjOgAksmxO+h5mvDhKmHqDab1UvsG7EsUXtwwjJmvriSPPY5AEfm7xgZpLcx6GU/+LrlhbJCaRii8NB5F3X/erHU7dYYTZOr1wEGZQkwykI6eW5FSn2R0S2Bx3uytMeiIPKgZx0gelMYlJuZM4737kFrrmgXZk7i+eIZJhGWiI+z/owB3arp1bhEICeyIpSUQmfZsXF1th/gqryAZ6w+AQRr1bceWai6V+7DM/M1l8ghys3Ptfoew5OrL66rM7+PdGeQjLwSzpN2nMeinZJ8PWMP81Ukzjsxadx4vRDkYK92KA1p/Rws9IlLhLven4AES9E8fXebkb++OTslUC0kNZuHCxjvjcIYedHaLKAZyfI/lmZp0QlZyYql7VGXLenIjcEFf0HtX/GlpTbM4nZieAQBVG1NJh7bYJft6VyQabLVqGcuAk4eBt8w2gsQ895v5MEasha+xSRU+eXpvLyEkYYbbpOFyz8+p4zsoY+cAoUTsSw2iz281wY7oYDwdAsvSoeWbscHf7DosvXUrjOrrqWjpTjTAUg8/BXxGgklrmqCd9FwU/yd5WnwbWxlAso28z95jsLmrsUl6LllUWQ0AmiJhulgINGqPl/EoUfmebZ2Bb+atrmVfvmH8hO09WuWHM4j3wXRPKQz1v4yvlfTrIOQJr+bTmx4lUIaymDor5SbtY46WGy9US7agQQP5wLDNXoEqZLtvhBjmCiYpSpWpsMRaJSGyeLGw82ZwABFn9Zb7uW2Ioy/C2y27pFGcfiQI8esuLZ2I+nE+agn97Kk0cU6ZnJfjIymCKs2yWrwzFGNnziDdO0b+odotNVlepHs9hFBtwPJzXJnO4Hq4bH/0AsIsBxr/Ova7Mj4h7dedWXELXYc96nRtrC6ruNSVptnYpJlGOlwak/p6+3urjUeuB+nAOiiRiGWKbB5xGpmDq1UKnZrWFiwJmzQpaK5sjV4nTkjf4yox4pCH6WJKjQSl0BCxr20fUo1O487xSEbi8288rDFDaPUjPKNVlDkOpRFTgcPNb3KxvTQMbJyfxGZUzaEwgwlosM4Nv+fC8YSJ/cDH566v+FrXYPE2Pzq85h/Jg9MxEijLxv/b9qR4/Q0fFvK1Y51eYcsHRScx0873J3pBz4GeIkiS8MBg3rnf7Pj7aNH+wQX+T1kK8BeWSabryPwRUJmCKD0qhr7Red9GOB7z9lH5qiGt4jPH5DnCHVzQ46a3bGq6ciD90KU/zabHjahD5gNXXRzGV+jrLg0i+grN/RWn6upmA+mrzxIt9eXP2w1HeB57zjeJ4RluTE6c/k3ptKAc5GHQC+mVp3uKBDT2RIaQsjAMkgEFhUaW6mMR41quLSH17GAyVcVJ0rdtHr9WkRjzJJIRrk5vSkZ+nUbYDShqpEUc/+b03Y+Iw1OroQL1ZVMWjOsgkf5o/7yMsvAamIYIT3hx0/su9cuFust+iyGXUk0lEHoXmfppZJ+fA4kLMqjq92LMeZBoTfcgtUBYYcVMe3fXTH/Q2DRsZQmKJeuTqx1vULcvn6Pa64C039jK/aoLEEheSdto4594cWrhYOOjjfegbODo1XEIzvn9gfm0u2SMV2H7VAaC8kfKaxJ7F24j5TzoxVlKqu07USPXLOgHGqrRI9xiF619/ixcNOLyPNqg3P5OvPENGVS8FZhxsUYamTixzGf4KBAXuwj0mb506YFHtRWl/36hhcw6dEb+H0nzhpNnX0slVyiV6WqUbz/b33joB/9VAByLrwaPDzSHikuf8NO2OO58EqoCTikUPcvBRvpj19lhnxAZQOVY97uCd4dLCSJjjSk77KdDNfpL3YGdTl6yneaiEFSllJXU6fyXQbHT2VmKjd2oIc5MU9OLfCPnyREfth+NK6xYaQdLYmnJ3MPjcbtLAr7+g0VSLZNRcMhUWzrE/gSaega1gzDcYKEOPn93CvN3GrfYFmFGIFnz2qR7bnhm07fqoZqwLdzYuOTZZK7li9p9bX+x0UWqlDfV9j6ktm37EwrakGp7Yuz0o505DAn6rRyBSMfT2OXkD+yfTxqOmFvNjB6Bx7D3KI+2gqJ7ybh8N04TOM9vCUvGnu+fwrQqq9ovXOXtZ4n/gIjJwUgI9Z4xLWD8eBySCa89Dw2hyOzYfeqbU1mNHPXJQ9GjbExdAAhs3KtVlNnnrvu/+jiGjP2cG/DSudKj3wPajIY9Pk2Xex7L7xa0JyIlvbp6gDzWxKZMr2t8kmzh30+aaZUQC/ZFMw9/7pcdUSl3gw+txEFinYMqs+z8RVTozIK6in5I2VmfzdxbKLL7uj0OhBZoRcUKJ4zpar/5wKpYe5MCIFhLMH9qwrvbs3l/XMH0+IoQXwHUmrXeeikCAM11H2ffeHCCz78ZCvTMkeppx979qrXiHqx8LBPeSmYkEDbevymo1KEfLoSx272iiNctdoR7hMLnLcu5b3Z7um8dLoEfM+a/OXFP+DQOPIUgFh9fAgxXDbKsyftFZMYE8ql+uuHdCmXKSGzPUPg0QOQN+HwaFPsiCMA1PFoeKTD5TV+DYV1xDwpGtKXZOMJGjH7TjxYI5eD1MfP9sQDVwQaFFsuMor1CY7pk2brKqqIK0S+icra3IY7tGMvaZa7x7F7ilB8Z/gNaQHDl9SleG3h9B8H1EBT2eiOfw0S4OU/54onW9roRYDpps1wefsBf1hrqW4RJ245uKpL3rn8SX4HzTrbq7Omq8H1VjQRSBD2jkxlMY4ywyRZFMmr4O8YCzUzZ4f/6/0WcJHoA3yeJ5ABHh8zV+BkdW/QhGPNnxkTMvfujXVwUqZMn6OlH3fsTxFJDg59Eu8yHfzZQJ11FfLeECjT5//EktUHbXn2fu/nrb5SuDv4jyu46I7JLD6xG6ww7s6hEMGDd7TBDqYw35olrRLrx3KRcd6dB69TMvgYFBSZmHtoGMIeXrpGOY58WPlhRvJUsPVVmnss7JzkMmjhTrEthpBFaCfWwqBxd1c9WRT9PQPoBwsnbi5XhGWD5FIdZOJso1MdKi6TZ0v4Z6Ni1U97DwtxHalYq4KC1eqBR8X81HDranI3eLFEcQpY74+YOY75OUMT6gK07jJLUmWN6nZAwvnx4E+PFPs9TpC/74Q4h6W2OggTicEGKyL/YrszboyO1nq8DkZB4dwlsF2wytFoDO3L3I6Qgmg1vaGMIXYSRbRiSRgsZoO8NMx7uZan063T7JSSjx56tusL6TELKFgmvR9u8inb0Iq8vwgpvgUgUyGZPaV+IQcivR5qUgI7dC4BIAvHYShJVLwE3enOAhLu0KJqOubR9E95jihqj7YkaIitOoBfJmNIYb/6Q/lVFjyhHiE8wcizrFlktZqBpops+8t7wyyws2QEi10DQrBBVFcByA1W1/pA+FPs0qi/QxSLS1j+C2A+NtYn4oBLXmHUclq0RtJImf2ZBAm8amQ1b8R+k6tmOlpx7Xy5qEFlA4zwvMF4vs5FuqGoFnM+E/lyz6napxazJ6ne72sBBSlL1D2vqmyCQWWfISq31RS9tiPQhRYOkiKYRMvUhQvaTPH5WTa1EZITOdPy/W1kLLqv9xUPM2vKwziVIat4IJLju5Hl3PBw/WJPON+zaaXuWjWz1nJrCRPOrEbsCQP4LyZk6qwUnRrGry5aDKS2WVm7SxvPF3aIXO5vmkobflnEwg7YuHCD5X9iAsClGBJHxhGWfC3eTPmhqH+5kQ/2HUhgvTLqcRdxyS7rpjEJZPeqm86UYxwGYkQjqLi4I1F+PFZ1jNTo6yrmXVrbEZdI7MtIzlAaCNjsHPSNHCKE2uotxZq2DVluYVtqA0UKg8TV6b5/zTzUlcxSSt1LyUfIpKvQx/htG0/hBgHkqpKvT1Qron/spX4WEFMzEREmhujJHmB9hOVTOkAGI5Hs6DgnBq/iNz6dYbJakfdF1OfSmNPjwWc3YA7ZxC/HVKD57E4yTnggbXArgn+8xSITRNYyTmkpv7kwYStcxMivU3vs8HWbJ0YPbWlyamoWtwXefoc/oEPrpE2d2xCffCcQ37nbAmfk3QNWeirOA96QZCriwJkhHm5Ji2baIAbyCA3Fcby746Cde447ORz7T6HXwUZA7PAX/GxFMvvMc4eGRGC7ZecD7Pfoedh36OS+pOip87gf01+wDmkxGt80aQhpRYOCUlZO0DKIf3SvdpDsIyXfQ3ml3s4RMUBpPRNxvyq/guQFqhXsmbEa5LSpIvXLIqoPFIC/OQ6iQIegbLt1wuA8jCX1azbTLnk26RiK7ww7UqVFRTdlr1ZaEfJc3R1MZWFTWiAJFc7Nz9FEgDXkyuzM7YMSPuxVH5cTrtOB2Bmeat1pJ91ENVsizlF3jdnZc2Wn2TLiy+plz51oWwXra4DJgfK0isfismh+xDjOcgrx77eJO5qbTqUUeUHl2AcmcBBlSQcKGepWSSpUk5bFs1tVW5BHWGxAdZrcxQw7mO+t3A2KBoyLCwWzUnfCsHi370VAR4cH3cNClCWUl+pG7mYVtIDL/Z/uDFB+x9flbSqAljnvuxbBjwm25E+kNn+Vu7WpcWMWLEL+2J5+XWlx5s4ZRGu8I3xOeXrXzOGrkl5XI2O9ADAtvjmSaScchQekI55vL4vbskt4atAT/b9HMgiHAjz+Qh1xcL9yUQgw4kM/a5h7RPiY5S0kTxi6CFRGFzEn42IlB5F7fiEzsyeZy+byvVlngt8RwTRzUiXHR8nNjFFl1CUgkzTLAF2key7QpXWIyNjz3Zn35ElSvRuYGDrsxCyOmJOnRpKOvqHwkmbzs5aj3G7JG1xU2I2kzDIOb2iNFbtY6At5nA5AKE7YMvwAxHBMYP40REc9GxS+71zyVKHMG1UzeI7EsO2qoZOj+Au/U2Kwg3WMb9KNZBWYyJvp/44DkkMMqM1tkzWwXFjoICadnt1uqHbcw1QUCFmAxJwRDums2EkMQof3HQFin7FjJ1/qZ3eTtHq2MjPEyFPW9KwLRK0DdGSSNPloCLdGJOKGePudOXEr7CRgZeEiWJ20V9oTMapbmBHeXS4BdoIzH6rKXx0ICbaYdraI97GqbnaEW6I2KQ9Rnm69pf4BYFxZWGQnT3EhKtDbLRtWqMi9Or8HAORgw4oicyLOU1xiLmuZh2MlYHIuEMO69bluiFrCZD69yimde8rGoNsTi/jaA6L/rjHMW43WYkB9HHbwIIiurJ2qmj6MLtQ49EwiLQ7MAShlFbFfdqGwmEWZhaFllfo0euasErYzrzYp71z7YHnkDYt+0Dw6HxtdAm9m5/M1yDopzYlnmI46yttYq2Z+9NDWhywMmRirDeux5GFgGNS9boG+gm+YtT1RMwQg6a3T+mzZ9i6Nx0ceVU5xUtOzotIrBOBjmXI000Q47h6RMpo60nm9GUnNGRn7poQlSIMebQCgZda3SFoQZZXfw6oDLqXss9UFwvANu8yYLskpqxF0/Wb87EqlvDe4lb+2Tk2QN5oygCVNsHT1EQCVxDWzjhv0GX854C6CzY8jf1dvWj0aS45MqluScW11AZpGxOElvsYRdA8qHEGV5V1UG35jpGtqlUFBY5YMMnbZ1n3O6KkpNYKLJDyKxy1z/qQGqvtJeb+dohhy5f9RCw+yCLTxffz14kMg8Lk07cVu6nnbve4Q5goVG4fQyp7BGzF4TnriHwnjZbD8AXJKTGsd+laPWr2RLXj615nKy02V2fevmsbG12JKUxS29jR8r5oB5wywtUYEG7Y/cyijgMVcWV6C2Ibqiz6o53RSsat4qSfMmapfrLjeci4KQ2CZuZiyXwhKNsbLCu7y1S0rJn+h5gBVAuG84tQvVsWN5B2zrlbnQ5Uko7h+YL9ZrN4mdnRBjes4w4gNy9ppnXZHngK+ONDcSdjKF+R1+Z24im9GBuOA19FxbckYb5sDon1MbJjplT4e1Gx0KnBMEtW2mqNma5mwHRd+iYGNklu2u6Z5AeDnbaBQZefPBsnNs68DGIKXsPvnhkrKq9aXHRSTnywVIjYCni7qhQqmJz0YfZn8ojqJB47cN4lhhZDdSNkbaJpOoOAp5PuvE6RwY/YqcQmJIngBHUoFvaYI2x1JWa1t9kKZ14ZhdH9zbhVto0EFd+SWwOC9oX1227+sxG9UW03pbI1mUd+A09qnAcObZcrbV1FiqXwNCyhchAmK6ulrfY++JM5CjHU66vbChJjZXlqbn/ks1yXh+L+d/Z53YMkJOI9ElSDQtqbvDCG7V+p+Xm4dF7NK4eY8f3BMGS1/Cca40051eay3FGDICL1LGdtuyCdVVi2z5s0R/3rGzZa39CFeo+NefAaj5ZqVQEMl7LNkP0/1yXSNIGy/q4ZPRfEsujb6Mz5/h4zzRtzE2vP7L3rtH0vYh+EIxdfbks0id9UTezXR42YJhyBmZMn7uNf4XKDxFo7LbBADJEK44NVlv7kDUrj0w8cjaxOrRNeJPwwzhzH1pKraXmPMrhEjYRMV3+PtFmtjLyJZ8PWL6irhAur7PW1uuz8ClCFA3p0kJ8ABX8+dI9qQF3kTVQVawuYeUJvr7d1SLSuRyxt1yMCECB+6kgsJDcrvR5su0d3fBU/70ZvlB2BetquDI7+wcNBlMmDN6PREQ1ssbPbWt4yfm2EbhBxx9iq4Lu9pcOf9gLZGGGPAY8TaOS+KNmsLWOVffyAies0tDIqhFp/u6+lZL28SxI3Jz25m2bXWCdlXewUf6LcT9Pj7w1DpQgGsMItY6FzPrYXjg7sdCLqgQYn0R71bQ3+GNBjgjoghCzttXPLgWXWMqv1goX9BJyseIZsKHqP/g5JMC3RSEpm7ZRJeBlpfpGW6azro4hZzbPiq5/CitgUeFAb84ZT1446AwqyK1FjLf74HIcNjcm1ENpm5cstr9uw6obYI+8+ARcwgqjR7cdHDxdyy8stxbF6MIj7bmdtAhRWXBItRtzKStzH/UxcZzrzcfRPIx29oulnzAwHGjnlUMb8so7YE91h/mMRLmsPcsgBrBZ1isjm36mtMaI+Vblf1cquRUzpRdu1ThDY8Z2Dmg0w50sqq1VdAffvjQWZu0m7SMVCCcSoqsyJVPpUViWafssQXA2yF7UQ3ILOSyz7m1GswonxLt0ripLfUuyirKYKmtoqb1RLvcpEq1AFHXctjzwYFhb/e8mivDZ14xFBm1NdL32OP40C/csH1fEG2jmbkq0suF0aEHmpb/ciC+DWhfk7PfjvuP2JgKuXBWtST+JrlV48pT4Bp3GbnMZh6r65t+oPfPClZgyCyo46l5AqrrM0TREAXouR0H+PC8+MrDc2unNDnRotuBQ18UIVnOjm9Tjwm74E1ki6gHrUwE6tCAjGbcLnQQ26V51PIKqU7x3eOdKeETVsdMpnpufG5HDM4JzrP8Nd0zgZRB0g+m75wjH7g6pYoh/HLTDtBvZa4/OlO3Myh7QfBsA+fqh64cpeKhAXFC8qQNCNeDdOMvpPFnOIijCw1reuDHG/jZMWcOk91RQ9XO3dKveGOTfXufkb3ha0LcDPvrojYlw8PJlngOGutgs9ePQljo3bdmsf8RrLsEOMUkg18aUrjczEo+jvDSK93DljDf5xoAdZmoPRTslKjpToxqm3o8PNmHioigtBsp8yuPj9KyCoAG9fvdCRzum38bkffVhi0r3bL07gLrmjeMccF9Ex1gKEA6c6O/pWo1ZveSFGxTBW1b/RJLIyhsuJMIOEnR0YjAY7NojeblSZ/ZSz/MNS+yRYcYwpNLywFMtzJ/mP34JzGFfNVwLfxEUEpTYEDu4v5nG0dYzOxUCpdVWCNXhXXRNTpixYxuPeCUq6NHuj1+bHh1X85ZC5nrGt+ewBc1zuXAowE1nDa2D6uupXCW3FCn1hHRgcXG1Zm9qCKXUacOQbaMunRBicUhXJgzp6cMi0sy9VflpVv63/Lj6izTIHRkbBgeO8/80HF1mJ0so6yPgIML9706wRZ1VpX8EILOV44dyHCCRIAEzjtOemrMms421n0CZ56W3msBiB+btLghprrOS84s3YVkVO5atKHHq3Jv8a3htweaWh/4WLgtDDwIK78WMuGvghf60lmeYKn/fg76AILUQmg03KTs1DMrhWpbkfVSCcu1D7FQoyCrbbL98rbflA6ux9lnzK75S/TAu1L+fgbxJX/S30aDkzPaHj8tYjRaZcaXyjA5AOcfXfBq3wJwEBFYbQ8Och/hkSatY188bs1JIO26nY2+c19WPe8zzNLHj27rwgIz07f0GYXzjHu28xsPBxxWMbqbj4hfftbqCihY1OBSHYfm1yhdPj819IR7DcjLEIED+OMyHiB7uelNqbtzTZxbUqDeuKoi2I9yr5bimjIdZrKSmaCDX+qG7MOQrv3p63GFtBra/6+dMvqgU9ZEoffAsbpdFuSM/NEZjB19HXff1uOrt5oc8E5ZhPL0bfzVQlnSsiPnvGhrp9qOrJfKFMDgCizO+JET8DZ82jiqrUdRP6HLeRcz7gZ718Vza7I2DjpLpvUKaHY8EcxyKEES3JlS2gwvJfKxSLdZMK0wyBfZhr8o7jyB2tA0bgiE4JgYNkW2GqKb5scEmFLJjDtqaeavRvkc2iwuHKDx2/oDwHuYyezhNQxWOpuJ5JCthlIdfeex0GFC99jpKSZrn68KaNTKGSVYYhP3/uiqy4BsWUtLUgN3nGiDEnhVFDkBNi5R470/XtQzNoq1IU5oOHff+C1ZYLwOaAwz9d3qzlyjbH4HICw0Qqo/eqBEUfio/YueDmM/LdTItKXOqVXpr1lHQ/4kU7m6ONV5+qQafPNIX3ZUXzcgGto8vg3ADU0MFJGIJIdvoYOGzy8KEMTdU9xTg9lEUuCNkcH5UhPdEA6qFnY/TquB4BJ3UvH6iuYXIRrsk8X5FAWAjcX+vVnlkgnx7n0L/ZCftwDfyIm+VVgYijfy8bjtDI97r0Z0dvPIadoOlc1ud1lUO0Pj5QD+AKTNK+YMARPhu7piYeRqcZS7x/jxox+ehb+1yLbxERJx0vi59V7Yn3PQfHAuUebPMEdmlGL74KDRXkYB9tN9Ch7+kW3kJqBoE7zjAmHp/4KHGmopdzctM8MKxuLkUg3UVo/fnSuo2pGIHBmlvUMtUaQVwiPXujgNiFXsXrbsghXU3EhspKNd7Q5kXNKcYyXn2qWS069T5pSuv5iY1xaClz4hUXFxyzivC6BYDHSD0fYJ5o59RAG3EMlRq0v9tMH7qHWQmgFsawbIpiL15VbHGu2EQgs/ZXOpXzYJygBfqx22b0tTBjp5VUk/PGi6cb/U32ewl86/V7DHIE8YkmNufom5V1o7x0Fm/6nEWzid7S8fQlD1JEtyWk5ZMR+nYCW77ZGwK6q8KWZFJkbqUY0+R96YpnYPIKKDIWs0cjhENb6wPHHsaToxw/Dc0efBCJoXnh06XiSaMp2+AuGEJVdIhou0DqZNKM/nDFB6jv6ahE7QAeU0uY2jpY+OHt9E9ffp5QkOEAgrLMXQ2DgkpVXNJfeVwuLsxf3WUoI5bHkRpNiialxoEaKGsEu+UkcT/wUjEwo16JR7IYc6825tzuXa5/bP2kaVS/4rEyGDS0Sw74UbevcDfUbQ/aCw3DAD/IkRiEu7wQf1siT3MsJDAm5x2JrE5ffWXumhCySqF3IHXi1/Plb/iZkU3LUvGwvCxXPLRN6odHhJPaiyrddGGju6hpnKFM/0L6StZuW0y4uUxun+V+VTvtCl6GEVHd/eTLS6W1r+wfYq7LBAZhL/A/m0JPpSv6l7hg/Ci35/9M7NUK5/nJVwrfT8kqTvmpV7RM1O/COIjlmIbt0pO+qSjA+iuafB2e0Kk7Gjgos4ws+pnuY17f648UeADSk1X2P2xt10vY3UzG0TRpvE4pDnpbQmIfCJGZejRfto1WCphf1ftXu/R1XpTEpKusWxNB9Heu9NMSyo98NGq8MK8LLUdhwt++HNfmcQJgRm1QiglJOa4YVyAb6HCXWV4ziIWhpYSyV5Ge7Br3izJoGEJoPjit/n4zfcy+E/t2Zmlv1orDYZTzZkgcubQbflP7RpVDxybEtQ9YqLPFd6JQTZGQvjIcA+Z/LJ4b7iqsga9jV0lYhSSTjEOu3Xy8KtpelVHdTPdBvBFPL8z8NIyZBjP6EeB7YbFukTexAaj/ZE7mzsopHUR4Q00i68Q0/rLK12iT2P0PH7vEgRhE+rOVAG+mof8T/54P2y/p8GW9+btaYRucH7dUiPJY5HeiCXSV9n62GDvvhHuafGLNsfqYPuLOM7Os+NlVHfwS9l33eanaLjnafvhUU5iD3eih2AvhedVkPhi2OUgD/Y5aKh3jWWJ/mkdDjwQH/RJlqeJ2VZ/4m1r7An3TipcB06SB/5LVhhKpl5S6qLy74qd3rSXjv5/TjlQ5T/tmz7i/EQM/oysgZkWtsJ/HPJWl9ktmQ18hCSRoQCmIhSmDSZ0ZNmrZAIpSI1JmWD3bZKVvyY9Jg0JdcwR//71wdFSK+AwwGkr02Jjuke3jIcCBtoGI51TmxABlx+rXmR5a6cvHBl+G+W4KsL8Hw7+SW8DPYw7hMnBibHdA+9VfKZXLOJSbYCkoL1tMWTcZor6rDBv+HxdKevCH/Tywlxtl4/rHb8uEwUEpbiy+Oazt1ysrTO1RKc3azNqVO2KQATIPgi/n9soOSEsFyZ6v9uPDFUzSnjHqam/6UNsWOlYRccxMB6ca7EG1fytuS91/52wGFDa81fqUKIamogTsTk2m6/cTftJrJGYygPtiDUBD0kok4os/6NSV9bFCQ7KihdvuEK28ZKkV0qmYRCrcu4qcNmoTOcv5QgSFA+qZ9VRNmW2TsSkzH38gErPQM/1zdXri6nSpU2kuRtmvVHFS72oepNykw8RHUTc2Uq0YEdr/fU83ix5UY1EwPzHcz+gF2MqyQM4/ruE0shkTQUHy6dfoahcxubje0vM9naSHppsnzm82+PHaOuCIOEtYND/LHgIJcRItIOqTWTysT9d1imY8BEtUte75q/tivrsmeHZVJGQ0U6fF2ArT8Lyb4GJhxe/VhJmkeoHWAQxM19A/292cA3B5VeFOexrrNkNf4WY6jbQyh2MVNA80rH7r9ZAcZkRxZ1917xqathK3eLDNv1M1+d6fQrDfRzEiMRnIk5lB5Y/EbMiFe63wEAi7u0wRtkeV1X+qd4De9XNQgvtQeOzoFTK43H42uJMMu4MB86NoUlEkkp3RQYgIDSUHIemDndIU3mwBqe8UcGAftDXCTh3wimR4LceMbZBObP7GDK5X+elG2esq2Y7wcL9+i1lhnljZ5Kurtt9Sl6j67tE+3Jx82KHNCCRxbCFDHzklt0lUT6Wy2KCSQUv6Rqsj3ii1LkOZ9LIRRXUhEad5+XwJqqOeGuQkKkvmQ3agXp+VbWTBB5GeVxrPNjJlsPjaKYLXu46VLNIzE9jn2yh6avX2e/aYdsLedfc581zkrEQk352xZTLeYON30sU/e2mraHuMqoVWrrMk1c4uszEuo+qzZwKtn77AOf3bpzBZmDQeRxhrj0cuopVVTOTDCbB3SK3+p0T1a0kuUTi9P6G8okji2rWFqmWRgq/k6ieo1Lhb+jNqqEYWjhWh7SIcT0TaBrDenzP7AT87DgJ+DXKH+dYfmR7yD8Sae+k0WcRYxskRap1Fg/1fnTfaFf9TYXee6c9uyhWBhWpj37F7wkC2lQcB/oyy9NEjAcKew/hY6S8CWMLdfBVKdrQ8iTKbKJdxZijRyj8ZiXd9e0UnWMM/fkq9s+OXSgkc+4RysRknrm9Qt/sd+WeNDLfrnhaDLM+HRkXCthMkHYm/MnKPVk5fE3PlbXY8XBRty9nFq8dyS92S/kK3ODmeRm4IfahL7grS8HVVQNRS0fDxQHGuX0AFshoGclbyWuxbI/S3va5nS5JapntHX/ygOrQsPfuHCcg5YGBbFbisi7rwXBPbOhn1gzTdNtEdJ5Zq4h3G4+iBbPOvcUbXI4bBlmi8phTJ9lEI/LrdsIvcsl7hQ9XDHV8XkHO6qadOHilkbJvdZr2AXSNLrBwHpGEzNkQ2yugJp2FD6o0MWfk3umPfnwIi84WmZkoLx9j6OLJtSyM+EytZQmaBN+Lk2EDu6hBHwQcAIBh4EfkVtG+kytC7M0Vn1W+RO/MN1bj6ZRZcRXyiwffskqP8h0utnlbdl9ao7qTD6yoOprDcH8VRie3l25mTsrCFmqDuNeMUTP5lj1tWj4688NIJ+uPMgTr16h2KgoNDrMcqjGLYr5AocfvmrFnP3euhk3TCo4DTJBa/sw3xsdnhC/F1kTr7A1bmvk2+P0z5Lfv9yI60FDSnUjWWJFWcL+XcKKn4lljLk3MXT6f5ZTYariNiae/1LdU9jM3zJukY9tLbFfM5UwkHV+3JhkcONuZQYs5c3uUm69Ifp2G2vzCSu9g9HU04mIoBnKzLeDtTFU7eonCGCIx+174vgzw/UP9mXcvE1VTo8+hVzebC/gx0dWgX/mcBFwnWP9pipVozOnrAnbVzkonF9W6QxnRHvYVMawuWa7X3+cAXOh9wNWRmG/9QWkcNDFyTSnYNqcFfa7bP8q++ws2PwhkARQ9nYsKO2lWThY2a6Eo1j8gXxtIcmol/UhB/KJIl7brfUHX14MbEDOCJMWPBtwVRFWGyC8ML0zs1fhxN1HwEJEXKO/RyS9M7/urpWIUdlK9M2AKE76Tq2BoDfBAs7MOxL1nY7L42ChJo1dgXkaXBkz7DMA1p5LJ5ZSJ/57fU8DW09cLB1l8P1LiOePPRp1xRu63MeJjOaH8lkMHI/cImyky3OjMnCRWneO6ksJ+d+sZo7bBxQBnHuxG807M+s55Re5IkHU9c9m9r/dThuhGG76xTQAh+sLkcwX4Dx6WbYFLCLRH5NxCszrvMR1Td65FG4/GSTkO/BfNydLDJs12M5zf4+22QvHDbDBgmJSP5+PYtDunph3J3g9RpbO8iVUiCRLzyciiJ5igUgSCsepBt2h+N8N18gG5mFo3a/YXBurLvqaLK8Bz0GXfQleXPh2Aos3njZ19CfzL0KJr5oIp/9K21zhZ2OHS0D+ObnTYKiEWnq0RDDFnw0kh+hVkCpykzeDlsVQddwTp6Af/jWEtqypG+XgqeDRDGsLEBF/JvhWE+UF0xBo+XKPzvFRrpD04NW7ErGz4OQ6s04oHIJ8YNnYZvk/uDQtyaaaQDZw1ZndVX2lNSSz5+8cURatS6eJIoCw7XaszM8e9BlySnLUxZP4hrFGdax0f1LlpWJ9PKCTsNlNwxk/fyhhHbzsokTWCsimrNW0kbjHRzuJrEszQO6Z/L2/q5GRJnAdrl7kalw0qhSyMvuS/o/D7pK1xGmGbswRsQQaTNMtjLgJwOv6oz5OGwI2tr3mh77Z0T0iJj+4R9hjdui06nuKulf5URL2MiUsY6zvcj0LKTH9jgLk2N9gjTBK4N3ZHVvgwQsWpqjijEAAysOI8pHL+z8pLbSMjm3Gto3fDVL0y27k0IeuyLCvX9NWXrGtDw9Du+3a6Qb9Gnww/uoiSMviilvG7i8GaHrKtpgf5gO4snqFtT/HcLnseXV/xbER2v6MwPKezGI5dUfTph4FErEha9rnpnXt/UJPznC1GyDn1elHlKbdnwLcYSxj569XR7SgzbsNkZatyyPe+y8n+DrhSvKaPiGO8499/64Z+0SMfr+nn3EZgwi5+splSx1iCyuBM+T/wWQvj5KMcAqh4PfWAZO3YBfcMFeMy5u3D9YQFsYqRpi1JJR/JVqDu4RLJwkvrwdy4qWmgH+QImaw74iDEUZqMwp5WGpFG03/ZHdJj+t/hx23kN1MHAkdt2JEnTKcMXh8iv7W20mhc9nidOoh9UAndsmhIAVh94NwNc0qpIxOzOsWkwXEKdVoltj1cYdcWJMA3shnozz0Fhs3Bh8DXA+jh/Fk/t+oBf6JMe+Q2bmrQREn7zQloaBBhaxwtwZqFo/2uma5ZXY7QyqkeHJp/tQjEjVojlP81dIz264RHr/Ko6/C3EgxpLEew25zBxXcRanjs2/jVfCnAhsqxjEw2S5Jirrayym7IxbXgnywdVkXX3U+YUSTS/74LG20nineRE8Z4qRqEjlqYc3ly5vNIKv++LkjZUE1SwQkhRCtOdZgvT6fk/vxNKaSx/CFyySqW1dX1TcPQo5wuhJQp7+xwp/nnYlSLqwqh8p2KD36SJXxDfJ4SLwCApqKnb36GsQbughm10T55PvWKIQItHOXMgK4juswaxaOrW0F6QzR67QSOn475XP2sFnUKTgt/dHz7ssfWbQVcCiyvBYwl48zj7I+ePu0/ahtjeviUuLxgqjcfoQ2QlYSQhUlGWsC7TcyH7Yual6hPWV8ra9bww2q66n77GWXQI/l0+681TXf3AuDd9R/0i4vKR1OGICx9tGbrGmb6W+/fWhc28sxsKWnvp0Qtd9DKrPS9UhEXsqjT+iuPFqdeL/z/YTMhFuxaOam91OaZFBI4F/KDGYOKoSXiZeUtByUXqZsGbcLLM9drZzsNwNV3BDsvW8TgWANilO/FFuCd7EGtgPd/vobw9+pb119BCG+gqGWY3gvK1xwgDC+3zHcSJqpGXBx61NrRqboeqXBs0+jndZZsJa8CIqibCEdb5uyq0H/Y9GCkbEcQwWK7dNV0xLpUhQ5c/oaOZOcZTsGuaq/Czq0WuB0hr3hUm2AwciS4nNEM+N8ExdGAlHlv5M8LNu2IXd+QFUWTWvgJ0vt1CP0F5OY9wflVmhqdDEbMtJEAPHPswt1nO7RtRNeQ50ZXE2d63aZvpjxtdKxMLj/98wI8oUac8gau2RiGhCr2zXbQLRi6lJCL4SQmucU5VBuA61shJ6+mcr0cwZ3yN94YGIFbJT2g19AzR0HEIj6kAfZMzKRxdXIiozy2ATn+OBEDMF/vwm264vU+smGIJVWcnBG9McRBxzR+uSLGa07lwnq5WlfH6dxp7QDJzWa+q+xX1mNb1xxLERcYO0H+4TjsNWW9UVTb7Y3kzFQ5GkavrK6HmarxzJAEm4LjiQcG53qWYLxuEcSbgTvUlaqTtO/UYf5yK7uDfYgHfSG9/ErCiyzkWJPo8/q1dyry5ShaBngIgT8jRAKafKNE1fMedxcBz34bzhGkuoPypBAaAS4sA369CMJNjmjvkxCggrEzVJaWdAar4+aca96RmsO/D1w/Vehn7q3m4JHjxh3PBr+Meu8tMgqvAfAuJSqSRvocS1EFM/sOOevWIilLgTlx7MRaL46JVSzvstmXSYZN3xNWTOpSYWRlSS9wU6o7GErp0HBYC9zKG6n1FKY8NICCBTKzQO+7QlqF0wIt5eg/yhdbHkmRLuV5n6LL4JDt3RkY4VFyv/Q62KXKUuiyZJYLI9OopmOkZPtTbPlZefm2Z1yFZbFTIS6hrhV3wr/j8dfZ+5G6e0NR+PA1ZndS0rep1Tb5DD9lTDJvZclOB2Q7OfP6LucepECFPa8kVkyP5ot8gZYwP2zJjyS5ZHj8J0nFsS2XNw7Hrle+jJreTxUfGyrluJF8Wm/SJdNo8Hpn3yt6TLWlLktBVJqOYtv6hEt3q6XwvOGl13uIEvx80zfv/V9ip9n1XT59NO2BiSe+91izaEUWtriFlzt92Yc9XfdXM5YeOEGy7sAWXT+cLBnnUniWMelm63XB1szESnxAtIUr8i+9K69xWpV9jiEde1ATBPufGvjsd3vUlwr+RhaW2TjxdVsuuhulbYRj9VCFXOq4Ud66QMlaPFOXvkm5nzj/JpgkGAoFVnZw9/ysvoKWDLx7mHGchndk1yaInpEqenjh2Zau7+chTWp5UtT1Oe4w3ec107gjaa3idQvvHBNqpmIzXFFIMIpAjkK3WNaNVVayF0dXKS4kMU7vmjk+WOU4dNwp6VZX8RzljY15MFhtUWANBfM6De4PgTCKUpjvBtQ9jbwP1V1v06pgQ5cdYg95Dbi4wlLSjcB7qxd49GwLVpG5MFfPc6of/ooJGWYLRPxR5jHMCkB9TcgObbgJhJIL32te8piZQW4Xsjj2ZeFvUVZQmqHNfo9gB88CA23fxGiecouMkGFh1Ztf379yPnwKFoIlt+4UTcq6rbEGafopypIDtrmuxouBj3Z5WfmrhSzF+g6v7XzehQTtYjxw/2qTIVRxY8JAPf0ns3bZDNgL0jWlhtAtQMbsg4e5dqH11QX1uAh+amYydMXVwKJVFFWd29H1MEZaXyd5yrTF6/oP8BiGcLdiG/lB6cUYBOCaNqn/BbK7NA0rQQM/d1IK8wO8XeRsQyel4h0eUCt+VRKuWnjzWctGEYa0p/QPfhZK93jcUU5oc+3UnstXpath0j7whJhlKjHqGJU6pLii67/EjoW9dXwXszXZCCMhmLFtUJ5JZEsCFyCeBmab0eYLxhH9weLMKbTX2Vx2g9cqDIRYo8mv/boYahfXqX4CjDTzya+Gn+1uWlGrNBLs+jE9F9BmzjrPeNhesjBsLqL6RCibn9v1ER22KDy/Bx8hzXxfYTZBCBWHeFIz5a4Nwvn1yBHa2Vucc6u1M9cYGDREHijKOJY5Das5+z1gZGfiCY50UzMLi5d4IUUyAcN5lLR2pLIcpqYuCRm169cGnAsbYIRMfbPij/5+2AO4RgBnjynYuCQgrKB5p+8mhtQB6JoyZmicgJBrDoBk5pjScnItXJletObIz0MoFR+EyIyDneVdR9JGphE9ZqKgzdMOhjn8K9Kz79k8yR0QQqubT5vkQEq7OBTbixp5i3HoNjbd78GKorjxedv8zS6lgYZoAKLNunQ2en9/AlDaMwLG0HDBl+VwYJmO3ba0ATJyrV3ehAk0f5Odo0mIBxr+ktDC2GbuVtpGAIQiQk/+uOBSsb40NHFtT4eZyoibS1mIppIxFetAP+d5pjUAN+bciFw8wCHNM4kBGEyydvBHraSCfND3Bpfp/esqHQgCnSlUCpPNKuObI2OUB0gQ2rGID5t9DkMIHKg3bsTiz3tnBHaNd8kEc3xjMw/Wl6KTWlDzXPpTIeEJ7rvDKLjS6iCuGYTiigineLmwVSQHhWGGznpVHUXD8FJVRxp5pw20BwhSGb1b7qV+ZWDUIwkEvrhdaDWUv4YQlFrSVAsibBJ18DdmBCeDDcMlAKYlF7kd1VNRQJkxZDR0Atsuh1Ln6Lzd7K9fTHEaX4lA/wY4eSNCQ1f2XqpVzhNS3CMNzfgXZijPQKwOtF/FerFEkvLma451OaPS8skKxzP4J36Wdgbo+9V6eaWc3ezLRfSreDHx548AfPedlIR9pMinUsLGMXbtGsLfHbo0CSfTTYi85bDZaM7+W7/9c/nferuhvnzg+unU1gFVqGGxT/DUL3FuFYrCNXjG/tHWn7PKItoMofyuH4RA4bxcVHT7CE+p1B4SR9bWrzoaL5cBIzok9kkS22UJN99ppISaXQYbP+nuKCVwp/bX6s1fqgY0sur7Inz2OKDRWBt2dL4HXE6GI6QUwCrnmQkfPAfMQNSJWRmBB1AVzt3Ktj4bEbh1aqDr5bvbMjS2NRcqFiwGz9anFMh3Tj4gz4FGSv0nI7RrGF+7vNTdPRp2zzE7RsKnn8VUDYRDyMzbz+wBHITEP57mushb4TQw2Owf3AWHC4U+Y4YGBS0oQ8VrjFxgS3c/3Cgt8wwTD3cueYRq2Mjoo0OTNW8c0MmvTTV5i5IhLYA1NF0eTxJwhEIznyqo07llkhfGmoj9iH0ZBCCefmWws91ytOevyLmR3f1+mbfj+6d+3gmRyQ2ZASyOJPkk0CI+wW4y19s/gCVZTkj1gz6W6mHVRcD4dFq3yCwfmXRCprEnlOzJP1mx4ofmqE29CqYXU91THIap+x7KHmkifAldpX2RILavq1VbMtTyPfbtjZSzcZtuVx+F4pwPF39lqUTLi429xDV4szH5RbkKIF6f4hvrjkMgukyhTvj1UeVPuDkVHBL1jSZzyxt+YmJaVftBmYqhIAU+Zf61+zCecCFNuAhkpwIOMovFGK3yowK82DKzmGySnt47vsLWoNeoiDsqWGv9sQK5lga9iNmJrUIb1tfyRjJJcAOywE0BoDlbBa7ocIVnWcty4kdY44f3ZttmGGDPYlpLsiCe75GZQg7i8GkvFPmizfNEOir2RAb01G8IrWlzIOEqq55uLqMdQNgFI5Jeub2y8c32dta/xggGe8xUyqKcbk1MtZ+cHMyE7aELa7DeMVkdGzpN/k4f+MEtEez7SoXv29HrMexC8G/oUl0oNPcy0A+6v62M4pFH1fzRVCvT0VdrdtjmTqMxfDD+zpFt2ky4KlnhWJov4rfLV0ddN0XL1BAvlzw7xgGs0urm2cHdJmRWG6SBb8e8wJQ5F0gbVQjplsja4N7W/ZYPfc2hJxacSQJ3ohvENBEtXZGjeHhv9eiB35cvqcRXIZKZChNftbXyrMvtnIj3URzC0jSZVBbccPNcfPlMYL7FSOADw536ka0thlEPrC0qjUjbici8X64D47EBOuCSuELbvnETgzh0/nQjDVfhkTUlD4eRxumJfHyShWujhGbd3WPTKAbjWOSoexHLUoIE3miIT6GpNnWagpzdKxCGWQiM6y4qeygY1hYzDT42Q+8akbl3SoPn5zObmWdOcKQkQj5+qBZMNa54x603N2nZddrbUK0no/lIVDZ4XvL+h0lZkx0juf4TUx4xDgq8+KDAGr+N4nBsnMrDw40VciaqFyyM4vX2P8X8pgkj9cBDq742SNkfi/kvzOSW1wcdtYwDng6iVIZxeGJeMYBzl4azzGgEhHVdhLNI10qxh1XuppofW+ZaTSWmXLAqPfpRlFap5wUPjO1+wz3vh20N7E+hI06DasLa031w5q0Ey/XbXBb3wyS5xXD7PkP80rG77s7KhyK1pIEu38XcNrhjYExiwlXwlb8w3TzD+XVpMS+ajlFX1/rcfB+eQM7uQh5eHvMBhDtoae1V5NH2nuxO9kqLfPhirXm83DXVMOqdhxv9ofuCcw0R2dx6k0cD2dCmKJmuqrmIw1/KAVV8xnbYgSbnTG+/XhjMbOKgMQYArwjTfddX4CnbfpH3fgxjJnvZQTpZlT/1tF+JijSRh9RHO3Tl+oNadogbj3+ZI22dMKwXihSM8BHLz2F94CtWonepzP1ybgZG7RxVumH/AXsU9qbRkeZdBpbrP5DR6Cf64rD6kPaiT58TU1M7STZkde5olbWI3Z3NPNzVF1hEDY+HL06Mf/hL1w9D+X1Kq1+ezfbRYv1hHqcjJ+apzlptWNZEekSPSkDM4wcNORvlXcLoeuWK4bOcTGRoRoYvfJvrng7G54W8i54jsd3Qm2nXhd6cEJXkKFeII0cPDmtn1/aAqpfPW/C8hmZesBcZzZ7GyDLYFVv2Slo/Ul8XwggJNS2BKrnHlW4OrkmzCLYeDcAgayqEeHCbxYeI/HFK5sduzSEhBRq7VQleAPMavUym9UmCvFZ/uJGAzPbFOcTT6Ceo/+EAV91zXOKAdJ1N+RtEnRsMXLYt0d6a3tuadu0jc9O8Svjf/Hobj90xisy9m1uRRDlLBGRQZWlkcdT5FF/2ziZu0vIfGHOcZGqxHIhx5bWdREVTL/oFl5Ijh9vt89OpQunzK7oX/V4mSgJt3hAgiENpEZM1k+z55yfTrIWMKmQlras3vR9uklaCU3NVSdB/cH1+Yhbe22vga4zu/XnDiXyfmkIqYYN7eLiUtFvYIdZgH6+LUmKvAdGDhxIkYmo5fgCAFrtZDg6+PWzdzfGdT4UEAlWXdmIaWeAJ6q/rx4Zzw2aiGF4eoIKZgX88dK5EN0ISovJCmBtUl6GyjUKPPfxB2VPnX/E9+6TDM4GrIfbtVkTix/blthIrq4s9cP2FGjMIy0uyEBVwkuuUoQHK0qeqV7h5No870JhFZj145GzLqgtWH6mMQ9aTMnffjUY3HthnPgprZF761OI5EqMvlhVhjYIkdYAUe9lIKoxmMPWRJdhXulL4OE7Kb+3Xt72AWpwlSfH7TRz/qT8Xk2azop2xrXtI2v1FYEEFDTuq4FO3EhzXDYQlTtROHW8TPFB3ZlSjwVTVVDoGfCEHh/lj8WpcTDmXAuRHtoLjmfjtdx1CDUfuLLWk2chQHvlD9egxsVlX87WRNt1RuxjQxIPaS1f5fP3SvFgtcomnjrLT4yVx83PsVF4aMQBHSLHyAhtPcN92g3t9IJ3gacrxeILor7ScWJaCRyiWZ86G8hov8sCOhfu7dNHUCELi/aLVQcUDh+Pvw8IYWJxV+g5rJ+VoTvJ7KSWQRMVEYSkgRMVE0lwBFWZIUe0mC1wZqvIVHzSBNv1pI2NzWOCDY13me38T950qukDcPcM6dB88l1yZTi4WvIRZI9JWY1pKyPV9bop2FkiuUePx1E7a2vILBf1BtfaD4uyh14nGLvOGymyoe4qlmd4n1aohsB0lrpIWy8zOPU/yZNlImDKrxrpW4VB/ptEcQ/X0eu6UW+bbiwjeZPrUaLqTmI+vWjqzpRkaY1SzTzQ5satDbDtSpV2kNI5lO4ok9RFIWGuUlIuwkylsiFTVkGIZN0IBcY65yOtQVV5cz8Iv0VrfZgXYiLVQrEZaEVSTswJ9Qds8G2y4gHVyoWxjTGzb53CopDwtXMQkXTggzEUUR9MuRb7qZamc4QO+NuDSSoErEJvxEVFXjyMnAkWzaB6vUqHN/r9Bf1pNJj9Pfkfg1CVY1jZCgQCNIl7If/HzdcDg+OB17Zuu+qUTzm8tCya/s0X20X1inpJk/IcnWjy5Gh7knCTfv8o6QizHOx6aFeMc0ouUyDaG5DN4y/42I7fVQKKgg1gzynUmkwkj3PAaGKyrUa/L5dMcf5M7Ebzb4lXf7TL932PIc+Z7S/UMlE8aNi+JBFkbcIYL9mf+fWosOXluuZZOKwInmu/7oUXQemeDEPu0FBhpvXyKFOrxz9Nst4/PIwJ+FFhbiltfBJMZff07gbl4l/vTU3X8GxHXPTRHPOi4AMLC2ZAYdUHdzCYBmJG/0XJuG9jZ7vIAYR/KUG2r4MzfUe/9C1iH3nh1KJnCrc6FzENHZ9DzfULa6VNluY9wVPM0y4HgJ9QnEOhNzAxp3gD2/UlRec4nlrVyIVZlDPaZElq6YHztanNSLRXKsDjNgoTomZS07q/NQDI6XcUHJSNJyXmCuQQIeWwNiX1XbeluD/y54K5Mf7ws/zkRPLMLAv7EVanIna/dA6FeCJvdJei1VDFDFyAMBpHpAD1/9fPEXoOmLQslUW/J99sM6S+n8oZ0QLqVMYATJDK8GWV9HKzFYmxEK8YBzraDJNKdyZjvhoN5A5NJLg+JvFDxZ5aJeG3xTXwUPtuvGbBt4ExebNOjgDt6mF41Gy4sRKdmGArmsSqDvpruSF6Hquqstsdxg1yGi9g19AJ6ylOejsM/WnpvHr+JLIZip1zNI8IM+6JlzUioF4utZC9QEOF089NR5NOYWrpOqIEnfnsYJm9o4FwFzmQDfbkYCALdHi+juob84eClRIy4DlFoQHluzQe7B19oIsPQNPNySe0HLqNBE5KYWGOWPZkYGOyG7QVghZhbR0ZsMLhPl2HeK2h6wIvKsZAi6Az7IfPEw8ioiZNR0cDYtRsxJBpD4XwABWuUYN5HXcSECgqzPkhwDPNQ/twhlgS4J91+WqW0AxywfYkdk8+LdMc822ooN7cUj8NdhhM1lT0k5JzxDFMNAH6ZgwCHxmbzc+CXvcLcd+wwoH8cna/uSVc+AkTXAQqfViBJspKPLg6QgXFy1ApcvhZ9pOoPf7Q10RRnmDDQdSt9mnR10feaa9SSc27epNvuKnfJNpsNXxqVjeHIMyTllET5PN5yey4k+rn3LT4qx8YsDEnwHO1P08ABoxrSPfRlcnm0N9XyAITVUYrOvDHRoUXxSpDFVmJW5GPRrQJDyVcfeMofkaPoet06Szhpy/zmqwIeLD8AM/qlZ5JTckXnkBmT08CnQTp0mbFKn59AdMgx+5xgMld6fmk4sDLJlU+iLN/oW8ca/pK49Wfhrq5i/IQQW9ZyfXI7jsHdc5YtlXmYh6DYTimficdwnaPqFBHKeTvqFUxpN/LqrH8YQ8Qu6Ji5A0fm5y6UVQOxML+HWNvtggDZBOQe/5lcI+fecHuxV8C7vHvQ9xSYQ7+0L1XZJ2qy6KTTZePHDC55LAiyWx5VHzixT9Iq1sxgwfTCahJESnMkBR9coEiKadg8ErZ5HhTwK6jbATxRrdApn/oa/lm5449Zpn53TQxbeaBAMjJc0ANuY2SWjBbaoLfnl8zTuVDavHncw6juEVAx3ke7qS+GxP20Aq/eYI7Bou4htn4xal5w4DwCqj+UKDLKkkXSkpaRWYXQkn/FqQWTXeoCiwBGZ97OBqTjMYEoZlkNOcy93pnwWfDjWXs5p+SujWHh/sQEPtOU8Bon/l0T9mVVQ9M1AKJzJ9pCpKHG0L0Onnb6kq9+cD0qOVkg7KlC6EbEeW2Zru6PNg3NhCdZRvQRWEjGlREdicS09QI1UtPMm89bE+2XVfl3NFRG0BahbaI+uur4rh1jCGm4ceEhzXwR3UrQJFWT7uOVvorz5YJ6zKj0Hq5sM7JvgaaBzgJ/Dt6wNthr3vkl6+tdTGxItITHs6VfEZyD5RpqaYTnGkzr3Qzz0zJQ8rN3sn/hnM3wUKfOLl6xDTeyRg/tlHHOIcV+o6ZNVr+C12mhPFkINZzx4Ps28YLyt0Ep9Gxl50iYeB/LEZ0mXIkhYEopoDaMQd24oNWe24MLL6dMO3wtnqTaURhjF0uZmRzBAoxNIqdGfrQII6lGNRZILZ9N2n+SFCzL4obkxX+m10x5zfk8CKeESvGVvqTUfkHxHIovPDF2UU1swVdw9JHHTemhBemqeJBR+bbU1ql6rr2Pve2tepbK2rVTuBXEI394/DHFBR22lJv95Z4WktPAcni1lr2Q8rZ9w4X9pIznEwLzKZcms91uISZ2jQjmXTaxpX3nUAsV7OKF1+8eL5h434PSwIBZU5qDC9wlpTtLOLnbmthhd3wqpw1MgaaHmj4Kz31/C9e+ONdIR/yMhs125h5LX9s2+O1hJtLicTia98w8LoSu6vvRQavZWbIQE7QuHDMMYnJs0m6Izgj0+IGRO39JvyRvgkQ1ugQrakPmFM93CZ0xsa0AkVbM43IC77iTsVqsvY5KvKQvY4WwHG2BJZnWg0uEAWfxEg7qvIqCMOydki0Ri0H+WtcQRGjMnmD/0zIPl45awoVkfAjgYVS1KAKSvghEjKrFEn7L3G4gioSwt6lkO/QLlm87w4Q3CRsG/Gcavmg+s6NrUDH+ufQiRyfsrLzI5Ey24K+df61+6sMUWasUkdKcEayApeunfoUEQMSrDKMj0ZzfX9PMWRJYH5PdygXry0Lq2aYY5fDt171NEQibYGlW4ahhgjAXKUjMCdAU71CkcrAJjPBtrNjDIXoeujMgvr4me+ZqZgR7XPiMDWk/DBvnPSAdAGO5irKCPYI3oVgqu5fH5jn0d2Tkjz0jKkagkQ/onmY04nOwoEgdmSSviL7w5+5z6GaQF9kb1EvbOEWChwabNo+oUYt644aoPJgLbaAyjsbQn3JzLk6h+95OJma9WAjSt0MQHC8C2YlpgKiFXkYVZqw5tdq1B/IqheEuBjkGoHnRXYd6pUSd9s32NNaXZuQNolIXh0RbKIknCKYWXZtY3ytDK5dM821U3bVNPLu4XyfuBZbFNnZ92hoMd7+nwxzWMRW42vpRjexsO/AFEjhZXKQDEahhbvatCTjSvt7/GcYOgwAqcPLXk0HCooXoB+DeJYfm2xlqUsGXEn0oS02OfdFeyVfemzLSg/Ct7hUlCS6sMwrbYYkd6t0rAcLPU8ict7kjfug5L3kf9YMCrT5GWm2TGXMZLZ00BGC3fkhdJwi1zjXI+JWfQu6CYC6JRbwgObudglstEp6HCr9i6b9DM/VvKQ/FeYdn0KjvYcMuuDAtBvUshGZEUHX+rjxDbVaeYMIRWm83KS7Dq6IAhw8Z7Z4CgYnAKvBqnU9yz85GKm29DeNIxFl1Wd2Er1w05E4oIj+2PwSR9V+XhlvgcX5zCcBARmAwfjy0aCQjhASkzdSfdc2Og7t8I9/aXzrd6UwuCed+KMiFtx1B+s9NCFfNiyB/cyvSNwlzXa1v6mk59ml+O1pym6W14KWxVblnwPw6J9tMHyRYyvX2vIbTlEDZDRA6aV//7X/XwrJvSTOMuBqCErRvK0cf5IblczuL+JSq2pHHbgqrvpItF+CTKw0NkO/HLTshIUnYISiNJHLk592pRyX0J6eMQP3PHPVmL2HbmxcKYpAwDyL8trQq03bJFT3Zxlpdl2Mb1gjF6dIIi6OHscfTGQ19895kP6KildLFBsIT6I0keEevSFoFkEwkKTFeqmqyiWGbIJOk8wv8F11nzkjllx4NWZScJcAROOvN+lYWr4p4zXwnj7damply6xDh87FSsg3Q825AHcMFCZU7g08pTzHqVz3CnYJri80y+6H3JYDet+6+Ayg2cLNCs+8OBYdEmBL0bGu7swh5pHYOyphIg+h4a3+PjpVUiZbFpd7GQxMou5voesor6zR26SAR+U3aoq82gBZwMBardtubOzsB2mdS3p9VpfKdCKCCTkEQtc6oz5KOUnGLl/iBFkRbJdEyekzHWZzPb8yJKCzbhmTQwJZa0EhAxhkPoJQad1O7vRPAujtKrUnoZbWlQaXgkL39h7qwIU6bMjUefqv58luaRZgeEWLh+v2AJt4IoDqfrJMc6pNZ3pWdjFuWjjrJ6koAhjpTqjNngZusThrJIyd3A2BKIDpktF/Y4IJQlO9sCz3yXrFJAnjNdC/OpaEDtEkO45tAYss+Bsct2p6noxIk/H7f/dMEumSX/VGYQ1DjXyY20U201KgdePiGcpxFw8v5WTMw18lXT0TERleSYKtY+njoEghC/AI9/4433Bzya+e0q1nI6sZFfJ9v/qNtyxf+276I7EqKDBpM3KQv2I5BulnTjYLGa/jT3Hxds+moSnMluq2KyO8MEaHtjOqV3fOy3uTjHCxI/E6bq1I5GV4Es9qZbfNJ+rt8LTQw3FCpxPpcsmargYHHTS1k4UCOM/T3TGdX3copQtASVLwhX0GQT44pjKCA+nAQraIzeucfgmRRx24EhXALMKq7bX7RaoPmbCga6+sWNUvCpoCRzqexWhcatRtKzAHA6ivO27dOp+b4bMHIR/TqEX7aX3byxXIESRD1DzpuScbQ1z2zPj3YbkxS5nI61Xdlc1ovH3HnKmoi6eYLRXfr3PX2inKN9jsKuu5N8LN++6v/JnkKC0//ok11+noiTdxVGXoRKb8lIRaaobhjd41mQZgx82M2O1ihBjWaGerGdfMj0hJiXMlfAmXdy8ISZQnOhdZlqnw62cCznXiUtQWvn2Lq5wpFUXpzhhpg/1qTOEwpHY61IRBWWOV6zhqkXLyqr7Pmh8lQfVyyG4xim6OtLvqiFlkqN0zHmNqiP2VUQygLDNn8+9SM9SRxmRqkgZQr8hRtdT90cddSHQWDDxF+BzuAQOrOBWssdR975m0eLM6tjEN0lWD7dZrIarN6BWAa5P86pMffqHYbHEO68iFSZFzNVyvTxJ8RpZlr5E1GnANok6ZS6ftWbwYcJ+t8QMAp3KvdFE5D3Jn/XYY6YIcW7BPZiUdoOpVqNldll6TKOQ1ZUPisu8OhQ00ttzRxGcJKkyEq4QHbXkB0eymmk8izO8z9xK0kEvlrhQlPx9NtSu/pTLV/d58F+Jm7d3mT1zIflb00wFdWkHzicGZhIFgIspt7CrL5mX/K4YAzgTVe1jpNG5iOuUqZKw7XBeljvlce1O3rd6zgb2dmwY+/jK+mJri8hKc/Mvca71BgkpFpbh4tRl59df3uEumUiifNni/Kik0QtfCF9GGmSj9GFqKgSieA+LJ5tnoKW/awxq+IUP4mjpRIjtT1nYKP++KLe7dg/l1wsrHuBVAeFyp+GflxKP7YWHTVcH264Ng53sJN4itjD1xgqGZ0zbwUofRJRNKV7OTT25YDtDdYyXa+UtbsjsfgOvUCYrA0MhaMNQeJ3crcikL9lsL4hYFC+PmkAb2dArZWXxnDLhzf02moo6NPi/4XT8iUWsMpOnikvwr1yGJdpe79IgyVUtytd9DcTfCwTUZLW9iiokdG6w2jniW14linhNDjXLXRRwmh6VNx2x7JmRQNkjyibRSbWKdvjCqQlX31QgW5l7JGT/DTdyANWolHrlcJAEsBCWsMVXR+aTcr310WYS7oyJN7UsY45RFd0K964NWEEZPcwMXHkI5U1743GwVFTxJAeo9e19uSJRNILwBLckeZSJPVZoab3EcxE/9qkIKuBB2odASu9HpL5Ht8uuvJJZBWk6sGzSDppwUpBac3Iy9WpoG+4e7B76x47ENo8VK8JStkt3aTJH7pFmgp7GPH9v8yAw3VSE503KjAF3jgRG3T0cUVHEeEqsvkQPVtpZBRoPMiU2Lr/KIESqs23fU3KRsHHag6fVplRD3TZu8asbgxzmb9nGD1BCQd3OxtR3X0WdmuIqvmrD9GKmPjwaz77C3dtKvr4xKNkamcDUwNNCymxaTBA4BlGswoX59EV0WH9JoyLJVBymzdPym9XSEQmMUT3NyqjXebREY1Y+JGHHzkhb4B8yYEiE+Ko1N1QImmkQCL1WsyWETThIFDuz4GWS9ec7+/phVNFF3+ihT3Ckr0bkGmvlglz1sHhdHwnLcxNQEdlKMidGFRLtXfRih1qQCN6cHkW9HD8bWbu34elprACk0pcJDoXuO3VIGXowADZw34yMy2ii016NIPEB7+xTtMSOu4WhR8K4HAX++/G9zvGjRXVHakH0ttm1w/RdLe3UJKtCGvQtHbSFvbnh5+qPI9CDaKivJ4r/paPMh3Pt9rwrd5mISpASZgN38D/aTLc8X/KzbPd7uSX2lwoVHqXSUnNy2cZrlSkDu79feK/pmz5wgynub2h8eL01wOTOZ1UQkKDAWERQ2ryd+OAc3/p2M0Tj2nXY5WB0pCre1JiRaadsG+IQC8ikQXVCfkFSkoi450sJgchXaXattEN9Ss6KU8TT7T+d1Lr2nlryvEMbMio7cLVbDcMyPKZrB37rfTpjy29DcS1+Y99YBakWD0r/8sYzsQuzi2YdDcXifLH6IxUbPoQU49M3tP/w+cLt5xrLjVADGmpvHZfI2TDGAEFb/WSZDAdY+Bkj5UXhfnX/e7Rv/F3Nhscc9Bgj/T2Qo252HPKLPOAScx9WnzxTqyGTDQ5RAk25ursT+sRywrCPVdVHEjEhVWGYiluU4/bui3i5iesvP7xGLN/nAt+JVzX7bXv7R9y1m73cz1BT2fhZd2/0P/UfWssP5Ca3G40yESOY+DGSKZhRVNE4Awd/OjZkv7LhtTjJYQGXrcUz5rp1n/lkTnzPZwbhOcDhWN9nJybguGAfBPThAODKOr32ZU6r1FzgoAvEajg93RGdM3B88RSGsAzZp13EiE4S2M4usmvCg8JCAY6eny/GZWE4fz+5Wljecl+zy3ugPlVmvhMqCrfydghgn1goaT/PNayQvcHDeA0n37i+USCeRufNAKez3vLggjtt7Kbc9M5+RKP6ox+N5EQAmvaR6+jriHbrvnbolPCI3JFp3MxBZua87WsADsPVOD6UDibv18WocaYQkInxgBknxZ5Oy7Uu0q0wFZHNtGwtftWwkFGVPl/DR2tpAVVWkiFVMwYMXjCP4vTt1HU2jkTc5F3kfPLy+n+qB8sSXYjscVI/GvMn7Pw3WbrJe0rvyPIEr8qrLXvdWaWANQv4IrXJQ8HpBtN/kW7SrQTMGELJkEljRNwFMgnZlM4WaOt+Ic+9HfE5aydJvNFr1FJI/K53UJKNGz4Kp2sQRj5ZeGAxo2bD4LPKQwgiSeOX+nRHUIAUjqWuVJ3SSHpc3dEZ1m0lg/xUQf3VWREx1G6Y6xhaykjVL11VUTXJilGsEgI51aoHXVkXnXgT7SwJ0CfG8RqMFH/m0SKkMZ4WDaoErZzbEXpQYh4b6pm9S2vTauyvxdrNMK2I+WYELLbgiSKgpLr/6N54BeXGkQdnO4JnuUsPAwr92v+5GMle0jALqw3/F2Jz6mHJOv7Kntrtex1ezm0sP8CRE+yGmkf6IEOSwudMx42XeHde82I9Dk64arDLasNrOFsQzqT6lo9XPW50vUDEo2PxPmXGfipiJMgeheSoIS6ZMi4symiPa8ijF+UMo1cXLZUI9pccMs06eGKDSirraDZxfLOyOqNQ+5ZNVXDjcr+E3cHuE5cLi0X3rgf5jyvT9Ix1I5G3eSXFQqPean1qi4y/21WZ5q6diD71UzHuKusdFmcFc1uyzWJ790xCn5SUt7XNaKkHMUeGVBfHrAsSLS6oNnh6w1K/tjiho4apSNgg+vYKNoIL+E9iEGRpd/nWy5pjEv4XlTF4VKrkTuV6Q3ojP+PBCN0Tb00u9tN6lM7EdttBZrQnmAe7iMYRmqArJ2YG/CzdayLBDh9vigYcQko6urB+Lun7qSNnib1UrIlNU0Xx+WnAzKMjujA1MR5FA2U6HUpu4xH63jbnV+K+CFeX7tmsRyik6mAXFJfVHNhnovc7Hsv7aLJaX3ZG8aGAbCXfdafy6v20qJoNXI3dnRfE9GEFQebstGqYiHmUCrYkBhY61inmd2yM3QKkNZtfja0n7AOxyQG140UpXGU9GQ5jZPHUEcMWhYDn6wTKqZttAU9DQZxNWA+u9mtxzMwGvG+Gf8+Q1rQIVztQW9g6eujpsXxLmbfeSwbVGSGBdGnHC5fugIGSoS29qkG5npJFNwj+hj3CEPlqpe1HoMkbzLu4JQfRtAf5FmaXrQK+BzMv2ZOTFwiguPuzDA6WkEfXryh9F2zyF2H5l9HMerPtcvvCTLhTQf/njmBjTUrqWioMUSfkc4EmWTVf28aERc+mP40zLqDUBgXPP3eIscGAykQWFRlsJhO3axO2QtvzN/eeXXegGwmtDCPY8tD7HyAjj3iNW+Xf9s5/29NSa6xyPhbDIwkeh/+u36QuzIg0DeVxFU2c4M0WgjP4y6+WZsZL8zNDMT53D6yoOAaaA14ciXmh8kxiPGHgCqgoj5UHq7bTMmleFLViLiygCUUKOpwsYf9wI5UoFUQ+0I7MSnRvOm9s7JRhFgnH+t/eQbWVqNMhOaHqCzTkjGOf4TzTUtHobnk4ET6xpXTsnMxnRpjgK91SQx74Vlvuhp3sMhgw5oddJ2zl1uZPaUxr41/1iuRpcphjAGHB5NbLwnqli6V50ELy63V2PnvlG3m65v7HOjT4IjlhMhvLaTU7hT4QUZwd4GMiTHEI/7fyrDtt5+pqSWb1Uk+nRvNDcf4Ym7pTnf3RH/++V4P40NPTFlxFQPrBQOaLKcjwdYoxAceLmwy8oL3hbMebYAPHKWL3B48xhKRgHOT4ioxzFDry7ZmhpbTlx8F+bE7ff8kY+nZYHxys9Ax0bgSUGWOvQRTJ+Jf73oU4WnlthXOEZQzNCydNv6UJunV3cuBtC39iRduBn22kZcK/tKIDcz6wTHoScXiHwBmW43sOjbtVR5CWRfYrgU0nIRespWg5kSp1//sOS2qsnl5T8XCBCdl4+/igUTroDp2stNYiICAPjTv5fQBSKdQBUdITcsJLzHp4zqYopRcxu8UjLbZLCNAsSKqygEDOCTpScuOUSNadNR/IqeUWtbn8f6rcSTOZ/95RHAp8NOOVz6DAFf7YzrnJ4Hql+0WqqItBdeh0oc0zOD+4gara9XcTOA5pKm1OJxK168s/YO78etlwaNltnrIn/58uHS5By9S2tkETNs8GUWL7gjAedXT+T3FQb/WDUoEmIc0yGg6n+vvDrss32wAJGMfFLnV53YvEUKqiD8Xke8ibx4S7AJXKhTKd+LuHBHi02L9OGBaqRJ5qHH6EhDO7XceuZuXlChNAAohgAOkB2hyiWZs1QWps3xq2aNig+sqaZeaDcjS8HmGZUtCXDM9yX47TjbYWuKfyn7OjE/a9vsXiqZTRMEoGT3YyJ6XMO2dIeAw5XzuavvazMwYDTANeUfTZKScWJSvSQeewkULYRUNKBmLt1cNW9SPhO4rjer4pUxAI5nrpEGB9/JwEXwOzx9nMC9lNIDOI9u12t4xLczuK0slwJ6DeapdQY0GClJlTyKtPzWz8uC9YsgeHyFZzJtYJQ0QIYdqYkR2yHd011e92SwSoskFIMIVOeY0JEJDedeTNg5Ex/6zCvV+C2QtLd5IoSW+iowsJHffHVQFh+8IvhGYY5Xbtkb46+mPxDGvWZ553e9RtrukfxzgnVaik/wpNSh3I52JEBzo+3r6kl3RSnMH6sARrULk70hGQbnxvL1hQPMdzvzbPEJBhtb1ZC4wTyjw318qLZ040i9CnwebjPOjMJDGNysnc2aFwGHsVN4yCie4+V6azMjRYBclihjkZjeG8drTtydqkqK4Zf6o81TfPHjFdFbRbqmv4XPFZG97RsWMbzJuIplnMGr96UPq1kjmgcz3O9s4k5emNEVsR4hZI/0SXH46gbpAhpfqFZkhWF4gZmUP74czryaftVRjiAteZGrtSVdfkAI1KDSKBSnJ4EXiJfjSwmZD2tcwsZWn2XiEE6/G4HXrsZYKP7wV+AZ0077JT3rOX5LSuN+9ktX2LUR9MizpaId+pbMwSE+d0E1H+4Ia1sp1suIv7eQR1/Gl+mDSg/fUokxcIC4R16YSboI04yU9ki4206X9qp6AoedscHf4Q/8SJwpEYPpGUntgeaJ9Kbo7wXXBH7SuTDNjWpTEOS1DB1Ed2LVyASbOzd1T+ma7PqtAVwN7TUgZWW5kUV03nSk4n5+GWXOhbgnMxQ7Dn0j5nKRya4NDV5bdlYqZ72PEDvR08H4oO5bBciDzxdT2UtFsYjN50Q+10M/Qagkqkdkf0r//8xzYvEUBcWqTFbIssQWou9XFG38DHX+LOhwrIPpC+CmwTVW51+GPEH11sGnRDRWGpRWHY9s3OnI+EgY5m+pBEDi20Zo54MK/NbWo3BIlKtolnhAMN5BjpMpvEawg26z96SlsFgipmkGgL99TeVlu/tEtTYC5VufQSaYgeAQahsBPXFfQacMxRTBgcVVSpl1gWAgqUo+BkebKjeJviBG2xrz8k042K/QoTIJzEy3WFI/qqXx8Qgsa6Hkb5jyIXRiek0fEj9x71MMxeOsq8Q/n6oo0i/5rP4PdIy5cJyZbbGMc7PzVpFg/B5ksMSTb/m5d9xHqseQtWis6s9KiJnf2UGje14n3F4gDMVAxEnDQUyhxVZgeAhb0cHHmhpGVBhoPP6QQG56FYM2fz8wF7OoshSYhSkDAyqJQvc4SE+xqOpGfEZBOmPET0Puap/25GI/cB+EmzCHBCf8L+F6OTGwrdbYuKwfr3gLKM/BVWQj8lo/M5/tbY+00AJa7SJUZ7Roqycsz9Ct/4IIGzRcdleb1TBZmgeIjgRgGPP7FNp9jxj6AB8q+p/44dqatu43PIvFbOgcBmGc+PMpop6zd92y68O76aeo7blGdF60/UejSz3U8wnb34GKIsOTjAEIlmE01MWS+LUbdpnsfvLnsNvXa9Z1rz+N2PrAzpQX2J0V1R5VtOV5LptbFN4LMBDAMjPdlplVA0meRHQyY1+YD7jEh5dpd4fNgVX3CMGL6C0tpEi12d/Iz1E+K5kd7l+6LdWFB9V0O8dJbb91aQzEISJoB/xa+EXONyUGxk9vqs0mH+7pHoIi7nFrmU8IsQXBVEMpTYHyfHz3nwiMn/LyM3oEN4HTHIX2X/JIN3k7kvrPUxeUa5F7iqwzm1hbqWxNckto1cOl0GEIRCLe2hBLF3DzISg3uk1CZWzBy0+/ClJRXG+vGKQdGlJFioqcv0pabfI5Ybh+mVaNoRhWd7F/1clk83sWx44rENYJ3arTp7Vlpmr/LecnT6n4hnGDK1a1LzhC5f9hOlJCIHanAchJn0TA4LqzkVLBslLvzBEAxNbaAb2K8/0nsKbB4Egbo+6TVhNgZ+0WW7wBNOCiB9vRf5+goGIdujW5P+rwi7t7IlYnl04LSGhkA/u7M3fHXARcLh8EyFywYkjqKHv53nqGvfjshGIi/xoQEfj3dOb5ABoGRrsNQv8ltEMmS94TNc+kvnLJYmZWPmMDU0Knh4F8wAH+SCnGr1uYq0SpLYLuQaORaoSt9mtMNCpTiZn8ZYpUoHLX4mOGa7P4+HPWsmOOFxYXOQdTr4hbq6bCfMSmkzYV409QJag6a8f8VfDsXBFVjQzlDVU8hc1SmVCrcapmjXdYEAHE/IoL2GEkzsHtXLkEbb6HKLOmrn0S8MtA4sOWZ+1umoHGqmren0mREFsykDat0y7IVU2C+uLjszq9E1ORGuIJR/oW7j1i7ExdQQGMnFjfrg27GnqNvB+IA20DbI542FMfKk/YzDa+gsMuMZPxbQwUjkLQiaecaNtJmjrxq6oO7sPjCxB0W22zeN1cR7hdCZFxrIZn+6aDqEMmnhQRlo0xt5NRmXgWLd0mkJIzlTjSSdufKtap/SdUMFZ0JKtlpjGtlbvOmcmZp1QEKL0skHRupHhumUtFIwtf1jDlAm40xpO/8TgndNRLCH8cgvRTsbYttIQfHlGttDYaZe+BZo0+QWa1FoMVyx6P10kye+wO7aWh7NG8Pl9LylHsaOq6mrQjva3sN0lkgDgGo/UMvFpV74bv9APn5LOy8sGoRq4Smb9BuGExAHR/JtGVlHlcS0isBj2/N5aaWoJPz7UfndMwXhRDiP+Fg56/omZqkRdJhvn8eo48YzgTa/xZrOliuqGpY0c9ApxvPGA561Gk2K0bfthOe/WFU/RbUIF7CWZllg1sLA0sCP3xhEwUxnR8s26Yb4C9kO795bK1qUJLM/KFOEZvDdVWSdmjwSQghejezYg06BZQ+Rs7feFXJE9QObK6zBb4kVzFjGH0C5xm8D7Ll9YQD7m02EiXMPbGiRfQLEwdLTmnTzfTeGuCh7O06TY+juBI3s/rgn/MSWuBdKPj/4MRIFDqsl/+Z5BwgZhoKI8SwnwNvL/JLkYGS4YlF05JYAay7rFagJaePd49H/Y6PXOXLmXjkozdiN5qI12ZrPo7FbibUHZhpqPRstllXPkOoZLLBID10Qyw7RUIHJdsTL2MEYqOsnHIJZUcY5RqEmmMVCiKJijGpZRWfAiScvsi/e+QCdKH1kB0hhG5XpU9Iumh990VOTnYo4tS+0Eod30q4FIhGoPtAaFOfUDslaGSDGoOfM9GDFjeqUyZ/gdQV9JBRAIFP4n6HBzA/UHgzf+ufVNUwN35sL8/Mr7E/FFNfsAKI0nfGv0zFdQoiAkmcQuPdJ5CT5JDSU1uby9aMkZBIH7LFy7hFQbJTfyBa1IkL/qUtjuuVX1RXTpJgA5yugneqQSlIo5S8r08RvZGkABmsMJ3A8ojxC4oUOAeLNvrIoaFUuC4uyrVkttNvUycUZFxywQs/lbhNvXBlW49bh4VqvvS3TbzvwmBvOV1KiUU1R4ytdYY5mBKf3dA8N7ZfB30+HV8/bxtaXQeBG06QTnLGInci0mOYbGa3lHH9ciKNcQSXVQuBxhnsoNgoJuGuIR1jhnnCYrIi9HPKiygTUcc2l4MxfGQRqcvD3tOkbHPyIeoni+EWS0ccgRwXqQ8jn+OJxp1hBaeyLSM4/Ow2OjMy0SJKh6qN5Q5yN+BFKs41UsOA/blfMGd+bHXxdjLAmAts8I6wperZwImUbtm53wbMLNgojJCow+CSOicembv66W3uDdbEyom1UgFSeHwOwCjAVqqBGijIhl/1qHtA9qkQcdaBf9LJGvRU906xdz/p0Px3fC3E0l0W3t4Ay9Wx1Git5Bshl9kxTqcLQz6nBlEr4IXHRie6TmVwbwnQVricEdiBdT8w5cIu+yLFzFmdyDyN6sis/s72VqxyR72o1JRkiLM/jRnFNTr0LwaLPBkwDgRsQiANJaf6CKui/BaAoSLFTCvNtIFbx+OAKP9+hCZAXljWlUOWH/D9lo2dMlSSvhwfD+/PhDxn1jDqW53kO32Uvox+QkeB0DnkfgEWtQB6pPRF34kOoJGEIK5D70E0YJarFXbCKtLrOP4BV43Yyl9zUCuWZF+QJIweNPFB1UKkpFseiEfndZPF8zWTbRrsx2qBKv965M3lZFUf/1sC8pFwTJwfZyMb5pJ8F65eEWRSe2DT8DUKiENkLslCos6mNPpG2gg1w21X/d4/2j012LxmOQ6mMzSo5a+F/Nz1SoTHR62YTrJ5YZ0UMLynsyib9CWMVfN5sk88Wx4B6uPmrnJ5ESwT3/Cyr9VvOMOmXYLe+HOzRbEkvTCkEsmtnLF447oN5C+IjBVGOhQTRpkI7GKi+MEQdzmxwc2k/qIySWgMFB4WnW6luNj6JXA26XarE95EMmK5rbPo6YsAH4HZ37X9eAEHamKPsajWtEQp1/1AC1BvV03uIGJna4oQsmUmkdLHZgydKUSvMbIwbkIW5GDVCxCm7uezEqBkcx6gvO0JOIXwaoK7pDhyHKYK235GgXhLP9DlW7MPMaPFjFqOXIOCKRGJaN2oE9F3CSbSFFMcoQK7LpbmO2gco9ns4AsaZTzmPet9y0tqnvnF0IzhdMquUD33QIQqNvxk2FjbVqv/04IKVgT8KQu/cL02zv9PqdBYVf9E6eDMATBn4zLnyFnDXJ5oTjm6tnJZX6RiAyMpPVRuyAePof4WssPtBGEeuzGGZ+n0RUVIqDaEjArebT96Qoekw15GnRvDAC/oAKbsftYqspa55pg88oFN8448x3JQHoIxp6iE3c8hJFyCZVGpKQmgXv7kNZuRGcvhbjwrHaOpLVDLtMm88/mZ3pI4fdVf2QYqnFI2jM0O8/wxg9zKKzPT2HHEBiy6O40/k39grWZnQ1jHOMm35qykgbtfLGuUKQzTTMQnvOQVaKF+YLjHsD2RJnxUL/9nvcV6HfcGnKnzq2Cp12f7gOnk2pe7bbs8vxfSGmqflHIoj7ifA7ihyDVWHl9TPbw3+pyC2788mbpYeMeOqxA2GgXdgB7W+rYZyNRQjrFeeKD9O570X3gKSapzU6Hpx3t16AmhguJhreeBCrodDCaj2UkIKSiUz14IexwZlm+ZdZ2+9UXwmIpaHntgfJRPLZJSVywElUeF8jYk5YgoQQDBNvsVweuTOcZcS2bPcEBHihHJuFNa7tOnfp/X0t8JyMENwDFnahdfbzTQDV7clVAEYGpr74Wpe07WuZ8pNi+vL78AnumvHeRT2MTzPHItfY/OEz7VRi1vLUVPoPZ1ZY/4BYFNDCjKUDjgQS72eAyqW2ewVJU4pUK83h1vPLLdiC4Lr1kPSNataYQV6Wn75mb2gJU4rIM6cKezO3RWWgQdRetKlVeOQZTy0XizqbLRzoEDUGUY19SSQpp5iCF5f4HekZXMRF6YeXn0MtkRlC/ufesP8Ek9eOjbHdzDNzDJFTscZNtVSwDLFU7pVzy9n0PQV93Gm5+UNLuPOk2eUOIzfb3SQElz1Qt5iJt2wAI+cfEDvQROSu3jJV/zmcjXlJhwHHG6AfYTyndH0y/xnSEEUdjXf7QYE2b8x4yrvbFLK+vAhgedPCBwAchKtp5LzFoGEvojk0BLHjXnHnq7SFvvdIi3rVl24GchRjRO2CXYYU0njUflqYGK3I7MUuRa3aODtFrWB0T82GxY43HmHdPeBKJ7e/oza2l1LjYWF3oVs6Re4IxBAp/YZaNiKasH+Ia9kljeEbT2MlV9OW0rmgGxcTsc9POw96TNGeHfSwI8qHsWHD2Qbw83/18NPM1ZIDV0EOm5MUpmwStt8YuTeFwgDTpYYMtBrQA8s20dB1TghGAJKe2Pb1SUzs93bgxBTFdPn9w9nw161GxdaM34/L+UnpJ+/hOvIwuL/en7onz9QhONh6SsyBWEWYpc758aUJvJ10KzqBxNxIR0EAlyPAwpET3gL2UbaOKVZ/yGw9pIFwKdrToRJiS35txEKCcq7tjHWL0UmlJ3DtpwR9xfePucmU3rDWssofQl4Ht7l/k2Pqkp3DpDgFR0i1elOk0b1WrRcvpSs/wjTSOxko28agXSNmX/CmI04Nij6NSiWxDdepXq+uNA5Wde0XX1QN39Ch9WcQmuWbw4PpgWcPQFQrTvrT6yWYgN7K0vBD7O+Y3bTpmQksaYJyNOQLTGyKE8kQn/XtcikxojLwm1YT+iINxketXm2kziRcsRPwgQYUjCEZxevSUcZ2IB819H+pLAjKVdejqsEUuJ0n5ZUd8dQ9pysZXQQLt/OvFSGzOlja9o1sPF7k2gFbr4dAnl+ZCi2W8losJBTbI/XnQzibnsS9UgP7XENpkbaahn2q+/+Qke6he7NYHXZvXQI4N3U7+1DaL8UIAPOMW+Q1Y1xPX5DJTfjBVdDHeSSt/oD5MUIdl9TQRk/fkX0IrWd9+qpAcAXrlt2Box/ZrTjPbxXckasBG9Wq36UgxcVC3SJaAjQK12ynow28JHbXp911ZB0+1E9gGEBR8MtU58q1P6G7Pctkh+9T4DFkbJLFIDz17crm5ByNfomL1gHGiLvNBlvsMf7+Tf55g11PNs90ENET4B0d4YtG+PiqUAdfqOeo2ZDQBjuh+qnZGgNGV3QEL02qh0DRsWXghTpo+BOGq/6/xHcwENPulFbC85jqdhrvF4hfhuFufoOOH4k597aYlM9KlvQmVZjc+0AjZgA/B3fqX8tFmfjwo9mFIUDZNr9HyiCSeIzOaHCYxPOq2zBLU/11Sr2tXmQcLDJXl/a5f5+Qsq0FHRs8p2w9rVb01GE1kl0yjRGAdeDUDOLR8IAym7BgN9FTuvvsU0Edph8Nu5fHKk8KLoS+9aHGlhduH7en6heL4r/tpHaXim7olcZJb4qjpEAgYM3TVnjPykH8SdrA9HV9P7XDFEq8CeWjBTDXglAj9BRHjiIBrwox37jH01SrDIfUPMWGOJ3tpP9iRDqyEDLEGny9xXLjW2kfaoBxgbVyZF/ViJU4OBedA56RO5y6NghIdMt9Q/M09J4jtAoxbVnYCf2cdWPxOpV4jYoAGrA65+8XA1cQGBL3DxlFcxArrrmThCqKZ5jrpD33TSJ7NfCj1MxKrs56uLD2dhjriXQV44FfcQkXkbIp0bPzrRlO2bq8fkn025rPPIw+5pHlCTNneFJjG+evZ1pKcYWlUr5OldbTb98hHqdB5Vh5MK2tb9gQSikLOhgLKv4pm8TG5FNOEe7+E8BBs/QxgZxcDekh3HzyqNHioSZY0o05jNu0LYyFPI09mT9s/g/D4Aa+sMqneg9kM2VzpQcyUdEkb8WcdLx1NgXjhmVqSB19s52JzVHo+74ZKnOb6dUa2OaP6PaD1HxzjSPatYW2Wl5pE8FyGw2ugeBaxqjnsKEHq8G3jBQY5TUHxJpz5/sHdipRCm+u/34gf+Ds2aUmWcUSya1BrQvJEZf/KRmMZcUGYAFHVu512Tt6gyaxFNlx6t3oEppzLqi+p3+4NELYiTd6lWjRHlIp5nTw/7kzRm09EI2NXlfiPJCpmc1rkYnVQIqa2uMjmerlOBZZSPIPyZ7iMKTTp6KJNJ9FZVnFhMogLYVpuEFK1ELFntDfhB7LNNag0Dm9/AZEsnBE+mp9x1CqV1L+t4QSfJv+nhLFZ5+ieA6cyVSa4YrOzzwKTBCqf+V9H6R/YOJG1nqfOcNY5HrqCv1L7RSXRrO0cleidQkppm6mDz5dD7KDqZ+90QA22gUBx8d9ZijZa5W0/o52Zw8ITU+bnWBFI9ZN/qUfeiq7N8SaH0HEFQZRNeszAYRRDlGxyP5cgZNn+rR6jGZdPpQumauda2x/FGKhSU+ieosY+/h5Yz33tUqU6bTzpCoeuZLDyr1WoB/U61HShP9Fe7Y6ZVqfwz/0L7gvAU+OWcEigdVvwgkDncsZUpQ24gRAXKCdquMR5gqDz3ae3aTV+7kC0Sulj/a7i4/qxwIi5GPaeBHUS9a0GH3JIqyg9M3NWYuEitoV1/4RBonOSyibSWq7hL18ppTYnCTNb5dOa9hMmu4EgFAdKA27evHn8m2A4/SWbrn6JXw5gsHYGLeGMiTuFtBJ8aibYXsYnLey+zIKaKb+eQio2hmWcgo/boZjmjgYEmjYeign2jRM1CBrPZPNEbImSZJ9PTDav3iojDMNUoGZ3AajEYdhzry3ypAai5GzIw7rsriXPvTgmq+fYl3kNAYLfD1Ux0hzM4pMXCIdBmmJaPpX43MI2vdokd4mkLXnYz/hgiMirdvrS3/Suyt/mJNRhRQYfQ2JnBw+gflFkSgNkWxNaaiZyJkFnOaEhvaKDzgYBfu/AqmVxU1aJkkjC0tlwoD/NAadu6rpQxXTpDV44ELWSnn6dT/QOtRl+XHnm21+8v1LxGjaF5+puPUO5TR86jyasgQvq2oxPJ5J1AIUWAXLd+PgpuIHtcvKeGdJLSl63Ct3kPcmhpst1SpuIHHTvIsbP97kSCi0HkW+XpUKI+uDTEl1rTCuq53JibCY/xKbUHUlMseEtn7Inou/kGpqhraVUEAcLsYkzm/zyuepm7ORQz0v9uibn+kZ2CVcd3mKFPFsC6taInIAmBtguSsnFzbTfda+wRMo2315ka5rUqLlM8oZVpAkGzkPcxAm3GqnCmbPaXq9dNxrblqS7TC6DrdABu05JFJLCdw4T1kaVrXbigPj9Eh/GWVnsZAmKrqsOhFrHT1a5no+EbuJt6qDnV+tzNbFQ7sfEcU8gm9HAn3YUGrR4zAjLPB0/2MDxK35g98knnhRGvBkuTN5m6mVCPhVaY3aW/DjVMICp26eDrTEl4d7A6NobDwePgACB3+4YDAUjoj7Una87sHy5+JldaruF6txzcWxSJKN9qNeWiiHW0gnKbLQDLgA3qqIP1Y0QqQs9wlTYXcS43qrJmR02BO5rOm/67vpAewKTOutzs3zaFs9pipZlbABGnjgTkYxsq6ARiz5Dssfd6+l2O715i3s+9xBmjuQ9HagEX1yjLAGngKZqH897iE8825gBK6k2uWv9fDc3ZtnnCi1wAwdOowBBhvC29sRJRVbkwKkP+7GB0+lfoC/EZYZgs1CVUu5816H2NULzIO/oOdeffBM5p/k5MxjmMZtGSb7VpRy+Li/F9lylJ64F7iss994YAEvO4CzSCLtYuhXsOVoViTzDic6FsHFWKgbR7+YUhxh7+LULwHQobAIR4BU4gsIwXDscXSpwTtQhmyero+ziG/uVpI438KJOf/ualhfEScSS2uzzvgrTn/b2y3E+4rvIr1zYAjc+7wm6BMihWlC4Ggtk7OQ96Dkuh98z741lCsZ+jVCcMn6GbW/IeePnduoZIR9dP9ndUGVM72+BbT/G91FigyhBTT2uMqMFUS5gQpotWsVUbWRhuRXzWfgjJ2fiqj7N5mqQjCsMlVYiPG1C0s4eUNbKcOmE90JXdlUBLo2Hn103DVefsXPuYkZpCUh5+jgT7Y0rcbQsX6BN/kMXrHkpsZNBswOgWknPZi4LK87wueDs5VyKDdi2Yut1l2Wg4kCjKMGtf4JAhCC75hT/V4vexK+aRGk8Q+cdNSW2gw3kdQIzeL9opsBOu07c17JFKPN1XQURoyqwecESQKRhdJW3u8Q7xRersRmc8bgtfH+CoeJBSwBdznwQPkKNrFdY7bnHbj7wO3DuebG5d+D9S4gBnZ7N3E3+S3qLT5e/L8LHa0ZPi0+HYLPwiAzbGzdkA0PAW6dR2FPjQwDq4jwFCuwD5Z71GmuhAZmQ5on6niUIi37wrsDM4aA+iFIU/2Z6DD93BRaROU76/m/OMb6T3A3RV0ZMdbqFMOA3kkNMppgJ4/tEkJ+YwReFBh3R34ClCCtla/swelZEZG4Lx7e3MUHJpNs8qhGP9m5st1GDAghDqUKB6TIv0Qos1bv2bSjcSbU1sEBB7ktBlRGT2rN+NzvNl3Fv/Q5at+J4NIfFH2IQzVDcpwKYTlkYDXGBj7K8uT2KRHKpKwvyyonZPNHxFvf1neKU9zneZQAI4EDhqMY7zT4CrJOM+bV9fgoGSS5J6P+8NDAbRZZX5MfIwG6ZrJs97sA8Zg7rm+FoOEUXQObVSySFAc0HrPO1G/cQ7LCOYZGaH/OXP1F7roWR1Qh11S6nz7fVUQXGsbnGCHG0mH0TfnEwjNq7rLe3AbcjFoBwSLVw2n7OtwxJyhiL5pF6ESii2kMF6JVgVdUTR+rfUsKAvrMQiXJCSE5cZ01iPlgIj1epX/MIB0mMWCyFJnoNCxcclSZYQCPvaU+/VSCnbThNbjVxPEsM/g3R95ICrYx2XRpBUNEwmMxgw2hG+OyIcOIeQPxWpOR70SR33FvvROo1bvb3USjSBbWpgWPGJLX0S8jgWeZ9kXgeWC1ryzMb0eTjdFPIw/OlqpHidToQW6MKdDKEqTN9zCkOXrOZchjY0kozdRqETDc6nJNJRdQF4zJ74iRCeZOMY6avCwHUNQpbaTqj8GjFsfNSWcnDtXMqa+m25SP0MyJ88VOo8EesD95Qea/qIKWzAZ+QrbfLl2zedqVYnpOBDaG5SmIAxnRcs/ntCQag5xO8f8dvIJiYE2PXcao0ChfgoaHjV/QigfTuCyZ/L57N5KyIosEn+gBwyJX5KgwgBDu2s6Oy2UGIBjus5D9oi+QNhx7ZNOoJ9/J8V85jb5lf0LEKC3hf6LWTZ0ssCKalBD6wnnW/KdVZjkRpRDNcpvKk8MuUIz48NTV4WBB/8YjkIIkjdJw7b5fSliXw3ypciZXm3UEeTrMna0pF35Neax27IKQT2KHnA99ZTPMp93YMeqkwF/qtkwJTnNHelabd75RraxuogNTDPsY/2tC7tW7BVHff7doZjQRvER0SN5ucg2LVz74S0lRShSdfnTLpgy9GgzCH1Q298nyezukLVr2XAj6uMJ7pZRJmGba15ngIg/3hbW7cnqRc5P8UyIDnB9f5qbqxRw+c/LU2eINrHBriDp47YIZXwKf1zVLli+fjDFZ8fbZEImYJqCeHFyu/4UHQBD0hi+TUzdsn1XB8J7ddP1orH9T/qZ5ghGZ22C0BBlV5MCBOLkkZNmGZ26ed45an1XbVAtBbqG2oNeFT9s9GTvy3AL5dFAIzV7+RgYuJL3PeQZLKv41J0qKPR4PWllycpd85nXyKpEKZ+DetolDf1FE2nHYM3YhYmC/0fjryRTYFTEMy+lyGN07k3Wz6HR8Tmj+f5ZGjwk8847PAuGLGVPsKhTS6Qqcbg6418m6A3QPEOAoGqBuZGEZtuh+STtWOD+G4z1m9WNMd5KBUExysKbuoabbgApbI77xfa3SjMTMhyCArudxgTuCs6Rkh7HltJF/2IXCTc6vuN3BfTd3Pif4ORgwnN+3E5VH+rJwKsw3BneqQPe/OiSMVrQEFj4zvMaZS9KM3MeTdcHw9LShQkXxWjtAMVAtbAeOHwz3QSlzaxhfngo9uGs+Q2TSM6in66lXzHWlXOJH2FXWXzgdJb83/j+lxH88EhBIvgFUSQaVOO4Pq1rGchIjBp/U7y9lJHDrX08NBrYQiaQV2h+77jGsB7BUQxFPSBb4ZxA9m8l/ACZFtR/QJuvXFKJ4OqE8gtWstcmoHVdjkRQvwg5NWm0zAdQVdhfZiqZUZHbYCjKjFn1hiTWMoG1l5jB3C51gd0NUVYME1xNfUlWFKbcsawlRb+EyYNo6gguTXXQy6uGPT7hlpp6NlPQesQLBXNHE1G46xfW1BpLoTkt7uQRXlUe+fggqOKz3TJr8gPPHydq2ltESf3tVoiQeP11w7IPWu9QjIytqSzA0vSK+GKvSN4skF4CvORfqF8RZevcY9Hq0YEt0gMY9ZtiYekYi8p0GlYcgTW8uqWsDNsWDIdA5sLQS+Yq6/eA5Eh9gNKYeCeB3Y/aDsBff3pslP+P9mtauf3Fvf6M0RGaOXKcDUBawtmezL00YWaabw0AFskxYvE7wh/49cDbT+pUzHbeWWE/TEYSGqqOvRYTvDRDlAQDk0d+IslM+ivBq5+sVp1m2NkCbdqzXuuCeKdEtGtdHaebuWSws+IFDX3/67gtywtIH7Byzw/isuAgkS67JvkKstVG/2W2RsepbS6Lat2C9N356nlQ6THl2h6qhwsfOT0f8P/G/x6/TUfEpRNyGfDFOKm2LesXHuLkq0voUDButeP655V7uNoCHfmnevKPfQjBCFumRoQSP8/I5mUrY/rAKDIiShB0dDK1n1notRolGcSWdA7joFHNWzmUeWK1Jcv0iUeuMAkuDPv1YGKiqRnVBeagwBqmXAtLJQVJ12Wl5jz6ZokSJ3lLrQtiP7n14/x+05y4pcS2maSKWDTsmnetBxYcHmr6d0p1Ndf7U0bNgsmB5NdbikLAkRFkuvgEhAV+kGh0dFZ9rJIllqALX45p1BI+aRfWOnaQatoSS5ooU9EP5vLyhg4iSmdc/kESXLG4dfzv3XGZW2OFT9+Q7GEHcGOpOYsZqq3mKAWLC4mykx/RxHG7JRDrq5IQL5ZPf/p3D3MDZuOIYQ8bOL6lC9BtonYptfxLJ3URr36P8rW6wMu+MsWfXybUF46bRtO9U6q+TxQti9pqXXRHJSNgFEb6NSaXMik5eCq0xLlu5eeBbtdm+dG5jEoZtQqkFZNKtp2CdhITsaMwVHYjVumIM1Rw+zvY3nizkxtmau7YpnyXPI/hkt4wB7PwIqBT6F4V7kgCyJqiMtLDS3bVDq4Hjg6uZmuVJqbJeW5R2IWuDD5QXbTAVO/oNImhSwE09NyxZpF41jFn14MhE8e5JtG7oquqoT1DbI+fe++kFBmBLBM5zsbJlk+wD1ry/lWjVGEdF6DhAHtX4EkSJv6+WWxQlLaaYXfrT8a5ndSjmf2jDZNoM7JXQi0JgN/MsMmuP6SM/YyNg23eRckYjOFCOjy8bn4WGM0P/cp+HtFi6erMmBmkPa1kYMxc3cK2l9Lbjkdu0tC79WTUJMuoz/B2wijYLRdEQEz0zpstYXACHbQEKElTJUdtCkM1zpcqbpMea80tc31rKv2ZFuoNlCPZ5OKiwGcWWWqwbFsbYzbI5JBHiWWp4Zf8N7dgNTqopBePzlznpoHHerCxGFlzqfJsNbUdixuQnrOj6fxGYSuYUADNGUJPdV4k/dYtgvwcttzRdtrLbXQTKICJrG5jQabWZMQ3puAAd12fzKBNELcpnfMft7rlYqLGTysPAebNJ25GUEiGHPsdxUHDKz6cVRb0Ohsn07P1bvdxiUJMxWZiVekmF7WsHwQOjdZ+71vJIuA+LULXl70e2PqGP4ZXLy1vE2fjTTtNTrL1XwjNw3t+cgNfu75frfW7IpXhBfCjDDzr7rsicwpPKxpL9AxZGXomXaWhDJRcgIArxASTaGIQM3TtWHOmLkkMXPMvyPgFBEQ+XAZt3gNKK9J3pSJThOhTX4NUqfv8DBDlv4GmL/MS3kMBVzxCt0Hrxl3KM89fAMAeTtiw3WLB4Df9ZPhrReO8CLsAsCt/rHnqlq5m8PkKmTpHzX9QraRwY7jh6AF8kVEaXaQuING8HF3al9OIBH6eK6GwiQZsFDFM9zY1LJHSTNxxyo11B8auYw4pxPMY6I9DKV1RXSwA73L+KEFT1v/6NICxX8iI7mPcszV9p9K3c/CVnaaMvvLrJ+U7yH1tNWDM2M97Ops+Ohbdjmta3+tXoK4pnnfvOJYZgDEgG2H9+G61Dq2F6rCnuQNH5s677fwkXeFoVjSeL37MAhoBvxTn9+SXwa7GZCuWivna32sq/Hpq9P+IQsgSu7PS61fdrQ+LO7I53OPK3qqvWgBwfUKwEtV8GalJbKt//qii+wOrpv8FTCqcVpXdteqr+OnkKCctQ8dZo3T6S74gW6greGyrmTwrb3lU4dsyd9p1oyc+z4eZ4zcDhaJb/SiR2f+RCRXkYiiEoNC+ooXaCLp38SqIy0hlETNuVt2ukEOoKabtcO7ARaqoyLGhhaBgttB4oO6m61LaNykqzFEqXtjQFTXhw+ZRIFeIS/AVNYTwuCGNzxUnznEk/ht0lODioe6upR3yZM1ggyQim/405w+tOPmB6cP5jRcKRBpKx05bQ9BiyFBtKVSpHzxHqQ6kpe54EQwzMI6odQ3UivOV54xnICLmp4vYPz6xQOFFVios5glOSAPF2AoAfKrI5haVrUwq8PU+euanxkRxepwQKhNBrtvzyUzBJ8fQDA1vX4JuElDKjQYP9jMwGvs7TbR+akWMpQ7UtglLZJg7j8nZR4ewps70/UbEnrQmfolRx2vuVkwxKhCEH7OkkfYXUTMWE9DfPQRUBsKtcsvOQ4rOFykVDIQbDKFMYFMVH6KtXyQ8yrSJr+aPGSaAoW1tDY6yzxMSbFmg4HqTHKXuKPuSP5idpxrnVWGW9zWqnZodLbtvWHTUCN4AF6d3mQYk+P2b16BizLjY46zVla0QKhLstPaVfJMF9QLyI6KmGvW/yjHexvTpEJ4v5DFyffZxufgNQl4Bej+27gGcqD27KChXbpzvWJjCB2h60y0NMrlOj7GqPhySwYsbT+oPFC51grmEF3As6k9+mFY3khxl3mCsG1zYUJuHMrCO213o7u91PytoFF6heh8u4OWUOJ3blNLTIEJeAzN9v4YwwCT3pVebzVFxUaOQ225EuUMyDqJmhuhDWGFj588Vj8qvXUsNi8peXBmYUpPRZa7e6tvhRPSXJBfvAtyQPR8yP/vBZyhrO9HQZ7CbWPuyY0lra4eXpVVqid3t4/RSsPC0YhruldmTS+demXJIAw55xkApAM050SC2COdcpp805pqo0psgqsvr9QdHkv8xNlj8Wnc/CMeyAltVyxexGD1Ug4BJcxkfhmVrSnBTCrQyaxVYa2luUSDBhK6l/XmmXGb/sZoMJ2pnGZ7z0ENGAX6+jv2+kyV+sDXrh4hw39BXrJCf0hs3NcdS2wExdNP61kVphG0cVpuNlOVi/He3TKH0mb3mKZPedVvU22riIAXip+ivCp3bmhb7T+FCqu95XXQTDEvHOcz3/bs6VK0S+Ar7E3xEzdyBmcr0Qc8Xn0TO7QNvZIPnV/YBiqgvpKUXwJKk9pieMFNDCvoXPNm8VpYmOlBnk2d5b0luWI4Oy6WITxAlOGH5O8eI+FfkYB5ER+Jt5kEmB2y6TsjumSX2XwgMrGo64/sEVu9FWRcmDcBRJNRwdWFH4K5wWKbpbmzlCK0PdTJB63K9rNNEr30o5vsy510lc1GbO+GB/V5uCgHccHVkzBSAtUZ59vnMisKRqzXjg7Cl5TQwwT+/jocy8JGT+a+yUPWTx/REd+vQtVOBx9V4Ryid20WnE3hSdr/ClvA/hCO3qGNyHT3nUt/ByP00m2rJRPPBM3kQY5vwohDh/1Mjd4NL2N5lMEIZyU5TbgtykzH+cRpg9FKMieqJyxo+wPzxK0NZdnjHdSdCsZJxzBrx1SRr5HMdwJe9gzAomFV/fGLZglSGWuXTwXaAPNr8Vx5ZYSSnZtAFfgTS+PD6UTBviJ9XWUFCcL0EAfAkR4ULHAzcV0CnIJVVadk0CvbSz88GgBW4+bhODXQKBfPtZTJvt85yLr1ZML6LUHN9aY3ktaeh73suF4AeLlePVvyxi4swEITBId3cw/2EeQhPrwFR8P7RmtS/F8jCERtyynRBtD8jX7TFOWNcpnnrHteykexMqL+qmpuoa3I3OqklOdJeZVkkfJY2s8CprPjaoZbA7Uiy22T3VV3GoRUFjYEzFeChrrQORVx6jnma2xStUWqRo+O4W3nQqfBNQCL6fV7kvJ6wXcCc6mm6mB+WrJfwRVUbDchYfxi2vieqN9wyooh6vqeFzu3HHEsvGNmEBK2kT4/NEMa7H5RA34myOzKHZrFirO+q9/6bAT8NRn6C/f/V6xyBPpzgNE6l6tlmOMldNj+gPUAPLmVFHb0ePKmhs3GkJCpGISt7bFIEF+mb2sNvZLiHNkLqsx6IUBaiibezQF4JrG9pE8NJWCkK1h94PD69rIk/Z11NYQ8a1vuMkPsL8BJacOf1BncSoDLFcEseGh3JhLHV65KG0sEnjLd/YoiGOs4hdCQHFlvHIL3RKt0h6Fq2sFy4Hh08JMGMzD5ua2ChLCDDFqIej2eA//b510IC4gSL9TI+umVTN3GBAua0uI0kAmblrtxdt8Y/A+1dICfFQo84OiAt/+2MLO9lKZevSccrl1vxi+xr7b9O8bIeF6fShcrvHzkalOcwVhokE19quYDR5NbadPm9iRxkHnDHVHj5Oo3L4gSxukr6Rt3Jfb5fEBhPn3Ad+iWFaFDp90bP7PjJgMr6x/Ggdl/joZYnPBvMJYT3B+ZnbuZm/rldCTyXpVMzUXpD+/g+jHrPwAldSv/1rJxmz2WA0jtAo4S8tsUPt3x8E5VKQ+YMac6ZSCRDcMfMUeHv2REGiw+0NqxrCs3RmW01fkE6DaykGPRnpZkmobFoOO4XMmVPTFU7UKM0gUiNy9kOCfnd79etNdRq3Z8WNWWRYAuPoCbJGgJJbn+xNa5LDScqC5JtBVKVRcYHXAmvOLbdFQdo+YcQgGs5ZdKmGMSKV3yPP32gRLDId0l2QHIHhZZwJfSdZID+cf8xaaExrCKE9ehzaGlpd9jLGCforB6jV091efMlawzvPZbp/SUE0KHrOIFN7WL16nu3Yc5u3sKAbkOdhwqq8cTnQKarl1CLWyYeftWoZj/DI+KthTVpo9RjYE21RrAZmv6ETKgDwCzEaMCLTOZdsVPRNJmyaNQexolKJeWe8NLlv0msms6dcukkARw68t+lQz+9iYVgS5SvZFoQAP0dZ20V9wXthKrxUs6rNgj6xYbQyyibGrPmhptRwTcZ9Uk6N+8dJ8SC0Vz+MQO7uqWJR5arPisH5jdqbp68hvyAfXkeckIRA+gFMCyr4p+0Eozs7ERTyg5B+mf2tDY2kOiYWonpg5CvcYsw3z/FmrP9FURyT7Qy2Xh5cD9YJfTGITPUQM0+SVWgsArXxGYrov2N6X5FParQ35L0Qm6DhEUkdHXjh0bNfBEaPgeAV7GI8uHxDFtHUkO5tXoB/o7DJtEaNCFbMJO7pVbW9Ah9fLfS9yYsZdjMpnmIjXbW71SkAAfM9nHm92LX4EPJMLzYtHcwfq/o0PoELkWZejDri8K68ivHCYfmgWBbhCaFUv6AYXWCBBIcLHVshGz8VFfz9UbtF1IoEp1agm10dEmJeC4W2EW5/otp+3JkCrmOYAMf9YmFWC41Bf12KNRTtrL3ZdPQOHqHkn4DLdAan+Rq+gg0oOqOSTsO36tEWiCSHiDNHEGoyRihFgUIKd7GruJ+I0pJ4bEnucWoyx1hgIair70Hj5vZ5WXAWLrNwOfUMcJnYFpDLjaMOvkTcqeAdp0fVuPNnOJR7tollWmKeEVqUJm0w6m7/83qGVYpEdcdveoVG//SGf+4o9O9rKSQ/f0nq2yN6Sao4+s6U4d2QtcHMMRMzRMnTPKIUJ4NHi1NQqq1IpSuHn14SvwVGFDpIoDP3ItdMN4KQOx4EHr+IyNHZDUHgpaYd5krwaw3gISclvbnj/5qPbrA1RgbO2AnoS47qWK2Lu45n0R3U1BVN461wjuLFCYzuypTavoleKA7PsLMgNCLLNOZHauXGylTSaoPIl4i0kxkOGpc+p1vE//CY9Qz6bdS5rtB9GjIaOzG858Jf4rA960h7YCaWdKNZpSyto7xwtD4NnlfvxOiGOOzYhjZURXNS4rxThtCpORk6k+qKx4p3DGSVchaQogK1dqrVYLxGjVtXyAIPt5Ad3e1gVlIGGa3tRMUdfYPLXVl8RjR7ke+92t/MSr1gogmy3AYkRS0TALxJia3pju2SI1mayQiW/fAZyyQS7HXh4TZAgWRyK01Kl6pyqn3rFE08mJYeHcLsAoid9ILpaBvI8OWE7NnhPOnwRNlIwMxLP4zjyfp3+ylW6ltDL2+galuMGFr3l2om9kMc/U0jKYIcpYIQvKERdm7kJAb3Dd8ZhnKpU/Gdydjj6BDq72d6BvWBmY3AP34kuxyruGTeZyBt19lqYD8pooyM2oK8jyMBZGGel5vD83fvGaItGapmc081vfejzwTghDlgpEHI7a2LtHRMO3xWWpo0qhcgWr45ow3VAhkqdjJ8tLSUe5EO12XAsceKM0b8MeyT30sNbQC1QYO88luJTP6/HODs79Rd351R7f3Bdx3TPkh9SYvcQajLO9O5XI7M9PaSBsKsd8xfXq0JvivS0299Y6R/yTkMVjR9NsN1W3bD4F819a/Lht13RMy3kxK3OiJCbXmdPDoweVkHRYO7b9HQhfoqTis/PhGGC//XJIHJcut6IdvrYMCjE6uhg8/g3bP/PVumftX9/AZ/TLHhtsH4NK8Q/byBFGCGC53dQFdcLJW7leQcb2OCiRqkzyZd8EzCEfKqgjW4vutTrbCgdU50cwLvqbbO/4EfKB+xu2xdkLm9vqcvqL+94Jpc+6WMGvkrWjZjC5Jp44fbbOVPvw9LAXXdh6NCxDbgRCCvYEVRToCv2zCN1vXdKAme8JR9oPcoxxZMPBFDWH6bZILBGCz5TH52HcMdpf3GU4VWiS4XrQ00UHQaLWL6pRatAXaKenLtquSfWKyzEjWSKN8mruEtbKJJjvcJPA2QqNCORk16i8bjerdCTUnOQb3ziu/Q9jXmZ8mG8HxRBQ3Tpy+VnDsvDABY7LTQVMxfKPPwWOwXMzI5vnW76OKaPsyBqLgQDsMEJQf1szeQVIsEZBH9OLScprj+RbK9l3F6O6ZLAaj3uf71HCUxFaMKdtqOXBY/6yEG4KVnJIHBFzNae/4nuK6wqTmMcXoS/bLzC1IdahwHDmQtx67lC3SEtq2iQ2uu5e1DU4/sjeixNdI82dqTMtPZqHxZnkWUWpqGdfFppkS26AMlrARk41LSFjk4LR6YCTX3XKRvQ+X4Kiy8O1FMYbEc+/VHrSbprHuPoJE00BGKo9gdlG6L6+YtHR+zZ972Zh7hFwBOBff88AcP9sG5z3l0n8arsewrwHvXdpnIdVCcGkmu1B1WrD5NC8ikL47I6KDfACUUQM+rbTITHuqTZ1ybF7mMLq4Lg1snLxV5wfhg9AD05Fg95MqfqPqJzTkCBiQJjuS9+FreZtjHrqQpKeWCtPQAYIu0+72j5Z8lFDqsIgprrBplqE6e69zBPjWkFqDFqUEpUXA60OVA53ys+7z3kpG27Zcgn4SD23x4Tg4ob4I3qxpnWzwS48Bwo6zpXn1MamJPuiZ1EzeQXrG/84ZoDmfgjppwOyP/ZTKEzlSiPBhkKi9yGeyRrzPM2SoLFCxPxAXPm4r2IJ5+W/gXaMd9248832FIxXGUj2sbOMlSacrKesU6PGg0caTZJeyIILU9AJYep/P47ma0pt7XeBP/ahvTUpLABoGaxTpEdJiB1pyNICYXlXzfhGMrSNHrjEuzGUagq7BUGQj7TpxkQ+2fEuKPT2jJ4HaobWYsnD685WjwWleFvp6SWIDd9Yat4EHrofggz6C79sKXjuopLBPfyC+YXUppysoA0VXB5XW57kZKvfkWH7CdbIptH/KIYA1A3qd5YcQXNqhfydNvXHIAMxVmhinvbWjFn8Iw9B5XKwUs8wz7bp9nrjc2ww8hUvUeRY5cpMRikpn0F3spgzr/62piTzXJ5FPyfhjtJsLdKqNelhcHZx+me/ozkPrR55Pzss99yJEqqCiibRb4y7JMUdZCdk9cPD45HoIREDUmyKFP+9qdMV8A4An3suc6wcc9eKvH6vDplrGdyhEwt9lekrq6Q+cAw2+SSi/oQoZ7WZceuuXBZMU8klgYyJuXmo7giCh03RX/7ssyQFq3QElEnyMWtcBisYyf0mkuI30zjgg9oC0JJ1D5dqnrdJ31O7s99NaRmg+S38iYOj6NeIpJ8MMNgKh+y9uThoHkF3fmWuLGf4+3tl4KQ3FnO7xw3sInHY6ZnseQLyt2ew3ugY3RFlFRJZGOspgoWGpbdFWdFNuQRWMGtoAlLvszM7dT0t2QD9vfnCxSOPp3t/aupLr4Xhk+A7l1OQdVYt9Ado+F1+ZthnL5Cj9jbbx4EeOBVilRY4sL1ggHwwR4ehUINrBT6xpZR1C1/I2Kqae91CRC2ml+mo/wYHE0kic8U1/fZR3Y25om4KiDXjbUBT7CcLy6DM/epIJVxcWP6SFHBrMh/lKGeO+4aIIr+cJuZojG8Kz8yhTZ7llWvVoIIk5IGSFnCoh+z8BsesCtv9GqqiiEKOhrCXCVQ/K3jzyTLzg9wWhUoXXLx/iarbEMYf0ssU0A5mygJvAWVsELQwiHobThgXQ9FRTfMb+1tbu1Ls2G/mPNQwmts8zPb9rg3Gco9c9nLTAj4HcEZqCEVggP+TNLfAsN1lEmZCP4+44EpXcagaemIGJYZXmy30fX3MToB/dz1pKm9eXaJ+yE0yCdqvQIOlMQTviRuXq8XEpDs+5QMZGhB9r6RACRp6hy/7axGvO8S/w36Sp5eV/o0iRgDZlhOyygoxYsdxv6oMIvITiI0/g+OGkzBbs/1M7dKTQi/gNqmlkfxcxgI5pJDAEssASay49Fwnoq6ds5xJXWlAZlQ6zGNqP+Sjp39L8ezvKvcxR3PP9eKQqrbSbE1vs/KKILA5pBfTWgjSuf/xefkenIJwu6tKeS6Edk1eK2xvSPbHjChMHMcK22b1R/nMxyNsIGeS3qZOWbZAiBTyyckc57UZjlQoCY2nATtaW7G3vllrClC3i1ZuUr3v0WLzgP89IAWKannBiaPFFuHv5j1UM0gyuhcxG3QMRLSEtl/JSY6KxNi5A5AkLf4LWts6TU+Q9Y+LdSZNnlqv+RRwMPeJun0H13S3YhX7Rbp8KJuMPzjDqurMWhCNNtEh1nwQXVh/U2v3DHCJ7KYLgMIL1mUr9MfYM+Jub03olBqAnarohC8Ez+dE2MyTEV4rBszHyKt8WC+7K9NkPJYDcMu1TLrLMXTSHel28EfmVNlJdD9fgCaA39fgMo4NJmCAADllcufJKts3IG8Fl3nJGq1ky5c9lYJfJd8U8V8HlvHrExQA6ZBq871A87rYKUPRpQirQDsn2JqVwMl9JA+sHZjKAVil9/Kq/a0dy17UOXR99L87okVpzPejIe5nmSsZGcPjIJyV9SzymM9wGyDTIz6IQSEv3Ft6E7Yiu+DCbhO7QOeTjXNKw0MSal8RJp0tZVrA6SVgeTVjqT9WK0+88oroy6imXveqFURpLWM7QB3W7qwmdL/NgnSEQQv5qtlFgjGSfPrjHT5nOlsmtlZ2VBDYCce/7H6vWQ9gUxHbTIG2aB5KdXu950V9nQGVFNdAxX3I7OF7fIMf5wMeRNgW3K4H6ya76U5DeTX/FDExiCM5X8PByPXWMIcNvdIhaIC92xYmEgHAof3h41nN/fl3PIxIeDwMNs81NJ2MIeF/zFWjhhccTt88WrmrQAvVRHu4esONdr0evSTpcRzwQSieSto/lBBY3yz5O1CdApm0yhCFkAA7UEHl8/ojUsCMAwG9L+GC8JNhGMMEZYLwqdpO33W+uO4hb5fPxaD32N8mRDa6MZCfnQG565qNtafWC6MOFYneB06U9ZbFRsh+kvwKp7CtIcv2DFq3/G2EecBH8w/d3iNbyy5H+vGtli3/BXw1qQp+4ZpkIo1i8bqjkq70d+qjIpdVpCyhP4vibo7VUXRJwraLaTPO5+hQ/KiRIjFgAKxvRbfPhYs0YhUp/qReUjIVUgbVcFCioQgf1wBl9tbvbjkmDdGm5gueVVaJxDPdWLnKQ2/Ul5wlQTK64F6yOXNRdelUFeKBOEi8m0kRQ4lOGSh0CN/kMfx1PFUKZgGJRI2NYpb1PZlrubIZOxvHlrL/2AdbUBRWhJKwzZNzvg7gS7y/3BUoypi5jzzed2O7jkR0TqPWUaBuu6SpWBh6+b0t3KXahNiUKCcTbIL/x338Q0GALSNV75scajXcDDTSIWCreIlhrr0k9fc6pTcqwNtQ1bu5AzHGkGdqiwtlYJIHanKim/Cs6hXIJDtzBFdY7bpqq5tdST0znyRYBPvmaBcwjlstq9PQG0/5zLH+Ib8Jh8b//V1dtBO5BMFhpEQ/rJK6R1Yl9XQzrdbX7fFCxiAP57sjfBrAAUQlgVUuCKcJlnrscdmpYK8qZZgBkTJ2mif/gk3zFJz3J4vXOYPqM9HOkeExKc1IcOMql0jgyfCVS7X1prsKA2pwMUI4g9sjsuhoq/KKO28IoV5XQJy2lrlgvWmttWM9V5Y/3vzh7kZ+3bAl+wlOiz/IfHzcqA/yNu38LZmBgUWwdXRZzeqpa5lnf9+hoxym6t4uWE8rWJkZ87aEEG19vL7NdxlO9LnsxTpiYAjd5ZMHgnV1STye71t4o+NWxN3wEsuC5SrkwCWGJHm/pSnMQxzYL8lVX+XK7pp6MOSHVyiXZ3KVsnnPYkb5Hdzg+w4dWoWF3AdIyi2W0zpMeD+5hUAS78I5aEtQ7oyR5Pj9w9fy1X+jaUPf9iX3HgcvaIXEK6ouM6MXlVLp7Kwipy7ESlfmNMPsI4yrdZvluIhLHGKRhrQHBZfnQg6ERIHECkoAazgg0K7q9Zpn0aZBzf2BdDRBWJNV5WeKJpY7ImWTr9sanWd3ihx4eX14MqdBfayLFXS0h7najYgrhTpSzkMbMHs0RVJFqkFSNnboOyBoVw7XdCWyfOquCKrjcvujQzaxH30fDCCRVnZItowKpycsA3j6ZJRLdgEPa9s2yWVC02SF+biASLQrDwEUaE1kXjx+brkBuYwczG7Xu/PQlU2EdJQJBJkZA/gq5OnsTCuhG7eD1CRRg/nrsK3J/zdcFyvi6GDArwxOTzLEjl4AZKxFZCAuJ7tHzOCdeKtz9Pdloi4Kz42gQlevVtWdb7IeELhWnKyisC5eXNmqdEDQDelaa1Oku0ZgwjuNba33AU9rwSWLe0PXNuf/z19+rEHFwEulCoNZ1zGDFu8uSJS523Uqs/4ZPWLGCxuCcOd/45fPjpgpp0wGrFsntwBDi1szLzQ/3/mPI4ZqGT7V81HS8g5i/AlidvqdGCz9Q52/Tl1cgUi1qSKfwKAQdiqLOdA5DOQSWWKFqp62pXF/X90Ya1WAurqap/d5HFGJqCJCDMe9XNenvgs6PEJxBMsSyFM8B0EhWwfq65aehC2GwAmkZSYSaf46QlIzcjHhM/zFbohCxjI5C09cpDXZGd7+azXomy3a0TTs5anLB0FAh9oiFnbe/PAJm8XmK9tXuFDpwk+zIieIQE7NIaklm6Y2wnlpl8rlfZnsky0aKbTRPXoPWMAVz0Qpdgat5eCSq+yp+rPlu2WdxNFy+Ykxl1ho8qrHgnPMx3phIqphCnA/0IjlHDbqgKCP4N7URa/hXxOEkxO/Tvx0FFuLWVZwf4uiAQOtCuyNcD9dbdwDC4XLgOw5ne9C3DQ9Rhmyb9AxpviM89lsFOJj3PGJGCT1FUkVV2vJsEN3xCa9ecn9+SaLpS5HUWMO912E0k76Z5U4DxVJKAWw46CPPAQgdX0nwddG2vMGPrW/Ed7kQXc/nRzSj7PeSrtD9ZKV9VYaBSy2jhY3kYvUL1nrxe8GznvrcRzBVSIAcmc0eqvoUsBF8Nu93R77xSz4yf3Z6W2kKrgmY4jnTbo7HUIUV5BE9TDaaBY/fZftVyZSFDwgbJ/XLPUaNFQyVo4JSlwWDl2xF+w8ptPgFUtDeBk5WX6Hyr+A1i64vbsljbl9BOTugXqmkqerOyNvoUH/oF67RMxTed77VlGcBOu9iQ9aw4l4/HSUBbdPtgifv21pj2moz9BCGqe/uzfwLge/6oYtoYFAPdxh+Khd+Q6Syt5kiCF4fAMuXPZVryRKF0WR5cq9bDOuYSIYJ/Ozb/QwW7qV+W0gEQUoIqiWMXlN3cO0W8X7gFF/UqL4eXtLU1nSUogviwAlnjRqbyC7X9CaByTm4Pyo/liSYuV2zb91V9gP9GpFP3EfGWN5xsDeBAKsw2ACbDugL3j29EzRZQSEC9FBTEkyNpJxYVR+h2dmQIJN0GQgL2M5MgP/cnB1qaDIXRgHe3W0p09QeTUN9bveSB+UVFqzCsUituh4KqUQfYiTylZ3hkVO2x2QWrboFqCZ34gBsJ/izoawXKleunEZs9pN8/CDSEH05A+2r8B3a+SvzJxt9SWGWx1MVpxfdbqE4tDE9wjkX/wBcHhjS/MUKJQ0VqjKzOgmmTWa1AfLzstO8w2lIr2LIZSnnZ5LxoQ2l0nYQsTZR2+pmn7AdPAOZMISCeBxHySEr4ja2mjc0A1VXBwIPrJIVl+Jr4Gni+mKQcbRJz5gISm6bC8iLFLN8NkvANGIWgSeRrTB8YQePVbbRdaxG7oUHnxoTu8Nb4znx3dNlQnonK0gM2Q1ZeO+QjQL2P4ZEIBIq0INI46yMODDPR322k+Uu2aEiHqkO9BAQaOCg9Bv7Mcxqw3HGLdowvc9jOWpnAhd6LnVJJMnL71JpuoPehxqN8BaKN21qUH0s4B2AWH8bR0LXTUhdofJF7QKPRHdUVMWnGt3RUzaQNC8NgsvJoV9fFQ++HaShquowwcdcGMrdfw65SH84xRoNJceYkwUkkDz+sUYlRYMd3wS4ETSYLLJTIXrg7HWafpSc/6OeAPWkaInzT6Q5TPC38FSvusS8d4OMrPwEpS4YgS66BrBlnMXDblnw0+j8XMItwzIVzcMTq300JPfU5n3LFMovU2ntrVOAFawI4rJjf3sWHz0gYGFBJXSVcUx1TVU2tVxy87mDzg4seyqY/sQnluYdoAwL0staJvbo+rL0i9qQoNxuyQJ4PvM/lhP9hioSx48PU7V7qHZ28DORHsivF0jMG1Hc1PkXHrBolVFR39HIeTm8/LlUmQlTS/0ZGuzGmep9ocsC+8wvBL0IGpkyI10WxGV7aSLKQRSjif176tcSSx8Y8qyydTAalNG15fUGffIrD59m2bSLEK7Yzx+TQb2rhQv+mabIrtlwZ1D43qHfptaYtkf0De6Adz2XVSNHPGp1XOJfrKE9nS7rUCwnYo3lnAhOBMtdxr9fgKEDkjP8DhdmfBURBWjJwXWopQhD+hkzEmnjkJDWdy7QKiEFh9raizYeqyxybGNMqRxBEQzoYjtkfLnb1qoBSGJp6ieZ3kMkUTFwmxVkEPgigu5QsBcgeVZwybf2RcY1tD1My6601OIDM+UvpKjruHnW8YQuSg6mBLoN4K85ZiMwHd0E8CjGQj0ObxHdCPBvpHzmtMipiXuago7lQ+zeM5qGt2abQznIqnzn4odp6cDCxDL73OukQLPEIdD49YbtIFbHoxrj4ibip8qTQNfwd9QFzxwP5b48Vvdl45a9IWPp2dEAPnFlxMLjbTxlE88ijTaIvZuEPXReaxTw3r29dLOYWpOh6w5U+fiUYSHSVXtLcCeKw8mHuMn47+5JXF9Q9qqHqNBHnp/yp92g6cqxWdU3KS9E3ThXC8lwded9Sm0neYLSmqEaW5KRxhhvjKp/Jf69SRzYsn6SlKHfm3p5wmB1hCHTPJ2TrtoPoWfWgnvhrclo4iXuLy68rXVcIw5p0/nvD8AWMNOX44In+9qRD0A6pNXqGPNjyyFeEGL4AYXgmBsHCx/i2VKPXsz2CldZvfoUaI7JZFYN4QNdDvOtpsG9AxgI2mZyUt7HKHg039wWQSlNDeMRYWEwumRteecEJVZyo790bs8CpdoS9P//HQuY5s9GIlwvWP0N8h0iioxzLDNMpTPze/s/eudWMHl36snB6GsRAWpUWvbLT8tKWXzByWQwu9OPGWykewjCdxlEkQ+IZUNyXPcf5fuqUfabjNnArk6hPHgFvdpF2BLOFs4UqZ++LXJNjqtz0KjMNnXJzmpI6PsHX+HDe5GWcJnlmoIGoY+jf7yoq8OxlApUjrJAN3YvYw3L6fCZ4hJ4CFe953zbnuk4jliRF1wIxvV5zZVpP2miHbNJWi6YIOXHij6Zh9f/S9rQUHjTKjGkV/9B89GkhZiJB631aSnhQXwUTZo103ZohqIzJP1jvoLEHOTu+1PBWkCLmlahFON8oGS9RlS92cywiyy01PD7TF1bJxvC44w4VG1FOP0SNAMn73go32Xxqc43Pvy+wNcaT9X+aKQ84MnB96t96qdgip/RZvYOlkJ3SrMy/BSEcd17qh2j2g3NSFoTfOz6i/I/mCkh09dTLNmKHuZe1s7XydFjwBsAgRVggzZSHk4BjUtxs8fk8VrE/GaJw+AmsRaTEavezX0B4ymUwU+ARpLDEBIQIJMwV1vZlBRKmrZYCqmQzWxVKkm9rDksyKueegk1TfNx73Muq0C8a31/uXtzplZmYhatm4SWbs4032chpZm3vJOF0nbp2LLBP99A09O77gy56ZtsvPARkN7gQ8dV/UMbilalMIfkSIwHmYnAzqSoDI9NeaQ8PWZ+0TpaNupgDZxmd/yiV/zOYCG8F/ETjwRI/pl0KJIXtmUJ5k2DjTLM5zx+uE8Qk98tlquWbEP7YfC/QKVRyMPYSXmkpY26INIkxhLn3oeXu2ltcl5SDg/QbjlekCDZv2ra4Zy4f79NCK/J9/A97N9f2zySjIX9MO0azO3GZfyy6clxP/3ZfBSXoQCtA580qVELDNOAqI/MDQqVGG2MfAKpI19EkMN+8JoaCr9jTQyZm89jMU618oxxjoJHa/FLBLgl2jZcBlORsSdt7Wd32HmAFRxBaSHsK2HYmwrkKrO0BvXXvEZHQAdufbPgQrDEEiIX49KZ1+Ni/RgMt2yNdD2bPODxyXxIoPHvv1Q5JRwSnZINkBz9FGkmseMVZxv+WR78G6goBzjJO/T8tncuTSWoZcHHo8WSPKDJehkrvlKvQ4E2XAwHhasRztfUHUAUfw/sJA34YD58xcYiwpcb2p0wNzgmdPhZsiKxnngj9Lu030Ff0pcAIB79nYUyl3sywhxBfTMkusOKLac8xbih6nUzPl4a8RwRnPPk/fcJcMO/sdknR6TEb0YBjnhiKYO2qNJQJzl69gksm/hptcUd1ZrpzKUIYKm0j66iLZ4UJY4s6HNsQiv5DhG5KpLR/4nXUNOct9B/DYsQ/IPLlBztY5StaOhvJiezZyu+ZzNT7I02aa4B41GeQ/zvPBb7ETUF1Wp2VuWrZN2h1YwWiu4HVWi4vW0/1VRiLUWP79Q5W3SzeVgqn8C39Kx2p/n+rFxYKUxkJAJF0eCpLasNi+jOsBAu+Reb/4zfhcqmeo2PLI+U6Pt02kOgziRm8YWyrgDvH3gPP5fWaZYPkgshFXuEXuxxsXOcw/tNEDWK+zny41LqcDhtXrkIjXj4f9MTd1T5DEcFM/7pXTpykwGDsw9oi3NdyHLcTDdn+XzQXQ+9KLGkSL5pXzp671i2o87tUeYwM41nOemmBLDucR2UnDczDQttmXVn3mM7+si4cviAbCsyW1LIAfMHMIPYzgRdvUaPFSmpcAtsI8FZjpH4YRLaVhm7ojHFo+BY/9hRF9QM+Xh1wMLFEX/S7clHqGj6DGWXag5wUhQcFHH1a0glDu4YxZOvVpKXIwu5R3Jfj9q3La3m1wfg1jdmKbVwHKWlxhXDmmMNdOFlR4mMuc6lCavD0wCtTRhMhucm9tjFypvuqbOwRMgyeIcV4iHR+NPaRrPKvnZXlsxGmBvAKfadpd5KRbTuIE8O/SG0i4uItTDg5V/Ei4HqhcdHaopf1VD5wDeT8lrzXFNuPB6Ordsp4uYkV7hngZZj4OZO2gKQeu9GxDpqvfwNJ8itrutwkc1Wp68SanPHtYdIKEzgPB66/9umSlWqfJ3rvvOqXN/bfau2FnaRO8R5FXRv8/3FueMpy7vJBDl8c6xd7964RNz71yZT5biV+hoommuySyw/gCX1OqShYyH7qAjk91haBYUQPmQCCU5HS10hx6Gq3sb5CAitjeuM8YSNcHu2dcb1c7HAJ/Eljak7bzEAOE6W3d+/4U45NL34YXH6V7f7hVSDn3Mmf3KXxLeuvnsxsy6dYM9zz+xK9fvwcellmtCBoLW5jowp4Ptac5K4dx6ARjutkRDgZhCEzpTuCN+EPmJqF9+MoWGLOC9vftcjOu0Chn2eYwj+ART30EnXv+Kf6RSwgKNcWRVFl0TxKPUFyDUZ+ncqXzgXuUkNN7HVXwdOgh5QVbazKZb8znMKEFZpFgMMK+cvWdKZSNDH1wllU99eVUpG4UYgoMpUAFIV4FFO0B12XvxS6e2KkPYUKJ5t7m+LAtsqQDT8ccVZpPBOwziq0ondSz4al7X6DdBRIe1/yemV4QrJf/2X7iHPbtnq1Ujd2vD18E/zQgDGBZxwH0VM9MHF64A0VHjv7A1US2Gd0WR73oeWlfz09S2RHKZyF3Vnt9fKrT95sP+h3hB5dYMLsDTPvDth/BTc+lBKQCa1IK48Rd8Q53LxuKz49mhLSYxuFRRSo8QF+lnBg7Sd+GPJU4vJQjdWHYu+BfkUAyj0EayDpvDTyD13wwcQNq7mXUFJp1V5AZGjG/JnBOvYQtkkzMuJVdeuucKsP9GZe/TqcboYVtd7YDizpCE9YDHQGeCPaquTvGlvVl9FqY7wiA9780JhaOv/J74Uw9CskI1438wcuu1Irv2EenmeI2aXTGwoJBH7MkUKnRtsK/IMPMSl/L/59r8d2KbTaG6r4RfhkiworGuNLwAb6KjiXuy3hZi2pbD+gjwTfD5jYisnHSpRZIwggkXBz7E1Y177V341qQJXUZhPSfGy06F294TohUBXODFRdaiNXlIuFNxPjR/mEUHI7Q9uE4hE9BRFazPGgzqINKhIcc2Neovr3tUUHfPDF1lINiXvAyZ5nqZa4ud8qrnjU8l3iWPO2vXww+NZXBP2BeiydLyrsifoZIdjYh64FMS5hUfSfwJUb7+kylRHNYq8/nRd8jtpsK0iWZk0I/oRgSnOdMX6L3k1ttUD2Wpze8VP/HRLBkny6VHBzgDsEY6mBneT7nXD963IiS9QIY8QXEH2KZcn4A44sA5OCxosp3YefNbWPC5WW4WLjW/d/H8nVnBgbiV137XS31ZpkmoTS7rwFiue1o42uywzJjZuwG18JNemjIp+xaWGqG+T3Mx/XFvvTtkYZ4gd+5XbhCpEBe0ulgTwMXBNIGxdstb9ojpS19l4+kstKHE/oGYkK09ZDix+L3tTs58yQB62i+zcbI34DfKt2uNGK/g63yuxws3wrAP4a+bOet2jj+5H6heBwRfw9RENF/XS5E4aBZ481cdtYAQvvhHW24zulZqhgtpeju3f1NaE2y2rk+fixp/vDYKTZUxZTJGNT7yKNJILERQr2NG5jzH9EmaafDZLNdgAkn0pb2lyV8TdsWXpF/kH3h0Nnddp9SSqi+MhdCN3/pZyZH4iuP4U8zMTGJLwD6vdBYb6XAQfAPkStohINQSmiC+eORRMFfmikSRqhWpx4Vn2sHV38ww4JQ7izWiiho05oaHKJvNv4iWO/9izzQIdLeRv1dLHQYhiQ4CEVgwRuj7uP/iSbejV9rEMsoDqK77z0pnp8MXaKqwOmZYoWy5ysCwhVNl497lvzv3ZDZyQhYUIyo0I49MZQw9qn0b4PdB39LUrZVjsLWtecqEEOoJejbvlcTFb/S5AvXMjxLhrF4GolugitIACaPM7TbGyQz+Gqy8O4eNp9QcxBt/17M25Nrk40AquHNlnhzAXF+vN/xFALip3w5BmHXly3h9ny693kz3F7XvpMrAJvleyMH4bV12xiqAMdlgPbg4ehoMlJ1RFvXNCo0JVRdeqaH098VtGfyYiImmz320gogSZpvs0IHVVxkbVT1sWhgE+9oNpq3PNeWLXE8mR2w5CdfOQAiDnXONrcYb7QNtjzPku9XW/k72s0+C2D51F+tsLCaZwTr8Dj3OCMteUhmrLln4jnWvILmZdbvOK/zAfIss8/7K8ECh7CRC8oDXNXagjz0S8WLcDFvEtOHfsWPvWaUQuMqWodwN0ORjoGxpARaW/Rr3cNdFyhUmusvr79ZLkzcrtY3jWarfsjSmfoBQpC01s5WGs8kmXGE3wqiScCO9bK4S8i3IYgY4Q+sk7PloQzcjoeuikryF43b11Ja+ejzXp19eHs1TDODpNEDIuoVpbm5WjbLyNY9mPdJoD9h37+h9+bZM1k1Hd+V8nrPyAvkLnG/sXRUiE/dHD3ES4tNu0+KJhJ81/6sGITOXNFdfB41Kogi0aVl6cxhpq+oOG3Os7zQE0EXYIJ7ErPudmlcuz4pzwZZdovJdTmSXEkMCaMan6iy5mP7nByyYAm/BLbsbG3J3WHgHP6IZlzQ3Z6cgfBQEZ1Btjxoosu+Yl7yQo3fcq2QYIvivJaYQOrabUDC7O7pe5ww/ohYd8u6BuVhF+VHvm4UdsrL6StSqSX1tCZRFNOYTCxcNDrkmk7m9klNel1gYgu6WD6Rv12oAGIhBz4HmZ0RsX8JylCuq1QMUQMgupmunMYlFvUJB6uHtG2+ZXQBvyvaBZtVoYzkAmTDqkfzzPyNY3vqP4QJJv+vtBFybd7YTWdZsjkPvZrkm59lcjpwPfVQ+XMR2Z0Q2eOZD0MGJv/0yIb28FsBt++VqX71keO+9cJXS+qEieO2sdL+RNidq7jx5sjqBY64eS4L8YpUwZdtAfB/wH2wGgXqQNZksSMEkAmhICdH4M26/f695Xt6nUaL7p0gfckVeB1FEisprdbfU3a038oEmW73SxJqrDd2jypbxauVuC7/ZpLUpYtC44MR4RpxeCG/dbNlVKGf5bfsQysnXBThTTIYYQw6jxrpSvUiy+aQfOgcLBPkFiK09W0BqDDmjgFDxqRTIb7g06atITUUBK47mMB3WlAN+5AC01Z9V2XjxxAbVGhEaJG992gtXfLMYzc4CRHjBt3T41kGKzqGXYJC09R4AJi2CpNFPEwa+fJmiLdyis85PfUyXxXZ7JYeEBK63nzUZIczEoYT5V/X+2nlN/IQAXp4iUFBxXjs88FOLtLRnTKKJ6m5h1xHJHC2cv2GthfQ0tNI2ThB4XvjeatN3ak0mNzNV02S8GpZ519Fm7fyutu0Hl6c/eZ7Vxr8lZIWo3FZYxpAMto3adof4J4Cc24sKNkXHZ0CdUYKbE5qXOMMsrWANLmh+lE3wkX3NOQtQ35NB9WgXIl2IJpoPTqNh1izOnKRe2asC/vTauaG6Hxq6wQ5IRtYTwkBpAhMdg5z2iSjwsEPZkveTPALI9fzUF6r7WB3SuaX4muJuA93EsvAiY/kpcquRFvrnBnI2keUX+dnwWGMGvmM2ANwzDLVDNdv7l0x9BodmlgVVHvG8u8ArhDPWWQl7RMzh525fwmojjQAungXo7T3YmBIhKmpjW+rVYY29F1mpVaSK4J0gqShwOaBROTQD57iZvihXMLYA6DlBt9sUybN5iOKVJ9RRpY5f6iyoKpYPFC6cXOQkL7OPa9c9vVWm7rFGuTcq1Nt3xWOFpnG3bI3FDu55Lj1wSbSmAHTn2GjlGlLCJofLNm5j8ziDmZt/Mr3qdSX0151VezfPagFiCjPMaU4agiGyasAvTf4VbAwWRO4w1Q99LRxIFfLGCAXmya3nbFTfU10KROSFlfxdwBMnecH4269LGtFadIZE/7V0VhSExs+r8888cf1otWGW1I/vZEDJvsfAOILAUh24dtZWgQoTXVpjv8TtKSW6hD8rZB2Je5BYH9UrEr64mJaXpQvCJsNBKbNoBS5fxxUKD//KAvuonLfbSpF4UopiZV7VwUxUAEtae8ORwt/J0L7LyOuEEIWoNtWVNQ89na8iWad+qTDdzIP0ASB/3lJhbqEw2aTfW29sm/7/y0FFO7xkqfnQ2I0MIGzCrWG0SBjoZJ0H2EInwXi0tH+n+Nzq5fdgP3qhnrPHyGkd/p5/Op2TgpZQVmwEvanO75hHtqeUeDW4jyGSN3PiAQg2BHuCQc5nnOWqyTBbrB8SATZYEzFCMQQt4NbCg78s7dvkMWdKVALwsbMGFWjOJzxN6+otN1186DDvMDgjOeYRoXsu1yyWqEfVZzIoG88E0NEVWKP3cBtAftfqkNMnMJPBg6yle050HIXhmcrYAmvnQ9pOoR+9BXFRqFqPOE9lI9zLawKO8+BpWhT4CLgzcB6oqzUqKTFDbp5d5gNfLuO9ZNl4LPISElO9XM/FpgRMhXiAZNmPbiTIGHSU5mprw/plsDuMoCAOBJG33egyk1cIAc8hjWym2gCI4zCgAWQMYF/5gu20hF7+ic6fds8j1ScrpN+tKXKRnF182ztPScZH/4X/E+KcrYIK4rIgpHFkO2jnjHjmliuWoWRTlvuv089TNN3ql2lNZepNm4ofqrDfd/yW+LSAPOezHBGVWpUR8YefAeQfdrl3Tuke8EFRFQS1ZQjQaD9CHuFmiC9cu43kAaUrO6eyw8aEwiQTkDuV5SSByTZD/Cl+3teHvVmIw95SXRaNMbMwwd6n4ODhsDKUCkmKi25IsTBsssqDYpA3He0hc3hOJE7kMMooo4hABHJS+OeEAxK9py9zbcAlJdTAbejSDVTDbn2GtS5MI7/DQbDPPN5pgP514V7lv3mC/HzUGLjMIwfRrHD7/m7I8CIoZd4YedYDCiypqogBEj16Gqk1qsWMoo06VTi4t6HUjVssapN+B218NLPwKdE53W4cyR1qOCwpF0JK5l9jngwa7EjjAW4ajPH6/LhCnuEyy2nFzfDuBjCYlfJn7REUFVTsI6po5wEGxclk5Z+peLc0g0P9q4Qu4nptmomUCCfwNItfVBT8Wzv8UXjtq/K9r8BGicr4ftnfF9f09VpQrnOQNblC4fG9HqeClRhMnwBFJN86Msk2BcqbspR86en105x1MiMF/oIqbRtcwtdevuu+dbETyctt3iUvqxX7T4sadjY+Eiea+Uh2kfhjDwiCb40RGLWubsaiPma3B6zfYhpEmqliST8+/2toJ4tORd+5jc1HpcCbE/fSolFyCqvdg8N6kysrqMVAMvsKWIeol+g/BOjCTmvlb/ZCFKUHBZBnUoHkhzd/RKeCSsHCY5fYNuv0a6OcLXKgIXCr5AKiWVAaK77j1ZTUkmF5z1GkJOQTq7xJS0yxH0+P4HdIVueUusm/z5LuXIbkK2kzRDfjmC0E/UlwM0Y3dadh5FvjaKsi7PucYEz++ZAc6pVg9ArPn1KcqVJC1pAx3OVOEAW7iqd/UX0xXKfVghjemrYh2bPkLCjAkG1R9Y5PgRPX3ieB0owiuQuHtAso/ZqXv8P7rFhu8YAkQVZ4R7N5TDBKiREbhP83yhBUfDT3T7OIrofoE4GzUtuJYK3cADHfIJPzznvNO6HhcLS9ridgRX198rFlDRPEXlxB5jR+1yVgVBniVRUJZUzLlJOaRJFRz5ji1BmXC77LFw+7Xf0cnmiVEHicwWi/h7/ZEYEcALRSBU4OKaKhSLIZSiitqKBR/IXaM9ed1HAxABKy1amFobNxEEAhxmyTBMKqIy9sitrYQjCkK++RTSt9h+wEwYJdBIZr9OxDXqtEyyR2eyp6tla6iDnznkHRuRB2gFOg6EUAkMcpFMFx2e29f3tw5D0WD2CAwpPT5sf0qD4HcIjri1P1PTeoL/oDMEIjjiJi62CX11kMZdoyvjjGC2Ud8LL+p/34qimnEM3TryuIuBuwe4ZI4gShr6hm+eJMsHbX+UNaq64eDiOwK0UvH5q4rWVj1W7a/0lpGTduc6YfHhAVIdnlRX2U8WzAIIBG4d0q0GSgeoEnG5Ft78aIW+Iq0QJMxIhEec7f+EcMZ7U9CKT2Ib/sDJfHPz+P5tOE2pL+RCX1SudgtXRrfpFLC28yWrDkFOiiJwWrhTg1LhSU2Y5AfOVlnJXDMCubJ6S8CKOC8f/lkF2grtILbateh+7ifmMVEE6rqSPVxXQWBEUAJugk7TwC1b52LQLQ1NEOyvsRm7CH0f1K/2AgwNH6xEbd0oNyoa72coPwsf/MUfX/8ljAFJVFUmQCV8ogUj4XOjNFBjSVdfsFOpdI2JX4fKYT2w6WG0QtFa5GPSqUtSgsebzA6yt5l1IQYM34oNPcrSdYGCMsBTNtAh3IJa5kh4YwIii1BYmO8DJnP67hRLTAnTYf5Rb78aWHfSbgC7eEI9Z4GfJzwfzr4rmjwDPdsPC7UQ0JX8DMeicemWfcWBq3xt5GaT4JJw85rtTU25ZTzF92Leeg5rUozTEToySzgG/T4dr7Vw27Y3/F87fgroBjIW0wYNJW34fXZEvNZNftS+RPQpnoezBN3ZhGX7Nu7b4kLBra3+JXTpaLhuiF8KSBZldGEP6i8uN/V6ubCL7gNn7lCCQntNgt1+8FpZ+cg1AE6bmoJFntuVxdY13+bA+VRnqZLX64LYI1G/iOQHX3KA4kQCTTfrXeOLpK4kRqHyTN+wtERAw8i3Olu9cFQitH831yAuhbRQCvCtqnveTwbUI2C5ucZGWimD2v2GlY45+6h6GB67zh/83JUitmP5gIe0POLt4XVwuKI8DEGY0g4ZmCpTNJrZCB54L4Iw0cyvXh8wIOpucSJXYGidCELg8ygR//nLv7iwYIXFM7y8uZU/+OVyOAG3QMTIou5P2XZ6Z4witVbPf+uNZJjO4f/mVBDBo00/LQ25tHVngrZatFh7oslnYZXcsCgdg8G8Rm31iY6JKSfZPtLQ/pTKOlAeHFvizaF2SduSQbHcybmZiR3Whsf8ftWn096U/x1TbG7t72W9uCVpBTISZPbAvMGX04JYHo8wqmOYHH0DFkNYUV4Wt827Q7+rsfbsMusG8njJjWWVpM7SpmMiFcRs3mg5YUajasLqQ5dL2yGhtU92jaiseM1TnnzqQCNaTCU+odO/T3gVGgh1GrmQc5PFOrMk2MePlm1SnNcGe+m2QvL3xJ36G1RjXeYCM/53hZcyOjNNkUWP7n8NKjEBwiTs3lahVZDgf+SwGQ9M6yT/Pz1yLmU3SpsJjNckpJOtfzats2NWDF7Jya7bj/0FpZPPQzo+K/xc6jLZiSAeWVr3ygJ41OUPV45GdGlF5t1sjEkr3gUAjIztJz8vSAvg2f4+7J6xIwFzsUhnnFqbCx+i6krqImAH2cDpFUI4w8ISEG4G/U20GIUeLPClBs8PFrK3TSzaFTLZR4nrjc8c5ottQOxVA85nMbUvRptTaFesk+gTFyZ7Xq4+dlK3U6IhW37b4NSd+L1k0ZiQskm8ANC5XDH8rq9cFDPEojMhMJJ3IoAV0tsy3UFRGECUAKTufyHj9aCP106Bmnzjwka99nswc4hvhJy7CyU2I10bGh0THBJdMOyXE6jcYCxFMkhz/I/QTmy1Ml2yThvyRoLmBeM3UJ8y5SI6SMVQhTv2WvlcH95wn4c2n22CuJTmMcSkRZK76RuPU/6nQ6HZ5J9UZAAQGX3YQ5PgBayrIyjzMNI+CVCu7ocOs+tfrH+FCdayD3ZiB6/Dnt4NuHPoHeN48oTTC83vU8vnUTIXUQkLu/PU8RR4KKrmlQuSIwURvj7WXzvluOEDDWtWl1U7Hy0EesiH1MBCfZ8bJLpWI4DTO/dctdKIGilYaZLTO3z5TkY34dajC6o+D2oXaxfV13VNER/LNXBKhcpREzNz0UOtXMDt5UowJkJNzZsyst+Kg4LtDmSYgeRMTllz226hkkZ/jLVYwlWVvAWUxKtzq78OBY8jzLknetAMGf9PrXFrls8FD7OIgf5CWTzUSIjxBZCskvYfL5TkKusPhqfQw7qQCg4QprsSlDEjFhU4iJIwnRgt56NX84iIKEKVCWndHKUFdLa1JMUEu7VcnU/VTL8DEYrvfB2ZmAcnA84Tg5lvq7umj8ozkqvKIsR5VB5OElTpd3CAQ6rqWsj5LdruTa35nAT0d6kE7n+tIuNuvs9YdtOS5ixZTFvoEtW6xvX9z0ylDHVgjdfWJvgyganfWYttZXflFkGH0gmGCnzHoAVUG2SlYT/fE6tld8ryN1/o0v5JdEgN2Q+cbgyhCCObTng7GlJWE3n0csfCAVL9Bp7JpA5ACNP7/it4tnPcsE98RdWH9JCvg7bmm2rxyB1rFvteQigVurH7Er/vOWWtAyUGu/O4SBmGhoKq/lV5Ua7EM2CVvdc7tI3FrBTIeVyRXBsvmW6Xt/V2Fuv3c76bYDdU6i1Ffa5ylC9Sd+nG/jDSUFaSrNUv7zYvKaBR71YjaJ3QQXUCIEJO+dry6k0W/ffwI8F91/43TFGIJuq//uwHuXZ2htoUW+9kS/vLd/e7RzuMrcvfDwPaLFww1KCbFj77BrkaYMr+NAoAeD43aT6Q1YGXjbfez3UfUQXsIC5VBxsSw24nNYFMxyjcGUmsmlLR+rFm8EHhXLmnUUi6VYGGQZCgIqHh1HOixkqDVHjHAhf3/R8kVM7YXX68ruF5xIk29T6FuVR/2c7x5twWhaH/mgT2HV6HIE/xAGyu2162bpVxUd54+ozMNJ9FSD6d7iG9kTCDUTlSpI3OMD4YOF/xJCkYsPQmameVodtAhk4ARY6ccLsF8RC4eSswXjzhiVb/dPmwaf9k4QmOyEZe/3bDxUOCohdLavEqzomLrMFCbRs/eIMUIymAydz+bU6jwtnM5Kfk9X27gF8gfnCPoKJHJzcwtuDy1xPXE2z30dnShfmuuVBd5cfiFxCZA7grm1pjdTEC0aLSsLRb8H1QCF/cpCtBP8pB0S/dDLpPy5LBn0XLO4iQJXbVL1eeIQzpFq78Rimfs0iT3bPvrOf30Q/0fESJZ1V9qSYin4TSj5ahhKkaEtSFy6z9Dhue9GcXEemXm+xFALFxH/VnDJWWYJB65iUsgTu/PQ2QVKyWYUCPMhwHYxitHeHnMJcSJWOCaPLVjdovJHCPHjZP0WMd6Lsbc/ABZM1n2aAMkgusTXIQAxEwmeMuj16AVH7VsmgFjubN3kG9wxIIk756cPHeuXDXXsEBDV+AiahzNNpDNgzJDeNag1Y+RCn+VU+OrDhzuL6sqmvFnTnCUXuRpgQNF8SS1r7O8r3QFdfd504MvunY00zluHIrcnng3dJcVmp3LSOZfZV5VREndEhdPI5YVpTdtmI2xGVVTZryf62NP93+bPj0nX5cUpUdCdQnYxLor3d6pECCIpnvwaCCwFqZ//EeBv9U3BjogMPi5fNWnslzPSSM1lqP/2WehDOe6XWV6z18K+8pZQa6bOOzey+ao+LcAoJrgMFBzsi550gIo3WjdMGKJbAeh8qwjxIVY/mk94xtUiKVZyPp5vzxdgJ3cqOhq4nso+lzh5OS4JG0KDA5SFhGXFSFz7CAxekvqoo/XCDjzJTf2DVrEDWjNI/A6i/6kO8CKv5aoOxLILnBT0jjeia9+5Ukfcc3/wgOP0tyLssR8mn3bizuhwO0uzUEokgDgVCAupF1ijYzMgl1yulu0IIFixOB9s3WshGqd6gFJAJMTPdHWUa1oqKgCYGrQGboSGvmipZJmmqv3Toyu5E+aEhXVu/2DLit9Q4z8uKWOaa9O1TbSM/jMqHTl5WDoqzrUrtJrVdA8nvAwSKfHitRAP8sa7j/9Zn33Y6T/6CiV52+quJBwiCzx9VG8lALmsiTgS3wRnyNHBepUBuTW/r1ePAOgsJIASwRr0EVrAJwG0A1E9RNt6NIi3JRDHovZJzPukL0vZDNz8+xdjbaHnWWKbq3aJoStU14Vds7NP8FU+vDwPTtz+utKNvTbib0L3lgmo5Cbzq6v/sLgbAEb9lp3uySJhr2BIHiHIm5TZGsTTfUhFRRXHokM+7pRqkjgvPw8s55f/HupeQvQhOH8BajUyrD9x7RM0K37XtIltKtIXKMkha65JOMv9B4w0JTEeiWAjjWlEfR9icM4+f6MtNgj2wNTKp3dE05/at4cVg8DVl6VOaFSViILXJ3kIFqykAEEUgMg93KQeap+uE+ZTCha5niZpHgaH8EmK5HalVzWtxAuNfBj8AB92mg9AQudybs603L7uy4pN1+uq3wTHHbSIv4UuWdkhE42QjCdlnq0buCB1KZFXXK3Gk305Gu5ArSjZmHSrQ8JGw5/OUtZwj5J589o1Y4iL6J3BgZQwJsoqXr7yG1KVezUoScVpIl2Nso54boBl9WO0O/peGaKE1VHQATmKGJSJHpMvJTBTS3U3yOjtj0Wt8ZSJIwEo3EBrtTlf5uC6DM7h9xAaoGiD3lZb+4/H3v3uKdHV1CQUrcOxrSArknYBGE6UNzOUGsLmixlT8KOhpPLfq6s98ry9g+QiAsgGcqKhlDYmd70UArUBYPSln9w49+xyo6QGd3Fiwdmk6jTRbkZ8qAtLeWHHLfxngurutb8hfUNZY9nmUXPZddoxkJZOB7ZUC4f/PfTUIDP5J2Y+dFH27K2+bsQ8Gfu3Gk4fKxeXa8ogCJAZGxcfYFw++KDuBi8qZr16ycB4iY+AXa3kS0eGnbSIog5ul9HG8+XeF4CU0qpYTVR65oY/2RHfvgC/oVicDUiP9AHIwP176WLmzk/8YpO9yaGuGjeq2GRSgUAUaHlQLbug1elRZaCPGoG2NE9RPfFZ5e9yAWGjFSLtQuANYDUhVKP9FYd3F+ECzDmMBDLV1Died7UmD5svi3l6JslZYQV0YRpmo1EtRAfwc+BRaBR34e5A1W/y1nJ2qB1TGu1r3Or92l9+kg4Kfn57RkpvpX775HcLnvzIFIaDGtIk8dM7IYvD4/OD8gifpWoT9CPYrTb9STGzZMdf+fjAJ/QDw0qRu5EWa+hIWptVwMDfBN321ZdzI/GC/EcO2H9g2CG7Wbi1vnX9+MlXbHa1UJyetft9Vwzzg9eB5+7GS86dP8HInncJTOi+mftIUtnfeYNat5yHinSChOE5nrm6OmUE0iE2JcBesgxXu0hHcueonXcw6GbTUkCWuRb9z9+3Jys+ZfgKopfTxzLH7QRq8ZpSqzNCb+Kt8Rubq0aoiDOWTygcKLjY8WYP0ggVTEMCOPbSMw5UjUSarWAfujDPF8Iqd5nsPUc95X3/Nt4/BCgzSsgDRJIaIhs+b9g0DSB3cUc/two2Z2w1aAWl6WGmWabEAiLNGkfyyOn2+UF2rlFm+A+gMrodTGomKi4WkvGWAowYsrOLd/P0gycWzgx63yNU77zuln7aTLwWvwrk+CkGs8c+MZtUjk9v7rNeTACyS/iI+f+KnXHFlcGEa0I7s2VdPt7vESI1NNqey7EiEaXxDDytye6/z73Kl5y70f8YQxMtSlJ56AQoydAmTJzxzJ58KnyPnjGkWQr5Ial+m3q/vz57yVtkCslfZEmpkwDEwQ3U3OIZaMIwhHCr1uqn/OPiw2+GWJl8DEq5EK33hp1FeaPsdfJjBWEfwy1W2vHkO5mOuIHRmgA1JgNuGC01jNrVZTQ4teS0dxCEKWr/OYahcoyD4fZZu5VaiWhzaDx24Io5i1nOVLdtDSYGbXhGsa3k2T7bEAIDZkJNvJmyatFUzEp+ol9+7QbTBAVYV4GmgiJ5Mkqud18CtY5Ou+3fC3Ww3SpXo+gOyrPdLluz9BkV3BznGTqkAZTWtcJgwC2Zh5vpyZs7gNxgVEvmn1s/bFjjWDFIvbDHIJBvNlohdFB6UTXqKQHC1tzGvcKuTzA5EXATAeic7i+m4FMCPcV0ugzwd5qwoAOEZFBIUQ0bGlhOlJH2TO//0VYHe1AE/Z/bFD4OhG2eMdPi1/5Li38aApaK/WLbiTTPcwumkFU1A0URff5cWBqCY2rrG2ye6vFFxT7o4E6gLfYMd9CxJyZzga5arL2rR0TNvh5IU1bfONz7+6uJbt46wvnZ/bPRcmIQhaovFIUKIXutZjnzz6x/PG0iTCH3VdCCtFTEf7jBKa94ZL0An6mKkkpKoE9W/hYpxYo6GjRuIznwe3mp0aMNj43bU3TPU2IZyNYT+KPf9C4E6yfYuJ7jWxzwFx/Y+HWeYgbugiraclXcOlzrjQd+JIiogOK39O/7J6MEnHKfmFUeEkscEX1fzUtJVmEUTFxm2n71bqyzqHPuLW6F0t7jlVRVXE1B/QBF2w0yTESJov0R7eq0uwp+383S1cHqShnXMl7yBAdcPo3ldezJCm+gwFtq1oEHhlh1YPS00G/9bN5j9O6E0IscR3yWcgKifmnqwmFt2gL/1/mFgmq0TSpY6hMoyNsxtSxcC81Hcd4JgJ5/8v9ger62kVRZ1Ca+jeY0VfjzYYL0M3BwuyroHH9mZi0avmUzu1VKN1daAmZf+tfh42wCZbNFlXQQPrRfk0qIoKoChJ0QRBP3fbfIxQt684m3y1RS+rNnYgBaaOke1tObhNvb2mW8WuBGmFT3X+enKS4hgS4XoveD5We9bS1OX5SwwPMvlRv7uD51nzICbWYnrNpXErJ8KpCrAwDI5X1Q5VADSRReVzAdhQb8RsoXntBuXaYloa4V/LEgrTTKJWns7VhVmXWWl7N9dOSrbtzw0dKVMR7Q4ZrQ6skb0FRxEWzKKIgU+90YOJv1XBLHSsg6z7EZARWsIXHeFrAKlunkv2SvdTiztquBh4qjxEYcnl1jGxX5x3ctJnfeD3riQmikaacvkuDw3ojOTf2dKMI4jfzxWpK0IxOF3D39nvOxBhbKcTvvInLuaCpF7aUHKtvCud4cCjuFOOfJ7xuT0ElkPvThB5XB95F1EdtTxpNHaDfphk0UR/0twE+yoRKRUGiFN0RaQkF8FnNs9GPExB1B22kqNmHruNDhqVjMEbA/BVKRMjq/TuLC8rqZWby4hHvdetf0t2CNhyXBb0IQDs2pjZ2bVfb3ZjFRr1CiDkXfMddThuSM2PxUGpJi4EdEkfGmUMFJtjAlEyI9jvhamzIGTMRdGvZv4coif1a3+PHVtgIFyR3fEGfH4F+gffOty6XVYWghd+vY22vghnwLhCagtfaUrk/LevKX49iJOv28Rf3DcguXDvlr9Hv2EVJ0unLXHDp/bOfUjbeHBk6mvDoeYzsqpv7UA4FDH0YUWCOiCwKJYo30JatObglQrLAaL02f9QeZuq7jMjGWoqm1ZoU9OJqCHDGKrakRSbcmjI5AMyxcbAfmDXpmEkTeQnt7rXNRkrgZZHkhU0unzGV8JWTm0HDV7qmTy0du/qXBa/YmZkBTe7ezDsV5gvMnzc1QxOaZFrxtFyCeVhrpHRy7hfSJjqzhVSH5pklAgvpn+HVIlCQ5Ozm/C3IHw38IJFzka2m3Dw5lxNSsj8U+jdk4QV7FnfGx+KfbKi3KVIF2VT7bPFeA3iSf6+yrUeWgDrv29m+oH2+kvy3Gc1FZ8fG9FhJKIN5LXqea5U9j8B1jWBY8975lwM97ntWbW/Oed9a/+GmDHIQZJLUEZlmvChTPh1dzYpZRQ6wh1tDlpQBFdsiRNNx2M8y/b72EVCX+h7Utsb+ulC/SQ/Wd8NH5IWIQwGBV3w7iWon90XSNUNPr7yODC5nlUevvWOtg2XgNhONojxmfCy872fX7m3dnJ0W464TeOowpJTN8lKs2fNxhTmrIKML7wy+qufdooEHpbhd06XOhnySinnTtWoHxZv2o4CjwiC2PpBYAGyMtOGX/4ktAyPlw9x5pqRH8dcAdds+DrXZss79aSSmHVJRSEYnru4Dwt5UdBFBF6GhJsZfFXArH6Y+ZSFQCzWsnmRe948RFcpyfFL+0Vxjz+YsQfHd43h8sHHh1GAySIW/QtplPBwtEXSGoEqn5xcGZxkU/pFkJeVVK7nToMPoGoXvkqeNrC+4POU2feZPJB8G9lX2z14mdBZL025ju5FVErvoWI2jjuGajquuJPmSHWDVNU+PuEZDFrfTgp//LNm1ULLZ4Aa1Dn9KCB+Co7YTBtidSnRNkSHR/WNgsed6eSsr9ED0VBMSQaxmFnBAXE8P9vKRMlGdace1q4ueEJpmjrxH8KgHGSAIVAExFYW41ihLHhEgYn+3ChN/75WWysF/zjlHyFT0t8T2z3Iu1VwGT2Kg+YPYkMXTMpE8CIodEee1x5olmKCCA1T8tF2KC7g/HWBCRVNlnZysccdrE2qCwDrnfeY+ig1rNPQMMUBmJp9vJks5RhnB5slMHdDPHDhgd533XwJBAQdhRU+zs6jZgqk5M78Jtbcok+CQvwh3LEKcW4hGlqchllJYwtx0fR2b0hnotUVakyjGO5816jaaIIhxfEjCxC3sY75bddq2DlnT7GZuxp6sMqQaqHyzPmXKBmQejOMq/I0a/DCwRW0LpdnDrzd0m1cK92NHjPAg6nKNxnsMcsgH1ECpuAbgCANphGA9+10SfncWV1mvuXQ8Nhx6A2i81NtZrxIJ+B+MZqFJUQOMJTVikAMS4K6IedmE2WV4z01qcYkpHvzKp9dOCvP5unODI5ZQuf1F+bOm+6eOgCZ64zjLLjH9f1HnfzmV32Jg8P2iwn701uqoyBQNC/Yvh39QYb80OKHyixzfzoU6i+UiUG5MnyCAzFkGsx9AfEbNIVq62k5huUjKurN3ys1XIUVyGuG1fdvOamhGXP3yxjqVVFNTcFtNXkV2wZXblDlqcDJQcDgQUc/cJrEnTuB32cqj3WDA7caHzYtWg8psxmnQtQRuRp1wM2Z6Kz22/kMC9dpKWq1YVRszcot4E3aVQKZ2a3GFZRNI1t7AV/y3omlLWNRBk1M2I/VNjibNSFlHzCVbcNWNCklljzJ9I1lV6p7yVas2WEWJyvGOB6ItXiStmmRJreG2HRT3M9GC/LE0oRhDG+1Trql/v+qz6f/G+ARJI1ekvb/72GO45JwhYae+WAXtkoyp2GjJFI1mX8X4+5r2xpKt3L8jgpgxrvxjsLqXO3As4S9RbwZC8jO4tuuvkZhj8J5UMio4P8fiwmlwnugk4epSRAL5BXSFe69uu/TK+lM+YJFPnvDfxV3VjfDJaAVm1XRtJEzIpyH9v7U7yKXfsa6BXQK8SSqP67/09GToON7sE+TkMMXZ9EoDQIvpVBHmKb2PWgiod2L5q4RbiOIh7w3O++Yafg9vcno1sNbyEd9wEhLNiVAey+hslZNAeFtZEd/TlXYnmxrg/+j0katgN9M2FyWUZkteu/2hGuIAJfGhheq+FBrKZ7/IwWG1QAuoGIquCUT1fHKvSC5Oyi8e+9Cn1FnuedcaEtnFoMEB70TkT+vP42mQUFxdn8PW0wvzoUVgQWHWn2E6sb6262CYqSvkyOTISIf32ydfekMKtUYmzvDzfN4Co5wKhQ1cr/d6lYZRNGG6DB6ouSDtBUpuYhbG9T7MRBH24oXVb+f1OBO00jv4pnIoyN84sS2HMV1zEU3r4jn0348/wDwoYce1s6bTdzMtWwr3LPoY/1e2/hmI8apW8y7AmA7cfUdQ+/HuENMhgvb7KS/+bXMSIyAUMUfCFHeX9X00tI/gACC251OPN6btc0IxoriN33ssCWTV44kU0RBB1JX/l9qQ/8m/y4DDy3G8zgFxH3S9v2/G7PvdR4caTHjlNMBj2kp/4E1CESAJwH88c++YunZOoPa+9FWXqIqLm9SRMAPAzK5AMQ+DMNf3sVNKGfxie4OgPWmS+/B/7dL8QKmNDH9TdHDwIZqi0VTPaHU+2nwXuU9ssJVjRMZ56t3kzNQhwwjYrzN0BcwNOhqUDxHExNdtrSIS9+C9C43MQcMDYgfDHY/V9urZrIQqkfALR87jRr567LUofo2lnBs+yJv4V8qR0ap3h1rLYMRvJi4VraxcdFwpSx7Fw04K72fc8gmLVSQ9CgtEAdmKszw7DFH5PvynoUjyIDQBHQ/meIyfUAAHerOljYd6Y65hGOoUXC+kkleLODfb5a/CUEagNrdlCJjf1gpLF17jX7AzxtV6IWVXOA1DSw9jbbREd6+oJyQ702pZ1yx2NQDe4Ivkqn8+BB3KxXoX4HpA/D05OwvJyIdQHR2CpzeEwwdpQbZZGDK9dQAEmzgnypOZ6rNVc+Ej8VmIi2lg0eJcPNnHaKBMyRK5dudnxHikSbU1PwNG3RAyBvRPI30g6HEo6uVjUAt76mWu/liIR9YttDcOKz8CXuIMeYVxjSRhF9ny/saGT9yDGk2q0tZSLFYVkJGET4zvK69fR+UAE6fdFSHAI5e/9pIwO9cVaSMUN0tkuUUigiAZrTDrZPah4AM4e2GHSPfTGsrnce+zIsjY7koPDyKWpamrm+LIFryhdTxDfPxTHRNO797Ca7N3oBmWchlheIxvX410V5snkB9qxTlUdr25bdzNjfuRiWg2+etqmXFpa3OKdHIaLMBB34br+zBqfilKL4JIYftITlUCYDwDpiYkvqJnUF/UOCuhJs/S2Iv3/aXGKZtamiQlv4a2BWlcXDmQ47HHQ4gEwpKmAKagZYNhSxHdeowRZrpeYR7E6oFMrM67yuX/RK6e17xezAN9rHP2zZCPQer+RNnNVMq6XM9Miq9lFAtpNSYyP1Vyx/LmWMUvYfmaA+9Wrs4zYIxrU4NHULSFa4vOkmGLW4LtpVxfbJG4jzhXXAC30/6z3d/4/PGcglXZhXJZ3T02f/M2+FpiQ64eHGWuAMXuAFbXI4n+S3U2YUp1bg0mivuNjsHUmwV/6+tSNfd+TY3TvuaGSynedjvMoAx7g84Z+A0afqgagT2itflgeA6w6DCslqxRYViGiD0sSsn4zXpOIOkH/R2hlRxVXG5t36vE+EAfLaClTECArxStrVeZ8waIeI3oRdoZBW+PQKQIXqaRZFZuveRTSV1zhB1xp3DuLGLQVblhYK5a59gizyTqlAAY7QpEX7NI6vUoowQEf80DBA69YHmtorCxJd2JIZQrOj+66ickmLfxEyVQExSMhOy7krryd2qnu8WDbERPwp1mTGzPiybPR5o5M/exOgWmCZjo5lemDy71GflDnbeNppwofRQDisGR9qrodTivhCXrRB73clbjSEE8sFMLrdNl3djSSNBZKxWrXO/rgeX7P47FmAMnarDH7iYX3yfgaA24/OvWa98TZXHvjbKcf4n3pTTADD9L79ZSXQiycGvokXHzeLfaW00x/8xh5RdwqHzCEgsuKbgxx2eTi5pO7owmM8Cd1rJ3H9gj+MVIgQUEbMvxlly5vCLPtR7xdZoyrJSpldxocFSL1eFVp6KkjGxu5Aduvan/mm/61ESgzOLryhmgiOFGLa4wDaVKaYbPI1QUv99OpbNrJ9i1m4ys6pC6OeAwz8tLIGujv7INEMwYLiVRgFcxtDotSgdpKHQGRw/l74CJDTDhRcuDk3FP0vUPlvoniskR6QMfC2lIy99Od/NaQOesPBtGTk5T5ZWo+4vj8oBUoK7/QdZSwRWMS3Vw2zfz8oxpaeK0xklOgmf+x+TVASfiqZIGHhNbuu/4XbyZZ9ea5nRJ22HozLCyH2eXa7DyteTTriYyvD7G/6pn5x/fwLe2hVXc7H2VsU1wltcXYCdQhllwNP2J8eu6jJk/hQnofeTDGDRlNjq9Dr15z/eMkBKDkHAr6ae+CplPLIbc3j363/Yau/a/xja/RESScBVLCb0XQJkclyEkaObykhb1UP7y9LQbkddYNfYXAwkXUrsVQ7qul7xG4RBG8Gb1/7D6ok+yNBmODK53H9Y6F6dIMugULoqYlDs02Hrz1vpaPMwj97RNMICdMnGA88F1KfpeR0rT0QEAa7HH69MSBdc+qShUOqj8HOegDJsQb0aCXwyRM4UfPiWUJuPxCWij544FgNc10j4JLUePUm3EZqRAXaEBJpbLE/1egezhBIOtvFbFkZ9ZRuhUTNRzIcnJRakmzqeB59LSYb44+3uI003lRolMTNZ3505A4zALUoIrMQDWWiT4AUyAdKKxOpAwA/zjV4CDDVvEtnK5CZ4iokhkOWHW9FJwYR/CPUFGG7+KzUzOIXMZ3hedWdEZ2oRkxflysIc3NvduoBk5WGLXTJDQ2Lxi3LaWDg/uKCsoiaCbbIeIBsYEf4m+Wgi0zpauHlN9z2F7gyNDh7qAUUjtg8skjLvf+rbz3hO7CRwRcJH6MLSAVclQon3u0s48j/n43WNpjcnCK6A6wJmcU/XR5nASupUanbbSPKtURg+ugWsb/hS/lnMFS/NQK8uZuPJS2nFqbGoidRI6XzjHUQdZURPdjID1PfLR0rQJ5ZLQgXbeCtwQSwAn7xpg8KQtodPkyVqnBT6yQEhLZsWG6xP/PoHJBLG2YL2xIMx7KA16QHX3Zs6hamT7K5VsLpL2fIq97xfsuFz/qngi41qwMpi6v7ufVwkfFHIuvkSkcVcLlTbb97bKAfyuWq11j/zfCbhayr0Jq/muvMmLsY7sV35u/as1nUypl79E6dbr3wJ7E/0QaSY4CPfPBPZ5ayfQ/hwDxC4ILUxDW5kMRKqpxUDPh/wI9DsGFCC7Y5Me+hqY8pDUPvO6m42LKYIdLzdU+HuaLYRCYuDRGDCqRR0lA/YgAwCkalwRy0G2bPDJSooU109/qbaNeYa60VRNV+OFrNK67vkh9jzft0gdA73iGRVg/3E7OXzMuZcMHpEIA6mgxeExs4UQv6nKxPI7aHIGrcd/IvuaOgurAbEnGRUtK+/AU5To2ZYT0VCDd/dpgtw6Km4k99SZ1Z+Z2HH2J5vOXIrxtTaHTauYKHENfPljGq2qeB7ymM6nZ5UUBvaFVabYU7P7ObVQ7EM8Jyl7YbPNTS33Eo8D1eS8jh6V+G71S5FODgVUisFHhdCZ4QQy6VSOtMRF6if+CeS33qMGmHP7gNUXg6cWzjCz8jP70lslAeKEmzpxDnT1Z63lSImeucDSR2qCy6GVNsuu4yeZ36jKANjZQZI6Smnq8twcy+XSht8jcH0hZ7sMuglw9PVSoBImHqx3AC+/ecO/aqYVL0QiB5QamDHF+oC8lvygZhVPU5dCG5FCPWf1XtuS1N6vWqp0rRgJB2+Ur6MD2l7nrcHUyzyksxIJQR38Qj31nU2NtrW30v3lzi9mGwkk6cC/MfkjJETZL63WxMwWisOkE5ly5dyt7k2i8loCZbvOU/d1zvKlDRE4HAJKgLCEgH6kk0JnT68K+cVYXDNIPph6JCg3AxkzvojnAKn6KZwCm45WCo8zUhYq1d1zbqQit7gC+NFp2fZMFCsaaEDBnL8oM05IOkILGUH3m+iSxrvlXOItkMJ1Z89XmUKcyH9jK7/abas0boR0oYOuTaqhC83yasIEgxwhjZZfp88dnbOXJE0o8b+tw25pUwkbVgoXKtqD2kMXT3LpxS1UitrQbLTm8LcZ/2MAnL5noUArenOtd8yWgSOx6otm4nkeJ0smvdLGnVjjOebf6fjfe3sWJR3jdgE79iEBRIYQZnypBV6jXZ6VuQTrJHOhC210DqsACgmq/Vn9SJSwvm5OcBWK5Bb6RJpp4YjiT9fgsHjX0bIys3VFenKGOCxEHFQAxs0oqbsgd2PKH4nW5tJNgvtaS/KWHyGLQC9pnyA+6G9Dd4XM9qNr648E+Aj6jJGLqXF7ZawJD0Iwd/KtOPgrOTKj2khTw1jPhX64MMeNeqT9G9beeRJq1ujKOFIykX8YUfsbT28orEfbopxahWN5HzQpgf97M8ypLeSG4ofaA9ORe3KlS+CXR1ocf25Xwy0cIwhvkgUFt0Ob+LLEJoaYeDJeNxxhOdm+9dbFjxbVpPZrHT66PI/QlRwF6We37VN7s6NINXiAOKRrym6rZJXeNByRQitDEjEoZCwBWzO+QZplmwIA3Fn3m+14OV8XAr4DjqavRNqGWQIyadl9mFw+ff4E5/C6ueWwtee7i8v4pQA16DfBsAvrsuDQ60H60rWjt16oqudNRy9VoJi4ih89UDpAo6fqLxangiXDfkNy+7/Ss9dK9iRVw2BwXwluYjJvecpxw1i261g9iemz6fPcHjBQg5ToChgAbrYHxPH2xxcytqWkPKnLVtLqsV40T2nR7WejQbh14Xq6W1Q8r3JIjsmRBXOA5fbzlEnQUGkoYS9Bm/rlB7wuT4J+qR8VEmWfHA8jPmVPdBgq+Oc6jIHhkt6Vg46da1CkOPXnSIpE9MweUB8b5bAk/pMIaTYuewuFQqlClkzEQdxsx3cDCXShabJ361gOENDvqhnuzx1jC6U8LhP2YH7iEQsgJTlj1W23AnEQ2L+Q6KrYMw20aiNIt3bD/1SDQcwIMjWGoAfZasTtRas8wfqTdjbDS5ZJrCSRUolCMluUF9+WeTqnBGIfeEBInnltsnQflunmog3R2KwR+oi16fmde3V7duCOA2dMvx/0m+6oanPYw0D2g4fyjv7Y7WK7FLNtBwTOH+ZbG7SfZzC0FzpfNOorthwMVUMU+3Hk0+mpWKDpwniWlFjZNMSe90mFG7jPJWf1r9A5WLOT8mWOQHoTL3BxGeFTBKZ3zbUPnIIKga26pyRdKOFJl033ovReZYAdeucKnpMD496ASRwacEhpE4wSOFDbw/oTjoq4d9cvfenG90o9zCpdMnZpSYq6dw0UiGKR0/SN60tmkhwXfBjYJzwsEnmzqtq3hzXOhUftMFI7dvl8Lo/Z2LtvWm6F5ulHs0aD59z+1jLoCv+/cnS4+8OcriRfvQiYaDnYGbSOi5CEVo/S+zQ6utIhr38GJ+64DQ0UfMc31OO7WWxbeshJaBSieU7Eahy90PUH9+eJhZuA0haDwRHxoZdEPyRKsfecz5ftWHbJSzaOg20WKUp8aEb+sf5c7lnO/RBIbQrhhp/RXuSSScLjTCz0J+1qJfwUvPAhV4F2kNFnq9AQE18/zbLCtrIeb2WCQjq9kledvsZwGz7pRN+DkM/1wQIJQ/WnvI1BLVOz8SChzqHnWHFLcYG7z5KWOj4lpSf0/BHfhsu2ThiG3HFKxe+0bU+1D0crTLkKKspmmjtxLO+eMchUqnP3P77n9Sg1IauVFQXZBs/6EiVH5MBG9yjY2x23yxebdc8+FWHYL/H31xwfxvMMwz66J/hUwgDODz2LAb+2/bT2LwWWmb/jkk3mtklMKXLvnfFWxqMPtPDkav8ztasKXhTbAntaRFDT7DSLe50JtK4NfowTF9hlY4cmigt1rMwFyHYL7Irg1HkC8TFpAbR03+DRtFNy8e+XBVxvb38j97/YqHluQIsvruuRz5PiMoQEBWpQOfZtA7a2sXgklacRbZUkKi/oboLkKdZPeJZbxRxZaJqOwLkh2UFaCnnOEbEpUc0B2293+/xHbzr/E4S6teYhJ/b9mzwwJbH5R8Njs0EQ0JMOmuo4fG7Sf0DbFo3kp4OVRFk+Ln3dy9c5GIoTYCLEIMtfGmaYvE5O2FHwLlXmnGA4TqIwpZfPUK0ewR0ZhPA38/6VUspIPCQtqn4yB+WcGKSCRsInadBkGFOOMlLp7ju0STl1DHvYffdo9qYn9T9a1tCPg4TZ+FnQH6YiELIHB8SbZIUWkeFgV6KgiZXCwLZgG0OMWcNuc5sjgYmv4kZobSknbgJHc+Xtt5qSj/ixXFSxFPEmAijRRYuzT43fH/80enetVoJ0fK/Q2hxIUGOfFdPH2tlYXmDvPAQjrzk0yNFlr/n8c8ThKpJf3+bPmeQ1iaZYAGtZS36XI0uVJZr6E5MuHIQtVp6q1yFUNKN52L8MCBxJbv2opPzvYxKEuYj7regp6GUG6OEJiCn7OYDisMhBq/NH9NzI+mS49kUXkYY9E3Vvo180ITYqaf5pfZA6ZfQod2R1zYWLGFl8fRS92ol1kJrHQ86NremO4/fwBXgouw6PY0eqs0GKECBdqiKhqxKsVQYsmWiUa3nLZDlHA8fevWAis4LEgMng8y9D3axX7mox11APlJ7o+ypTjYM8EVrtIutdHfi11qYQ+hYSX5ZSSpRuH7OIzSNKhewjkMLU2E0NlUQhQwasPKZNHb7j1PVq4xKMpF4UTkftV8Oh8uM+4aOw/03VFVjFFVZEZ7L47Ir7sqEOQs7jMo8IT9joieI4avfajU4BCuQ5k2mwEVvQYOL9D03eEsEQfA8/R6EISJdxZ3wUnyaORtQw+UH6pKlq42SoBq1CYasbiNu1P39kwNGQZYDQiwyFoSYeTyAehrN1Zpf/d+w82lGXgqGhKw7LZgFSHlQrJL9lpIAk0LO72oBkI15fjj+AktskkrGhR0Ww1FkDddS+wXU/O0V/XBBxgSYwKaVUygZYHUpCuHmhzKlUJv626zYOmCkB+M5XMgWh6EzUcFatNzGYHlvr51PQkwQnvqHvI+xjow0VG2M0X99qyfjX+pOPHJFR5AFYXdWvrSUunkGK1RW5k98cHcGgCsJF+g0e/ElBfzLM+V4M6TPY3KsrzMVNwz1g8/PmhNYDYRV6t3816FeYev9QRM/qFHokaf6nZwEmPhwfQ+A3ZeaRAjeP7Dn9IwC5sws5StIdGsm8kgvxat1ABnZyaTMdOWm+uBtbK9C+PaOczNOCxUAH1nlI07fBBsXe/iKsZ8E8Wr50uurRwthlIMl+b0JaEXXNVlHpiGNwa11upYIjUegjX2VAnXLXMhFAe10CLexrs3NVkEukOLW2++Ph+YYP4ZbmNoZtoSOY5x+nXp76JGQBGHWCJwRfNdnSlTy6yBjgVYZFmU001JqGVTigNSlZRqIgzi1knWfXTcgCbUGvHTzj3E0Hpf9zeXLH3itfWdkDlmhcnN/O9tLIPeMxIQ+JHE5+qu43FVi4mdQ14I63ZuuceNQDYJeEPmwCCmLnWOsNseFYA42OuhxAiV1etmjSqATGIFqjlIHV8bvxcphOuYSuFKJkGVYq1n9k0y38UTMA9XfzpifWQ+sx8U3CqtrEGsUmtalFvvJ82YXTX1mllDh04PIM06csZjRsMbYSx3cdKz4c0jo8n1+QDTHpOl/DUZcHr6NFQfELsWQ+mfStAsuq5L4G37Z12Ccrg7/SP5Npg8FJMEu5QlQbmdBORzPkhOuUH5t7z0YFKjDMbScDUvdE8HhVt87Yl2F9twO8AxWEoDfWwGkQ+FfnjlXrFvDU8yNKCzV4JtGTLiIZ5Iqzj4qLUfUVkKrWbiSj2o+KWWF40IUAXXriigFXWDAApiqp4jIiizVIcvR1sTuNTUrBPoYWiU60howhK+7s38+QV25sfecVjmXDVf6L/fsY8scV77a39bguHyEyjdrv0oqxKVKgjBEwDdQ8lrmdsLZZXn1WZCMwxXzS3cwL/S74RXqbQoVwZH5B4rNRsvw3lEtqmNzXd9G3cq4ktF5c1cP3UVMztjjpXRyqVRGygBN1M4zRiO0VX9b3jOPJTvqhldocfyl3I/RoX9QVxozktWc9I9bZCIppy/a9MR8zS2nuF2xdHQ8+LSQBgZv2rexedCh4fkJdTK6SQo5BujAQkmXzsZNjHavGAkLSDZlCi4XuTCsiRXEBWNyHHqJ2Rtkcj/NJ3s0JfJEyg2A+4ozw/fzg/bQaaTUJ4NcUFbAKVCBCPBuyGxdhICDR6zZqJ8oXBYLwkAbzpB/5u0kBhD6csjysvTQAyeiZk3E5WwH5pgGe+osFwJOIByeTRhYUmNIxyCWi32lIp3F52c09mUMRamdgYmB/HhdxTkx/Tks3obogpKvO1HoTO0poAaHcSmWXxyvmzxiYpJvwX3u94sTnEs6z//bSKj31AbpgmEIITaNovPL36nT6p0rsLcbUdA/jRvtfNQg+ulr5QDc75XVKaF+iyB2sB5F992eoxCeVyZBDLh3gEypeZ0q8PgA5BpXBYeEiDANgk/gbbjDM0M17LNVIJQSuhxIH1pRoe04GDyxkyzmD11wbNZEc7bc6NmsaswAVEXvXgAa4m/UUvuUQ4oq2qIM0ERKzNbyPJhqbfUfgQTcpcBNr2J+tcgYm9XDDoQh9w8415Kk7hVCElA8g12J24TJmX+M19Wpe4JRh19FYe4ehWG28gpNwXisMLV1CIjya6x1SZec2+V1P8LAwF0VEihphIUuSjZQuKqWkaQbVskpbJlKqWfktMIrUGOl/Nin7AT5QFp53obJDjSPVukWCbTKwdqoFsNbl3mhyZeJofl0KnB9ta0iJAsSW3NWmPRu3S79QsTYRamFabksXvsGFbW8Z7vNKE7cutVikfHDSLnsgy89NdLPwFynNp/P1VLsZUPSD067SoZUy51BSxmha6Dg/rEOl0Nghm/nQG/hbOg1zRuTMtlUxW75wg1DZtFxLLytpl5z18ylvhlvCHQK7yWomR3uj5umUQx6xn0H+kzxvR+6wVgvyw8vutvQDHpJj68wKgqzSEi/EkLuNi6NLZfZQjm1427NGlbKDUmjp3/TmvqMsGEnaix3vxmJSJqntl+gWmqvYX8NPAe+bTpwsy1aMW8wgeg1DSqW5pjVrKlNCpu/Gs5jPBGT4qPwqbF4os++7Mki9Y77Zfg6NTgiDnmEnACsjbGVQ4ZAyMzvd9Jxg+n2xJAhyUHujnupUQeyj8xiT3h6ufFrc4m0TSOKLsLB1Id2W8phMzv10ep6Nw29bQZgYSHKz5TCdgfKqzQhqyh0mZfPHf4DwjhIzJ9H9FsEcy2Jm/84Eq5H/7+ueqYnMjx1494dCcUyBTd7elhfwTQf5B+W6oYIWzbzBki55SAWaqgJE/5OnO5FuKmUsmuxVgXQ2RniC37+UfPUvkHeJVfOpat1ef+OSY6nUZpeqq4Onaqa0UBvHu9Up0PTXy+Y59+dcKVv6JQftFAWW9rUuYeBU8/r4ehJ0FmfKBVkEalzGnn4rF3U4v98vb09XSh7+1nP28wbQzVvCUMDFZsGcrRh1FgtptIxE/pUS2hyQ5X7Hz2vHouaTLdCxWWM5jSgqwOTKW/YQOH2bCHVUTK1xTGo9Pk7qOIiAwRPldTx50sx0jYj8b5VmHjwV4zt6eIid2ydczUCFg1zLRsipalEqGgreUY6usZ4J2orioR9ecA64wTHc0BDwOn/pJawOefCvXXCt8NPytk4zfw5TMx2iZz6YBjXO+xSHY4gBeVlMzROPPYm6HXNIe6ZJhisOhxv0SJmYjA0XE1lyzpHCfCv+0jyKjQ7GggYQEdzY6q0Q9Z60eTRQznGut+8EkaCabUHiajGeCXnf2FvUjfzH3xz9wVDJgPJpnElKqz5a68ns+E1Vz8l+EYgbvld3LrGWb0OOCqVaCY4dVl0YQtFw87sgcLvpNY4STP72YANGaa3UQfA9G6aVqVOjW/+j+mEudBDXBv7KPrN18AObBgWMeVSrMzgugkCfTn+aM6UDffSCcz3NZrRqc8pyIn6wskV/s+AhvyJHsYtb/ipwgjEMdkVumfYIfNX3HKQAcjoIqfEby0EQp3HbWs7v1P6sKoh6kfUajqkDkr1IKa4pijROrlhiIRV6wfRiHnAcm4L3FI7gq08hV/fxqEGhP4+gxSg8sW5jT3ZRTTr1A+kaYmNhjjfXFupz+hddmwisRDIMxhLyTtNUq6duFAAMMiLFJ6Su8ymImOBpOP6wGR9dCT/J/zIn7s8CdsmVy3QF38kzWp+DSyevBLI9qov/lxOje4nU2DMApGD9wJc4kzpZjBE5KFA3QDhEqrBjSUwaqYGLFvdQfUUo7Ef408zLt9uGUU130s0Lx7N8DhDafR74sLSePxU0nEVWZa7O4RKTaFuXvOeMWpO3L9WZmNBYEQHksSS6JC1rBrg7Uyj27jcsu1GSnb9VL42fo1QRWDPC+bO8v0j6n13MinwMYMk2U7edNNtrZ11WtePAKqY8frSGtuIeDbbKjfUitASun5zDKzbIQtZGRFiu//fPxXjUnJyBkSTcpHznU/ZNhTABDsNjQxCxML8VMMREOt29qBkOzkD4/t1o7UZu2TrZMKMb/9z8zdqtOs8awU+Yr0a25eBm2lkOTT7tIykVa9BNLh98oAkBI0T/ohjs5RhJr4J+KBMVYfhygWkiSZzT0FQGgpl3tMz+CRVuvfQG92y1uiiygbaXTKQCfMACaCjcXvXy5X9oRGTAYS1BE7Mhd7+BOR/lCVZEHbz98H6wsWVnYAklcBU1wF6YOk0MD8RQcvr78+1k76zePRfhPmCJzmLOajDDNrChXAjvHWsu91fmwG0Hd7yLZg5fcDsvGV07T5IXhavIUOHS/j81xAYEHNadKBV8jxytOJ/5joFY/Dbq8IdKANttVxAe1oxDHJaXPobc30HScNv6tQKcP9qiDd+wkQTp27G9G5OVZG5Jm8ASiuWmcyEWu8b1vWnVlgN2irZ8QaT1KAQoN0R67rq2vsgykSLJepMjsi1xQbL3xSM8kjxV4P2g8fRU7rylNkp3P66wLQRHg3RnwE0VIH3RCrChFtAsJoXi0bayDdnrgY9y7mZy5nZErb6EYKgy3nMJ+VVz2ttVWLTGRblaog6ztP0dDOZIwIXZGDHx6jg7vIgPBmmmzrpgGrGUuGuoE0SBn7LlKphOUiU4kSYm8U4re3381s5J/8NEec6sDLzdZ7cnTv+2834oyXYReGUtitigfIB3e7eA4+ezStektC/52bUahm3/W9nOaw+scclxVIN96NSnHuMzlUke3ivlmGdZwuRQES9AUYawsk2FsD3wvazUwOGgUn0S1EwjbIY6MIeU8X3IcQx+mEfvyLLBdy08okXeOhUTON3qSyMWF1TRi1rmsC/1lPeT2ICGxLh0uIUJ3Z1Ou4eBN8du9AbIc3Xy7J7NpSaiTPnHtB5nKVqSJY0eXoL8KXeC3RKicUGRIHpvKLETIsaxrhCF0ywtJ9vICK7Be/6M36VlpsQ/PzJe5iYSMTDUM78HLH6uw9nQ5YYYm7J7dTdQtpgSXg6Lu9qUP6Pjv18zYi5kRIHX2aBrjbWND7EGKbL7TCsNwC4dHCmZ29h2SC+dk0b/jaZ3zm7u4ulTcfG7YGmT4G3302HPXNm1jFGKCgkql+VTbEHTihx9/sHdMjr5cdf/ueGI0puGE5wEcDxXtmxYq2d8mMh82nO+L8x23LEHCq6GOR2v7uACXRRHxNMNyuPtaZnyz6spQJz8dGufjYyaZcpSG/zZoVl1N1r7iUUZJM2wLuNrGzSo8Pwc3X/rO1s8+sIeYjODoI8aE3xl4MXC+s8qW2ATCuXvYxw4TkuXxxPeQaQh5kPPPP8aKBlIhIQhv/WB+XRio2BDZOnxyjRuFewaV9nI5YZS6mdh+GNEYZT76Lg3sb6g5vnmIDNKs3la9OFFFSzolNSJ3YGRD5mKStg7JAJCzoEKeBmr3Zhog3/tMcpxKHxNvD+ZC5DG5zEyCNf0VrHVzqjlQssj4+0qLDAIYbMYb6BEjfyR40B0GU0d0NALJ6CjFxgCeVW9FxzDn/7xd45Fv4NcqYoAW4TyT6FZj1FDtKPPmN9OvaFERjpi0IM4vqfY0wWfDOQBIriVRb2/dwAGpIGm2qiQ4DQY4vhPa/S1bdHia/l4Zy6ebtHQ3SHg9kdJvL3XSL7WAeQa94ekEpEhijVxDUcIBj9DQ4OS9OM/H3uY2FH3GGnjJcDDxoQPkCc5ppykVAmjMqsRe+HBO8fEviflNAtUUtMwHeCwAJnNdE9LvK2GDdkDWkKbIz1ti1UkScj6dvZAdxV2ekgckFfvXNz0rnVl8v64DABrDKgxaln7M8wylekNlbIDFsUZVApIAKdvEh0NoUBjaZBcj6ZLEoA1/AJomJsgF2QhKapHDj2OvHDWtAJTcwyU/ouv/IXVc02GS3ewL1FjpvPmzW+x5BCorOAX8lhjhbCsBs6F/zed7lt9ZII9YqOeBfY+fF2J6dHpIelC/04nQlqu8fNOAXh2xjTfSbo1q+768+qUkGLFMughyxyFuC9/ITgEwuXXEiddXYsz3QdAKzECLIsa7ojqA3oWTDRBq3q4yx0ym/5TiSv1+fbQgAofVeZCgd0UAevYe9+M+B2GaLTaTPcThjcj9VnZmdltITZT7sf0YNblgZn97eCAa7Sc6uic4XcE6LKFT+j8tn4Ocx81Jk9wVNGNComQzqhoC7QxGBhloWxG+Lz9R3jcY1Gr5ragvQagPO1FcOvhl3OfWkUDFU6f1vAh1M3/UUFDvBLLT1vt6FAy+O4e+DwlTMBV1orziqUsS6r4PJb/LIp6UD7NlGkoJKQlqYP9igvkhNJu3kI3WDdL2Zvpg0RPuiGqBExvXFN6m/JhZ4kXqf8pp73zS/of5UaW83EvMQxdUFwtpiaOanCEMz5MUQ8RjIDLwA4r4+2rb12wHoHC35SIBW7eVQ1aFMDT03YaoH7lz9lNofFZ4iD6cClL1SgkVo9ciMQRuRegusDwtZhgAQDSgrj1EV1xvrj2coyEJzppHMJN+/hk02HqYJ3eS+Pzssw7yoD1WSYleXZlQcPuAx0edvmqac9Gj6qZzEoBg7qhSTNRg2/lOXsdGcJ3e31L0FevTh+OYhWyDqcK5cPo/EKDVQU84I2rV92sAnEw/cFwvNIy4LxsN3jZZ2Lmj2fnqIL9yIiGdKGqiANoNyTYd02PwtMde48QwnZV131emHCDz5wqAy9Q6M/w3WqwTOay1LoUOieKTC/BhVnqLboKQH2lSiWfpFf1R6Gxj4trZBy0ymorlBYjYCT6IP+k+B7Dw/uaKrAQcUb8cS2qVgk8EJ6Loj06KgEf0h5weRdvg1c1jOrTOzuf+TccFwO5IC6xH/GLxcEnZehdD0zDXCeYf7u7CtitbSSOhJdfDK9NjvSRGyeQSBLCwFzsT+LH63hwxRBQU6++7+JgI7Gzk/qmqoCxyikp+/NrAGXs9P+nB3hrM8cTmpIZ9jU29yhPfU1pEtJa95E/ZKiHcWACIHApxrK0jPjHDhPmF1a1Hq/6ZFxTaa7X78mrdojeECu/Ae7bvqj63h+qlc/3TAwK+5Ozn8MgVLHgaRCTxT5xyyqa7vzlbfHr8Iw4O1VdhwhQG/kRng3FvL8AwNR8rdnRoe8b8jWl7U4IfMP1/P+B9JRmmlrgYLz/enW/rjAVmJDz6atziChJvjLNKp1NQgGc9clCRQ4RxEBCdmiio1VRYUmofx+52wqSm4pZD+aZByb8nvu3+khfi5EDs4HqghE43H8S81zru++KRz4tgPkTkq0bOt3In+6YYjjn63omASFsQttIZPH4wGdpNXNRaFNj/fD0A/ronbu4efQoBHxFDFDNXh1/r2kfJYZuUXtMgWBhWex/HHfXA7ObP313YWrveGKlwKqiuObFG7bk9H5Tg3ELf+tuMYo3kjxSbuRYJXkM3Jp5Ya3CNNzunDbOKPDzO8+N/aQ5yMsnMM57rHUaOyBtXHHqPAN26vlbNJ4SFAsR453dFdkG6s2U26rOAyNX7OO8ba8isa4xZJmypJxExoE8CmWIaRjtAj73x6tuTSz31XF3ykxgb/R0B6m4cpnKA2JKqEHT4AlIGpxX+JA09C1mhHIsDrqzyKuZiPvyYyRPusX+7udj/1lnkBU+5LYkg2J+XBO79G7y1dBWGbOu89g5Bi4D4AZhOiSwuxj6fypQF6dSl+Uq2apjaQXaVlp3QISQCfwIXrBPw+fd7oo3O75dsTR7dqRmco3Q0l04hQ+w8PAY5Pwvm1YW32pjBjPsjQNtitnsRsC+U/871mRE79LgSo5gmK3evMLWH3cBfTZh0q2h3i/Xn3V0lSJp1uwGe+hSY1PYRYxwRAAJM+N9rz0PIE4GADEGdeMmxhfs+8rJMD1cqzbFgwrQF4zhmrlMT+dL3iLhvWUxeMB7Yi8DABBX+htiXBMW+cztlHBX3OiAH4SZLnDmmB3Y5bKCoRYg5T3SfnKp/K7UT0jHxGQrX0tqJ8snsV7+am0vndjjZJvBjUUcjpQQKhdEEoDqlBRxK2kpvKP2gkKpoNCYQ9z6kglLl0IzdGOtKYDO1nqMglgTTpiapZ53Pta13TgwPXVZDaOGZbLsifn7G0gUT5DpI5T4eimxdzA/mZ0fRjyegkTygzEfkt3nDVgp+w4nE6uLWTeRRe3G2ebDyespTcpbiF6bNZxrHnQ1Oc4Cf5+Z58YzZ4JINqQjeWjbXKtaD8jtHIndIeUzTA/8gnNPvTKtjnTAAwDbW1n43tYSAiUV22ppGF1kZwfJ/OoakHR4X1x9GoSbB4UbCJmBocSg/BVf5VUdj3TqIh+sXaKSwxC+mlHBS0WtAF5MTLFne7vivkhI5z/XFyHXy9H1jXIB3xIixnoo/gamNdpSPMT+IKB2zImT1skcyYqHUM+I4A9enM17/R8gYJkXFXJR6b66litCzNyVCM2J/Ggas+iZkjC65WsLCM73GqXk46ffb/ySuTvaWvLzlIDrMvtKh0X0i2IEdg4rhnV0ItPYbeRJIQZAQkt8XSKRbl3kJODCVZPT63xcRLvVfwsc6Df1+ASuy6lOgwnoHFl1KArFYtbLqJNMOG/+4+KxNIJYAqW5WOxi92Q1WUO32s22Kx4eV4QpsweuiXEje8PwaiHgIp70VrFN2Yjwy+1AUpNc2MG+OodJWARPnFBQT2vhwWOvf//ff7fHLvTOulUy+Eq6Q6HKZun9RZVCK4NugqhojqodNz9EU1jVJjUqxD9IQRNfCos1kg76ZTBm/ukBTknU2scTWsZz10p9ai+YsotS2RnBmX40+3OjHVS+MW17qpTurCVU8YHPgG362bHMxSa4NHhcz+mCvzDmY8SG9eeQ8+GoaDna5qQ1rOrrInRxUSpNl2V8aps5AGzms5dKe85T9jpKBDS3s98lhENEgK6e7pUnaDhdszRBZM5m1emMjUx8WeXNkzeDBjaO0yFo4shuGo6qPl+dtU6soO77Bwi8GzJXpfxCXJaCcigTwlAcAS0/LWBGGdqn178rwQX/C7il8tNA2I8bY/e1kXFn/u9dz3pclCN+30ra07PIBqSicFxlRo/hf4LKJjzd77vcMTBAM9bUGTRMGzcXA8b3qp4exuc3AD46R8x0YlJ4TFqYlF/HPAvMTxYlQbWPO34JLVoAUT3UCHfyEE/kvfTdlNDiqX6v80smy2BUpCqEqMA+87F24GNqUKQv5PXy8QIEqFZkboSbny37SXk170qDLpNUm9yAeSjKeXuzxfI7O1fefR8B/w8KpE20cWEs+i7FP/XrE+TDrWKb8WyRuuQ+MjYulGcD3Q2fSnDTlVjwq8a/HarncX3DV7ZICBOJYj7b7S15HUfRJOCc8lOzhspTzMHGHELTcxYts14SfC8KQ8ngCGGqmsG+JGihEMAJdxzvhY1TaF/ziNutMIUTJWajgP7cBoILJwSlheJY4tPHUembVK/PE7/kwjh+OTcx2BAXtpGQ5emzZ51rcy/px61aoshBEWUJVYvGLYA4t0E98Q66zeqm/Do6hRF0xdPeXEyQKDT8A2mWkzqCOZucxMu1VLOvkUQyMhZ6XodRk4Abh1SBY4pxdXUK8SAnqVKserWjuXVESHvTaNc0Zt3IxEO5r+HnI8xpbZ8n3i1MR6DryyrH+FY9d8R7aftE6T3Hx+B6BVYXtcC/uBRKJm1x7jImKK6uweBrcfMslHEBsR0V+zqmq/8h1ND1fr5JJQ5w25NFSRxnIzORoigCJ/Rbsx2PqivZ+8JexVHLRBXAHl79NYswsp/eg5p7pYiKYEzni+eRFDr4l1Om7F3XSiiD6PP+jpjSnQu3x7DKMN+TGhN6mbdoICVSQRT8nrr+L3reRnP7rZMpZsu36M7yoiZeotLe1+ZmZvfAVY7L2hYH1kxYwRHRufIM6TxoFXV3DCvKHIyGAUJOoES1+Ln3vFcb4+SNkq2fIJIhcVdqiIBdD/6w/R5fdJoLWWvd10OOMM/cyGWiP4EHyd9hvVR0dYbU5Tae5MeLtEg7QJLX9RaHKep430t0q5+cYJSwvblDn+mhywPvdnzFVoFkpECwT30uJa5TphB0kgwuJM5DhykwOIpJuB7e4+p5Hd0PZMbSTqfz6YMJe0iJO8OzT0s8tbPonEx1zBSDXVfpVraCXkyFDdboLyyNYTE82WSImZttzjLd6PFEdYN9gHitBn2+/Q4VJACacGFqdOccmZSV0ShLCgb/1gBWIgw6y/oqHM0pVCiht3hiS7jAv2xYov/IHGc6hBspIOhdtdN0aBN2ltvZ+xBPQ/26sSk9TzMqX0ijXgLSAQkzIWjmhJ3czWfQWzmgGsOabSeIOIhvEg0r8YcNdocWP8VfajuHnZ3jR3Wj8wxy+S/m45GKDUOUP2AxyVLf+k8hyL2fLc7eyO+Hp7lgw9BjOa7JvnLSjEqUVJH1AyLLyT/QeGsb7PpF0KkCnA0yQC89nsWw7uCa29YgpmZz6pMQdyl1JV5C8/tBcYiQe+Lv9P8CfBuHLsJg44Rdgea+/h9uboXgRViKcOd40cLjFd+Fnu1lTBtnJDiSEfGM9DtZMLsUk4sJSGo66pAZh+HdP1kSBDqjNnKWwQoOVlRdt4KNMqEa2AIVsO/ehro3bNfSpQ4A6O+7lPyQKiwB/0epk/qW2b1Rmi/Lpg3FjR9i4FdeH0SYt4b4uc32u/sP2RqEM26vQH9bh3sJtF5mhSwgZu7eUA0Q/6zQ9ZZjAh98Q+SLaxtf6Dv5AvCbwaTwOP0YVZe/SXKq6IT0amns52lyo4lyEA/MsLcmjeRmz5jaedO9hy9DYJPTMTPKTC+Hnl2r8CoBJdSvSRKEfPx3wV9m1zB8wWk8m6rnP7ekh8mywXeNZXroqbTz2tb4ECLEIaZg3X33nNj6SsXz9JLUWVVIxJWg3NLSWY+61Cvu9m22DZuCQr3/5okDu48YZCAAr5sNVajPZudBZJLUvefEChJgHKqtz6s50cB4deZ7Z9cUu96r3ezV0PbUoSqY/8+iqVKaIeS3seUqKzkQv3jQdx9Iu9gZbzFiTVVxOuHePG+pq6LVEXgmERX5/8Rob+YoDGTREZi3mjvkmG2FLYAn19QfAEut7qojSQngktDuRcIJKHWzKfcbJKAapgDjNIgdQTYKN8vbJV/zVBsRubxAZv7xJLq38NVIKoJ32SgGWYKZpMJEGJAk100P//YtuQhFynqKIiVDPX8mrzpeszbyilIYnJb77RkwSGst3PhDKuecg1FVLDMhCHA/x66of9WtH1RPRFBmQJWacKytGwexqPyWvu7NhasmoxPq3Bvz7KVgB/Pd+VTp3/3PiVAkwFbRTHVvcdxKKdpWp2e12XXSiMa12xAW3Nbg7SAg89Ru2nTUdZiWGX174toAHdxSSi2uxaiRwKG258ucSmFD5ZB9S7tvT+bCVlPpLnTzExoNjyGlToM4oF+WXcwX+fX8HK3frK7foHXcYoCeuwJDdXiejkRU3oSYSr4vQM7qUtfvrJxxwkimfWMrB2muiJgK5YHARAHNw+xU6AfO1Tv/aRwYv0V/SkkQfEfEVxwiHQvgCYCBzxckXbRd/wB0oVHuaB4AdQOGQVlqmdRz0COiotKXK2aDpigMwkgtYH12bEFjSapfhPqJ5+pZ5u9jo/U8OuhSUeNeitslLyZKXgk+NbhWQaSy4kVZix6/+eRwHHXyahlrNQL6t/rtfTPD0XWLvTrdl+J6S5b49ZT1TFu777ZVLv5+OC5vQpbMeC12kyfG9qq7/Zp1zvE2wDTUEnAYTWm4fx1LQ4hIH6xe7fdedcnppeZotgdoJ84ndgJmL8vOtyLb2eOsYzWpnYrqoXBANq21H8o+N7IPRW6gOKv6Vvo/LpheeroJ6d4S6RQkyeolINU4ipn8bDgvsc7xHO0/BZSIQrtaJmuCMJGJuGi15LGYJrXqWBE6sMZx+nwjXhr8C0GIujIGH0ys9BVJhhGXXXti0i2LT71LLyrpfsJMgDZEaw2yJtXBziil0DCriIlkgsBEYd56UxBwuRhR0N88H2HMd3qFnjX9eNvjlUnbWwKEAdAgZYNhRCLIQug4hxmF+ZGlTobr3wtOztuT3XLWeb+5CFx+1aEHPo8LI4pngjgqGM0EOqBlaW6+bDgnEyiUUKAc/8RWEPXs/qVMSdKIxZHxX8weUbDmp/PhBntSMPYWYiloebg9H5y3wTTbkv9CQsl3FVXzYbfgs1/gqcBrXACmtS6S7rc08NCfpeLwrdlUj48Phlpff1kahcWNs56yW9IC7SIV6gXvXXQQmueDFY2Y0NmS+KTWZcmbiMEcfCwIdURHShJoXsRRdM0ec17yxi6ebE/5fB3ZEdcvqHl63m3z71KbnuYPQ0riAs4UXs4eoqKt0SNy1YufLRtzhBnfUa78cKFCG5q1E0/Y6sJ7CdlQJ3huEOpUd/nke7SBegvlddu2jr9CD0sAoHXbkaJhz2A4bpf99qa7YlEwrGv7ix5e4Qev4U29exckc1efzxLrWbuvkdQaa0TdE0ueXKUvvYptUWQ9QE9by7hRAE9Ilewzaz7Ev9YjbDVRVpX6MehEdigHnwmnL1izLfb4pY8MSS1m2CKpqDIxvNSRO1Ff4wrqlAwTELpj/1qQ66fGUi/r4kkYAKj81RJT5UiXX/46olnEsUkL4QJ1lWerI3qBDsxXVifVQlNIba3bBao7EZeuHYw7ziz26+lfR1XAoDJ0iP1nnp4fdTdaYlfNo8uMihkhYImS3wTkwwIc7tnMj++o7G6isq4bIo+pwKpoh2GSHmdIrbVdOL9GARULK2nrQUhuPBFw5WVeUQVJPPAUd30Cng2gXSeJTQPHu7umRewvhACTyWvXgS6jr9H1bVG5K8hOVg4Y6KcuV9Q1Pdw4tnHVd3l1S4U23qMDs0M1U7DufDrhiHfSgjFWc+sB65Tb4eL2yX78l4KdnJP1uxv90wvt9yAOUZQo0OQS8bRQJ7I0D7tdJYJW7wmoxPEA0ANSu1KJanzpVXfS7CRtcDgS2lg4qtF8om/WG5edGwtPSOrRkW5UTdvwjdYnQnLNPnLplU1ml/6vr5VKYznrNXHvvN2wjrpK3RIb6q6FRBWXxfhJHmpXtsb1YXbEGUo9l1Bf3uHmeuINsn9UlpyKEECG7otRg6uhreCdjNlPXGUfs8WqhxoV3ycLFQtcBhIjxXgS50kLRy241GYqSgMaQvVaGj3v4yMy/VYYouuIITWtWWfbEAzj6gSG2Ks65dJMVEn/WpQKpmc+yLg0CNu8D2DjTU39/nfDEKQ+uitV9yFU9IHlW9Ms554VdnKtB+D1bRSetTZDGbf8nkqYl47/fdFU6U6zo+nn/XGGiMlBHEewZnL4QOSCjdKdgg5Bhw52hdl2bCUbS6FDkAndBXCcw2YMe6Y5N2fhaEeB7o+8tAbZKjTs6S1Gh2WUICH4HSwrFIZNTMK4+RQGOL4XsqtSCWxNjenS08O7zwlAqd3Su7CO+f9WUK4+ict/rCoKz7pXj1K4BuVslELFCgczhooNLOeGgrw1FNM+HC24hv5lgty9L7KT14hS90MWIv72idB62qULjSPFG/746JNW9Kngp9jPSAWqTRGOryY5hLe2nO2/kl/bn0bIkIKujN9IgzL34gscsxCU9lJi3/w6/kvjGnaRGONBHChX92g6Im9bydewAoq2+hH/VragC+PJCFL3Xgj+OiAC6BFORW8GnzCOEpQ7o5xZgqDrWaTGaJ05MOLbMYuRUtvuhQuHMfdYCrE6Vl70s8tF65LpzJHrhGx8kRdiPqwOEACwFfKLrNEByU95kBPVdEm48ES3dk3d2E+iWbLNR6pU+T/PeU3znTJVDF643zkls4a3oMjz9ZtRqTYQJsxR5nQ8AQFkNSZNDwbHlGPGeHQWGa9P64InJt+717cBr/gvSFeA8TyUuxiRaxAPErUMaf/MbNC4ZA1N9DbWAZFBmPdQgEehuqt0quPJBmmq8aK6I2kTNmwhrJmNtX44pkfJYYTlkdc8M923i2lxGRaKMV8w1AjpPq+0wLywoCfnjl5jJPG/XJiZHE+k799FoTWVlfkhMNtqtrzvluBMmasTj3w+fOXB2d+hTM58w4h0bsTA/CkBtEsEHmZhyO5j3p502aaXd0L2BIAA4z4jZ6kbOWBYW+oKKh0Q2HzRqw9dJUEC6Dx3tt9Oq5+kw9mhAav8xiofWTESp+nVlMkRxpIOg3oK5N9gfW8sB72/EIm82Lflpn9e4huhaU4IXpP1N1ddzxqwR8nfqQsoyuX2qzcIaLK1DKa/AN46RXkFJB6OtfJ2F1AER1PdYjLvFUDZKTZnXEHHTvrwnpYGbXASfp0JrZAskxyD8AvaKqgLn7DvoEEUh/VB2+kBUUewY02g7YaNiz1XI+SMnNPLCE8bVocBZH21ajbCDEGPfCD4/q02ZqkJqI1KgBU9lpOH+9mhuolITzF/ZEuki7KNMHgPHuV7EQduAwBCLfVl7pMUKClcXuohRTMIQNhdg4kUIXmgNVJVu4GEcvybYWIyI6n+RyT6o6OTsrFRtXtHDZSum7yzZBd8326TYutvawpGh61TPqSi8UEfO68lzHLnJSc5oyaxnCaxoCe0WLuEmnQpVBCcjpGXTkFDqEabOyxeXpQ/DJU3l2q/HWV2PCRtZg1MyyzTQVJruCmDi6NJ6Dt/M8F6iGRGpH4YqGDfml5Eje3ymema88hoxoS0xMZyXeQ9lXXXT64fDiFYEJYh8lanBfkORufmSS0EXngJYH60qp5Y/WirDwaNYrWxdP1GxFqDt6mnTp6rsS+gLUVuXK92LXpLGCt8RJFZgcyihSBSek4DvaKVS9y3V9yF7O69Skq+HLDoY3TKribEYy7EedKItWoEIK+i/4xneaAFDDZRBR9k7IWzMZpCFFWh+d6D3yoB9hIo2WuEO3+h21Ah7n3Ux3s8UjYvTjk9mnaIWtM8tfE74idJMZCamvURuVDE0CWzU/SDHugu9qVeI+EBfyJpFEIEYOYiZ8Y9xISaL/cp5bNCPckO81fAkpzR3pUyPrtlpXlKdIvxiwEVwBHPBCTMwF28eAVrG1MLivFCPISRm9ex+Z8AjbJCPs0bQeFpqdL4PJ3RL+kTTy1ZOywqCoTXsMmgi3n8VeYMSKSVPh3k8TpMpH+dmIgZSSiRUpPjow7wjeoRhpnkv4cNgCsJAXUOr7cv6b+mvWy6L3skryx38MX6kc3QH05Vz1LZ3jHfADIAACV102v4zOsM4I5uwaey/w640L4XInbV625GIPla0dNkoM3wTAmzuYdKrtDY1KOf75n2p0P3RNYQk7iCkHz46C//CrOBn6nFwgkAE4ijcKMQIcwD+3bcFqFtQYlvK7HrMuD0KZDoTJ9BH47xQgbGwKe1euGCZbO+Xhphfg1p+IrLOL4WE2qtBAm04cWe3ncBjltYnNmPTERZDlAuW+8jZMGOEDd92QgNcLt/nUDrBTwQKFolW9QvCCnyaxj9fWIF0NG/gR5xCgvY7qBKbdnGL2Y0ODFKaQ8TGDnPuGkK5pdjIzJNTG5nZzhc3tI4xDc9p1hc5dcbKquNCajGC9to6kQ03LjLHFSaXCrBzIVQ/eXpw7BtkfD9yxIEBSnuAPL5UF2JGV+AQe0uxKjyVlZ8TJ0JYFscK19hIrcqEGSZMV/c3AmEKfrfxfN759VcD5MRATBEB2DR1bzS+u6dtafMtGUNOosco8MJMbBHEkNvxIPQvjjXJ18OSF4dsmCvHDZ2n6dZ3MmeMrxRPWxoF4NQ3nA7vHK3m54yRNILH+9TFgpMNn7YS6yGMPZeRQ+gNMlwsMefSMIOsRrIK33jPW9lMHVFKKPdCjqG28HB55S5La86pNKsJ4gzvviLFjT+3DRXHRh9HoeZjHqxlsGMnIZ0yBEQ1Gg37a9E3ODqW+C5LXhhjMQDCmKcfuH1fHzgAUeeYyeBNHdShgvBIAvp3aK/QtP5Bt2oWJet0Xtg0fuANkjH4JZAVd36xBnIe6AxUFIJ9lHQBqDKVGF8E8wKWZaZtEQXrrY4S2Y3ss6e9csOwGf/h6rwfWvc+GwYwEbBYixS6Q54PtpUsmKRkKcZWZx4HLfgyn757nO/UB0fwKJO0/Z7VyWn++H5yA9PWvBdCrnVuOHkRHHVz3oghSFpvSIhANfRKg+r+xRHuO7V45Kzc64bao1IEuiuuYhV2EUG5RA1al3yERoyCc8klhmhfq+MhP3RZGLyxlo+j1DpwUtQykdSeMK2GYM70EIA4lsNoXv7uDqMaZEgIqGMrUd5wSXlMk1DQX9O7qVbJMzsEA4+KNepeYjZTnk+ghl60Lp6H/zaRVgzRrCb0rfbjXq7GWqouRW7iiWk2zku6UJV4oG/G+zTWllYSDNuKZJfFIuh3fx1D63tVCD8sTjCt5I6mxUrrtuNhweaGfKxWieuNWlRIFZr5AB/BMzowiExPRElak4jcu/eC9D5nXOFwyAmJHLrw9NSi3Fz4EHOIQ2uBc7CObRA+Cwi4gpDl5yL9orJvPZD27xONLf44/LwbQBE0R9PB3l1BkA73qvE8OOjli7P3+EFBXSb/DlGVO58G/bdTnWNJPQA1y+eauUSACkHHOppYIL20AYBobR59kBwVvIgcBoeRIBEjrvl9yi2gCG0WZDjGRVUbnKttksSkKvqEBrUNQruHKqWr2bIYjMbvXKP4mniGOUU0CfroV/TDZTc/8kBWQqlRWtyXYZN57Q5Jwik4shNxLAhcruN97IWkAcpcrAmGx7OLXX2Sa5UkcPtpKhp85d5yCuwkBwhiYYnqpdgEgpp3lbC/an0vpyUyfbgPEjlQ7mAgxHB0gwioR/m92vwmiO8FwQOU9CLzE13OAJEZUh56KMnkyLJz/NVy4DWxtb5F/pXY7f/b64zGFNRJ1yqgJaeJZLhAymf7cJvU0kJDZS3vl4oj/sd17pNqtoSiFJf5lTVzjJtv9MQ6s6IZwonGeeL4ZA5fWLYSjUV4WVspTl8Jvx0rl9MVZQefFi/fsLWU5fQ8tY1LGHhsRcf+eVacwFEo0j6gvz7+L8j94jBDOE4IREE6azNazll71FDA+omjJi6RpJ4nqAxmdp+5fahfGu9UasmSJW4xgPemR8x/ZY/0u/HzWmlzTKWoiZTy8S8UBrFSNOF3rfMuTClrW6Q9c3L8ypK/fXRAsps8c/0OuJ/sPt+AhmG/RPBF57yYxcG1YwAkRRqEvAecma3z8KYvYEf906v0x8OAImSYyipaKjYvJOfgidr8sdrkWy+T94ofARp79KSpJ8dHwnndMZSlrr0jbZ5qarorrkVZhWlyMjNHakXXSs2PXEmFsR/oqVUGGNWUuxZYcvDRNI+j5kRZWZGkojZsuW+3vbQIpBMUAM9hy97aa1EmZe7gyUxmseY1I4woUKifZUHaCv2BlsmcE9IM7Ckys249FNAS9qhGLSWWnZw0ZYAGWYBolIjJR2XxRHfH6PLADbBpiTDLekvCv2MnsrCFEeUW9Id+mMcAwcEmYhdWh4B+HFKWZXmCPiSEtl3uh/1Qq/L3CGPTNznioJbeEFYzGhzVP2JbamsxR34dti4VsYEEFYo7cxmtquAltdKsA3OdmshmWvTyImQwPTLgBvPAwCNEwduB3x78T5LZ+SKtjMCAHXPaUUmHhcH2QgZNlZs4UqRZ+69F7fmSD/hcI3ypeVSmdaty1cYojL9i31uo9qe1AtXY1dDWNuM2DIydl6V4TiFnMJaxT0oOUDB94OOOAC3aezIWEbhRvOzCWFrtBQwT2dROYowF+wQn1rw+acFt87AQxrKCLzWagkg5Yp/+Ehvaf3ZGpAkd/PFMH9LJPqNKKwK6HGcS3pi/r6rwoPicTfOTc3ppIwJKQ837G+KJzDl+YAAEgymXc9AeCzxCvvYpuDcnlCW5NCqLRu4NluH8zhjje1Vo6UWR76y1x4Yl+dI0QiKQwD0pPI/NMIiIbi4WXknmVfqWDLqjajUeGigNnLJImVw43vC6jUi6SZP6g3zgmbeHcIpZtmD5UuR1J6HmApGk1Ucx0EuLUWExWYhvAUeihBSnzFLR4bWk3n4SShh8IRTL+GVv1n+Bfq2TvneHLrdCP+e+Yc0qTsdsgqxoCXHzoC8DQSIq++DV3BuADYUA15zPi4sCPiOx1BpqDEgAGcV3vAO8Y38xGdcT/ZqTvAsFDAvQDI99d9vxRq5TgjChPjdEhgH37+4R/nz2AtLyKXvkTMxLVaZtzXpURgaduQKKKLyNorshmIasPtnzRvNEADQZNUVdTwoqCCwZB7JIFUjio4o3wzH5fqUIW9b+KoPF2vF0D8OpSIGatPma9XE7MR1rmepIfPjD/9/BzJZKfhpjvtyWQ2RSgbU1wA6zMbF50FZrxmAPz+765WU+hgCuvQPMa/a/eLzLmHKreaulrSAaZxtT9j4E3LKlycedPQuWDx6Iq2w+o9+GHSK5Mp4ZPUCRjIoV2CE28YaQZMisEWyA6QB2/17u5HioJMXGPjWkl+J/xKl/PkX25A+eRKrwFB0ryIgUCRwdjyZ8VvWTrfIvRjQS8YMiXuh1QRhy25QeMFZ6ak6ocx0qhGQAWyYpA3eu9u/eBV/1mXTAjOAuMEB8d4id9+1KsIrIJAUr+tcsBQJG0T88TBIAfGl2qSkFZahrjlodvPMkuUtF+4DdwBhfYsMlcRHUllAwAuHNdzlogv5II/HfhS4D+jQsv5nWeokgQR38Or3DRKrCer4YUq/jM0ZiwjNPmtlPSgaEp6iDors+fPvFq3hjQHqcl6va794gfhw74u3lN5uXL/wH3B6Vl2C9lLZYsYpMjBcOtWan+R5kJJgMEIclmBwbJym6z/kGdIxT32DMdYy9nNo4BEtR7j1zN5FxgqmDsvLm9o7TIUEmPVuYL2DMHHVE880410gXzDx508tBTfFIuCa57S9/1p1GVo6YOeWOo03M7LehspdBuCr/vEak2TbA/IMwH3ZbTTonyFaBqFfBUza1wCTeWbLXVi56TpbmWBMRHx+koIUdzavjAL7K+hBfoLY0n8JNZzpjhQWDa6rp89g5NqDoDW8JfJMXM5Gja8GhdcpSSUXRo25k+3OqnI1gHsC53HtVTXzhR25MbAIGjJPc7XBHmClpuQOwwydTNGFZIT+9hfokCevJk2VIsCgjOoS5vrvk14EMWEOfYBXncWLkHIfSgDw4WiWrni7HVQbIfRkqwRahLAmFQfsSfrsGFmJAjkPz6HFJGsscrBqXMyhkW6lsrBikLKvVnCymrcJ/WW+iANWVMiTm1SSGK2hhVghVGABFUYtJvo+9N4ptjX7Rkc0tJVIp4ql7jF6TcwqLIOesFOveavS6B3qjeFhtgcdV/TXArwchkxM71FH85x3kcdMtD1CZyKNqUnnqI3RTdyzqfb8CikihT7AOwyDx1TVfEb+l9yHMtODMw8+XmfkweOCYHv5T4syQVMrakuuowEpSLzHRCpInLwP2lKMzzdIs++ZJyqe6k3crnHEVNIcotiW9EKYxD/8cRl+d1lGK4nKTDGAQXIZY99ji0dl9Poy0HqFTcNSxPm5yj1dG6QhhEl6nES8EDanzybtlTOVHwOyZ7LT+xzeNdB9Y00lk9oS1resO/d77G/0vTI1hEwOsqJW42rBIaYw04NlhYZiL4GwMyZppnvutX/XwJYGY96uSFVbmwtO5n1ir7DX2N2wG1lbs+v1h1ueRz8jzolTjy81kRIRRH0sg5UlJP/qFdXiYvES/adp+aOsdz6zLQjOTLoJ6CRJN4LANNhtHGxpxOKHw7rBAodITD+6iY3XgLmx00DQKn+ikTjvK4+cfwhLQBHJmsGVBtbxXeThlCKKYYql8PKWhwaa5PIYmyJEVVKgvRUPYJvQA/uPjlvu1qd7oXMtamH3vN8pC6e6YdFojgUiOcj+bNHWUAS1GU/I6OT4aHJvZqrTFgsu8B/zh2D0UgB1HwcFgxcDihIjIjKXcBU7bUGZi6ouHTFIzHvD4sS6KtQReydzvVeI430H4eIZeDN1jsCyizCnomgFTMI3Jr+L5fboxy0gPTik+NUai97l10/qLfYiQMMRtjo9E1i0wnf42X4jZdQbGkUKy8OxmKhVe3TbSCBm8zoXoS41Uu8jPrLXC9b+6uT7ZstN4FzOtys8t5miNiGPgLTiTuzjrKE1ESOMhiG9t99V3l0P6xLenIXaEUAFev3+Nfi0q6xFfPm7d0KIWTbs46AmtPGRmqEsQtF4UzVaZUA5MYOLYtlo4dCWZQLcBSPY3rdsDYL4WHZ25qAHPUVG0XZiO/qhBXhMy+9M0NuBjcT7CEZMA85AP+LT74s9YhXGdazSN4roNrtS9SjKsZkZs2hW3skfsDQlBNaYBd8oYWtXcAmOlvDzflmQzLXb6dM/OflI00TaEsFYoRlS0CYa9KNG8y8vNlAlALC6DC0B9dVXgTJoho6D9ofde9erpQ/QmI3VP00PoTmQKXaobDyhcY9Vqo0GH+RbBZZhosl6ym4xydy6AtRzYicc+caXmEqE3jw8LW8IvaS5GgNev1+Jt9bC2YYC/xmFxuRCxrpiNSybZ6I8fQ3o2YodLKzn6wiso2rHfPEFlVJ/MjEwK0k8rrR99UowqSsgaqcQIhLjfYNrj21SpHv309fBKjMXeaIynlH9AXZetTJlnz6v35THjk9eMF/miVE/Kb8x+Wbz9roIUgKzdmhy6GrTI/gyUpDhoLa3f1TO9fROV4mXbvN567Ouavt67q1EBE31g8ivWjWkI9nnPwx4RutV+cOjWoJkU7wSCaEp5GRg3D+D0Emy11LZyv/IvBZ1H4+1cZ0v25xsP/Xa6JBp4IL7ry7s9okWnGrpTklg4PunNsudTh68CzYLnyGUO6kOVsejyWyBt9MQcencdx1vedGeKvcs4YaongccbqcNaXIJI+7VjYieLLIV2xmSHErfcvx6JhbIWAn59YwFvoZ6w98A1LALSn3hzxHnGb5h3gdhpL5W7R6LCBD+NW29MBVvTRUDoR2qztx0ZNwGoU4qb/ZEBzzlqJHchf/ekiC5PhM+NkteSuhKQR0Klpj+g7ivxkgg5bp8b5E2jzBtIRM1otBLYJTFD4C2wt3YIke0zcmGfksBoejm2OMH1jqu8lPWEWGvTHXKs++/89ejHSEvqRuv3TiM91VPHWHOy0vsewsCbe9gfm6WGjwIGcsT2RkViGedLMkiIM6m7BY/6jgNItCNo6V7yNZg8fi/TXbrp/PbCPC3fpuKI8Jx5EzMVHmc3WfDcdpzu1d5CQ6KlGfrKUdN4SyD+XPBSwn83/B8x0eEFBeep4Bm8Y+HaIqRBknq/VTeCsy3j4mdxlJLD0cVsD5/t3pv+Ic492ShluxZE9u6rp63Xtys8ioCY6mQ1p0z6uvO5/f2wCT/asKs6S5ZmBLL88w6e8lDXYaqpUpBsuzRNXn5BnqZzj46LMtIiceZSqor3pBNAZP9DO/HyQs/mw9Tes+3NAGXPgJVQVKxQ/niwgvn6sRGQ4xu62It/hHV/BAyN2n8XSM2wCJ3LWc4/hJg1CkIBBqoZyTnmDEWnSfxBKMJRY+UIFjbDYTQfq8sXe8tGgmoLkaOVwAewaE+sRdfD2M43Hi4ssk8aX0bcTTKmmyOiCiGKEr8lfuAeNPHONw5KR64IRMIlAKq1n0iE6dVHOWux3v47BOFVatEyJRC5kIU0qCHR+C6ZPieE1JJHYvAmFO5hkfDmO3V/Go8R5JYptj20vxKqELlknzEGjVrcjVh1FXw3zBLFeh90ktPE+cVr3DtTwoniNkS7S9TEWVeyIwgykqmtugPAW5RGMOuxGnEcZm83Vj+zCghBDBs2d71kk70Ayq6UhaRG5I1jcXUTvhyMN7ZQf+55ZWo6BR2dbfQCrdFUTQY13wjCHtKWFbr6KMtYzO80LUuQRTmDvv+OsKUCvuN/Ic1Wu1rfhadnMtLjhawalzJNd+KvspL5LP+5fcpD597GdwZ9eq3YoFuUsWk/ZMqwGyIoX/idBM4vceaUJH9OJJ+nuWCsujX3rAPCE49X7gmShCrdE1ZHdsF215P6GVThtk3i3VujW0UvrREIgR8dUKSwHt1X+s12/4+vKo4pAj9eBB44ZFrTab5HmhH/6Yk8ydT6N1oLaP/LkkJwpVff+AQbQELuKLJhmT3HdkFBoNg68Wav8D312Xz5aWx68G1TlEnzTQ2pZAUXXqqDzdNwkqqv4N2XjsfrAi/CB01fKP0asCyEZ+KHVOjoW3z+qwf3KB+ypxwXb2+MEyLtw4tObSBI1dd8VnLxiyw+WNj2p7l7dcEi5ObKfQkk8iaJP7+peuMOQRThMGxJzuSQOwwkrmnRQcQjtZIjfewe+2TVe26IrMDUariUZ3LbGUxUZjLqg1F/2hv6F1GAEMWLfuYT9eOkTW+dh7yQfhlJ4kVAo0mYmMyyPNvFZsOoE/GBn8D4ejfv9Y5PPLYlkYStAlLf1sKUiYn+zBfxfdur5K5O1rYFdK32QjpJXt45thW74oJx7x98IefHI3lUuP9fAJFau+Pu7/Xe0XtnZhGqg4D6oMSE97NLHsXsqKOCNgoGTA2LVIOuf3OAaUg2o1kYERQlTolkuTziqc3oRoCrzLLyJ53jEfKRDePwhcQOFVIAPNFDJVn1fXeaNldqqOJbfxlEtmhUNhaXkb/1JFKRPrh1PBFw9dSu2adO8fpBOMg/rrYq+1iSGQuJjYRj3f2f/XY2snPW5p7KhU5LAsmIEM63b22UIHGoNPEhWa715XXo7VJ2pPEfw/VRuTBHOoooQUz3+h8vvCSylk/3q2nDhzoRah1LjFLkC40n4yiUx/E8+uGmOvqEJQ/P6sKM1h36dW5PTrVuPMROth2B+mXzO6NR+LW8s1HzH/+55Z2nAtMoLJyjmmexOcahABjFNR3y3rEXIzueTMlys2F5vloWRkp6GNX8z6KhYz4Ls3HGRR7CyfS/m8Z8PpSLwmvDDJKibhHsvOD9hcC3LNfbN/cugGwhCetoVhocS1EAbeZhQjuvswoitGG5IMwA+BVVDHdbU72xefB8rgM49JtYj9Twx30yh4mUMmiWDExAJ63LCeWfjK55miXHyKEVPvtpUT6hosgo7JZlGXPGRJebmsX5M/ehS2fXoEz5wWVy5a0QZVYzvFGM/PrexmPFTtPRrgawYrSt7ornHL1LRm8qwtXORJ1WTF+zh3/eYAXUaQD2U0LnqmWLT8pzdlgfBe3tEhHnwdtB+8xG/s0AfUe4aV7HSHtyOFYGn6QqF4AJI4KG/yLkdbXu/Zt6NIzMEckCTbuR3hCOfth09eMghp40ng6dVocDxZyNmYyaCBy3PLmBi2RvHIHSf71OqLhqSOK065nJZuvOdsM6Q0b9GgiK3I4oqZNBvA3DdL4sAwMHeDAGI8Xan/UDj7DRqeMACt1pKsplfWEg5KI8z5fVeB8Dm/bRzDsLDA9LiAM+1OHG+UG2ZIkesBW7/kwo6dpplLGbLXD06YEbWdpRQ9gcYpKR/jaDH2M/GyfeXdjjZ49xN+M+VICr1833AihG5U14I3/hm0xCYPsVWUjWN6sBtKyJzu7ryAYboLBbuZYt/tcYDc4eof/vXvXy2g8Gp9F/XQ6X7EJP2kbjTPyB2D2ufgPM7ETlE+b5LOCuiDNJRT3lPD8Lbw4cw5JGkC4kU9jTmeV9aHQCjjqptQAJukWIq6S3lXVjapHbrbJdx16rfJ/swxtnE0FdLDcwIdxDM7vgCt+qdJhH3x2eEGyMO8X9Y1yGBqOEZpyyLF2Rp/8gIMaxBPU7WrAeNQc78sxY/LDBYfBjh1OjLQeRH/CLk9Qh0S52pHrK0Mqd1ZWbSth2G3GMQSLWclXcJcf5bIHQM3+ebUuw2MnGtWcBEPSR4h84lF8WNuZiPMtTh4sZG+ln1XMegvMpCI9PRJ1HIbDFJzpOi0LXNXFCZTa/jrJ42yEgsVByWDOUQtbU3Mrp9ftD9nkKOrH5sE6KUKDJu1ONvvriIaiZFwX9ngvAAwKn++sZUCXVQRvihjRfKCMTtjkz/mMCsjhSmZRX7zebV/DfM1351Dj9IQ0SKG4OXNgk6PhHsvKLnndN2LZxOzHC+EPRpPCJm/u4GmK/xgE/YQdv38LcciLItaPeB1y7wP6+N5X2rcPfWmKIZRxXtC5g91Dc7b0aYxScaY+Zh+9iHvj/6deOAmTps5IljCfbi1NIju9r7jlS7gddPZhqtvJaTuo6VijvKQauzuOnp0orO8pfTH6m+sFT1IScPPvoZDsWW0HG/6K/cDZAo9zbZ2zhUnfjztWjtbAjyYbpW+zZRNqR5dCM5Ig7ZOYIr87xNHVCb+3S1w5uVR/l3M3BMncz6k4L0COedDF8jp3qWW7PMeKjzUNZ5AtpEwwoZIjWUaW33vKRmd7P8/pzjgsBOBIhx8UQpbp89HSEW97ka1E9Ohq0Tx8MMtz7nwt3qqcqQrm06xUSkGTE8MiHZxsdbq4uhoSeEKZqOlAzWVKE+wuSNlISUM7kEDMqlkO/+fVWwiGOFgIF3ig/iVd6JQ1ZU7AT0p/DqJIUQmTQPIbI8KYRV2yvDa7u6mBlltAh14whNY/z0C/dIdTrf3ITKjYE8la3XESxdUddpRUtZRetTOthXfuwXxOPGmUkCxG376ZJQpbLGnuZpQ1gJHjHDagLk6a67DbASqBt2GAxfvdawDFe/3bOj70i1je9+J5GnpSYyxvKjpQOO2J0FNYJ64yGweEc+zU//VMJv/nRWNw+zNTtSPfyWPfTkx4isbo4XsZ8pegz8i5lQgPW+pA8+ixf7xCCU/dDXDobl8eo/YHzUg2MNJSaPkeDQWwfelih1FwrelNg91ZNQ6T5VoieJokcX2lv/rnl3JQu3wnNk2M8NJv2vGcIxHYQ1Shl0H2W456RPMWD+Q9g/41nnJab54YBfxI31loY3RlxKcfHx53yDsNxwbs6sXEU3cwnE78bAlQY48HGV7Nhp7DTmd4ONgzQawNoRg65mXwQF5P0TEVcAm3gQWeiFvifDFvJ1Rb3+ejS43H0fYQNJoGB5T0nxM1yWaW9Y628izpH5o2G9RjpDcXSz7VB8/gFDSabv9kmFRg0NWEJOV2REDqToJtZ0QDbMwjflojDnQz8dFzy9hzF45sqmsOpvM7mroH3qTnKKQIYQlw7Wq4sLeyUdbNpfBWiG/YsMATuM9IdPoZHWpgYlLmWqwRTS3QUjOQero+ipVp9szrkNDMFYhV8T8F4CNJy7202fmia0KJKZpsFaaWWQ/v8qB7SSz5iPalPiBAnsfBH39iXhEfMqym/20Cv+hMnzuhNAELol2CeQ0qFc4zBTY+Q1FnAOumkfmUVikKIaC4+2QOyWz9DFmbcKXfh35eFvuDC8t+N2jAxseX/ckfJ6LhEABlBRUHXX7z72xW7BKEQrB7RDef1bKB5V/CydEYWa4qgRkQzMHtXA8TehcIaLOcAT+hyV5rRsG9TepyDyVoZYROfBB2+NCvRG5l7GpglaGdyoU2v0o7KmNi3Mkvy9146y1QJTmtPN4X+7AIETvaFgx5qdFE+m68Vv3CwWEEwkgXvOsyKDHcV40uRZh+qGCCK237yy/jYGimrngf06qzSwgSEWlfMc/i/oz7+Lx3qrsoaDGz1+LH3gk1u7HrDdb8+jS9bPIuifQ5ETaE7RgTCwX+xVmOSleBx7pQBOdZlH7jKQTxPRn7q91PoZAgShjwEYL/TshM2gYa4Bur2MpvbchJgfx4b8VSzEMUeVQihq97juH/tEpIlOhQd/23mIODDrwVSnb8W4yWvPDLcsSqrwgL+DwrMiyJI3KCW3cfW9pUfpPNt6J0X/V+gR+lXZETeqZ0roBQCWUhgmkKSPWbB5ljIxMTw8aArS6ywOUgHa2SQYyn8uu6LqUpaamxNv30CzW73n0FJTI9nmB1v659g4UM1i7xO3VEoZKD50xY8ZNUn9pGCz0WwIlmKaDxXlg1bsMYS1RWiXdXQwTN9RhLF4AP02sNfAeVieazZwj29Y4DOawFAirXVtJTsnUZCRRbMmZrVFZTw6QxDeOHiQ0Fb13b7rf9fCViUjhmjdJeu0Eh1/lJm/KmfXiGckIzh4bOe1o96qhLDio2P192YHBXCfJHqL3O+inya2PZ6we+psN6NjocPRBkIVRyaX+V7Wgb8w8rySn0aLkEswJMfkF5RyViKvzuauXlzW6Lh3SoJ1hidQDS8fAojG4VX527eMTWBnz3dMlyAfv3UG6XZXzL8yu/n8FdynHwHeLR8DRiEdEFc9Eov1Q1nxjRjHmn/w7jFBa5fxyroG8TzX7HlT8t5Pz3XhBnr9z9J5bRf+VecmWpT3NK1k43EZ0pxNjy98FXfx6+7hTzul4dSgJCro2jDIGxt6TTmTLqqn1o7cFIH9FW9ipSCjvfx/vFFNyXbtHl7WvjxQK3OBFuwhLt0JdgNoj0MUTWkgEqBKxPECKrTFKNOYBO5UG8fi3ul8nZtZsyzLN2l6G3mS9ikMaGsnayomVzwreoJL7ZKImdbvwuy3zB2OUa3caSVIIlSQHldJ+qSGd/MSgyw+pptpCniCq/g392So6JFpSf8YsOWoneli+9Fc89g4vQKUZFlJb7nQIsawVL+uOYzsYWj5xxbM95vlzL1RcAXaYTm8A9euqI3HuJsR4hrUr2IFu9kU9ibRxKy6Rn0DwuwJj1TS9p+UQQlNqITfpBNwYB6ooclGpP5fLN1ZSBdBDZVoQU4LlkOSwIeKiDWOPxfxJj2pHZqpyTLFATxG8sNmd2hXYuEGZLIx46laUPHAslaP5mZAe3SJJGiox7cgO3pp6cuD+CMc8gVEaAS0Vui0KzrPu/pdPZT64Ihwwq5K/+9l6A7jp9BoHR3hmkS5Fedd3UrZ3JFop4SeIjRdtOuGEleYCkMmkUqy+JZBXwdn+n1TLX7PLQL6K3slWbdmU31k1SeqE2QSI+XUsrPsXOlvYhxwYKXECMro0s1vM14B/TLE4bCwOsH4w5Hp4cDMMG/94D4HspT8GqX+TWxNZArdLoic6Jqgp0olT8+0GWpXIzYiDN/hBFj/FcmWLVf3oUiSG11L352yrW5AHruVjGl7Vb3QAUTszxs/dAoU/AI+p/n26y5W3SOv8a8cPsHNTnEAM/XAasuIlTk+838Zt1QYwDfkOZ/IpwTPcTN/pi9rT9oJTHRgat57/iuGX14n6VyHmyvQ4LH6YCKBY08Uc67PqLcl1A6OWHYAwVni5U7dcP7MOXMlNxsATHzipI3JlgBG1IppUhhZQqbj+ettLrVexXrtJ5rleqPXp/YgJwFwxzZIYv8GRiEgW8qUcW/5e6xT/5W6UflS32tJj2i/LmoYLjkUA+ggNZAG3Sr3RyWK1Cwigzt/Np8wzEp31I962o6ND8IuBml26SQnqRFiH2+/GP+UtgP2kgzCYNMkFhQC/CbVLqi/ugo9UIN1v5grm6VKTvE2LNPr9zCe5GCi8jNCZ++kj5KglWMGy8s9zZmx1h2fQlL7VjEd0Xp+yIQ2OF6Ei2JoljhpRv8+w8fuWRZ5l7z+Pxk0BVMn3iy5/MhxSSpH+zu1waQuow0Y/tI+giVgqo9zNzDPWq6Q5r1OUAsIfqYgQwI/2M0uFq3bYzWzy4tn12scyssaZ3amArtKr7qm4THsdoMALyHWdO/M+lcYgMRcQXXFji7AEjH14rwrkxJvPqU2MelHNbaU0AUpOL2YWw58HFZwg3QUpkQdpwWX/r+CmEBL4chYQGCuha2o9W5nJ/cV1rDEdCd4lcZZGOMjSvO9TgwMsYVt/fwfmlhhiWrbm81GOfDf22CDOGx2odSZbcEaCvQvyB2GFHtfXuZaY/WEA1KPhYigdDWzLzfqScorTsz3ZSuYBurIm3Zn/yDVpDdC6R1kn4Z6N7SK8lkDa6809Fk5A1eZkWiqk/9yL58KRJcgRPGIsxkR5YkZ5vPAvcRQVc8cE04VK9mQR8QkG7zhPPFSYFUztGVi9FsCQ2CQKC6E06Rdd8O45HtmCyiXhI0LTLXWbchcR4sGyC42rPL51Z67Br5dilMm5kk7ddlIfiRMUQC4wOpX019Y1QzVk5cTOmsYCyVojnoP6WBjJpV+NK7zoeosubbDBCbMP7sw0PsryZu4abB4iOyRwsYAxrS7Xnvl4bGXGl8DO9xHR0eKvS5CkIuMVRF6/p464XDaG2Faor3iptKbxRdEEiB0yc36HQTzTBs0mcpbWgac+178Hqoa80qQNOh2nRToTXaXji6fjetKCer7ZxWXND8JvYNEKtfXkKDrFv3nll4SlB7znnF67cmFCpr0HYM17EDklYSYlra4WeIXzK0YVz/Gb2sWdEcKv2Intylmvz/u62jBqGbWbkMQqeA9o/EuVrjFJ8T04H89rPPw3izsRDcbaH6htGAB/9/lP5RT/5eAm260mgu4yiZgHSuxflJ9RJXCbxXc4I+LWSyc+LNUk5E/NYWjkH8xsgEfbQawY7Fn/h/lMLfjFavx50+YAYHvSVwO6Yhm+KLcKxqDEYbiSrFxG0g+jTXe7OdHg/5ZGYtNIISKkf7OQT42+cLUGurowHsqINnyRcQ54pLcJSK6VRY6i5VyH/xKh+D6URJCzGZfIsZ3SRta730NLy93jXUFV+or/Sb5mo6SfIbPBN13W3KRt6y9Q7D+Xcp3YwStVf3ifNkRGP4h0SJAM8fdIsBrd8hB4PQuW+CNwyc2N2t7RLmCNMEU3y5VHRoGeSjIP9v6Csw3Ym2dCi06mAjDZpsHlIbV34o6SOjQjWWLLDyuXDJ1TIluptvxbFjtLarkfu0M1NVlB+bSrSPMcM5YiJ0v4X7R2AZPHXEV32XJiQWY3DAYqbfG7GRm3wBiwVFYWoPuFCkznaJx/XM/YU32gNtLpm1i1Sk4mALr0DvYi1AczwqJcq7DoHMzUEfE8CbwPR1oOnW9Tn68WP7yq4WLDDWcnR/tKOS5qRq4F6CzVgYDrL+i126N6EZ1B1YQiId5jsmPEQ9yCKiFbjknX5nVwd1Y0FlPPxBTgLBiivUof0EETjTtphvsqroxCZA+yKW6AZiwvwCK2PD0VsUHYy6U+iPJnH0UjLMcefz7I/Px5e+vfjpb+41JbrqVq3Ng+5WIlrWoSgb70hQCSzekeZRmoA67YMJRQs791ekMsfPqn/fe4GUn3Lk8m3k1MYnBFjti6WdzIubr1w7rbXvyLXoWuwsXL+ACCt7bXM+G/lnuOMuey1+/4w8XV6q6LA88TA6g8LgOFrprMvHXwB82iGoDEMm68PRPmzAb9Sg8748NIUyIMKM+8jRJ++f3Oi7fMgfJP8BHzBJ1OC7Fzz4pxcOPlEA3ciLK9Fp7D2F1QHU3wt9LzcrmGFtL595kKx6LgtSY0bNFVgfo8lFJ6E4Gd2iwEW+rKbAqXnVAi8HiT0mlQHfTWwPJmL3bxz/Oxs9qkeSclaWc06JidV+vnA3smodePQ/yfelTQbIb4Rb6Yyf3e4etw+u6tR78skI+UlN8gD5tbS1rDx5//dur59g4aQ6prE9JDifwpiLhwivjlm2skuiZCkV/QB8FzVAe9MPIqrVBLGGqPyOuWvpHKxNhBUuA74JGtMQFrJLU2TgbaDos1Jp2NgyrMm1Gd8GRbJPmVEakC11zUTQwSWeSTHwxnjc6JoVI3/n0CNmXlIeRM3jRbOED+ivUnSekfx693CLr5fdRjcsV84Pq8FfaBtiKEG7KTchWwzi0PccwmTvhq0hbYucCHWOWtjMNMv1LNDYe6iRsBp0L5IdqZ8WMxFQvpG8RujTIvEZ9U5k8R04R0Pk3A5WTINaIWL+XWrBSpAYUK+VywMHfXt9Zgb8ACdEdsPBOEwFFmpiocn+Ytyvi95q2DqQ5ore7qOn4QcHItxSuUO2iBcEyu12du2rEQa+Aux9MvHmlU2HFclZY3UsvMBCvKj2vTC+90J5yYvMfkeq0cj6iB8jw92BLTGpp9IkRs87Vu/pGU3cCqOVL6mb8q1KctgqdxOjpyv+wTbhS+wUYezIcb92VeLRcH8wzJdNTO15DdPbZuFNLXB74W2FpY9hrsJA2WvGadYBWzrWMHA0STaQ4BAh+zhxXw8MDd6ZcJT7o+ajSsbbD1GE1Zko1RZp1iEGDBFsN0Edy7mYZH3ljLz2KK0KrNpKTXVa8E5Lp44V6awSsAZvcgtyoMknIJBz/CW43Z12PNhOUvEmnHsk3CaFOfKOWW4HLttGYfz4+RhEXeqbzugByM/xxEbp5TDBXGKU6AVkuZaRVFRCYKWIr6PMt1KI0haHJbMT/uxCNa+Sg/2mOvz+CoIj+E7DOdEuCEZdsJYOki+2jMUyE0tKPWi9mohuvVWtJKuRwnOz6bU0bbSDwmcrmaMLFEtKdhcy+72zRoZSOfF7BWuVn1BHFNLH4Ez47bxYJsEUoMDZ4zzowS7kilMrZfINVgbjJVpnTWjISnWgBFSILYDNMXeCAybQrxxLmmP67zqfImgLebiK7EY0xADk9Q4rIMI6nRPqbAoNwiUV17iVYYhsBK23BVMRNG4y4BGgwZifPOzWYr983EJoEnnEQHodRT1IeW7ztxkG+Ra19nObhbwYO20SDTx6JVwGzbKiEkU3BJVv6C0aHxxAsd2YcXAQUxITSlvTUst8LHB8WNq/fkufW7gkhxv1K/McMDWT3N7mNCggNby0is1+tNJFO4NqqM3XjchmxYum9cXWAmwN5LajdCS/X9Be1E6U5gDf4Hp1gCllBi5Z+cqNDXt+YVnH3ffm6Df/s8IWdXXQp/fLHJCkmW2RWKFED8GbBOa/lw4hZNEIk9nuHK+Y1aI6URGs1Z9+bxXR8jw+UELG2KbRLYlLC1uqq1NepAycN1wbFqkkHQGgQUWR4Y6OC6cwbp2Gv+dIEnQp4hiPU9oM41eKhyX7+yJ0Q0bP3zCCE6nGoldlXgFiCl51UyRoDC4TRXECULt7GsoFZoVhqGzDMwSWCECM9WyMae8z051vQCCawvkphvNHPxQfAr4XR0HQan3N92liYmnOTW2pLSxMuUkjBqqohRLpD0sZym6FTmL9tX5jKeHwwXyHZtAT8bBY6U5vG9oR8CLEUKkyVtwgbji6rtsjDCFTZV4or6ZRaX7fBkpHjhuYZBIq92SjM4nEArjSpCmx/EFXCf/aeGPxGbMkTjRSxTAWKyQyNRZPqL+d13Q/G0lzbAg6UvDoFmVi24YnCMBMrC+GTCc95GCSFIfHesmZZgwPfva15i7DToHSVG8Fk4v/BIWfCPNcn+d5iQQWUHlnURKdBYRQh8rZrdQu0k+e2ICWyoIrniQG9w/Ln1lC4ynMpbSmYXMCGebyxicYrsKjC5+DOFoVULdjtxV2pGGVztru1h86ixo9NbpCH0k3z3Z9GqVCmsh9QGaVo6ObdpEficbKbbkQOOkWgPtjpnHv+YBaCYPaI/aXsbwbOWyMWL3xkjdOjOhQKZG+TW/6ciGmsaok2mwJoMbMlOprHdXmxQNy0SnGsUSr5Ts+V0b67JvMekYV728lRNGGDBOZQMvYW2h2CFFeAW1NVxXoITCO71GGYQs4xZL+njL/tY+2dBzY5qXD7TqdXCl/vgSTUT5aGm0qaEn7BQYLJHyxTgG45scHLOeKDtO3LXVeabYXbafXbjPVdg6s2rLE84afuSdkQbDHIJlrLNf4ZJPn+yId9SXsmPa1xqlAs1DRGyAcdWyMOqnuLMB93yjBHY9ldGjLIiwC6QSFsOr2FbqPim4iiXKyJct1x4nJZRPL2O7E+fZJRqMwuiQ6DHcYZgPpuTiTsPDjNiF/+smWCCwY452qfcyLUnS0GEjO2hdtrbWOW4Ld8Ya2eMb9YBHBGPIknmSCzU/bOgNXEQUy4CAIFgF9xxrWbG1tXFM4pArCl7mX4381ufoZcAunR1zwZ61CcHE61VZVslSfIkV57uMzQhZKiAA92/7I4NGgKREGuO1JGIJepx+6qU2FLN6cptwl7d/EYgoEBU2jhhN9ClqYkSLjX+6ZKLCBlazLMs77BefNfiq9BXFYDhhteP+WRvJbmLKHqjIsfnsmNOwWRm/lz2rmQw5SqzbI6KqPz/QohI9tJ7pNvTEFhXsIvjiR/3gzyrZ00oZoE85Jj37ViKPFoVEF8gW3/I2GNPRSO64Y3u0RtMmIgm+XF9zAIL8B942zLCE2sfai6BcS27jbvH6YHQGp0TEqwqtjELOZLplXYTpTjtvT6nvf7c4bVZSh/HbKM0n1ORXXjrPN4UjMSQvTGkvRdXPcs7FS/PEiT+BK6w585JLC1NSGd/tT5IE770KWiLles5XqkOxIyUsv0SmeMb3dwfCLr1cFp0Fm9mkG5zVd9mR1L8ejeaqhjxPWtNsMOxf+j1FIQ1a7Yxl46nshLBOdAriwBUuaO5SIHZlzn0o39CHhvgjyNRd6dPMCEXWq1QlDewUZnY1l6Vg79nJpo0DUaunlHKQ/q+Xl93L3oNb3CzFY1ntBC5zFfaJy4pn1GqjIWAKYeWcyawPHDv9g755AGDMkhaTGjaGDHT/KDv7kQ88gQajOcPzIfknc1H7JdKxsB/dq0PLK9sffhEHgSZxVGGCvHEU6W4cfAb/LrnUutl94D8vp/N+Jw4UkJNvMEMxWQtcsAMpOGr0ykOdFIxzazNAKrG7v+ci5Gfs3RPosI6oJKkHu8X7Iu40FT3uUqeVl/hcQKbJvqPhAqrSkop4twb+E5UO51QpZGhEzjRaPJiFkMi33YzZ+0HOqrnAurveH84fdto4JeXf2FcuJK1bylAwVpVs8/gvHznuR45vHt5LHlMuCeKQZQMd9zfpvasVGIiu6wQf1DRQkZ65Wb8Mx21FbpN22un5qsRJ7PdKphejSqK3rLryyrzolMb97qPpll5NHxUG+KQQAdF0Uk/49VmRkkwcePFWcmHqUGUjYYCxgV/2bQbi0fgD+Fip/MJjBmFK9h+7+xUXutg3ePwq0KEmLHWuTBpJ4TYJeh5PLRgnQaLvqK2vYql+e+kTibvEZbPAqIcc1ukD3f/nUKHVsJVYKTETv9/KlIINFQhNNtSX6Spp/YsCG28yoLvKubECz34WJupuEkbfbVqfFCk9S6CWTfkLBo143YDdeJVGo/+GU7yZDm7DYP4F7mHOfIPPksGyV4OJwzrW2sdfzS2bg/JViDqd00AI+PL1bObqXtfGgn5d4bmO7bzG9KZgNNHxg+xDf/Gm6eEXN12HK7EWUTJQ4kk+Fg4HYF/Dljkj/TJaImWHaIQgco0Gwg1Va3j+1cjoorniicI7qVCVapcSSHQjeBMHqt4WFf9UVvu7sO8dhEUohpQWlWcJapRSQeHGWyna1dKB/LUyX3ZrG2V6A2dhUrOONSLeNfG0wuwAt93/EqIpkfwAnVVgG1ic3+5uoDJ6jTGGsvEtxPagiy8BCsTIhr75CRugfOE2Sl4Tj/i/uyUCrFteockQb+ycyquQbYjIrwWuexgo8gWEU8XEIhZXHekKKyagZKcBAR3/VLx3DzjEF/jGf7eUi+1+8DzfKpTarW9GPuUaMKJWprrfZfRjo1nHOJbdAYTTw/e5ajbHbckkIK7BrE1A5GNDk1dD5gPZ8PcBjvRAWnHaV5XILr2XwutB3beildiOfg9lB7QN5PpjqalKwCDdKTDNXBGEsIMbNS44pig7d5/H/zPkm066flaocTnnwqtZmQu00yy1HB8XVPsYknL+4qE97fNqcEON5M97gwFIgUMgYo5rOswEMp9OXwOTxuaj7imLPF3rJvbNnGRmzweDuxEAy/7SasmrWDryXnLz5/aztc4QGaDXR69h95QMsCXeorcrPFbzuhj2c1WPig8f2ecmasSD9m/IB/Gfe+JcAs0BRcHunss9n7d3350N/zNcD7gtmnfSTHu4T+Ey6z1tP44ZM6nz+A5HZ4hZOhVwtFKaZxhRxhYfwEU4daaFmJ7cQKyPmZtrHYTDE5/R4PBzqyisKDYvG3ooK+ZMtzQ2kVTGxBxowTMCLfN8WMWMr+VKDhzWfbOGOk2yOUgPVgB0HMO3Q/idyQKPlqRnj28aOlg4UYbc3BFd67KWoz+xbAi+yqJYZ699WSNzwFHWAX/TNDnj0RJXCwxSLI23AzVJjOZO3O1FnICdqmZUtBdvfdjNs+sUk8DkKDpU0L+baJNFDwxmiiwtH6c2K5GL04yzrzdHKyecbpbkbaSNSP1bUipRRkn+tEE9uEzsG+19kmr5ZJqhzLZ6A/mLRZFopeZY3j2DlV3y8Gt2pJLrTjSJes/G6rl65IauYwp/T2F63i9orZveu7CuC0D58g5sQR2kr0sBHKIcF63ohqMh48IsKnbsEOwV6Rfw69hlXDjFurDpZhs3d+Ib5noXxN0mH2hbn4i4OYNnZD9uu6F9+4iy2HzTh5GP1tNOAOjsjZuugMdLNmdUL/kYuhCerULWxHna8YpGUnMonQj2kYh/1o4mj8l9BlVam8ityfbz2ecZ0zKq+ugoUwuPU0e03B+8/dP53LkmzWgQxkh9JyG6IMFLGDWKsTJubYg42uxlKMfOOUK9mIH/Vs7dMuhjVJ+giXIaLYPJwgZRDYqiz+DEc8CYTTBFI0KLlcQ0aReO9/uhCAIaJHr5RsaywBYoz7WAk91IGxWWyfaCEarBs73+jsqqakGKbA+C0UOz02jMbNCFs0h6xGKvThiWDMpA2IJKVmEOkeTO7+8Dv7PHClZUf6xrCN3/pkVX7+s5hgq1cLrcer3wWPwJRHjMt43+echWGwdZl2BhntiJw+x3zsMaJZ9dXSUYuAo9US/xP08Fgus/5e50wXtIuTM8GSaRNamzmsj1IbdhhPGF+7p+z+/EnyEyASCsDF2SWbNeb33atP5NOlNOc6bJhEw9AHZK00NgTaIil6V9l6m3nsBJFk+sMw4W7LAn27EZoQJpnZR8xfLqTUlsCjwzK+takQIjdiMAMPA3l8h6O2BgcHjLVuXAidlv/0VhVwLTyZNz8pkAuF92vle5RnSAzIWGpSKr3cdgpIPA0OQwswgKWv9HSrX4tvrhQ2fti8lvKKQzd1jCIeYnXuxQn+sUptgaJ9H2CACNd5LAkwOYjhhO7fwx6lPL0CS25Ur5Xk2hP0jY8fQmF3VRBy/bLwtza/a3cf+jxhkb1RMQH6E5mkErPFo1QQzQbpZRIZePjc1avNJC2MBS083WufnRPpiD/c2aHIktAGdMgMSMz7RodU+eKbBPJDBYTAijGo3oqr+X6M4z5TW4Cyw9StZ7H/bIUpCbF12Cn/+FRA3kgMQf4wlhRBf3muc5vYAcMRM2+ChpDrUwUh+j7LqFlMbJrpuROoQYKS1j3SjNEYwmduLImVnGMowMq3avyKODhbGy37iHVcgltgGpzNQKOzkzI0Qx+qb4DG58NN5F9hwuI3M2SeTqksGGscLNJq/yCToNfpwQo14LbFUQK2e9z5ThQQJfeow1/Pjwsr/tCskCX4/mO/vIVA9TbMM4IITfphAIUfyvi/X/UPE+McIIvqEGLidiWUGsJ3+veMfE7b5UoOzSluLnF2muUvdwuYirjcxcbOZ7ERLsxGi3aoh/IVMrI2v2AvqnjG0aD9E1gGe5h5FlWJ7UxHxPenxeGKS2JyBV1Ir5TMeuwCnRIP0wtOsMNChSn7Ky311IntgLq0VxP2nS6a6lBcAubifYFXZ3RoeFPyo1sQPkyyRsuoyaibGO9Io6cqbhuYELgkcW0mHMbSyGosAO/52mIKjTqYzZZRHn9sqAUiT+sAAgsthtpicv0JfKDFtWhEWXy4xWBYTdTV/d2OPm7vLx2nFPm2ryqZJnKEQFk9qr/qPwBR5r0YU2zITA4t3ASZlJ6F9S986r1xEwaqwxeyWvSjMT4Hh4V3M7Nof5LIucpg6QpaVIPGG4E/g84rk1K1QmiUgn4zRUasJLAwzQ/G2c8nCxNda1HxpZN2o/g28zK6UJeLNym0O8GGLzhgpE6vbI6aTHodKZsBKdvEXIYzA2u3xBrfXFhv1DuGlSzNC12iCXKmEoCX5jlI6OQZX/V99yEtGm9YE7IVqDFiMbTYDRM2DTo5AihhxViss2AWebj538AtbhpIaYmAcnI9uQmMkSAVSjMtjgNY2SKo+2UnMqwdNHfJC3VUZABQI4iBOVVtMEBe6Wtf8T7mkLXbYADR7YCSLn6xo0J83vYbW4oqyNEgfZSCC5qOZtVKPfBB2UHlp8ABSlFelsk5Z+ajiNXz5Y58hiElwbdYqtz4pY+GJv5fsgRyygZYods8AjvdkChClOxiuRtdVxk8LJecxYP0/K+ZvFzSFHT7cui1HzIuUHDl7B66KPdkEL+rMUiyVe1EFHuyrcWVKUKnSu4u6uj6gxqS9MRrWaVzkWnZQ5dKLj3JSy8HAJPL9pO0Kht4MoZ4RpAB9hKbRc68eEQEyqDzuKHp1a/9NHdPlKwyjtzhWTrg7A3CWwfuqJ6+GtsCUaIg6suxJJA8ZcX15YNgQw0nNelMcf/e1Im0KaOI4blkp1eJdembLT8Mm4j5QElM2IFHkbDTzQpBuo+uJMkA5bmhgchF93qO0SQZqEquPWuYuPJRB4gJm76U3cKE9fcsO3MO12jaGsQFVEv/qfHmjgzbrMkEHxsiDypNap1PyLh1XBmAylgnGlTWzjH+tDlM7zSDVBs/Sv7MYZivpAgHVgOtpUgG48HWy8sPArPnaAcNkbZxqJwRWj37Dd+I5RItfq8Ob/yXavn/g70O0EO4KeOMWgg/KeQRRYZHiy39VcmHthzaj0JskcDrlrVFMBW8fkWpc9aGcBkvrfOs2UYRdB+BZkIddGbiA1tVQP4MJSBioAR6iaCoJKAAaC7MROPfPo4EBRRb0hqptVO2eXUfcYMxkZM4LJY8+Z3cVzsywTxUAgT899MVPWiahEKRO+x82lXltEjvd4LbUbUjd07J7R29u7V85aowKjkw7BBG7eF/6GBRpykCqryEtps22XZCSYzvBkENPsTFwxTXAGDaLLz5eLuCwIsmgsHQ1n4L+bMFQbc6aVDq8cIhVyp497ifvypUTIxuMJDdQL+ej0bLMIgBWYwjxENJ0i8HW+lZ96e5LTrZ3WhUMMsBEoZFddHDpDMRqt68rJ/H9i74rN7s47Gw7CAjgvZ6uW0zYDiaOUqLwdsVFEE3N228z+iLU3f/WW2RsSFuGjM6KDaPExMJoisSy3mLzllE81l0BdaqahyfxX6BM86w/GpXdZQzQ4yX9g/kboj0USxeCMbYX4sQ7WQNrxzrIqQlJiSk3N6VTieyhzCfLeANKnmYKr5no4KYhcbNvIoXeFFl5oWsUa0vwao36thBuG+c2Z+cSuZH6KHuObr1NvR3gDZW9VkdxsvEcXqM40h52fdM9UNNFMychRvafLPPFVD61PRJ+GzFW9rnRdP2DKkKd6k+PmXIvGf/G4HyZEFvOHEyHoxwXko2AQNTlFuUMgVO/bzO+lqHJ3ExgYovQ5Zkw01xwohyem2dj8vAr0vareqrzOQ5IAhOdG7j2oUvH0AicrGdQzdsjjX1E8p0qYtlsikANkJB8GjnpdHEe7zKHbI+R27AGdWwnIwCHlzzmwe3LzBn71CeTC6VPgITq2BZFH24f6fE++ahHS19vFyhVD/uUvPkqrpXY5+1x8wNlXk2UjbwLPvd55g43Yui6WO/8092VpwPsDxBUzrra2enPofING3hj1Bg0TCATMKLm+/PVMtMm/aEeb9EuQAodOwwkcQyeC910NUufO4+maXzX8QyNgnU56Vt/y1KYS0g37diSMdiQt5Ih81PHeA1E/u/pAjuig7lfyiRukjo4ytmOSUtQsPQzItz58Yue9/CIiYfeyKE9WM+gipPfa3TMSScHA6BHKlun1dwUBlNrEKOE6TGlbY4Vo3IAx9bDPgYy26MDQKFMR/txaUpDwW1LAgJNeldYc0CgEZ/Gs/dRXCg3yCkqaedkITc7bzfcDgrw8TuyCwup0BIaAZ10wyqyi4a2PW+r4aZw2/hAbeJ+dBG/cjTsgRZ+ht+HsHkPWeqccQD723794Ze0SUMINQh6VyrEm2F9CZQv2+YnXqgQBWkFeBIfMgCKqcd5k2OMGQe1E2zHRK8a4AIZ5OhyQmntLpU596qg/sMOTNycIxPMHMB7aF3k2Th8ji04Z/Pu0ItelZptHFW2+uVv62hKcRxlklCfzzX+y4DiaC6MZ7BbWAJaOuHHCcEqd+ljrSqOGnhDYBWfWoBPyF5dQntsnv4rgitjjsuZdAnGFz+mf+cOzvPDZAxSo0JwcerefI8HH5O7OWNkKgWu+l+k987qWUw2DkH/rtkrt5ZrYJaWw1WkvHx7g2fOZqjc0x+pd403mGJNKKydd0SDkgDeLDL0b7PtKrm9Zwx7niaLadkB7z6K2LWCDaKhVY7GGPBHWu3ObIhsnWsa3AJeIfkta2tpfpa6B4UEcfXjPjM5uksDKeZ9ndNjferKUYj8+JtlEENEpGqnrBzKyC2yO4hiKn90JWcg7PaNSt6PMm/D3Bzn2qH+yYAoJNxopFsavp40QFKcDzetggDgnQoY4/WrKsrNw6OPNTZYmhVvIQe4MIGwIxPv5nM4TGVnnbdRajsD0Ql2HpTRwQFU8/dhiagezJw7kmy7JDUqEoTXvC3uPl/ytZcVNEiz/XC+fkdC0zmiSRoAvVxB9IGi1hu6Z2g4dhgJX/LF0R+IwdkSpqE4AdqkVnGlLjTbYIJJBxgLv0CMKKoLxP7J6YwmPBNZfv0MyK397CPGAcpYP01boX4+BH22j3VloyrDQKZLiRJ6Sm7bDnemKKHA8JPMKxnMC3K32CcsbABZs9YdkfMrJwOquFuxgd5zCO+BjKjpFTAdlROr6was79LFcpQp7ebC+53Z9+G8Eif68Qnpu2/q4aM6BLPyOfrZCN/FxVgdy6pEZETSbhvmXb4THJvk33zvynQVOIVvCRStTRklCaHcQl8MMvmBwLSXKpTAx0VGT/qjU4RkNDZ0WJQyABp3wfi90T/tDqweZTCQdHzdVBO+6sN9gp6kyrDB86XgJq/iAd3TIVOa3NVpcFKoqx6gIrCuPjybwB0HWVHr3bihaaexANKbeDinO5eF/lOBJ5kyr7un3tqmA3rHxFOPMvgTeG/YkehWGSJ3y6F3RQ6C7a1TU6+DqZzHBIzFs+ieo6N3tdzJP1+CZ6CLrPtRAEB/PGo60oKk4DFJRBacCBg83VSWzKvlcqkywMhNan1J2jpS8lgvYoxiKL8LBgu4v3xpGN9VuhCcIKjJxQ0EymdgzO2KO+t3mGHrOiPCHfngMELrutbW3hOxrpHFkxuZpdQONdXJoi5kqjoB+GD9TLKQ7af6xk2dRmFaTf9kFiOIK04UnegPj0bX1Q2ATCKSbaNznH5QkmeakcHoSvbaWgdqgfRp/+PThZ2gu6Q/lr9SYIDohH73RR2Z6Ay3kaif3Zn6u6Cq6HtfQ6WlRwv/qyzjvzWt9GcfU+OYksem0WnPRpjATucyVF88b/Er/LzogHb9BXSAtfmeth/RIvdq1vDddTsSX0IEGV4KLeaSIaeAFun7s2V4G214xTwaovuHkvGRfSss1A+wDHr2Jk9AXFLgoJSeOSp5sihhz69xkklnespIPGXvJtMiUadQC6t0t43DUf+plDDMcDlOZVoz4VBLKJQ5YgvI1Gqal1yGY8La1QRDzpCf2PhRp7Cn2QwhUEJOe+oidH0wmZASW+ZXCKyIeA9Gg6LDWIJ3UdAdWXjEEP5fPLCebrea6vBhjakpIovFijNR46aDirWVB6My/0tTeyTOQnVyXh43mYdO4lYVLUvD8QiJv4fNvFyn2xmGujZo/fJiw3uq57xERxmoic1DJlZ8AA8mosQV9030zkXKtYc1sKWN6Z84F/UUAA+r8Itc2zxp3SWHlCreQK1wXoNn+0nVP1t3pcW7aLGvekfBpXO2Z6Q5l5U9WwTjJUn73CmbumUtlnwAp8cPGIWxMqsUPEXHE/q7u9HCticAkldb2I8iI04JxwCppUgX87OsoozOCWEPZZr4TjAxMHsA1BViW6OJIQviNLD39c2bfvupc+Rj0+vFPrvKfvFyZ749a+DvahVRKTyv4XOyCkb3vCLy7lDVHSSWmcF8oj2gPuWAM3y1fbpbSbNjSpnW3ivZ0quRbcJvTN4FJKNHapenMIYjKpF1SGHfTD3aLhpwMHv+Jl6ZUcbNoULmwVv9586GpQ/uM2kdnOMnqEwxIucCgCFXdXThmGIXEGjvRwcr0NQL00jgIf2C4sOxR2/S/2XlX4hHwlD500n9oF9y2MSc0ML6xpejuX6G6BFrXITmhOtAKnvQSyG6DPLLQvt46cEUvcO/UBgaR7lnc5SYXxVBLroMlBVVW1/8aHKH4EfUppnRHsVd+iizfA7J3L/nkGZp7PxtdAbwBL9xjX+Q3aINx9PoC2z2/bRDSyb8tIZz0PCpOkpXaC5fj9PC6hLrWz8mP/iLds04FfaR93+JdJ8pl+5PiIE81iRZ8mTED3gilp4/lASbYED/PW12kVsiialZfsmPpHELpxkNGRAYMy3XDHerqz/6ExhpAgxLJFlJbelNa0HNnFE1/u2IU51kqeUjSqFJ7tGvKfwPgeKXVKhSdzHbUnhv2PsTBoMQQ/Kyxd6bJ4IcBrzAGeS1NTSo2XnEnu92iOOanOkOB2V5CcnjZ0KRqXniivpa+VsaQ7YS7NPAYzWmnKCprOZQn8kcxtnB/G+oMmyFsiLdS+1lTTUJO8askHuiwyevpTO5SyPspoP55IEBz+nCh1AnGvgsKvXX1FUfw2hzfmXyXzMGX9gb2tYJZPCgwVNCVesZWNoleU+BTNP+oQai130jaW+EfJTWeoqojQG2PHk8s+1Gw5dgzSelEJ2LnCOHn9CP9ulSAOZrV2Lb55JX7cUarfJNTsaXsi7qIUMrvJ/I8PZEiCaoWLLmB4dUkvrVv3y8PH1DyRVuFsTb55VYoCsFNu7DSuC+1qfGb4npridMHWhZfpHMGPpFze8/WysaUOF+jePE/JdVBLnxhOxztaXNjuejJEm5M6kEWARQxIvkdZ+CQ7UeAbBlFB6R7bvCIN0ZA9r+JkDbksNYe25Yzdx75F0RvBj3iddggDzSEkr05pOXJ42nivh6Lztzyuj1WVOL9Srs5WW+XTD8kCqUGjgcijrvvBvxN0TVX6Jv9AigAFhxWyuBt8RbhYst82vOPQAdo9r34xowa74EsGk1mEO7mpnRXuZmP+KgpoBn/Ta1EIj4gOjUmnIOpitfaQZSCQ0RyY/Gi+HyCwuxITwh9OkV2Zv8u/hZiHhuwzvuznFvCheT8DRtlHt99SDsbpUyQ2nsP2sV0WJcF3wVvXk+NyPXYVR4dm0oJnKwDlvr31SJPx/ZxCjvBuU21eq7/CMxeLy5IF/z4w1tGs6r7vJZgTt36K5LWuoPjlCzJFZf+rqJMe1DtjE8RELU6ZEEsmLkTx6EhJL8/N2shMQKMXlwLkN92wjBuCOwT7RVG9xUe8p5lu9nVD1Ch8n+9lrdMNaJ7KXL/qSTWhjukcpW/UV8uKexdUGa8D2MWwSefb+b5LPrCqpZEYNijt4NJoYCikT6H4C6ls81JtC37E7/usjZhhBz46n0CAThh9PaSX54iUG8hJ9HAfdVMIXrzKajSmrcfhF3n4FdKEM0RKPxOgV5QigMzL7LYmzSbA2Mf2u/XGt37uAPYXK/m3Of8WiHDW2Sz++6lI4HRLDhiGtmsRmUm8+CRM4GmM9k2dk7KDXw7waWHF2kCenpcoSGl3p0povZCLsBOliBHUMRmSCTtTKZSyq2CRbkwI/VUN60wMKfmlnzdpdn4PIAXNUAy1zwhIIa1vfuxU8xTFTRE/DXXym0P4jpIlpcciDzsPRwMkcWGP6Sxf/kalNQXsO16ExPdMY7GuQDgO7q71TdzTcBa4wW5+ytWZDOV+s1i/fOFZAdxBHElrhXI+0I0SGksCU+XLIQNoQBPfk7Y+Whvm32tSmmkon7nT3g8RdTfW+u/vfj5lmMyyPB95auKLwZ27JJZgmsVBJ9fIeji1vzYtGtp7ix0atJjSfwzP9awfbX4v+aaiaSiK/0OC/PBj126/2hYLjyu8N/ubvJruwmPKJFoaNZ4nquSR/Y1r8W6t0pPQOX7vDPGcaP2F3F+XTk8rvK8iVNsC/JRlHqTJPdsAwPHnxL1zQjI5xZtGbLYt3xQH5hfTbi8/HAL2YbdrMwsogCQKsuiQn40Lt1m0VkvRBXtg5bPp0ZxV9BJFoB4wbPvloMs5g61wAgTjgGEdfwJH3tXAmViXLMBs1cuB612m//9i0BsnUjmKZSQ+4zqNLC6l8yiEclKbMSlVK+FaVjdCD6KhILmiEBeaJvlEGUh2CJTLOd7PzPC2CgIG8M5l+//1sxRfdVcE3h/itiY9tIrIVYXTyKTveGh0eg61ert5p+1Ltnsi+389Yz0FG+oOM2nRQPK0vvUWd7So+MIUAGL+X/Ii2x5iCbAYH6+m3p9PpVVR/ew7vezT756Tiol0npPEQyBcM0TuxowF6cM2h8TH88k3Ogcy0q/9v+5o8DyGWe3fAoIRiFCgkEmJBGJchQDx4lc7b4CuViB75z9+WcbKNanFETDeY+OQb8O07aPged7vO4kqWwCw6yTjagRIZF0p9IVID1fCNXbYJ+qp778gjUWN9EKtfT3bKHJfIbMGmMSMy75u5s9Q5/j03gsXkyq0HmdjOPAet4Iv08PuJxm+YodZiSOhroRF0M9gsBMeIrLKXvdI2C+MNIZLIY72WGt4sIy3n574RfoqDbuoMI4HYF0/4BhnGwsjPRkqNuCEyaoESkiI8azOvkeML8dHPSxkjo/LBlZjwhG+xe0Gs4iI0gjiINZvCPhRqlmIYuL5aZCtfu9wMjTAdue4nG3dZSJSo695fGWucY9dFEwH7+N70jCp/wuRaj99/sz8iOoZzcEW6s9pI8zp/IA2nPKOn6/vzksBI2vTHedQqFmZOWhwcO4Z79VbxzBN6C5JosBCIpbM/FT2ehCrkC0IiymlsM5JVLfeoWNZV2qq9k49ZXbLvL2Wu8kWpSvZ/bA7wd4qWVuXOVV1hQv2ojmULcT5T/I3W3j4XnH8xZzGRQHCn7nglazvAA/yeFa2JjSIiO+CdvymQ65+qMDHcMDv+PJ8GYYvCvZcXvPo5Lq8P/13/mwJRtNQf38Qbfnd9SIQifAngt3FKKA7nLLRSFUJRnpwtmMApwVVVP/tFPq04XwF8wlVp9nlLtZL5dCA6EKctxNHZj6YRT2I1MmzLBDrYOOncamRAYmuv9MH9zuhk4L9YhjFqMS4/slX06HWH8eutXozhN6td1Sm1G6QTzvGwkO2fNcjM2yrd6DZ13K2K0Dx8u2OJPPSIWuHjJ91lQnW3gn0hxTvBHy/wGaMOSTZ557oftmlrU6edQGq87IDS/S/HO0Ozwne4XGQfoV9HuXjJUct3YStJI2FniXeINcQ5FDh0e2dapeWlpArm/O39xYHYdEvOZl720LRyDu9IUPwYdHPpvkEJayQAEk55p658Lyj5BeaaCrKqhh7ql89zoi/ixEw7VrK62LUyrZHfPuxdXfVSGUtVYE4ALkI1KaG4Z4uSwa9PIx5fvdaPF27f8qMaXEIDK4Ga61G+bvYAxztq/HSt/D/OML9JKB/wU86kUmu/sh2csVs2MFIksrxz0jcfXN1diX4fpXs2J4Ln2V85DX67r0wPhKMQgb0odJfij1Bd71Se3SFJg3wuyo1DIirNRfIQ8q2TuzGQLBHPDttSnfdmnFTxp/dR78CLArlRGE88d+MMkUf7JKZNSdDyNFEl/OIK8c8B0HhVYF0fUeuwuQe0DJRZLghaeN9f4rzI7NUTXzTy0eysglNjf8d+RcnRdasTOOcDicDKdhjCTcmkghFq43E1BFF7ItixtRSHpvx1yENt3ijjuCrRUdjYv1lkQEi6wFOLbFaqOG92eY+wkrnrCASX9WEwSuyTKnZi/jS0V/eiUSPWa04D4SRc+4FAbYyP7iHSX4AxJ1DeFhLaAfRSFm8Z2ky7eajqFYQnz4XBOlsuxvocGuIuq6TxfHyO55S7n1U8JZhkQG6IN+4UKJyre43kSm6UEOlq3s68uUwI0WDlLEADebxgWauynH4uRgbepyN4y2+fP4AGUcwEWFtMQwFz6xA+4PNGriLwEWe6FBscxCPu/gmCDMzbjelcJQecRa1gc2b9P7Z9Z2ZAVyGVH5afXJuMAhv8BIckKkfWxL7HIsxsmtENlZ+foq4QY5nPPYM1/7fLYaWO2ARRzvGHPIkyPC2kq0o460nF7mG4Z0WTWZrexpbjFyUi6WQGHAff1xpsl43o+FJoE+pzNOdrrjzn/N2WoMrTUe4CAWMV+xSRAUp9CnS4rOxGxUCEAksbfAuXbwCsXOU0lQ62SFcaQ3zu07wwEdRaxjI4oZBoyDHMmNwsMij0sH9sJxL65Y3WeSpbWr31wFNxsjd68zIdpTND8eI7Ydz8aetgkW5k8UPgl6FRvU107OjDPywraVDO2CZU5zdWJCzD4Tc3xgbNTauT03f5C6dbItPaLAU9+QoVkScglfiVsOMcKkTlSmbo5wFAcsAlsG3feO0KrdTSFFdMT8qQ6hcJLKXrAeJzReZdoQtdxqy8HqCPnI5XYPkfzjqaAW+RLB+/mIOKUCS/5Z45kn+BwPhV6k4eYwio6OIZuSsE0o4TofbDeym0WcNnZgDGkFGfKIedK+hpeHGUF/5UTesDVWq0SpaLOrye2Sa/OW/i1+lQxlgPIqHILPMY27C2xLMkUBbGstktjgf/4IaNzs3OSDvKM7MX3T8HLKZoBTVmMui+irOYp46J6TTK3ux9D/2hl6ZeNUNm9s27U4SysWivfL39oYIhSy+abVtRuMi+qTJ7EGgIrvK18URb/GcOzk9OwT57VM5l8h16tjzxZJHIdtYyuDeYkSFDhuEimp21/4zpeXLdu9RFtwyrfvcGBB+D0PZ1gzUIl77AlOhpOx2sQVVVncvU2vvyjwaRdLuSDMFrU/BGjNM11QwofYAfPv5jlejkgdUyZ1S9UBYL/MCTvrkh3Qi39dmBjQjb4MfUD9YfLmr6Z3n1vc0sTMXAhHIGbeCKFjuj6EXT/CGX6f6iPH+q5NRJ2ZryqLnmxh5u+XV6qF8nZsnLv0frioEyC+FOhzlfTkjPyRPqKQEbhXNUpp4D1SuijgX0iJtoNJr98XPxZI+FuwfI5lpu5xzPnAgn4fFDAb/Tozkyg7v6ppOyOZz+UJ65GVHAzy6LaS79ZK/xWpGMueabIb7IEjouOPRbT44aGdM8QFFAC40kbkTEzcQNrthsxRzPtlZFjx5ARR35S0jIJGa7weMumU9dgXQL19UyY4wC5q39c50BkVWEdNKWxvsQBueGhkVV53Y3Q6mPyx08BzFWQjdSbpkw6FIeWxLGOidFptBgg+oOTz3Dw/UCncT6uuSVYCDh/fyILtSFo/iWLrzgkk7xM1BptVLelkOwIR1yA9Ly9Oyy7Zz90MnTUdBnLphwOukwcKxX2Abr66f+9QeSbj/U+g5bQ7Ad28RBS21wxXxpwTiC5Ak2g5gQevnjPZqmEc7a/eD3woGbVL8cXGrACh5tLu1fNTEVTO3WezYdlbwLW4dydSQv5bsQK7AhT+iuJ9NMq7StiIjzbMqnzYnn/NsxHK5LqL7LzRBQHcD+bYXoZcVwCDt2zz3INf7AzL+nAwPvYbmhs1O8wxBD155/mIlAxr2vlwsXdFEdCyrDI1M/zolU9iOLCmM9ia0prrXggauVfKjyJG55/RCs/y531eQfRj7LxdPZfRi/G6XmGAn72KjEbh6dnlaPsCPVyGX/nTUEAuygCZg2R6RIcAq9oLD5oGoPGSbMGdfQAvzqgyhVmLJPGy597NWYm84IzijsI30310C7JW72M+BlhBMCmviVhNXc2c13JOl3zZuMkpxzAlyQrqg/VmuBfMYdO78pNZsLZdE9b06S6BE9QAheDQeDQlkYCM6Zj7FKl9JIlE3XfLLn7Cu/4gOHI0k050k/0z5D4b4NGEPZWSZ1PMnlA/syewRM0wGF42xbq8KTCHaZgWX4Pbu4kt4nJQ6GabovrSAXUiO37XcpqjP5g4V7/59LH1IdS03mVDuLkX75kZNix7EgW/z5iwlS7Ft+3M7EQhqHFuqcGNQBzkJjzVUDEwQS7fwQgYhrpnNP3q1/366XIB6Xq+CX145ruWkVIinVgDqDH+Mg6S5dUGEzrC38GtbFyNaquQVRNFIYe5jd11TJwKXzrgzF+UKQTvFhJ/6sa/OIhw31wSjONg33b+nNsjFOtLfxBmAH7EbY1ikHQz2WgR0Amr1hMFh4oWKvA/ZNfQvC5n8LU9LPkl69bpJ2xHGpiahfYTTUioaTS6WHavgbwgiA3B4E9LMaxgsSIlmLUH3mvCPL7Si9e/jzrSatDWtEKjnQDa0VWihPgtTdswUQj2H+fILF8jlRKPJR6911HeSvGrkhFF8Fza+4nerSxNwPV/kl9wUsuGyO6M+GsE+p43jNBatLc2Lj3VzVtdzgqfE78A1oPgyhT+v+iXZBoc3lBf7edrTJj2Wqv8AvulIPWNwiYClNpQ+pD76VAiTfZj60bjyhyVqgUC8IIJyERFQjYGqLjslGKPJKBm8+UgO9IAKT68pjZqrRI9e9hIYaNaXygycmNFJiIvOw3HbVQ+r/DeEyutJ1/SJCLkO2YsuhHNAG48TTk1t+VqGTLnUt4Uyx25S84SDmV4pBf+sqH2cEaPO+aIHTcSKq800jWIqt9yoTn0TGPeZCg+Y5Rqqn9qB8PdNpfKL0ikVODoymEGjeIuZkeCkV2mUYGmBOa0lwrjNvAl8wflZQoIvZiFBuRRY1IPkz1fbJ7pl4rvzTjbvYunDdO73HkOAe84Lpl6HLK++DnuoY3VsNUYbSI00NpeefUCfWfAYQ1iULknuGd4UuHuStCXo6/cxz8QJNXZuMATeUIzVcdi5jteyhatFKOL0jlMAGZ3J8HR6iywTcYBzMzxeTNbXJDjY8TT/7KE2MIA1z1coMhYhlzZQ1mRoQgmXXIoA90GKVF6HofN/a6j8oIYrO4ma2GM2yTrIfMknWlFGfbpQJ5Mb96rgROgb6rMCoo4F5WcblmOQPSFEeyFJA3WHPHxzWq+ss4hqcfeF+o/3hfIsIchb5cSAk4VJG+3yP7XSpvortSi3avDFpT7SRRdI2FL9jG4FiPenaKOubtFrHYxavgM8GFfqTVxBKlLT2Ywg4HSuZ+9kUfvoze+TcngAHVHbfvX739HEwFHvNCE3eIxI9lu3/u1P7xintF92dWl1H3g7fD5LGMJr6zBdV8LaY8YaD85dfBk9yTCcF0hPMdsQjSW03l70F+IVAUd39yvhR0Kf5zxBqkzzarnDmgUElqTMbVgVKKgZ4H1eIL60DhY8XuDmoQEKD+8qZ5GRaT7e+NxpEAgIRrhtsv85ZPm+6jDL3KQi5K1BoZbFdtSZ0bPtOJY0fyFtn2L2lckqpDGAr2Qb4Dog7t/zM7mY4z//xpKsvin0OV28pztxXeN076T1NvsyZMc6EQ1VBpPM9dArKkXD3TYhsEIRMI3lfljXJThvgmhIfjdyMZQAru3fnmYXhMZ9GxvdmrUg7wJAd8w197J91nl9aZwy8xCiK+AS6g6C3VPMqLcZZmJ8PwhME2LAF8wTFx5Ax3OLCBThteDhB49KS9cxcop+zCsIc4jKX4rGsV9a9ZQj9vKMejs6qYxzK6CkBv4Upo4GNuLlm14NTYPLX3ZoCk+yyWkimL3IF6P4TfmOGkfNZg74nWk5AqDkfElWZ30N41lFdsgsr4jLzQ0dNki+XyhrXxLZk36ObVjr68B9I8bN7XQQ/3ciVSWcJUuWK2IO86sJWgGUTWVPwSSV9p/7ypsgYbsOunExdNWNSN2brO098OD1vc9kx0BAqZW4TRKmjzvUdFsCDHd+dmEoDkZDF1CSM6bVuTj/po8KdBgFz2r4nI8eumUEDKbDr6jqjP8GynUGDsYBD9NwHskudUgVperTJE9UAIHFnBpw6et9sKL/HC+TvHQ9SVmjwkVdLcZxp4kelQcQQ4LKW7E0Sz9nHLMZ+vKIF9HT6jZKh4PJQyHCeIhzWHMkd00kn9HpTId0HiXE6WvAtdQA/iUpnMeoV8bePJa0BnGXfeRwRza9q66CRmL3QnLysQqsqEfWMINN0Jky8dFaKc1hV9Nvc4K+6MzXM6wke1Cd3VPFnul1bVBuSrU7Awv5nlMZ6GVkrN0X6aF8XHVj6J2o7lAa5Yq8Gm/E703329OIbq97y/2hymRt2e4SVx34/u/O1/So3c0NdnheboWuSFhuy/a4aYFjdcfWWFbF2y0HGcDdJtICKidzSyuR1Irjf0dw7d2ql45RJcGzhnCOAVoGNyoBCd/3XZ5cJNw0pWdCfkcW24Bq++8aVF+NSpW+QN1FEWNJQPfhOq9n3Npzc1pmf0sWSW6oZ+L6J4U5CiTJEIsBqZbYQctwmxE3W2etY2cl4JFMaKybnaEWbMljOFAP3027vLmpTV8NiyHaHV9MZLeWuswjyOwJcWnTkeNGABEYpgRpxYocFrWpPN01f15UUBGvSiVyhkfxUpRoj1viNOFBVDlNSCV2XZaND08V2idww4xy+grqtbS2K421rduX2DQ7SuKt7sovCuis+N2U9EQOZMtyn0I6Aw61G/RNCQu83rolQ07x3GsabWrsuEznPTwvqdkRfE2IGRdyY8FxIm21Z//GdWpSbWwyj+oBxMxubc4LSOyFDQxbk9rZbZlErIc5XFbumGbUFdzlbbol8fgtAayV6W8wMgEFNl1oEmzwLTHeMUhqm/zKc7O1SYV7lPFhiPK+yV/onK8rzuuIhbG3ZeWx9yngXFZH06EwGd2G2WZBIOwwbYTy1ygvMb+cgBuBRKN0pmkPX+Eh5Rs1IcnmGA4GiI69TKSDGLt/Rf8bWUJ5tmFbhWxTGTv5IWCWhbNJLVxtTh6nC846Vm7lEybGAwpWTEnWlnOFpiiMdd2rl50M8EkyTwklA9g32veMVYexKnmfqraLGNU4tb5UJqBwgmSDnXpo6SlA4wwnUFDaVhblzSfEO8ifb1/j15vFq7KnSlPQMnpcCAw0puR2fUpSbeaNx9xoo3/b2c14jM5LV7KwMMW+9y2nCba4GE4ajSkyQTREWqDMEQPcM8IKYsuDMAZHx/hAE13XZq8spj4eGz5aagsBodgGdfw6JqRohQ8BW5Ekm5nyFbQ9+2rh0WOrMGRL53C94v8Onjfkbkju1BzBRwFdlljhTiOy9btmhp6ykn8xVwATlsejtPbvO8JuXsBsfMLxlPTCcpvpj/q54nXJ0+klItQmHdZUfI+jSLkgl3CLFV9dDvlXTebhXIWuKYcTAAqfoS0Pvr+jaVvGwj0WwdGP3nID+y6bVjR09p0LfPRov+FN7NC4kC2pLXdbOBAt2ArG5gtHVrdWlWGZ8PfPN0b8SFy8Ovp0Qx9+NQQ4dc1o+GeUNbmZBGutBXbFtseH8wna1/OrMOO32yfvXpXTuvwoZQuHjGirTXWWmoOxKmd3BB7PdOLh8nHFB/1XiA4YDObVWT+eeJjA+UqRXib5cu3a8wC6Zaotl1FKacUMZTpiFFSstBpqvajIoGp80RHM+hwLicLp4Wuynf3ZwBodJkZj13uwxoh4QJEK59957IljXuqjO0hozTq4W0IgVJrYJmFM2/OF1uW7FsNejYfZX/U6EcyDZRN1SPqr1BwbEgNkQ6HbvxMTMQojlaCkZrWe0UWFW9yDDHKK0E5hmdKE2RARP5ccQwWYEaY6bsafmBnk0Usn5cNmrTHJ8Qigcau0CxGnASN0oDTNfqZXBHZZQ5Z1WWcMv/iM/SiO2122efH56wtCWMQpLnvmQ10qE2OYEUNHE6c0whKAB7E4Ehg9yj8aIypywP//vwznVRFvrOcEnzLdC+esdXmIGTA8guEkjNcE8dozmNCUGfAF9/M1O05Wy9IXUlBHUILYDyzS+7OJ1pXmy2E2QSkt/pLwKqxK9bRGrBDut1mGWWXOpNk09xGo/ay5jnCq7Pda4E4H6rT0Q8qs5kRSL5YS8skMrbQ+SyQd5NLwpjYtFCOwYwQHlD6RQSKu90m0nMb4VNt/6U0qZa17js1OxKDzidCvUJSjILn7/yZEE0pEfUDYlQP9GnFLUPQilRkkSs+H1o/cI4cf3RYxplH00WGC03M4zd1B8TcOHNepk0fawWsMuJv7+LgI97B09DytjvE0eH1521K/lQ/bydLUxk2PsCidJxG5j560ZvFr9mtHl+ddLnvNu9bW2pXJVPpBqDPFzKIpRBvsktJA3LkNrwvEtA0ftfKFOOUPh8n2eXQV8gb5gWfp53QaWKKrPD6naW1L7zeyCyz6VpgTJ+H+jtDvfqaVN5fpyMmDM/mA7IubA68g2GK8irYO3gurRAuV9vXyt25t+36SzZzcWAodC2lutERdoYJCXwM/bGHD2W/T1AyzkBb6584Cs2SHq87+a/5+rXgegp68s+9CzLj8ist8wNUHUkUxh9MJMhzOOro/xKHCYts8ksWxRP4jAT18r0vjpi10/NpBA9TghNId2AnIlSXaF+rDs/DbtjPLXS1eTt26szoRNbHFsR1FyVRoH9puV0gCCXgTd0grkOBsrP5XjTYc1QWDAGAu+95KXFifZ7sKbp2+IOF1FbaJPWLAlQ/esQu7x/maVyukcKit9CyBwPynF68JIpaCW4Kl6thAS1h29kxUdBNvyIJafetau+p4G93VbaX0UFBD00WUnj0FXIzMtRQDX5751Egoj2kembCtDNkhSRiTe2vT4w59hstsyppFjibul3zyMu2H5+xUR677P4dzJx7N9twQ2vFluoQZI5eFnQ2cjEEMj+08//EgO7BUsXyDPYYKvh16GNM3Kvu/41h/DrL9GTiabRsQAxY+1BlQyX/iVgV+rt/wVXDnSdLwOowEu+lynOhHx9KG/F7wj9OXlofZaFbpBsy0MFASTLua5UgCg75dEWh8F697eWmMMFdy66SL5S8ZDSySp7ChSxGOmEe9y7FRfdBZPhCv+NsTiAGOPDMM4VSZNUZn4xT3bXJ7fZ/la6bDk/aVhtcwzY9ir7bjhShV/K1PwrJSe67AN3dViTdnClqXDVm3x4Y/EIeszr1ve5jEtbzKUVRDyGPNCjJw7Y2FaL6FaXccBonezU6VwJP57LXUvFu1/iKZc12wU/+3n04seyd0s2yyqklKwhYpXLLh7ipn1ATwVcWFbFB9O+jZTZiVaUxGmiLxF+DHpaZwJFB/cMub1SSqxaMI1C1p5k1CM2VEXjwvphw64/+36it2QtvhzOjVK8TgA82SKqSsQ3FkwqRw/lsNlgPheQ56ix1qXwh3Zz/Kr5vG+7aPskPVRmZMdNeh9rcNXJKcS+zBcjkCeMXkVZdlI4NhH/CP3az9b5mexWytE77bUdfX45+Tpy4Z7UhPjIXRAaiYTAfu3F69JnGXq/nKcVwFLQ6jqBL86skAhweKnPeNeXMdGKaVbqKr5UP+yQvZdqMgXizhzk0p4uTDMnKPYsLe56G6y8FEfubMzupgaKtN01GYmQrbcMoARMFrA9xOzww2BlaOUpCjxDWFtrKQjynbt+4YYdQJzg07GhJ6R9AE33qIjCn2P+SRGLR6CazjtQ/lYmlRfw7al7Md6Utb/D/kGGg5ydLdUT1nPMPB73iyEer2e7ivlQS6guQyvCiOG0sNN47qlb/2Qwt5OJZp0U4oJ+AgNzNuc2gCA5OWFmJkM0dJCfE9ahp3lRwpuI8aF2ry5Hf6xpdym9G6ojPXT/VcfwqISJVpCngWaEpHNyHOIAqHpA5C9NnpWOdyWwVNNZHvDyucE9FTHYqugdPKrpsHlY2wmJR5l+FeiirafzC9hUIUU5ps7Gm4cz+v3rYIYPfFe8xcAmh1qBOooR805VOCn287BDzN/PaMDJWYpB7HwKRPWWb9/aCH7MuM8OvaNvPBPbBo1/RYpFijWZ9wD5fU/L5l9cVJjihjUlXXCDHVWTI8/onNjm7HHAnuvwzpEA1ZeFjjzjhOBU8iqF4seh+kEgIJd9B5fFDfCSWWXD3uIy6Omx4J2feQT2bs3rltYhKQ3VbBwTIR1fzFjGiNGAag2VM66BNTioROleLqq6K/yItgTI7Paw7ZBZtr1+NvMBbz+gmsgQe3HcabqkLsMNIvMylxnTU/HApf2LbnwGzLfqLI5GeRhbHX+9W61reYK2s395VjA4j2QTZ8DIidpuX9bVq14WhnfDCBq59X5C7fHhv7Wb0OXdtxu5oSIzko4HE+q8LNzBhpxBQS0FZt/Sne7vleEus79vvkoWqsJERYk7tRpJObhJE78CTPp3Y30TETQ0vol0gRN64sGVJ/RWQrr2vHSAq05MXAYSUJmKOU7u26tZ7eKlGee6mTGG831x1p4PGoMQknEkcsRlMrQEtvd3h5l8NF5/JMA26rKwq9xPSioV4wxctKhxLRppLUbfoIVfiHos1AM/1IWZsxTCjrvFBtN7o4bPaHQmM0cDYoFePOtxorKe6vluZ7e2BbzjKaTeBs8avY7bELyQqwVq5QUirGzc6tCLU5bwQFGQt4JevPk2Gs4mEhkzOSt/gZUD44dSsi9YHTuKn44OqECOltkhWkwd/By9pu8pyX/tA8se2VN35H3YAkyFa5mBVM7aDO0MaHpO6ng63tOohnZ6uVRJN7U6HEB7otw3nz7anCZV/M7XEQDfVePmztIdX3Fo/1YxGnycIh7DxpxRIa2T1tIvslnJiJrHB7CJ7otKiX6DyWAQfIeFjc4MP4yuAWPzjQrE3x46kMH8Uxq82PHHEsxopWpN0Yqa7Fk+W74UvknnOPOctQAMBzF0DmLP8xeGBp2o3r5+uyFlFVt2Y0aI1w6p0AyTpRBL3FIFZUnNEqaGxjylj05olYFWeBx0cZlOeQqYlUVZHCG7ILxNLoElb6mK/hSoLuUa43JXAh/znk8twxXKd4lY9UxDX7AG0ybJrgVZYM37QdLFpkzqkYPBy7tl6MWqifqO3XMJi3SAlqAsZxEFiuxZHL8GYneEZbT+tCGb3EB/bFBXZj1H/JhY79HX/8Bsbd9bigusVMfMxfDvvFy+HeyVBMlIaDFnOHxB9BM0xjl8/0bI39BQrnuQTGU2VfzHl1bnIeWqyFS7Stt2TuvWjvt+GFssrBLQMpjpNCHfJlIByYbnbfa5C262LlZMdgBI9YrdisZmf8Jl7s0E70YER1BigTRxTYVdagPAgAyHQsXN7/EdnaO0+1h9pb8ChPc7Ajwdkuck3EIZF5byc3v6IRmFajao00Pik7gi0+3o7iCxTrxR1S3UvTFCIhqbXrGXzeJ5DD8TV9C4NoFWytJxJ7sxlA50u2tSHpiF5m6bJo382us2JrI2zZq1BOHzsmrwRnZ3NFZUr0PG+bxUfS2lCZP6C3O9mummOLctBZuoMMi7pIosXkOoahD1zojwRTuMYpvbDaabVFdqLr4NVnwzt4E+YZlUd/LTMXFAHQGVTPz/fASgQGz2ldngylJRZHFrclMriWgEFaTkI1xpea2WNM9x8sfDTKex02a8BuVnu5mQ/lP0CJ57CkZ2/X0ThFkgb77WTRUVJgEyAJqSaWtUFNtczKK93FueFdS7Tc7mIKrDBl7KuiGceQb/gWWlipb+1kzoztJyc3saySMupn8jQfGNkPmAqKNUClLJr3PbCuNqQ8LtPfZ9Lhrh/B/fWghO60VqH7nDlmqL4pClRtkKdUXYTyoGof1P/GUzZX+H+fxU4ZrUCkoYiX06AhNlS49f1wmyya2bx/UFtX4qDQRspCkOd19nadZpvVbLA5cUx/Z8sgSYgS7S1AhoUA3dSDIVjtOWokiJrgTT9HOqWHv9cQlGHBBXbgz5fopY03EK8cAfsNp6BvqmZCkoHuwZVwTBCynANcsq27fD0iFM+K0DfFh5na3Z5qowCcnUysOOp3qT/HiJQFs7cUCP6RcMcYiaLG1Ii6bM2/7ZPBiOuI3fkWY+E1rL2QUsCb3LLuTXgT4xAj2gkpoBYoKIQ57fgeSLUAMNhFzsvhM3QtaMk87WOjiHX1Za5ullXl8fVknd44LS5FZs/vqOpJ38xlYC+JDMs2RvwKOQpYaV1QH97SKUyZ/3U8lOFkR+BwH9o7r/oNd7P/NluY6CCToKtInNRzlxWwxAcOB78ywmdSCrdT2Ckgp56R4LYuMfzZwDjNireSaJuTEabZ+jmdywuCYVpmE0MJdRf0nAFKq/AWMVb0O6fxQxVzVbUsjdZOtXObwk73A9tuE98LzFW9ckT6RHzlpBTz9nJNm6E1ZxuydUfug4ScYFRT+mv0qaldYZiXCfs2/nL3T+jYsbKMAI0xiqlImgu0C14RaoFxdRR5QE4oOU4MyhKTFA1T781jWxCLG7OuyTiOGQ7dnuuEUPnnBayt4gQT3VED3sG+jcTQmd4dSIOeGUZyrTd/QlRoxf0Gdm97jqwryGVOHHKcq9ad0NJOFSCY3Po4e9Fl7i81yn2T2rroTWA3cj1ZlKNhDhgZQxSmUJ+Q2PyMh3QX+vOgGJh1m875yxEhETSzRI8CfQ+f66RmjOhMhYzUBbOXdnnjsggXm9/coQOMp8d0NuehaeOe6KcVA8333275dzTC12RPNIj16cX9rKL6afX/P2Ha3arCt2UjJDupPTnTw1X0hzB6J7z1chxLDz6QLUt5tf/i0no7VEfUGrAVfOj2ZwDrnCFq/xdZ5q1/8kpbD97QmLWKXQnc9DnHg935UMJ4eTepdlh7J57EXFCWtoTtod59r16DbShac0zd+MjQeut4pCX06LZDlCjBKS3xIYBwQfu5BZ84rZKQYq8SCR6twDLst7a249MX8hqzz8V8QxkKACdDNs5iZEEL6Gim3yQNE2hPIQxlg46r7yhhsTkIJ+gnKx/9seWyRgdnjnmygr/JG+POTmfuqICFFKoxOd3wwSKORGzE8Z1A5+b1i5rYjdaN717WAoaZBoFmbi7mHvkbgeCa2u/svBgaxP3jbgqLlsAAAsjvaMMEZ3oLmhiySYbQUWvlG74+NvMELR4lJmD8hfAlue5PDcyrWWDrBsnWiZQFhFJHVOfS35T+oE50oBZbbyjr8IIwCBJSsEBjQXPJkxZKTO4TfSdlSQu6L+el2XTHQ4cXWxWtQSRwkGXPNof+mCIU2Hckwj84KhIf1pjan4vUnV6h2F7Vja0OlRW3BbZONFJ1TvZg/hupxHkRSC6742IDckeQ5R1XaOrno9Z4dKcP8nWDpiY3CmR+pMN7rDVNM1juaoJl6IdMWGCSTB7XqKJgmOTlESc2195JkXbM90DTuJixuczyRSQ1LJ5bnWL8hoqzYr4jfzD6edhwbrQ/FjqBykEflChBKHXbgfibqb/AyftQG45Pv4FUbSSNx3FpD85Rat2iF6Y79zzxTrZYTfn5pNSjqRbi5/V6cssdDeDBOWsACilIadpS9QsRbqzu7d6JUGc3uT6tgqb0ahPjvvmYawsXfHhibykPPrF1gu1KYDOAe3Z4grsVJnAc8MBRhbAvxhtkXfvS7c60Qqf5D6XssYHyMnPXw6sFRU6bD2uy31q5dHzvY7KMGalHeg4eZ+sooQlSqhJ926MCJLd/bs+ucb9XCyYAKs2wAt5/TCDUHiZTZcYAVS9Ag6jrFbuGL0uEXDXIEj3ehD+P7EeNId2OUmkCC6O/o6RVYPVSCfkZFjYXpzY1kXf7sZRu6ylraWEFfqQwf32ReKpPM4m22fv8gdjFXGMytV7b7hGz/z8p7WPEDBqK/xNyMM80aNRg8Zyf6u8O49vTIZpPkf9B+Fc9081Laj9vfQh/+9mrtjfcwhNTh0CVES3v9RFiVREbbJYmf0SXuhzpc+/7/gPtUytT6K5xttwcBXgGlJnxvDVlPO1IWd0+VbJTh2KTELrWtX5PHeOJ+9KWQ4GzTS4w47ZVftTesGwv7Y2Hp/KAL2dCOYv8I5mjMM6kcLunEeuxaEuKquJuG3kyeDhyYnmEEJ8JeNdUBElTeH5qUe2G2ZjpAnIE1oOLEUDiAViLPPoThLhR12WJwQIZsUMYDJ7hlk8Rs4MbCDe+buIuyxqtAD1rNr5OeMrEf+YxdHqMzL82HLI6C2pBJG+i23iBM2GMoNjp6a+eE5POUGmxn2qt6lq32Cz0oFns6Jqo6YL3HL4M88C7Py76NB56PKcbN2PfmnmdWwOc7gL7cFww6mEc1rzKZ2KXIewf9Sf2H0B5lhUNClC3j0nlRdyt88WyVo5BNcykNOUz17q8sF3KmFWzaU9RfSZ2bGY4QJTI20lTnl73jCOIHt2dQcvuO29PYf/E/JlPY1HK6qKOuAEWvGkWCvzWpSHsRhDoePLzWnXJzzBlhRxir+GbdOH2krm6NG0nWDwxYxQD3kborwZUOGTXPrRricl1YJYu7G1nJTH3sctfz13B7tUMlufdaF4frPIy6j10YzbqLWxw6givFVEKstjxxw2iooEtbxhaubEVb3eXELzooPQlVXtQ4McoaFO55gqWPIvPM8uX7EUh2ZzzN1paSta61pg4EGuIrYUTdTC6/np75QQdvMoeTeZFbY40HvYaCZa5sQd20tpNUjlGKwJoqm9+dr8iA9RjDdoN4jtzgiZ2E8Qc50t3x98w9vVBlwwZyMtaT5NAwwIHvSbwUjIMxwVYRn6xZN0e3xdEkpZvC7zi0tAGqpY/PgbU2x1BnRvPYWY/43l2lCmuPIpZU+qFsLD+COgBqEveLrGwATIB8k99ewRdc3Rt4C3Y+xuX1brjQk/LH+BzdKFbjuLJ7mF4/dEzEBDULRyMGs37hLk06ZsT7Id1eh+lg0OUzSLfBltRCA1XBJDUQj7nEw1xNKXwOoaVWwdr+sXKAnG982ONpCJZAVYqz4/iRsSCfFSv9bn2ieO9wMrATRicbfBsQQCKdjwXIA3rY8razuYJ7rKxxeD23imn8/gq53NfLkyo7BtF6jYZmBNEImeiKfy/e3poNY57aqsy0EylJtQ2u9OyPHRCA/073iIBO+2w66jSLZsE7jErHQvAwf9yhwHJiaCApBDrSJT8DcUPj+iHoxs3CEeufxPqstkdG4CCpRAEvGfNeVwcA/BrLNajRh6wqxz35a3DNtUwy/aKX6VzdVMHFek6uaT5Edn/iZnQP+LhKkDE04LjyG5NqtND0AdCeOSC58Vijb3SkPayfjQ1HiWydaZpCWC6qVPHo/yLfyGY51nX8/ooGFIx4S3+nS/uGC43WZ7BtWRJfoANVm/2bduRVJSYs2oO/J6XGWJuEleSgla+rOr9vCvMOxgsxs7idgT+TfeZq5CC1orjExGd5iM+QdkPb8/EhLjuh0QCBC34LDU09srxli2xt+pqJ8qdSAPT48Roi9CSWkAMGKgV05VCL3tL5abC7rd69HhXF40uYwFZA8DzJ0wUJ5mAvSa3YEreAvDZwQJkXYEH80HsOUH03nlZMyhBSM/S3T8Q9RajfrZD+lxUxE+tPXAjth9JpuCIqakYnCa62Y5raw7etN06L/5Ycwrcj/o2u4+irvjKI0Y1JeClhDwJ1IPWgpyuvZeNq14EKqBJmASnOpWio3hNo1lwm8Yb6ohyXHcPPQwVsvVsfFeE+cyXeM1IYyHDLBvjm27zwvCOxK1ZcokB6iw0Xw3d86MShODetfmqGdbaczVAq1P9mbWEJ+pQ9ERT2FrrNLbAwB8gj4yEs8LvGaVcq27+TAn05jraYg2v7JOCwn1Tb+/kCNasWKdKmqE+FYGZSZdR0HPcX6XiwFwhVB4tqW3pRkQIcmFaoSDIKo5lSoFeX7iHpSEujzNDCTGjciN+ZXG/LokklWSDgy/t5RjKTYfvue4Yv7cD0tMNe6TMO3EG5Fs54NtvrdtMIQlLmuLXZCUgtkS0IcaF95YdRZu2zgD1ZtvCtxQfZaJ81BnvdgaXUnF8/DRYvADtJJOgPWHdRVkI613SnZq6NXkIRoFaA3+cgnoBTqjo/SgyOWt18ZZq+40odw8M4KqgWARtMH3yX+EA/ntVsdOkDYTLSF3lqJ73j9egsz1G9oX1hIjELfbfUuuoyIoO3tMNtPeoK21nfocj2smRGzsIpYowFCg6Ks9VucIReEjeOVRGJzzSrsCFj/ehDXAQ6e6RBB+MlEeNjXR7u80zG2VoSFdT2Vaz095elyhd8h+MRX7anF10KOXmWKkp8iXslf01Mi+LFD7xqwmNq9br5NfZJnIub0UkrcLnhX49F7X7bV3WAJsG8E+V1EgSu2dPJhFcXcLc5K+el6ZJX5g16MWyJHvIaPABJt7AilMH2JbsyqIRmIVAqJNhj27fbx/pOv/Dwo2gPYuHBGd9gkQo6n2D4UrsPUPmNcfvZi6Pw+F023Uz+/iFFG825iq1Ial7LXhK+P2Q6I3HZL92iR3Vng/A3IJfW/QBBtPmwkk/7V7Tyv2dEjFZ7EROCkuxdduupMHAOFc22yVkhA5imzVKruo8cng3wH5Zm6QK8ZM28C0+ooq3OdfrEC5DKD0MG8gUN5xvQUHy+8II4d2R6tJ3yPCZj/4PkJT+VQvBvXgq+RPulS6cvPYIWtr0+1KBBNjqk0wGGMJCoGN2/gupjck5vdMnd+jgkaezeSyNYeF5ZMsJ+IIEa7pow/Y7WD3GA8LqBW8exa9BGbzqJV4S+70qKyOfc4XLzegJ1LBgpNu26HTWRqktTwBaBmPa4Ji+MDfdA2hjErFy28fPmQyR9QimsyLnb8zjh1Gq+/fIKxnxCIiaybZRYVEYJMKYJ+66Syyhyov8X5UzMLrePYm2HqaURiPw3JYz4a14IzeEjV1nCcNSSlREJIJT1lddEc/dNR8YHNXndtjwPUDnWVKdE0m28BAU5t2wOQXyM8HMQFrc0ytCeyS7CRHDiZT9Y5yf/7xJStrDRLjl1wwgHxrrUAdZRICtyYExmtqm8yVti7U4ix0nHsWKZYv2K0lpwjIuoReDhId8WjpOtT+SnB/bdpqhny2JgHjnyt5iWlQeLWXtvtc/eo+9KtbAUIlQy4DBAJSV0Ghq6+/jDgtt1f+2VYpCChw3Gs/M1f3bKFCQFRSAEURGg1LlAGAi5uFpb///VHxx3l/vp5N4CTN5mTbhy+Sb4BoFeIjdrmiLBZCbFVR6W2oGV1VXnFGp44wmbIlGrSs0aLHzc6BkhCHkz43IrABCYLktsepljuZpu1PqPprWKdbHDB6XoYV0PvK3Xg0KSrayl7gq5rEQlKHpj23n6+zAo9Iij9JSGlKdZbdJSEi3APt2ZhOXsUvRLv0uIyHtd64oIrB2LE4O9aLHrh/NnTb3K1Ds6YpiNhaRUYytPq7m9BTzfd3iUjLaPdGTxVoqA/flVjl5YbPJnIcFzkplpKsJhEETN48xz0jEUb10E7DCkr0Fdzla0VgW84gq9wX4t5RCb0IJr0B9Id3F1qjLMadZx8NlKJ34KwnEF3tMTiVZ0RH5njmDynjJ7rvcGcdGAm1pZ/TWJAhZZb+HGz03aO2sxiG0/n9cM3bhQs6s/1CR7K6ty/R1vAX0z4u5o2m2D7r3DAFMCZDoEQWjyOb3bSrDEDOd2Snw+orshZGdrwrr/EPlNHpGqVs1KDW/ovKr0Jgt4AGBXl5HwPi/C0FXgvpKGsp++EIwaF+MDrJm5JnDyphBBLCiTztvdiHYwXn90R85Gu/Dm24MDAIZsAdIjvtSTtJWtGl2kwmROXDjt1tzsXuW2nLTZrTOlqF1EBPIjnx6wvvmGi0zkuL7ZYhrgGpPClJgsXjCd10vNFY2DopBzpirp9NxPnsbujGsd5qS5VGWqh9n4lAwBM2tCSecQbzT/xP4G3UXcHmEcCkn7Sc5Go6VgCVSawdqU/qprQ7BH3W6chVG2LEc738IvRds+ejUmgwrL5dUYrwoYsm0v6rh6mQlhoPcIykRaibWh2VXce4xMmGDuwvY24X7sucnvCeo0n2MCkeWH0XTuuL2WDYbNHIo2+2ru/8KenB7n3ROD0aj6UW3/FgML4nFymaSSH76MJbLk9n8xcMLSArt8JHpT36gyRF++Hgq1CBdqcSXpuyPFe5D0jY2aLcIeGcX1gOIZSr4s/PxgHRXJ+6TlMKyXG0AeZYRzFCfLtP4Sw5mH2A6jkvDMA0l14EPQbw+HoQ2zcr/wT6e0qbEipHMxh5BxXT/SNxW5U2/GvCwqvhdKwyfSq60+UZuogRbl0KA8pzCPfK+DRqabJU0qqXUykTTUerpiaXuYKrze3qCuKlip5ITZnsDEIzVF/duHEVQMCtECnqOUE/0V2m9jeDfGEqFKL4zhP6TZYqThvMZKfiVynUTzdMHaaasNYO9PpiKDV2UJKrC9Wg2IlIlGxDaRCNp+J/t77C+DyCg5ZgsiBrdtp9q1bD0jolyUIfYw6wFsnUX1YRmtw9LbFk54Hd9t+Rk9ZeSsDq0uuMZ/U57xYiAzROEZ/l26pjIj3cRslC3qmq2e7LMSnvPDtHTWG0shp13fIUVerBZXasVFJJexpYT7BxhTyOCgWWfDvegXctY+jB1HOW/XceCcXvFcnLq1Dy27kMxisIJc4M0TtwaSixiDTEJC3taiis4dCQKkpnQxLgeNko+/TIBDP5q4dTzmd2hMxaKtBNox4NXJV/MmzjBjb8lx1fROwV4AIW/QP4RTGheNCtUqDdAVQl4busQUbUely1/dloBEEb9YTRDelTeqhWhAm2e/btlShOff2GwLBwGifPDf0v9g/hw4KyRovgROP0r3DSCVqUeKMFOsu62wKy8i0YOcssidez5PH4tAfUaSLeArESG5vWirsbGw0ob0VUZ8Vsn0e7hKDmftP3zZqKg/+ObF9ofZCICI1wa2OgYP7e/HAVlvhgrUoCLRkz2OdINWkW/Pz7KkoVCrogkP2l/nIAg4+H6qlabcDBryFBb5UnC2mCUaAxK+upWeNyPH2KJS+SGIiTOnzWtQj2mHOuzHskr2TkgTXq/BGxDqw2KUC2Lsh/m9Qph7d1ero+GYS4HN9DiGXIl7ndPyuF/PDdmkZkri3lGTRJHfJdoYAsmKi1TLPwavBWshjEVk6CG9tSmq3bgHFfSlpNaq51rFFRVNVkKktGmV6xPguepV4NsLsbQKKrePvcZZCgusXaM/uGCrZqlSZCKEJNr57nBGohs89DLoaOMNZn67udVsqXnJOwzi5grPc67BX5w6ll7Y6tMtlrR7DOpVwCf5m6m73NqPcX7Kp3pcocOitcslY0lzSHDUsSqqHQiKORuMyjOHLZ5mKAQqaG0ceg3wDxBwd/WmK/1VZNTlHBWaXw1oU4DVQgpGUKpnua4boWvd1YvcLjaF9VBK5o8QRbCLb5ZBSXQwDpylRWoo9VQGm5LHV9N8i95L4hQ5X+PYC22D/Uwa7wIzJKG9WO18X3WNIN6HI6rpJjuHMiUm3Z1qXkS2bzzjZNa0OSAwpKE5VwXn+qkTQqgtLVDk30qo7ykKVBZs8BMykncb2v50DGqlb0q0yuss1Ff28yZY6rTWXJqkP8G5Zb5HCC5p3GVHbZuoq6JtVwzWJk9UBuITKai3LGxnY3/4szG8A0E2XBIaJ3J8EAy1Sih5F20vJt06sXhLYSFqYLzZdHsHfS6MpOd+VjHtbsnBGWIuqUABmmozIZQaLDUXfq3HD7IWpm/56wh00bztQWFTyVLhvPChTEoF/Fih67+Ogh6I3qzJYovxo3sj0HD+OwuSBU8+N+tgDPVE9dd6u1HgLQPpqxdbNcNalwzTwOmx0foY6BJHxuL7/PXWxbrJyrpQEz9WZlOXkvnCsya+UMZwOf4hMGY6VJoa9qUkSq/DK7P/X0ywHUAfRuAc+R45JasIBdSacsToNcLmJRPjB5l1v42Es0bXdQHH8M2/Z8dv5hgnBPod6WHg7Kl36tjGUq8UAuChcXEwuHjej3EIrxzNs/crZtPhUPm2h9ysmCPpz2OqlT8/oX2GJx/6rRONxCjnZNKmA2Esw3aXp1i9DfqIdyIejZVXmGxidAMrvJpK5AWfOLxv4Al/NVM/gXa2BEF7lXiaJ4/noENJ/8nF4RnGv7yJfAZIliu7onMmtdy6dttIf6MistRAPWCImWykV9Pyyrc9JARzwIDw/NvIyCGNmu24fkhWSNacCdzACIETLqzyqgsWFJ8IHoff2prPnakF884dhrCQiFSYCOcLNDZ6hPZbS3w6IHElekbEneUk6LuyzqHJSIua/vZhBfEFSafWBhmq2DW8L4w5RRPKVQ6ISDjp/d0odtkl4uGA4wo1aexKUYfNfV1KfacchWUmH2X1+s+2jpdudYUClG+SJb9m4UK9hkqdCF2KUnLIrCNak4VMX37bGeBtFwau904VkMpOLn8F41J6M0TZLBovLlbNUhTIsrncj5vUA01ghwUTxVwk8pBuApog+518OalJZ2qv63SuG8qefDBJraHJ4gWpueJd+9rekmGUS7RyT0NF8J8Fh53MAWQFhSCqyPvA5/Kwl0W2z31NJXFylpMLjVXpJjxgOqp38QLoHnGum6vf9wVl2EZkntzAquCua34z9qB8Fj4t0OgnhfG8sLuF9Ep3BKWxAUBm7s6fM4rdn71lDKxTe2rjXu9xT2fF6pWatK7rZ7B6wCSzkjSNCcU4O+6WsxlbQVzhZoVGRTR7U0y8P6o6h1dhic+r2YrG/sL8GG1la3/GFL9/nXvzmCFO4kDMWCBV2K7LW9FG5Iavtg9xQ8a1Nd+j/hSElC9+Gx9TkChpTLZrMo5+aiRRcOg/IRj6KDVls9nU7Pm9XjBwJg+KQvddqDFxoNj03EuFnEroWYCSOwOh0qoepX/ez7VjkOYu7YKTUwWv/4RnfdgFXFvUV3CTvKcHjBoZdiqUW0WnSX4BuZfZi2u4X2Us+AVH8ip8RfjaLsHy72FAdZ1fgKo38DFVse4hHDa/4zNVYdTP95eeqXywvADmihHjphWz+8IJJZ4sqOzYW4uO684Xjhli9d9hJWpplPMcyQ5GVJFGc5eAaJcyWFja3cwK3QvPqsK7ECd/REipuqDiwGqhNnvuBGOBW2+YNXEDXkpnv40b10abYZFZ/raNZbTG6kPk7w/OyhKxVeXdGCsafYCHM7T61AFBgmNRLT6RYdw7Vi/uq3w10KOpBZtbyKuTM50iKxyiVAA38Xm3o3QCm11TBi4hTfDi+GfoErDv2oxtqjxrv5pfoHpIzPE6jWs6klwiWvWQYsh+2U0WXl0Cn3UonSWyiisNZDup0oKZ30VT7j+R5qlcaPFYXjlVw/nQACrpg4jlhjJXQOVbL+nQCTvKH6i/5vic5YnJsKWDGO5TJIcqT/lhl8izQ9z+2eCSz9en9XTjpTCvfoB3NZ2fgbqpsoTuy6Ps7Q1Sh8I3poR4IHxNiNRgPewOwJg1CNmI+QGfPyX9aUr4JG3edaGS5y2q5C3BBKd2zwTNNvx/XPY2JyPvYtoWk0VnI7SDW33uZoVgQZdl9nMk6TPWe9ymzKcPJv1X3RcecBsdveNtKMR4YXO/2bT2dSLRtSSNZ4B/imzhzVgtxq7b8Bq7FLV8MoivGdzo9nPOR0R7gVaddr7CWaDAWjReC9B6v8ElUjo46ppF0cB4z9CmA1KiWluqDifbLKTjCT50e0PS3n4W95ZKwx2K1++REkyFt2nduBs3BtekO+cucG0UbErIZuxSS5aunggi70HgbNrey57x7Y4G1bPeGlu4blfBsSdeJQZwQdgzI/T6m+6UnuVgJkCbdsvEyTSpRXY8mm4jGC904tSgo/YHiaY0xLsf4y0xU0cUary61NhFGBtdtzYv6KXtTKVdC1z7oYj8115SX4LR6cci1VIkrWeMIWB8LSGAfNB9HbZsoSpIr2/YdP6LMAqwcvDuK2s1LVliUCa3JQQuNMevxiYA7HAlGjlfy5F3NzgtlTM12o2agVgrsP/NTlqKnWggHpkPEQuWqLssFPocVPyutuYx6pQDK4xFdZoXLYWkKN8PlrVfKFjGCESe5EqaGslwM2TClfNBk4VKg9f0L9qusUF3trATdOgvoq4X4O9QzUR3URcTTPkS1/tc7uJa3M/dkmwI6pQjhL9AP3jiBZnOWxR+K/pEzJZPcl1DHGf+Xu1MknbslS6lyRsug4l0e2B305xV9ClVVswiM8evmcRFnJG24RX7GfEGFb4NF8i/cmVOAumcdGhYbtGkm/M9yGM60H3B8iRPUooWM/vNCpHVthVnv91lPcDaLfoOxVsCW8WBLFhjt4uPERI17Se0nu3SY4tUtR5Ym47Nu3SiFXGEBXoP+JgjHKaWqMDVpu0y4gHI1elpfJZAykCT4W7RND9Yj7nibglz2AE7z22n1Ow4YtG9dmHueYiTQ4L7iIQHbjPQ0JctDLnVfzZTkY+41WbeKNaO1n/eg4kTkwG3VvJTOxNtvvEBbZt/E/RTBwmdsyFokz3z7zebeilXB9k7MQKTdEy3Wdupys1A4i9HiW6d+zjvkhIa2N1j+vP2JgLgWybRCXCPuN+a0GXuKReD0m3+AGizhaqL+tPiIr6XdPBlZLVl8W63BNP63iJF0q5pbTywsmxVFwgpeQjwJXiUCAtzbR06Wx/XcxPoX4LpS08FLZqOQZ+wHt1PY42AcqOyGZa8LWsJxdn5zG5scfZg9qBKf6nxGXsOssefMQZG94KVEyXMRju15OE93/Wxqg4JSmhnOZUA28M7gbidkf4RxME/11JDLTg8OnSVgoLsJcvMu6wAEVg+qXKAqTJ8K/9IyIRKpfv6hgTWwnLOc//R+OXVxXTyD747bOjTQP3Jrq3Eow2fV5t0Vyyj8xnH9PGoEddQGuA6FopiPda2NWslU+k+TUv4LL5qCuY2OChBPCmzE7l7Lf6E9IkOzdup4+eV8iCPDjhIgk63HdpEkfwhDt4dvsuiTYX8aoImVI7edCkPLvYVVJ5y+UaYAPjX1pJh+cqzY2R8ie8xYmRxlJL9PSOi8a0b5jGjx20xcTzulPC397M76KNP1XBCSvaHvtzUlW+t77vhcPJ9KcB7WjHcEtTTaclwf4OZKam3NMwn+0gk3k8j9ybVGWeJzKwnTAOUpYEx2U54BqvbX1NQevWx2E28HOrhIJ7opMALv9EYLmqqdJNJSnPekApo4tTwXTRNonc2Rxz7rmsgEV2meevGWy5+3i6juaxueV/z7sYEcLul0vRBoZbRsekqoMzVVsXvd3AOLp6nJD6KIkHY6u0XX1EWdYE0m7jlRPVaZw+4t7lqJTQJKzbPAz/VfTvblc28M3g/sIk0DgD2+fkA8V+nx4LX2X/cFbUtoyI7fPg1PJOXO53yl8br2izIBnv4dR2DSZQg28DqqgDAisr4L/4BltR0nW5EcwowBh4FPsQOTRroFQ1pk823vHfY0Pb+S4en7I9v3KssA29wHvOyK9qxvjdReiNd7hVpY4ShjfKKtcv7hkGGlHShzQe0S181SXZTwKpygI+RcaE3FlDcpWxbsyKf5R4ixTV8R8K6zECdEtYVIY9ea6myCsA2g7x0gRcGd0udt2RuPiVl78/z2CIlRMFPlZU3nCTqqfabFV5aJIOzGhgwzeREzdt3VhY27xJUGJ/aNzKMfLBbX4fXtQDNJbITdwmIV/jfMMfhC6ed3g6g307yU7GHRdOGw7Hg20EZE8fYVJcT5NlrNpYkoJ5WssUZgaPNj4Cu2yJe8XyfRirzj72VcoL6dcFQthbBQcoEdUbGe+ZsrWXwFQm4637XBB5PMOk1KNr9FomQZ/ZjFsQHJ3I13FvBQCopdtw6i5kNhqf1SdcYem+muCaN7pkdT9ncEEVpqgtxwH2HfeQkEjUOcmOToxpVShiMPROJsUWmO2zy4AWihNBvE0bkWVdYWsp21vIoaQuPy4/7iKOiiu2VTYyCp+SDshVpjAV+bRNoRfEzSi1hY3016NkQ0YkJtRn24R3lscMK8b2QqCmWhpUyl78MzSTjDC20H7uS05J+oqhaL3Q+WI78De8cnJX2VOC8XcA1rk9m+/VfjKOUbYjk7oMXWwaBHAMsEIWu3dhccb1QtrCj4I8hVp8ApBYYnguBUfPHx6RW4RWv8Tmel6xk3XwNNlJmRAi1+nK1+mrNMAvn4weYOF6Gd97Y6F6TjeIMiE5LRQp6sMwBHkD4LWM4OTRtPRBeIus3bDRRWFJoQPeiL4suZw/5bdxtkTYMb1vQbr5x+gngOicFtojOcCU0yBroEfO24c85lRMDce/ZWazLBZ9vZsuq0wDXfP2QZdb/QZie0nJIqxgKcUn9EW2DzP6Wy/63P/hpd36WBfr45t2tueKVU56UAYOgOx8jlw+uamFHW4znN0z+mX8Jtg2fQut1O2EeIapqjdYHqnsnD6tdXC7SExLx1J5ByUJ3VlpiWhevB8wg/27+1Jdkzu/MeCeL1OMdBN3uiNE9tLManZ3OwT7oYjwWyvmcg0iHEuEPUgEtOfO3IRLb2XjGeonY+yOVG5XMlxyi3W3Zct5dRdzKDx62l1m/ZWp4UqpCIP2e710FwQkY3uSfnnEW1wXqxaqd+AS0UHWtOHkDDIFsW94Ldtx0/csfu1T6t5EXW69SeOY0A++m9TH5yX4uNi5B6EsE0rtnthnVauWZVEbNw2vOVVHpVfE9DGSOVEBoZcJWoeiGf0lFEDp4StN9+HJB7QBQuC7XHyKrVSX7WyezDQUlUXrRLbNgUcY/KmV096gu9J9MnCxRVNKXZoUJkuyBSSRlUmJtI++6WIRFUzdSVXQll+T8Yxsrlbgzx1dGqS2GyIhtonrJOStM6cajxSuhJGni+hVpfHIx6nUX3v+A5yLVxK9C2UE0sXsLAqynGRYrINScN/GA17z07iRziwIoqv+5nOZ1u7hyabIlBXn+dYjS8pH1Bw/ptzbB0S0GxaK/6eYjBFU/rSgVUQga86B5irUWJq8XlnVquZ78yUoVOnfWFGUZuUl7T8OqBI5puDWgkUi/m3vrVuxwvtp5+ySLspc+QFhuNkqueWQUfvUyy+JUe633O1jLIwJEMZW/PPJTstRxhCLljWZjGwRBRkLdeve3t5SvlDUkQstdU2Sh/E5s3FFJYk5lUbU+sMnC26nu5hFMU5PvCR3HO1juIlVwO1YU0PS+tm89sQWUCxjB0IKUswp5q+HZtPdn4XyOhr+Ze6hr37BdXSq0K2pqaYWhaCq8G3FI7WJja5L1XK+s5avRwsuXwhaFWSJTNMnyk4FKPvGRHBVdHLVHbTovvcX6RgO732MmIdT9wTt3gpQMJAzEo7JQB+NngESqnf2FmNwUOpBio+28ilA0uRKr4k+JASQAJE80lggE8aKF2beVUWtYHWeHs0gheIlpTEXCzbH7skg5+dxnmi5ZQgZYzCK+r0dyxWVaZ5iUd0AUJtgkJaDARGVI1BbqZT7otirlpaXaE+Yfym4AcATNY7ZXda+vuxjHjHO+kiTfDVtj2qGLiciSWBDHoXyOZ8rTklf9jLxaViGYbRvDPi+88/ejYBycxmOwA2DT5DillEgQ37NRLQF8dMyeaFxvaAYXND1rE3vYVfcJnMVKjrmbOwIfgyL43BfV/reHN/j9k74S8mYqi/r0z4xe7njzr6T/c4ddMADVpaksOYTD21v1dBHPnm4MRzEeUKp7tVB4z+cbB09oGgYYX3Xl5Urd1cpS0FdYFuTt1WnXf4wWnnrZRrnReRmMSy2m7LHlHYxqsO+3F92LZv4RwJCkSVYZ52afo4U0jZvyApFHXcxTodTD63sDhOxcOeflZYhTDMPd3h7gSxOL/AdTo2bKilohjTZkCM6EIicnm3g1k43DbdMwDF+Z6B0hkOwVppOMcr02Ls/y5SN3bUPhzERm2J4e23CIsayJOVbHrjOJFg1xzLoFybfU1OxjXP9Cpl8MRjk1TeXGuPCC5udLYhSd1XczomeTWJ52lEMskA2eenY1dikgfUtvLPVZlFGmeLlkSO+CUtwU/BqGKt+HLSMBwkvSY4yY0qlVwOpIJKWTbFVJ76Drb3zSagrSneNDJ4fvfmpCdiroutQFD3WNgXNwK2LS/AFDGKvK4AKqImbj2bdYufQIUBoBsBcDWMZwFba8T6XD0n/FlmMiI1weTt1QJ2Pa6cWX6jl3Ylz6eDMK07HsUxY3Rts5ALx+ITmAq1hM+C2ftns+1TV6293FqJSKz4KAr5YmNnXYdbZQ7dC5gKBgVW+qQKnGBIA9MCDusSMfABKuu+9glL+irTlyByEMi5NO6tJmMnb4Q8UCi7FzvRIEwHw9g6fzI4SH4dHM1OUHyiLWxwAhEcribaA/C+qd1j+e3virOcU6I8yp1mtJyNPkiexvtOs35+5FExChJYFO3gDElBjrBbTezxvX8Ptc+2+G90OwaVYthLGOXyKbHT5tsLJE1iCIkF9RmLw1BapTxFbIDS0MkydJJ9L/LH7oeSwYIxRO6mRdGP+YHOiWy1LrLmhLACLlL2xb1Oc2FvhSAeG9jruyo6D4/Hpxr0VxFkqOZSbZf4MJZddbgi5AyuWumN0rqaLpDQmROuB1qukrQSR1fx+ifIv8mLgGrjiNTSgt3QuzAMG+AgeNk8+lgMvDc1xnCDKLPfLCmMg1a0xceCUxNrXm5K1O/+HLsJAv/COwfwNA+QQld324jBx5IJB7JJtGKt2deLOB5R/KDFVMJmiTuyCQEE+KyUCnFXRS/uo3CYA/TCn1DLpLgJ6FEERqOr8aWOU8CAIZMx9iC5Q5vhhUwEaU/LxkNOw8DjOqvNAv3kZupNs3AEePAGPNIW8cC5F1KoPhkSVTjE5VNXpVAXIcDke5KW2oNGRbNt18qh5DXyS/Nj7UhlubNqLSZzXdymFkVDEqRIOAS2FFa3zu7JlrcfGiPQCONIfk5/icPboBA/VvoMlVG9WayTOn4v28mFKGA29zqo7BRuYsCyoh/t9Dq8Kra0zM+YiNF3moZ+Z44jU7Z//QARn8C5NtwOSaEawa9jhqKJJmvdspwWEJOU6FbBOlAsFX7k51OkujW6CrlNze/C/++uL7u5U7RhygZCdhVyNa5f7fy4WbtNmMHX9tIDtDxJWRDT5espuxdiihjsdaWPOGqF2iILPB5oYXhBd1WLvtpi0nzqK/sBeQA+bqvOTjZywZqsTDGifA1s1YpZu8hwVck0T6/TdUX0UccyYxiyLSKJ+rvd7Mr2M8W4OgayH+mvjBv5KGnmUbcjk7JfcAAFB1nNnqcQPj+jVuTwnWbWDOUfrdvbv+ZWJzcAPkFbdyJD7lXPtL3OQ2qDYrSNoXh2u9LHQqptFqBLLNwMHYi95ICImU7gxT6Uu9BIpiCbP1n3shFYt04jq1IhhiOr3cCo1Td2ECRIfr4BpslsyjRE6qmPZndyeEfvs8kx1+DQSvBXxBPfBbgscptKO8sAxHS8GoDYMh5l1blPuRRiw93Ik6pp8Ajt0wmqymR7E+8swv0uqnBrNIAEjB3iRMvxJtYTWrnUACWbDCzNqh8fcJTXFQIdf1SKUuTuxVQpmPSvRplXNIFPhN0fUEIpViv72LOIB0VUh24N71tQOzqgUwbW0+KQhCOs2rVh5UQ5p34rMFZ1WtEwlF2ZSjOxWnF1jTjbnywChDk3d5eMg+kSMV/QqoxZoKS56w+NQPzVgA7ciLyC6+Kxpms13HWy9be+8i1Vn4QX2RL828ESM/StDKTs8GiVr59OzJXAn8oi3+CTxeYxhaX3Wkd7izmUkIMN8n/hVenE2P3YdvhXIi86DojIPCDb9lBCFx3E6WD5fr6WOUsO+6xIJ5Lzk2JIHvYtZJRa+RWmwMe7iAFjSspEHYGnUvzztS5KXyCF8N3/eN8BYI33TTkOvbHYOYMQMpR7VJ6A9EfjZ3hopyVUn77kBTj39Etw5Lqz2xSRv/CiCAW//iIRw3mRze66Uol9QB8t9SOEsDvtwzskv0TPOlfrxN+tNGpKl2pzZQMipBXQMD7Weqr9AdGm0LqPJxm3vHnJdpm9NHDPv9I+rA+ngaQk0QC/c6VVd/0AP0CllUOEew4myBmqwbmP+Uqj05Jc+DXd24hbIQHNHjBoQ0FG1owLOWtmKd1RSoItifWRhUURYobufuBu6sWz1Hqeqn3nMI04hf6c98jXZxcDMy/67OaojUUd+d9Gvt5YZAzshoj1Uvh+Y9T/iymIdd59lOvBuFqlQ2KDIPtTs8bms2SQoddAAGIieh54UdVFli+Hy8iBMf/vHHD2E1XRHz26lk4mPS8hI6PbQc0N96/KqbXEpMFhBRNzBXpPsBYyWNrKGvupGJtk+liufMzn3XOrDUCK3nPDzMUJRSLjIfHUqkK6iKK0rxGxdd1M7RQu080qM3LwGMiNGv+B73sAfJS47hQo3LdhgR6gy1tsCJwZmV4qbCq6Mo58uNIM3/SiqrH9nFgV3MyRAKKu1xgIuEvxeisaV6RJ7PRotF3BF1pnou+hfutO5pBw1awrPaK6BFVfWJjKHFgwfkFHniGE/6axQ5ormAOMqcNKYjNq3iyqdiTrTa4YLp8AGgOvdV/xM1wXAurBIuIOwYgZ5nMOBnN5lbNi28jPnxZ/CdMh7lH6d+d1z/vK21Wh1aLhqUU4sioJfvO8v5U6EFDmJHb4e3eETk0BtTOpaxoxLTDMae5BFwgxSN6zeyxhi+XXH5rRQTqmEi+qWkFf65wwkkqANSeu4T2Kmis4Hthycu4G5uFxMC2hXbSfKlBWp46idmD/LwpVTocgCGRXqkuegqKjzhkm9svS3i9u7yiy5N5YCppXHltaJ8LkK261hSaADtXLQqRgkk5FPxpJYxlH7wkhOlb0CV/c0ycp7jvoHxTGTn5iCgA+zyGQgAqiMgbkG+Wa5+IgK0L3FWiAKHZtBvx7A008aQWp6d+5YhihrWdbeqipQ0hP5gs5xjydDhhfYvTR+T7GVlh4T6DDeGQ6poucKkcTmOX6o0BDSxhnHEp/KMvPlMBMPwVUhlfXBeufvHWh7YMWJtJT1UXSfAEa7gdGIDIMCjBlutfRZ36VHT6tp6z7n5LAdTCTb1Awtz6aLvOFvmxaKpjk2DPoABoGtd6RnovWadp9rlWuhnwbTeTmA63yoSOG+m1Uk+RnG80uUMWaq4B0dH7pSnSmm+IFMDVHNwFoBR87FEcFkRcoKO0yVayIG/6Ao54yGvcBb/gpF7sJap2s/08ir+btzVwr4uB/QpHWMJuh060UczJE0S4s8EBK0r/a11RKWkOW2pM+7CL38wDQzUf2TMyWbYm7sDsEuH++Gc3jwpRwWlzmmmvfiwAoi99uhSjyIo7Q9HDwC9EfthiJWerL5G+ETf2Vlyxm4YOjKeFCWoxdSGpEXv6golYpKhTBulMk/h4i0YMBvyZRP8T/NEqJvAexEUGBDpdM2mwDOTgQKvjRety09HTzzVtOXuSp3zpQXUAIdMLkijjLDH+WXme7VvAAdNY/2wNPXSoVjUVut35uSKnl5ppOZGxX7v7GjErdGZkzeRzZGKSET4fr+swIeBjKCqlF9tuOtXIX77L/kAbKlATCRLJFioOC6hrfN9RJWxpKlSMurq6CICmYrgmHe9wgxbht7PVTUC0z/u73638uqoO7ig5A8SKZRjU6J0OAVaO3eOTyypjAkO2Yex28bH5zDx+O6hO2JXPAd/cfgKg5h5rpD5r0hGXU8vxLF0fuuC00aWyrmKOGo29/JaNDJjCq0x+1nYkx4t6Lre7fB2j2dm0sCsOaGpI5ohFPbTDAXsAsRlerDlN2UaIIK/J5j+YJ6zIhnI6STw8DgNrzFqbpikaRHAfWCsZuUqfF1HLDs7C24hkztgI3URIlxNRAbB7jOt0jbCm4C5r6u6ejXsu6GqSPP6zni/dREYjQRlQ1My4ZAUmbUQBTyGgUIvaYG1vLeRhOGbM0LZTV2Q01N0wwHbeiffZz+CpG89w2BqU8E8DG5ZM0sr+4ROHy8PMlC26Yyc7G7egq3GwTCnFFnMLSiV4slDEFAzjTitSqSnkPDyXHTOUZs03ZpMAQlN9B5hc5unPOhNVH/YRldq2WN1Jn/ghoFaipASj0B/iefH3VKMgaAqgJ1fGmwQfeOImR4YkFxiKR1BPBsbZ6gcQyKd2Y3SdqGAhaAl3uhkUBezLzGaa9b4YSS8Kr8ZYNSUlgpIzkaHgRA5CQchQtCkvGLiJWZkcws6gRNJUfPkxOMxdYIZnXd/UTovyCQQ0+QFHtZPK0sijuE6FZq2/O34k9/SiuTqsfP+IzkhQguzncRGWEADibS7p6/Hp0PZwSlvVcWMbyfXgZ92fdvXN/kFaOR0/VH0Jp9Fi8HIIY7W2oGYkGoE819Q8QnDd3p0eIhidU4lrVFlL3ACjNzppvhLpCDTb5+QToj2ozzoj9LEb0Sp1CUMsif4cRXmA0RQ8AuzuBVR8ce6SG8s/ntSHWcnNy8hweMnI+8juTMTA9SELdNMWewCRBmElWdh5g3a3dOCPB0TGxMr5YEDEka/oEKaat0NNKpRWIOw7TOBHjiI+XfYJi258mz4DIxfoYwn7erZ/yPy+aOLea+bMuUNJF10NsAdpDbNHcobjM/obuuVGF4ixMZvRY3orLpe0xOOkoVsnkysZHYXfWEjHk3jdSrc1ocKrEi1PPRiyJulGP7X3R0o2wOPeGNIV98Xg3NfYHzIY9kjWALimDteHZ6WCTjCMsqPreKKRgS+7BTVffG87HLNO1ny0+8oot9yKok1tR1ytDU+FYBGgPx6AsUZthb/APPasGBbvvURDyPXyoPw1/DJfDEJtm7QSjodMYx1cqxPZNxw9fy/1zCEoM89lUgX2dANwzno48sO6rTAjb6k2ko0+CcrY3SLwf9FRgT8xQag6i4jHj5fu7ittVM6GDD/so/MrGIBGqv8sYTSikPe9xKMC9Oj9M14C7diUF9caX6t/sOM2VBTTEWQL9kO8O9Bm8OE/PpImbL7EJS1OtKJF4Evwz8GKDjSOvzyaLTL2AXMw5h8qK5Z8GMTtiiGeaaecKRKqSp34Z3pDhQGJ6nXO1qdn0teF2rtcVzGHWcHS8iiXcsiKJHoUB8Z5Qf/pQTbvR284WDYXc675w00kjcYZgQuliDCRdjbyZi89t9ke9IJn0XdKJEn2zDCmx22vKAJfHpfjtuYCMgKBS1DfVvsy+Zzxnns+k3dw50ENxqKo/9ut/2t0Xccy1V4Kb3OjqiERDTA6wesAtaGX/NXa1fnOC6xWsXpnKkPJRbvOn1Au7w9qJKmdYdnb5LHtPLCnxX02Y4dr59NdgTkR+uSJwllICdE49RCun//W3DCtpvfPJ/DlmCN6SFxtBwBQ1yGwNzvUDpunDs2arMWTiDYXzp2SYCneRAsYNcOjK7wHVI1NwRVzc82DnZsIdhXjP9hyXjvHduRLx6zTtRD3UiT8ctDVtv3/eYc/JaQRK+rj7dzDLwRCEyB4S47iitkd7TJZGUXYNH0xNB5dkMoz0t+vtIueoqH9dspZan3Yl6chhlekuc0ZnEnvQ2aoNUKkmhz7ukwsYGE8oRalMMb7ucwzio8El3dc2gAQqIx2eJUlCShR0MLl/DWITD8l/FIJav6FTIjK8JVNcWZZJbEvy+KX1t6LrzQ7IsrTbIcE02dCWWtxY60w7PLrFq7+T1JRyg4fxOQQdaZ45VWPnfDEztfVCA3jinMqaXzlpty8R6OnbshxUnXqk7+ekYTXAbU612EDzfkBn0pFNG5Vx78t0/PVT0fvFsPo5clIYdxV6+ztYLI4TxaG3ZDb5LO+jQoDEko9zF4hGCRFsJd4yKi+fcBjdVD26gg6lK+d7RgJ97OH6BiUnkxWNb8EjjNUcLEA/v94iW2sZhJFbmcQDN0EqvyCg7XJ09KPjXLWkfw6JYLb9emmFOs1MPFFqaGTViCgMV8Af7sIbo2lTQzhlOzRGbDYoOrUPBgF9Ra4/9Xm6sxoJDEocykb2KRDPw0unwJ1XTXR9fM2w25PVZHeoB1cmlhk3pkXrIWCs+wHDwrM7tiziJVuoVnmT8NlXFAPsW3LhhH9HojoHXPFcc1aNcL5IysCaNfm5rzM+vo5d0WdUZZOI90IcI/dpqZLpHSc2YhGhy98vMZKd5ggKoq46Sz2ngNhLGGjzZoxhI2PMsb3Uo3C5KRTvlCrTVPJYJ2AHwd93jp6nfEAW0RtocgbGsObrucLyP7avPXviWuqhZBa6Fdhb0xSXzw4AUl//N5qksqpdtvaDyhs83TxrKgetrLA5MPy60H0zv0aPLrLj5jVbtVQ1dlllupiWQ+SrI8rL+fi9+YrJvMLcqFk6eguW+sL/m4VltgkVsBpTKcb8lwlg9csz4QgLHT0GnfG9CeOWC1dkKKfYAjBKOwOMApzQXBOk1i3tNXl3FlhOj5u+ECzd9EFxzOH7C8YrFSfo/JeMRWAikUsXCNyNm4+S3Pumi5DIVR789v8hpYwRdhg7nt6Gls4FvZz8HrkWPoFxnsu2ddrhr0o16JQsOECS/IfVjW1PpqCXoUqE8HxbmVam7mHKsHYCUKLTxv8yqXiSNvotCTbZRhHPHZeZvqDnzAhUgNnsiMeQWDZ9+GYA6VCqihWPLhbAdhxb+Qu9Sx611BN4w69mFvaOE9FckMdzRj8fx5RLzvWDMxUcaf4wY27fxrKBP00Ion6cvlTBQI1YEhC83fPhvq7qJUxRgJoRRoyVJP4rzuBq2QHmLGL7czIMcUc5spV6mFVGtgDJDq4gJkMZVWSJPLQc7iiatDkmB/nvmw6afWxYH7Xbb3a1h8WNj+mGb0Z1r4/kxM2iWOC0/qi5W2kWGPTBIxzCZBaQsIqASEJ7xYJFTXkGR7/TpNQ0gZYVly6+96N+r6H87VkXr3Eka5kg6N1C5S4eJ7J+YscjDl4OCvzKw6QfytYal8pDwfmUGG76WTail0+sUhcjNQtk5OwllQ9IDtZGsCkR6+MGtZ7O/NMjBb5Z1+fO0HnhoXYI35lgDCF6JCVEbInOUWo3fzcAaQoqXh/6nf6SuLGnt82f5ZWf2yY3AfyZZLyL02lS541AzlyyLBMCRz/dEEOBii1SyPWkNIIdh5NSlRgE2GO2pgzM9ui0pS6FG97oHNN+Jjj4RmSjaOtc/Bqad69Ka2OB/TX9jl5VhW4Zh3UgE+HJJcgAw8NKAPoz6AwN/g/mdUllzs5va5+UTYWrAsNMKDcXKYCx456MgWaoV/p5WQizgZZPiCqXYbSFYYdSP9h+ps15FcyW+qWWVJu8Dyce1tJ0EUONNGseb2TGk1elCrp+JY1m5De2TGOF/3WUgS7FUMC5kGM0Goal+qjDx0vyNeLSOYiNpwr74Bz0nWAOjDj/+XNJtNHMSvU9AEIp4ylN+uprh1NzekXJsAJHD+G6UIYQYAzooNz109zLtGHde5qcy17kxF4jFZDQt2IClL9wbRQwAYrjcfKnYxXzyF6DCUbmb7IQ8tS4ARRG2B2Xwb3qiw8iw6EPsrP0icTNdNXufxEOrIoCUrDnigLf1Vzmi+QFMW2QlNLldwuKyov4hU/2+skDRjYl5hdJLT9S1JCxu5HdOlXV69NVAjRAOAOGZJ/UPESJABJN1zrVQY7sQbdlj4iMiqISzXUPlmukbCIX6lQWDcTbxedxlZEWcBliHJ9t1/tCSd6VHQO/kykdgnAnQ5eVjbcw6wVX1geKn01UHMLWdXgUlqAwACaRTmc3xZXDpgJqifHSSgLvDvdea4jgJsnLPOllOXlf5U8YifaahTRD8CD8bFBzxtsen0nmyySEWPf9WXEM1G051kKLAKeuMJgWoykpE8tvMm1WNUC+AqDuFbs0yIF72VFzVqr9cP2ZOQDCpMSv6eR+zpDOheBA5vGvzul8rY1szRr7mGRnv3oSZ/sigDE/s2UtileQPeYTpFj4m3/EtU8Iqk1OEBlS/RDB0OeR+KCEMq5qLcdS3JZq779apDBitTrywiOXBSGz3rpPx24B2RYZHATB0SPiZwRHfmkGdEN5DtikSEo2pR2DLna4rcL0+mVDIaFURppWuf9JW2ouuGuDaQ5Eb1aiWuPPjrQRJi3w23mcIcWQ1yE+0/fVHuVq0Wr0443vrauF1TKAo/1SXF2zuIS/SfWzgNC5OlYfBSUNUwHPqW3122IK16P/37EkEY3fTbsoDmk0P0iCHJlGwwZ6mY4rR4Miv189C/rBDg3A72EKfL8Oey0j4sult2hSZoD/8hBViV26HbVlWx5ouAcuoCiDMyd7mwJAK3VRmFggY01E6YyJetSeNsIqd6/SHPuqvwAN1d8hbbNqQsvOs72tSAid1tgwcw5dXjBd89uqvtjjp5kYKzbwcZlGI5YQ1Cmz17+6ACqY45gnJobOcE9x0LTXluYzBDRh2bDL6kjwUXKkJdfSyUy9/kyMEwKqvfuIKIRYoG0vb9H4Ls9B3c/aLhX0b0yBVEk6RP0ly30qhf9GYcpZ/15sr4vj/56Mgkk5HXPuVZB9qo8TD6rcT9TbSZYQoOevCYskfgLDoD3UzQwvrFXCAiKqPe9fkNlVL1ixKLtrg1eMChwamWh+hhzup7HnrkDeueZDQYKW3sKUF9+p5iOovdRSV4DeCMgDgcsV4I8h0xVmbFbLx4qqBC0O6rlc+df5P3CveS4P/DRG5dorFI+lraohh992ij2gKS79J0vlreV2J4kqHzx/j3YBmF/30N6zMt/fS1BVA2h82i/tu5O4fF6Lq7V8YyHV//3aoGf2T7BzcZ5268rR5s5DKd1KyR9VzrFhsOWZtnI91f676/YuHloTGHQokP5mikKCPDOhguACg+0swG8XSXdwYSXa5YLBUmUsb3/T3+vcdouf41+PuTr7x6Nhw6cKEkiWmWKI7Y5NMaREc5x5kVTck/ePLVou62Pklacqm6ryLhgy0REMKvQgqWArm0KLlCBI/m2EbXIiub7PRM7WY6A6VKRwg8f0u9nSPm9QDudhnbGD0ZR9as5eLXm7rkcoJG+ydIH/1ccjTUcGuaba3Wa/gfq2Z19AyXaQvjHmRKR+umHC54GxLmVSzXgOPfsjKI6dw8W1jDqSvN5P/+OfGFUlfKnXOsQWQIsz9JyeDWwp6fL8LhOIL7afKS3cLNIDy9cJtcw9hCGP1ouxigjaME7h00bypy9eH0n4cFt5wF2qNP30O4vtTrxL78T+/U8cAfgnZNAAbe7Zpcod96GG6yPyChoL6nrSM16O7RBE0BZIkUTvmH31Y+noblTvZQGVSpVGEK0iSjBGTSvjoMGk1vWvEca4g/FN/fNzFoKTfh+ge9cwHmqcWii/gJJkeztrJNiM8u2lCYpG27uquQHMLy6iGyfgHo+9Hio/00SqqCN0qy12/xWI1ejzLn48l9afVbMRrdZwEaPRYdACZ7X+cCrArDZVHIvE35ddjq/Fk8QhNaIYQV91nzGBouB07ygrSA/UfqP4seC0p6LT2td9+ZOv3vS2z69oM3Gx/AtJK2pCPs3TjSYyDIJw8VO7/3yryei3UEA5Y4f7Oyc0qw9BP9o90FQwGg2CX5tDF++GN6oPRpz9AVY5prwQ5eEFakO+YG7Nnv2+RC348d+2+sROOBHqD+qtZUU7uQDgvuZ1HckS6WuIvU5TqxNR9q2cgZ16o+JZNVnxiPIaScT91MpqkhYsgnVAfzYRHncqSTygvGFxZ2ql/h1k6FQsVe+B7ETU32SFvRXe/5DFejCVX8OyLY69CfYJi3uC57e/FXeAWmVgMeBLYVqPn0nNlm5UwGaW2cag96E8LoHVHtPRq5+rT+U6e7IUSzXOr+6+cwYdzMhC1rS8mq/VmebTwiJ9fauGwFgcduD5abwf/9wWiTkRGHb4asl4aMlTr/eIjPUj2Pa/851jg7w0nEtZJD1dV8ase+Qr9K3CEH6AarGW20vAqCEET3zZDoLn3ZfREGBvrtIohX8u2RYfhcTnRX0p78JhcvK7z0HS09D/gNil3Ogtxium5tY3PcVLG8Z6pYTIUilYrA912yhGmVN6eaL8AFNMoTO8V06upULCb6x0i6jMdiAbzCZ1UKhYkUCwtm1nolrgzlJT5iOmfe99aOFbZ07pAu+EU4VFTR1BCiPT7EMcFIo5KpIZ1Pbgc5S0pvesFnDARqp7I4nIEU2LcFeu0EJun4dzae/8d2cdOi5/XprSLAfP+BAEKoB4xQPp2kgw1ySKLqzcSZLwe3W1DLzsh8SQS7JUhinMcNRuT8yV15cJbL43C2g+zgMx6RHWR5LE8HikTE3AGwudbGJ5t8dx0S0wnkGyWzyIDoHyp5InMjw4WbRw6P4SksET4faCf7wnyUDXR3pvlk8Lw2ZOmsRz3jfMC2GNOhShw8TzQ37lBRxINYEYJqeKrETS7WoNYolhtuzMlCVMIs3a9qc9LZ11ApjTC+C+YKB4uqipvii3xL92PbOLW7ry9slseX5OlLZYluIEDvp87euRLn6p62oxbBvcebK3BRw9gfoajRxkR1jxVNhNvGbTYhy/T6iXkmys5rEDp/on7WbG/KcfX2OyOMokmBuFIkRa8vjHTZJtabGcIN/Of9l81piA3zFRHkophyksqm8P0qdNESTltqtTxI2OKH13YePs/hEL1Zht/ypPdLrA+vdAG1UpPgT1lO1Kgd1Io5wO2qs85SI8GI6FwABhCiKBxIVTw/oJmj0dabeVTlag3xsaVfxDmNvm6WRNyAbEe2QSz0/X6dW6IGGe4UAqxfJPaZybqt1gPGZOUBtXZGGLvMeon+EiLVhSnrxi7LeDjiAvpvRlwGn69IxSpU7iRqV14t6Nao9Nlxj81TBp/rYsaddOvKhw7r/j5VcjIvE5eAPLBN6aFZTWW5zrM4LHJ+3d7hEOkyUXcrXGPNL0VkHorb3SBrHJYIn8aYBY7+Z5gTO6+EG3/iCJiWwndu9g5kEizFzpL6PB5La4IoZI189kPG6DDomxeY5xb0FcFsEu+i515j1UDt8TuiKVoNybhJAKmBUuIFnQUuaDj/6r1DzDifNE3wcjxv1UQtOzPDT/ra3/MtD9otLQerpnNpD7OgLGoNaasJESGKl6130C0BjXaXkDmONldTxlqi2sD7tkVtoeSEDr8ScXLApGsHN2zqhzht8v/k8vozLtqsGRg+9Ha41hWpwjH8a84d3el0eyFbK+5Wz1vag4XTpN6OUKZfGDkQzC9FYBK6mxWEAufSMs8UkxCHqtFE5hHNmXi+J0gMX2Wl2eHI2TFr1w9FttA8L+uEhwDzeseHIdzLmhPBIHQNzC+dY6KcA7WoNc+8XzGcSuLv0akW5I2nXgoVz1BxXREP8Fv6onjo/KZucuTb3xN9FhTC3G35VniZkr9b4MJLO6Mc5aEIiMZbhN+yxh/oJ57hh9ROZUzkAQ8M0j0PIRLJlIJe9n50Bdba8gB06A5sT5B2S9LkGKxDMTN6Z+juOuJzC3v7vVR4RwsM2hEKhDm/i4mDlFDzab/CPAJFhHaYcoJeS79I/YzuEojp/RTpDaDeDp5w/ey4qK9CJAnfLPpLjwek3YJLkc/6HZP89Q5bqsEVtfyoToHkS+yPabGVVlMQng8u+ipNizIcYbYypfYzcOE4JWOqsUYkjPq8eOcN13WuihuqYQIdsufY9CKDmEePqdXtSTM00vQO6oPEUOgh4nxl0RSIlP7K/2jknRdC1eOnTcWwTqiH+dxtQTE8K+HJ5rrfzgrQ1ODdr2jmKbUfAdWJz5a/cKHuVG08hHxnlxHS5W5WcfiqnewDIw7JVqssFIWI2GfOG76xcrXdFs8cg+XmG2ooAyHg5M4q2CFZkMsm1QeOKuUR5knISWVqBQAA2r0GMz47LbZztklq7GqjtQrmG5tCiEvqcmJOpfRv1MnAQ/SDqO1c6VAzbL5NT9au6LUaHeGhr6wA+8sGtCJeYOn4R/253Zu5nisUFzpxG9jjIVlkSxOkCD/5P6YNa4QCC6yNDS7uno/EUkfN53tYW+OH73q08XDJgZ6f02Ey1KtdpbLEqCrg3skBwI+qfUKiK1NFAosR0Ft8kdN2uVaGkt9Mg9SzYUqR9pp7cJja9p1WDEqDe2TcQKMfIMqaM5RX4Vf5jJAEMhgL+gNB1WHMMRSCb4/y0e8ov5FUE9lbLhyS6RfaBBecZ+85yIcaJDV9ov/psgUhUpiVAl+JP3Jlk7RfyMfAkJ1IMU5fEkmbfi6M4JT0JRr5vWHv4VXotFu1m5obCDP3ZzdewoorjJtxRTTaodSUyUjv6TA+tye0wrXJ3DMYL+v2F9ubOiJxAzz71eysWVGbdlchVyRG4aINDJgTFrOdLeav2KeAXeJ7GzPHOxRsdAI8pw4mAM/UzdFqdKk9cC4Kkt+9p9oX/RbUY/MlC2SrN7NidLP+7yBE5hQfkhOk3jhy8IDhISodbUFXe6OiZYjdE1xwWpjFNYB4uI4wuTkQJFIy/pZ4dKFllKtBpaykf3hF393id2Y3az+hCuZ2YoXjI9kDnnrlRG04/q9zkxQjS9jAuNsUvIpFElLOVXg4dmiD2wIg7DT/yZPkeSUdqAu0WOAm7NwLyxXIMs3qGBS0YOIKvzqMvCxg1LZCHwvpD6DObQF6ypud5N2A8e6Y8hBkPHE70lySu27Z9b/dptwENGFUS+BkTEJt3TERSLy81P4EESbMO8mMkHc06NKEwyoRbXiOi8tRD6NQe6I1payq8o86ofetGT49tfldmkdowgJItKl3d4VwBUWQZ6zn0ANn3GrF73Jj+OZ08MXAFTu5ScSDR08SWWCxXt2E3bPhWiVtYrrQGYiIhXgsANyCdktWnXPwaZxN9+FzgaoUs14WwhwfGAIyEpzJ+IpEogOrnyXSJMdO4VZ+TYXDZBi2BLR24Xef9Nq7fcdqjhnqa1ik8TKX4mr+Q956VVoIj/lQEY/AZXTnUd5K0tvxrw/NA8+V/GPvxbgOSZmfR7dfuO+Qazg3NytfVb/YIAN32nX70w5p2D95bqwuN0qNUPKjUtlB5bFQh6673uAgCP0t3YCnmfq0WLcVguyfXOs15gYrTTOwuZu2jo+4km2+Ia644+K6hu15VcjKj3CaKiO1sEBciHL8B12oASfopcoOMf9C0h+V3UTumufB+//toHVWtcjiVTmoqK0yocdKEzg4FJ1nLPwiWW57t7DN5qOx6IxmbChmMa4CwDaG3/36urc42ni2ROpP9ZcleFY3w6lA4eb8JW55Hu/OdmEuJKr03j/6Uj29EwAiTyAEMwCN/96/itIfbQDuJSL2AXbjGRZHoZo9qWTcvBhizuAeqyFE/qfYKviJkg9iJAYEUcWK7X1b+PW8s4wWr2pV6WQv+STbbWNhY7f2wbK5HyNqDt0rSUea+tA1sLgDP0pZxKS+rss4Obt532yqQD0dfeH7Q19ThGCXEpKSoE/7P1c3lSRgzT/3MsId/SM8EEiIY9qxHih9m+r8mASroB5O4hNu4EsGLSRm7Sn4SHJLWDe64WNZd+m9Cu1GARbmCjltKsF9GAWEVc3d+Ql7jXFptw56jMf/U3TYGITLLKGS2qVurGbR77KBZEPz5OURjbM+VpLMuPImBCP5MNb0HCoenNTcAF8oU2R45NoYEG5HR+vlZG5/W32fJ/9zGGYXocUH6QCuqNebpYPrtO8abPXCnl/qVpsfiU6+T4VFi+vmQPA6c6MgVSHdV+iIuMPoCDWajDnTJE7ymmAst623D8YS9QOlcj+mJc6OE1oO4pg6++gLi6hiXdK6jAgqyJ0qcwkJCMsMoGmaF4MWyZnZrXBjmOAzK5WsGIPxHgzwjnu+Mbv3QRQnu4k6Q/gpCTT3UVuWMdlVzrlupePybXZip6w+hz3QcrBu82YinV/MrI+Egnbdgt3ern8fSASCnYAcg4BtRBtSO8DwFuTTREp9C3lpncRGua/tBSdZYFN0LxhVZfjBeYbd4srSURvcRo5VpWUzyvEYxfryUcs115ch3PV5ADlRxVuILHDGYCY1iErv3uW/oR6xmdkTfmdgO4jC7NJ9v1Zw/8zpblWHMCCFOZydi4qRNXCC5DL61xmtokfjwhg7NW+N6s+ZMVvkjgS39aoJiYkcj92a15FrhAzX+QoOffzAsnXj9XPM2qECcu8jVBZic2rm82pm2nYxu3XPoXcw0l7mGTcq7Gt09XTtRrs+r1KTQfs2xa+H57i85sNRFWOaK+XhXf3RJ860/u4FYiwtTWY5h7//O0A6fAB2kVLC8S0c16uhNd5Yhq9kDlUPL1Rh/0Opkemc/KZrbQOfYVg3vnDDXsQidsOI8JQd0LaLu2qFyPGHTwrwaNatTnL6zPCR9zV7RpXKHU2hmM4sOCBPbd81TWz/xHQL5saGbm0GSkHq5Y4ZcLT/yye8JO5PBs5vLiCxrN5eZg7+AY65r9+KtccKdzOxim1mvNNg+iBVFFOFmZcFcpnrh15wwK2cOkm3Qlcgwb0ZKmMiFnleWzMCtu3CjJVocGsIEsymwlrpXbSrTTXCtB3upYrlxgdOMI6io8p7BHNFxQ/dVbuxJejQ/2x49fOjRbBkbA/mIox2jef/GaItoEJ+DpCXHMJwOEVFs6XRw/iBJfo0i8duzJdaYtsMd4qAPyWetnq6RRI/O9LBszLpvEYMxSZtrFZaSyrk7MZ+W1Zco0+z0NSPXklDXomjMlovZsrJPZSB1ZX0GlfEaiouK7gWUPAmBRm8Y3n7vXvTc83hFg7gABWMDFwuSmoE8Q0yWUVAULD1yGRZ6lKyw21SVtjDSnHuI4ga0md5TSj6akwg3xfc5MJT2UbJ76GuYfDFn7PVs3f+JeBZkV4APd29S6PNRFDJ7ciK7VaTj9K9geHkX8OzZjbokv8DAWuZgStGL1NNFdlWn15S7cpWAxbTZDB+TXDCAhuldF+ZQVQsVw/DZ4bgHPRBweDXsUsq696TdOJtwR0lNO+79JXExmdsuRqTrxVymyKYXoITH1+jxS20PMiQBF0fWj7V76bjawfBns0t8DCIBGrga2Qq6Q+8eJ6/D2LebEaiagzRl/OVRYb18lGWbWyu+rV1+r5kLC1+jHcr81rJiPSM9+bLiF8l6o+Z3DWSBCypf6d08obtYx0MFE1JX8rxMP3TFtpRnSZaHUbQBCDxGWsyjSrXuM75o80uf0+lJa8UFsRQObnlrh8VuDT1P8nHseUS6ZwMt23u1pH1ihAr2GfQovX+9O2vQ+buO7WLu/WC38earPq7Hk6x6xHszkphzfe39sHsPeyKx00GNeMG/rVQfjMoI5BMVZWiWZjQBDRXOzkDRMTRPyHV7qSOMgXf9KbmP6LAMd9QnuGQ5y1/zhgsZwksiiDe7fuGzqsqMrovTEbvIPzk1tmBihqbvUPf5T5p24RQNNwRVGEYQMZgGWPrG3NParwGbEUL0lPwj66qa3t8sPnE4JdijCuJ+eb0bkmWfF1dx07kDDaw0Eu2x6/voux407NHNpVypztUO/NiNJL3FKEQ4LR31SYwuxhjPCtjTL0c/T0LzcjCNVGK5ifIgE7pz/rtU6dt10VfgNohOJ2PScghqUAe3SUWNC4TFnT3Bpv89N8MjTyK8D4nVjhY7rQJvHgQnMfFCneA5k6zT1ZcHvlRC2UyNu73SU33zXPXyl1AAPxDgz5iKCtTorVO3jZn5uS4jWly+boPMTBGMsK6O0KppVblYbXhHAPGTiBzZnpNNEn8raV+h9zxfw5KCD5dC4gvKxwFY9whge5JXgvPOfBxSJsKIGaxKZuPZPKexuZNjup6jJFUpUoJWPpIgOBgxLcxvUDpx9BPsuWAQkW5+Cga8hLChMdX611p/PfS7UlsjdYEkRsn64tmEG073XnYTwPKjagOG4rkb7o/hCu1xEEoY+v8voSs6fHG8Yze3rm7H3IEr/l24BjFGi4Weg0Cf4y+POu4hbu+ebKytxmzKUs/4uLY9G2iSEjiiekwrNB7XSVejWqA7vjTVWYW/GijHQTKIFaFaZmH3dNi6FwwkuQt6PSI3/fLK1WHEHupEUEACAanA5zb4zlUUvOqGp/BhxtBEKQyEfRL+bNvc1+Ie2IgG1HvvuJf/i1qtMeirplYi3tA9mS8bOuDnhTNmeLcMjP40hTxuxc+qbYMLkE461fwP3Qw9HjJ1n5DjKiSfvl/+YQUeASiiIolgJS9wFXgWE/TV8kLZZb9s8XoE1NTW3490I7WFWx3SLYWSn+EHwSuLNGaqeHeQotJFj5v+PiBRs0q1b3Zh9kiWHbFSpAY3MxJnOYOjF5IL2n3YQa5UCFFy6u9sKWm3GWQuqlIoxTkF1Du6HruCwThm+oy8BvowKQK+XzshEM4hzKdVe/KP3gJL1nHbrTFKsoelj7IW/oMhyh2tZc2W0H7zZKag3q/pP3whQGkz7PtBAJXgCwG9lVcY3M5blI+75P/F11/iNC4ejwct9NL2lJucsYVd+Fq9kImxB+y+5SIPGHrBKr6OUPnpdI+Mje1Z8ROVoipra2f5RBkn+LWxH4kAKV1hrBoR/HbygpikbtP/4h5YbRyr8d6qnqKMkI5ikvyZXGQS5HVgc0kqH0IAP9pC9Qofi3VB2Q7h3fR2kUZa4K6bOd5Pb+fWI7AWjuHrrR2BQmk2x3830NSVph75MLID6mCTZ5lVw4jEf5mJajE0xdSBhnVCbuw1+XPrfe0QaSwzMNkifblXCyK6iwF5Mg+/rW48+76KVXK/TG4bg84QPrDzHZ3O6fNGXLfhW3swMm4piKCnubgk0BbVzMPLP7B1EQuHtNvAyrJEj1im1yWmAh/q222Jrj0iEXpReQbCsfpqnBUbO47F8hru4MqyR5VMqSmKDiojSroNhgmRCxBavO6hl1rhZWIbJQ+vqj7T0M4jIiTLj0hUeY4/cfBQrmyR6IvOi82uFkLvP4vJb1sbBKij0Zdv5NAPUiHFCD80quMB/gEJuMCj+0VBjAn6tzCykJMUyfDO69GHSYWQXlD2TNecYDnIEHadppr8u8gqptpdkcBnowZTmBrJ/5eN50oggy0IZoihLlmJe3Hswwd6TG5bDQZ1+/v6/LZb4FFtRTd922o/qYsHr5bLb84oNX4wIgMRG6WBHHphWW3IB+nmM0wtnYjVc7d5h8lu2AyMPAS/iH0b8SHvaCvzuqL7a1by6Ik805E/UOtU7mpBIi98nSfWnmqIoK9loM+O6bgHLAMp/RX5ng+2Q7ytcglXER01Gp88yup6cJs80E+Rge2glQwOk87wwnme1rlgQQSvBHWNkhB6Q9G1Kc+AD70MfZvDDbJToNNX7hBlovU0LgNAILea5P7U1MacAu6/IcFMSjinA93EicBEmc2e/oRL4GLI9xi8M3bYdG0O9KzQncGFqSSYqQP7391FChHJ6dF5EIsI0H1YYrI+bibf1suibvfOXRg6UHrug+W2zWREffG9oaletkFM+CjVIDgc8PDhbMKFWPksius7J3omPdRpF5bxXl5b3+6wauvkzy8BTLovcrfha9HIjmUnnEXZAxL2JxrfTz17arv9kWt5y64hIaWKzE7HRz+yaN0d9ifrgD/8lOb3QftNAsHmcde3MABG/k4lGq/z8aEOW9zLcS0FFYIAZXtW75o4xsG8bqPVlTOEhZQF853mdppCwW2+WeTXY0W1JWQT+PiVQAx3DxIolnK+7qFlYE3A/XT1UZXoScYIHVkJpRNDV+tjbHOGVDDxsYePlTGnIIzblxbrK2DRwnBPnolCwIwPGjamQ1hbyVtcEAfHiTVG0p+r9nNEcgaJl93thHZZPbAkswqK2G0V/2KFdDXn6aRj+dpI9gOYJEEga2ShPqrj0/r6upVu/ztMnc76qLyKJFiBOFUbeXQ/TJdZlXJwAu6BdejlQzSbUwY/a71bKkmVgZxzXpUk9MToBaDIt3DaeB8v71YKGI67dxHpau+DI4/sT0nhYFI43Dgh7l1/zve9SiFZHDmdws/+/0McBsslFHtc+Aui+LfB8JHqlZSVW29s1omLy0+fKYqHnEs5tJW3u6soMjPAwJQdRndy9XB/4ws3H5Rb/twGE85yscB9htKvzeiE0KHjMxZMjRwy0RQQrPfvS/0ZZrjp4aiE50sXhIsmxIfTu1SezhIXhkVDFBTSjftxmLD8AaG9oBzjHZ4iDU8THGHpT8oPcBg5k/BZ6DIv6gn3tJ5FYAIQfKZNP4MzKatBqnI58J0YNcbr6Eo9hoxJhuqsQLJN9mqvT4Pm7yYvmk5Ahe9o4D4GFjH/fYcb6KYzIYrggGr64CxFYPl39fEUusB0DpG7Vmholb0+TFpeye40Kv/3LkDB0xAYuHeucsRQdMIt5Uw5qelQ4HCyRxTHN442eEGhSOFs1bYVAjhj8bvaN2RQ29eY7dHFO4IxJDX3F4GKn1osPBQsa+38lZll+m3hk+G/l8PH6Hng/kzRR0a/RRiJlFdLAGmtG6Xfz7oOzPNO+5cZFNg5kKNXHRgzkpFIynIB16wqW+PzPZ1SOkhKL4PlFd1xw4ZXrkOTy17lHnN+4y18HE0t4BTCEN7PD/EtZHzyB4ToY3rPyrMcf7cClrxUgjkokppsigGcpNXVN9HGpmRFsZGC7WZxGumtbHurvAEQGdTkV0gvUIh0zPqjJIQkW7XyiaKQRcr26HMRFwzAOGIbYf0xsPb8ehA7sXOaHM90E635TjzQpVdKN2jF7FuPhUMpsmbvmPiNHMTFNapbWYlJZLsSyxXvBtWKHlLS/ClgAiDntbsIUL+8/nCgQd0efduCfXjZzjhfVGsaiEEr49qfNega2OOMvPgPGsvQ68Q88jLDlLLNuvWnXMIMci9h8WM4Qb4ERP1QB9B5kbaD0uA6D2ixrkuprhkFnyTdV+npD2g0qpg04S4jmqjsRsYP7/rn2SlXzvD/iB9D7uiPwIJR3V/Hx1JSki3XDQZZmG5ilxEmCOx9wxnKSn+YZ8E55q49pJiwA+4pR/JhzkdZ2iD4/vTz3mptbo6Km0u2ZRfADSNGP9bxZX1zoXpekmu4rwweb8kEAIoi6TFv9XPWa2X4lwKR9DTqcwsnxisqfvedwMkHon13faQ/EEtAcTVLFvtDhedKya3XD7+wEUdlWtokm7jIlsCoEgJdxXxs62ergIhH5ZfR7lpom3Oks7xInI81tIQqFOl423oc3E0Kf+kbXD+YUOH6Tm3orB2jaDLdl4eLPUO+nLMi3/yYJ0j23DHShZLeCd9/lfjCwtPAwwXCFxIWzevn/npS1ARuTgalliYjEDPzXQcmFsPqg5Grc7LGvsfeZoFVawAB1GhLLyImfneFa96G8VA47ovOt53Fce9MQaz20j/g51EM8D4Rej1ce/xtFM5tMk2golzSo1cFpwMHqo5duTfPG2pz3J9TAmel01gKhd+i6fsf9l+j0EkuCdRgg6MTCkJhL9oO2eAp6mBGsUXF67xcTMsyICAUZoT+PdF5fWt/eVvjVXYOIRU4tv+ikxeMGQ4c42XGdBxA5HZZyyM9dz77g/61S45vTi+gKvnvtNdpyvana7BQ//iI7Efrbc5fbgT53PQ+jbY2GyK9qWl6T50vkPFXVP5mGBro/mUFlITWonyO1O6LfR091yxMt3/Rib8BwRwOJvfvlRBPGZdfq3eL/Tbj00FLkVsfa3HjnfhYhIAcWX6pjiHK/L1qiqXeE6aRa/aIbMNnynnuQgcz9DLQDSEr4GmqfFS8GZOZ+NAzNL9Zy8QHODDYo5ZKUDbl2OaZj5Fkgt6JcQ6JapkIc4Dn2ChFE0HkEr2jmyAYytmJynG8JGhcIP9pfY5Jo97vkrHtIhgdYJ9U33yE8do4jWZjxaHDeVesPKQk0fwUqttqLBQsfdJhdb/0yNO951cqG0OyqMKUrMuSZkAOGvqaELybitqUsUSiSXYJZwZExPpUfOp3El5VDaiKjbd/GZqFeITcQ1IkPFJgkO6PwUBhatxJn0fKxR9cIpmaQ48yhN/yj8ZG4QUo5P+IcYsRLXehgEVSCGQX+d5tk2JRv0t1KEa0JLptemwSIWYIYbsmAoylPrdgEczL4i5chyW/NdEGPaE6Yj45wVGLO5jMwWK+r1v8qn1MZbCA1uNdrKic1JWs67wZDn1qR1FGyolcL9JwUs1C+1oDlSzbOngNlG5TO1H+Utiq+nK0PqqBoQtFwpKwSvdlcwn9zWI4OH5JOKSBbXbxM4t+NNI2axHMKiiVfcHKikbWkr3XCblJL/LnEb9Knf7eikGtN0hcIkHVWxBpYgmL47484dh+Ja+wVJhTX9aIuCVdgEap4yOEI1esGrnNhHks1Bi6zXgELMjNVfXoI7o5wai7YNv1dOHN8r1xyfZFG5VstmsvNexbypDCzeQYuTX09RV0Gy1ol3buw+nH3Y96F6Z/I6Db2NOltBTP77ndiu7RSIdzPzTyRzYHxd+P/4VuVF+jWlen82q2LdUu2IkcR1AGspCXNSLUXrw9tXtSyAjcMfr7nWViIzgpsx3Nb9YyyxcLZZu6iQ1Mlz/VmoF+/qZ5TqUJ1PkvTfKdGCtcGYLRkj7oMXTE8t4cPZ3+Z6jt1WI0rPgV5K8RgqTdBlT/GCIUXUHZhcpXe3Vj7uby2liViriRUzgxZx3FNrWxN8SiGWyUjsCdPJhvGx1aVW2lc2Awnunkx9AbV30HtHanu9i6rBRIEUyBu2yaoT8IS0zdfE+yQrZKuXMdV57lXKcwgPf09V/BECeeLZo1oMS6UJJwyxTR1gI3iMGxekRzlsKXjkGf2mDwjEOEEc5WZ/UTQX2QqbrqUIui/5cCwQMGmCXc1OemuyHdZbSiqBDf2/qXFJARf6Z2jhPmiRgEhO7pMoczFv7cWw2ShlB05l7HYuYZG0Gn/fQlxNyfRSdZHra0wxrTR1Qdt8pSVHEOykPO8IBUsrd+sPM4JAkLMGI7fw0LysUpQ8S75fvOeINJ62b5S1nts5m/lokjbG4rMQuZKBi13IkGpvODNlO2Zz+GavGv1OTwX18qxeEOkYypxQlHkD9Lgw3sLFkbS9HH5i9v9Hzm7i5HsEOWNoe3rXNqDpaS/MlRI3PEMR9k8wDdk6DMBTmz64+o8cB5xCRiNaR9VIuqbRF63t0Yyu24KxQAcXFGwjjoaQEfd7HFtXLqHihDRCMRsnX7QRqO0ruhIjthFcqe7j6Ms2OfmPM+K1PTZwSPlPuQZez8l9W8K9gisVs63qd6+HND1ygitKBlEzHHEhw03UPZ4ynAjn3QsevsTXpWVr8Y8J00plO5P8j1eDZzyI8NmRdAMRuVfvJGZ8R9izYVc99gtGKtvHkvMOHdeuHwoUFKMyvIZ3zE96LzBXqNn6dkSyVCQXgApUC6WIuCD+1fuh1i2P7X2NVSV/45L4FXLwShYL8U6PiMwnVKqJMTsyzOz5keZjF2M5onkZeha/md4Vs88s8s4+6afryQJqkcdLkZWifgmydUUNQk2ZQRXWOzYJ9v/5IYIICZL2Mf9qnoMC5vwNS9Ah01PXQRPwuXKTuFduaf90gWNNRcexvuja6QkX1NlYqwIcsi5JdG7tcGEDL9/iegc3yjLwpcnvN2BD/Qx77tKu37xyDyy+ZQn7MGfw9B7ZESvJpU7kE3qiqc2HOKdEnX5e80Sn/BPqFMD4nU93UKNr/CL2rPqKqEoFHSBSJPZ6N+HWEX0SDnuYulnCdBcvdhJoKnjgi+VGbgGjCzETNnMRIFitOnlWvF47OHPUzx+uDpfrlvX6/vIQW5L5TfPS7JB6kvSUgUfaaLpbw5eCmI1J6A/IKU3bzcvLuswmsuVxIuJa3zc9j6Pzi3PSJSFa2i+PpbUahq49dY/8GrqcbfJtpxrNvS/c6C/TVFPvXaUT0IQ56FcuAVJvKu5mVIxiPpdZuCCEgESfr5KWcYAubqRFZDvUsCrMIcBlLveu5yjZ8qNIDLliYmpFZUhGlTNznTLvovtQKeqTSCt7A0oZhWsjk1Dw42t6ozX/00fkxMVXdjp/v4iUVNgnGqSx3+GoN4p5xiZ/ceKl6wrQg42VxJXoVcjaay2ew+TMF5sgHzAJc+vzWl5KhB+izgYzOY9sXwgAkI7FrWUO4EeBfv0goRLoJnWqcPvZz7Gi47Sbopfp3Sn9WyFGJKhCWZYXGb3xPVZ0Q3bIdbZG+PL4+jRswj9zFo5bjFxFLXPRiKjkK6AWtwmgkxlPtX5WdSgNEr4IImPhWgSTXbHeFoeayCGoe7FbqbVoPL+gyPg0xsunSuzz4HNuEQuTSwvTuSIFw+Zix5laoNtOBaqY0uIvgR2X6a4M4KFHHHI26z9eW+MwXUfev3tLpHifFyMv3vzz+FwHNAtK8IpHtkowPhhHUUX987Rvz8oaQiKAn3t7f7inN3aGJ3kg0HchoV16NM2JvLs4wYiP90sK+RuVWVeSH6o+q+bFJJhI19QYpPwpDMg0njjRo1md2JU/nlA+2c9qq1ryO9UFp3foreDmY9NA7Az4LJFCENEO3AT9VMabWZkvplyZt1ZOkvncU/TNAp34nyewqgCdZC6kaFi8dYG93aIX43WsYd7Fwn4Z5oJ6Spukj1SvuCX5QxKK23AJUcSxMrRXBYOY0lUEUbx0BMFek8Faz7XRxdHbOyXqB4PddkSrOD/UQytdZosZCRDkG4I3EDBNBpv7GZeAJrARXeomPyoKmzLiSiuIxhu0PFkeZPXTnm0QK0pEr1odbh8dNmsP927aVzwvse8wCoFEcfYudLd2jPSa8Smkv6UFU9NkyBGtUFzh3devwJSf+Ba3B3eoXoECJuQLrgrF2HcOliZ+qoow3Xu5n6Xzpxkbf4GFMeFNN9GjCyP7sXXpb9xM6aNWxRIobZqFSiKabNyYz4lz9qHEgCO1aVo5wduDLvGg1nI2FtAEGuFC92yAt5hVtQU01e1h0fNDkeSVjWnnoH4fuQ4+YnLliIeTOrbFDX+izcEkVsIKtO6agXGi3mDeQcwdMorsZaoilSk03MADJidWGbalONJlVGXgkYbsUa/tnGwgyfCmYmZIRBJQ57JKMsZbSxPKTDuMpo5vTvHhCV5MoVUWArm58R0oeIKDbsHZy3KVIRazm42/CFAiPYRCqunP2K8pQ056EJS8zD1SE66KjEzlf2nzuSz34IQdTzgFGxPNcsY4CSL9QlHtZ2+W4CdrARdi9YKZ43cyREpYqAsmWdqhDgNm1zHFvkkMcQlAtxBdxj0/hbMbzr4/LFI0ojrbv+40rAksYYgw+jwa+THh3k0IzQecW8CK+EsOZxx1pDgFDKkgP0KjobnU3EpJ0Tq/GxFVbcAH7Wozh5bdRGlG/SLLOE9ARreMBx6SP8L19QcelwepP43TJ1nBgggapavPE9M/ZEdnjjj5/QJlvg89o8b5pGsO9sbWj3FEfbV4TZJy+82EpHW92YtKolmStQI68MbMd4tvKl0Pcvd0WuLwGIcyYaZoqSwnWwO/klhjJ0gJTXsaRzSq2rLzLTQMP5ry0RLJL+B/vdIrLGV5lKaEfzT0jI0GzCaWkGFlLjwueFTWau9qlQr6PdGgAJxIoRAZ9QoV6A2ozdM9Uo0o4SHOZgXHJIndfljbQUh8aupnzmhiE6jS2HsZQttI8mEkZSiKMDzqgsP+yZTPIvieL8xJmUd35MQdwgSBxOEXTQnBABw663WpUEKsuzHw51sqRVoFk3LnW5WygfrqKrI6xNjhAkuWvHaAXLy/y9m6ph/Zho5Lk7YcAI7s7+evilPVTG87DDCuBZQNd1MTJiCKf0D/6PJha/dmkpSbiuLXd2+y3aITCLSf6DZoxGJ0bkDJS6du5heyLQd5OR0tzHQK0baCu+hr0Ui9eQ1E82SoIUv5xRzbsOUWPVFBy3DGoiIFnNEjg76pvFIPiS5DiecRlfslznwb/LUwp9amyDvmNHHeTMtFVTvOo1uoLyVQps6SkRCQwdyjZOwfel9/3Lhff5u5C/HT7l1w7/Fsxbm1tjhTnAONcM0I/MQi/Ug9DfNmA2J9420424BOvyuB7KsHgv0oJ+CnfXXBtilN8xKUSYyAzRw7JDqNg1J5Xx2ghhojRnm/2PI7YAQefCvjAbiE9kLKyrT4AjS9wjGzz3PsuPWFMwtg7VvAhsJxaVYR4Icki2HjQCeYjKIJid8rR2kjJ9ImNMBxqbhR6n3tYWFDR5vJlzAot8gWy7YnfAd4c0m+AgtHBxpcI7mVVhUO+hTsekmmSTR6RX7h/dcoIr6AJBVvc1U8Dzwyf+HsXpDuG/IrAYdnRJFhiUVBpZ3wahmMV58bQWpEUAVtsfs/M00TUXMeil4rgHfwl8xjIM3DGZqxwnuLjXq6Q80gtQbqEtrI3Dxnv7AAH9OMiP7VmEaZP9EpMbTU8qeNSn7V5Lvwe7+Zq6CXyZ1dLMNl64uFGI1QO3qVjQMSyQ2MbomqXRTGZX37OfXzj5qeAXr409FMCbNBUZzv2Ffn8Ik0aBVagYFJ6tU4DfXx0vm6+FMmaOPBU6+UbXItnMCVS205AP6nGfXE4jzpf9ljDlFJ/LiWCGr1HXZlZyNXKMSW0yGTlp0bDte7SyslvbKvbYhNRb2T7jmfVIjhw/x7zNrMOW8T7sK+958ZuIBezOMHL7vP0WRBfF7NLwLHxUdscSrlBBlwkMtLkkUw7J2cztTefm3Sir6cwR0dNyOiuYjU5DIqWpb1s61gDfmET2q35vPf4zC4zEdlzornGJNBGNg163Bb76OLqHrYMGclgona25YIiZu0MhcnVm2qZo/5+lnIA/PwjGZOlPHb5NecP2ctZTS9Ux7xDJy8TFKL+pFi77MyRebBSnXYB5BuwdCXtyiSy4TtXTrelRi/ATOhwdRCL++a/l9KbSjrLsNBApDJgvc8Fgo7dMLM7n+Uo77IxotI89nkUZjJ8a+8OG9EYcirCNjjHcGl9Gvq54dt7oDHEepOuw9BL+JvrdQvh7MRGO+s/36HdQK3/9MI1GzPmiR8WG32DfU6aMtu23Lx1JRxHuvB1Eh1dINY+loICmWz5dcpUEhSepw6oB4ldeWXq+IaYZf4KMKWlw2HKZ4WD3CIXtfCFfLN+P9IJioYkPds3HcxbM1aix1UvMqDQkk6fwM//Phauf8x9NqcutSbEXKkJNl+mgkDsNLI1Yiw9cz9y39uP2OBxGiN7660xWp3RGdCMUwluI5g/n/s7xpePJPJEnspIP3tOJrbn8C8d/2TJdhashNy4/WByGkgzJ0fPlC46yvYRWj0mdu6TWYLafHAMsUsFVjYea1EKUJjA3M/++JsSwJIbdZDgGJQI3jDnrpFpmTGKydmY063ZtCVBk1WMEsw66yh1qoSC5tft7j0wr3wzz+k01gsOOkDPDwk+egrGR5KBXLwLJfVgP9nKOQXA14Y62AfIQJ16RZedsmOzXL4QPlD+s/QvJbg92vGUpCK3G8+afwyCjlAJWq632DLXVIphFz51Jb+LvKAHdL10G2YKCH45N4f70GYQeFha61KwjJoX+dhV9XVG/Ds7u8eKf5jaSHrgCTyT+t3+O1Q0vgcOCGPMsI/wcj2ItNw57zc8sfLQaHYnFrCRZz6Ldqly3akmLKIcE6Yf97voMoY0sCg+iWbmoy4sF3PWTer33B6aJ/fQhoNd8rQy2IDM7Yq5d3pCCl1Z/RS6RtAOrswrphn+MZOuN1NfknCeKxQY/vKKJhWcplwQM2FpBYXFwjW8TXw9phCihlROyC9cT3f08yadZ3dUIwn3YRPOBOpipJ5oBqdqMZiVQUtXHAO4ex6mFjxtw+n3m/cZygXzlKdjwCRoydqse3qtwIN4bQNOQvwfRWydqT64Nq9UzE6MQQs6nMMUHJk1vqpwL3VorF8G+U1Pydre1t5OBz48FixEtmaX0Bm+GosBm1cfJJnpBLhUg0ri9lCIJIWr4YnZIg57ql/9+28byg4ysKqsmaAVhN9ZNEPHjjzhDNy9s6m4jTveyQssU1czyrU23BQk31tU5wxk75vZjWq0zetkkSVhUk7w4jIHAUtFFzXg6FXl9hb12RY0BK6KkayI3EKxYSsnix1RscTzDpB4d9eH+TqnwDXQOjEejLVCxDBgpHL3aUTjIg9r332SUTh87X6Wnw4SLaMIhSTNBtOQrp7xOVc87SdLsM+BdV46Lsdm/IuhOPSx86GNp2i6MH8+iNhMUiIAk+z3uj8Z69dDK4wDr8L7z113GO5PMR0nbTtW0sInKlK6TS/Hv5Xl2BuMXe0G631ZkRLdmo9KTnHrInsqlnRBCtQF7jZAmKksBedhHfVtQns3F5Pi6K6gtRJfG23bb2rX3ZivE15HT0U1K+kW504rvVa3qc85ebcILOohJCGJakykZ7yVoHYYyLdC+j6FuCCej9VPySHcxVQQPGPzDYCbDdq4qrX5o1/QIvDaiHBmbB1iz9HC31tcohaEOSXbp3suhOuN5wEjjDEkrZLr5xN++JUTQ61ZrJ46DY7F7mYB1/UB/T8yhI+bFeQoVfPHIdKKmn+eJst+Agmkb8m09UDHbDkQcHmkr/pwRqegS+MZRw2dH73Mj02U7pmZMBONZeztMm0njGJIHCr1pMB3owKTxmztAcNdQkjZuP0e0XSUmf9qX0f1tgBJRi7iDF5mr24IHg2e8k0XxY5C4bxAR0cJxj3IqIx2B7EjifN0GM3P4W/sPdcuHkAOK/OV3pSL5BtLNlXecTzubTw6e1wPcJ9n2DDs2zDTgoQ62aFbBmpyP59cJx9SN/XGnUgifgARLycsL0UoxRxv6Vdlcu/vYpYyOs8Y5mlSNAfcobD+g5vQfrcrABdZl+OJbFjBWQIQ0Z1WFfFpWWsoIbdKootjqkMmvxslzJueeKf/6mir5bGPi+AaXcQ9FWPDWQ6ep2jSb3tzWDcdArs6hucpDIzju6CtVz10o8Kk5qegHmRnpoVawvwIKAI+TwGChlshPaZxeUHnU5pWSch0ve5xWQvYsWD6D3yJN6VYSQJpGXAVaSISWuwcrJ8i1z1XKHBD0QAef92dQx6TFSEn2rq3Oa1msQqhH1JX3ho6Uun1gc/hTeuGtZbsQ5AuDGYiu8p9fnBVpekJpa0eh4F6RCli9Zf5Hpq0fjeshQ+WnHKSt63+cyRKJ0LRdnKwLLpp8GVsn57p5k1Q2k2g+6ptYRCvWX8+ZIVRXNRii8L42h+asm0Dia+cdJzT+Ka9hRwvZlxlau6Daw0fSGlR7eItrS60xzeoLn3teq4Vcfrhb6CNDNWnOgR9YespJMtVdSqGkkFuQnlzr8vtXgO7U0NefIFPa+I2uuIaJlqtkHBfXbtpuAdcb1774tWwoNxlb9W7GNPvrxFctcy77VYyb8FvBVtlLfs16IgwW/nKsCccXryIEEOoZfgH1x4cwLjTTJ+8zUtAfTNRJwJwCSr2XFBI9BMNXw5eiIzo+rmy4RaMIhtFbrGR8oRpGgsM09gGWMms13iMaWKLfYsFFEUg/ZfNLBpMELLwYqdsAJhJHNkInryuq4WiYHykHzDY1ZG1v+hDtURt6cwgvkkTbrDMH6QuSJ/2zhNsCFVnAvYUMA5TdiNnaKqEFGpJH2I9tgG8lFz/E3krmVwFWKn6ssz4ZRCrHAz9s1u1j6wQl5LchpxkKchmTQ3nAxts5Yrh5e5+41o/JgA84XVF+iUyR6W2XI8+xlaCm8JpcI5PYOj/INie1bbgKGXZvlQvXIcezcdEZe48PFSMdk/N3G7B0FkoOC0mp247YixaFsUwGd3regHjqpb0v5t1I56PeeqTXmRclXxBfO1eEvDGYNpbYbh7Oy/f0QDY6hWrN09JB43IjsMlKSpfg+3QtvjmGjnKT1UuKZbDbnfKzJtyNUWKKWoNU8gyO2xpAmIg/7kG90Mqa47YR10fnce7eRkEsmpJsKHphhVKqpKPyDHh4h8U0KIPLGKH0qIaZA0iE9jVF+sDRn9kB3rOMLQ2FHCGOVFqHEnUXnxIW1O24jx1ee8VFj+Vo4rRkfFcVGPZX5BtLJduvVq0BCFspZCf8uFU2QWQRVzsaMR+EEFrqHEzWhEfiqTwkkJkrbCa4xX4/s+agPOAleJt9fcufDA+uQaUtGwFVtwXYh+zU4Sk2RktIXNuwqFUSWAWozfdz1yzVxaBvLRkVkCmtlaGarqMIBGnlJst14XDZhD9xCKcgDuorfHBZXH485RyywIHvYrxyTu+eT1BigZzHhRJof4MV418zGqxE9PUAnhZ2+JRJwrnOlIhkGtRqFEphU5v5PqB0bnYEVPiKyJMPUTR8oYxIzFVo+pxFahOMMkq2ocPYfVlCpKbJ5ibzuSS1cnGiymt2GEMpxvptilpbUGs6ul7v6sAc46P1StvfFNkcat7iQ0Y4cEclyTUKynFT3XXcQSKLcUU/cKadYhj7ygr7GAeJk51vxaXChJ55zii67GFSA3C0wDY+0uz35PjaulurtCjUSSbJAGIU+OBCBvxrJEdaqAXboi3REi2boGw4kYG0W0u1bTi1J6JJx6yY7/cJkpZoFtrz9FxICfpQxHdPoxt4MdxKTOC9bo9abjui4vtRgfFMlcePCTQ9oryFoUKlu6bD8REyj0nXvO2neA6haWxvQI8R1gAno3ZyFVJkn8dCcG0dBsouNFuxmIiU82PvgqtvxkeEH7fP7ZSTrS7Tdm8FL/Ab20J7nx9gcvShqn4so2hyILuF3VSeNVFHe341XGqvNzEc65HaD3TyeVYkrf3Mv1HKmDepudapOp11ddHbV3NRdAT37bzNMGVxPuWLTvFVXyTfxOGxRss5CL6VzHSOS541u4oQ6stNo0czRPIHxQYX+j0lwCyBpnjko0EMlWPnoc21JNCrKTnrAxwpdvxp1QR2PIEX8eqVBo5pQyrf0qV1GrgieKNOM8Pu7bKN5AnGUljvKVuZtKdw4n7ImoNbe/23CUiwYl2FMao3qzbX458sOtb7Ri2eBwwGV8iEUbc0HcDurIQXzPW9lkHPhDc9ttHXslNwrEgMfAkJv/r6WzwpKGGsexTSRTcTaugSo8vaB6LAxVdLEEKuRgOXNel8H7vcbcu/XnAURP8tQLaPuX//pjVnvmoWhGEySfzH9RKYGVAVeZsSF6w9icDOtRncqJBlrLCjbmo32SeJaOj44WTw1l/IiQJBOPlwfi/LNsCnVXtQcXlmnGySfoWNl5KIJyrJTRYOHaklqNPFislroG58K5pdZriFQJC+GLdpY3fYBaWhrM5ev7y505zZ6n+yY4UcFGoRiYPiUZmZwgCReXeTH8oXpDSkdJQ8L0MmQBmyQn6AdW6MoYslrLy9AwyRt0R609Bj8o5An5I0mSywhJcQHGo5ZYfJdWCddymmaEnfzi2ntrMzkfOq4IQIwmBB8lD69rk4J2CHKcQPrGmyQdUVNcJfzURM9Ru3akRS3tRQnZBOYrQ3PaJPwC9fJ7AEF9Gjy9m2gNFmXHGYMnGZGOtbX7niPSPJXwEbKNpVVpaiL4Nb9bmDWsTaM+IiSiH6nsn48m0aYApU76c8xQxSMC5av0Bq7BpH6YlMcXZ0Cc+mIB77lnF2JzalgNFtkuGavnjmiy73Hi+A5pxbp0uDWjUSTngCzl2akaydtTY+sqheEdtgFbCD6GwLiTAo7gmCelyMqupUGyhe0oOYENjeX8ddj2SoAUVFdB7jX8hO1kKoxZHbWYffb60c62iWAWRtOIW5oSVXLzxO9OqMLpnyviG0/IzMyz3Ykyvd6crBlKS44cVmamEphtEr/yish4NYlhWbV15owLVIEL/SpjOhEmqte80VTawD/ee/hDeizXAk3KJe7HBT0oUYXZBle6il5tlgxmAzYM0tgKhVoZnGif8C0fAF91noSO3rG5gvTsFKRCZFJxz+InwX9xbZBiE1ANHaFy0WV3exrJN2ZIttlrMBYweJeXtIHnddRJt1w6Sl+Lm4pccyCqcRdiquvqZxSNCowmA2Ejh2UqlvIDDc9HFnB7QXs82mntZ2i8CXemxWYISu1VVFKC9fIljuoOPdANSpxbzCZdWelOBeiHlv9T7KL6TiqZcjgLAE9kRBXAtq8RANmd98inTst4IsehdVnuVa57zD68DfHiFqwJBh0tS9OsVvQzk6sgsL0apmSkFVlVaJUBDv77pgFjX0St7SZcYecZ2Fyg8/AsxQa4K5v906lNCeCXOO3Oa3mZWjDNIovCHSPyDgAOW0uonHVLZ4iCzekhqFdtXatZ260M95rN6OF7dqNMu/lEnuOA6Il+4UgeEmc85UWmStVZ6/xnUw3DqnM1coCimmCFKSkVYjQFwcY0mRTmKIHRDR6xvczwa4WjYavawhrvjyx2fhNTuZlyHArsCxXvvr0nBYyZlTEoo1CApBjz7zcTs2CF7M51dqmOebvdfSLOxq4mXOvP/QAbXYjTFoPIFUJEX0XfUEThoxJr1S46uaIr1dMAX5vgijk38yEavUMC4GxYI8iDaudewFVO4ZGmnLnM8N3++kZ1oHpCSEg2YyXkbgWXQHYaK96wgG8cqnrAdCLVFJsZRVomCP6PdTkEDzO8DjbAiO5Aj746+wdU6CzO4TZtRXv2+/1Z6MFhC5Not6hq8SUliq4+97lorc5dCIfJDkzOW7zWsHUAwvcGo0KK5R350TfF5YKkn4PEblQ56M95Hqt+aWKyyaz2nwSnsZgZaAfyGwMC2fNrkoi2LSXv1P7bRIxlQgdJKbg+Na/S1MsfjaMd0oDbuumuMmrIW8uYC/pAEgqHK8NdZZapyQE4pyTmWAi8crPup44g76GeGlKRBnw7+wD1QgrOdFfC13NrIxSsPh4IuZbYLDkLvsOEb8tIrQ3bHfQAMGHwuE7ByXRybfqKeBLBJ6lRGS8N4sVf5m7B5xnkt+NxG+qFfaLki86tg4CapvJPrQswpT+/JWfHRcB4REeF9hNQXszmJn3RI3UuXz4XXbYhrBtcbjE8+PLeZUzbVtsODGh6QjFoJ9XFDI2p5TuwbZ7gxrgFUw2Eg5xRy1qBPIsM1fMvihefscrdKoluknVCFSxGDftOjY2B/6/HflIKosWOZ06feat6NuSo4zc5hzr2dJdMygfib/8EAKhW5QYbn7vejVdPvsJN49GEOpmi1eZ8YqLh+wqeemupOWlEhM8f7DSq6SkiZnASXMzPo35zk9sLs8S7YAgloDjQyoOwtBl5h4yFGFTpFWnp7Y42ps3kg0cvW5kOV5lSM7/DTIf3zX0PlY5uYiyDTLVQ+MBRKVW9jaevQu29dZ6P21IZzaZ/QkQdFKrzOZAnuDEkJKLK56oDV67iIru5BT+FeLz5LH0HssCLPcz2fLGYkdsxIvEyHitr4XxTuYeN8N3l90DKFuWieClf3yAx9LCBjXdihd1UAK7LB+jTGkW/ftKtoVPI4+hX6+1buw4wIMQvzbj3UC7y/CAfXbAGrYN0K76jG1b/gFddocthcSZ20oNBw50U8TSJEyq5cO1b0qNO70gLpZDmVdX45e63ZHf65nr3JvZ5lIQ+HpkRSYKUsjG5kjumgsSO6MPRd7fcm9sv2ccbeUrCSJcjTeQ4l6ftQqyCzQS62fxplOJ5MOKg8SjJjI6m1bNtdPolMsg5u7Wy8VzSB2sW2qYWF25CbxNK6S4MJZ87gvgjqd9aBby7AOMzP2+TORPQ75Q/MhFFE6nt7cuiGZbNxeMST0J8oZhglihmzlFxMZHmaGd7L/7g78WuNLosEZt8sXZM237GdNr2ej3x2nBkV6MkxvHXr5gFDeoPKkVhp3Fk3LXZvi5MJxGa4asIsjFnEB0/j8YW3qCTEDYDRU3eghzTXw+G/Amj5gdPR7N03QjGJtFmyMY41yjMK6nPSXwJidBcG2GfirN3I850UMRpC+WFQNfKjFhd1t6BDNp/8leXJVkpsRHBCWW38oUKOmgt/je1nyS9hfcg5vIEujUBVghvDavzABwLoEI9edpDJthiWzYEelwjqOemSS3pB83Yal+CIDNnetlRDcjJXQYDW6U0W92eg2VjVZ87eO7fRNi92j/Llssw9Sx6/A8NM2u3hKYWTB+HYnxU6rmnIpaW8d88FclNPnraUDKaf2A3UX21Lh1pkDQ27K72QoCIPVtPIh5KBnw6wFMGVTdORzmvYWhVER3tEhw2MCAaWsivrr2P66QucxhdlramcwuGcvVJ7sfXCXC4qpoHmYIO9JQ6odAlLW0H4m/HWcC7tKHsI98d2FQorqN89A6JglTml6KJoheygUXzbJKf1O/FAEjSQ4WtRolZ7levkmo/doVLc0kRqgw7WqltO7C3QrsRYEdpclzuh64FcTzSnowh8mxsDb+mBi5OcHAuWDhIiiZgFcY75sqM15gFXKy78WaXN1kyu+ABxBkqSTVe1H3Vze2oF1lRV9y02Kd+zEKI2fnM/YD1MFQ//RrDCsJw9MHdfbq+R3KTOEuz/rk25c6qKEJ3E95U5H7qsdFjW/La6UeCUGpBDuI+POs+QiRabBPLOMZv8FJa+ojoPOIBKJYHbKECvS3cWWPRZUgi/jNwib1k3z3mas19qq5uTwij/23vipKZD36cEnXDtBlxHWexq2Zz6hdgS0HJnogrvgyD3Q4eU61VU09FdzQ9AZBKWEPCleAsqn1/iY+bfQR824tYFr0rsocaX5FL1goKEjbfv5rKYnj+jks5VplV+GEsWh3hddwGAeqBfCxDLKdeBtnoWXNSqHufXiWh3H9Pi0skpRSriFvIRc4RAhy9qSJkZ237ziOx0jaDd1iJwCHCbpp17gxs0uhG4mfYu34vosphNZ4APrKNr1y6X2GjPLRxw7mcz6u87DP6fQg/oj/NGO++HGg4zHqhNy5B5Y6/5bYVQzrzBa6lprat/EF78hLBmDOkoro5tgJSsdZUQ6UY1Qc/vOGT4SVBVj102p2SLFW0idnvrLksqr6iOt9AkWGtxscr75PVd3XQ3t4mDsR50IsGirS/uLSsJSKO5DwOE6ZcsdtQ+w93TCreFavagIm6lu7RgmIEjkTtvDcYRdUQbzE3dcruPbv0XF2nhp+WJfeZDWwIbRHnbww++8J9d4R+zi55XbK7kK9tLZe3PrwtqY/B8M2TA2BImNLNUbMOH1/OkDP8oMOcZeqVhK6ZvuWltAZW3g2XFh9ik+bi9SatQMv28W+9zGBfe5U1W4KhqRFYcSEq6bxRv1yGCKXtTkmfHgWZE+IlLQgi0FcV0gEgzBLlhLMnTbUQsLsXxC3xf7dNoVq4qR3C51js0kpiIkhNR2wbt+N7SGnI9aI9eXv2kqhkj/0WFYYgWxDxwEQvkc4HakLHW2Wa+gGD/TIeHeurX5ZuXX0ibbppBV4eLj/V1OqyIRlhMlMPmEqjOyhJnDBh3E01CkKc0XLaEl2JjcrzwRZliJ1V5t0NFKzkK4J5cNFLRCYwMXAKJ+sNEs1zwm94I4xwU71MkHOdvOGCiO0kSmWhGF4BUiK+hKvHK76mX1zMNrYxYk2QtuWEPjd9vWKSRE6fVOBxmO5zzLbdVGubQs6g8aS41PSDsfzQc7jUIkLfFY/PHtB8esTvmX4UNoJjNzzQTR/SwRpa+6nykItrJ9Jk5gIETKX3qA7nHCiI81beS4emR6aMz4yHwmkviXiIDaP6NH9g03qFhbgy4rU1rjb5R4NghnDJDF0Rscc2rjfNp0svmEiNhAbkYGKBDflVr4kWndUTU6wrs0JeDhdviq2FmmXfSS1cl7eR08HhxhE+oAfiaKKFNnun1XUYNBdGGNXguWWj6rkdn+xQn4TJpAp57J6N2PWZTGfSy91haG9/TvpNAwTrWvxo1hH7W7ZSy/Qo/28CcJGrqmh0FfiEfaUiy3H+2E3bj0ZnI737CAZafkr2VRvzwB6wddmiNxMmvcf0OEiuL7VAn8vLCQ7Rsb4kwO+mjevbz0XGzeRai+fBQVRtcFO4hEZ9KUjytg+JaiYnS9F0e9Ku/q1IHRNRJLeOo/sFAH8TiNK7c4llZTuncSIo0CYLWetE1a29IzDZSmvkPsNnWrIlQm+fDZHvAffyQ4YQQSrdEs/0wP3CLoIuoytwcbReLi/6Cx4tIo1f58WrVyb1HQsz99SX4lFoqXabiCDZJrSEyDtZjOhrE4JXQ+gBunywrfUdwoqZLOA19ZLaOHh0Ik+tgep0iELdzSY83RQyxSa5Tat/98QNUUvHyguYsoa/E1vbPGr9bfr7w/puedV8yqWmKm8fQ7ezuZjDBax/mbxZR6CtngXv9aPtkOKkbKHDTso5Cuk6pjQ+VWG6dFNFviJGQruMUDmycYq1V3JCleWNULbZu6L3MZ3weUbb/I0I6iMer9y9+B3VyJmTRTScr/OSuey33jjVqBrza3mcTo9K/GbxseMWoy+s0ciKvArx3hBSsgz1THo7jRGX2RM8wWFN6MoZHvGxtgwGguJNclopeE7fyL0BbJvzpr5mwg4VHQUA5xCSoGZVmIglwbpeDP28qgb2zgyb/FJb9Dua8h6I7qrF0yJetQV3vNBH9ngpkedytd5uQRkmB/L1wY7SoFBLjpxJKf1xyMAYRikupV+K3rT/J60ndX1rqP8svO8ns7Q2bhrjOhETqK8TSUzF2/QYQB8g1KB2O1CtdsDbVdndUwEaSYiQyMGImcFsCqNyrvodGSy+SYd17MNcCE5KKqrJssoLB5B8Us1DPgeXipZqOoGvIQ8YPxmuatvelW3w0WLxJoP8llmzZAhNR63vRoizZSjU6cA1wxWhC7orA/7j1ejh0k2pkjLiDaHspqWthvgCCXRz8m3HVJsM9XzAbChxzXmv8Zc+Dq0cgeLyNaYhY4Ir/it+Lu4y1yJSyXbdu+JOwMOjbpZim7CGq0Jmhs26m512IrlMDlW5gnul+C3ftqgTKZoFtOrNHKisXrsvmEipWgiAP04vv/kJBr1LR80zplvb02F50juI8Od3ZaeZDZJm2FFIpxdAdGWxawPlOHLunbu5fT8uv1GAPRilfH4eE2RGth5jqZ5MI5Qi7vS68XkCqqKE3VeovfCFpzXa3CvlOODRu+mJJp3Pr/iX+2vunmwlq0/Jv/1iS7oeJqM3iXsLWIat4mrJ9CGRXVbIkpLWSFugtxJhLl+MeY3HkjNVN6oyRul9W0hP51QFWyuBOAmZUthiM7KPbPO7eUNiurOg5EzCUvA80crIV81lARq11dbCymjhYGVkQt92appCjnLyihBbu4DeBInzBjo/Ye+FdJV+AteMfEvZMF7QOW2oPVWZUUSWU53/QJvGiTR1ZQXbxXI3YbnQoyQkA8J/HluTA44ilUBSiFCGv7cq4jZG7RXQGuZF8EwnS9UVEp4eLHX+raIMv3L7UVVF++RrHrUXiAkRPHAb1XZKAdJZtaNc155H4jXkcT4Z2IeTLsJXgcBYavl3K8XU880P3Eza1ILqMkNr2ePYrpza4YzQJ2RBu964NZjS9VRDjkY01NsdYomQQuFOO43Ov4OA1AjzNnEEKpkje5V7Ar7UgHHYGGrXo4AMcud5iQxvq5OU+5Htm1u9hctjQ9oL1FlHBNYvslzfOKe/Eyut+gafhGT3nsxu0+7Yi0l9oD93mMbwnKp1c8AoOYya45rh99d3qqMA5HzIsZOknVxiJkj3SxYEXkZBTbYETvZfwUlIF0hF5eflkxCeZqQ87vdkTSITs//bKymZn7iQA8lV4QZrsMabGh0mh1gCaQI0gg6zYOWIc8ZqN63ML2wTlGRDRYTLuLFzB+Fk8b1qRZVG88XzBM61qez3GCnoESwzcykcJuTMaYJw49fRoVmFpcGi6ZVYehySU93SpKAqlr7ZTQv3Ko7Kb/kI69GCRFMCegNiII6gh9AvctEXyVwSbNLC7cxwA82+URwlXQS3RU8Zq+jxE+xaGd8XFCtJgbqci4aALLDsx0Xl1qr+GhPUQNzMlMWheuJCBt/ZoWNAQoN/+858oXfoKTwGtZ/tvMzVTnvdYvCc2qSf3AkWDbSrkMR54+j4jM2I3tBGo0+H+a0jiPPCx3iXrPD+jFzstxl0JYIR4VypL/oD+kcn71VR1SDVbwfh4OgmU980o7icgAbYHj+uvyVaiE+yaJUEp3cWN/bMySiHKETxjY7rH5e6yNgaCBeOVHdwlhZ2RbZ01YFJdv4zkTTASqVA2VDSMkyP/BrZFbz3V7lRqfgWL3ay0P3oVMAjXS27nFDzW9bcUe0DzrmS8v/u5JUthokHMyhdzwF9EffyTUXym8xoGnFbRhY4FLINbj/4F48L5Q4ETgshMzVC4VoUyubw+2x6QbEZ92f0NvINj+VaI8F0GldDOBm2vvSoiLfs/M0wLMu99dHncXlgnqNIpwoKUhhakbR9YLsBDtJUjXlfwNv/VbuI0l25AjeLLPvUMy6+xy3K9i9VDPTgBKmkmc/S4z+E46hi5X4EHkxGIRYZf2DwmrZW748mWEuqBkiRcPnZ0xLB+Bz+/ytstTf17XgEk4t2Ic9RDJBTTdlMFh3WZ9M6wzr361JkNzNe4+FYmmsFCCwv+ezbfwSQ70POTfn2B9YYerYTXIv86TDAoyS7Y/vVp4H8Rp5/tlGm0ooecFsGEIngCzqXags5jayR0atXh1eZsuRfLSwp1UAc8Y83JsgsuW6eqmDJkV+Jsqpm/exQ9E87qygdjnMIQQnXwnVzJNXJ4lG2opUx1NNoGJhXhTkQSE1G4DNT0WkgzyFOGyoOi1tiswmfd8tipTSslGsEaDereOwTuQE7HuS2vJImnljbYIDU2Dqf7Yrlrj3eg49OQ6Re1oGVAieHm7jIU5GaRL78/HayDm4PK60upM0+h6XcdrZMhC3VWXkm7tYlCsXggqa4lQPMVqUVvto7CirZlSXOwqhRh8vj1g+2owt7Sqw3ph7ovFszhcZYGGRXkGXJWG2t9+HSVMjRJ0UDiQF5EIBqt9Py5if8V5qqi+8gF0onnFrfOkMDp99/h5iYjacP2TYtn0yag6PLkQmddPerBLsv51yYRFnmwxbVhUFANzhg0oEtuUuuKRFejL3LUJ2Eo6nwoN5idIL+iosQLvTSVtHUrvGj2O05lA+RIgTXSwSR/BeCVC32DrlyJ/ACVr8d7TAU3riRI4nvyhUDNIc3a42k/8Dh+pvXs3uzfVd+OzYbS15f6dUQy8rZvwT7Auk2rp3nen7r5SXrF2ZXbRQJ43uuIBNIlw5wE5JLgt97FRZhqHBmxIMhV+Z6qgk/S6s7lk3QzQOjEDhFNXYrZwv/NPeHhW3zXetsUKfLD6UgFvPaclApwmRVRmCY4tynlw9vhNAxOqh0YS6Al9SYQLuQVgUPEUj7RZIRoc59XrJE1kHEWjEaEO7xo2tK+IzknosAAUd3k0gxhpQHl99Y3TIe+97RxBEC27/ix2rgZ9kyDY4Ux9Km+aEQJMyJpj0ekJle3EAQg3U0cwU0+bqeLArC3sdIGK1L0VH+shzIePmRu3/V1taUrzTw6fl95LSjcocGtspO3a0fv9eHiUIDO+iw0zzChq1NLaamxG0H/jUzSxNUrdqdan6r9yutCntzkfB3Beiuxkt/OvEYVkMqPeY2NxeBOnxZ5w3l2lFURxEc8qDZYWdloD5qHkdGokQ/5eGixh1NQccM7qUe3QwJK+R7WNQZIaIQykO0OY2L2SK1B19FCKUqsTXuSrwo6gv+A6kSlt0Et7gTc29yoIAjymEjuZmJpKwlmvre1ryWKjPvE40k+MgYtSvFLXcQ/nnZL45o9sM9r2jex0182c55hTfBxRh4ax2yy7nvL1yxcEXgfAikOAPkYUqbxrVidKlJxR/5VNqJcz0MM3fXl+lGstb8J6joi0NXGrKdA1IDYOjxZsM71WSJ4dgMG4oca1UiLKJ+rk2ChbDjXv40OO5IXsjX9Ls2AogQETAPNbNVho4FLq5u+uHJe3585EZpol7i03Rd5KHdpY55XGuv6UbHol/rCYX20BUiQmwtTInsBpBDDNNW0eOY3KbmgM7ixEA2rWwqXgpAxUk0Km2qVKALRSoZKPPtCp4ju5TK2dOcgBOy7gcCqdmgrx04XdzTMcrHEM3Ol5GSoYPICrtSF48NHl0NF9oJsAbsr2WJ3p9ymXTpcqNRc5Hmmoj+scg123kgm9eyd/fdkvNpdIMphwzJ7z/St5imJP13n+c0flXlA2I6LNo309pjHNFbgdR0ojANCKZcrb7UlwmTCPyli+UlytsZkaPdMEwZjiyxpizN3CFr5KxRPNIIOxR2/Qzx63tGGpBqfosX9EhtO56lOewuRzOkf44gfOVY0dHs/P2V4uyec0xNNaBHMquYhvhbcPdwXlu8qrTiGys8jI9wNGs/fJCn9V1KGACaEkv8gqW2zdpAWzh4M4YNAkILZYzLvsVJin1NINuOS/vVoziYqdtX8VPx/fzSoTOZ4yu5nFDAV5kO1r/+8cIcNnX8u6RPMquCoNVd2vHNyhfe9OXgSs6hDOpJoUff2XmDbIFzh653wBJvGGTKRGCQtA//pTqUd25Vv3L28lTTLEHQvtJG5H0dq90XcOfzObWm4sUL4nzpYd37qeBj7sdyU/ACXBng/6pMwzzINvSmXITRXwyWrv2fRc2wuZUu74BoJvC0GTgbP1T3jK4ZMTLQIFdlu+zjBp4EeEb22290R5BlNS57alYQdSp/B0+9GuDljhqK+RcekPMS0/tY7TH1q7ptDpi0Ovm8nQ71Z/1BvwoC95Xzf3YIxQkxFiEtRGITLGPgm9jufc0wXQxhn9FDGamEchVUr6otMULh7f90WIT8YcLptR7NhYbK/P4HsLINpxDDMfzlhPEPg/zpiSaPvkj6o8IaQ5T7AahPUkEi2bZ1H/qBvJK656NPsy6oAmZT+waYz1DGqn2e4qmDGzzJXcKx2iNsvjvIJUKJgkcyXkWY5+aLiO3q8mX0+Qy7Tszsmfmunt+npGWWHU/BYdsjBnU3xXcZZ7jScdl1zZdWUFY7bj8QZterW1AV+8Vhsp8lPg2fUG7YlQOU0E6zHtzkD+rcIPe+QV82FpoBozT9pBA9bh+Hyskp90z5MQXK7Pkm7VSPg6D4s2sQ0pRJ/J6BqZOub2YWOWjkWOboo47fZFSkvn9RmkOOUiDcaa9vRBZz4wEf4BrCMyJGqHi4XnMSlhmKXZbuQZsXnPSs4M16X4ByKzU8Rl0yM1blVjJBYHCnp5WCvGePOST+xWKirhTPk/24fzde/3HFjMnzGIoj9PuYnobtjhVbEpznD1nOVDxiE6fnD44214WsyBQa6kJs6YCuXD7Ga3GBN234POvEqKX3+kRGbKerV8L0EmCCGNI3sVTO3nQTiXZJdSh55YJt7MjC76AVqMDCp1atMOwjsoTZO4KdItNobbSFgSi7oPkXtKbt36Fvgnir2vLd0/re7dfginqbj1JqVRzriCfyM6YW/OKyjBCq/VRXP1AumKGVsQFUPAC9+JNv6Jpd6tWPktS4fYi/1I8u0+5JHafVUGF8lyus/JYiolX/R0Ut+Q6AE7NEO/s4VwS9T/wAeUzLySP6YN6vTqXCmHL35RMn44+fKw/9cjsvnzCObmZhAJpbFIJwQ5M4u9K+UnBf+0+CwqlSmJ/0Bki0IIxYUrR6mR4B8WMvmjTXiIpMNyfAOgqgfQXnPCWLGVImV4YgjxlzYXklS5CuV6pphraaAeCWqAOCpDWKmaHFxyk4mp8smevxaM8pywSYKcvs1ikUUJcAujCLolPJH9Q1SLh4nVcOZ95OladXMFNN1uL7xdxjy9QxYq290AEG0Wik/lnHkQdFu5qtH1BEG6YHo9V1U64MVYi5yUxQwpaJ6aPzcmap3bsDKdss8KzbExAnBBp2pGQ9+LCU5/jfy9ZYG1KMjflEXjKHHft9Dix/9XNSqn6tnntoa+CUGPSqtioj+Gz1Ou+PizJbl/+2oRSRt80nEMKghmIeVdBve1RqKOs9gzej5YYccoNe2IhTxBdhpNoiqadNfpDJ19PyV7X4nRoNX1v0fHnkVXjogLiSJlxRWBohgPhco+iY0PntlZOr7vdX+rFXRW8NQjTtRCE8yxMDjFSKL3ZbOQC6A9Kl+W2/E4Lawu0aE0uWeyZwmHkTIml0tl7tQGfoNlNeDwFGoJt1mnMpPkFKClwSfaGOj4qvBI6Vpr+0fX0kfj/vGbYnMmD5ukIYkwDVOHKqGqFpRt31bcSZJb4kk9FPU24D1w1d5RxY0UkC8nEynpGExjOnM0KtPxMdQomn0EInxt8jr3huQ+qgf7O5VJ2uUgwpoHetvNYM9AQQCfg/7RQvHNrzdC/6hSBFUIe0gIsuEpzdOR4Ia7VjsYLqVy+YibO3kkr722JV5q32HMKu/NO7WuXtsudmuxCWfRbFhpt2N13VU5W2jGpyYxtS2piqlyaopFskE18kToloycdHj0gF89gu64JBIROmbrMdF8F6NJ9EuKwDHT9Q7MihfGpyx3pLXShazJVPiknBvw6mra1fUgAGD/EuoeGTlmD2hH1aDYEX06QsMt677yPHj0y2PQJlwRbcQbQ8pyvP4JJ+WkGon6kOU1BHcLhRhtRRMDUcNVEJTlqsuAXXE4tQW4ea7XHrjt3rdMCgkOY1Ttb13Hhlrn6P+gTNJ4kIQAB4gJnE8oV4d4Wj9YQTJdwhvUY1KsU+F02tAIc1OuhMJMab34fO5kIhvcOQkqAgNWezFXOLo8UFJv0ynpFyADFTb/cpGX5O+jZs/cJpmh5FeYO6lCzTY/pye3/aPW0wALd+SzvKxTNjpFM5Q03sfRXSsF+V6kNApL3hsNtD23WF5EFdD7JdGeiTaia/XDCoL0GLHjhTlTyTPKYBZJm4OcXR83uGf4ruoLerH0bqIFjpCbv2ojhT+E87rUnrJQf4rggUOGbjGi1huUcq6O/fAz7dwr5NqT95e6rfwi/N21/G+MdSMsqsyVDNw2UxaSDV6cabbSFYd3GoUpetYc1Yx8uVrLGDzEmckfQd2uNvnzrZ+U6SkI3SPhjXHc9s0udlHWGoriLqyyEck6Ym3+Ms4aukBiPi7hiA1xfLMJFpH7XyuFh0tSoIubBXB5gTXYKPupVV6EILzwqJYrcbndeAI9x2SyuitcuyH6UuI9MyveaZ46ZCoy16QH9SErvE/jwk/uFFS6g1fWVdS34c6DGCZjVu1ocg2MNT4yJQ/ekHhTWG73xmsAXXsuBoq/rbXeCMNuq0Z0mKU7sC7xEg4MxFx/gaJGs1FBAR+2BQ+DP6+TIxkwg2fu1Bgf7hSS97LHDvT6Xfq6p1M3wCLv+sj2PGlL0OS13bI+AfjZ05g2nhZ96j0hRCQVJskHdURN8qsft3wMm9WCNOADKszS0fuZiTbScH3h2yRm+UFQ8WfpQu4s8WZGYzX0gN2J7u7h2ZWtrrYxX6qfn9naDmBm6n4nge+1GWq1NzA2hDBYEb40+vBuOGAdfFC+e0m3zagmQFDGSLiOFNgXZnkBrIc3tx7uEOvw2e8gIPig2LYjlVREGldw27V26zAOAjjEbVLmIwOu+vZ2IW+pz58L9vnjDqnxbCS9WO5QrS+LULpJs51r+VoAWlgSCuvbtqxUvpD94eUPHJBkLv0NCw3K8UTtjq42Bmzf2+vSJzMTzHZdatklhOI2wi/cmRtznDM/kYejVBFFJYO3ZiFXo5zB5N/8AnrLx5Xm5mIjQaW+4exx7+jt0tTmUFvGGI07qqOOzDWbrQLPh4t4A5q/St9W0phpAnobIAs316u7ibqq5gQymyRTZhMQ7E9piKo1J6x5U8F31+35pts3pZGqvErjDS6hhrdTrHmmOVeUa3O9dCNP3BRdjvmKaSF/u75rFxTIHxuvhcMZTs2fjQFP322H6n2t5wAVete74EhYdrs10S7COaQVt5xwtq0S1QxYIGwRYCIcJ21glmEZTH7rYhRwEJKyUQLsgd3mNyEozUEQ0LPk8FMf30ESxa5uV51D2WgAXXKT0opQeqzYycivhH33YjpD0TlFOWBZnWFc8OFqcmZosFRNsdm8NPGx8IdLLBZK3CoiUK9ivRUYnmE+uoRVit4bI9XoeMj7KY1ElgNNfNJoUfwLEIncfUQxnzaf1xjFj8eRiknXPFxJEqFkKowzXGNV2/z+gs/1VgCfPCHAu9nOl81p+Ws3LX5Kz65nJCn17tjzNrpRgNYpIlnxDel1tWO21YZoRZI4VBC7X4KAklgAk6OdveKT19FA9SCqhdGgxQQmsHIlLNzYT3Shf9Se7EmXKh0bj9NxjEK/t8e8ovhP+g+KPO0xNlrz8qKBOAPTNio4UgSSvE7wRhaDA6/615eqjDHZyuf3jcD2QXPPzKWEiJ9+p+9Ej6PA+hvEiL4qrk4qQcorK3AnmficgKyigivnQ4NgMyZTf3aAnksKv0Vj2LxlR5GgskSIakNKR8IwbofUDIhNzruuH6+ZhCIAt1UzouMlaAdcvvZXejsNlGVSNT9rrBtb+Q4Zx5iNtucIkP2upJegRBxOlKrETrSH8yEvCGXu8iRl7JRPWDthI+gpxkcJ1ir6SSd0eVb3xQKsbkKRrn1j6lV+ViucNm2FVBEHFiI3ME1+0vDIBo+KxGbljCrLCPJbQKtF1IoAFu4DWoKMF5EUqAP32H8LVytcacNs3gXo4RFjToSghzAmtYb9n+DqeHyMcmdkwbelkIC6Oad1Qiav7PRHRJVydeDsLdiBHGkyMZ2VzHn1wTFq1txa7Dg5ieOqhHS8GX1sQSjPcLvHywfrA0jaU63+mEoyRLeVUyE920WZ5KTc0B2+9cgiFMz1nGHemBSjRy9fl0k6aXvvf9uToD47/fdLS0XdNd4b2ZM9iJ8vmcDTlKCdAjFHNrB2g7CnfUTynCpiab8eOQYzoagEBeSR0Brvl84oCtY36E7p4zhn5NbHtHkM0Uuz1F73S8YKOPbAhDXw5xYBCUstbIVqI9Bx0Gsxia/91frhr9kaTsQaTtfb/Y7h7mF5aR17/265pFAIaAXuYvI0YcmjRgdqXXbUBQfQlU1JnSpP1QJVG+uiN9wBRbcg4raNR9NyNwQ7H2AM/qWvT8TDOMMrEY55BJkp1AsSSlo226H11afNCx0+lku7bzRk9Z6+HlS/qq0PdG8ZkO46/CCqt/wko/3tueI03Se4pV5pKAcPCxNHGMSgNFS9fJub/wPhyIW8Y/pB6ZvBesXP61MtT698AJ+UaxafMV1y7QW+TLCfXPEtS43oLBvPmNMJwLkdfo2wBxyJvlRJAlI1MkS/fFLBLvj2EheeGxBZkgVsGb05DAYCDEb772V7ZNq130KAZ8SgB++dhFc0iOGQg+3ZYDi/V/+TsSqxH9Rptl98YMdUJ4XYCZf/Au+pGPJi3UbSykG6VbUFuQeH8GXQC5X7ZDUXY2AfV5v+3uO4nAx+zOEapppxkmkz0OIaFEpEOYtOoQn19ENTopMIyXv6eUxhBJnXWq5+0sDX6c3epdtyuGEdM+I1bv37tHC/NIalCTiRkHhleryDkB21mDne+tVASzUYNOldsD7DnX7mMQGioT8UjjuYkIuV9TJ9OKZVVykuj+Z0QDEuWo7XyZZ/ufLkD2/bO+V5IzZMdNG43jaGGs3y8kimyfu7fs790DnTlP/L6XxGxJyVfADqgOIX67XpFaqsgj1+bxwBDfjyRv6FgikVmrJOcc+gQ3Icpy3lsq0FeumL9YUVj4F/4yg6mI22fJC+NSrOMvFKl+Ty1ceP/7CzxaB/rSS159+ug2TceWMjvkswigF3bzBQNjbcg3Plk8J62kqxbKkD+jOJgqRBNptjqLUhgVUND+cfL6edSrv3kCnr1wB2WJXx2CmPMwSOqkM3eKNZg/9ng0QRY46RfLWQNCH3IIiZUdarFKsXvEU8M8VHn3dbIykjp6ZG/DSqrs7ZRZnnjlFNCGM51J/I6QBAxQRZMIU4J3OFSo/3l78P12oQ0VYdmjIREo7hI5GIqpVeF9qtpZukV0Ykf92u50u4gebevZGhTZYaJmNtaCyAvyrwbeJPC0HlRehn/1+SivX8c962QmDjzlZWkSJdl4U7W9NEdsRSqCVEK3Jp8BfRp75xVCutm0cw4yeoDXcTm6gFxNKrt8tMtuvPeB7aqkQyNTFn/5N1kz3FV/74fUm9Uj3mwhu2T92xBqiKCt9ynrjBxRC9Lux3KrOX/iPOXr2fMiDRpKIKQbncXJ/Gk8wWh2IqjqHk51RywIcz0U9GH/CkUuBwICGnfA1OQxtWrBeXbWnU/QVdGADlPhIREEuL4xC0PLptCZbKD/4IPbHsewFEWh+J5Qv+289AGs6JOIsVdRPf2A9UwVpXTDaJ0OazuTLQLK8fH8rqK18Hjge5bfftJX+AWUQsmQEXRr+plENXB8HcOt/vsfOcCWBu2bZq9eXXGWfhzaAbDrATWW/0LCf5UybNiyV1vREInq0/q7B1fukc3gwOmkE0+Oa6a4e9n3873rm18d+mL2bxuwaQ277kzMtnJmKcUOto8F+DTQiPU64onqHVQILFIfb7EIOqJZA1GCPrnyelxn9dGO88P6JFabfyoQ+swuRlSowXRqRxG70NIzXpR0XZvWycunk2AYx1IdSdjWgMSZkvikmFqILdEdJJNBJK7NVrOd8Ex634X0OPUzxkN1w81gntu6zxnkUQgDdcx7tV3KNqxL0zaUpqShVvlmP9hkomiihVgeSfSpH99A9hsIVDmYZPxDP6FhtRYQ1fxJU2/JXGiUxIwxtQB0V1bmqQB/0Rvq6SlXGJlGrKkz8mMW6t1zeZLOalK2AqMmNIwmStR1AWF/EEUEbmbsAkb8RHvyHoxMfq6id1CK1RRWq8w6hhHUPNm1WBUZNCCrUqI/ysNpY4ata2pLBX1f5XsPqN5B9VZZCIGIIziwetPU9tW31eNdho3X18sxfDYMl/534/lIYxNIc6lA2m+S0p7i0TcTn9P4XNcrf16vIifXx5ezfOMEGzX/5blhnEP2Q95d45j47OLdMj3wDXIsDWnp6EHbOYYVLL/qT3UKcrSxq6VyRujeQXrOJ/QiOGRFiATENtFVKv3rCpaT2u0FJZIjm7g6GoKuvA9OPEhb+BB43s9Aa7JuqeRrhUhepnWAnnaJQTIRQRgxFzMw500bu/enbrE7a6V5IVsSsdpO8wwy22l5gLaYYVz5cloQPR/1lagDlosDGOs2i6M7UVIwwRa0qFyLA9NI7LzhtNz167iSPegsA2B+pXJzlpg4MmZxJMb0pSnTCZIqxSifwPwOBLzXSJZRNX9joARPYD1QobmRPdrsQNd+rO3naNm0cUtTePG7R+NWk8XU8DwE7ASbkPQBxEKro+2BrqgJV9vOxoF62mnIQz5MYLo1Vj+cL6Gp7Nw2va+DN4XmOGQItsJFaigVKy3McpZymbTP9Bajh+cwDfLA8LloxVtYpXR0sNJLNKkwbbVBfe29+RlwDAQ8TTmH81U1Irq4fYobrfNakfWXi9TtmGGu24DmqICfB59eM7ojmhKzve5/dKMlPU9/LNp37kAvkb/+HNS9i+OnKGIiF7T/IIgKV3GgvivbHXA7Z0SDGTuV8t6YPuQajfRU5o8oc+tp/Tbd3OSMhrWCdAjkKYAapeasigi/hmKrZUnVzwtGibySI44wxGPEBzkO5AteWv81u29TlKSzXdKj2yL5bYR/MHFHNioBVjoWlin/NPa5Utnmj8ycvRHHK94Z1UVH1nTrPFKx6yu9Gw6LMEB2irxYv90TF9j35dxDa6DOHGZyZd9BYXxh7UCx+K2mCsPiuq5Y7J1eI9UsWkHF2jxbtfwQQmgoCQTDPzfMyLE+onaRt3RUcx9eL7e30diF9GyRYcQ9yr+Rxr/qhGMU4Cwt9HuV7h6cMNgNCxzuu1PD24qSBiRBEqed6OBGV5KLx+HIM1bLanWL1HByycQh7otJUUQL0k1ld1m5kOAouayY5D8SFvHIs+Brt48nrlIAlKmvKSboQ2I1JZiv+N1VaeFIjwIzEDwZ+dVbXAUvJImqSpz4+7e6z2Uc9cB0iMFUx+zD5bPiGzUoMteau/cKubnrtd57cN5UQuxW4WRpioVy81/aLefNVjahECSPMpdRzZswgGlq5itKAj57D9//XmJO8L8w8rrDbDKhctiO4ouQz4Fwk43OacEqtiYhtsgGtDlmy1RsuZIrpL4UoYTxxER6oeodYEo2cjydTfldDXVs94B/WMD8kNCQZqTTHbUyhAy7os1kULfZyezpZRQisWOM1kOz2QeiEo8NVnxV2p+PL/CeeEeXM50Q02Kf58ZkPVsdbxE1/dZv77Olc0qN3r7zGs2u4L+UEFU9XUgXVNB6TFqYHAdsQNHfF+UQgPf0QcOfMrf2BH7YZRRV1QPgnvAq1o8P/sOu5XPt3R6Eb80UZgGE59gKociKlUnbOu0b84+wt8ga+gWtUzrIz3BwmoiuYOI1v8ws4xmEdCwa3hPbfS1ROQIbg+tPyUnWOW+PYbqofpGVvPK/rvF+LtXD2HcoUo2AtSfFJ9P87nTIqvKdx5P6pkFyseIl1fBnvpta0zFTdvsFgz5yjef5D0rk++lTSAkp4PuQNB+NVoE7folwNxITSHnCs7l4RcWU00z0clM6nrPmU6ZA7SSKCIDK0GA1veq8st+aiQ9faOOyC9xWJsyrDZ1y5BaD9dHSZwJB+NZiF/M3gPJKTl5BXt1e8GgAb6gJ38DeaYeuRRGs0MwQeryZOfOdG9D5lMM/b/Le8pkfR4qKB9fyeYRtLKumylR69PNHh7bCh6E9f6dejl+ULjJOr7LtG842uCKEwEsElmDMml6pFaEy+vDhzokKwpgET2FjHniSF+gzo8mUBe6syChPAK1Jrc0dSYLMXvpvxw5pOCl3lB5NWJDEU8KCwInp+8h0rZmMDE48QdYGOJ7C3W7CIEz2a3Kxcakah7I9JnS6zho+rxeLktMMC7ZFT9yg/8uyYjuUinkCH4FWa2EpKHSwVfZdQz3Xq5zv7FeO5tJ6rw6JPYtKjB/vWFkHGYtm3ojHsPDGjtdYKZibfN3Ztnj/ru0TnR+mAyuNK95anqNluSEIxKqx/ABZ8RekYjNi7tw729ZNdzSbszkPeo5LjkWt8Cq2Clp6+zmR1AT6VcALeUhDNYaAcqzgOT/tsOTyacybkFLEEOmZvEHnUy6b7E3TFKI4gsfRcbfF+TJyprFwyaLiy1wqr15DwD31CUtwxfUcSgjkt8e5eYfG5pUPInjpCaS5lCHQbBK0XUH2ngjboKqywJomIfeNRI5qqO/Q3XkDG3G68hSt4ut0mpokXctT2fj4ZZdp03BvvKdTF1r8AWBM9Qoqb7k/69h9o8EfocLy+2bqVEs/IXlxS+nGdxJiD1H0sXYSAjaVJfL4wPW5bXGb8T8vQf+wHZmQm2jHN1SxxalbSi1iaiBI03lSyeHZwaW0FzAF1Bhvk1zg3sZdX8Q6z9bKiKj4jsSQVmytISzmrxbE0DCMO+UA1CB7L/8coJVTfOmJ6/Z4GczTtozDXLgbEuiu0jVBBY4qGTRYPqepW/qROLSei4/D0WMJ5Yx3xxbQuunJmZMbjgAyNXp+Xc9aeTGdLAqKjuzkTe1KgqJ56xA0GwoAi4VuMyCGBNSrTcYJ5630LcQzuzOHzRbOj4JmOMNSJriMZBD7WGECNXqXPctiMJzZ4XRcubnhwaSS5+5CYtLW8Wv32FEKopBRtjvXxfl+p+4+udsBrZ3NyHduagnxheYSwalgpeatmnHEVF6WyI8Jih7PVE7dQcA7Rm5LZg8su4gtq4qQZhsZpzdtGMwJCZsYwKSck+4wLm9INOd4ArHEly4OwG+2ecYBuuaXylZaOR+H3KFjQRKHojdk/Inkr1wfQ1GyGn3EWXFe8DhEslseUmHhWaJjYl8xwwGpb4Df/K4JxfE1n8biZrfOwYQRhEcbC5KOmWkLlcDNI1WO0LdPfS68d4zf3eReSq/G3jyNIHGJBI8MxCJDEQBhOW6fOyVS9ExFSiR5UO+oO2FXlPN9r11pGMz07y44t9CsOCK4JSfs1uZyfcPLYrLlFlgr66vULz0FsYdDiFnRbbj3srAAEVxZzOoidf7o/5zEYrzAck9oul4ATu22mdVuHMyIx3PtPKq3bb8Ozgvbk20p9FkRT8hpVngHRGiG2mAx78hydFngE2Bvm8uSjMt+FGFmNalnmGYFowPS0GLpBt/knYGSOFjFoqkTWpfLxWiJY+qV6JJaDJYaI9lZmKlNNStYGBSJyJEGbfeoviL8MbNyvcANVo2LMRzs7zoC2ViV/sV+8vVuerquZfCPOh4pXLTRJg3BpmNe5YKP/ljRXQ7ICQbIqY5HT/+gzCOOi5iaW13uNkYP1Ej6KFclEZk8ICrRYaWawZFdLm3dY0cLk+V1PulQcqWBS83YqPiZezTYiXcpOoxbrVJkZskKZscA+pXOJaI1iMJc+yLfDnvLt22uzGa5VajxgIJhhJoATILu7Woh+HI9/W+APzWZWmIPfW7Bcu13HkeHlx8Q/lsLaQExYbL8DH0DUwRGQnxVdBGcnDg9pkAAuogwZsJezBAtXT9IU+/JUyhd4t4prqoERGNYDWolg3daJeaLPJ4SLTgFkYjLwD3Wamn5nXZYJlQm4dsrKIewvWNbMU1FMTLI796v5mzyQth96BwgXXy7kb0vWBx9HcN9xRHIbe9GkRml7SfpXKgnVI0nKQW1Gx9mMVGCupLIjg+vQBKBXXHday7ZQuXixGNDy70bXQAGx0uMDIxSWXp/E/l5Uqub5IhCDr4vipxFWcy+27B8BPehrIXlGBjCdrCacUZFVcQ5j+Bxn02uJW0qgr6q4ROTr2kz9v4JLato8aR+hfnAiTlR2fgA2tltNDpLTIK8w4OI26IumDbHzF+6aX1uOSkiD/V0xVkBD97aP2YToLTJsvlYj//0b0Dg7vTBCQLT08K1biSwStfblNUwEbezsKGo5bQ+F3eLA8Yr93ldV7FHaaGh2MnGkxIGMaJLdCofEceeIcclEgZxAZlW02yR9vo/dfBJZcNMuClw13/Mu101CF+YUxCxwpbE1PzRrHUMxVzwJIOm4hS9zj1HGXpBeMm6mTo3ddC7XWoC6VudnlAUNjcWilAjVaOcBjq9+vmpcWxJpNLZRh8Km4w9VwLlWh9x7TSZbD8kznp/RMa98hcciBVt3GT44rJjBR5DjrAdsRvWJmn2lKWqjOnZ4O1LxEPX9VjK/1sy6+EOYG05r4qf8nI0itTcPN+wnLRBEq6p7I4g1Wn0Sh/haCzrOG57NP0Uh8oVRCitNNL9U1b9nxMH26pgRH4Ka4JweFtPIr6Grxg4fp5TOQ+uII5PK+OpBmDuB31uav70AhUA++qRLesjq/UBYeiRxZD3l/Mfntp+OPiHeC8Dhfv1igCf9XgQ61MVoWBClwJRPC6lJ1mhrA2HlTMd5HxoHr6Sk/dMiuNIs2G3HFRd43/XSSB8UcYcxbdY0po7BMG9uj5w0XfU8Ppi77P6yHnBffCP/a7L9HWIQbGKMYa9cu9zI/OCqYD71m545hybk0HmxI0QgUXECzNu5fTSCq+Fm8utBbdlxQOkDaGf0rWrkaYhW8tcS2qYJLvsWWuxIGfT5E0jmxgDLVhaIYcEY8HKkyMHpZfDcxCcAgK4d+8r90VYUZ9PJKkTlbEioTS1/qjG4zzIa6frrsRRjrKC1xsvTHbxYSTWpl0zyZh0Z2l91paf1NxoJoGaIfw0+bZqJqX7+CpHhY22FrqpAdZfDb/oPyzn+rR4bkn7L/YeI20yzhz/sB0N3qS+N38Occ4N45JVsPn1TIaVKwKbOXx/1BoZtBNXuRhB9uVcS0mlz0SO+cy8XPbV2DHKaAZTdezIN/4guHh3ZbIxT7dv+U1GKdXeimOzpQIy4HoxKROzOdwM7BMXDHSimpbGAZIr/lre6xjMUdpO5NAxETASU+XgWsBhVZwPD6pcbOwOMF727DMsrU4IOgErWwvZFxvovUeWdC0codtFbgy8roGjWWvK0Ce082HJ1HRFmlfBLoAlw0fVZSRLX5ASM+2DvB5Pn/4FHVeTt4WCYlAb24EhnF2vbKo83wyGrdzI7btA/G/JwN4RJSyiDy5rfDOGY4Kmf0N7GTBddhyqcEXsZDY4igYjS5WoohQEZVXW9FPRPux6LA5gmSLjPl7qwZzBDRzY4teklb9ellmDd5CrdfYuaJLh5Nrah3ZeR2qZC1tGEylR57MT1MiPuxZgfd1Y1CJDq9yvLU1W17fUivMaPWZhrl6nXCN2sQjM7iN9P+SUprZpJnVla0VzCFn1pJ0ny5+VftvazwkgElyoZwUJ4m1BUF3mle6j/Z3Cijgj7ytSZhEX6mxjgZ9Pxo64FNUQnFcIZc9ZwKaWrCbC/IQKoP1MzU/qMgHkoFVNbqyYN9vuXZ7hS5mxblsbt5jD1XhTZ8iRS4MD6MVo0UNGuPElLprXS1JIXnNoPLojvmZqO49rd/yHSR4IdvX+tsY1NDJChycNbNQMwCZmU25MUmQ7hYk5S4Z3h+lJ6MCMAx8ICkTDRaHQUwsx/IG+wb4LE6+OjwgFQrN22yUhTUbxiQFxOb8Drr8Uvwc0/HFRrVLPlfpJ8PimGaPFV0Q8Scke1PuQESJsz9BhSuDWygxvAIjHcFJc6XpgdovsNnlvHEf49E+yAMD996YRAdJcQzEX+JRK7Nv/L1hyIIic0aK/QM7lChpw+nBOytDRjXBCzi5gF83nyZlmp/u1vOtg79RY/d988pYVH1pAWb+hkY7Sn98lq4iuezJdYGMalBSxm2Hn3LZ2mf9hiSfsrRwCFg+WlX2VheToI9rX19uMFvZs9yBQzvXeFT+W1/4hE0n04NpRhSVsfwBfMUHTPVMN00vg7IXSXgerz6GMItNvRbEu/02v97Vrp8uB7kYsJtJwzXwYC6u1ecuPDuI6EnmVB6mC4YcWl1LgOmb1CJj6E3sglWgh2NdQMppg51W4l2pExPRPNx6aM1r79W633hvxnhNvdP2yGzKA+cZTvd48aFhgH5StFPpRvxGHwfBz309kS7mZGeS5FaVQpBuSJL+CRRT1TTQuqYvYfOcfz9wp6bMjmj5eHI/yhiT9yc3VKexDL/FMik5vfo/3jeZl5+b1FaHkQKK1nMN2jxkjtYL290c0dfmbyDUFrGewvgQ4I/789H7BhurKDpMGjH5kQSEyla1DyzaOED4dKIjETgCMvbwL4MnoQKxpnP3OpqkOiUJTh2zeOs9/GV8WvHLF1b6xcMHCWqAbb2GaV5WDy4eErVEA8zrx37dSuOLrBABpgup44dy5uspAeQXcgrgK4XPT9QR6IIYMSwtL/JkulqTAJ3/70t4hvyJrby0HpqCujnxrRhf57/oAZ+uAvd5yqvrGrFWYujptiibo1Ot4bU2tdzN6XKszYHvBJTC2RwxD5XbXERq+lrJOAn0Xn2eaVr3X9Vu3Tn4APJfK8HYWK8z4jCidt+/OtE66yU6szuCi40j9wnBUSMHRFkpVjFaCK/t1gJ6bjeCTrz5Z+fDFk/oR4VuF7s7GHQz0KyOXnotZAljEPTRXUP0hjugXkRLH2XTyisBEhfqFt+R19T12fqgMMcXBAJek86wjzmxg55cItvO6o9c7IIh1aw6LzqOvdEm7bLWg7xOB538OHK9OTXATkKoHLDXC/XXOecSSx2AgD/uutR5z7RNVtBSZoViMKw1iTJPRnv4OspkOrZZvxHj7CIJwORpb3oVs962nN47FBL8omKbXDosLmlNSyulkz98IWrgw1bffy6EBqn9evV3FawKF7uVQ4BiIFPiQKvxnmOOxEI2HIN2wv+0u52b5sBvv17kfuGgWCwYmzWfMUJcbqiOriqD94UjlIoS6z8isGxKW1fPU6VmF3tfQcIdmiqYma9+qBMDzxQXrC3WN0Gss86dUzFxA+5fAfcEeUXO2/wDTBtsORg78Wgirw7Sul5n0TN6/7+JYnBj6+NkJJwgKB0DfpV4AG/dwZWBPzl2IP4hHczzy66sHIy+PHq5WeCFLzEBn4rsF3O0WfkbpoACwyVw/BicM/5bcy71rPMSHzukIRdZsjD/AeUGzDqWIV/I/+qBvooFD4YiV/oBRr1AQG76c9CdvOZ+3wzBY/jMAx8220KMYRvCQhUbIj+vg6y8ZsDvOnq6kl4Fux8L/zTMe+DtM+cpgppxV/oy4bYa5exGSEZxqbulQ1MhwvyXrkG/FHJ5wQfd+TwhC74LztXtJq8gQV/ufXQxABvYQDjuAtlBAEBZ35urfP0v7DDG0aGT/Z5yZWqu0oIJkTFOfPyguPYaKcPs19/XPOgPyc9i6umO/dvcqvooY4f/VPFIqLBBnDQjRlNWZO02Kmx3oMSVARWrvhPFcY2uGRP8+bX8SgJ0CDZ8sjwGOKvAbh+ne8Sg4QjQVtTQiMy5/9CUwBpyqPWaROq/BGLOB6UhimIBwGMu1ouQtzAE3EmEOBfPuNYEdf+32hbormT3EpMt3FIBx7lTK0SbDsdx6uUJuNbMClNxsCx0cKeesmpfv2Jpo4r0TNTlD11EpvzKb2wlDvoLRexn+TK2VGm4wgSwUevvgCyK+uZiNO6wNIUdaB9R4DL9uUNmN6TcXM8pCDQ1TDYJ061om3IILdt0K+1rA8gLeV5F3B03M1BhUt+ou/hHbCYc1e/Bww1TT1NVbRxd2iihEjoUIRdR76kIiSTMmTcM+5M3lHexmJVioyPXFHZXM8uiBjOIlB8j4QeFHwitz28U4ydC3eRLGe6RW0/258uSTZifTgMwUd+YNW0qMZv/tUryzFWmHkxlGVPF+don3yNf8DYMpgp+corL4b8npHAkU9zPEAhmNFZucgvNb5S3meKSaI38ZxzoEXwg7sb1vUexD4Qem1g2EXBwFSsR3E0F6g5BdpfRSmt0xnp17ooSndmcVNbSQiWQa6J5LuCxp5zGuu/9AiFGJ8xG+f2LEKUD9jbp8GZZXN3Bhk6E1n6xJCuRA5/H2bUbIOM23P7FFJVKaGZpPrALlhvdg4b/54YbYB9WKTbhp7qlYJrqTZ6F66FKF6azoD5DfOvWgMYqEBO0fxvEXD0o9O3Wxn7nrt4xN+U7cmL+rMX18+YwYxIxB25XwgU84YiP3m0eZxvkrNxn9rFsFEynPib4ik+BRO5Opkr3DCoxBqPRVmTxYvC4RtIMXgud4/2zz4cyLXB0DGNTpyQXk1MdbBpjbCE1garhiBVutsZ7YIXrplCUZ23kZATZRFMhFHm4/ty7omxxDh4RqOJpDP2LnevUYTghm4MTHSxvj9yxV+E4xNf3Xpcc+OZb69EdHGnrMYOluYY8fB/Yz7AulRFtFhitMdHpUQWZTkYNH+WqyQLab+lH/nE8j0G3Ylgvy1empFMjIqT6g5kwm51qfbBMANPUDTa1upr0rhk5W8ivleB5uZhntPUozE/crO14FvWDZRIuJ519pgxZYTS15TjDM+i5VDQnaBeWdLAdKx+wqdIi8ffS3vQdmMDpv9ZGL+mg+Td6andzLNJUL/eDm668DtUgT2woSCB3U6G0pg5gud5ttR9ZV5ZHvLlEI/aOaTDnoxo954ucqGkfkDioY6WG5qD6F1aGsJ3WQSpU/TzrUub1ZIU1XACn/vihMjLWB3ZDnEB3uMyHpiZZRu7MJt7xbjcEl70ifpHb30dLA/qadL3UdHPjCqOJ2B0NYep57g+EAp2IKyNqtg4lKzNXWlhoy6/3eitp8zCeM46Evd75ml93VX1Wdy60q1CsMOy1fnd3Nt0NshrpYA2jdD7F7vFWV29U95HjogIVwDdI4yajKkHE1eqDByOQDKIRe9ADaT6A73uj6TD0j1HlNJVgqflNVCEfb8vizZL6kxquQIAeY5ZGK1Zej+yWJHgwQn2poiyXssrXiFN8qAbEzF+ouNWDhb7Q07lE2l8FFf4+70q9FhrApEcieuUgBPM+bh/bVmdBkH3MjjaO0xCbR5Mqs6OYDizsPSXUrJpwXZV07C1wKMleqweR1RFY5FHfYdkQRfQn/IRwLHWHdTmv/raCHZaCa4xmZcvoAtVCK2YBaWvAI/lCMecf0qIcnGfOZW3hYRR9IVFPgh2eXJge7+orKxT3gKr696v9PLYgXjgVSUINUitf3lomQigSOP2f9uRtA9SmnmX4fUv8AsaTbfx1oit5cEKMw3pwu/dcSAjbGyv1E1e+vbqUvzAr6TnWLr29Z9tDrChd0OuS5SEeGC8tcqKzPHfIzcgi6YRPPUF64r4rS/cpn/Ukju5TrzJTwnvNNdHVqNT5gqR4xiu1tm7L+GBnR0zkE0KXmKPzG0YnrsnLNbum8BsCH5FO6jJif5qyGMWDliK9e+07T2BzO/Nu2051WPgz4+vf2z89rTrV9+Bh4jmWWCteuYgMBjqqnuP7camYfxPD0Y6EVnW013H8gynJnSD95jZ0yx0CLyT8Z8HM07OCc+o+qhGj3Gd6ymT24Jn2UIKV2v7H5hfSy25/jsRyQRzyczRSmW5T+N9G7Gdb4UazNF3rtkvr1tmtgu2drbKRdD7GRbx0R/MQZM0NhwyIlHUQY4w/EetYmz9SG7A+0DgzHSM6BaGKuXkqjMeXmFLOvHHAcu4fceTCQ7mqFrH9NPnDJHBnVSny6xKmV2KX4SckoTHpo3m/I4dnDu1XTnvpocHaP/6zp3quzJ/zGcIP6fllhbK/lO8xp+95lV62w+R2qIIM+GO60ST9xvGY9XSRmwAn9jGVtaZEGHk07aMCj7J60xEgGhzi+4Vjz/u3itJBHAyjLTIjR9tXE87yanIeOvWGa6Ikj/A264A3435t47/RMdCUZzy70fBnRtK00+BbNt7PKgG5idbF4pS8ldtk0TwjeLV9o/erHR29K1wgzXJzsNCNALZn3phvsRhUqQJKkLTwaJqoHs8PkraVtKZmVcPeoJUFWNZiesCiKs6ogAdUfIGwgTwGc7lnO0i3XgFaytHBgJdOZyz0AEFUskPBP/qW1ygTgG/XWWMoDbecpflaFJqAFs5mkK3NEUS+wcHTaSzTpXQF89AgjO6aKXq2wS9O9M9P5ofrOgn9/XMJeE3aXu2dsts0QMDYt1FpphCUMwHqnX9mpMKjqvywZbqloPSwg8ue4iZpjkfIqfHhN9Dgt5eRxQRuq2ePw5Gw6bjxANGx97JgTYVQmZ6lJ+ZrvfzQWYjQX87p5ZG1hlVRoXiXXLF6LpZuDhsQw4hqHrndUGWicPTW5Qs2Y3a/DRUYCgVdhG2kImsnbS90d+3GutZ50NUD9oop1MFQNtBxaSiTBMn/F8kdN+FUK1vqPwD8YC4Fcl+MbyM9DkKqtVxXqaDSnAW0vk6XABxuOUIOqOUR63mtafeRp8yZR9f1FXe9LDi5HbYd+8+0Q2Q5rLkavR/0R3VE0C+3rovWiSZrAJx62POtWfkt65wXEquvRBhIcj9MYSUqr1lICk0WGOGz7kbT/jOuJxFiEZY4fukTrcvGWRQ84+rHZ6EIO7/DCvnWi7IKze6NxnjBNgqoeMR9dlpOyxzpvfwpdxZuKr2SjR/LCmvnOCzBqyvBrneIFCsjbtnBsFUmiYEjgb8QRWy+183b8fPxsD84705Qe0ARLzThU2NMxffreNYUfLu9hVLB5hRUpK3hWEoArGWU5T9XsE99h34Ui1c4TUOqKEX6QGK1horeH0YvPFIPmzfrjMrMZkJgOezjS/IAp5m5j5IjHFrlm8TcA/oJYZmWrN0aD7/Zg6JM0AXwXjjyl0ppBe48sXMg2EEddeC44t2yDeQw5auuCKeqEdfuM5LRSXSEIzXxAOfi/wYA4m35V0IkbLIn4+asVsM9tKmvt0PwlWR0N4JQMf0r5XLjRBMkT1C/SO4bON6JKhmkNniMYYLPGNUlS9/XYHesCTX8WoU3ScC3iT/ycPlDtQAAZvzAiGS/p3XUoNvDdtdvehYyCQ/OB5bzc0rIKifCgawkPg/6B837ZjrCX8vpZqZI+otn1M/clbolPEs+OfnA4Gvq8uCIekBLxF3NSfrHkx7H7FpnBEL+cueAH/X+tIGkH7RiGSfj6mzoHqkb9HXbYBzo+cSHSqIkE1ejVbcKKLw1p+t4z26ylPq8o0IAqmWC3/zsreX43zS7WRzKfmYbNJqb0JSqPlLo7QfaAW/+8WBysQDKd34KGzB1CXc9CHNyXzO+0RHFpJ6jfh0QhjSvr8HgWgU/Roa9Pu/b1uhgpwO15ZTMr63IbCCPNMKGSnhJvsAUAJpklCyAZwP1PZnP1Xs5VQ6qhuq43dLBb0Wx0a+Ye700euEjVB6RIvudZpUM0C+hv9R5DCsLyALx+XvTgAViRGJHknbwJQqi/hzABBxERNQadHIvBexP+229UVHKXMab0DsKNCVVLX+qA+nh9aeGaHpDEQg/i4JFk1ISPSeykMGPT+9Y0NoHmfQKuP2SV0l+jQ60h10akErs/k41vz24cyuDF2XEPorCBXMrIZQLo7UxF0ZNUjfoSTft8A4kpbljY53C9wWX/3FYgfKy2OjwuXoUfxgGwLX2tSACG8Nq8po7nmH06N9GKoKcRGU2yFPzt+f8VEtHkPUoyIK72px/rBxtaDOR+2QHURbnzD8lJcE0UgzK5otgWQdYn4jo4EFIEMoWtmqNZ09fGKQ6oJGqfEX88HmbgkTvcxIXrRjaLgE9frjB01zhUgV+qlQtox7Nv1JuKRMirghfo6Ux34FT+sDQ6X5A05e9HeNKgCz4x0sBm6SWPanjX0+IABdgNW0K0I0lJk+12/cU75vtTYJABkm7juPnEccWFDmS8npkpb1V1DKqOAaL3/HixyZMpd4bAaz3Ca1+F+ZGkbuscOx7FoJLfe6uaFuT0CYI5VuzK1QR/FGQUxs4ffa0/Y/gUUU5TQ+TFPr81cl8trRrObFgev5HU+orbU4EvV2TjVi23ZpjdBTntBaN9QJE6xh7CKQVwdQ/Sn5mTb+TRI4vdK8fw75zUTj0DYQqpc8y3Ps95wj0EIuB4mAbWL1Lw8Q/QuK13ZIQKQBmsbMiWkTnycGKyUro6QnbXVIUSUqOShwOZXML8aOy2N3MVgQUVHJntOFPB/M2JnIqyoOLG4IwxrqPAE3s5reClydNJoLA7rTDo0SpwXrNP7vZI6y5loJ+mNIqzJqRxCQV1l0FjXhW439pPIXmC91AjRoNH6BjLYCAL1B5kc/EFIW5VV/P+zfTytMMlUaxjQmb8D9/+IbHRNQZRCLYbCoid51g5IdIdvxzD6vpbbfiglLUZ3n/BEz7+amZuWl8rWkC6w5NtIVUtNP1kGZG2W2guCtkpVZVP6VLDoa25D7W1nAzq373Lh5dz6HKg5gGpUQKHcMXimk70M/H1cXXcGqSQwxfRqs9UvxxrmeCuHiUaj51BsUBCd5lUG2qLU92+e+RBRPiP8s7r+XVrf/4O37VeP1wiiP/4aRHSbmTOtU2yhIH8Avl2MQgMsbATH3AkuVPzFI8Mb90IwsLXEPl5dcDj2BVaVxutIfd+OBQi3Fcq8JsD3+/0+fRr9DVOApNgYROS4EAHpnyeai6o1HPdzTBCCB4jQZVhqXUUWz5S0LXSCTby0+kwrvZRf1nb1SIH3zeiX9RakiMC1pmbjmxabNJ1zSYvCSI/p+Io7vnBgSThOpDVfSspwkiKskBlvhbs3ALSOAs3PxIeHsDOY1xe/DInPyI/zZqzAdC4FUwPJSS7z121Qye/8QRnuOrLUy0iMZ6kdmO3PtIdXYdkHfWaYzGnmsu/sbr1Fb5PJ4f/yk3NB+pTirw2QQ9jXfPzOwvd2wnUt46mhmdEigTneUo02xl7Z9dkaggWzMxSpAzJ0rvP3dpYbaUL9KvLHyS0t6B0uTLLKbvjiUZLkNO7DkhX8JSoXNK7XwKQC/+rctnby8QgTZG88voy5IFOY3DXlVSzMv9OtOBv2N2DCoMtHdPPK8M9emaFi4tY9HFxNIcsY6muEhmi6wAlxOpmVqao7Dzu5tQsp4RfNiAtavLok6gTZEp4yIXWt1B9W98doHpznWknLk5ABLRaySStNClSpbBKbDTXb+KWqOLUV5kh4jF8AtUnLsyzyMoAXqLQXGebN0G7GQOpz3ekuQ08/xthxNG980BkA1aBNOVsndEd4DqgQOSk0h5kQJYnHuKFmcLkClD7j/5V/dT4EEhcpPMw24xn0YsTph2jofzc922hvWPIiCC7wMDpta2X7OQAUlZP3EAYxDoSf55mdk++Bse0hjty/7MKGsEfLdkO8SkPUBVIyMnAzZ7FyLEI3eg0+UUEUgsiLe7hp9R6UdhmelnzR8OgEcMlgs+dk+V7ns5FA/Gq0TNnFinDHI65I3Gi2nX3x6LvbCS88X7jOaop679yvfBEdQ+nlK3AG+TmbJjPZHkpBX3wAkz5cwh1CNtwujU+5DX7xJJqpm97YpdkWI/IRXyKT1p7PzVo0dyHmYSkRtaU2B/WqtctjUcRNizn5VYrUy3vzKrxsEuTDUbnKBWDCGXpIafYo7oAIeTuihQ7oKRNYnQkyEqFc4SluBdlS4+1rUXNcKJkxmAN7/dP4LZ3V56GCt0JB4Vvd49LzMLMrAWcPObNb0f4IAlKLjMpE4ZnfakrwnmjzGIxl+BQjtJHNoecuLRPUTNR1O1JUFT9jqeEsESuzgYHuhr6e4fAQ39qL0th95J2DmoSuv0CYMDqIFIFoefDO7mg/u5UT46wdqf9RSXgYjkdUAdykv4Gyi4Wk6y5FQy89ZkhnfTFAhiI6rRMSJc+qfrQsGo78rw9fPqpDL9Hq5FAVwskeLRE9ffhhwhNy9WTYrJSZZ3CYRyyhVPLM7T6zBNqSFPsyiQteX5bgLSLQyeNqx9LW8XJfgxIltlMdJqfdfldGxhV9Qy/2Ul7cbLSh4sBw+TF0xJZxchDjLUtdW4q5MAqYHOxRQ9G8aNbIeTRu9FQjOGDErztEOosQhYQ3ikW/XfcjFj+4aRwIu04ZKrFn136MAnC8EgJOTgzXoubVBKNo+S94RU0h7hrBqxvYmA3xIPhA3q0khXI3gxmAfQeT2DgjBe4X/6kb7+R5q+tYruw6ZaPeifTWwZljSfVx+thbep4fqzbAxyoCzniZoHcJ2DjacmDNgUABdNEXTywEZFDfTcKchrDvDIHusvykVCoETY3tU3zDQu1q8S+r4bqt5+J2U09GBGR6YLost7lYSbTnewpcciMXUcEb8Z11mzBI0EtcH/ejniqETfuhgsgyk7q6BwBKKICGgvBd5OoKumtwB5zRLr8rGPBr327z/m8pZ2BK7Hk5najyTp4omOVcFfPZ119KlUTE/ZVwHoafOl/x67CzsMZRDqMfPcb7zR/lwaK7LqayeYKVZmtkng7F96xx7CJREGWE6QQqMGhZBBw1gDJnSoAWHT8Nz7SUNYbKekodolkAc3F0vMbhHldW8PNDsGH9OTxHDB8vJ+prJgLnrpLzX9d1tBkoyHy8MEjdYhDXF2gc4GpgdTvcnTg7l2+Cou4iUsopIc9Lhbfshh+uokgMXgsL7aSpb4rVuVtQf9sfSWdo/1II1dC3ftYqN7VJaMNQl9v956+0e98cV35siPPNXJaT0R1/qMcYPC6V9RgeocD47zaflBepFP1XfBuQvWnzaLxhBNrb/qVTRLz4EddkUJSpmefc8bR23v4c9t3inrdygqsWAtrbZRISLnAq0G9xgUZfWU9nkBcPNYZiM/c+8AgeswZqYHM7u+FuHFpe1V+lajK32ziT808VWm/fcbFXJBzdJkwrhtZjS2uojjUOWvrpeFiulBEMGM6KnkuyL+4fw5PmypT59C3IgUTG/UcarAnNxEIjq7cYbMci3/+Eh9KZnCwUzgs22lFlhobN4sNbR7X5UY/rHxge+Epl8wfMjotNWxG45po6uLaiSpk94FBDh9TzfOv2iF6MdbFJy1MpV67L1vTbsdZMVFS43hzG2qITrRcOq/Wiyyrmp9D4Y8tXtTHn6Zw5ukjTQxYMjTx+mCIh7EhYITiXVzKSSxRJTloh+PPnAGIPqieqwWfuwZnYsJr4NpetDytX3w5gFcL0gF8Z08RP0ZClJmpQZs5Vk81gXNFObbReYpGcixzvOQCGrClKfB3ZL2t1XzQ02dfRyjEIT6pQycx6XIGub6PyM96pAqpDZzEqFmJnn8ZQkwwjMXLiN9n13cDTLBfhHpF6eusTfvPpbocSScmIcs2oDyzBwtxeWU7jtnpnLFKUnvjYInMAaWru7NxckPw22iexJYyD2EXqZ/Q9hEu4AgSZN/qGJ8j1m3pvxNiJmzSNgytQCYahWYMWj6y8g/DBqHBuptBVje48Gnx/JpnkMuHucOtaL10DO0lC0Q9f4yjleRWyY0oNoMeOS5Q9BIuv+eQ+0ce6mqYgZm/m7BhHg0/HS72ZbC1gPGd5+5c79HUWv15atKeupfFPTRorGZ729KdCvDbr6H4ihO03zztWtXHkFgJHNVbJFkY4LOt17iqgMddPb+wZ4mYjDIXMk79kp5ipi6dQWMaRpeTUt+gqZU2feRQ4bsb7gA9YRj4n92GslbleqzUZtZvhUWwOY9ySlrnZgkuzWPFhNOhZXPNi7migN0iKw996vJUic9BQdHr5MuLPos9hExAHmFtghI3uSLZ6d4YeDMoq2YjyanoJgtLC9x98yzq+U5vrAcYQOZyE5lee8xDkXaveHh63UxUTiCTiqDq5K4OirB0wgNx3ZlicsY2p50oQYWsmB6prv+wIQG9G9Cd4HAvRbKsG3P1zwNGvDBl/kbkNzIhf7Owo1AZpFdDGXeI5UomHYEO7R5NhewA/lNEAhn/VAZtqFWIAccJUe3aqp6jbL1YBP8GuNU7g/bGibZiLuSxOi7wfrvZSMf2qLIT32nTJDNMf6Q+DPNy8ZRfOuWUyHPPUCjdtor/FzjTuDx3Y4I2MgBACqzuGZLUD2sdRnqZK579X38tzIhF02CcQdbiaoTU3+ZokOTgZBNH0LK32ld3I1nU+fcB6uIqwJb2MChB1K3rIT2ZP8ATtlbBA8JFYnkbUgikhCrZIr7vf0kS4MF1gZDXfd7CbOmExuwhCXc16ZyeQNNZ4oCeOjR196LsNWnY+RXT6jml3BHhUgLDPM+lx+mOJ9PV7GmqmNMzhcEvHhrlFJm/U7j2SNkXwrlim0tdFaVz0+fVRQa5Wdup9Dseu8Yd7BqAO98E/mG5jqCPF1r+jPLp4o2WrjoSA4ucZRnAzNdOumRRZAmenYlXM9DaYczZ7cl39SpKLTb052o9fYnztR6AXPEv/KtQNKW8MNe07ZYJ/xD3OJ3yIgWh2NJ4SlgoDSg21Ha6iuktVP8FMwbCboXVpmEg6nMHm8FkHoCkqnwVKgWylu+h4obGLlGwJkO4iaI0cztbhpTjW+cwkjCKf+XboYjBd+j21waFuFP0ElazqJqlwOWVpg0g0wRQ/lcgfog69cdVUphknd7fYB+DBM6HOBalDj9LlEsN8LnGbSjz8L/QPM26jrmabSWVUjHlt0waGv1K7ysvSOK+EW8AErDPRTa7mZANU24vOm0u5wLXQgkUMwgEHs+jjuP3OCzvIC2tGh99fxj2cXzczVbblnnkn+meLJW2hNKpW8iCP4ceYT0OZsMM90Tpy87M6+IEQZaeIokSctAEEOfKkYgseyLxTB6uHX6vv1IYWuD2uTfLCKRTRAABBnfp8FI46HeDt6al8J51Dtjg63XO0YjwTOWEP/ZQlTNd92OC4F+6dPx1BIlrFXgWoesqm3GWIbHHgJOQkqRCpVtwNodwxJg0/BPLri+s27JmgO49xXc8SGPtYsUokY+ZW00usvp/0vVxNHd1iTE7yZLIYVanW4w40IkOt4ufh42ogMZPJbIIJ6p5ffN9zUi3KFZjG7a2xg/v9KeDgNSNswOgZxfV8x20JAJaabk4Eg0NHRcr1JkEKZ+SbK1cV2bCKm6GZBl4YM+fhzM1N/6lYLI4PuwGXuspvMx/Q2mJjxGZxMwBsMJbifx1I8i7Rhq/X8fqToDYS9My7aGg77IdwoLh12X9Sod8CMj/0JM4+Gv6hyC5Fm9fCd2676hjKLpin3AHCcpdHow/nlnUJDO84ZXjccbl/0ImZqjhqBwU/Mm4qMkRs013jRHsVKc8eCmKHQYMOuLP4YBoOIZxfxO9Qr3d8X3bjsJsXq9SLF1s+zyk+04KMn5lhbKFr1N++1ksjv14578FBfZGxB4gJ/535W03sR98ODacUx8pUGCt+Akv7VpNjMK6ThDv33Q/77pSs4N7+Y4LEuszm4Ra61iri5yNMwQ7+iEsFxBxFm/U0XtGJWA9sGyPQDfvW936r6195gZAYlK7pPuLWtppf8Tyqqz4T8Wd5wADkdZ70XxZCiG3zhVfEfiCXa9XPTUb0v4xUZ03h3hh7XDdQcqvsCySO7MghOUDaw9ubLzRpw7bYbugDtzM1GT+fHn8HcqOKgy+tDQGCPx1P0VoV8a9LkOBp3tnJYC63wSoekqTL4PuDeT7Cpbmbbqot9PcwalGkn/AjOQgexu95OiNOw3i9VC1/UUHAtWZjQ9ZIPPZETBG/UrhvFPON+p6F8mFz6AVxc7l1rlpedsetoa6JeY/2k8eTXkjF+AQAGA01SfVroHuwO90QWrfZvIsX5/HXJU+B8Zeahl610FF13WmnbmKuFSc4gLhIvQDIHPU4Wq2oJTV3BQopWNcc8hHxcK31HwoMmMsvwpBd+StaUR12hubZ/obD3pVy34Jn/aXz120LGwdPu73UPqK1EbKs4yHG+ULD0EjST13Ch6ZmT7WqZDzM57Sz3iFZCXYgH+iISoTL+ry7PGk6a2iUqm+qf7ePLQSQH8FNJinc7mldVhjmWUZFqpxx/3duhiTH9Fo1ikY/uetlmPRNOZBLhuLcyMLoEON1uuLJgyX8gdwWQdgy1mNEEtqdiaHlE2E6evLFvBteRwF0utGh+V0dcb4yMyLK/ZYvN7F2q68HWHSVUGVc91kf7E66rajJe9Xn69cnrjDfT0S5hDYYwAgx2YAXHYSbfKlO9e5L47jZKfnOZeoe0l3Zqezaq26mwpB2G5lIbnbsKKiz9aXrIMeR2zSez/NoDHFAAMqn8WYSjUqU2/aR5BS10hRkB/Re+nWbw6yHU2ePKNsYETC8VUtJymK7V0cMffVrFP2bSm6icgvVH4wJj3lZMXz/geWg0Pox4IA+uNlGsXWQQbv6TCwQi9OBHh0PR0lb3S+dwOPauh+wLpOOfrGlArsrZD3ehhy8AS0lf+R/ov7yqbxPh1OFWO1rzi+1FgLzHaKUqis1IG5BW8UaZuu1shmjXoQM34S4EGrJxgvnopj56nfz0zuhLFVnJEeikfOR4l7VquW0+NG55M0LfgLp8lPgDfBSWXWBl7Qr1W4SS0RquoQSO3nAJw9m4aYuT93sbxygsLtNvbI8WJu7uNLa8Hjj29Cpo5gVAy7O1d3ndQmD5B1xsuvud7NSh8Tntj+MMA1jbdLO3s/AUKbGzn4X58hWeRXg09FoumFJ59slZ8PtEymd4WmClSEaQhRFLRq8a3tX9JtX7EJOK7JA1dZHAc6tDEl4rY44fJRwiS/9OUmtTPSMijS3bSRMw2LOFZg43aFC+wICog6omrYbooi3v46YYwY+85yQes3/mUPqLWawrTHyN2d7h3/mRaArc6N12fzhpFdGgBU3Txa2t5KNNcO/NZ0WnATYM/BFRnfOOgdA08L80AMvXDsPnjcwUGohHdwrvBB8pNCwn5P4STzPufdgiK/IbdVip2DDDewS1y64QR4lGGKlb/lVX6WM8ObXCNHKDbOhPQauGUlKpvZLW/mLDE3NxemHZEx9ZdcCCoGUE+A4+4jV4SjsBQxkD3J5l+Z20H4lVyVByLCJEYaG3XjrRwDMBFR463cgfLJ9ze1K97GrLq+Nh8NogOl0sz52oPgViyzqYjez1TeqgHwBr3rS0kcRiEsHpdESttlJPpAXF8v/WP6vCFwod3W0SU97Tj1rMvhSrVZFh8j9pYzHNuLqA++C2e+FW0+A0Nlrt/IbUTf3ai5KC5najiPFPASTWKp3yiTCSOjkv5RaQysVhDoRPb/AeFqmi39aNecIv9g/gp4JbN4QLcL+xmMybfcVmqBpgH8kYvimO0owJmw+tZHgYe7Wi/ZME4KsOpYwtjnzNW6WEF33hn9PTlW3c/KhFks4vf0ATpRjZrWkDVcfU7jG+mW4SCAf3G4rQhoOFhVSJsgt32iZyO2fZqoX8lv8kZVebs7RNrzsy/wZ2FsfwPs09m5iZ2IzslRjJKF2KbGHUrEhGtp2mCdp7kJV5xGPdT8afxn65sBFSFSgKI5pc5zAbIPIn/fyfBcKr9pf7lN18xuRVojca7p00qUQQCupX0AhHa/aqKSHb39vvevxQ393H679OGSvEZ96o1SAREqAeHa5C63ClL2Bko0KGp7oQccYZKNA7sLelsZJW/IQ6pbWGxig+owHzbj9ej8/wzpeXtZi3u02B8QSwprw7SqC+2o7PXb9qJJI6w9XJr3j3g+mTKI0Y6Ce/gSbgR35AbNYSt8GZZtzRGx0MYsidjDqE+XP5NIqBiUsq8pECZlI5NPXqEyPb7gxunubfMCCOSYayI1CCKFiuJg/WcQT60TkUU0FUW9D0z6MwrAgM+kx+hlnOGheA8qTQAviJzctUejEUJAJ4sXMQBBdCkTw6zlItD2EVNSr+dPHTXR8keYt8Qgh+aHNuRUdSjnB6DHq9EEF+a3kXMrTjT32bj0ZFVzsUPnBT6poNaYiBXqEhLTwAaefTi+cJbUsDreNXer6/NbKol2GYa2PEH/NIVgih2jOy3azwRql3jjhSU7AYBLpesIvW+jsGrIp3snWqQC1d5tvmhipsirHaIzioAE5UZQOtW2zFLvvl5izaTe96sWy6vr+TGiBbwy4h1XwA2VrWgzQP/hoeCNnAkxSOtXPU2to+ihWRxoB2fFDQqYCR0+X3n3sIZ1PUcWDUF+bnjHDgaKlLWpRdc43QEA4Qndst+ayDTDWSGhLFRPl0MzVybp8tJ4L6oHruj2z3VBtCGHwr9gS0uJE3j5ldjpUbBqqZpy3eHKWgf9l9P3+ElYH9d8le2FFdAsI1HU9AgAbbyyLW/fiDxuDik5zdEQ2grjO0wdcCN5Hdg+cMsrZnZ/auSgYDnnuFNHIHhlahrhWwEjGYTyFfm/NVEPI4rb4ftBj1VR7IZ81JqPEvx2fq8ATeTbYKIwA3eO6bq9ipoUwyV/CmSoJAEy2HivyUcg9qyimRkocT6BJFc/x3FlckE+H8LMRJfakxORWwk1kD2UvqtQ0wn1yE6bAAfBkJ8THTm7xZhfkfFCseMoXYtd9BAbvB1lloWbtp+PtcfdXY5xdwUcPC8CRtrxJEIlqQQFIXdVuydZ/Hf65QgCVX2G/OXcW+VOEjVPd4s20CQLbFhVyCQxLllALOBhQIfb8XivQK6ySTy4edPyxEc/yBi4FXd7FYXS8cWSyeCvP0xqQg76Smno4K6KAYDJp61KptOzBANclZLQtke9i/A3E/MOitdwFhBWeDKri/fjT/YKwopbm/CB+0nAuHiV/uabd14Hsp8gzoSjES84PvUVifcMZQsMTMupsb9oYC3UdeMUAi4WzVGN3vg4VNEcfdpmcGLaeuo44ZxVEZ2Dho0I+o8U7R7LRbP7hZ+HcGmjcGhIC5JdDsQDzOHZwiLHUscUOem1Y881ERzrtrkr2rZ/FFVesg5QQUfZR7SPkox2RFAyetRlHmoopFHz1SbZ6mBfAycP1E3uselrnhVFKeov3RjC0/wZoSUHOpreqcz9Igjc38HyFIlGmq9xbC/h48VhZ3k2ZTDYo79EaABgApHgmEWtkcgRv+F97iulcJcHyGE3xjC7RF1Fhr0a9UqdOsQOgQCh0n2oiFSaWKM6y1vcn8HoyFLwZ6PzQjwj3p2+H3BDC1fDJsi8wBFTzdtCzc+LvBxZhcD2eacVq2wxb/i+vZ94wI10hJ+GKGU3bGT88C+5mWXKQ2z94EmCznNu2I+XZ7aRAJLT57tLBx6FAEmBXbhGQsMh/D/hoxnuV2r3+Q5nzmBP+miUzs71oJzd1AITUKP8wJ38cVimysUPsW/psnL02fZoOkpc2fRSX+x1ksGP4rUrL3mNp9GcWPZESItLXvw0OT+pxS4YNmX4UXAMnlgwfufnpm2DdT+AFmbvcIaFR01o3lVWB8OtIdo0Frf2sKEo1/SZwWdmIB+9WvGqF/5mM+DIm+sB6k+EsLkmPnJImuVRkR3Uv6seM2YlgoYJRTLI/hmC/fv1lhAbv6D+nFWVzMNYAu1YWdMy2WZMyt8Ued4ICz3O3KESWkVtsbAOWvg1a5fuhx/BoQ3JGEG6G//Vwrn0HqlFoEzuDRsNVv9lYneLjaCPa4VsVc8bHHl7JBNORss1rg7upxD/COJuC+oeVc+DuZN/flcqiQN51SZe5WOojc4bA8974cEVvR8VLc4f14meRJVvBdxLRSIkL9BlG3krwbjOjjVe4DJQ2ywYAEVJOmu31l4Td0Z7/Ad5sfZpVDQvVOM6s8MaSew9MPj0/7siMvd1oA/7Eb+xmL7SpqghIIqn+AuVoKc1P/q74VkdGKyygfFhB9cV3fcXTnmP7hFIuJQCd0k1GneyyKgaOLvjBN86thCjc0TCCMwCMcEXKI36Qnj1TlP8RMhxymjFxYHe/nKkzwUG654wqCT5rxJ6NchPL9lB1v9HZlDNfdFHbcwi1lyGuTvxBlg8BgLEndZqV7Ir+z+d98kZrb9yyEcqbVEKZUikF2ao/Sa4fFr8+3X7Y9sfCQLIjgolbl4Hil6bjJZzGofGsouCdHhKoVt+ttzaCcFp70KE2ae0/wueZpxOH43qKrhKdeepEAdHjk0+K3Aa19qtbv90c9oz8Vz9oi8dDYI9O8HU9Su+gqX6iwpy7ZxNBrfCYEBCX/jd50QlP4GpCLhA0JHr0A/Oh6Gn12F4HeyR4tCnjJtSlOH9dqEnjC8CpvWKpZJ0oe4ZtdjsDG2bFQqySLQKBL4rQzsS0WlIrTLAP3sZoURthZiBEeeglAi8I8QZSD4wWToyErCRMpIBIdCq242eqXAhnw89XgomR+1O2diRC+955YKdEmeb2S/9g8yDO08ecgEdSyr9tvFrn29z1Ez0GpcZh4osKfzZ34oZLfUa4cCV6GIYYSAFvX/exQCyZMJgCyB1soxBnMIGPOCWiSl2awMjm/sWEM5ELEwjKHedRHj9lYxUqE2Z/xH/LCAzLaH/qgXgTYD2sXr1LqKl/KH33i6LIAwhkKI6sjgAlz/BD1twGYtlMpPgfIxI51oGefMXWf2J+AaL3+x7MPqiOGg4TRnV1/ldlkDVIcJmLfoulFntr+Wx7UgGB5UhygJjoF//qjlO10LBIhvrZJ2XSrsRu/aWU1kQZf818QqP+HsE91faOCdC+wPrMIIRqGachUcGIh7221cnBKnbHU7o2ffh4XsDEa2MoM9B7mietF/BhRcxuSWSR33tCQSUFbxFJUOPiYh/0iLy6X59PiluFCoawDSD2puHllPa2lt5REvmxm9ZjNTHtDmYnnztIjlNXH+85OmHmThkxI1MQnhqqoX572QcrFErvA2rO3A7COsZOsR6AdYxBFRz6XgwbKNvb4qCojO2cW23ZQiWzQ1a22N9IslsYj5epgSJdLJE+Xkut/B4v8ipIMGRMgjetNBz87KH//+5CEP8T5PZa0ta+bEI0iqavsyuxTeX1O65eod10As0goSkVw+/qmdnON58X4vXjmvn+wM+lvVfucrb/fUWYKlH0blrv58pxl7FB5dlbU/1K5AwH/EWGlJ+D2YVM65Ed1HwVJsOdYEZLrsiaYHUkFQI6yOtii1TLj9iNY7ENbyoSacWhKqSolh4+jJE+AKBuXL28rjH75Rqvt6Qyv00Wjq2PBQX2HmoRBbKvCb9gZv9ttWYqDrBFN370iIdnRUBHi4E2Bn1IqAgdrzBgMij/AT6CXt1RriwKJn9hbrKDPRT4vm1sOiyOYqQwXvb96bscc5zHMBinuJxnIeFMDt6YQR/iOuFr6szbfXXVE6NiC72S6jpsyw5gKitDzgNp8OJ0lQJBFQV2uLjs66tJbhLJTPsVpqKskdkM5KI0yXjDb2yGtm/WwHnfvY7hDuTxlOiyZ3DnuU1SZZ+cMOpvwHGf4h1PvruOXOQoDLCH28QTXqdNyPcaGvz/vYxPZvjxqB9awMQ2sTPkEbflvCJbS3ac+QhDbT034Crlt1oq5YyxgnMN6TuSXazFOYdZgMMF+vKvC5/ypqG71c9gSwySp93iYNDoLUYxT2YNSU9w/DGCrY+qVz8rEMPeRkA0tB1G6b6rQIh2d+87xzUx33lMmToSodU+MF4oqnvRb+yfYpfFmVWeAVakY9w+zOk11EDPfWCmV0KUCcW7c6xLykzj41y4iy/QfgjFDEsw9t8iuqMm4p4kZptxBbWRwI9g2X42683MruCJNv/XUBkCLIWlAX0a6/h5zZrLgiRwem3LYvQJKCHqpsv0yU2qJGuBW+onjRtx272yTRh6/HM3QUEVhFNJ0ws8+OIAABUlLZoSdN++dYssIWFsijM1XLyZZHQL+VBiMroZJEg70V770oAjm5HarpBGnlqqO1jht8hXuIwTukA3E0zsiH80K1Zldb3+NXaRhciMrEMqcK+V4aEj60BiDvEVpePxzThwhpaPXmStbiXAnho/ISAcbwV7M/jOe2jynuK2QwkVP3OJtp4IwJcxWHTyLtk0ANjmLcFA6OnAgSg9/Kp4Sv9taWfqmEZIkUhr6LbJvOW8voFZP/MIjdkPkJByxai0OhumIR+cOtR5i20DzkwbRVCiD2PwC03UjI4QfXnjhu2AZv8MV8vQ5RvvoMO/U1Pxf2iUbrZAHYT9d5UdmBa6cqw5Pi/CNIuu/0nfGB97qhMyFvqeAFKLnLJQrDPoIAWD5ZFlx9S0dbZLxRDqhNVG3UFfHVzap4tuK4EbIj3UacCcM6vDGQtGJKG2a3thZSOQtf2evMMT0F3F8dI2Izwu7zcLHgm8U4aNEi29D58zn/a8i1teInOlN4D4N8NdG/Bu2abphHyroFsSr+Zw+etu/rkPnC0ZlNr3K55SYO47Q/UtcQSC3P5aymH6fDC0yXGQchJ707e67PR78QojGza2nHFTdOPX8cWLXnQTSARM4xa/BUwCaAE/x/i8ymF8UkRKjTa4v+KJeufPY+kfvVgT4D/FNd5vhL5ZgXkM5GMvBf+I+kQahxMan6FJp9onMbR8B9tdTRFP0FhlIeSl13Slirv9HpZ/6G8gYfbEUga9mJga/qpGlJyMgQk88IOLYAOQZSiCah2BT6JVAvgFySmJJpb4kvAtn74rx9c1gB/wOYM5+n75xYwqk5n1sKc70enTYKCUTJ65KadivlE+k6WWAkTqCeqeVJqo49cUaww41mQ0cPee/2yZ/OVR3nfrJhWX9Q9PU0HEUGczwY2EUUYDeRVQgweL9hSHJpunz0Imf4e+oR/wVx0J+IKzKqrj5idagTdiH+rtvS/EkgoSaxy7DGhpwrkLjx7MBjho8GEC/h48CmNHXvloaRAEPeeng1IXsS7RGqzJal15VnI3ULYXLYkzS85VFsVHOm8AFJOuunrxAILPWG60y4UqtH5+ZMfpWenpDRImTdp5318zAmCX5TG03wxXrQUTGcMo4bNfx2l0eS4ujPCuLBcoj1bRe8+INzTsS1XJSuN9As2Gvu8eMZ9oP3RFaPORZpAYdyCLjr9wul0j4bWWpWh4t3OT/LVoujP0tQxWVHRoBwm9zSVrny8SzvT4NBG4manseOdCnskWICSRBdHtd4OcVxwqKa5L8zUTpMLA/1Nt21ePiwnF1+RwVVdEevuSwW36/NLH6FVH8VgTUMwpWzZFdq+jDJnLc1nPt7Fh0SMmLYhDfrkZqsWGMkm843wQPDHdpHjlt39VkRS5WSpmTpqNUxtB+hfdM93qaeA1FphPd5Yv17u+1k1UpGudhlg8DTn+vhsyiyjd37y1g9foqYftz0IH2t5zeI9xs5JgfF9ZwGhfvYLkQTfcGHXrzf1MBUsNt+429Fn8BsCRc9Et6Tuu4T4tfM9Ee6ElV0mi5+0XUYRdBvsz+pA2WPT9RyT9kxS4AgSkflRYp9vEnXv3taAkahTaL24zvHy0oKTb6G+RWmOKzeN8FFAFJiGdB20PzfGIvHu5/Ju3oavOc1zlYj8XEIz0bwj7MXWLeYM8fC4eHDGZQI3SNIlqsRtaJ0T4/47BcIu+RwYgtUpJRnyPuGnu91EKwAMsLeaCBi0ngeutV6TZAgZXrz09A/pSfAoj3p6YmzB4vbe8rT+cEommIsbvn6vecD8PIeWI8/B8NEOQeoto4BsOBKk4DW0iQCeXB+8PGgxle7lzC9fol7ncteWLL97u1TyUKy/MFet5mwKRRi6qALodApLcZM3h5mvlnqWkliZASyXGkw9BB9EP/++4R5uushyjVJccYoN2i0v9KRnkowbSTUaim9h5n9xFBW45CZ+hM/XzTS0iUZb5LkId9/wgHX4V5r/eKRgWSubvSFvliFzeKC2qPHwmLW/QRbp8pA0mVHQi5bI2hM4HAjcL2Lu+9PUDS3rMy/tDeeVR3wtZAI8gAvMV+l22a0/L9dtHzgTSYofp2cnewg2WAnDNmWNO9gJXQPLOTITzw3XM5JOWkFghJPfw6XMHfN66TW+Uz+PqPXk70KlGpKJhYtYtImQGDcfA8tnfA7A8kMyYO1m4E87PQp72usTWToDvBWdTSDLQNgE8djcEqGimRlQfyL4n03Cbjg4B00CX99OwQzmZLHvBUzs22IbZbW9SDQ6JP48YFWrc/QfzMS/gOxnbJagwxDHv1HM5pb2boxL75lqQRaNpctmJsRYqBmJKFBo0Zg56sr6oZIXukLS2R/bte8TnzJxyYuyFHrcvfeptet0d4lVzFMyx7Izz1cPepXqR5z19Ui6ucUFjMzD66D5AusWMmEjftlpaFO+7OdAM6icFMXDhvfvfiIopwEx91rZMlVDcl/BUKZK7044C96nWNCCJC9HvhdsGsMjkwDnEaUioxHXk+Dgx0LnfsJGu0ZBj8Ey+6EMBuLUAXALLTg8YLWAv/c8YEARZa2feo0da2B8SsOdXQCZHGCbDZPTa4ibfY4XGxuHZ0xpM9knhHqU0sNomkjaPQYi6+hPcXGMpUldcXTW4NQsocsSkBmGzZa1sT1T9OgXhOvTmvMlvxu+haSBUyTQ6b0ULssqI/I/JTZBqiND1l/Y2OYZdeQOecQbqoolhh9eoNkKZddG5AvB3GFLDAXiEBxCG+A9xd+PkTkXrnV5nG9DDv6zABlQUCr5SSC33rCmNoZ+4hOEB6DVNAuMhpZglUVNn4hVqePOYO/Tkux+BfmBB6Z5hFwEFWIOm9RJsm43TtLu9lAwcvbeMHMzMV/RMTluSaxKa8m+SR8DZDQp4oaAQKWKClroqgCsPVHynwiwYd39x/Mh15Dqa6z78lJ1crDCJpVnHbAndWN+fuD/WUdi8OmNR3DrEuyVt2eFlWRzofZXlvyH3L675kdsSEXxt/5uFHvE/C6FefZkuczuSqmgJ/hNod5/6XbbEmw8KU9zVgKPjOWA2gF5X4elKU2x+pCHkmexxvuUqNHpxPmPWHGLYWjGHnv3WU8HP9txj1iLXOijzWTNbgJx9GZY5d/QIMdmpgEK2Ai4cxcErMeRa/hBaCoMhP/E5YBjpHOV/GUwkGe+i/OeZmrtDEXaqqknkRRlN78n7P3Y+D9Bb5DrLUomzHPZac8xiKBhCXkSnMdqrq55xCil6QUkFF/AASvVxZgPvcIIFaCKWZT+bI5ih9xGvuoCMejuZrp/s3st2hPi7ZAkM7vZlObCXWmI2QpAIHA2IS9CJfjvkDSvK0/ypCbCZrnxyverd3413h+c43plQwJLVptVtn17o4ZXXuz/+6SrstFF3010GtiGAP1ZPw9ob+IMXQIb0S6eWHYzds5AcUGzZRe4pCfBvBblBV2VmHvoNgWBg1ALbNCCRKUeWh6Kwd/xD6/aUUrWudQa/K25dXDoTqwDrqcET6DLxr4ewgXsC+Yk+nfpuXIGII+bKnMuDmApsTNpuNwA205tAb+vrUbbFIKLU4TeGi/sPO4tuXI17GeKKllzrIGwMYEG1vEnwOwXyCeuY/tGLI8MfbABFSjkV6YL004+7Gbu6NzTX4Z0OzloIDzfG/13NWYQEZ8NwZluUyheK0bh9NOFEDf9dSLvV0vV3RLvRJuPO9moZxl0X349ZZaf4bzQYUCxv9075+rdg0pqDQhLwFSlBAgv3VBOGQJCl8GCxTkwWM//PEpQQ48kIpdGqi6gy/qjKx5YzgCRtK9cfbhJqIYqzzcoyrh9fyrdjyX3L3/3XcGvYlBlnTAV+wv10TqUY5CtqPlCVbRI/086p1SD1GljV7bV6tvesXpbOuIiBQN344U3pKVns9C5MQ7VVxWHnuCZ1RHgiRDdaHNneQ9KLkx37JrzujsUICHwciM73AAlDaL+d3IcL8LjS/3RmWLbgGQ1Mcieims35bBAud0k3B8Nmoa9pzpwNq2Whwi9VhRoXqHBvCYoppxzbZy2HJRiAbCfq5J4JlGKpU+QLTu/BBJmzWdUJv6RvBItfbjNzmk8vc9rs/qN8xSgzQ8x4bqyrbYw1XzanFKHyCNntItHwUPmRuf4aUkVEJIht9JP3NCVDzAGV2xjDM7z8thXujEDD2OpYlApt6FCiYIPmHJpiOZJQxCBvef7oiELSFoOJZ6Tyr6KHt1eQRnTSZbEgmxrkoD5OowIv8X5U6xOEri9fKf1nYbxIjiJ1pNaLSzNBhONHkRQahXgykL/Bt7LIjIEJUckkNuBPxpgEaKAonnGCliL9YDBTrrOvWoySrKLhPtgaQifFdAi3XRNaPn1Ykiu6BrJi1vO400rCsu7coMZk0/V2e1aNL2NN4rddXnVWRDBhfaVURE3y8rxWmg86QHba0KABz9/PncAqgTQ/+DUYjlWfIgrzL6ABPugF3ziHeWpdlXY35sD3hPUSE+6hVcTWi3HP3fKrYYlWpuR8it0uasMsYINHayhMyDCKtiYR4GjpULEF52gLGww/SV+ZWmUMSLerc2qCuDyjHwyUS4Klj+cKy9W7QNi/zoqtqj+5CC2kuhbVkXF1cui5sQhK1+xfbRfSKyvlHdDifdG7G+ld0/l8I1fqtjWCL8SlsAT3nTSG3dpDsQQNyV+tYwQY0+jWzRJld9tmUXalhKI2RRsP6kKigSpMfQl/cBw/FKsVREexjJ8Ra6WCfnFxb/oum8bp5wx0irxpJ2IgitJ3zS3ogdG8G4EtAwHSYd7t1UXCs2cGXNfcX/r5XeI3bL5JLETBkt99aUfovmSOeG3uA/TpzORwMnGzPjSDDivhEdTdpxGDSauSExiu6Ffeloh4iLbDWxKnZIEGr3LVX+ataKDd0kOxdn34d6QLUajfE3XzGQUr11WRcJtIUgUXhOdXvnl7q2qHIUeCXS2S3xNMraY8i7AlIiAj6Se3BhYIYU+aw3PeTJXo+SrY7hqHt6jIpuNL4vjg1J4qRYmpauhwk+1lO9wmb3XHUPgNpeDjTkAZg1PFVs46qI7LkoXPKJLW23R6rHWTezRkm4BhBA3lXFeEx6U9J1hHHey2aIQxCwA6GraWRW6rRRLYrsH2ELOifkLh8UTIlEbXy0iXamsiknJ2I3YunqEHyX+au+u5HUNhwVoItS399OI/klKjeYso3Y/DBMbgOSu5gOyoeORt4MvTqdmYxz0pEPOfJ1i5T/Ie8ctYHQJPOfrtvE4Qbid/T4ifkwAlBgLyKcVU0esTMDNnAnmmXY/PXX2L0OaVCBNDziTf7UxM8XbJNybcJYYgL6E9XJ6KRdQIO5A12oW7TdRNuzpRmN6t66D8cnhasnMMhjUltC5GNt5oooMylqoqPUGkamQxdJLm5uxe6LHypk3V1NUk2vGpVklpHZ4R84lvfyyDElRzm1KTFZ/e59e37L2u3LwQW78wgZ1WwFRxfqCRMtG5rmEKSFW1Jzyrz4ausJtRfx/PwHHoBASX2Ta4JTGFzu0KLVq6YKtz0JnbHfvt19fRG2RxFF825kUNj/qVNqs6fGa/dYpPUPW6XBvP6pJMZv9b/bEag7yi+Sl6DdNLOiyS2+ZH4OhJtly1iJqOQvHO7gOe2vhSL4Hxmd0G6+BMAKAJlLekiNsVWuSIsxLe0mxKEOl4fMu7PkLKQPN2eZ6Vsg7f+DK0H8bS6WqDm6YfRGP9Dk0FHHvhZy02Hj+ZIGI0QSUB6bZYXlU6bXyiICcV02dzHtj59AXCOBDendh3PHJyhKp7mzKCeCBlK6SGBHIhxjiHo5kjMnoJEiDNR3+bhInu347TW02vpDR1LKpNVOKX7nD91x9hzkMHWkp64fzqmtcxyBLl0Kqtsg6LFYmFDX9+nj7mUZpltwZb9ZgQyz9yRFAZELKBJER+7qVsm2N8bR9IK7MpD/v7kYcdI4DTVEmwqFGnrOuC8jE8KHEV2Qdi8TIUGdFjn8ECuJ5QT32F3u10+/fq1WTwtEVhvn1zZHrrS18ut5wLvIjTjjXzEvRr6HpQe/SIKlZ3iyebc1IOdd7c773yhov2YsQ62nq2p+k2DHdMti22gUbKTcVt2HP6xDbIqd6c6/Rv62g9hJF0p1IDxcJygfpUxfFpDNcysy01xVzw/ib5WI8ir6uBnExOkrsXg8aMZ/5IsfLxG2bOGY6YlRq1P18Kh3KHeuSFoaxBFmOAt7OhWodlUrmZZqM1bCmejyFcUjPfyOJ/Y+G/tVKXiUdaqtjHPXoDQJLfK+pI4gPEPoHUQ8jNd/U5qK44eJ8jU4Hduw8+9zKFYI0p/fY6AuhUYT2GXlIJB0JGYEmV3xVQ0Npa3h/9w7FM8DCjQvBcLxENQwFDAb0XNH2WZTY51Jc+uTbH1j9wz4AqzWojVysdnInSkhX6i6Rn/EPoNpyI70dM6zL8PLOf2Fz1EuElVhjr+pE46XmrKI7j9wLYi0FjIHVEP5tftrCsxdDTp7zTRkfWjjq4HZp7wL+P0ACeCdA7VC5d5dtR316lzO9GEJizIvhE2Tfiqi47L7BAeELrtADPiB/EYVSPF6bgd/q8LblmSOe6Wj6Pd1v637Nn9L26F26ZJOeDjYO73WSlba9MtpDEcL87kvT6iASRI8w7MNbyk8yjlOGLzktqXjVdSf3GiS2kAJ1sie09cUDltjtkhwYkOMnQT5In5MtVzQtrBIe34b7bCYVekvS7flW6/PWjGDQzeV5+htre3ohBfEfAsjqQNJiLbKkQ2qALdP84t5oKnXazwoh/1JA91ZKvn0Q+H6Xr7lHJnWUn/785sFajoXoecl6bPSxmIsNQeQJiA399MzSK7d/ednuEHBN6T067pVrlxSqVqqHGPDIinkG6W7KNW9aG7nknM5KDlQP6Lnu99N+r+GUpoBRY7lovuHaPkIFVjsUxcwQV5FtTJiTM4gz0jnUHRoL6RV1HYOD32IOmtUPVGoBcRbmMG/e7Ik5cVyjEZBj6y6RaGXRDTnl3fTx1kYv3pvxytBHuCxBvZKgKa82AF///11BiAhAQrzNMmzIPCe1nEP72VhEBZndWXvQVcBZWcA29A+fG1CYdMSLkKl6L/YvbeI145H/mBPC2EH+z+ed8xaKVoiifbnLWGpsL5I2YpwWs9y6YXJycDaawsE2/gt/Whi7sHEMY+QdttfIHgaRc6hf1MAuIbe9GQakgMqo91X3KJr9rPP1FpblBY5kQJBjVwCtmsDrjWGstq7lxJ8ZGQyaIHLLp1AO8D6yDMEsE0q2KRQOC0kWruE5KXZKdnrsZnpzlPeWI3yjKMVPRBqawQkh8jmRND+JAq/M+thVG4RBkaVeAB5PtugEC0sVEG69XrDNYB6z9qJL1KHGVSAI0pE6hPPj9thJ7yiHzOJ5tDL19z33nti2w8qdzdM/JM+85pHJ+g49ycBY+WzKv87j+muPI/fb3dYhImMIBetlJPsPdn638jl5zjq6A2rnPRpHTGIeYIcSE67Jrmmg50sG34C9JeOKY6/IjiFeNKH+ohfDLeV6y8n5xpq6p+vBg7on0PEl4/LCxLbQK3zlZB+Nhzi7Bx3Ep0V9QM73tU8BvPZPm6iDulpvTokMRuFtVI0GrPDppASJrA3DJH+eirZfmYXuBCr2bPF9krphR2m5ltsXMc8z+UYo0q+l1H5jSRNKSO0Wk9uSjMIneauy6Yh6DxKnBtzhm44tT72xPvZCVLCtRziBMwCsAaMBoluVo0QzUBH2v/LZdtAb4oHg9Xpdc533wIzGqj57wcjrR2mW0f1sH8pBRuPFYFQpOoMtHAJ6cYCD7BjKN8TOv6AWFOQKXEb2/cMlQhS4R5XayGSWqnK4t+bvD2EENoqCC3EJX8pEdMnUOCofXteFa1hUoR7snVxTIk8ypbqK4kTFwPc1ASqYH5Qo/FYt56OrESCxoR3PSfrhE6ZT5LNWReQxnkJp4EW2Lqu7+KZa4Tp3GiAtjs5QTIkPYsCgT8ftEhgX7Yjkog+ONyeZKzzlByxjBlTjC8CjRlEWYJYj95RabW0fmbKBmaZOwbwpnjGBcIlc+/juBriyDlkFuano9HBbMggL/9Y7Jc8GbMgxnI9bJGLKqsw0MWp792EufS/JNFBoxPVUtZOAVhh/ZG4NkrabgiTBLnNJ+mMxDIiQ7boWju0OoDnSJDHaPMKY2lBgOLO3iah7F1T14Tgq4mwB0kTmBd6i/HOVqsD6LDDx+f8oMjXjpL43v1/hE1Lk2y815qVAGzd3+qmC8/7cioSibtzPd3Q+pu0WEj1eOHYfgdoH7598BKTRxvwD0Fl/JaTnKU0c7bPmhvKDbzhPsiOCh/otP7g8Yi95VUSd/Bo0sWigvUHVta/u/MW7qTd6fb+YrLC4dkNcD42HxEafxgcViWHhVxTN3KLcHDF8wTWh24r32L3Un76IXZCXlywAFCIiMLUlMcHDj2J+DJDuBqUU7bhvUEK1veZqupsnr+02vsa4J0YYcpU3bEtoliUOa2QPApmjVI6agaRDg3nnUUEHmq77oBj70iEYqq4za6fIs1PhmIV5z/8u2MXeKpx0gCEuMkZNBB6Qv3PDdGtd2p642P3oJYbnCuqDyHjEE7m2k83BTnJdW2DGM2/HKYXQR7lIHXmDMD3hqbIO2RBtxvhnztX/PVezkoWqhhmxLzakZLVDfCte0GebQmol1ONetMReN0r6NWyutMM6xP+YN7JvYL9DHzuwWvXO5zJzHdu/StBSUviBl2xGYQFpOyJFlFYopwclwPHeElxLfhWmz8A75/RMYvMDHjIzm/rvCMNbYybSmX9Q5X4CGoVcbLUlOgK9XEpAtOoISO62vSchR3484X1cIywmYE4cyRC0fmTze7+phuIKt+ly5DVNzhWOQOT9k7Vq1XNxgdKW5HuVXThRMsthI3PZKuGZuHCKvePE06S7piyAcOppSbH+MN80aVmDFso0XqEias6e+cd8k5NaThqgewpk3h7HjZ3v8hGSJ8BEQ7BFq6ieWY/sAHSDxzSoCKaLeLh6PDBDKP+bA6meFvcFNhF6+WV5z3vvwgBtxin3InYMOSvnoYBnaoQC9qWWURw+SNbAPitbmMBqYxaUiWaupOahsn2+dLM/Ka+zU1tpXq5PLSnwACY5MuUxrYb2WJiAsQDf3HxwKOJTcgt7RwT+vHjS0ZS9dfWfYxXjJB7FtDtE9FnpXoMGmFzQC64GlXv3jbv6BWCojasLkiZcBiQNq7SYQuPXd0cJROxSeazSuchq2V0ZyLUoKxWXUp+DQuhGn9vjo2gewToT/FIMPl5y+yFgjlreEgyAdzRAw8ECvQWkM5b5RJRfDEguRPNNavVOrkNddpkCwvDL7CwqwboDCoz0qdMCDerdYsIpK1scni1Ic21OPWNQkZDe/DPYuamlkbo5aSJnRHyoqPR1xAVBu4jk2Hg9SjNMJXt7aXHYzKK/76kMRFi94X1OzA7c8Az4aUbYColwTbOegdoWr/eF/VZ8V1A2rYpLes8B1eYD7bDnMy/sGbOHTU0BArTAR+Ov3b8sAgMlGcdeYjhms2YPKCpj/YAQcC/y5CTEQmozIIzSUsqmyMButez+tyPiotEycRVK9vZ4Yl+yOChoPY5F9Z6tT8I+I0t6/AKmglUmLf1YC/EMbHyYMtWK3C01xVeLvx6RBjHDMZZzakGKbcLvUTifbf6Faz46W/pEsG9Ehw/c+ihwwPu6hfMlUP5OR8bRZnrINY0PjnNyN3/+AHaWVmzU9LcbkrJFHFN46FVLEDbeDBSv8fIraqwU2ALFlZTNzKVAVq+gTi+Z/BC61XFlEkepBuRVt9cEiiFXGGx/6RwsBBu8G4kKu/Guib+v/jfsCzEqNfOZ9tqJJbdrz1DMSb/JTUvDrvIfhJZ+monZ8y8L0HjrLB+jjvquP85hY3eyqK/FpMYWMgZuuos5NHbtcRXo9EYKqf0eISbZq0PvKdjCLptPIUhqFFdm2J2lscdgaYuf8uAA13kWtg1plVGNTLomORmsU9IUFcvqjaSN95ihjzhYN4JMtwv/Sf7c+pA6fehJ+Bn54U5SKzO+agazrofq/UVWyy69tAdVmy/AgNXVJs01l1c3Vps0l1T3wH5P947UCTSucgSUgRWZgMjRSWRQp9gD5OReD2D+mWVc1c+Dvc0wLTX0/C3Z3qZ/tQRAmFtpnaPcWwBt2rcFbebsg7V9nw6EAzOedlIVNdCr1+1mdRwIWQoE9KZG3I3Ws9/XsDE9aNNmNSYckRpuzMpu5/Uj8y5CAhdJFjYR1sShTZ0TJw8Ehcv5fN0wwN3n8K91REjSzvej6RXxMUXJjlAwckkvQGSe2Ycq20RUu4JzJSx99XORAL69opc+Es9W21ZkvUYfGUEksUnw1MGK2mxZg7v2yillkf1K68YgRgz1/bXe31//2RddBJSJBz95SBwaXi1V0/py64P4BJFcGSqB1Gi5GpMBaQdm3P8d/+K3PVI2Gt8w8wNtNe2OapYoU06PRCUm4iS2ZDtcrmtPcFM0ljbSAUtkmEQfXAaRrwqaKUWGnuTkucj5Y3KWnN9qQb6jMLandOy8Li6Kc3KFylE8GHiUO25ULkPBkbte2YR07ccRuPOrrOOYUDHCFzUzakBN8UyjYVrK5url0AOyqXcKPjLIqMGfxbwZgXv2VcWualqyDaWFy4CTIFt0xWfRCfynjr7h3jqGOKU/s6qN6hRf75FMFodfrRFue4xvY+diZ0dVTKXbslyW8KJGHE/YDzQPoo4P+hd+GSlZVb4+p+gcR5bMYh6leaOwm+c0V/aejzOBPZ/hEzF54ZWl+eldPDEbD1cnF+3rXTAw8J1Ay9pAcvbL9IRgC14UHs8MZRGw1ZOzxKDSjE1N226zDiGiqFtBsWnRmN90YH+zNMtZvfzcfCfS33LkJoEO6tKoGZqxJwbU3m2A79paSDB5QCgltJwXWwv5k6YHbGBHMLNWMdoU6J5LyLXGzE216C9EUjCq2QwU2//SYbcT2oYbj/rYMQGxGxzYieHWIDZl3mg9MCL3jkGHJiOhbmEhC96NKoPk8tlhEsX4/1sDW3P5ZJ97EqBOduyF7TKbK1VzvP4ytF0jKZhccoQdQxGPnS2ZL2uSGOg2MvJ7mvz8LnhqIbedyzflSmXhSLnPR5ARpATn2unjbkuFbXfLfQxig2rcgqU1zdvqSTkbxqCtZoomnpFKpeQV6rtDG3hS/JUjsntBzR/X3oasN1NPogQBpAaptHOz2w2TwCPf3TKYimXjvVQEa1DSD/buhpsrAZG2MdWqWWg1voFo04dgIILJWDmJa48QGDQI5URcRtPGWJombwIue+JsfNtMCc5o3pH7vgyQib45seIrdc71MqJVSeJu9rjDYEFwK1hgrUoFFg9Dkm+O/79lrWAintF/trwAaH/sPouFlQoOZG8I5440rKt1gfKx+52ppzPkjyra0C0JnQIMGyq1dkVPTY+bpRg/esx4lofZVIo3hyoMqhVNUiiPl+PO8i9kwf/KuXbUSXUyvmMdwKzUrJ8as4VEIVncb41PNMvltkGnVr+G+E7X7JBUrHnrSCtyNtEtiPk13NUqLauwKMZRHrbjksEgp9dC5jj9PSV9cUQGwl8gTck3oSAsc+thdo4zFMIkrhPkEY9/fEiWGbipPKyVAip+mMaDg3E0Em0WWeIiKBLshGs6dwLYvdD5i46REbk2p9eKSUkdMz10z+br0gCgxO6G34eFhMqnddpg20bDxW+a7P6jiflq8ZAFhYsmQDmFhYt0THGuVbmJUdEYC/ghor3BbH9ASx3XGokjZgSyDH0ecOBwC+WETVQ16E8ghE2q4ej2HkscEiCPePGmWCYRWDjVM1ysqQL2tUntk4FQAImdAss7tdy4U3xbzGp5mPvZFi/5ZNogghh/6pc33LE8XDgLFTNlC7t0sCLAsgBQMHvfCnDIZfq4J41LN9ZU7wTX8XroRAwxyUtLEUNnYLSlzeC4w16j+CHxYb/ykJbcDpPui39JyCzDPXPAK9pOemp4/ztC5AvrHs/fIYft6U+iqYMBCyWpagwosjRCF7UbfgRshYT8S7xPQI1CfXFn5TdDo7IkBksqcFcmqZ803krRzORGp2HTI9yarx1NPwuKZN0MuixEmsduQBocwKcKNJ24W3GD/WaNo+iS+q31rgBwvHjcIXYtti7Uxs6WqUo9SYyCFmxG2DjsVl9D1dHqR16eBoW9wfe6qOMWsIf//VeOVBvNkOv1NrhS9gerF7KCSBRnKtolcEtHJElyj9edoo+J8jufTXT75kjH+H9GVsGpPrvcbtsL5qJ+paLEUkrMJiR4tFeQe1R2SoAGTlrQxYpg7U/fNxwGT41REbE14PZVlZfvAAYkNgYEmVlRqZ4F1CalYdADa3jrhsKNis+uRwLed55NqKQKWCGkvSihSK93lxXOMZsdHcdtcFQz5jQWzRBgzm4M0p7M5kziUD6t8Vqq09atZhBa6R+b+CJnb8+7RPiH78DGfHXj7W/tUFuJsCmeSIs5cDLIkMFTU5RNtkTw7xgp6rRGgPfscvMujiKSqVih5rvDvR9JxEnVc3KpI2XPYIIqyiuDKJEL9QrW52ysNwOoga4JmYv6yH2H3rwwWoIZwHFUOiaTAREF1AGizculI9yIhUsBQG5z7BtoenJ7/zFXM0t9s4yoHjWYG7LPu+b8lPjcr5g0hlX/Zv0LWyBzqAdWacqEqug9kOj/ujlMXZm2mLGV0j5w014zmLvqWG/1WEJm0F/0UfXWcSlOLRujyE4/TOLaemwoEYdKTI+X2e2orBZJM/rdZuRn0+eA04uvUuotk3jEWMfwQXnos0dnWw/fTHuO6ex1CbrsvuVPUeKTAaBBg7YvwlPHuF/CIG1gB1BYxEm3Z0nzLjP1rRCv6DNa7lnjHUTgPJpqSzU0eB1xQXywyFS9ksyELXmQCgmZ22J9ohoVe4GZgnGriUoq4oRgADvoJQNClUkFpDehUP6yNenSY8r6J699Ajcvbb7oVdBJdBwW/pAcpkKFLlwiKdnLIeBOG/6dJ/wG5F9enigKp/U7fjsporNWhwF5Dvc+lEaLbwTbu9fGSaypaQgf/8nHIMXBbxD2lPEpwMr8QolnxPkF4sna3Jz0inMzMID7M/B/oNVug7Sn44RA9IzSg8+StJJMzX90fJqjPjN1FLcUgqmMbdys0sKpe7UcB0ary+KprDKlL972v6lbfq5OQca1axSSUzIM3iJ4gmJZwpVm3jaRQJRczKxP8jwFoAQUrBlzqpLJ0pgQtIn34i9jYzJ13B7XPS2n++qFT9mDdAHRpG9g1o4sVxeXqmvQxAd+HLrXKnVMnickVcjNkAHrVRKsyBFee2uIPJNAH2x33xkGebo783nTi3IRJXZrsTwRpFBKS2lgqEwRRqqHDrZUR2LYddxiqs+5bAk8tvAovYF0nBDN31tw+FO9WSgNu6x2AQAsqHZmpB6gMyE1kmeuegYfX/ryhfq1z2PRz6oVkeIbsAI1OflvnLOn4hmbH5iHdeA9en9Wp2gNJPg5Qer7o9DmbnR7bx3fBpngGCTajidt2x3txokZHwwETHPBCVTdnUYuuVSkGUDncxUrgLD0vvHczUVjJrTkHvUVcuJ2ln3jFN9gP3g0J0THKY2TTQSU+VpnYQWkjTtl44Xq6pqV/Ev/lbZ5goTFf7RDSc91Uubd3oslobOP1jMcv3Va1u2lxxLm5bi8n6JTot+GzGTeGzCXVvT9fuLZ3ZKyO3Q+JWhgp5t575514lnVhWUlSri3ET+3TarfGa5Na4XSp9bAhk3Jbg2D+XVve3/RLTX4hSyiEit4h9Q3678ezYvpP/GjjZY8t7yklgsOsE4XNRykPqmqdcnUJoGiIw5IumEQib0pz3hvh2Q50hs6FLQtj17CWyHknWiyN9tObuSmk65af0N41p7HGV6GVMH2wgqmPzUajcPJ347I795xb6SLO56raeQxVpY6GQiNV7Cko8xpvxTJpEGtPvMgBb70iHNgsNYhahPQOjWc9svTfcul5enm/ztQpfuZMAkT9ixiOVwwYymLe9bwDB564IaDhlGtYmq9ZMj++Ad9cxjfiIUDb09aXUBRB4OJR647e5fPoKlFodmaRDItQU9+mjX0uJ5IjP0E8soucGIRf4ywOBtzAOSVt2Lv05IGNslDFNXlwHqErQgUt9YSH460fRBvSUA3QJV1x5CtDH9T0uugh1PKCBgUnY75VKIuMtvnt41/3DHtk67id6Ox4x8IdedB/XlapAnPshT8s6D8QvsgGBaDHlTZ9WaV2g5bpAb75joXjJzN8dPRF9qhu/kSBKQw8p31ZVREeY/LVZVIPu/I/klDyykY/pbKwDeTdd3QKq/zyH6qT06H+GA122HtB8IHLGi9WmxJSA7gWJn54qZTCxl/m5ITQmT9hRF/bNrUJlOKySWP9V3kxg8uBq83xFpaS+0wKnC6fkQ3aaEr4cmDwl7rV8a7sccbfNhPsvJYxUhPKv37fTfrowwbToyXhqrGmwqIqbZ3nQH8vwIFWPN1s0nsPGSMcf7DSjeH1Hv95zWKJz2ztcPiq9h3srk9jTNGaau8MauDYDDavkRjYZ/BahwGuuk6UO+02c7HJ9ucIfmR67UgT0TW9cop3pEU484ApqXt3W0DqRG4QT67+STcmF+SldZwozvXbc1KjtWd6J1cF4W0d+JU5Zh414JD9msRnh81pSewsGEagWrblOAD4mu/AOHuVeQ5+LZ9tIStfAGAMXPIObv60uJx+qvQuzJs1oNW3AVx4dTm8G+ua4vMnZvFB1Gikp+giPTrfFhBDfS8EWeDc0DfPvkhl1MXt0R72WpnxGX0bs61LNdzYYUZ8vyIAneFdxz5trHUJRU+ZWPKs/shi7DuUmmLF1Ecp6EnVY2vF7QyAGGl/xd9CfPCSFjmsKzLLP72usrSxUCqTX+q4IRZQaK24DUQedPKhKapKk62zIdZfwPY6rvey+QaWZMUtYJAjx/Ne6dUfVWYkoi8SOR7PK+z1MwK8DZa/+OTrNlDV3urDUa+g5E95hjKK5p0JW7+JWw1L1SG6zRVuKSeKCp7OkIY7/2R8n8/BF9a8QhfWjnDSGdtoGG8rsc1n53W0V7MrX3crr86h7ziAZM06uvTiVrt1CN0HsMK2LsYC5Chf/xwhftkcZgZH0/ujm4az95k5yEj9xc0geCVdg0H15dvfarPgfJOc7t72RR7blaT8s4QN66/RAwOhvD5czmdUMf1RCuD/oCA9SHqbtwEzOJ/vWwRHeQlkNfYooFvCbybUEVJEVAgSjXcLZIBCIdWfZv8r7fTLNdHWzVK8lgWWK/8UHdm3RBeox16zsPmq381AutttLwSS6227kjxFvVWtR2RoKFqUIUaS5o3fCDgLVp1KHlelX58uEKW9Nahy4HrHgBm9irQubvZBmVBOOVf0nPA8v9hjR0rRi8+fkQuN4V4vf0fPNR8TS2lD4PVosRUS4OlIK8XkuMt+AD+ANWgTbWYKblGXt0QVAVaptfMXkVIb94yrW22pI6HdX5rECOn0/01G56m0TN9RwoqPatJu8ye/2HTzOh3rsZYCKyfMDuQu3tv8BUX+Y1Ko+RdO8FKyCO1g6SPxeK9p9Dq3DO9DaXgWW76wlpaaCKNvKvDZXr6Grdkkvu6wO7RGGVSJDCB7dyKwznWsU1dyy1djNfS9Tp/vpnaub7Nau4fn+CjIYKMcbHgrfUlc2c4eN+9auVGOMGt3Ik9LH81TiCTllV2Koxlyt2rlAJhg65unlhE9Dzo6RgQUfCexHcHWjwvilWVZY6pPnf5AvZ92hsJ+0M2R47PJD2COMCUDgcVRItN2KLHColqkAb+ZUinznE5pOaa6IMGvOfcDz28c62ZDVpW+YCN43B7RqifNdK4kxwhvojRuqT2qxr30G1KjfKbkGhZBKerNXP+PQdB+drRPzycwMOG555QxY025RvNEA0m9wZTdEpNWN17z+Ktgr//HBVob1e6LCvLMYXaQgD7kX+bK45268mZCpRua/j3b2gkwQaQdITVagxg1RDzBPyL5Oe/6lUrqI7de+HucfH3/MjVxSNcN4tMw4p2U8SfUXVOP9KiF99+7BvGKgB8jQiuM5ArEQM26cvx+vd8yttg5t+OJEvmHqX/bci6E7yS3eVyLAOP/G8UKbV4KraP0bOKY/nXLKSckk0sQpt4zdasu7HWmGD1LFDQ7AADaNUYb3SRV9fgbF7ZVQOWXS0f0D3eRVCUpe+NaE4RyQijbzqjbEbzs6GWbPOnPh2B0lx76SMFksFrllPDmoN8nObcq1nc0GRNTcfcfdCdQ5mRR1W/XNisxi2UBkKHSEDO8jf6RK3dUqwBH4h1VuhEMEA9uzl1eMxEs/SdFaA+/8ZwCoQTh6rlftSf+E+MKVL6qGYbUXI2QVqGoznIGZ61McKLgekyN1MdyFnj18OhH4moJsnfP91TSv1bNlRBSYfAWu7/C6JoTryRnaaSiy8duyF8b2PnS004mqGO6KtAarVOkxvYnZA2SEmCgeD13GV3cvffI1ECtg/OR30HH6a8/6xzAI0uHzGBVdoK3H1N5jimLn3bJI7JQjyx0hgQzip0RdASo8sQpyHEHhbzskFFT1NeFIXQetS2OndzkwbvxXWCoqcngzhbT7VhPPs6yAVIs60M1/6Jiy6eRoyQkujHz3GSciq6slVVsAJ8NJscg/ceNvC5oo6UX9meEaGah5LeFMg0erzziWTQ5UvuOWrITCnwyMjshtXIrbg2fDwTBFv+40vpMzDy7VfQskned7VFKActVa4X/zF3wV3a7IMQgjOnKv9yUISIpSoCp6sxEGPu6ObSCmJcovGpv58RtPqRGwKddzpJEITwMVZqP8M6yq53rcSw67biyXvoD32eh62AUli2voEYjzz1YtNACWaLtdFKZpdHd3rAmW+YpZGH8djdN9lGXVSc6tnBZq8/8ggAwfrVYTba2q//rWdsI44G5+iulReUIfFzAlDQbP8NPOfCgDa6AtIOEx2jP5fuS3mqaUz1lADmCwxBzP7fI9gb1zPku4aZdnWUEPXruIGxh3+rGSg8p+kr48Mx1mdhNX4/M3LPWB+DdmQyQvI08286uLrISbKrSyFYRVm/QW/3jRFPaRxHvtLz3PoHWDAIBv3r+hIrnP1oz/fqZmUKE9sAuSYUry/TcGOIlGyWNVlSWoEtEE55i8sux/Ysn3hBc6YXfMbVF5UpDy8WHLA0fw187lJH112wy2Wpv1BqONIzEWYW42041RgKHq6Z7nH5YVbsVtMklHbaiBpDfeIb/O6k6zTEbe4UFI4RCPcMd1AU7hl1Y7QP4cTfmU6VP9n7oq4/oc8GQTBNN/+2cJfIz2wsUKaan/puRbf6M+n5iF2e+gYiiTIQaHAxFfNodBt1mUUGo+9IyXp6heGzhPJuzlQB2r+RTXlnWeYrWLUFdjJ/KCDCxFchQe9bRCWqwE7naT9ZFPLUp2f7Wu9dOAcAooVu2Le5+ykINdU/o9SSuzB/F4aojuXrwOQ6n1wfKqRfi85Y3n/NHJNQLO8dgrgBAlwde5oZgJyCKYjpI/aNzfHZ73N27DD3SU5q+shVdkByVDOxn8c9ASlWFo+M2CviI9Um0kgda0pzLXas3kDRmWvzAk+bao3cY5bin2F0LCndMyFrYeh7eRvkfZQjb+m/qWkI43G7gnLHJha1lqjH6MRCgn7Bjp/dxCcWEISfpHSV2efBDwH17dwuSYKSvoNNUNalxVAQyuIYBjFTDhFRPfUpF88P3KtKz8SsfzhzGUXs/NPsGqCtDIA6OhUcGnmHsxWg8eswtrvkUgSKcHsJpnFz1rCnsxRmbZwLUGgrB8dBLiMmXMmMbweoSb7X9v4FWpX8t0Ejm9/HkzA9qgDHl7it6xwvRHsX4xscxVE0XR/NjhDdNWBviDDT54DhaRZaaRPv1TXD9+y+HTLf15szUe6HzPU7SyIvXAL6Nkj1HYLiisVU+HASKSYYdoAditAPqeqTWDuxjvTNEyc8L7/XYEN81PKRrXlMa8Vr+HSeM6XNvuk9iNr2q4M5fOrgW+rCcMaV6LImnraCbtwsGWX05FVxBy974mo1A45FSgzZWDeXsJy0hI6Ev7SFvqDflW/vcbzhs/mBmysRyJ40f6Jnfq2uLQ5e0HxyAYf6w3hPvfXZ22bYNue72ULeyjc5sCrA8Vhby8+X224/qEKD4e+YfP6pUnZXulM0mQ5uLGCXQQdNZ0neXtAI1zY9tcuOFyjbtYLau3R2XlnomhaMqu61gMzyBAbWIFYfN1U48f3NHLC7aXOQUGmuMlR3Ym4bAOM/ny5FMaYIrkODu3t8kuY7J3YuXOT2km442/g2qZEIj4uP+U3MepSuPfUJCjNjBJGtsJ4zzyF/dmnFAS5TNr/m8cmvun6eZY9s4MYq3UIAGJ0iA/xP0iTPNPaxVq6b9czWds6gz+8HYfbDL7AQ/abTzi8OpVK9a74Fh4nEMXZ+VEWL3Rwwzwm7ohfVf1drVE5NZf2EqOaCxe9C2cvEPxMA9hLQATp/YlsNBRShCAF9imL9YE/RQ+DU9UK6LYUvMbd157lqYS9ey3GC2LhAEX+xW1g3kURc5fTflWNIwkzGZdpNN0HJxZ6LetiTROsbth7tLdVXeprG59/+5yJk7ejWrteoVKy1BH5Y5z9rAPMR7UJS+o05BaQNQQoRZbQNrOOOrQgR/20YON34CWK/vd2/AR1hlK0UmxZTTDgfZMG6p1UMpIiyCBqT1ClUG96XJGgZKmIt1xo2qbhJJZ60vsh4cFx0hazZWC/ZsMeaDkIHDBUS5EJkfWIzv+B8iuxNyqYoZs/U/5uReRc0zF2tWGIH109N/WFm3ORi1Uwwsqlz+zgci0Yv0byqjjjwCbTcwQQbhv5/FE0qaqqHnricYZSmJQKlYrd86ZlUEs4LrH3acV5G8OOSL5EEfREI2zyJdUf5evhTG4kcEBp/xT0u7ULTn2S2xW4oNWOCQq0pGLAU4DuHhzXl+zUQvN+mmGgF7KCDBEFP4QvPejPFbx1PuJ5hnWvvjKHyYIeXKqqJCNf+TPBLI4ozrEVTWNVYMbs3VvAxIcmjfJy6fWXcRlY2XLayN2GE/7qEqBmh8t/2neap3x3RcdqIjvV+B5IgTKWLY1Xsg5ckLybSjb8KPnwSg+215DhcLAwmEuFUiOPTnSB0OgRbzWYATfvSyoaw2AZuXIK37g/en7iVCCvyv/1azOL4dnRMChr0YlwdmeuCv1BzGNQYQM+SdyTg/pG+ZqeSc30B3JHL7v299wweYX0aYmBWFz9xqjjnclnw3AULxck8xreGjVJuV0a4Jj6ETlh0KaYv0g2bVJBFT5jQcT/rGoxdayuLew5zFv8oqiPq/aHhFf2UplW9ZqGop5vN+ZrU/GMsRArDG7TSDQSdheI99TjIDksxaUxg6AqEoV7M+oaWVmQGreyCbXSOJWwIbxEPevLokXCDH7CUASGrqopVHLB3rtNyJNVV12lnJYZkB/N6weFwswS8U8k3MzZiebo/PdEUMwgqQwr9YI8uENN4yYelVVhn6K441wGxfkGlHiOuXvqrNbr/k/RHQxGeAB6yI0VWvETHO7hSaU8xlUu09Ekq0mOq4LR8VKG15weyL/2CWDGPLIWESC8aW1HartskFtIK7THp418bAKmSOJ7qgWndH5vrFrByhRtLyMVZZgt996lSV7azU9SzN1EPQFA9lySd3/Izm9wOW2kqjTw2BD5kAEXaHDb2MaTbkNMmh4PRCFjQVN7cWkeM3pnC6DubYld7sBov0qsLBS/xeEuD8sRFrzOJE3hcZRgOtfEbUJuErzEEnlXuau/4Wv+HPNFzprRkJKJiBybKBdHCYqsBF2ovUDW3pRjbReRYKEfgkS/cpTmQEfxcdHNMDCV9MC8rcjROt9PQwNISt7mD/1rcjvHb0C8FU4DnCQ8oFEW3COiXDDYKGUbOYIu2/d4SXN+5nOL4FYG2/GJccvf9hJ38HSmr3LWf1tnbkefLhVXj7eWrDd2igPOZwFt4io1cxVVGy0tvqgZz0t1GcGSh32B5eDRo06MxxD5HkrHoqJyTucHZTWrZTQJLHV6OmcPcqbzxZ0vlhe+GJRx6/0XnEuA3QjyBXIgp5OvHaEC6RNFoGbVbZXtvD4MOQlnpMSGDxSJ82tLDUEed2Ln/UszENE317lkasTz2Iw/nC+3bVblIiDywUhlwrFP0wcpKGVeX3WpozqrjBH6RVQUcebsSe0vsrnDyClTz9BCLSa41GRIaVHm0+gcsXvIOgz7F8QORV8y+iNfr8tqcCecdAuItdSm5U/K7uTbIs0UZ4OpCacJy0DQC0a9B1D9JRD+F6XG52uTo0cjrSKZl9Vfj53LY6zebrfgXHR48AHwIUvCXc1DhkCNXDW3WoTAmSMblzMB2IRYCqattelLbqL6Q0CJS6uQ7aqTWm12fbzTKZHTT6oyqp0Ltp/V7mk5gk9bmZTrs9mjKRY7xiYCxFDbXFwJkyVF8Zlp+KphVmmrB0V9D4ri0cD3dgCp+zecC3mfgZwcBEMLszMyL4QAbSPwy1YiJvr2bYHocnCwHHxzD7UdSX8FdIxw+Uqh5veWsbCEQUWDeJZBp7/12ME2XbUlYm1qLV9cDP7rKTdrwqaHq9kbiGhV4I5GjEkOBaf7xV2aWEJtLVBNt4ZfhEgAmaiXlBS+BGM/X02r4IcfW1mzjCcpY18iXVZviin6LPaZt6oa1OmUgNkfDnjSLLoIVdVzsatpZkTrcXwefJR7f0dEJh3Ufs47xrbIqbjES5JUib3znQeZSKFL3ILxsOmSeC3skmNgHb4uB0n2GS6SrjrYHZQmv69TN0SYAKNYKSHvxRgFvGjKB/Uprel+M+6qa79eiwC3uIxrM1eLK3amw7PxJJMjyrS/7nUmcMm5jURv96v0wd3AosOJVJii9Zv97ySOUlOKdXb7FQjxsB4lDmNdnAQ/3nzMfzOE0snVzfV6psbph7yBkUGT2PZVAK2OzU41TpXopCkIuIAtL5gsuoy4pR+/b2mOEoyyGcO/TFMSL5yGRAMgdBzlJNq9duiztqzt1BlVclfwgS10MymyR63Kf9ELesAxTzX8Bf4t57NAYFY9P1kJbNd8aOgk5hiwYVExYCusDzntOVQWgyM5B4u90SlhARlyWy1rvrNttSwjJjDq/dNrXM4sB33wbqqL8crNeW2b+7fEe1kquo0SYFRcgJTNMKNIYaoys+yhONGEbQnY/vyo//joiGtA8YZYIhPp4pz9MZ6a1dXpU8XwKu3NC4zjfAYUr5YBOcVmwNvu1NUP2BT6/7yuEie8ToQxG5KjSD/Z6ZQ6ftPiw4dilklSObpTNTAVafQc2K2WjODjqvNRokDjEvuT9bZGTDaAgeE5Yq2bgS3IPs7O+Pw7BQpff1wh3ic9StIcXTnVn03US24vL5GpfP8L39g9P9/sKLPKSkryYuXFfrm4+9SWwFvTPClmGsmwrV8hObJJ4vDlPu0nQYqpO/k4Cn2BpqRXMVDQ2TG+8eSvKvLh7+g4hPuvp8a2hw5GHVyamC4HirTIeeCGvQMs5HXgCHzIAebSSdP7B4XCQ6WBMI2XdD/phbaq6NuJzKnVYmfwuClgF1A4I8sU61BpSYEAnFuddPMEd1QMEvzqevjWaIA5aU5OW4ni0L8fQYXwIEh826JwSUBirijGiuilHY07nVIAnKTsT73ouGN6rmDsRgpLeMJ1pvxI11MPkrFohEQPjL7xGw9dVmuYDbylMi0kh+prx7LPmZHs9pGFhiQtrZKdNuUl2QEIhzow8TEvkJAMCpW3i9lhkYDBAbUpMUkh/G6m6cCvVnDX9M2Rsy+qsyuwdD0kBURvY/fb2QeCgdf4KYJwPr6GTRL4+BysXDDZOtODXH9+jpXCPj7bplh18goPEc6yuL8xn9UPW/KH4U7l/fDirJK3AB9zRV/e/Bo9r+8UbaBQWQY2twzWF+qjFM6j9zojrHhSy4hAIWFfyQW0IM1IJIREEAkTsjlz//Z5uWlnQ2JuWpWTQERhNxAGBDtZeOVZqD8u8Awrq0nj5v7RXGKtDBz/s64yO+bBnhGABWDII1OkjQIkamf7N7yX308WRTq17HpJYjUuERdaDF0F8WTe8vNWFvBIrJ0NXH66lXcqJ7xBaL0SS3ea8hhpOzDJmerLm/kZQqL/lhn85aTICPssRjcIcsbJxd6pmt78tpjDvSO+k+oIQJnwmnhbzzvlrF/H7MeciUGZfwX1Hqoivy1+3dGXCkorcVvgOiqJk37VsxjXhD+Fl8kXFwpzidGQjyz08Pylf87kcoRDVgxETH5VdPViKwoRWowji20MhrJcZrhH57P3fRd/mcMFMwpf7KCxS5TTbzwBzxkWcXbwyPJs2sG81VVO4LeaMiA/qvhAWezpKaaTGiDDfPmIUFfsAYPAYGTU4NSWp10k/sMmTjHLCgsAVXMt0D3ycCMRUCBh4DlSMJQ5Jwqc53PCUwwMBnIQLvTjN12UpGv5Z/vE+2m9fftE0x04xaK+j7tFf/O60ZaelIWjPfhR19gusb1KMnkhPZJ3459wy3AdatUA0T6/pQcyJoxThLFiDPWWbaqMZHDvlWqQmUFYL3sNLS5yjsktppx/9G3duAKXcnlYXmia/HZGGrDrddttNWeVSWZe1WZLV02kEUd9r1pvgOk+9jLHzJqvJOr7dhpp7tKDpHC866K2UfRsV6+l8DjqgcKCEwZkQyjwJI+0uebDPwHrw+7C49WtZqoF1FjeYGKSmhgRhBqJo+NeqGny8tIeQenSexvykkudG1XEdmsMPgG+krUK8x5U5KfSp0hiGmEis9dzvEDPtUjVFwVNyC8oIE+gXvPdwfF56W9MR0lRXM2W/UCEZzweUpy9wZbyiCzLFmKjZ7haKYTfnRpJyd0y25NzttrJ6UXSY5tOGE/Yq6idxZkuoNEajncShPD4JpUhfV+/bl6GyAYomeS8+i348PRFlL3hRePOFXQ+B/5kxPKPGzf9cw+zERW2rx2KVzeh9lurkP8idLUdGjj+KEnOGkGTbXwyBbvQWAKuXt5pSL+IjYk6GuBYxpvcctegzOXzNpfVkxHFB79Bb7YzfoIE9JD0lw0/kgMlpClPmezShIrQZtz7LXGvLI8NvBZbfjZCZGDMTgvToaeFpbpPbejcXyS+3ftrm2wiBeYydSll9jPLuQzGWFINPt/sHdn59dNQ+wqUccEQxkgNQCzeqMJe5zc+IJA1tASAaZJfUzvcTkW/OMaapZRlB3HnYkTN5+V017GMA8J3iJUnpXm213pA0Ky4JsefM67DHhm15HjmvWD51djQeQ33rkTeUviOx7CNHUvvDnWpbuRqmpfhnHOy2Brpd1B/7j4CTth0xyCQccDJ7ERSi0EaiYlYV8rvmFnNzjgi1Ss+8IutsqOh3zVmRVYfifEObcwoyyjKJW1synZB635a1lLxY0qwr4cCFDFNMoZHnkTokHkhmXyWrTEalCe80akysMqnBISz9FqwmIMZRbomiecfMnfFd//br6USr8HomtvGwBn4Ga3N25PEctbODqoJB9qqpQ1VwLLcKdMROjlg7+Hiz2PdTkRbLWK0HV1FypycLDd/K9WCWgwaoS2yJ5yWUclBBT5XCxwwjLvtGWp8N/2Ndd+yJfFq5mGGJnF65PwcOYOxiX82RHqAOpLJOks5jq3PZeMiL4LBiAM+G43htBZ08zSgk/PHDXPd8QyAdfE2DWdBb1DwDe8O5yO+PXMaK+Ve9EcYEKZPHLv3yYe31XUvMbhXTr7QtIsKYVYePf6O0V34HfqoTip8X5O8GZnVbBmU/uzljBJwQ4h3MTuyMxzIdfuFRGtYdhBA7cTKQ8b14JPi/467M4C5fva69kXR48VycFAM301wYwHOSkvpUD5LQ1vwItlIHClMO2U3iuodfvohZpTS635lFtbEEocuR6SrRyCgJRr+v2DHtlqPeT4BlQaQC++BUnoDKNYbUlnjN+neWKPRo0U+t0SBerqE/L1JZ74lzMhZutPd1Clt2fcDoDthWnV+gfoyzcBLMmT16nIVGd7VFGqU4wST8U1qcGPQTnQvsCaK5kZvmqifmBEeVEUIvk8MyVhofnZfHi8mbHGPFnnANBv47MFz8w1SJEUFoWqmgNRuPXSIQnRZFi9LSXwX6jmRT3b5R4NjOUCZWwZnYrENIfRvkGLnStZW5313/ysUH+Y+C3jJeOvtRS8fMMTCWJZQrR32maeJtYuxn9buXgCu41ETtS2FRAzfrw7e1TH+SOGbHEDP/WJmw4cHFTDkcKoFh1yEs59K/i3LJ6ctIQxxRbiREI54cGNGXAXX6piV3Gr9SfaTma3XG9m+Oc/hooh165yzPwdizcKOTmFJ2Wr41On4lMXXQVXaf/c8MgYRUpH3oJJ07qpxxZI3Ei9KNh0vCterMrMhoAWJzSLXCR3JvhHOueQCYO0ics7Y8eqTjmGrt8wu9W+FTayqIx4ZI5kLPYLt0e1dGR3a5klBcxuEOO26IDuxmUvbfXhZspnsiE3oHdfR1pB+U0AbbL12z4wk3YgAaPA/csg0SPL6PR5FuOfwV7NZ2B0Gwz3bM0pdAPXcGLb2s/i5jyWUQKwL2ZAayejYeEZwMnpbnvzN30V7UuY4/jqY+Rfjr0FSvvsvdDU0f6lr1fsrYisvjx0gvy8+hRpbSoUfRfE/ibPWKgASghp4e5V/MTrwoO3sTvp2SnxTBxWINXvH7z9Etqgdc4G94SmbwB8OiXzFaLlwl0QGtCbiZ895kttRBhf0fk4/1iI2bzD5rT5+/4xkQgvqgIX4Cv+ypE1wrnwUiPtvHwbooluegRpjT5Q10WuVEY7Q1u+VBoFsMcWSle01j+9MErGHZQDaKYm265pIMVwF3KO6IyScX47cFF9Akd18Afanvupd5A7mE8/0zTTydgUHl0VloGNq/9OS5pg/CIFmZ0ZciOWsFUzg9TVw3EZyglRjQIOSBvRJvgyUxPLrVnorPCaSBLZ2AxT3btelPiIr5fjvXJYrQQhkSTZ1gNUz1DuO93n9l4mfnkVBqm9L0Bucl8vrz0GhZvzp6tguo+RFyN5qyw4MY+bzJd7Ttw2gDiZW4hQLJVKVqrPqqjBkZ9bsuqbOO2DAYw+vstMqrzZygDDrHyNRzWfWGm83bqF7rsxPybVha36Ozea2/hzPh0PyUXPNdLcbpobMQsaF4rlzkkZWJ+92TI1tLZ1k+cs0zKK5oA0LvjHhtaEpqfXCOPucyegPKmOvJha2Hv4UAY+w6jVrPfwo8oeCnVRlEwGLGuf9g+L9mj6dYNguihnms0S9iBVlerHnJeo8Y+SJcle6UtfCuGAUos3JC3W+LDHw3Ay7etL7JXiwRXNrTd5rtnL6qXQOU0txG2O/SOHcWINkuKaA/bsWCK1+o8WlYAfK7XwARDzwp7hUKsJxnEFuhNtiLHOh18Aph/y/pJJ1Dslk+aYIUnoTOWCCDsueB0Z6S7K3IvESFsZ+7808yt6njezxUGt0teqEse1L5l2z0e0Q+a8gUGJuLEiI+j97YIy62qXUoG3fq6wyW3yV2OCyKUKKXwMc+tuQomzk1M1QbVR87QmwyYIwChiDH7QZmQICAZ93ILgaDhmxMmQecNcrUk9JzKXuwm9PfIlqexI1MGYThFm0L0capnNKzJBdMGx0PM4TKG2jZSm/ZiA65ldnr21ZzKDLWpLGVfWx3BBnyaTbUH/SJmTvpN2O2Wy6sI/+2wGpimdGDEifcNbv1t+5RMrDSzdpyErPof0Zr7RtJQH0/LIqxHVGuih0Ug/f3yjg6GI2xMfrNj1dY0TuTGPT9zVPQNpwkHy+A1M+Lz1EKCeWZcKkskBK5OFKQMpO7p6ChBRp8JWn4YclSdsNsssZ4TTziHf5ap1Bfef4W9LDvaGI/C1M4SI59THhyB+LxFjKMJkGr1gQzk4vqRRmBsfE8+UUksU277vW2heMuYawEDBspyR+H52fYYnhaWrHEu8QD6jCsdYWaCXC0ZZxYSkR3dtojlIKF7IeM58zOmYk4/jCIXhpNqFPUHUDwdaA0sMwF+vBQTFtWXjalk03oKP+1hY89Ji3JMbo4dBGW52QyFRPgP4HZJ42aqjq9jNde8KovvTw9SgIeV/ZQ2E+crpEVkMKlcWqmuhRwnjD7a0ZMGUUvRAJ0NMLFoMycGjQ6w9ZXYqtbdjYGKgblRgd55VJGnXFHQrhxWlVLh3LsedInenTzlPgp04jRUS5FlLmgk8thnVDU8WqHabpKF5coUtuWEmWXWTJlDnlsDTsfseICXK8h5HEjXg1JrvCBAIF8MDa2OLo3q1CAXiHBbLIo7KFwGTqV5q6G3VHF6IkrQFVrM9dzuuwqN92QxhGWZPyPh3Pb2p7yMyGLLXMjs/9dQTeJDOGaGkiEVttqlQmSVSuea7Alw8ESo1L1Mowzygd0cPu+OXjTfCwNrW1ijM33xtaRPBCnJXShOx6dDU7pJGAfT8b9o60NYjkRHqv4HglnSFwLFda810S4bYR7aAy4Ew3mZXez9mCO278ThihyRUQbSr8W/JPyc1xOLF6mF/8h4SUKhiUtDYeJaG1RqZdV8EAUM+LpjIMsWCWfSYQyj45i+NfDUMqAtVT9tPM5WvudEaiskyPON3rWuqfXoT2ZDtpmdlc5KSZFRkInIje2cMGUv0c3jfrcMBktGERnofR2SpXOae1bz2PZ8OMJMOtEqhbLwecrKRmBw6hsQcwKXUzOgLJR5zR15RLismjZr3cnlu0MGcZYnmG5E3a19NdfKbiF5V+pm4dry42kx6dwVSLK8LEbWj9NIdhBDjTtjVlhWAkzksxsw8tJ2U4zkNWsNPlreCwlICSgnqctZ3RUeXNB0uN2n/f1aesgK2xCljy7NCF8/X2G0/h6NtFIU7PlSJYvnW1QS3I8oOz34SZ7V+1/uCfQ6i/1bAQpgUZF4h51MhP4HaYbpTtblF3sP+svmiQxb93c9bU3lLwzPmeeL4p9QQmBgmRmS+hlrVK9+rouAjvNVCjselNj3Rx1pQrdekh/TyhlU0m1t4nmp7MakiiKKQVt8G0pxId8vnV5g04CWp+idJfzUSwtgiP8O4Y5Fss+7WdqQoT6WQk5qAeDIsQk9F05ColJAGx0Ro0DGx9k8WFD2LAoFr+n3+zSSfNcRbeBoRWx5tdd4xJbA7XVDKhIhR9pmBcLfGcI6tIx4l5kgPOQFrClyV2Ptj2m6uuVV1PQerXZHk4z1yiPQeXagyE6fTMvxDo2P9SdI/JnsClDS3ApPkWsNMpk8jSYWwJ4ACfOoBci5k07Lewts4WWDVwh/5yBN56GMGyVFw4ba/33dURUijZ8E/o2HzKbCrgcHG1ukVRawRu3beaaWkY9sH2uqFtfMXL+glksUe7aErojVCyq9z+vki0mh8HaEcHlsL73VJplkfSjCw70A8K4NjctmWehbG8PbiMefQ834iNp+hu13bUsff96q4lAy9L6/5gHXoOQB7xM9QC4ru6u9Y7lLlddcyB0XUzAhwTHhJLsKax5o6QItxH+qibdEXWdyM2IUtkeltTVPX/H9ORjynMMPm/yizmyT/3a0sN3ULAlpKGlutKYTrPrgUFiDdD2+ZPj5qIcI5dT4Lwk5Cz4P8k01WMoXO7jzHUBmkUjqviyLMAeR3Yf3NaWoJokif95mqRMenPUOQJZYsWXwR3oNpfBMs1yhi98BCu7+3nL0N5zmXw6TVfH4U2s7nzYCwD6+DL4Oo3OjUtxC0bucezx8QBIQHchPmfcrFEiUQUcCJaSGCnZKJRMiOUI54wcU51RsmOtbBUlOx0l5xR9wE3jhA4vQ18Ex6pWPuWCFgtECz8meqpEhYRw8Y7efV6YEKcEBtm1jJMdVF4fFesyNWewjAOx8IuqCrzCnAww5hACO/ld7DTkfvmxqKdngK2vfOTBCcwtBIB1vX/exl0S7RNSShu/fV0U8tIX9fbyQcWFrH/FyCr0AYES3VFzuCjfXFDQmEL9bUWIbtFQZqLINThKpCw6DQg9lJyUE9IiFYVXkSHQxqVe419cYDfCc/e1FGYm0MvxdTG6+Pka/8SRBonRxHZ3wcxbY4w3SRBcfxbk0DGsDD6vGJ2HFzcYiOiOlnsX7IQU2fGnPlVO6WZ0CnesAfxkZX231+QgIFdewpHcAZZo9XiHTo9p0dFuyCgRUeg6s+7nQF7/K+ytmgYj6IxHdfTE3UOA9IBZ8MqVzY26Oq8HCj+Rf6k7abw/ijXpkgJg6sfXpNej808OjVfcqepFpZ+dLnpGtmyAQicDV6j1oaeZp4Kc/7ypxCK4zhwEBhUu/rRc2l7Q4Mx4IQUCxTH4tnpJ8vPYpPorO0kYNgAG/BgWfwRV6HJn4K7Q5Rkx2399sxVT2gIe+l4Shdz6M5dimehaVtIDfERFc6EXTpaG6rRJeuMa0sA33K2bRmKDCBO2W9R+SiYVvAzBRQLHWpYlznRqdBnwEHFfEjgpHqxGhasf0RuIUGwUNlLVIZXMvOwdwfM/TcDPP8eeWbGYFG3dNw+pT2UJgmFJIsPhjGg5NhCjlWqr7k6yCk4xDWUzv9Uhg9f2tRDm0tTnPPX28xTrtGBz0fqrH6ZvYSrLbHTzyE14d3CbTdZGt3lyNRBpXoKzY63Kscuun2swuEVhAUyw0V10pg0elubAZokuoK+WjgAzLcWZce1p/uh0JwDRB/xDbs8qXswJEc9Qlf8/F5GCZu12KocdRegXGERaUMN2Po4/JtkQlFPPt5j45bmq7Ktc/zEaIU2b7TL/Ba4rK0s9B8Q+Z8PllCazgA3bv7KPu7qSfaUSq/cjwN8Lepo4rS+oWu3ohc32AygKd7e2ijFhkMZ5UX28zaEXra5H1OEO250wm7gM86D/srzu/XLaDjsIp/Vs8d8fS+KljlNVjTpSr7SgQcOE3dNM+4xJzkAi8vlZMLo4lL/NNMVd/GaPGiMuxjb00w5H/M3Pe5h75gy9EqgUbASp2kER3cLuY22KuYFFxZAXlBw3a279egTkmdMTU42+9D7QteRoaKty29/IY6p0dEevrQ1WcMWQuiIAfXdEX/mC4sTeIXhjVwQxXzPh6ImeuqRAyjLvYU7STQs1xWv9G0+Ajl+emCm/9NY1ksL4QvClvAgwUWfabyWD6UdaBcjBkW1Kz1rU/jupJIkBCeyUKZRodeQwqfNsmyk5PQMNxXr+bJifkon1OWsN9DK7kBhZwR1saAj+Eu7OG6A1VNM2mHiU15VjmfBfw/MiZUpHJCrTvcVYiGf/GhkjA9AqR5jRFgaNpj1dYF8bsSNY1lhyUPf4aam2LZq5QJaet/PQU+Hu/nct5KOQ5wkzB+e5ux5NmHJL8S4i2adZqpC1NF5zfoY+b2noxrjsKbLrB+tA/WDVMMVW0OSY/hSEJV/EXyAMX4ltjUXKnRmmuk1F2c4x3CJmQig3fdXYqQ2s8RQqjMSczJM46WYDs+K5OFak3SLszdXm7QGysQnoSmAMwkG8D2iCli7wbGd7qwOqhXkNlzchmrRIcC7zBNB+YicFB90p5//nZw9temdnV/x76/spCg9BX0V2GjcIUOsScePZ5uTNrMJ2hGiA6BHHaQuECthkrZFrviQSPbieM9txw7n63cPoiK4z/wOxRCrK5HCRbPfTmHbIVBGEp5QKm7RWL9b7a3SnBoxBBgHyYZoTNIBvZPYnT1GIcV0IJCbU1wSgFI+buoIlr5lY3GpCArf1sJoXTPU5Gf0iTlns0yAe2YsO1nFcVNJYBT64N6mEyT9GPFJbjijGx3PNZRQShYcbEDlIFbvLnj3yTHN9e8fjTlymkChkX8VKPklFH6WohiApO23v193b/UGSDr51bh+iqCiLaN0AawbgzHXylr0wvRChdySy7O0xkiYr7J6pRFa2mor04a8rvi593KqxAq/RtomgQsY8I0o0vtkOoXraFj2KsRGm7rFmUBeu5cQ4oGwbyPrDTGgl607CocxRiQeODQyO3D8lBmoDkvbiFZOkyIsoPjjuiBEqpIXUrehCYsrtAH1vjbSWormR1DaaijrMdfDDLevLqVCnznOqaazNstpCJ1HtHrltS9KI+whr/y8BQMaEPBuz2ery9wib2ec9wzc32T76hHww82kjEwv4Z5gDhg/4F4d9TM4nKxogozcB3C/ECkIMRbFiUO7ZxnaEdi4EfXPpySRBWMapm3Z5ZKk7f/TSTVrakK6nAHD1YWHHGed2gz0ifaPC6Z8eaLKK8p9vsHbabJRSgS3O5C6rmFUKCJy0AOiroMtjH5ZRvyUFRIzgH4AyjOk65UlXlSRXLjM0JvmftY0XeYEkS4hgge+Jw5KoCMQVs4fK24GmbQ7WzfxkJDNmIzuNxfKvvF4qLBJ2Toq9FYDuS2Xy2t5rtN+OhJ+Ld7tW3k7Bp4lvM7431cRRbdAxqNfUqBgTyoyvxSGd1WC/u3x30qCbbXd7OHH2fuJQr+V+4RtQZ1jwVubYudVTmv8oTMJ67dA7zP17KtpnSVLxhjKLGN0ILRK4y3WfIS4+k8/6M4UNPQyIpnboZ91ANgUetBiPygK1M8gPsNG3iU0HpldigwCDO04r0Qw/wRtfv7tuF5a1/L1UP2KM9gLUHZrgQkVPwtSRD9FHFZo1Sqr4DtvtHbMZB8VD06wdmkk6CWCP+QS3zYEvAY1XaVZRds8HPg8v4jtZwteBtaZGd74qNX5SJabiOxXA1Q8ZuI9J9hTy27XBYF5uIr2WUapZ0UaLOhaMI8qM7QWGuueia/a3iqu9Qd+z9sHNY4tkui9uOWINNtD8dY3vaFQeigOTmvLmUJQxJKSby8YKA3ZyCHw/hxNguHwNm+Q47E2MmllFHN0xDI96poTiL8VrYzE74iy6j7yzV27xfpR5uk8qhWkpm2N8UnBuYo5mo2puB9DKuyhp+3fToqUpt2AFiO1snGz8n+W8MG40UDsQwvpBaPrG5kGU/tyXTCfc/TqMPyU32WfNJG7XJ3RIxL+OJyLVhpvFvWKUEkUh8upUKcVjY/5776FmnZWpUy7AfRVc7frBH+41iksNic90mQhRk0nubV2grnKu2YGc6lKYQVdq03wTL44aDyR184TiCEYh5rT/TsOlmUo/NV4LMgOteY1dnzxwNqa+Spd19I9laoZ4OmPdqrQ4eoafRbfZ8tue/y1YBa7lxvroBbxVAk9zmxU4zN8owdevAPjCktPE2zrWjWpqFMrSTOGtqUL35RHKvITmbNX/pqBWts9JJkVY79vGmwdXAXYw4DCAvSkM71u29lULlUY2Lv8+0vCk117uU3Yfp5rVYt/zOewtLn/lZ2uZQ7SWjxl8RfWVzwyRu489HI+wBReE9p7VylcndoS1H7IUp1RoR9lbwOGHDayENZdAGBG3gr/4OKr+UEddl4t2BfC1BP67BK4RKu+P+JglqxSc/9jFrXU722KkqXME70XAxm5HxW1uuz1Clq4LYeg5Y8puqbdlCl/CtycQ4THBoyQi65L0dfddrL8Y3QIIh+1Pnb2Ft6P50OvYeBD9Tq/fEl+LSA5a6YUJyrLvZPmUrqkfheEBRkyKiHM0kalH6qRVqVe2Vr3YgYjlo+DwKyGrqeFt2tkR+eDnp73e7plS3dCBafTYrN9hm0ZfrHedWc38wgITDykjOvqFI6n+qK81OSagJv9zStNbCt9yjfunEFKtMM/KhO5ZuSxJuavhwevg338QmmzryrwdncdgF1gNyLdz+/vIb0JXTwsEXr6QePBrOlPEFPVrr5zA1q7kqW0iCqvI3RmGAJmqBvWwK1cf+18Bpqjyj7Gmy8ya5+o7qYEFTOYV4wV4xfYxJCDveoJlwecVdNnfpYnUHF1QZWhfbU1vSqnUX2yA97JaYM6KY4vTs5R8vFkifert9jqcYIoCmsCgLnjaZGWRonj3+QE0UNJ4lsrn+l+Cckw/x4q2Op6fmzEPW6rMKG3qq1tVjDzr/bhLwNSWJ6x7053hzsbBX+1BobMTYLZgfkQ8vkcL3SJM7JxKl8MDybEFNEbUsXNznGYiT6EqDciQAytE4DP+qkg9J5/FrTXhGHkPoO4vjPWyYhyNSPRzxK8kyRzuG+g01ig9yj+ik1nE17PPbGwrqKgmIgbYwtL9P1AnYw1vWihsa3iV5sdP0RH8VtTBsoVPH4EXS23ePvrt2pwokOeboLoxQj49jAWHUCAlQRJnNCzVzIlRWxGA84bygkIK6CMe8e6Hobhqe0ypxpbXoEzT5KYfpkGFJfRsMHh6oXSl0ZgUpfss5I5VhEhVfnj8BQRVDXu5cS9oqxHoel6kroxuC522pRRJ4Ro/KxeF3Zcqr3o4itG59mHHp9Oin5jv6jcexyST7XApACndCYBJ+nwXSCSnAdjZEDUz+BhoygpbwccvKRPJzB3ei1e9Diqk85vC7ZwYHcnBqKYzXG+lpAHzp4BYuWD14MxNDHLJOG25V3SAajMTorDPH4xDBtotqVB6vLFFrYHefgFZP3kEF7rbbb4rhWIZFqnYSTAVT7uXcM9ER+JFU0sGCHq71fyL20sBaov6ZnunOvu2w7ql0S0RHNqlvDcPAnDPFlvt40LRYCYSbbh7FDycDgJJC+Nswu+WKDTwUv0CDpPOVuAm84N2uTU5nUbqPSvvxmLguZ9yFPUzLyaf/KnmS6RcH4FFot4nj7nMFuJRg3iiqy+QaOpBAz/1CElk49bR6BApyFls02SOaRKhuVY7x3X1LaN/Jf6+RFybs1ORszq5FFvHYooO+RmwKoUO+JLH2sbooThMYTzMonMTKt7b3HvClq+tvnQ6Befuif8qcFm3x17L+Pb/DA0wuOIKZoW8n8f/R3+v0KJ0LlbQZBHlffELfjfHU1t1h6UeJsPefPiLdFNhIDbjs8azR6pV3Cg6otQzXT0zTnu23KPKrl/7PKa7CRMxSCKEcRroVQ0F1uephFTy8Kuu2zmQTnblt+04WBmvr64YMRnEo8GF124cVTihvTOnfCbFkIwdlWesflp1SZb/bOr3tdNkY8ZMGhVcYkJtGS8z8t+ClO8MDEPC0nzY+g2tPcvrCGnmObICni/zqECD1kycWH/WMk6mnqA6739tIOz+or8Cb7Am6C7Mae3c4J7I2Xhf6aaOdQiEoyt1ns8gtRpdP0c3j8wejKclyuGyeuAXNjz/36zsSdjmjPOt5FgmIeUvVHvvEXBgS7E/Ra+Q1sV4SU5jUoFDjngG4gplZMXTWEDFeb4lPYB42oODzNZdssSxCDzLw3VIA0HqQY9m8PuRjYY0LhBvmGamexM0MuV/SbX16kjWibwNVAtG+tCm0rOYX7tSZsAZ+kfZhuKzOYJAzcxw2DLGTNT3rAZVlPmGtk4osAJnqLw3XE1XFfraX7HzTuc+O0t60wCQPswn30SlJvhfQJmFVdORNl4oOW0GUDvfKB53Mwdoi/XR5af8Y3KOr3rBIrkY0MxgsZksobeb6lOO1XA7SFJX3JTDJvC7kaexqe/Crz98ZiHojFAylxRRWy8prVZHCcwADheD2yIiOrfd9XYCydQ64+HIS86f4ZjyfoE1R+rnsUjcomPjZxjQHHKbqEBG27ib8pkkv8VzjaeO8syNR6/8YAdbiv3PliGctTuTZXsS8Gal75jm5lzKtu+MKvxU8T0VaSWf+mAMZPJSt0jqtTybeNkWgSsGRIBgCqn203upiXVJWxD5E7nXabtF1HTrcBwePA+9Ixf9BICLvwjI20ZrqikW/H3GUWlZvQBEVg4ARc5wY9WHEi9EA+atksf7fOr9+WUrprpOR5dluzQU0s+f2rcyuNNGyhvEMOOWAhBtGa7238M4PTWoHW/yYsHJflTkKXyyPJtHE7sd2Uti25/ObouSNoD7bqhk9Ivss93QQ6tkRrAH1Zr20BjVOmL2DB79n3ROy0aw8PmPRiiz0brXH6Wc9G9cUY+xG69YnUQZS3SUGIM++oxIyutHf7QF+HKZ/nFChyVWZYvNgilOX5q5JXrs0EbEtz3MurYOtqEYD8NzAWZdKfNyZGyewUKhW6YG1kr1PaMStvYRPkCV+4lnSIreubkB9Qz+KYsREnN45WAZ58vXr2Q79aHZB1fRxtVvf/qozMUtIB8sojblEW7qGw7gIRfQq4IWDVTYqSxpJCdEcJyGjoYAc6ydrC8FtGZuMc21SDZsE9k6DSJL0BSAdE2qjzk/Q5t+T2dD8r+OmeIZuafU9KkhBKhfN4r0uCV+TpObsHwNFVMt6jQGBT9P/I3ReifXxBFPbOBdNyhCJoxI7apY5gfcwsoZR32ztONoP2rHvYFFJFFzTussblsaCGD0PxLUAcf5KT/0W8V2Mjl4mI06TDtpq8ZBOXd6tEK8DB18AQ0qvTcxk3Bjmlq0wqlUC+5sjS4j2uUl8IQqnD9i4JqDoQPVKQpB0EPFPQ6oGtuCwAcfEWILn+oDYSVqtxo5kWJPscX/Y9+NAXgmD4W05aDZv386Y6zkd6nKwiNeTOGzttrpU3IuJ8sN0K9mrCv/bnc70K2OJgChbIIEbxgxzKYxB+Hze/yyhbej+QsXQLbyAXDjLQTf1zolwgrtZ3xyFh7rzbCtBqJ5SsIaaexxjneCmgj+tb96/1ZIX5ndv9ExIZKuK9As4B2om1baQ+C0wVdU7boeveOVs72r3U4aqh38Up+iy2/sOd0KbDTsGcL0asMjQUCEwza/R/zK8u4yQGd/7lNTxk9lOl7HyjVDJUmFNPa4sBdVvO8wwrqdljXre1NN7YTK7lE0DBMPvCcl5+hUk2FJKcljUJJpgQ4Cb07bpA3hoqhj0bIZ4meiuvKUWnAXaiLdpX+yR4XlMIGn3n44uIUS6oiCqd1JF1m43KUa86mr868yyhWEdj/LA4DrltygkduxeRrxMm7pXz8tXcyvGFgyP24EcQyf5KgLCaYiYeIT7qA6faxvqefoB+UxqRohSZrLyCpB8tESRqvImIlig7qdExJ3zF9B58lNbFrZLwpew6MFIW5wSOj5uWVUTd095EzXpOh1pEZJM8efmKZZLAdeyLZmcN/4nNUCo5brhNKrP2S/AtwNpoVbPbw8p1aheTwCuIg7/tBKPGju21UHlmXWrpFHLJY6w5Sj7gYuhvJ3B46QN+dHzm0YTNZjH1jJC6u9qg0tfZzc3EZlX/FhygCGpuZZqvGdtU3t8BUZkZWU7knke1DMwS+GvgMzyqsx8fUAQ+GFsQBmnuqvOYaWcnPf+8gDR8GrfJF55Pa2VeDPj+w88Pw4x2z0+6jhmtWWozEN+Z9Y7QEubTCk/GudPr9ngkaC7OhoXPeuN05sjchZPnki6zUlz/wtckn1N3jS5rxTNXMNTsC06qilg3Q3S13j5kDJ3KP5k8WbNKsnhUhVa9CrUsRDBqg4qdt2Mr7DAnj5C7tGg+OOJ5ls0C7kI92XuOgp/8mGpRQpWbnRksuiyksQLyj2YIIUBhrhF+tGKT10sWxbyGxFjI0Xu/VtXcNiOL9i8zjHhelsXy++qPQfEBZXSZ5A3r8u9Dnc0v8bg0YNprNvF8DqyrVQWixu7E2RBFrZbZx66jjJip1e+IKjNA8E8zg9qG+fYjbsLs7i3fmNA3HaQI/gRoRFOkH5eQDb/DZ592TxOxweo7SQ3VNupDpEPgL2qK3lmLrImXNQsED0FzaC7VssOmkkjDRLD8zyvzJKQBuiUZxPStlME0h2SaBM37paIiQTm05MaF15j+414JlbjPQ5HhyN8EDRNo2q1oBL1JWWHn7Jcd8Epq4GgteIaVk8vdyWTGsL37bdbqTMTApsVjlamPyCwseiZ2WEICn8aWNEMLnUgRZ1a+FpmyMlaaGewwZInzBbMEObjsxL/8M9WVsb2K0qMcCDuOaTCAqtpsDmb0N0rEuB4+1C4moIj336On+WdKSfDtHo6OGMdUrvpZwKwM8oaLITU4B0vSi+K2wR/j89bUIjcP0P18qOiPFdVVLro/DLT3r0g7lYaPy8At69+BbwWWmZA62pQhRCdpqArJNQN/GuaXbODRb3XGXksDjUyB4+Thwo6LG8uuRmnz7wv+XwCP5z48NuYd5IEdSTHm5Zs+TSTP9TwPMRsf5rPVR2sFgVWE2Jz+zQSolk2fZBNeVODAljizfoX/mftXGYm8J/v8u5zBWAbgAj9AVez59PZa77NthQfy1dZzkvmNw4JzBVgU7hkBa4mgJv6MGrFe37QW9hLf+DXURFXywaQy1tHL7ITIxhLfiDxd2aBnsEzQcEzZoWMMv8r4CwWpO1Y2tWzTR67eTG2vZ0lPqds/lpsMKELCBRxF9pgKTV08tu7j6HspD3LRb4WY1ouf0sH/o1gl9BRkcSzHZovGnrvWpmP+lb+TE9HQDdAgsTnaxdGpK4lYDmOxzgTideBZVOzrFsn70XNYI5Xz9QgBr6h/0BKT0K0gt/GGksAKxtPbtL4YxFs8AGwU+TMjaOCG452Uaech27ML8mQjgMsUEHJ77bTNehxNxpRs74RMRvoCsIUbe6B0FiIBBuEnc+NSlMBEl3Nz9QGVU/HZsdZ1WcnqPPAFAB9IBpSEwuodtGAleAQYYDTf0JRkMuyM3X1dZsnW5Gk9ZLD2HjkWfcJ7ZHSL3f0im4n45UCrw4J/iI+Z237UakmU9j6/8/LaAseCoOQBXgkzaJpRM+GfOiveUokE5pWMDNbaqwab/a7Da8cj7G4cFZXiDnI+e8rg0wxZVDECshnWYX2/hih+CzT6keADZVQ2lgK3I9v0Cce8NV0vDOfyrWr+Nhm9/iSRiC9N7Pv1z6FI2dkVfEIUuOpb2k6XAHUTL0hg6dmvf2qc+ksxI2IzRAKNdycII/i23asv4epUM2RDgeAurXvABFvirw/NMT9u9l8XlqdZynqfdc0ZwhyL5xnANVGMlvRRxeDx25FgSwnSMFfSVA+8Ir70ZrTrAj72fGiC7+vxpy4/gxUgdEb/Crt0AM5/f/woOBmwqqbCVW++CKKs5N4OYmDf4VXI7HNnC2DwAa8Uh1/YUtUTxk+2DHxiVR9mz0r+xoC7/6oYpfF1vvQrT+PiIfmzE8gwu0fz8WOTNWHySWZMWNUhRuDoGGrasKazQGiOht3+eli96AXItTQ9+xjSN0YgGofeqOFk/JcEjff9+7UcPwR7gXelRmdVbdQIxXw5lZTRAZ8d3RLPzg9UM9gHv2e6VDkUvrMC8bDpiIwmj2KSt5cvAkGAyxWGuNOjVkeyaTBMAdCf3ZIOYKACpnUZq+eiRMvpJt/F4GzDQpKOiwbXBHu4C8i1rMvbi6sSBX76O+5QbrquKFtcp3fs8jPYQ5OpfNOKh2jkVyox72gi46R/pkZu5ROuZdbmMdkx0UEVmUeUdBxaiGMuQAm7cTIpmp6lBCPi3u8teCBywojwA39koEXCxPIIsmzD0+Vzh3UhXR1FNFjtG4mLpKSVPr3COg/Ty8ri0n3bMz1178nclfl43JUFWY/WvuxjJnVKppNFaO0H++b9DAFVNC3VHSsRYjkygk18/3r3iht59SN2LOWcepcLLzSAe5kHyiYSdXdnresVcMIivd0PDSAwWGRsPFf0IxbtXoIT/KBntr2oogDy1lD1dxk9DdljeJrcNUHDG2KEVmZosyyud1cGiPptnZQf87l2k5phsMcJGd23zncmsPMo5VuES68AXzEOrz164TwvZLIcg9fyU1tlkpS4wupEtcgFJJMk+JqMDHGS5dV6ZMFgE4zC5Pi6Yd0nO0BPR5fRwZ/SxSUd98T3sIyXYXbAvXogRElJ2Jz1TRG/RpZn8FqddPgbLPU165cHQMcyMHvT5Y31+4FP5Ro6WFIdE8Sik2/CcZ/F/wozMTZN3P96i7C0TDfLiqzOqAUC9nGw7KMdFBTxEiKDHyoUl0oltqsTB5tfTkLiDjo44pFZgswaC8Km6SFZXgBvGF3mLAyH8h0bxzrJbf8TaU1FdNKe1gzPjueqSyWwkhPBMmmgQmMbhIyRqIM5X/g+vAboiPmxHI0LzU5+J1KSH2iQbhR968+p3Kqbt4Dq3QGW+WMAZTojgNDjmdQP/nhu3CsKRNliZWvI82doEyTbcH7JFjB6B+cK1jBbb5ul8+3Wmddkc6A1lQSRcINJeKvj7PddsDWIpURPVcvG0xLOPfE4MT3ewEHpjG6xbnVMPNy21Jc4cOrBksQCAfsflMk/DkyyUgalt94/BLcwhZId0oRpzDGT3Xa8G7YP+FoOa5YwUt1pRD8zjX/YiEcF+CKOQcVGOwTwRkdcrsaDvjh5EgNBg18nPQrC/7znrNAZ0Ge0TxUTGoFKuCF3LsnmzNQECYDl2CAl0tjk14EhOAdDpEw0Xq/u1PdtVGSZjnfTq5E0XswtW2yOivwnvFYLuN6GcTAECk66plE7Uz99iHu1VP1XLoKypXPe4E3Pum0kmHXqa567WOL1GqqDZAioG9vCOXUDfxB9jty1xk9/hGJDymOFwShbYibF0Ao7M4vRfw9skjCnge7d6mHrMS4V603XvDtvlqZy2/20WZ8Ovf6fG7EYfnXdGOzYgL2O4kSA9vAXGg6sLCESoxi5AX3MsCtvCwQscdj6vLDRQtpXUTOQzCFwdw69ckk9e5U7QxGLpwgG7IhkynucbxQz6G7ybHD7ynr0umsEFXAC6CChFs/67BSMHRZLbOZz3dCLY4tdMCQxr2l6GBsqqYw/IMe8w0VMqCu2e+ain/G3OX0PNwErPqo3pWuWBBgB5Ho5Qha2s3KqGKHPeX6+3P3cZtVrcQzOZKbXF/KJ+C9EtA00AkxQruMMfh15T2SGchwfNn1hiO+bFaLnwU9bJojR3N7EoWLa/Vrw8NHy4X8zqH9AITFByhWSvW7QocwTDVC6WdC7uFbwmVRbPt/xNuOVsti0/qEPZoyDiot9ekeaqHa82U+cC0LqS36ZChzeUJ6bgT90bwIMaHip9lKnWVSfpuYPNO7NpwOJ6JzW4RbAQRk+cJseSPLuLM+8en8OMNXcWj40P12HXySMCT0wwst9eX4BKi6T6gNlLIJqT9mhmxwSwIOFPN1ijFixYo+BrTrEk2vuePhM5cvkPQz5tmpo4dj1bA7M4RHe1LB+ygZiYwX1JehtanT7pzGJAzX7P2CHj7UxXIW4Y+gR0oEzpqpnuzRVA6hD6wc9eRVgDb403sZOxfbGHrtur/3XpiXBtt5qwf8ZWHnjxKzWkVEKpJ4ddNDA7HIBCwoDfpoatlwjCdzhFC3SS6/LM6UbZSpjUjT9uLuH+4tEpfLKPETgj3Wcl52HNs7QfOVY/wQstfqNxPEZ4vDlRyiBgWM79XbX7kwYiZjFo+cluCZxfvWYk27aKHdCf549rTdbrM+cEAklbMqzzwkvtqRYvxwT3SItOoBG/m/tsLTIHYpVejvkECqJNbHKO/vp+nWhT+REsiWiNqKwC59sGtp5jKndMEdjGqX76hJQXJGipPn4WpxNL47rKG7L4WH6VEZNkX/U2ve8z/sFKC4thN/nRcjNGS2cCipH48pSuWqe0qN/SVfEFP57Wx6EJNk1+82Ql5y+72Kq4s+5Z4MDe4ni3Vp/jlw4ETh+AhCvr7KuuXBKvu2ZXDsqa9corAkajrVNCNlI0Y0EDB1jz7jyX6YJ4HrCwAWeRKvgQL5tt/FNYtYkV2re2UntfmJ0v76Pu9w4iylQXvzkcBOr8sy5vUg0Orr6LnJtrtFy8M0hgPjm7f/WKLLfNIFp9mIK03VA12sULhmEMS0MrZ6FE7yU5pR+MMCPcGDXQPtWn/ZOcjPew04q8Zfp1wXY9GxyKiHGoeZnH1x9u6cVVntVKj4IpsFMQslvyMRjUPehzomFWmEvXsLry/JgD4sOHrKBYSqOSY7azECADZSDy4jIj9/mMcFjTlh/8PlTHGPZz84bL+LikopctK7ne+ThAr916i2kqBoWtsxZdCeaddaUrqQ6yPDunmTUneDaOcAWKNDgk5Sddj3dZhQ62MwiP1rvi1G6BdF9LgaofGVUOp+WrOb4FRO5NK0dvBuztRrRcdIIrKYRKVi9d96Pu7YTufJ27l2m2AaTGBOOZmrNe7uR3NISMcK+y+zz17r3s7JhgNXcIcESekQlTH6Un99Z6rPEMV3mLcXcm9jZzGUzHaY0BSRmbY5T3pFuRGfV1neL1dBUVTtkDSFqjfRtBLW8oyVih1P2GIvRxIioZTN6S6qooeNk8iYQ80W4Z8/un/RYDDScMQHzvjcV6gFelPbrZNbZ8fvHS9jfsxxMkm1Mr4BumDXyi3l4hed06uE8PXXV3qPhor4OeJjRk+yVJdHjnyJIn/TNYiZQ4F5uZACLBhuohh0Y7vLpcAQfoXe7fjACHqR7os3r5gfdKGDfNxAUhjGzR68LUQ6XCdxCxvP6ojm6+/scxmTV2jFb5XgOzKpZb9QJ2gpPMh0lqISkm+o3fAfziS6SYClJiptuegyniqHcWfnjs/JYtv+ITPGYERGO8/vNcijHaMrxd+JFm/FX8w6Ell46e2MAewnXXdDRDZIbITnjj6Mchz757wCrbDpkAFuRgDhfvoHHX6OE53ifgsCv4EjR9bhkqB+GDaMXX6kZkyBFwT6LWjF9Aj1j261g3pHkpIgZtvKMPFk1ZkEqotg2iDNvcW7gwVEai4ZMKUqJPYUELn5hQwu105ghhQrljCUDsk4y0hLadkhZe/p1clDMs70sfL6Q8n/zDF9ldnbx84CQTBchBg5h1vqvAzO6JbiyFQaKU7n78WjQb+NmXL7A2YylBqm/KpwQbkMN3g8ioc3Mtp/5sR5VV4gS38U4KdqoRmHrNyBRljTulAibGpDdAKAtM2hUC08A1j8Q1CBsVlPxWEpOPHIQav0Ai9poHSyua3IzWfvi02sG5EJA0HFesNhrPW64uXLJ+zQ3Ov2omJwVzAT5s2t+4PtXoXs5m0UTCIRCn5kiii/oHjy0btq0HGLjGFqZF5LykyjO5PV6PwsJ8lhhNLLlieUmp4y3fy/XW9LwjV4b41CZeBASMrP7ZCEGenquqh06yo0Y8uBH+JhoPufza863k2pcMu06CSIYyKh+umxVornI71HnNCIbT+L11qmuk7H9roh5Bxt69S96rDLi8PJgb55zWy+7X/59V+fcVjZdHmvB9FMXvhdfBjLsmekymi7XeUbqatLtczpHTiw6PuUrL+lHCgZO8aQb8HqwSPukUuifAIJl6yf8Z6PEsunm3MDp5uEb/SEo3qGYeGi4hruSDpbaw551s+gliewObUtaovbgNonV5O7LQX0ltBK2P+FMozoxGXmTpk70uf0w3LeOOaaWv+BuQSYchaw9bzFp1fA0V0/xgLAVe4nK3mKPJGG4aswUUeu06Mr7rgt561ucvAFlfusAUmIELX9hLbRDtKcHRHnfSWL5uCVo98x2UUE1IiEOW5HLqIDVc3R8TpwsU0rRjrL4MjtIL+7kqtqx4QHTDrha69I2XskDlUsEddSKdkeuLRM2o0plByRhjiTIvJIyN+5RR1pwQkmPPgd4IsnemvBwB8ZXPkZy0MEclp/5ibEAM1t3Jcyq0A3SN2qY4u+sepTNy2lk7Z3ZEaFxAnhsZfg14OEkEJv0SOEH8nWrS/IonA4YSQaBOl6OT6gk8iL0Ifq8ulsVUb6urPYo5X4rD1IzKbUqno0xL0XYJDSjy1NXYzJ1evugMPNgWWMdJcbrFp7a4BWKqDOL4vHPO44lV1VxycrhArcETU9SJwRC22hWjJ1UrjYljtDxLCqVOyROwmP0tXZKtmdhe24UZ1NuyNIiSQJpdmgouVdWMvHnksEcaWUjvRwCCargNUHNmyNr2ctEIU1Br0VE/hW7ihbcUabQbc4Ez4i6RR12Mwon3CcfSg7jaunPCfld93KUfjk9pzrWHLIX9AJ5zJa7wKe4zOWtdv0eQzaXjW07LHKN1WkbyGKDyMarBBjs3nOK2CEcPtt4DYBW8PLyoawIg8GPN1RykypUFoTeABNxDmTXxIoTMXVM4CVWv31zwhD9oQpU9FyBV+jz85xrtD8tbZ3O+30K/DPsASde6iSJdwUrqxSfz7lyr4+UWL+ff5YrXZwY6G9m/ylgRBB9ZZZPc49C4/9rc3Cjhg2+XfPE91tXV5CIb0sEUMPrfmQBJBQXYo8VxLEvf0yKVCrj5DTE4kX7pbpKTYVQoFB+AMWnnc/+3YeJpfRbnb/Pa3Fr6CZDYdc9hU1GYNThYfv8zcsdk1IU4rCqELC+2DvDLVv8G/KFVgYuMg0D81F53l6pOTpJ2V1dPvdxVm5bFlIDLQCF8iiLPe5eFqUPCA8NoSDJMzjGB8R7iaelNnTR5d+0p5X0gnkG3qRFNlqqejls9A6CyZt0JG1Nxvg+lumy7gFd+ow0Ukdqcc1/bbaTyI3OGGg9xws1HfkNJ80j3IHfSYY1OVob7Zq8WdpDB4BBZML8zsfprBfuZ88QXKX55E/qXJeXtWuKRSi9L4tV/6Y9V6jYetqTp3UGunOsncWX2VuDtxPbEVuGa4J5/+eclcsNq0F+TaImJeZqVMDkVJ6ZclPA9u0qxgaluR1ftIkhTaD9h33iIP44Jhe8KI1ghEYfkbcKZYV3kJ21FZp3ihg+hhc6yq1aNduReANiuFz8fs129E6AJLsW/Bd09z9wRbYYQTCMz08nqE/708wXhCCIVc3l4t1Qy/w6d4i3aU0bxpVvdxsSfqqD5BtVctHHGqiNtkMLsj1hEjcHr0EsfI+5z66wSsJflUUTYVCnDW+Jdq0Bk1egUe0LmF4BC9uNoATqQTQ+FJ+8AF5xE8/OSPlv+PhjuqKlQEJtMI98gtjno3PyrTziCaoJ2PnQMSuk4dKfGg00Q/ll0MCZTZ9S0p3ltKfPZayFriD/y21mOn3czW/AYfx9H22uO/CxKz3gvqVDjRUG8cKkdNtyKkGySPP0BiMVYSDFAkmzKYCTMictESmQfMH0O5KXjIkdxRXL8+VAQivtx8O9xw3cI0eSZfTAz/2sUFTG7sdx+SWw9S+n5rB+BkOmjPQYvZBqXPJBhSn1e4Z+EyDXgiZcef/j+lSy5ZDZ0CbocTQl4wN0huQZi/Gu3S0kFRIiWD737K4Yj2jfVKp4MOmrwcv1oC4TQYQH5Fy7KRJZ6j+ujBlrjcumfLOZr0vX7kWHzgr3Nyt+dvrVjMCvQgBZhYz5EoiKcKnQBLglKpRTso6rk5tPd0nmIezkeLu7zw9M5KAhQZEYcEC0UouZ3B3b2NaEtfSupJXC1fklugNWnnZKNpGIRHuIs1By1V8BB82ckbEMxUK8Gve7KxVE/8NX88WlgioKOccV2B0Ra9So/lB+c4ZMGILEHRQx6vt0EU/qzN8jaC4Zc84EVjGMDWKDDsDxC7hfyacY0Oi6M9JJwvt+HQk05JVjd5r0Kv9zDV2opbfsPdDmn5AH22zZfSqpx0Yp3gHSPzOmYieOip82Ar7B+oFMPVbT2QVrwtHx1yoklZGTld/r9VJXwVcSieW5bDaU6X8hn0tGAVfwcAM08MJYUBsXblm7zjeSPvGjpKIl10Xjuogk7MQPaNlfduVY+dEph+w4JfGZOh6Nk6nn81uRWN3tiBFIJlrH+Z0ODa+nc8qyqRFm5TbKGwKGGEkX0xdFEBIO9AygHuV/zKk/Ke21n9Xs8jD35pUvBg/FSowCe9yMdF3SDvmZwCdnunTRv3uOQ20IuV3q0PioO5KjFfMY1sIrMUFACilX1j6BQUP5igkgrPyFP5NZvGI2YsivKXkq0jAL3cHN8Xgog7TxGzfpJeT/H0R86zWoq3LoyQpYwyG5Qk6pk87QfHgAJMeBT7VQS01plPE6Js64dh/29gHxLh2C3JxL/X6aHv+fRLqj3DaqsME2YGzjC8HMU+gILxotWizyRRK+MpwQGkkYJl3k06veWErEvrCzKydUx57lkratdIpTHGMRMlkVMdrupEsJLnGJw43QzuhVQfUDiX4oeF2UtHga7xbqIUALJJG3hF8b4x/69gV3q7mqMIWFl6HqaR+RSWVK3KdcrmnSLmSjfbgBLD2QH7BxuJ7SekL5a+nqVnpL1BnziOr2QU27Ca5u1m4s+rHvmfbWvuzXWwkF1Y8RGpkKjTvRf5aYW48irVGLm7X9wIWxjHh1LApOmN0yyyGg9eywYuLpkZoXLLg+djrP2Mx9zNd5yxUtmwnjysUtPc7A9taKlTzPHdJ7yxfpTawtuMkRp7kUJkYYksrztbPlRL6Vj6YspAIxH3BYP/wf+REJGgaM7Orv+rnIuZa9mK7SwK7jxCcU2bmPLH60X5EAfUZoxcpVPBQrw8BrM6Ecj9zUUpCq75rbW3w7IXOIyInKAS118k7K56+T73JLeqMc6jd+59FP0zMxcxxjGAOv+6I+633ewftpxxrArwcdsnGAik+wmAhO0HlDwEAZp3lFe8kyuJeBua0IPCad0SXPQGcfIQkaU114q9dJLHvuj598PTVDmyDoLwyX0k43RXR29ZbwwuJJZXNjXYxVUkOybryPwWJWTGzHSyZLrl1ddd/qafZlSBJUCTKkuO4ObUC8WWs1S8GFjeFXvz3JP4gyzKiXfl3lsjcjVyWmEhd8+/8ibU4qoiMHsgiVkTtnyYg5wP4SOdtXeayeve/JEsfm63Lhzt3SYtLojx5yawA8P4D4douPMpHeuGf315+M3sFXcn0xFw3U3V0mPTla0/+E1+GRQESYtlp/YDNofM/6B6hhNAAxCVgAXyY/08INxkPNN1mtKAUPQn9QhCQCV+OnDdpO/Z3JarTZIy/4i8vUupRZtw6WmDhdpBB6v/K+HPishI38ulFuaxY7sN0CIhCoM8nNSCZdz2PwboPHdPltLJ5bzRKnukm9eqe4JQUhf/YEOWc7Lu+WuM5FWulbtbcmUuQXVRzyj0jy8cInuSUBoKZxvScNZpaKrQHv6hwRX5kqxVLaZdYGkB+hsw/BicvNvHIKTdc5cQPB79TufwzPO9QB1QkjeGb0UNO5D93w/Uj2+MUSR/JBK1IrgzZakXJ8wSPnNBRR0qPEUtGhbmZJoyiEa0jXD8/oR0KVCUaj2jtSuTKP4eouF6bkBHJSBrce0oZ1MQQIHxN3hHoBp9bphWt7Zgw3nWIDNAsLfKyhDRzxA24CrUL5Llw4H9OYh6XCJksFqxgkHe/et4tQnyEVx/bQOAJHsbQol3yu/CWK+BIhSmaWYBsXwj4Wo8DhnxvMur+E3/9CuS9V2J1P62Z5cHZzsQ7caIAFNkncBDvP8LyZAdAFJt4tG/6q/VsxZCsXIrZd0GauyCo0PwdupxnHwUNvaAQIU/uApd+ChWNQwkLr6rKs3sxr0j55R+htJoKVDlvCJQ+9GX5l6cjEofFkbB9B+Q3fbW6x8zv+qinFeKU4BVMBvg/kIqAkSRhJbiIycHqRYqpTDRZTtU2C6bV5Y9PEc55LLC3zduILsbhTG+GSm6miC/gj5+J0Qo6pHS/js/SoYoVXQE4HAJ0O6LGif/UezFqYCsCTgYGpZZC6Dko+c9KAklnby3unah7mQy832yqMTPP6ZfBR4W9vezfvVKO31CjjnOPxNLTO3bhGKjjZpy/aS0YrLlbQkG2lrcju5ptRgJJtY81WD8g/rNmHxvOuXWlIY/m3jvvTZtTVDxAdjnfZbc8okEqg3MpFjEXaJ6fJiQjQ5PXsCBhsrsCBwPLPYSVlI+hsl9a8ZsuiwQSy6aVmi1dGxpwVh1nAjPxbQb0MLpDKCaO2d2B0qIo/ysh6D2J03/6U8x8ntcCn+2Z0XiL2/5tH7sxJqdkidKjB52clo0SMIRSab3kj04itFvZPAUXvPsONEHnbVFYfWY1klTWVA8A/G8AdYRWgj0DPPAWV+XOLs3dpPpKd04j02lpzYQ4RYAlCLrvvKsygGDz/0SUhhVb6orRVsZu8PzqpKn0LthYGv3DSrsI3VJwu/RCFICoTVKorWxcxQgiLy4S/G1YGnXMB2+AZzCPdsRPF/4zX5ZhL4f5Bhd/oq/JENMm0JpekSnbe9+G9xg43EtLs1N1Ws3mv2mcublgFPHJU29MUCenVO3K6U+vVXRGMEJj1Ea+fYT1FB1Ql74E3OViHShWoAGRv31JYhVRs+3QMQwxoUWG5xAtPbB/bjB+XW0VwrW9njGiRztQoXIuL+3OuH5g2UyJEEgxXjtAq8BcLEFqAIiFOv1BjM75CJRtB8JHzLkjQXL8XnT4Pi4ANHjAErUmIuC6CYLQfXWwIjP0RLeLYYKUonzyMjOlHIXCS61b1pXbDLUcShUVdToTfbNXs2rNfSMSPXkPoU2hkfwcm3a8qfI92+rZsRz6pL3br6Ig3X9PnrCsVJ69RBZ2KASyZS8ol2aIRuGb9FYIJ8UYKA6taDRX81MH+Zi8Vc8tEpmcDB+HEUFkg1/4/OhZcoocdmqV9ZDOUPGIcX1H0MdYoIk+thREjJjMLChCbxYF8eKXCLyV9j5VdUmJlsm/hwWa2wuCfUIRUXHFBYpcFnfmGPY3Io9uurWyqVvTcC8ZP+cJE64d6WJsS2djpE9JV7vwrOm0U2veUNqwxrLwqlileE1mdTXX0GUPkg0x2Q/y9mIenfkU9KXJjQCVQ4AxuZp409Yy+XxiXuGTsGIBQmn7NH5hpqB4AeMQRdFIj5Hr0V82bGeRruEJP4K2wXo+OvbuIaJ8o405gXZTQmKUdJ8iv2ecAtoETGPl/mJRjqvdxbbDHK5r7qrCuBuzXnNjv1Grrqqw2hPFb2LdUo4wTqDu1hxDooOoIMEgC174ljFB78RftEAdGOF7SyVHfLWznvM8Bpxeg2szpK3huCyR0lwbH7xb9bgS132Pk4lGp3xmrIY7zmAgVvyVevG+RGp90X2NtPtTOGTGT91v2vTkSVwPm1DPRhJIg4DCnoBCjZm6fslEM1AQSOaC2GRdGTMMZ6Yg3PxY+579grXgM1Z1RPZjvV+bDOjEjuYmUcHKZF1s8kgefEObgsnkF4RydY0rNizH+6k6EYrkMG/LCbU9faegcGm/0o1kDmqOggAxeZur6b6K1iua96RypzA/FVMSPfjo5ouu3tpWbahYL+m7dxIWXTJstWXoEPdB9i1pUGg6q+Cm3xMIrM+o626bPq+IPUOja5C2arb2N6Ls2aSfzUTktDi2ssCOFZvggHavampdGgGtbOi6je3mZMDiwWPagQv9Ty1EfWDRA+FFf7qZmwuB3I1ATsRwu7r06zket0llPFeuyiRZ5lGRdRObyIu49BOZz/WHKmGpyC3SAtfB1RhDuA90c2BOPff6tPQANQqSA5NMfEl4sCeRzfuBSItACuT5qge6aUYaSnlzuETHVmgZWMEWysgoABNWG14KTN174vlOD0abZlZsbM0a5yrpT30OUooXjeIkrFHg40IBosEaPlKDQRm/7Pb510sIyThVZSvzaNagj8dhkr2djkGQ0sucHum5xgIHqqUdXGtwSVhUnfByOZMHyZ3+DYM785/ktS4NGjllidKCUs+i+lkgLhJkEcAIb6Y1pM1Qh+Rdti4umwNGcD5ylFDCGX/1BAL8jCWM7IaV1Y7mjIbuVEZc0G4hQemrwFBCD5odH/lrGxHGEa44h7icg6UJCF9owBOlQhBXx+UZeyB06l8Z2r9drTSPfZ5fUnjqxkVDpMLNFVSii1Nz7J+h/swpUMs6paLqZXtKWWgBlTrkBOSKl0EModBvOD8tjlCwJh/MUQ431atj0Q4qkNnr84lHTEPizEREezyFfQY4+Yup3a0WaS9O/SKJQNJD9GhphuwyuaXOkIa1Mia7kNsr47Oin2vdMgJRr6EtI6nn7Jg3V3JRgncxfd+CrbTFqesTwrKwLa3QGEvNu2IuZSYDrafzRR2XuapN3CObTar6FHMUi3ykyy2Lis+FYoZplnjjBKvReihpSA9QZzg6Dj0x9k4a2b1PZf0g4Vn0Jr6EI8+2Lb5KsZB4DvNbAGm+kab9jE++3qtV8+OwJseV4nq8chgqY+O+G+xvJCVWDfNi5sbekh5N7SvKk3x1Jp3JmpK4zdzmlXQmbW2azQFZOql2ccFj9m8IgeTwRvpoYlPGM0xd/pg8s5cjPeyH+8GgWRDnroawU8rLfr2RsfgW8YB6QjMZGM4SVS6c89LpmClBxW9p9chteMxE+rjOqgTX0zlOQ60Ce6qRwm5YmOdllLF3Xbl8YvBhWNjhPVzwMxBmXhk+7hYGcToS3rG3Br4x1KyCs+W3SwLEcKh0i3mv3gR55J7HcmW77rtcEPfjoaDJRmzMyEZLUBo/d4gL5IAKYMrEhQkrVgvbqbdmGH0UDa+fX4Or1sHwUxjGgp4BdsEQzIKHL0eqHzAaRcHjJ3nGF9qo7QeAvQbHcTFX2dpjLI8Ztqb1xBA8ZJVOjxvco8M/+69pSvd0MXEGcrx/8UrrPp+sVZbamQkp1DIYEPQzCVop7uzXHPQaWsYJ6S/LcN5EjEfT5dZUjPXny68xirkAsOJbOnawh1RnUGB09msUnJqG1nsg5qEnNuqL0m0IV9kxaW1cBScbjIGMqldWB322DBX8Hn1bBnLT8bYM2JshGVfuhiDjixRaudXCcAlTG9+BG2HH2tksQ+HNP5PPDV6WCbaWIyEfY8WlawGInx73LfCqQQdmLbnx8AJ3upBAJLU4s1XWoVJNVTpXcg4vRrkVznrqayu9x2HODegQc8CTmQhWmTDHuM5c123bsxpakqrETC38Rfc9RejFvrBBDlQPcpMfM82gNvfD/z7Rfh3mLzW8d6gXcbbUGv/z46eSiJJZueW3SNICl0B5nLnsZSC+Jmv+rRN7zDsCEp4/OTDUnArtnVMJaGLGXSOKzzKYHLMlK3/+UAYJNn5QIxkodnoE9P9m7uW747Ka4RiWQUTUhI+1khFJzLk7agH8z7VftJGalXlkoRutQsxXmv77QYumYIDU3jL57guibqIXXoC20Rb7qHI5baTGeZVq6l8KSSe9u1P2gQtS3y169gyPGO4jOZgRnxFxNIantoj0WwJUGZN0QE3/OXuqQfbyES+bQDouUhaALiJGLfeRCbRR60A5ko0nrlFlp6DSOAzistpXO2z6OxzMuIHSEGlUPekYROhvdpGdTJ4XpZvgI5HWTGNO0mfXQyB1rVqgsR7sUnkl9J8cW4M7otu6a4z43Q2wTAo0lHdpheRocGLCugmfmHasy9s+jnHNh1afJRNm6ZYnL5la4bXJw/G7pWiII4g6lYzSNHhqTYsYJ3sd/K1Hsqs2q/RmQNQigKzmXVccw7kbiGUKSUtj7OFm7/8mhBEMC79BxO6YjEb2AsDw8iITMma6mf3MS1SWzkOyS9Na38nTyiA6Bzu7hFxirV64dRjpBObhL59f/hppkH212Vd6KZb+BhstHaF2g5BGJ/yvXTZMgjdVMhIdEOWKJZNXanL9iOPARnB3Nq6oixwV6dZ44C2xYbrbjASDycFBEFHWBKNrZlCGG4Wuyq3cCPbpSSg0jIQiVei7iPy14KjoGpQ/1kPgWQ/Ne3gzuO/WeKjK7pQ/MP7/4DJj0ktlCZPxM8N1lx6cgkqs6asKdWVhYFSjnHzvKaYxCLtC7e2nQnpyH1hqgKLFfVn3B3QShHPMYg2dpkwFEPsW943CuzHfrdIOcGgXte7XeJPmfcQ09erFvehMYOW75YJOhlPkleHJmmVIUXcJSRvgzE+lC4c0HficbLuPkqyf1175+meFMzG7zb+exk7AX8O01NQQvdpWWdb4VSd7Ct7OP1gAhL+qQ57YjFCBQtjZengh+3gtD/LEohCzBu7r3O8FVJW2uj0L6TRpdDKcczaCvzxxlRs545glIsxUudaMKdDCTvGBgcLVTtf0/fvFte1PBpmm6HElvjWRonYhejyZYJ9SjFA6HqXB02KE4Dtjsk5xJfWeWL9V2Hz2t8tQip69IqaLaSBibPd13/yb4qIP68lHmKML78Fs5pyBrguhxVOQCFIi2tWEDw0dptsfUAMc+I0B/FRRKAJ/CrsyY9+rKeznQhPHo528QnwK5KxWKW54/U+7+Y7zCNYhlAnQbDWGsoT7+G1XDZ/A+A8ZTCArmCA1ExLm2uH0t9qJc6Ly0eGe4z4c1z+sWfdcXS3qhqwkjblMY8jbPJfCzI+atlRXYd+TZmkbUerhPAQEMDgjdZItF8Waux+ecuWVAir+RKkPlHQFh1zbpxrovpoRGh4sN416mbzAOZ9V1Zkcgu33EVT6ZPYqPXxnQ7/ArIooGpmk0NOjlV9fvTE901zm49ROphhw5aQZjhcXGSSg12pH6H20Rm+yKQAr172dOyqvrlaeEcE9Gzzvcn1sYGtgKRkhvVKzWLbF4rEo/66hKDAdJ3OTEJSx43DzLRfq5SsWTWbD0LZ8l5SCt55WZkhm1VPfCRHaqRWTRHjmMcfIuAkelxKXIzWqCAZ2MqjelQHZZQbayvDCf3gF2iZuNQqb1iHVLiySGf6Ha37iqUKerSXYWBylxcxLuBDnn6rSUbGEpJJQ9NoOgu1L4+lQYESsFuBm7NAq0o+kii7VBd9Nv08vWMYYGvxw5ls4AYJgL/726qwcO5CdWvrVXWDJqyP7N+6ylO8CNg/qdDCemyrcbPiXOHjkql/b00LVI/sitZyTsELi5cWvr/vLgczoA7rgoCs7lJYo0oX9IItwb5DDY7hY29wZkrH2tT0lUxz1ps9QpXh2Fd7LwSAhTk2C8FmleFfz0s3JxX5Pp0h4bh65S8C+RU2tuong+a3tKmR/kZ8q29Ddkkn+Fm+8s41qqxm0BNiL+7pSWdeVk2QBvY3MGH/pqtG0ktZfQXc9EqPE8nk8N6P5Vz3piEHQCz0T5J53B1A/nVbvwE0vrWhNeFnpwLP41QoYR7ISpD2o1z0C6LmiVqv4gmtcMgnwkXqMCILXiFdrs+MvEKRmMHpCuuNj8tkvuCe2lhL+2cAlvERx1SpzJoHdtWnctnJ0FlqGpP+9uec5S59igQqoyz2bZ0III0nsSeLsakbtJELile9n1nAfjSl6HjD+YPsF2lHre724pMdXY3vm0Ea//mCMWcwknXUAjVCMweEWenNeYrhflow6ZySDE53eMwTh2YjnBsU+vybzho+l97EDbWoE1lWk8AMI2lhYM+jjLmFS4O1/x/er0rdwWB2T68xt/dUczOLgScR/L6372W+zvlm2fkfB6/hwrkTRS93c/HeLw0UntQzboPIg4/v9f0KlsekSGkJ0vchXp4yFw3R1ocw0GbL+0vvxQaMBsfyqfGYQIv+TzPRQHA0Cyspy/gKm/KJkBLn/Aho4FcGIAp9fg2jpMs8Fs3yPO6Pf7IiWRCGk2uan0PTrHJ2v83DgNXlWQ59HsdjqAm3hovvC8qpccZ4eLSiggFyidfAUHwr1hU4mHjZCH4Pcnzi5frycb6t0CZobve9iZVk5SM2htPFs+r0q2/DqKpcx13eQpAxSck+6uL7i/FaBNSiFdTR29L6L30IUsvqmLXBNbDYP7Sr+ZotSdnrkAIE1VTbzNXlWvfmS8LJqd5TLJNAFmC6mvsGsPK03AKmjMJ5mneQRsv48/c6hMD1w6w0U2ntViGYyhJY+vsgLqSkPUdjgtkUFQR7PzvV6As4avGWBBJZNwpFxE6lgpQxFjd1kf2QgQksUGuXvcz3p03MGpauTfIVQziMpRBkbYuYlYSQPbojlXTa7i7te17JojpfNRkOTfaUE9l+wdbgJGNQjTcOPG+iSGOltzV7tFspzxLjfHFTnXkFnCe3Vno06QO56985u8ELnezWeU351ab+F5z3ZoaowvdCKimQHNRcxb6qxcR/Q5osmtPIvVnsMo86iQtJcSdvaVwH74Dz8hqEGpgzW04cO8J4UokEL/eM6CiTbET3Hwj1GZBYsnI7/VbA1d2CDxF6u526aZDdF27DphNViTU0xOkQd5SOIPh8HtR2jlD9L+4kOV7YFxYpLIPKZ5YZOvApIfyaHtwSD9+VZdUeWlla9j2LGeX8mm/s+7/rygg8ZgiKnFDgrV5dMpSm/055jB2TlXDCpnqv4+JlVfWdTlDZnCGZhNBYgFROhDXiCBr0Moetv5NfZGAjxMtGhAZ6xnMypjGfqr9ihpAY23+bm6wsIzOxTrlk2TJyWJPATH6bXKnJx1ZcW0QTkQ7D0uwm4N5sp/10OHuj9yWXaZRlk4LdLMubYa0KZmn/qEJuuLe56vRfT3W1gBDXuDYjjeHMe1Sv6imUASpwmjbxGx+hA6PAhh5kE2vVzruY9Li3vBK4xFnGirmKD/ohUGas3PrhWr7TtHk1JkjLAqGhtQ1gps+3D/svh+toxclhzl4o1tqb366Bm2RpIJio8lNZcHomIWjHaJ6manLHQks0npOiFtLHRe48M4FsnLkghfruCjJvE+Zc+Evk6z5fG97I651I1dK3LZLdd5q7zl8hgsT7cIRkixT6RYY2f4lJ71KPx1qn2PSCvXBHUsk+HS8LxWa9JUpdY/mPSgITs4fPDd/yitvEae6uwL3mB3U60ieE9v4Ma/Ige1GOb7rF5B9FQ3vLIUtUvPa0okHsbAougl3sYZh0yMDmvq8jxSVOp9dEWj+yQifS/DnQifx/G3wKd5G8lo0nMw6kl6MsNY6rtyce1K6SFB0FDrsrdpd368cI6tKulgvV4TgAkbsCPjMB7++1m30ODhbLUJrzB8jshhU0OJz/k91EQGbIkK5GQgdTqwkD9BIL1kjEkEedSr8Wd4i9oIS4pYMH8oc6qbybOTFbFm2m9nIhg7LW3ZAqlZrtuo6j2frIKFqkIzor/aLBLV0xI0UKAjC1L08JcnZO06jubUK84UKe4loekqbgUJOAjwdZsD794qlcktDTUk6LAgQuOLyUwCwGumhCh63AyRes86ocmmzn/s3H6TVh1w1k4zuUfuF6VB+QIDfdUggVbM/mCvBGLW21WT3TdAIgtR5Hy185SB/iVvfDl+MNE85ivi2DWBjO01IwR9eW+QZnsXtoY35Kt4TIeNQrYHKBg3fL0i8822+CZej/JHjws7G0wLJESzzK9SClxQOXI0UAeInqb5rk6eyO2gn1rxrXpRfFOKJ5YhoCIBzBR1Ulrf6btcDoAwrcSdbRE2HmYvSDQXoJDqQC3eXLHyxoiSKNXZxpWQCBqOgLciEBCMxYHZ3Faruj65/1qV4WS0L4YmA6jcNrnH/C/s5O/W1CXAyqgZJglkpaDTL5uMIC88IC/w2pHK6kO2XSmpPp3DcU7UW8Rh47sp3j6wsle85v+b5oJRITWw8thPa5xILLsSxxMR9b/HILjhvB5RIZD/mYLJOJUj4r+ZXADTIN71dglCxWxy+EJPkTr8MH3Z/28v7o7c0RrHVcKSq2G2G6SmlFNkAKUvEvP7Zz+Mivop6GxJNvWaUoc9UMmlH1zoYeAT5w04EGEF5MRkRhtEuomy5KI/byUnGGN9i5HiLLE0e7bzSlOlp/vuPWjMBzUoptwUN9ZWD5DN1QRAWfb91MOIeN7TQuUTfaBbS1ouvIJP0Tzr3uVQPoRTQQj00AYurWRHlL7ZHOZ7V2h+AeUKr5UChHd8Iksx7Hl2tdMsc65fxEb/8v6s/8ijgmX1TkV4oZBbs4z0s6mZRu9GJrcrKgld5o+V5/4h+n55sELTMoxY/P3S2miX3fbBx/ZwUCYBQTT3Dyw94/am5C8rLyB1ZAkJQlw/2RP3Ul4C6iCpph48/JCfdrBU8dbv2jV3yke/nGadfn54tqxQqHRstSpQblSdJBFPoInAkdqq99j7tSEZeHNF7mDtSB6H0thvULcoyY/BKzX40UehWIguih9pcrIEyqyQTvwk6KkK6zw2jf+WFfx84mvBymL3IvuDw0xN9uSRJ3uzHjvGsL8FS/S5sTPgFa5dj+OKGz2HkxBmh7yiaV/Syf8yag+VJMlDLmTIusFBCzkfLkIie+SpBVwy00+Okas1f0gAYjPMaitiftq8N/78+APS89//YvFRiaCV2uSfh7xWUu5U9TLZAoM6lQeHYT3DC0JATEEFcVN9U7J3ohyYRsvPiXUMSMY1Wv03vQWVMDW61WvsJzxfRhUZGPY0egbF13fYn+DcQc8hfJXL40vM5Cc+BDiyL/rfd99ORHF+aOKfZbuhKf8+nZVbZ6w5ewW6SubjlO6E4YeUH3qiJQ+bK/qn7i+eNEXtIS/VoaF6e+HITpBZos3xxYotrw8xvByYHdnE/kPaxzdPsMXJCVgPWfhhI3+q+wfVF5NMrh0l7wSTramG6ycMvwEWcIK6375O/3V/sqjgbqu3mFYAfJt/8nd5Bx03xqrYPtz8Rv3uss7fSgjM7rhLOn60upVgaFDppjEvInD9IV8JyuBRn5XASogUx++4cT2tBcgKlEKeYgbX9a5P4neRFx+NBBpToWUur478sZF7XdPrQqK6ia5svVeAo/1NAnDSGjrdfI+2u4KyV0LQ+IGDhLjhBGCKL0Kq7uZkuGIBjRnr8a1eaT1Z08MApcCFgCPtdRT8PeQO57F5EH/0LzU5HvpVZqrkeAHHMedOwiJ8lQSuTTjV6Jgt5l20pBfQx3tzvqX8zi0WQWDM3hqzyL7+6VsqnX3naq7xZO02XO4br5oViMNzCa+yALNoVPcaNHbxnnGq+h6Jvrka9K0V/CxYelZWbMDZoRwGavyjGpWHhlf2bcowEy5rfa0KRmeRxaq8bF0rPPNP5iFAOBAMXRQ6W4tJefOoqqBCKCfD5RAD2i58B1jMsa2rEnPB5pqnvcoZe0WD9agCYoaidYFxLihU1qz1WDhxfZ9BMTK1Csw3oxJ/4pOR7mgerTFqNJRfa8XaoSOZGtvhm182dFwYH9siJaAnqKQAd8wR9KfvPXx2n+wbpEf6pxj20GNF4+vVQkRTNistgYOx4siKCX4zuSQQ8u74jQcQq8C+sfbEonhdicS4P5ZckLFLYAqM8xw8rdSG83HxPzzTBoDvyFF4vjlJZQ6I8VeLJt4locwoiPD8jsGVddM2tWBnCdw7kgLz1CVkfDArqHagTiLjerv/vUDBLGck+NyOOhbI7u3TeC+yTe3tL8G1dfJBIlit32Bvi0Bcv8Uch0K8bYsCIaOfIMyaqGgOa1h9CETwrYGkCqpPJFyh4qEXMPOLOInsQYyf3Zas2PsRzj/ba5lT7jH6xVpwfEFSf2lCGqhJukQyqi+dSeAfb60kg4LFw9Qvx9UQJ4v+xVMFjNUs+B9DB9ZwDHHk3rnlMkHY+z9n16CvLQBZm1R+bnuxqeYLHM18bjYQ19/ISYjJdLqE+7qZztgPG33N7WbDTZNNs+iNzA0sf9NbJ0xRci7J7VlQPEy1cav/ecX0f/OZDRE7mtvGHArZCUoV65Q08RrxZZND4yfbpkQzWPHTmnrbVpYeLqi63RwCBmeebgWdv28T+4EiDH/iQ2IstYO3gIQHf4MCl9v9L+n4zfKD+kMMlU1d+R/kqOQ6vrEetfMWKnGxZYJdROP/fuAU7LWm93yd+1xbvNuYdFoxx42r3Qvs0u8YrGnEhLfDsCP25F6iXzn3efutc4/ydgigakfTInqHKrci3i2DcuA3LG8wyP5MHdXcdMGoziuqjHMDn4DUHQ81or6ETK/cpYw1yLHAX7vWDE/3/ZWsAC/dol9CaqB4SK7CxvZCTiFVbRM9eesCiHU6FhmyCK6xMTqRetrxaZvTqC4J1I3lGwrQwMt5mPqWBlUg6vdlhNkV1fcCOFrGN6oeec8yK1PdQt2/xDWs9WzUKfFUtHcNKE9dyZmBUCePHefMC4HgxflzS2/FUteFiTnzzxtOS8g2FLADboCR5CJy/4Zyb8TDvleh94mc7O4Zt9dIdMh64rDvBOzOHKmQKXTEMI9nsd8Rwu1doit2JETc6xEWobtQdsaElih0TkLgAPpiyxLNBPggCBlth8URLkl343DY/bW3ZUeitBBMpbcgg2qHIOtmQr49sfFp5POMYh1YAt0W0leyjFMlRtAZFybkFpMfUFk8Aya8k+UMPUikorULCkANFasexmDFgPyfsMMV3utub+3oTTqYLDFTFHdCpv9NHL+EuukEPeszUKpWJgkyiWTow7wdwELkhw/DHHiuVB3jBICS6I52A/LSR8Ha/1OJQhKkoY51JQ2sHRHfeOA1Qp5J/3iK+i+DETV52hcNcHvSyGHAxZH45KkXgqr3ttbWQwRfAYUFiO+x30dZ5//zPAN74+5gepvqpMpqiUXMcy87GjBnAGgUGIrLX8SMsNKSRuquUgDWFZ9kxw0PSlNzByKi6iTp93eYW4fO+CiHKy2P5WIYRJRM252Ya0P9oQfmB6LmTPhoJeMKr5bBaOsuLi30Ho9Oi+irnmvPK2Ja+n+wd9rM8vOk6wB4y8qcLnqcL9PVbv4Cfs0/SjspEab+CCYYZgvLBmAgNSjdnpsS6aPQEOyqucs57wbK1r5FnOmXAUnXBtt1dOW6VARL3h0CXTEyTZLVG6Hhi9lbgfOwLSoAPIabb6AvUtM1YA5+cw7hOOhRW3t2surAff4+a0DgpoHJWHtBTgRoW7n5urLcWxFct9b2/LsZMLocixyAYiiss78uLETwsBujkAj3v2qXMjIUwTmnnK5JOn+ts5g4vl8f8lIydsuWnhTiFVNfYyqrcEKhB9sesDxy0QFTTgb36GySloeKemRVL4uFOpHS7lCIxQ7h4n7n2ORuDWGomKIEeLMr7xHqOXgkJ0FEcRBroYyUqNaEzFbEmCfC3kaclm1EA0nJC1LxGcyAQDFQDUNtjngi5KXZuufuLgWMrA2S62bDsyKSwxTTSXT0jfJG3IKcHpV6qVsryNbAnHD03+pQb2uXquY3h9Kk8IodryPjLJvhYXUtjaGY/fuy3adk5Ym0dR0XTmgcXu7yxfQSShpsrgJk0fmJBeYzLHMfQzLyjRijHos6hmacFjSlSWDassKONMeo0BY/r5dvgYmmvK/OU/KXHt0OspcuawSF2wtZaCcF+L4g4lDYcjApKMYUa8TffgB0LiExtLZS50MVI020Ca0NZUEapaLk4mQ1CoWomokZGDMeMHWfrIdJb8p/i8wWCyeby6FpfD6N6Tpq0+WtDV6LzsU160EVEOcqIw18GHymJVpUk1kizTaac9aZs5jbCMwUzoupGEWZYyorqxxsE9Coxqz8GGvren75RJQapYIE5pyyjLR/paSdFuApcLTCtVBRuZ1+V3r7UTsqGnat7TiTh9/Jmhfo9SCwzjPf5REpfwW05W2V5GuIwj9EqDqm58bJR/z1rKzGmxVzhEv46ks9HIovbp67PrnRxAFPjHBXuBzuTi5F45LlD0vbBflqb0A9ipSKfJNsiVJY7GUYMeeSchRR5s84q+2CzUNuUuMiuqPckNuVFUJ7j3P/VuXvkkMY74dzw/nwk2qEEHRKmMnu6OlIPdJYsLfOwpMWtpyboWrZ3kdhSTy9gz43Dp77RD2Qpe/gTPVwwir9PsSqcEaPkgrmsmf7qBktsQ2kBHJe1xrhIOZkFQN54rEioem/Zzx7yMaiuPmNypSqG2kGBMC3IRNAT9b8ibl2aq1uKWnRqHcYLTZERBYXTqBmrFE0jzvonIMVj8MID3aVi7CxCpnWlCKfDWxqtr1MNJGFTh7977f1IUDkAunBVty4lM9qfam4+eu2avSgxv/75H/ZlI4KPcFLn9AzF75YyT/O6rYM1+5VRxaTKf5c6t2ZkL4yEmRCTjKNLJ2MVSWKG02EwUsLAXzbqkybv50hGHGp9KDNE+AW1j5zXgzSfyF/+I8ewCAMFAGORwZjglD8b47Xw4f/t2Ka9AkJBFSkCC2kR/e/eyVm/U6uuBo/xn52tZd1WbF+DSbGxCoguidxZz3guB90K5aMf8oJ2EyzhVF3cfdom2oKlzYmWSG6/5xHmz/+6m2bK8TGwMJSu9GIQD5jLUs4p3uRlSAWRJpgSwJhOxF7UujasoMM3uGns6KoMrs0VxoZUot7DtP9IKdsvEHq67q0bWgFJ/azPADI2lzWsXnefvE+W6uvsBKs7O5c6G6WOWm45IiJ0VQLRJnjdtSlN4P7rCOkmAVT44sDlN0wdJ4xT4cCjSIFMS22kKgfhx7QksMxClkUCbTah1SoC5B/VmqIeGT30/CiV2dayqGeHM5ZRLfPSJIIsiGRsnpjB4wCZ7h+XgWIoZ9ArMAb1QEGO0uJ9YUFktWwcKn7y1o18LifVRfNgzPOJtax50HmOALJLAqg0PNghPxnKv1a27Sw3mrkqx5js2BK/QrVF1ztRNeRstcpMHanouC3X+e7eQ/nWil5rSAgJp0UH4ZrqWQw3zf/3IHX75Haq513KqUU4FuLxXaJtsNTu80OPKkERa306wjZcvyzaqQO5zcaV1bXQOCFMZQJJ7uMni7MQvNOw+rROsshAOT2fyr22F5/9I/s7gHZ4lM2M4oyOGQePWGsH5jkQDQycbJKX5X30cZE8zGfmgi8zE3gqJBwu/y19RZywkONIf6ZjCEqrba3SSVn4UdPTR6KUSJweLlTXghWFhMoAGJiuK1/2UIjoqzpVqQZKirAlctI10jwTEibsDVpahlPNDSj2n5rk06sD1X98K+8QWsZwLuruCjedMkGMjBJidTvLKROK4ZkCxghLux4AgYUWCiNzPyCvI/otFACRvDvyG6dlQA/9+gl37qo0/IXPl/xVc0fSJxGeh6hVLANdZWioTqVr3Y7kspuFK0FS2JnLffvF2r9cHr4Fhp5zzKcS6pXjyrqdrvJjhOKACS8WZp+itd169zKYtRro/aw8SpMmlCAY10jhOqFwdZI0UXU5GlcHuhDOy0kW5J4LFLT/3oWFzapsviu/R7juTdWC4iX+Yq7eqVn40GDJxE8WeYOCSeYV20oIVETcZCBq9dn3GO0fmNw+3JC4Gba7WemL13Q2NvoEPxhHQLUo49mMN+OHUWfwPQsUclc4a4Wls1WMv/JgJT/+kUrJapUxrN4MGAxnKALB6slWAfH2XX1ZxB8StTjptpsSQdL2JRmz5sFbSUjY6r6hOQMfa4ypZxvMW/mZnglfcHwjuRFoii8xdDxBbmZ9yA6KD9jWqHKTTJ66aeCsrWA6rKXT9AmtJA+/3WvkFWDlfeX3dm9IoXRialZkaQunv7zRh2X7k3U4viMY+0uDZGA91aAB5sHCNLbLzOsykDp4CwddxHAliB5xyMUWn6TKBcYjoc9Dm7vsooZmXXADwZBzN5u3jtBohAs3GUPaHOGm32qM+5rcmsskEdoBbkZWLWsmo3lp7zndowPUouQbv71YTa8lfS/UjlzHDApvX9IcBU7tcPFcYsoYJgrifW0IkbvR2nXY4vJvtcUh6IyNKXf5Cszy8mDtTsxpxS+UrdYpLrkDbi+pIWVqv6yezWLbRa8cfvHAvH1jDVty+fDLZNJ+3WeOoPcR+XU3jUBNKA4edZ3K3iTAUj1rT/UH76W70FVZfswiC/7mEUeFlU+i/0Yho8vEhmUH8S0J3g+DH5qpfKO+AySsYAcn+zgTAIREvSHKJhcqR3dS4QB2a2oODQqDieLbhEAv74jacYc1SlsRTck2+3ynGoF0p/hYjhm9EP3KbOcI/0Z+XnL6p9M8C4njdbPwLgtjTNDiClnFllfdHw7JJPFCQibsHvp+Azuyh6a4a5MyDMpGmU4+B84iPieWBGuJDSiKjhUtJq3qzER/bOJy1AFxIANeEvPI9RW0rHSksG3L2i0leblh/Mu0M9e5DWyGz31qJWmOlajmcrrrbyVYTpw5JNV3NgLkxQu/emZNYonCQZD+V4/8DaGBjaoDqWUkq+WXxIk/Y3soD0zZirrW5Ru8QUtcpizmg1lmu6OYcTszQhqZI602sFlZd6Q4Sx1Yao4bVy6j+yd0ZaXqu+YxnD5hM8DnhM/xXO5FyNqlgREjm6uk/xJ984+rov+z9NQj+KErkWwp/dwo6FkHcTPRVKvOFHDCKr430kUAg2Htixh7eioLgOFcZB/aH4QOUiCEiVsG9r08upg1qfy7JuoU2fig0XyoVlO2NuWDxcAHjckI91/oeEG/eLE5h5RxawrLwzvRqlRizyH/9x6ppKDOUplAsHzrvsGDm4VUIGtE9mWMzpk9ANOUIlfotOkeE1eNoLUQ3NhAW60P4MINC9xCXhHOznLpNg33U9+f3uJhyp648VRN62Wky+W7a9I/+7eb0wl0ZN6alDwEXfsMJCw+jmei8P3C2SQVhBa2lXdksjLrqy67i6kFM8GPrY4dlkxsoLGwi4/aOnWe344rK4vxhh7GdRPZWV6vjM0B0MZv4XGOI/3xATM384uS57TUOqsyAcHGCIctAFJ6YCiN9CwKi2BVHmRzttcX9rsrIZgvseIU44M27oKjc0MK/9iT5s1lOdxrpC+BAarUAiseuPxo7zqDKwAVKgO/vpVBuMFUhlk7Qf0aSEn0nsR6WmcXeyHfzdh7xVbZbhiU1DA8Bla8RjFMXcAwM4vUigqUNJ79NT8x58/LKLbPLf+CHh8E/XB4XFG1g5axNZa2/5NhvmscuAWpJFK6Fe6hyUjWYzquOT6ihxOWt6BtY6ZRRsycPNaRbVjrOz6QIjrpT9fmjKbhFs/ibV6s7f+f7chDoJl0YNgkc2xlrh+d3T8O51y10L/gYyySw3LyMIz9/fXIv2OelSb4oitgjq1Q/Pv7xtL+dXu0Ly+I3uM8iuskEKCqX6HMot1bdu5kneoV7TB9br9wrCiRqFSGJdupLvND1YAF3iqNS7HCLKYqmEw1fL9e/aBOWnuN1eBFjtzQVxaY70Y25MFrTYD3H7osbjqKGa8eVXNjziDYixAg1ZCOjsQpcZSLU+lL1uiVk7evaB4DSASRuWq4+ZucsfWQiK3TuXkIzEZi8l4YQ2lCCqqbyedVTyzVUu4BzhcEwp6iFKDHB0pI4dX8LTA2beUkKzVAd78vz5R1jlP/UPrHy81YyIFa9KSXp0b/XP7qeAb0irzXhXF+elVfqTe4P18N41aH7VB8TXIiDf647gDR4CKSvTXt0Qs/8e83GJDdQuopdyJI2ZzXGWM6N2m33vzIm4hnGbDF2Nk0DRX6tXyBVepsQfpBnQezsbEH8asFhUDDtF4TtWGaqosFKWy9n5QNI+Za3neZv68Abu9PJCkHDt+hVIaAbw99NnPPHNijYWNLCvq9K7iNNULnIGpOuVOeydgMbZn8eZpfGpvYj2InzFQTms/8Cv4yMbHnDLCxIOXqUXoD+gaTkNJ3DMa9VaZH90iJX/FDFoAPfRWbYG/tMBE9cycu3xCfg74NFGJDqEGseF/cirt1ZaHCbY73J51iWPgZ381/a1+AhEYZLmL/wpdfT8SPokykJN/KzQ9D7nXtyQGQ5AAGL9svcL4IxqFGAsHeV3npf5rtuLLt+G+7bVQI7gtook6yI8g6UU2XXFnCP+oLshcrb9sByPjBh3f91YW4ZKrywzhvi+q4kLmJBen0Evd8spaobFHEbpJqq0SCfD/Kz9DuKThj4ZtV5iMfTSVx/PTVp0cKHDwC8jIUdVHF+fZM0TZglU5NQGm+ez1ooVvX/j5miy5Gu13ZKd6VcHcJ61PVj6zDGoY7TT9P6L+J6vP6SZjKLURf/2mIyspHGA77a00JpbjI/4a1RpBFLsZnN9YoRC7kmN1jZM0+WWin9OdZeN5wMFLbO2p6g+xOAVfJ3WnKVD6ntkekAIIgRigH5GI9W+3558fCtq0fiSWAR+GZBeErjeF7WrET7tzPYuAbrTaFDPKfZrSiq2TOOHQlv1mQ9PI4Y69I+sNMFPwDiHlDzWfzOyBdbvS19iXckkTwDgZo3LXhpaZF4O7tUzSfCOfLZy3q3yQa03YlGbPquSfgWHzf/E28VR++xjdJ0Z/Qw1UOtFpSp0/Zc/rYD8TgKhykyOvP5ilDT/GYK+m0g6N/HICVuo5IWUGPSadZXqRBRg3eWqhKZFG0UC6wo4HS5Y+xm+cQ1FDyHJ5/pf+3a/j/6lbbaFYOnhMqi6lvmx+4gshfr4aMwsGX4/nz+GO910A4DdTe2l6odKGH/QtJyaPVp0T57OaA8ILdg0b5KKmV2vi9AOWjnxIYMK8ajQFTMbFkBdPMhOURZVgw39mmVJDS/0SMgecK5H8G/7I4amndZKWVGQ/wZpd9PVaiX6OWyu91RjcptysgS+O4DgDl+tmGwY1noNqEtoKhMoM5GdH25EBCqtTU9mfX9cWFh4diQh7kiGc92SnyTSoKkt8/ThAyDyMpsK0QLYJiojNLzsoB++Dd6bHSYpu2PQndBatjOPUuQcfFp1oSjYl8HoPm/kt+ZKNPWcWSJSb31dg+0WZFX5aiU2nSke7alrEp9i+L7pmoBetK6SZnOGqQK6RIBzbjrj6MU5foBjrc0AVKNeGkmWE5AHIeIAOzhDDapNOESrPoPZqfa1EdcogfQFAo2PI9aNkbjOAOW7fEkcLsq/zqKhKLin/ehnMfEBPSPAYIi84mS5uddjrJSby51/nhDzjN/4qVYHVRRtshfuLOic16O0XpQ/0dhMEtFru43lLOx1Cvk1VMkLRPw3P+q5I95cfu83PTR63rQzsEzdpRRitBnILX4cCFjx2fZvfFJos+HU/m9PFYugzgx5NK+ul80jDBcqX7s+S341OzQhWb+DQryV5q85ItTiB6I+ZmtgDjgZTsihh04xGfsCrCFV/HRLPkbHsoP8VmKYBLLTSOlKEqAr3EUgI6tMLvZL1r3+rt5MD57Vg4c6tXM3WSC8sxeFqj+XpGol6STtmWyFNG9jDr4Uhp3bpsoL5qCi/SGY4YFAuJmlV8WqfSZVa/2TmyLfaee4mi8o+9bNS8148B1VGIuGZVMxtT3Lh4PdquxIWNSOWS3IdicWXMtd8ABKAFxsd8ldFSxLclta933+s0N25SkLxd5WIbjYzfMSS2o/zcyopFbfWzx5oWF3IOxGO4H4ZehE8GYXnaowXt0V7IPz+daDJ8gqSFcCOBhLi0+s3lJBEdiCtqGMZfTxsv0iJ8xb3BoCPWhuC7F3wH1eMEASbh9zzwGlcn4kYIVNDEgpX2Ea0MFnvrKqI51NriUBiO6hvuVDtH652Ry9UXKzsZ0lfwLUzMTxnT5yJrTar6R07KrlMtB6Tq79mEnxAKs1RJIbFG/XvrE6xgGmhu/qIS6SSlC5N0t22m6pyqjxibH49QoRf+84eBAH4I3VbjGsNpeBDeRQEdENFgL9wX3tomfsqQ5M6jG/Alv8+dCwQ4SRwzlFH0OZJvhTXo+edCzCYJU+8r2MQW48ggfrP3POFbTTeuIgeZ7U9zwrdDECvJJRWlkOv4QP84EhwXpsKoANjL/BF9xyYVC5FGP2l+5LrkTmYdRvry7klE4n5LrBXfnNwVftcW2BKcvjUz1Ywh4ZGAWE/H2/Jg844vOISrEKNmi6mc3fMf5JNVNL+Ztl+d59Q9Q88P3NEzVK0VjkS/omLR4QiWQFQcojB49Pcaihpbd07jzLF1zSsDYoBeWXb+zht/8z9kvrRs+p5grhl/YD3IPY7uvRsSn34zI918PvygHch+ab3l/A1avIR9qp6nA1yJ+uyGkSpcfZE9ckezEfqJcRNKEavUafwWHh6fXTFjyhY3BkhDkZpPNxb2a42dB4qBogpS1BC7CndXkyuLYQEbYOiOJVA795oVcibrXPHYjIN8wqPpLTy6NORmnB7hO+TUfL7wZ0Z7ZamrSploSYzBofeNXeq96RObOiX3DvjWFD1qqgxYVSfd1T/wN0Ay9po78KBWiJ7ySThRem7iD9b9DOHDU8fZg2BdZTvJ/wjAuT+TJcsnxW0fvrTanZASPpB1qG3MR/HiaJoGCsNmCPMW7L0qGC8S8UEpqaat7MLsDZBvqTmr0fqVlOD5y69+xLqROfI++qd0m5JH/VBUsI12q2nK651naaYiHBoaX+ttSbqc+FEhXHj5BzO+ATjbPjaetc6eXczbKf+Lz/cGj45p2Dgfu4Cdh+AY8TXCQ6/7KUBKWU2nHOoN0MSP+1H/5Xb+9/KNeds2Bdyi9/l7NWcLrSj9K+lyIw3K5j9P78eOX6xuYG6zOL5NeBV97hUzVSQ1Ptlaw9th+xk6K+ECDdj9IXWilk70rYtCiuXHvGmOCDfdH892qs5I1qsXK7grIsoMmpssqlK5Qzy68o8zr1nXc76F3fLXDgGZhZEhWl1mzJI6jeMKMXQsq7Z81kksBHC6nw2rxxY+RU4hqJNEIicBp4878wFNZlnWBfgAPwPvBVI65vd4oxgNtnDgJiwcSlZHgpvz253rJt2TQbVgVrDmc+JS3sZho4wxigXqSR6njdLZzbiW8y3S5rpuI6FV1fK/WcvVJJBYiP9IfbPr2IjtE3BzcTatkAaNfx2/TE86OvFU2WTX+/vtgk96UJPHeeSJ5w4BcqmxXSZBz+aCErQyVwUCJ7RD+2FGOqB+Mw2VGgz28o0qRJEJLKXr9TVtQD0XrengcJtMn5QDocop2dCKUKh/jhUCmR/B62ChPSfYOc616Gcbn/TNSs8go9gl7Bi/ZP/uqMbNzv76UaSUwlp8Z8SXa25ghUVZlIe5f7Kygn+lQPMu3TWjrbpCYMn/9gDCNKPFvCPb1UqljXwyl47oIpKVBktLuxlMXts9vjTA0EVUzXFjibk0m/0swGIPhNWgAaVfAVaJ4H4VjjG5Og4vyNLbmgRR4JC4NXMSO16JF+89AehP/4cXfoHZFSAbvXnSGOm8SxCcexmvdzdtZcg7iFM0GJNxUl1DFlc3+rm4E+wITju+Q4nrTkGnxJu0myYfNAunfJQ5zsd61dd2Ml32rFx7CbARFn86Rr1M2pu1msfHDoyfCXolF8joEZh6drBL51fFe3ip56TuSolEck8ILzIH/PpQeen7hn2E+f4Z6OjpPtdFqJtjui4wKcyhsWMdY0bJTo1znbfgBy8CVAroy79xCNUXFjnq7avLa91wtbyCm7Eh17Q79AKPHF7ht17qLCWSe/7Ud6oSgMlc3SDdNVe38tUdFasP6agP5YR7fYOeg7YVmqliwZDHL3xvmklOjtNACdZPRBbHHEJlgVnmYgKP+DtKbwbnhbpmsSF1Ef9N9pYBqa1VD3NDUj9AGg/ZjR2YWBrHngKKKpylocXes1UT4FHEMtjXBiRW5NUiwzXs4sIoohb99PKcRZKiDoMt3sKYhoTqdVog7vL7M+f3v7ItTiQNNij7PPUK8G+GoucwfNrbt2iiuV82f2t47sYsgL8EtAGv3GOk+GMKvJFVPS04HKS0Hb70bNJv2W/kVjQGROKxCQIHFgj+HMQIJgPg9Bb+rcByiINGE61Jx3qANXY9CdT5UtTLGEhkogMdXPnMZJjuEE1GuSxc9hQ5W3fu6ZBFKaE/27Ncsau/GSuuKEl/Zjdj21sf+oZDm0Ka+IzAIUBGFXoctOeLSJir6dx+LcHZfJ9i2iQqh/98rA6XedTOV5ZjCgz3i/wMmY7DU9IVtVrWIMj/aNXiChtXgoL9MmBMlexvbRlN0t7rpLTZEh6d3pLv3AEut+Fq7hZeq8gXws449VABsn0CDXD+AsmZXr1jao1IAtUVATWifnFWn4rI4gFzeuTGsm6DVNSvvaxOH10iQUdGPotVhO1BcEkGyPRk69v97MYrHaXAK/4OQJxvLuQSovPaLER4XMIRdV+CSuQh+fXcoE5MYB8xjIuS5NbVs+bqtsU5b+2lAU7W+xtIwinLVkVyVXejDxFVWskkkTbz8EkwieCTmAj4IT5xUcinbDf3YT/fKYGcbxsoK+lfj+e8ljODrAMAXDY2CiMLtigMNu3SidAOWKrOTUv3nHsgfwiZNZ7kBN91Y1RxzENo4G9O93eB3ciVaqexWYOVgMzVGORQEdSKRM5dWtDYhiRO71eQC9+DU/A24Y3rzZa8hT0j9p9b6akywDEqYPpF4BmedUzgSpqw0w0UJomxN3DwLR2CFCgl30+fsRBtBgUer/N0my4stafWr2ZVWffdjSjQuZPLxshYNulXlvY3uJoj60mX8/7e1GprTax5mwb1SHBe6/7qsP24F5jPgClVG/jm2X9TzkmUISWFr+N3LZyS3p87RWOav6YmdJan85tcsm/NIxnAwk+ppuF8sjt/h0E5sBEnGrLW9wuM/CxJ/fOxtU0dYPNCmCgPmy3OzUXwc3PTIJbsV5kw9SPd7bhNLPlhuSAmTxZOWqt5Qee8SOXjJ+GhPI4/pKtB/pALx5rrh5dso67qgNXeHgNNQAbTWa6KJGnLwIYZ9wHRbCqGGGG6a2GLkEsV2zpImnd+rdXR5Y2kOWEbcsKJs3ZlmbjFxglI1AZFjjNxnkBOyEW8ipABrfEXJNY6fqNFN2ePiSs3ZdJQvtw9d+pmz7l+yoQqx+L9D740D2xxnRdQr92JKS+XEwLAjLMWdtegxZEA73EkFhZmyGBv5uMOu03LXZch9r9w62GgxigYREBgm4SqeUL0kj7RL7geUdRLuVTUzwqYoonwnNXoYlnW51tnY9kluh/dbkmCNg1RDseLEpLQfwCwzVoRiJek0y5NoVzJ+leDO3KRYd7/KAlmh2xzSr5+peIfcW0lXAqrrfvMmiDP/3IgVMBdsVw4fAQLI5PoXSuc1ZTP7StpNxwZodGzcnTW14KmzEtGJ1uUYx5m2v7lvL3AvqFgUcE1LUaT02Cn/TqGXZVs6Mg254zuecHbfC5lsS4BMsBSXFrJVTdYHBcgh8a36p6A4AKYYc0OFCwCS6bQk/9zpwDAkPPaUQLhoaTnhNMqv0EZW2JZ5JEh7NRvFyfrAM3O2rQIUR2dgbo1BZomGycDBJA72eEyYV8myDDnHrZiPtjYcNrpbl7m3giW3NSgir6WO13Tc9EBkdxnnAFbIboDiNArO3QoD2tlgIM9AwhAzTVejhduC/x/g1wHP3KE1PHzhZnNeSuoUm/7YW2/OAr8JpD4aY/XUcTJ6VPHpoOVwmdWKgHb2ASPPywWoajJq+tq/nhOl9HPuVHUGfz++nYxVIGZBxo2MIcMkHR8i1CQM8vGb8lYolUJPsOBtkq3f/noFCg4DgQs1GNPQdksp49Ivz+SlE8Nqu5H/Z0vLqYihyPpoH19QGJyVAJA+26ATVG9BXC+LQRifZyCxQpjOnXvIhNfdc3+GZSAxTSJbPx3CyEGfA6YQwCUx30m7fln7XtRdsFjmUi95pH2h6WK+17yw73A1IHoMDbpIzmVNriqYR7qLbjIWic1TCDmdE2K3J2B6pZzwwQ591XZzTmyHoib5zI8Jg/aRraW++NA0uvZ8PzAZBtr4lX0UM68u0Lh9Cb5mwAYBIdOW9DuMxqlAoZ3SVuM5y3MN1o3SKQ8OxejKNgzjm0sD4xEztWrwIsT411DLrmxQfxqu2MEQnW/y3XuuR+qXIs0L1VCmrlyNEJuK78pXOlvetx1cAJJlO3if1dIh2NLICY4xlfdCPdDFYuigmOPVMF11/8F0EeUpZkAdzQL32IAZgNtlArCVzU5g1TlDDqchFi8QLGhe7htOhwmcekPZMe/DvXZ/aixlNvvjbFv3Zer1oCcN5YyWjZNIMx/Wt+NBimPZSSMaiptKKZNXNAgS2vo0c567cKM55vRsuaMD1QIvaox//m3YqGGgLt4NG1GXPvVSaAgL0Ow7oXmXdAvEwPerVjWIghbmS3kH1K6O9zzFPFYo02STIEHkPu2fCbfTwUkzyW/l/GK6L5sby+VWtCw0txLuuT/NbaPXh+A2jEEpDziStwMWO1mvDNhNkHt67VxXvFGthgAFgc4pfGYHVnMf9YhmgD8qvJQ2rLkaIFqdqXSwcEG8SfkC+TyX9eF08b+TjzfEE39Ixty4+P02pDgpSvMPFUnupEhxgPz3paT2JOMbIv/caIuzPp605/NL+MjnsDZ7sv/jbpVD/65OYFv0NiG5eBxQuwAU5VnTyeClreztulgpFRvNfHHGqkEJoD2NmPnwfeEutKIS8Mkpc1iw4fX3AFbL1nnvg85eJP8LOUMtJ0tahzqb5DlBtxcoxi9+FvU+CQSHXJuKVi1mQbxIltaekQeI98wlDApJxBl7eXhsG1+KGaLcPL9yVPuX55lzNQ4kII+xUIgHkdL8aGv+DKwfEsXtPijjfjdJWTscrgdXtFNrPLSVxCnJnSIaNIx2g2NrfUGDaE05J+VEIGR79GmymBsrqHzuLtPUqKNTDq4tiQYSFAXohCRaYZGM4aS21pjPQSI2tI687l0i1ys2h1l4pE0vEIKaEfweoLvfARpHKBQtsMXdoS27zZEjyTdkvSsWuXZ1szwjt/9IJh+snZvqLnfyMLJrT8DBOLk4SaB3vweVA2LgA/4RXzK+NrBkTPJbzQAh9eJF/4SV/5ljzJAtMQlWi6EJqEl7IUYjmfAcHfhXTf6dodXf03eqm45m4wBNDfhyPjqT8MmQTCNVD+G3qX8gKDNpcZuXpGTgtuCD+2e7hHdHwWgYuziTu36uo843r33hWY3synMZZDMJUm7v6XLz4XWJ9b4An9XdCyNO10AIwL5jXSKLWJ7Ci2rWFhVUmHWyS8ly30bkPyrdlHhvsuHBodA1fmxgmsE0QiXhh/GdN7rkmXT5kTUnnk61KyP4JGdB4TwLXAmlCYZ7gGKecB5zF82wXd8NCyfNYXNFRJPhlJUpHhewccZnjrBKAawKnMD056AiCSKx8QdHhQMgzGn/l4jrXbxW6GFSxerlxWe2bU7s5kUqaMvrx8/4wJWO1WQnTeG+Gx5+/kf6ozfQNg2jO+qlYJS2RCn2K/fwhCUb/iIYVy0oDZRAu7guglUxKEHeQ74Lnr4urJ8e7lRzTJUSvItYQ5P2lNqL74MmEPnfwG2yEFnfCkQQWnygpoTgBB7vx7KXxZjFLPyAjOSedgNuW3fK4OWrUDTTCC6Rv3z03bbZpi/e4WkpkqSxuNpPrjKQyjeL+b+6F82R0LspbHL6Gh2VxDlYBd72G8ntbvyotMsej5DIOe4v7Rh9zKaL9cKSI23ky3k5O6QX/AsWCTV1mDWTkiFyRETJIBDR1dsKZWlMV7O8MLaqyHZWQMgE/Aa/7fKLqkNpAvY7YeUzGLQHDKAd5FqEOBJmhMfVueM8aI2K3eMN5RxJiXgEAG0Qdc9aBFQH9pJtoKSJafpMOpZcPoZ0nscXitzuny36J1V7JjoM2oQb5cwv6MYrCV36blKcDeRBNVVZ0Ek0rv+aS/fNaxVF2DEyRLLwK8xxj0lPsjMlzZR/Yc7P+yUvJukihOBb/zvbvYhRhUwHNQLCg3rNUMf7IIwAiDTuJWb+nx0sdZMnQx6UL3AkVIRYooWEVJJ/sIKXZtern165auNTIVPQGb/7NyuC312975h+32K4zCkorpG6JBA/Fj+/llU9OMjB8bVS0pebKzvzNklPxY9j7LyQBxBLSbEHQ8D1VuribIy/uJ7YZUVu6thDzfNi1SvTnZcgaYACyPeUg5xNY9WU9Pkt+w0h8KErciZmXNVuyryuvSHM8wJ1AulhRpS6sktzzKQxWSPCZXxDFnpKG+c+RG5l6zdaStiZqTq1I1P7nXPpEEtBNh2qj7tkwMnQ89+9qCJOzE4BwDB/IdGFR81kxOcMHB4CKCO7qt0uQZ8387/nGyXM+8ULny8jv2k/ibi7hMWkqxjjLpn5mRy7APSipwbYaWahslalONK+e9iyWRCXBE6SfXIyxuOgSmg9TeGcrGu41+I0xm6bGoDlnfGHxhM4BshySfNOD5CeU98hqA+lD9LI0Z861LoLjWCcJbDinq8EKQwE7kEQrXbyd514xABDBnoAu+g1jLdIeAPD/mhWIsJkoVuLwLoNNdjHqU6oDAYcxhDspqPNdr5dmc8lYTevQXNKd2qap86bHaPCS8vgrwUi17ePFg47DKNEddn9kapI9kqj+AXv+ebM2G1PdYyVAqSsrvP3lqqpkcL4/ZA3xxq3lPolq6D7SZRKG//QwshuXBxKu27NjValerREU4Ix6S+MGnDxc+d1ct6/HYXHCQpv4jRgzds44tNzS0mzFZ/mOSApyKma/nLaF8aKtmimpqCPO8z+20Nk28xIAXTnZHL7p7sGnim0aUabcvY98l+sthgDKra60X06JkKZvdDulxIFn0+yeOrlsa2falOVsoNyUSPWfDrwda2xYhBMtHQfEvPx86VLLetFnN/tB3679+WZAvbTYFa+h/wseWAqGrM4G05FGmWAtOzju3YM5BNvxNFF89oS4foHzpwRdE0ut9NZtmfbZ9zE9z2WlACKWFvp3w222xx/WWJYAAZoFojPqsar+Z2aisAXRcSpfxEqIoO8juLCFCVD/0xRTAfnU1UCvzv/eAho1TLSdJDK/C66+aG29eKM8q/wjV/hDe+6U5kRwfK+W/Bwio54l7cTB/duzUvlG6FNrbwXfovHFJnQ09sK7FtGdjvtSPF2ImK1ApLLVNyG9QkpDJIgulKH5CZ0W16IQP6U6/k6ZhafHIN+UVZyeSrJHA0xSJCgm6vQg84B9pIeic2HacaFSmh749qT/dYYooweVLBOTQB3wuDFr8d9dRR6NB5HJWf/oOwFWDMZnLnzOiz5uIAh6pazv5ZylGjOMN33qIyVtmLlBT3apHSb/x5Ye96jAurIElpN2/1tiRgu6JOU8ZIWlnJNMCiLjh0PlSa9lrWhbn4nBFuYswHzXADWj45qOQ6jFQwD6lAcspKuzBeUG58kv8GeS2T4XIOyUYzJ42GKnalOr9vebXMRVfExyOLfezlI8V0mioKdhdnasrmVkgQsNMIaaHZbRrtdpSgkY559laTiFJktafukFJn+huTPTQtMb2IhyVbQkOdZpkAz4q/iYyR4igMYc0Z61sf3LtDIVQYi1v5Eg5QBk3QvGBZu9s/tuFi1Q0yo8fM3xL7VvcBg70/lCieQiHEwZ+D3KY3Xqe2U48X0igvZzoMMOTQGkRdyCaePPpDsSvfN+rstmF/kAH9+13DYt46q0d0DosKgpcS5GWwmbBvz4KIld/39nMJbSgRI7JKhfC0erx+cyQfi7z5M7pwq11MdzTJaYmgjhR/7xnXKNmwTKKAjql2MabC/zkA4G5IdYwQsUlBPA0FKBMyZm+W/pL5HouXQWQff1vghxSmYtBCKyehNqki8fFru2+gBpPAswNxT0/+tJh/80bwpj8w3m/ZObzzvfRPzAypGx7QTHozs0frlYXYytEy6iw/GW43LMsHvLsHXHbCZ8qk60zhAFK9NlBunp9y5A7X1ovMweKa9w8Q6mq8pq/VzznpeEJmrgI6etMpC03ObuzxJVe/jdyuWVs8S8kGF5j8FgTRft1NrBQT6IVBRXHOL9qkVpasKRtiFwNQ+/EphipKShGXzkLS4YHbs3uIpGDuwuBuRgLEE+6I5yXWHdXaTRkYLa8MgXoo97UVCiLJ/LHh5mwBhlv3ed3Qdwu/4yP/4IU5j7ZcMzYNGrIurF0FZDWxqS/F3oBUu8BBYQidVwtED9jCYkHvnViqcVhefYZG0ldlh08H8FI0iOi86P84xu802MII7SBxnpvB7y3ryifFdp8Uw1K0zd5g0r46tjptKGHM5lnWKNViQQQwYYJN9kjju2TSoqnfUq3klP0TqtyYkb1P5f8wd7LsQiTgQxWixTUIbiYw4OM/PqFn+AVFGPKSc2C4IXU3PN5NYHM53lhEJZkwG0vtq9gz0ClxHn7onz/CT52u4PzUonybpxEk+6R83410Gh+UsZXEtESruwrxzG0xcxEl6BwL0Rc5Zj7ZxXtmI5+q1gEmS/ffbcCmbcKIIsHKWBssQNN28rFWABqkgCCoEtrWVVBPOhKZKEVdOdbi9o4aqqxiVleCQ1WO8JD6iIboxHHYUE5le5orvnnHO0HhN/KtnV0w0DzO0TO/6MPCh+W1AiXFW3Dybh58bE3CqbqrV5yqXPbzlPJnbphC5F0Q+sMAvd4ADUqtKEwrqgVqUxFMguLlm5glbgj9d0SlvNuO4HsIw4JdZ99QSMhKylV7HKA0RXBWZO6yjkzB2l3B25Tr7ncpOfX0mudFU7TaXeXsUIdGfjFMkAkfDVDNJBu+EVfLBIlRN/XCcbDfl7m23Onx4lY1cOsNbKMv5beL+rqatkXqN2sOt8vgbUaxedh+kYXF3qmXxCstM2MCPhg2ZevCzEuVXlb+ZB8bOEJ7LFY+bzpGD0L70EA6bh7rAVVdBHePQjW42tF0zEfPKkckWb7WO846mOQe0pbmrSjHAPwyRChq8ktME3zCkyO08gMoTLDNlkaeDX7tIu5DlsppFhTzdQyMXIzlFtbQ9F2o4brmFyOU2mSfdslWPODMSFIPso5sPnKJKaJVDpuxNSKLX4nG5LvuYkIWnQvtvCWoo2ojGedOF2VUO51XXdpE2H6yApPdQpq4Uv2EqwjMJkRJICcUW0vaWKeZdyw/xTpQDVGoELSRiZlLEeYQduSk9zNvrckkyIvIw6N+oVaziiDwyHlmHUUXUqwM8F+gmU7yMUIBvKmPTvpkB8Dq9AQoJXNfEp7j/dsvyzAp2g/d11loOT3PluIpBRrD0ppEaCdkEiBOpc5dapfWj452EPhx+uTu45xHb1Eteji8KKqxeOLTQKDV/5HawaEAj4LR1InozNQwE4w4NrJiH1mCD/QW2vbP0ix14BwVndFB6z7xxQ2GXM+97oOeDvnaMkIyyP6zOY9W0fNQ5oTzI8CsDrHZSuaJk6tXp+l0GHTRuyVM84+GMc/yfikyzWnyICOv19PC6gsWyuCRsAXay6w6FRc/mWq+eFjUDuwXMT4eKqSm4ZF8oVdY4JM4jfg8AXDbSAV2m0+Za51eK8QvOjQCZsweEeKEuoxT1VzZIB8c74YGUDpseskmVZHNTMe/ZHJJgm6XtNJ/1qjUp5qq5+HrLUsUnumW2p2g6uuMlt73CvANjLDNvhGh+dB4vRPYv+QTZ/2u+dNagiZDxOK6E9MyrOuOsTkBrdvxE7dO9eBWRDVIYvAgwWd41nnlKxidweYI+G+7SaBlscLFbk64pVnB2sujRewmg86beCNwGTNSySBZSFO6cDgf6okrSK7tdLxdyplkW9ODD8vnvCuOyZvr8q3fRe9BaJcJZZnFc3iDfNOeuq6xjsRIg5volwV/1nzHph2u5QpM7Jss6S+e3JHNCfrCtP+ybqkQ/IPqFd+bHVUKkp3CIz5FD7PTHWuE+Q/Z5t2/bSbyZI62mOoonrSKy9FTzn8+GKS9CsuJ0w//YU4DD8ix/V9oaDwNL1dJvRgFUzfA0KgmL810NghQMRZvHNAft0w+s+sEjYWCdX88+SiPfBiQ1HwQGRE4RfSDTvHL8MZrv4v+cwzsuhK4AthHD2DSTZLdIjK25zvkyKJ2CuGpti2Ula30WDtBkoAXfd31WuMZc47V6Y6ivXduljV9EcrR4E23icfrC/li59rqEC2VOZEXLNGYZloBCSuJG2eS+9IFaZt561mkdAuFdmPvwHOQ9NXUaRn84CF9EQXduQzqqq650NqBcQnSFf+kt9WkAcKLEyWOfM5Bz93G89dUQM+h1I8eXO417pJFMfVaHfv5S/egvfykLwjE19Y0KZJzsPy7rC6r3jXjwMCfff8yuk/MLkBTs3z1ZX/ulidA5QQCoL5i2stU7OuBErSCmnKAzbbiYxkMhM55sHG7sl+A0iXYSFBtOvQ/LmkqT2NkhyT2yqQsv96QhJbvBYwcy7k6B/jif18BIuqR58WIKqlXzM2BBMDYPa0o+2IHpa9uSilGSQ4e6TOSUmj3DrZowBKoAiqK9qEcKGWY7r293XCeEbROVXw9fchhZsS+2MNbMNNc80I6F8remjnAniXXCmVCVnE/S0sk+4GdW1zyVw5ux5QBYNyXFXhIgWWJAW1CdmnT+e/ATknPGkBlvxc+Fb4IbdPPsWv4d/dukTuMwB9rn7+I1LWr0FJS/F6HRQ0lMDG1zJhpTdE7Ilvtb81Zh03WNkjRuT40vb90c8Pq1OCEL44ktcSKvladHR8djFwGWtVTlk6/+MWlLauj/EfJ7QyboF1SLhXNPwZdtyb//3OeD/5FCvmhZeq7oQVU/CWfE/dj0k8Z/RovHZPHqlTYEbnLuKDzj23N2t6Uouip9Uhkka3nOxVFwfhcn1OWQvIK/4j37Ibmip62cuW5dGLlt+kf6Y4zBGoHV8L9u8UHt3W03g+Gev9779u/O01RuJ+j/br2nzp7KNZ4EPyS//p5FtdhevAWTRhewRnbAKdEpCkg66gTjEVeTuQddeLnGxzxr510i/24wiTGHxTQldyMPusQuWszNrrasfK4R18vGEDvvimI8u6FHYFOdofHRItrf1wU8BjfVT5juGAiDVM17ZPdqRfnRI7JKw3v4cLgnR/T4ku8EYYXe3Z7rI4No2BbLjv/i4N+J7GMHvTXtPzXXQYNNq7O/nQVr7Cv/C+QrDBKWqmK3qD+chJBR/T9a31ygVwJHaFbZG/aNzMQP4Sdp2kltzovUBe/WSKbBATqah/tjda6gBPuWUy7u/NLdKYlHmMfraNNQs2+zNek+hbExX2gIdVCwY+s2zVTezp/e8VY80JDwKM9fBA4b6d4nYjYOAcFA8nWgeDrfa+Pg29msNgaQxbqDvcCbpuj7DfFp8fLX74FujOb/WHVEeP2A+ay9EyP5HttwVhDokIbI5nOrX6B+PYSwKvJccllaVSXHnMgyguLHn1kaR/X9h59NAPhgTJXJ0FR7I/UxNR1irTRgPq4dK/e8uINOZAw1/H1uUccQDNEisJXV+nSLeWjKxgemdxm90qp3IwOijeUsbnaBe9FDoIEjHLc/bgvun+COKbqx8dMSmEK/5wfP5vy9NyKQKdy5mAEP6VRkczBHN52plWRxGpQjgTwOs+IMHWuCqkWFC2aEXDJhFZeB001cwkGhDAs0/SlcHpXuy4rKkrF1zUZjSG3Bdc+8+fX871HCOY90hD0sdYX6D8abxK5tHwUXdIEtPFwZJtDZ1eY+33mIQpY41FB3iCl/Apb1WqiM+6YZ3hkjFpDWsTemc9vrhZ3ab55S9hSctJJEnZufOpZBXh0KGTY7fB4Ks/wgy62pjfnL6wipqAaLKwEBoHSJK79IU1xukdQvuZHT4S0tF7AVPoytzEo60UJc/mJ5/lNX1KYz7Mam2qPwvp52Ckwr8VDugy1AFCAhYdoKDvuItlJqw0VaUlVU6oRgyxEPxHKlYM3ZW6O4dcX+418VNIQE5TSph+bKkkDbNzZA3E0JoGWsQtgOIOJFnb4kWRqeiR2MehASxea/OGM2lROROrZbjMABPs9SuKyVZ8hO2+lZ2BizRbOufWIJKnOvt7fSnN6vW+QT/1SalEsd9IPlfK4IiXUH8VO5/ZF4UO5FLct/zwki3+AR0JeNoYUAaCaE0vHjS0XYGsD01UahtRkqi2tQOafOwZAJbQ1SgDsES4/OBJkkmmPe3uR4kGpeT8nlLzwHiyPHu7Z+xbB5qf2JOJkKQ5CWeCZHjYQaALfByRTCXjYnf6SumoHddEa3lI3pXYEvRFaFyk7MeQp0cnCtmCzk6/Y9XvmN+RGAc0D9W/yrpueBpd8ZREj+/DMLHZfsyGhU4e/YCbb6hGLmsksKaVgb90ROVKmgnQoasPyS2iNR3g6/QBOmKJYkLXuHT1qsBTqIXkFwCs/WBDRUWBCHrMkymaGOW866JeZT2EWAod5W88wP1tlOuyDOU2h9x8x55TK9azPyEypCPxLRhcgD4YtdQGoBdi1SunofD3pDNZUbEH2Rq5WceB2m03hJF7Xw955RLRCNzQyEpZSaZBTrpXdh/gVdScIhSgF2/HjoZV5j9Hl5VZ5aO8akRxviivSidZRPF/E8y0wI0SgCj4iGUBBA9krRxSE3cue0t4j+uHN+xG35dJfM5madvafR9wOycjYnfyWCfbOlK7GV73C7UzH+3UL8c8ouE8e06ETxf541rM61/MsGrMcAf6D7AAkBXAP2iQOqx+lPEROqhP49IhjZL5tqhPJfvBJRt/43h/oZIUAwF7Kyjy4DCJ6vBrDPVSHqlp6aq229ZTx6JdH9/MWcgAHpZBvldq7GlhIhSHYfHfU/YQt6ryqZB8REmbm0M5Y95Lwbya3BpCIuYWnTlYIvt02YRmvjy6pKBG0kOJ9qW98DVlhlq1z7evDdmsNKprBFgTixRJvY7LcGe/l8PR75mGcyjrkZO1Cr4EvYrQ8AVm+OO+wQfbIEkcjQ7dxHRBW7YrgTXlmmIU2WLi3/Y7Z8FDuIr/YJz0N525OpAi6MG9s/t1NP5cGjzAmHTW6QTHqNoWfuZuFvSdeKwIU+ZUtIogI2qKO/2+pnutaD4DYW2M4zZUtxTCQT51Us3OU+tItq70jSrHkd4wytzQn0tV7/eqVYYFj0P7ZYXIBZDVGiyU44Dv0E69soruxKKfYx2v4wIsaFJquNBPyViyg5Sjea4LS99bEpplWb6XsHGWiCNkuh3hz1K17S65sexY/+iM7FanROIih8r+N8tw+WAEhKdex7YqWmQW3gY9+XwtgWi0ZpNo5EfwbJqUGRWMMWSnMeHXhyqjUMn35xwaYu/btDuMqSZjj90Zj6VJtm8WIsUHnA3GM+w20HQE8s/IOmvz6ijZnk2k7oxFyn356Bm7Rkzssa4gtqGHn1pLsXGrOhJjbvElZoA6Qu9Zk9OhgB+e5t7ErK2rDH4P7fX0DJvWskVSnnnQEXsdRm75fOPUfzmNo5NEg8/OK6nIY2q2Mb6IJVA3l8WyDE9p9yUKsM+D4zoreXZWjcEBrR4J205IMUfAu5wwjy5nYldqeZzMkH4mjZAP7ZciZhuOdVBTAywNrCpeaDlsN9zKs5KuKgKNVYBvqEMfwXOlXfHm61bvvehRhwqpAiTjdVuzMpcdYlfIsYrKTbyHW/F8s5JASQ+hiLMjfe5g+tzuILf3XclOdyG+XYFnan3Iq+4miX2BSqKy4JMaH3R2IU8ayol4LQ3KOuUMK+Xsbh+/xIGqfqukUdTnYbjJQYrC2qAS2DACLfURF13IeXhqC8yTNmDY7ttv7H0XG1eLJHLTX/+FZc+u+Uj75HoQUEDv3EK8qjpVaQ7PBMAe/EO0CpEo/+ZKjkcPtIFVHNb8rU8K0b7vX+IxyZIw3Bdp2tMn+vcYUKAwCJz1YG39CMn75hd+BuUPyxh9VLJD0VSLdXek7h0kAtX94FOpAqOtaUcJhZxnJVmvGSjYQIElCBeL30KpEv7qGHLBu+oRzGQK/PyYWs7UqCjoY7lulW+SuVw7eZauqvRRDEfWShWVv1EJ0qqVqDusneYCi9bHFYjlwpVDUvZwUKPDyuMdGry/pjbiOiTqbTrrVXHqtJP3t8EMmQUnWh1ma4PnJy6LuCqltOPSrqDYcHezZeAp/+FjNez0jy785pBYWJGHWV3O16UZmEh41Z3ET/kQUhleJNbidGxUmHR7KW1fem60DMe8vNH78G6BVi+IzhpzQ7hAKsG4GwxdWkSUrVwmffKKNPDuWP/VyD2PKAhd2DLsR2q28sNBLFamBYBmlmWK9Moy4yvyVEXSoDCmXDjDfxevi2lLJsuDQPRt6JZjTHQdQGxnJCGEqo5P6p5QqC7ucShWHmNHFjAWlfCp88L7wRbbVmSD1cjLjGEeTM/LoEnjzAJ8M6FKyXWJTFGaK7M1R1WGMO9M5wd1KaJ6dfhmgXS49+AlTRDNmNN1VLxUNqQJWl/Wwpdujidv0z1Pon1HvDYlCZVI6FO3ntDsIXaafUbPHswDybGHNVIEuW75v3dTGpZd+8sANiX8Q02Jn3UpynNywA+H09Nh0iyfRK3WWjD25vzby//Lt1l3mtwucE4qhPHkTfSjJXtXY6LHkM++MY2Iwumkh85Dj4MgruZO4ZjthhReV2e0ZKRc9aIDAQb3tOAVjAUSuK+gwCF6YSgvpSBX0kWadZTdFKE1rjm4FeFrxoK0y73PpjkZok1gUvpk3v8A9J8GMFrfpZAPlNKAyntajjC5zBz6/vC4gE7z93cFEM3nCSQGPsTqGCuUKzC3vOdh7oVbk1TWyksTSzDoerjkb9KpK+yQlDux0tlarCDyAe9FtCVYK/e8033wlSeXXwNrE/6IVNAtBxa8/lNdytTILBem3bLuXrc21RCbmkIyMBQeuazPL8rW3quTM4/cXXKpT5Sfq6VoXvMGD9xU1AF78Lqh3Rf6ueG82uqy4H8Fhw9M1NG6tKnj568oXvp6NJ5fJ8/4RxtYde6bp4PMa9c+WTfMt9+HhuezHPEDi6Nd4fXQO+DpYwtQ/++yOO5xTZth2x3aHFdBsXxCvOI8TIBMlA7yCO78sDrHs5soIHuTDijOtDMFrvJ5PgM42xnTokmzOCQiqSiVJFny3F/nGblTEs3KftbILCJvWVLhkfbPd5W5CIAqgoDKqBDeIYmBcEUGu5AInFomicqMll7Xd4bb1GJNC6T/UJibU9PjrT8MaupVeu3Qk8XnGnu27RbIcbUT5B5cHgFHLuhZ5Qdsi2aI2QsE/Grw/Grs2KUi/uuxScBz4A4PR3sW12LEtEo02ahinAflIQApJ98gtj2vjbabQJ5D5eBUn8ywUXDAHAWkGNa8zus/9UTR2miF1/vxWb+pheKP9HlYHdtleBAEQNvljHvL5tqqr3zNdfaxPV6nqDoHdEC71pgNJMFdoh7fLe2qr0vTDwfQ7pUf1O+1kByXg3xnUNms85dLysbfZhVl8tF58Z1Hokk2EfUbaQRFmcnz6d7ZIqhG5ixFR+QO0KAwbQuKIVbowVTVBLPfzLRnWXhT9X2MgHhID/GxMpyuRjGz7eI1+5ICgQ3UwHAlNc3SXVXpGpXvIViEtxhlceukJfD8WY5uPVH9fJnkrV9+Zptto3MmMKPQBMJp1bY6uEURB5hkvsjtfFp9hlZqBSDxzfS/N2pYAfLntz8BGJCd0WAVZ7nxwpBwc5h5A4cSljiRzqcVwouU/nRu35LUJMWyD8yfFWRE8DrDcBmE5MqQvcXmF1NyYp408Ipq0URKfB7hnNubFyfgQdogrSVYl21Wksle1XjKgi4wzBOVIY0zZ+pKxEU+iGVZvkB8ufiqkdq9qgumOKMUm2a77pErKXSXEYMdcagSpCtd8L+chZH8YNUswbIsIcRywRvSmXiZVC+aJv87JSFF2pl5sHV6DrC5sOP0yp1pSAZQGzw2EQEgmx8vmDXgRgGFBQJTPyc8DEqm5NXDL+denfNOmDxqzUUs5eeJlQnw+xopyZx2j85RWyy8q3Sp3tACtSJus4qNhSFrKlMf994/ofSOYzqLU3hwmZCWeoQcpa6ixkWEGrm3YR+Ej9+vl/slptDdjPqd1m200rXRNEdbLjgMFl6+B0/kl9HkjVIkZWWPyI2LnNIDctrdMQ29rgrBTpYyYPSQbETztGj08cFzs2zyYabUBekFx8JdWcpQ0H+InjlW5VodosVptASvtR5sRu1vLHtLzFG17GtdIIY+3/Hu3JVXvBsT0XfGDKuY776BsSN2qfJDpF9V0DH4zyt1tfm/yacQgvR4lvhp1DpIm9FJdQ10dHo6EfHWdGPC8IND0BMKhYhBbEAGZX3cmO9DpIVvaK7S9JpmoyF69A+GiO+JrnKsWjJ8s1fuyWGXJbpNm82qx04kg6DPXOG5DUd4Sxn+bsMSk0HEXsUguRWBkmwAM7/8H64l/SJCMMcTjBKO6tNtr9q6yhOsOWaVJHHWh7xLCzWGIg5EWFLSX1FvnuYAuwyjzPUMm3OaXWoN0Pd9CBrHN3MJ+45Ms2jYGN6ct8WjcUWctBES5URaOpkJtzG1CnjC/5QQ9/Fnw1Z5fA7oqFKv4M9dEwCVCkDNzkTDDOPaVcMZszILd9603nSfhpxLhA6hXSxO4KQhpxBYbA5TKf3YEMuK5JFPgCRDrq7Zh3Q/f0Ppp/x+I+DlgNbRP4FureI3WS/xheOANIX3W7L1A5VN4TtBiP5q2jFIAiyO8/4y8NubKlTZmdymgHhKvw7chlrejfLe5Mk2jyoHhA59WKwsgF4qd5w1glRHtv5Mke2jVTRt536ObDq/IxhigWaQPOb52gkqUEBjAbyELHWLjbBIU67tVwdxCmHskRXfbvGoD3dHGWa+UpIp2VboWMnCUQ+HmiSMs3d4pb9DcEDUxDdfAlkRc26bx37hjrEju4oGCe37wzx5qwOnXBYstqkbrx55frpJkSGvZPCRwTcx3LIqPmLZSTkRF7zScm1gNegjkB7mS8JTZkuDLqCueKY6BNX3wzyWDz/wc5xdTBHRApjbh55annycJS+njSQHJYP0GkGaAKdyDt4OFOAe82Yw0Y00evzQAQrcNDyVSoXvsWkUAWJ4my8CvVoNVQaOa6Q6E/3YiOanJ8v0BzRoivdRC5UqG9892DM8/FPaBxEAH1lNVqOjmDx2QPXeOfzMJNeZ/TLsEmiueGvlrO0Ny0y3pSChEPj/NkgiNhrkJuWAOaTk6SJZnrxe6ZF7YzHyNvCIdNqszpJdDC01kP3vnqrru8dAfXzjSuqT4VXzWfiUIthV8Iomect6yjxpvTTY3AlG5nsgkTmbMIVIXppBaLmQ4oFBVGXZPBhcBU6+XYnWnf7jroFkalEncoYVEvHeWe9BnI1u9AQSImkjv9wBBpQ4klE1fFK29T7YIE6Fr9PYGn+YpsydYa5h1ZZHbi49HOeteNzf4/IKTj9afgPPx7N7lJFFYCaHdtU2VB0YhB8mMEOK4sTCtYtoArVYEZCyZMOIan1a4joZJhkMZgPzhvogwKasZqvqVxwJlIWubI62mETFjHChXi0dPkUYhTN4augahVDv2h/XD2EwO8usxRqeXm8G3TEg6IWcqUt76gTT2T8oI5aniXuAADnbVRRrT7mX1PCGyjhhLUrNltLr7wYueycQei3kQn8duG/o6J1OQfq9Kwyhlu6PDFxpHN0kuJNj8ttWe/4FvwCUeusy/hSPHuEhIx0XDAjyT4vUHf+CzywVBHBqceoH5bULOi6CNv+avG2u0v7g9cmkMxwZWlbGsBBLS2znnJ8ZM399nyo4rVVDmJlj7aNAwLvN9kG7Ftl5y20satmTE5J0VaIkQv9259dO0KsklPYG+Dvc/OTENPUkxZiFZrsu1Y1EqXZno4E+Ki13UeKbQdQDpPHRMmL8VZ4r2GhzlTOgwZpi8hJO3cpSDMe+AnuSzQXaKN7CPvIqeWSNLqO2MwfrVRcytxj3rZ7NBhBdhkUAcZHeCIQyxtZOpxM7IJXXFBiXe0wiFeqd1sHoT2thu8UlHJrJjEiLBBtZ7AwYqEViTlFSmydybabq4EI1c2uT+TD+ig0kIcjW5hMNjDWG6e7OYG29klETdtz8zvBscjxi0nOfC2RziOeGpwseVCKlZ1zp8iqlo5Yhj8IcZWmFR3LqG1YqLrUXB5Gok6dWouP09NYoncVJ/gmw6RD5UTZSze7o7YJnLFzoV04FYGYtFbsLlTnV6kjBuO13OHueZJD2woxgAea/+OfkBpfnjEaBD4EHOrUwl8vJkIK9pGvaxnMYo5eJfFzanZyZPtmWMYmqj16vo60EwMDE1s37MDYj0eJ+7FSEkVpuXUnEFWwWUCwN8t5AzQeG9lqIWKid+D8LN54m8NYqmmikGUTYjEh9eqtCy4/qjHBgQ71IbAA+jPT0uFIvZZl7OZSt4YuEm1cWCMTmMaehN+437kQK5KOOGnPTPh+IbGrBPm/EGDyVucsum1TK0qKznYL3pQgP2wdtn/KngT/7cl3bgRYYzGC+rZu0TS1qDwyb4t06MZIOBbhUuDywm/KcrCqR+wHJ/soGHPQiIpPsaAm/4guAu8GNqpM4As4CrmpEVx8t8Bkc0Y/hfoH898S3KagGQd/uyUk/Ig9sDXUxUXit6SufBmCQ92E9HzuKzBqvKxXs7J9fz94IsJ+JJil+UBCYxAL7+cWhK2hTZfBAVntAnoLIlcasvSw4mvLNtfpRVjgRY1UvLWK0tukjCQ+BM9BnY1F/Hby83/LLFJklpb2aSnyeCLBpIdMszVjWO1LdN9WlaLwYDAS9207zMN66EueAkfCFwdBXs+3LzjcCJ30Hl+dcgACWFdyyGiMEBmY55xPgKYJcBVDHt0sqoztIyqR+3BL88SR8zb5tVbToemArDoDGITja8MfTcmZ+vRkb9evfbmjnTS3cXtf4wDF+D0xOIco0ocwnRgz/0Jpb2cfO5SdpxAcusTcJu9eCHCc3kBa1kp+IX1EE5iQyiXrZ0gRjfIUesHRq2FcU1GC2UlRMGBlSR0ZxbWn+/v8nWR0iVpXEGjUAtSeql6rD1dSw14F81w3oCqyZdgZEraE5VKUKc590URcFaGzWo6B3xS4SgxtB4jpWXp1CWIs+U8QWcPgMQG/RR3aJgoa+Lo2JiOls3MY5PdGpwmxOXMLhDGeudooMP5mVCXbrTyfZ9aAczRsv5dk6qaM8zZ/cFdTEh50EKHbT7FpLCDcw9gBfncFklS7FRxpYHIm6dGbvGyUPIPdXwS3NWODjZf0eMYpcfnZpP9nM3XDasFjWTX8aKhpqD44W95QUtD6VG38h6t1Q2Y2adHz2ol9yshgrZCUfnoBBIEB7nV5eNzbuitKXJIYPigFOtQnFi3D5uzSbM1/vQWuW/DkCm3qz/pTYr69/TtkGQKCWZRO+rn9P6GMynHqm4wJfS48WUl2lhybjkN5baU0JR/Zg5Kq4DVDSTwROksRClo6Qmy3FtoydVmJe9tlv/NI3mpKrUlUTMxg6hEjos7+crNTVcAjLqP9dmxFEDkSXoC5qFYV588bk0zmbX0ou04RwodBbedxZ0niV/sgDHw2/k/peGuE4fE4xJa40fFrZkZt0wY2+AAyYAhocyFXQI6KN6qWEwT0KXJWjlD4+S34MkIdvhZvoFVM6SzGJt+weO0ETu/BqEdaHpADIE9oj81XMpkwY+IR5LwgRi+J5OuqdDYubChyb3fJX39vEoWwyFoTe1hzCl8xG3auSveBYfeGklIjRmohWq4A32/CMZEAUnAT0ZYLMVNH/rbBDl6KAnZhMksgzyAAlcLRRTIOyXsphx3mVMX2D0U2Use7VShCx3haAAr9N4S/AJurTJf13x5I5anl3Fui7nNihKqXLzq+Qmv0vvYq9Rsk0IXZapwP6EK2WYzDBuK8ftSsYy4OYo0SbaoOfCEdnMMoSR6ZzouAC0MJiiH2a6AU53Pi3jXozSLPVYijl2GwkG9Sz8sGJgfObqxx+O8QRPPsUnpWExqzxDsaF36TK+jCmpki1kklN1VWi6k7La+gPPVDxJawXfAicvr9x3mPu8t1yfztHf7mZ9sOJle04Ijq4LlYKIXg7EgKPTvXBj7CxSfidqxrMjrSlqT2WAVNkQWeyqhI5vRAiRH0dpQYlbmzgF5/gSS2tRKYaD3KFNhhihNgVwA7v73HSfDxJ5LA3YHp/yP3fnI/WJL9ljm3MVJycQRtU2V67Qt7/VjdPBmZvtMatHCtbc4jyEP0yclEGyJQWo+WUZe1/Al99uStc1l9MdFZ/jt1UKm3P3+IIryUgcsutIzghUekhP875FM6pORpxL9qPda9udX0yTS/AbN23v3dvBO/K/F+g4dwUWUKnReYzc3frhgiS1mqr51eTSvb3tn3UPBa8TMGiTDndzpeRKdBWd5QOWS67bkZye16ZXldCXdoVF5C6Tzr92N2a3Nr8+MO2YuCbOamGcLwYrx3IGyLdUF3wO2VZYXbgETp4TcQYzpEW/blbE+hmxlVwLeS/XDrdUQjuzFW52laWJDOLnE1kf6RVMMUkXomXtNrnuUakiA0NyHrvqC+EwM/PIGJdLSu6oDz2FFLMXRpOQ4PhrKbPb/DFo5JwGPE5x9192EyOS5W6Fdmr4wnUQf+HpELoTFd/TQYz7V3xsXTiWOATBY04kAdK3XIMtMofjec8F4rt3c5QK+MzrI0iC9rnOI+DPquOp0VMFlbnKmWOzWTvfbNu366JSyCnyE0+yDDFG1glOlULN3enA1oE+4CmJ19rdRnlI+OqGb2UUsoHHsOGUVUWHAPvKieFlUO5OYTzpLr6lqdYCYLNHe3+gQmQwXb+ixFP/Qkl9K4M+XQ4pZD5izth8Qh+OyX0lRVHBIfLq7B7Ekn9WrormSxEq07NhuecVqeY3ccvaSg1lMrKB6FbrtnXLL/RNq6qSpTgAgRTPa+HIDNJ1Ih9e59VWzZRBJ1DkXkwSl7cNhau2iaZ10OR+1DKlfoIbbx5o5AIpvS8ocL4H0DA2D0iW7VMT7MpJCGqqnxbt34Vp8a873LyOA8jVt6lYOHjqB4l8I0Z5Rh2ltPFT5cBAloRJbeTvgd0vwP/Y8SBXPVVP0APtFEzIqzOnWjT6/kkT/3DZYaawahi1K8CnVg3l8c01HXH81bm53X3TOBABlIUgk8mpPazl0b7Xl6kT5IOJIeYgKE5t1bmH5YWeaBV/cQI/17fx3lLqZAgi8Ayyy7o51KR6MpmSxKJknT5P09/sV+aq3a9rdaskVzyn/9Z85CEmrEmUxqVNo1BjbGY2lFAZ046gGj5XhaUFwoxP7GHwl4uON9Ld0yz1+oZ7gdlaw3G0hDuwzyqWOHbIYkxj15j1zc4tGEfk85P4wJr58zLaDKrrPp+zMgSl3x/KzuXjsPt0tQOY20MiWOHTX1G8sDS0rBz5nzWEYp8Lzin87D5HIU+oTnv84d3gIQb0B5ens2w+jElieNIN1hGGqAW1X3FWa4PsDLF8s9v/AeV1g6InIPa5rC8sGfOXSNFLpXsNTGagbS4Sk91E5IocPdwQ/6Eytf+IynmLmfJg7NQJp+oqhPLd0SHkzux/EmvqdrneLEFU9ZYz3yvFqT5rGs4XZAMTVxqJ+6gbleOt21OfqsmpRWplpYoTCIljhtwnrjcC/jH6H8plv3K3PcTgc4mORHMhyvzM4VJj9xBQyfJkpFCj/9qg/aOoEAN5fLNIHLe94ebcOAj3zCJp0SCGq4b9DEy1wo/TWox/9Mp4w/FXF/4nKGvh9l+rc7+qAMLjLVjVWa06pmBkQ/edVyEuVTn/e/FQ0R0LqDSWs9CZIobToHLkJ005ANeh6iXv7dYIMdoLrLOjawqvddUab5irF33CSXgb1J2To6R4BKLTaTad/sMreqb71gG0smZmRMk9mFYbmO54UZv8KC3BtRme5qUnpwwGYnkO37SpibHRTNzoxsM5mM2d0XD9M+7UkSWRU4T0xoZoNU02i2YlHbupeJ/rjhHKGXmeSts+eCrfkNSNONwm2d/ir43gRE08UUfQWMmx4kLl+Vt5Lf0Rgb8P1xD3PLkpk5XNJSEJ5UWTZqgcIQ94/fBN+QXB3faAIPU+XVUZq5kdUjWXKe1plqoFKgw7IHS+MQVLROjDUrjyU5kNLKKsLsWgzubU9QoCYH3zqATuEJr//tpk8XG1zzOKffX+gx2MLUABeDHSSxa7VF0vBMdg+I+yeZoxA3Semv8JIdUlxnYoyt0XT/qE2hBfADoqPg4tXs3a0MdiEvW/DedE/Af/h1bqwyjN2sce6pwW1I3jtilCRs/fhZTZMERLFy/kTsplTiC/2U4VxpkrBbYMQESePgRe9v27eIamfnjdPAxQYOxo3zL/fNJWs3qMr6YY8cA+6EHRAVtp5wGXg9ElKd6mbp0bVBQIBSfSBAhSdhR1fQMq8axeH+s3crO4rswa8ODOvFJo8K4cB0a7d5juTQ4CNqoRadWHdG+oNicA+mAwaMjMK461xjGhO7Qo6r8WLzqzKJCFFuVAgbf3OQIp8ETDsVmSUJ1883UcvWWsDS62JfH13+yLS8hSTj2ZOoy8CoHFDkfeMcXIHvaaxAY95HFIzwG9GD31fw363aXJMBVQq/hSEg6HEBWaWOlgpF/ABUGfUqnU68rfykriwM5Jcg6kkJ5dOAwZtt8QZFSM3MjbAXlD2tlTacnmIqDLucb+B2QLaK6Gmxy1m0hy0nggaBX5+fPoEUkTj9KqSnCuXXxMiJGmVuUZXl2Xutc7MWZy+NUa7JHUBS7lYdzZq7RxIap9/zPDIgwp4WhUr+JZvXNurDOj5UzCp0ITgWes8oEnu9ed+pK+vEPYt231ZF+mhLeleBCYUf8nOsQFwy6TMboAGmgSulZLlsZXDn17OylnPBmzyPvcUX6Zl+VgpH+7N6dYYgT/qaCtnLVFo+p5bE6WpP+5wM2TpbFZ4zcKMF1q/YVd85EdU6IG5L3aOW6Pdc0+XhGkKdBs+JIjXC0LNX832fhheFkm1mlhcz4qRvTvFNgMHt/S6SuQq89/mAJFu/HvBQGsQPeWktDW8NWx55BS7xvOisyLLc4Nou4oZh2wOOpJz/sJzi+LP8Q+JwI/tYnbq7cXDjkf3QzD4sw5n9GZ3Zu37VUrSzykwqiJu+eoXIGhtvQtpMU+yvBudJuQ2ipq/D57q6qCnFvdYGpsAdPvdPEC8rd2xqVcV6QJHFhm+KB581nMo/ucVtCtumfHhGSe8QNOLyKK+vUo2LEuqozM7aw+7qkffPbsS+osrUoTHMoxw1gGGdrzHufaZSLup4AkmHTAl81vWJzH02P6qXYZEKHNqBNEE9FjvneIomN562zGvOE8idAj9pzw4Cy8q51NqtY7mRGzjI4ZVaiXR8mCxlW3Jf6mi5n8drlgh7Xbq1o8aocLkp9yYgqgR895sKo9c3gUq94OEpEsUvUoZmlbNjWzP7Z/2jxn+kbyngdXpPcf0q3Vsi4Shasg/Prs0g4LKwLBwo3YQP3FGUYZI1Vg/cLDusLoTHD1Lvf27U5yb6zU8ECbvz+5TOLjcL5l5YpkBXcdfMtaT76iwCp4dChhl5ojoMHpggW7ZiPlCDvpGmuBHGL6GAVul7YEILZZ+xxWeBXu85uPkBlmF466kJQimtaCJdidKOmofK2XXSyAB8sGK0f2rboBrIBi8VIydNZl/+eBK5FFrspDeJJ3WnslnudmRCWShN2OI3FuersUAPY5pHKh0KYsQe5735HMuj0GiJKhNJhNnxS3NYqiZSXPBCP12vipSq3BUSsa3qMAP6DjJzfOpEf2uSmmCSz4j5ZDbGPAbhgETPnMIuj1PeYMuXWSkkHYfzmrd5T4tuXrescHPohOkMjcMyxNnCwOmKQbDmkg5ztmDRUs46xHx6QMoqcWXWbZ9a2GNAta/4ctrfzeB0vw+np/gbGEDD3sFEVN3m4qgd4XnIZH003k4Ix9iFCORol/y52PTc7HWR2BiBI8docLD2cpQjn7aZWWVzd8dNskd1og92g75y0hclosMTPQLn9JrdX8XdDPL/qUb6qRmSdq9HQ8kTvQSufP4k8Hnfuy+L5aiyc+sujIw8241XeiiqZlicQsokH4HZjEmufqTCvUSeslUAvd2HGc4Uj1B5tb4ea1f6LeyQANfvAf4CQ3uw1ZpN60BioAameEBbTX67FxQnXNh0oiwN0Kbvq0U472yW+EA709VOYsfefhehUCGT9GScXKiMp7HpNyUasMUIRX6LPKRmVx13eyO3DIckoG+LmQIdcgRd9GLi5AGsc2orMaB0Boruxn3o5IfwKnBlz9ogoxQpm72HOZQQtwo+2oNCErTOcKkLIKpwaeuNfwgRJ7A/5sWdgF87KlP/P+6gaWSdmrBhGnIlRdffcw/EnJA+Yp82HYUc3n40k+3FfzjaLoqRbXolC3sLF3BDi56kCh+QmpmjYa7kX19goKwK7Zkt3QJdR02fJfpfFfOKY9LtdN+B9/+m/H0w9vamjni1IqeKqP+V4QKRJ9FQZ6DaeHbtLAT+NMstArnBaTb+LKY+Bra+FHFZ6DNt9cLcZI5uPTTrMeBaLOYpBWIKw3mNSZ3FHr2RhytrwL/bOErH5I7ozKzGglSaDpjJ9G6BQmEFbxAd6zKgmpVhFo4u70vVqc9ST4h/vHGwEWjfLdNgRW3Uhv/jIjg4PMLVW6uBCN8P6pOhMd0hr3XjpmDIWOlCv1v6in6YzyqNfd4DmZDQETSD/RVNGbBxHB7EuotFiH6Iiv0PuPAXUO2Rzc3pqN+5LJl1sopfNNTcwYd+IBoGtJ+AAAnbLEU2WsbpOYgq3wKpYwzBcriDtfJT3c0vOYv6s55UTXQSQgk78HG9V4HOjS6qQAweH5kc5z2cv9b9NVSXrL0ej7S1SsJgJ6OAoTYFn0Aer6uU3JI3aLrPDL8zm47Vfj5hex1jravPhKvHHPRQaNTPs37cG5UXPLp5kfOgixVa9slqCWiD+CcxGiJYwKdh/Vt+OGlkgM8ho93qznC0xazSZDHLHUVFcYu68dEC0b5EtW4stC1Ym95zfDqkDksvMWz9XaMWKrbw+3pEFjovdE46zjeTlVdqgXnc8/j5O68OyRQKEz9VN6J+kT34hhAUY/fTl0o7pTT7GrvcKhsZMga4KKVq3wVAg2Mal8up0ghz4y7Nqm7UXyxkfFjCeCtJqANmCzXK7bNziO3g8lMeOHTUknv9x7cb578qoGbrp02Z+5Sg3WTcI6xbacyB9vknZ+PURy1qlsniQAr+0H3pIFuHpEizoI1O8XIVeKH33aOQ6Q2ON6iuYA14zqkNA/3WmNQvjpuS9E7gdx2yFA9Pv3A8cJMZkRLHwJINOFAlGpmR8FKWewbBLFkvlvahE+wXQWdmGUAH8PF+cWYuxCU15hlpVe71KPohwn4fR4mE9vck4fLYKaSqp57HupEiqjM32jcv7Y4/ReaH5arCuvJp1B8Fa/o8c4izZz6XF68x9stvBxKc/JiPR/voBL7o1t9paJfrA2mpHTtAa0NpjPoX0we6mfAWRNaa12+ZMaiXz+LL7Dxkb4rhciAY7OFZCSZ7uqBIx0EvxUjyxUSSHXA9vTs+E09OdNVaoSDcjXkznPWIrbKc3DiYU3m7Bv9qHnLc+zp+1DDgwKwtWV2takg5ojvhEFaFHyxczBDYetLQHRuwf9iDABD+FiEo5ygU9OVGBtsoNN5IUH10nt2xWuCDEcEvzadHOl0CGYVnZ7kZQneUEzi1tJDIsmDY+5FLqJGtsHZPWBkkpDdQkqSUMHWgsSFvGDO25V++xcxLadNn81fIEewHzHpo3fRxNNrDtjvw6z7pvvnyxDnGjbjJlZne9HJtKBau23Z/zZvzkf6yN9qFTcBrJbG5UN6eay4mPRtC0dB5IZiexJ0uQ05Kh+q4Ef3DFtM9Q4LFLoJtfddUJMFUpU+yxz7XE2vhvhGr0mzA+PFv/lyTSHh8CZH3W3o/DyKGitQ0pJrry1/lBcV0SvmBbc3IdjM20LCXtf8S7RTPEKhiWQoDYWlYIrejbOUBP5IkJ6SMdUTtivoNB5l7SuNSAYNtJz6Uil0R8dC3ULgq6MYYXxhDK/VNjA7scxmkLeCYEUd9CSTQRBIdc2gxRczHOEEcqMPMLT/HiLCGhCvLNSm7MUB3vf5A/jm+bE/c/LFvzvsGXO8CgR1tGoKNRaTievwL1Dw42HtGecJuWeS5ssOocRK8kCc4Ut6auVwAPfbyJXzePnFOtHWp9MOKdIsck13WbJ9qeOKuicIUZNrIdlKS19K5+WL9CFxyr10wi7xzuzsG9x6vIM1VJtwld9aO7DniPVJVtzpD7n9JbCDE6iVSGS4OYTLBR8Y0m/RJfrg+QZ1NNJX/LecS6+5PIwRxGSAkJ+xwXQ+a88fH3fYBeNUqOc68b+g564NEBKCZ/2m7frCK+epJJctTOQkDLy8iBfxqtawOnQwGxvTalX6GawOGwRwZgtWqqNmW9tmTtn3wD/2afSE6gcxHs1dEdgSMwnqUwHUJ/NOs1WNphG9uH8Qd4toh+cb0LrJL0XdMeJbumurmMsIHpklr4hvJspOZkTMsQNC+BIhArxFrF0fmAItbAizCU6p6ssAvHcZJlCYYuFV52yS/ZzDx5TRnmwirm+6q4i2VOh3xkI0s/zEQEKzuePh7OarjEtHE3KoVdVsSQZFPm5Fb1UcAgsmq9BODxmZrLys9fXVqDr4Djov9/ozGwbUWHVwq216sEne7DPMJBDfZqQrqP1Ni5HYMCx4Vgn1XwtP0OVG5p7l1KSbgP8dHR1Fn+IlRckWv20u3QNNy3cvMqqVewC8LLegQkqXJenzJ4M2SpoiWqOVD1SPN+JrOcGCIsYXabT0ciQdiRTXoADfCavhFVTYeVFcPY6bS3EY0AykPA2iWGglqoutOoyOLtLVSLg7RKw/4xCkzrMpYCNuqzHoMJ/yuAXVR4yxwV7nuIkSlxXUQ4zt+EFdFdlTi1oYAsu8jVvUlnSKETtGIx4pmyTmWvx609duaUA2yDjs5X6hJ5lHAK5+bp1+ydeV/eIFzEmiAEHLHRtcbvXmsvagTcrBZLJMPcjGhVQBpRAFw/+x6gG9fA1ZqMn1MXU/c9eZGzkcxQIu6zrFVc9rKQP8BC/YnRsHlCM7dEdbCwExf28+8hSxOJLkYBS++7oMTe87IaX3nnGmiLW1CxsAmpIZ+Dx5mySF89cSSqpCW9ScXDywh4/5DPJMCWEbFjKzdcA9qXQG+A/YsVcTT00vvxLhRR04CeH1rUPw9hVfDGC0cWDl/0Ns9adbGeO0le0kIMrQjT3YOkgVyEVGQ31II2RqrmCaZDWMoDarsCQtB4xqkchv+Xz/AWZv3QU5Ul9kpg1YnRbY/kD3VhAtFJ6p5Or+It4QgHvcm4rN8OmyHbSyGD99oRWjE3G6MiP2BF6IW38M7uEO80uAa+eJID97AtdIMo2Ch1T0h7lGcAX3eiNyb4NC/9h0e4gQfs3/pD3/6Iq2k1/MBTX5BSOLBd0W1045gc0DeLX1VogsRfvO7QlPS3yPEzhvJPbcn//BYTt0O4HsXUcecBczUUpFvKbo1HI4weicys8BQVuz164nQG9Sll3TKQHYeM9RFwLRhtatiJSi6Y3z1UJuR1VtyUq3NaPBE5y3FIEDmg345rJR0Dat4TQyLtO/XZAKmJwBSWEqi3W9EHqLiLW8K/udMwjgk6rBErabz6QW14T30utDkjz1hQkyaMIafN4F5UNCelT6KUwJJ3wjAPKz41CmJO4hoWJ4uu6sKAS9LWw25xuRgUPX12Ai4L4iEeQJN3QlgayCJ/XUTdPpzWSVSESrVF0zX6uR+5gGafY545+ctLw07Gs3DVN3zuIXoAiJjYsdjx+V2n94EEZrb94n0ZzMHZsF6IWEet7bk6G9czAsQNF6n72PrEd3W7LPB+8DaDWtMC5O3UgNFCASGCTtRla92oms+D5IHQeoTSwFM8Hi8rjVQ4xcIIKhkUlRYKlXLIk48bvGPK6FEK0WxIcEUdn/poCSqHqTMKL0TiydnOFQ513EdUi6WjmSqrBs3g+u/M8rGabln7Oj+TLjPKMHwzrNAKOhMa6rhuvURgUbIcsbJMZRtMPmDf37V2tsYSKnOFspnCflexUptYxvihO3o2Bm+MBGRn/FCpPVPJxMQZwDZtZ/kL9RQ9k/MVNGChZrq7C7HYJqfGN0xeC8qhFKz2Brst1ZxTAlwCSVFKDLLK7NtnWhzallETOYbyfDQNG52/W1TCn1MFFs/tKKaGJ9JXh3gMqNJhkpT3c6U6Wqne+P4ocwSBTj5DEUs679ampynWquPD+bKDd8bzXUxhdcOSNYNQOoTQ/WRVxKoi0zD0veR3hBeIHhALWV78jwvdlNVo/UqoY53uDOACiukSnOv3QCK4KS2PUHE6hXmaLw8oDVJYOCWph+o0RrLIzZzjMKnBcUFRkiHZ1R/DHzjA25NcPf201WUHNYRKk8vTEx/ybupGO+bUs+qq5tUdDfWHDYgaOyAW4bs4rcIZK4Ml2KdynCMK1LB6Ed3WTPSZg03WQzYjJ3RPLW2jKPVFjmabfWEWTUhIDP4hHnmeEd/J53unZ5Gqo6BR96KK/CApvN5OGYtauTRNAJ5MGOg0xX0MHkC/uNX0MeDb435QjK6e3e3Jy8EFoZfQaelNl7mWr7fIkN7Mr8lDwwL/G9ACRuDG24KqzyKZuawfJHiM5jKyW4CJn0mTIljGY31tKfJNSPq7+Was1QSWfNF9xs+gW9MTPc9HOBvxxqv86NCSvhXX5oi2J4fhJUnKpWG7ZIpthh13ezwkZcDjvhFaG44U0rnT8b9Lfs8FKnPInQq04kYHlGiVrMFkKXUm1bIwX5b1RSGK1eqIWk2wFMxRBd6SCjBOKSkuWCW3A0oSpsqOSw2gh3eeuWZmkBWhQE0ZxUmXKWkSDipJDaUL6cJzkZj1fGZihUfwTRNlUFp4I3uhWxTQkQQyfcUCY/EBmSo8K3yNe+0G2Z51VkYnyBxYn6Mvhi3YOE6mmDjCpGUmM80yowfO+ItewcF029jHa0JUEOUnMPFgv1g1fj5Bo82CoYhfh5OrSj1dTnhCop75RDfdVmOfhZizYqTWRMf6ONpOr5d0TlZgg3v25ekyi1093t81nyXXJbECtzpvvcRfbI9eFbJG1S+7Bn+RCnlJ665QWbKLzD0diFh4q7kC6dIAV7JdRCO19S+G69CGAD4eNE/z9ZZcQTOLM4BUuqcSNiLocrAbh2Fpxf1v7uv19E/08VrFmqIz+pe1Y/FO5vwKO4kVrr1KjsSfO3e1Yt3YarwNNZs5NkHbuY+lYArxSNXQZoZENaliGU33cww7ktZ/zF76aEj7APxAu8atYOTp/QGO/6no2VB9x3vXxHgn3xmpQ5e47nHGMCTIQiMlUNI3AUs6F31X4BPH0Mv9UswHeMHMxLsHc30i7AAiWiq2v7NbR8RgXvHiMOPKei8XNsiH/feJKA0Dg3f+g4mfw4vBwN6Df11vLOpcoTOayw4x9f/zkI/x4T2o0+kEG2qqke33T3BVrg1aCbz/+pa1+iY5ZS9CWTE+W1kAbVfsWXw7k8k7o7DTlCZAzU1Tf+kS0303pYeYq6ETUYQs23IywRtPoGJiKsE6nNIjG9oj1WcfV9HeAq39gvQdzM11xHI8Aj43Ulm35u4FR8aWWny7+QDhhp/0gP2VZfYYF2LV52JqGk8/m5ehjqgZCiwU9Ls5UUTahM3i8NrUFhx9DA43Y6Bfplu9GUSeQEIk4YeDCHZWWfyVn2XF36ednZ5zVZPqmToWsNqztSLRa8W52ZVEd5DA9xfHp/dThR1vAQMzWxJGWSQKqLvGdwFHqtH0sF+YXx5A/Oq/aq+wBm25IYUv17jE9cIYAafypRZoP/TPIs4jJLaW+VSEDVt1AO8/LMtNTwglQpWToMEgYRE3jgMSQC1NkUbEhU3cmczbhJGAgHXxtNC+cA9Oauxi8Q7QDhQh2J9Y9Fd/arfl6gO1I/+RA4P1+1AB0A9JrFTsuZbMFc9zwtCyrY/OBmvUKbedRINKQnwGM86U//ApcTFC5zfhxnir8b8NPnGMCyaqmxeBYCcZV5h32AcLXHsV+I6954OgN8m5ChXCoP9pRRH7bMnscSMN9aGOVW8l6Q5HWfp6V1lq7kZD8uLp24KSffiSe4FM51FEx9hT206hfCeCvQdVBbMlMYo8NaedoCr3aVDqFp7crA49aC1HLWATlwP5pVOft6vjmQg4lHi0uTlJWYW0MHZo0ctfw0qU1d7SQNzIl1GRf6r/7OeZ2/z1G0VuWIJIzji3TiWa0z/ru4Hbi5loIFuHB1ll5ohpNd+etZNnDi9cA/8ouV+Lb0/+FRTaOmmWNb8kUtnbFivQTQW1A2PzNpJ8H9FUOXBMcpI2br4WemmSc41FIkNh07wmk2KAs6N7YoeWDXtirpxL0N4NMnSKgFSKBwCCH9tpRJFaGprPJaReWg/tKaZ9vU/6U1roISzSrA1HFu4VCOJsTAjT7DmsAEgtbimFkO+ld5pq2wA1iw/QJwp1mfsEchR57CFHV/qnOxuzWK9ETI/vjH0NGEV7qtLW7MMMB7k4dYt/3HpaZC+yN06ynTqI89iXkTMB0EAsNuIsrgu8TVH/sboR0xbxWMnJrq3zyIKfgRkPN3wOUbi82d1y6IMWzBHRdS5DJyO15twX1lxqI8CgzUZHGq/2QUusvfZN64UMU5abKe51evTCVrqt/+stHE7qZaI++p5YGNwlYveSyIZ6Ih8Rm9cgKfFBliKsEKF2jjFLl6LWRhKVZX9oZQwWGGmsKV8XOXUNMLhNvEngUL4CXPIRO/rK4gg+CcoFNuFvKSQ8GP3xmVaLbGy7fDnF2fTBIAf6yKW2tcIwW8vAguHuc3R22X3KotDhFugFYbPJ0SWT6jHQE0IhPxp697+ircokRcF1LVBfuiKHHjR0Z7tOO/NS0a+wM12dZjc9kuA1pjR3WrnNLeoc2yMTnn6dmRPg399OJpz1tEs09er2bDAeMpZyk8LBXfXbcOAmGqw3RHfNqAzI8s728Wj90sjSaBbxFoW4XDwQUV/VQOZwBhY+1WOuUatrvBOwo+Y6PTRADJ1w2nAALziSgl1dvj0M/EKyi767CNs0Mse4MNdC+Ma+gFjpBo3JKaveyHhU1aY34pW6V1BO5hPSej2q9VTyrlvzvfYpYUwfqgMMoML4DK8lizocXjVoN02btNmzjyHRTBXotapP7PEO/T58Pm1lWpJnHN882+oeiXoV2w94og09BLFPoM35F+w9O0sllmRuEpkOF+NmlvI+AllaoT1FipEvxURR/CGj2aZ2d/CdO1tx5gKkyXr/U7n2+S4zWyINPuOWLv9UDEktpXtHTUx58xlDO2sjbRBo2+I1p01SCrwi2orvjLoquR7niZIVVfirhpWhIiWMoEh0ChPpTwhZsaNi033ls+DDmgWK+2M2mpxVmFzlSvXsVqh4xrDxxY10PrcCIO7ZbNTpjWdmsSr7H2QzISisEPZLyXIet7R7qgfWfeJebK0CvIuxj7vaOLskT/c3wbQQnPMl8Ru3fBcb2awvMGlLzkp/ZQQiDrc94U017Ylkx1dr8DN9iM4y/b5f0o1NwCaUI71yQDFpJv5fXlzaWe3CN6tI0D61+Jhd2AHERHw1bjG7GcWI+3M5znQ+jCrDuV0O2OE/tny/JM//8tJIODwouw6tUc2/eNghmDP0E9fJRAdd7cv2rtxKplK8TlyeUKdKe3zAgpd/pElSvTZIdCPgooVRRjDNt+UUovg1T7CQMoBixLz1CsB9ozGvaWAMOT5jXjiC5vS+4A1CL3hVsletvlsY0ua+UH56VqfrcY4XKLiDjbaO6WYUHqCoduJOMXieZ2mRQU+FzwzK3/zcko1TOZau3qqZ7B5XQ7eGwimcrgrJU8H0VbMoHitWhxk0Cocx4J9xwcf4cdwN3JMcQvvUuBvCrk6KTtMmpqMPNtUQ9+QtNjtZH18bvhcVLnu5r2k+IO6cNG187bm2m3tzF+keAUou9GEN6k2VhBDy2srdxNYRN2seeqQgOUE1FE9+79Eq7UlN9x1kfCV0PnDsQpGiB38KchpORJURvMRmFIAi5EVzWGMznATNjSbc6uP/RokRwmK2tkM+Nc88B/WS6uY5sRRBXd+rbKOCjzKTcOpF5iKYEY7oJekhv8fG5BD7/XlBE58x5uCMdDrjr0vBquhLMec1ZXWSYSkHW4qoLbph0/peh74VHFCULRDDNCD5CLP2BQwItAXF62NlRVBTT9K8EJilPC/GhIv55fu4wx2qmND7pW0z2lgBcY1V+B07K78l9bkDTvdHl5LBntwSZ8v/oLiTpuxoz1SPLOTlsg0XvtiKN8GPjSrLiMfuTlcC3da8ii/NhTKuWtgQBaFQuVXpPraOlFIUHaQ4cWn4SGU5pgDYlrSstuG+Fjbx/Yo/ILMequ01gH5HmfCEhtZRU7irjBRc3mlhSwPYhm6RZxnN4To8PvjyRACXAW8uDp5M7X+xFni7uk8axqphVhTzU2Z8l9dLqJmoEIMW6GJv8xxZT/4Uo8i7yPpdLBbMHswYc0Ed7LNQbXTY5eS8FSsBRBC7Q4KaaL50DBPRjeuox7VeAgWWdJARtOR6rcmmtI1hObAEi7z/FaTyJxbRx2Rb/oG9RrvXh/EygJY2w1TQbU4oVZBLrEqfwEMgZWLKUmeyAGFwXfPp7MJnF+hsl2KWP4PTDtU1+wewEWid+sY2xsbzsTYqvWcynWS1Ye+gz5+I2OZ30jnUsTBC8MjpBXDsCIjFba4GtdFXsZOqZ5duRlynn+khiKOJkLGcPuMtElBBG4RQnyaKX4+6ZoET1P7eSitbY2ptpm0TkXmKGox3sVgY9LDqVXdpTn26RaJh1np9jr5ir5DZaLDODaTVchvV6ltLsZDsuZ2gSquKPekoIykhJ/JKEXmAX3chPZbAhjQRXTJGxjn0sNEKWxXO7l7kC10X4WgvQdSWO9o3kmH7SZkrym8ad5fsPktJy/0nhIweMvDzhZB1MXlPcEGAAZ3FbN8x8I5wekGwh3c61RNQ/9HK9/8GPBpzSJR2Qpwqq+t1xi9fCL7VKCxrjw6F2ogoLRKPmIryxIssad2ZTa7oLLqSjMLEL2XM1rLnL/mTKCLBQNjGTXQ1/n1QSCf0/8Qya3h3AMCCMHDH7NHmrzxmdF2f1swA3TFnbJSqoNdX5OV18ySk4SNV5slyKJlVSp+jbJRuHt7qOOd4uuEnPPcrUjcWhGDzL1QBtk0nre9G28o8SIrIp4pb67C4s0/1CQBXYrUujSAcH6yNDMaFKqOj1C8JP7xGK74ryjAG7SMca0cQczJCyLWHXBGMqhaK0M3wnyex6uwqVYIjjgxY7/4A++EnFLdO2MDLY5WP0Pggta8stxANpZW1ZBfTa3wQo/KLufFSNv757vHQPVcu5oEqA0ATRWA5rsESpDFd/+jDyuvW+bebP0GW35qQd8w0O197v0njeQWkl3gnNVzviz4jCSzPcmMCBnE6I7K4rlQ8uInodVTwtASF8H6mJ5iUK4HwwG5nZ1YHryp4yczmOrnlNlKcLPM8r2FgQ+uZ4ILfSNdaklEgsQv04E0w7LauH6fiRFIOj79jqoNUkl6FLpgpp2wzARolY1WGIKVXOwG/EHyiX5Z5IfQZb65q+wGNvlQk6pZUIQSre1rESemySmFza+/1vB8ahhVlipGmEXXED/5/ch7WnAVLAbHJmreGG2YmmUUUqEwgRa6r4+KytCvfzCiyJ3bY0E6Cf0tx/tcQIjy4lJWRmUn9465MB2t4b1hEz4EsEEThJAAflYmDv+Gu0ngbex4TRTQQk1nRI6vI+4Gq2b9dy3MfkdkMi4LO7AeX66ahN91StVarjge7/8k3EYl3VDj/wz3KOcSD4iVohJeuBADsQc5bkBHaxfiBATeQpw+swrV5/PIoYGljVhEojVvblfhtqOUi6C+NNgc+47cl8zC+PGizKBYNybk4T4Z7yvhuHT+JHMXJmui4bLwRBGsb+1e8JxUZhL/KyXUfKNcmCi7CNcZsHMEW6/M2EGSJ3nAwu49RPMZYRKoDg9HlU5vfwW4QHU/klxS17JmuzwsPX5bcNnJA7CcQl7blNlw+bL86aA2rAobwVTBqWP609dQHV0nqdMAogVnD/1jTa6cgYpuW2OvB0M+CuDns6/C04SYUGakuVRnykQ+1hZmzGFmJmKNpdDMrTfIORTaIwzDwC1t1VVhcj6huyggMJVMrahgxO5OK/H2uKN09dMMir8dtz46yFLpZqYeVIp9GUHkbLa4NNlHEd/z6JrEnB+MjLSco/Hctn5UqwKPdh7jzkCY9KjHMvJVPMlk/lDfihZLEaTSxYYwTzk6aMsMvauN6FYcmTWzQihEepV0v1/4pRY2VUamEiMsClwb2BC4dr66MXzG5oM42BQZAZDovQG2mQE3pnF7oMwb+39NNTzq1al7xNcGtxMr1h0hFNWK6WMGwVLAMVCd/IqmXd2gKcMH3+KnPMNZXxqVanFu/ZKrlbEJhlhgExysHYW+U/IQKhbLy0lJwvwWm9DTipj0aVOeiJGyMz+NaiFtfQcNLNSI012TSm0mziK985FzLgiBz4fKhlRNlZXZ7fSYLKzrMUeiGDpFhRqlt/+MyvhzO+9D/d7hV5QsUYW+asQQ4paOncsmG/4IhTfzOkfGWe0Awq7OFh2CHUlCIjaMXUYDGlswBm2irXtdlvVFt/1Obr/ow+Kq7lF1MfocPUl76gwSa+vc4mBF1/B+LxHTa/S7dFWKiiHNGjuKuKiJ9iWsEpwH3B9W2bMBUQ9lU825XkWM3ZS+URXBUziDwiwMw6SPVEjQj5i1R8u4zJxpobXYklTOPZ8MZuzcw9uYQN8rjDRcQm12lL5BiRrMM/HLuqy3xyS4gAENUaT7eior7MAktdjsZW6HUHlm/tVMPprKszQPj9J2gaklFG6l+pkAxJssxjOvS/msp2qJCHYs+8SwUMno1WxNtU7cVDQuxRa3lT/t9BCyykwD3T9nf+tTKwiGFZ2Kol3ShaUuhxW6SeY03QntQmJUDaHZ2a58FnckJ9aSfScCavqivcB3QUMIzK26cJgKBZazA8kBDzWlAfxKDG+3JJY0XC09dw6B9gcp5QrihQvkvJhGDFuIm3BOE9hPI/nFWwsZ/b+B/awGym+AqJd39V0AkJZaxfe2mgrWYwo9NUtc+wMeF9CIpYGEhvVLR6rX8+oeZDlu+t+k28DrteYS/CSP85g9L6xs3BRrqXsS7W9wpRwuSpnKtALYnZav1qrmqxlz+KBB7jeV9DeDHImU0wqrww4mK63PBzZLTouzCPzaWezPHlQIg2kuy93wKSxGMgBhtE6agAUbgQ9BmqSpp/EfHzDRNbqxk99UY0mOOQQMIiW/SrUkkpbYJqwHWgqMrjWL3e+RlcOesC7oqS3OCygS5nFCkChtp9x1bWG9vNea9qzfpVG/TrrHT+//hXvVNfdbZ8fLecqTarRqTyc86GcVwK3mIJ0Z8GyowdJ+qsZco1D9c65z7hDeXY0A4C0TShMD6Us/ctgzu7gTxCfYOWAicfJS4CF66ypsY50IJLbVIQeFz/vXNdizQWJp+vlygbqxLMxLUjw53sz26gtzxvH4uFOe0fbZdBrOneEVAmdsOaUSTdE9ZWO8xv/iw7nynIYBsMbGySeeJzy1DpJKCg7BUE8aDUnBIMdzeegNYA9d/87L/E+teyo8i0J0dB29kVZld4O7A8B0EEZjDgkaGWKAgVwnfVgFi+xZqP9XAwaLXrEqEFGrZyxBpXfgFHmW7As31Uwi87flqPJA/zvV44EbQpiLvyn7S3bQXy5kRpK7LXpdS69X0RBTrsiC3Z+ZMkuaxTLSq1TXY8uF9eBLtGgF5qcJ29mZj1vLaY/a9XEV7aBpbX/IpCDi6LyGVAvvhA9xCCP1nRPXxZ6LzkKQ4MYWvgtkOmWP5p181xw1QQb3ZdNaEoSyZTFDSW8PK7VElqthMlrnDJp3NSl0y8gZVGQPb2XgGkPKEHWBMC2QW9QKNfWBEYDqQPESWCkkZEvm7JRY5RtnLYyCv2QwTCHroPVuFOVNclinwbY0X7+vDC8wipzW9BMSitjtE+XxW/uPeKNh02L73eR7J4r6endpiC+EFWVgceSElUdiDObDyjdmvg3ogR8JSwKZpubIQYcLfOcV6aT9jZ7eWLyPIXaspsqX7WTFuSedzAh/erlTAVYwK+Jx6yTSSz9RQQWVkV3JxlvQxTM82E8ZKUy/6ZLOmUIlDZeutFedZQ9E4Zk71klE/3KVfCF6pnqi5DiBNmxvPkG8kwoi6fxswDv+Dp1h2VSahX2GU2tExzrUCGjpTuG7mljQeZlZRvpjdvuaOJ8HIBQyVXj0g7Qbk8EHJY1M+4tLzkgGLr8GDpkeuxbA6PyUMJtMlrtowRyCMXRsrTVWBGyIIh41UFT3lG3yGjYb0boW7OZJdbMMoTOTIN8+B5rm/MAivuonoFsgsL+hqHMr1Jebs1GCjLfL8+VNycLDKRaZcmvXRDuv69bmr8eAWpyIFW0cRKvXI74vYGDYJI3N3y3hE8rEzub4GU4L4tVBrYV78nqhbkLTJnNIn0zQpNOSJAvodwzi8I+Npg/6tPFZQbU+bCu3qBpgHs4kmvpqUsLXPfhlZTIXOZ8Bnzaa6PdqJ/AGieE+fF+UeJene6iv2Mam0y9qexoITYFoQZza0eNJy4WoZJvWXib/ujb95OTnSLi+ctkWYfT12ySSJM8ovOvB+Hx2CSCbBlESnKwY1zm2IBFnYxOV4gXjmqcE4OQF1sZz8gRKEckb7HP7JdVf12miQUnbped84v/oiRM1P29ezblrTt0F6ZisqZKqEfoH3qUv2VEoqrr1G52Magio7wtmPDdXKr78pnmKuXwjenaoTTKZ7OcOA2C8x8aKnB37X5stVUg4Za4QxQ7hfaJAF67XTcyQ0ybvuUrKQXCA0nliJvqw5BseSp2OQJPjqzdVfFWzWfiqjaYWmFZiLubuwjAxbFkm6XbCDAzMX3vdCOACz1kpkAWZwXlFODkHg0z5DZP8gh7PMuXJM0gn0IuvU8gWsAibd5WPqHEFBW1ExWLiD9XFaVQck4lCffhC3SQvrMle33VIrzeMs1qOwGUSOmt+qMaeVMzMj9JjVtD0H+y6gDKmydAxc2zV0V39Q9J71FVX1R5mxE0psQQHnMUvTUp8NaKvU8nekaQsC+0YYFm22MkjC7FN8/8AVkPSK/gzDzb/8XrFmnjlVTqa9Jco+dqMJbnzV1wDX/HVryv3yyHFXV04Mj/+uMap4h4rzOCi87joxzfTVzyLdyq2/RpjGNRnSGbaa/uOHVQId6KKLPuX2H+kLONNl2nmIzq2ZtROAaUwtWYqBi3NvabGKwOHJf2FSR4kaBcPNQZT5N+B0QpgCaXVN5M7vn6ETNnCmW09mwh3Bv2edAl4V5SS+Y5Ux/3tSYmoKeTf5LhTjdx54d9EgGlBLyJ6o8FvTwB/TVvwole/uMXSqY7MMea5i1T/JsS036jddKj4jOOhJdcq3EHacNXmc9HdY2b1CjgZgupBQJ0XGoN0bPJ5Bq/OAH3v+xdaKhLHvpE5Cnn8AhQmUEK/aAlLHyJBvx3fExFPTQ/81ymzdhJYHIrEI4joOAxGlUiPDG03MLVKrjX/pl65/WvDAVEBS7REzFNoQrL0itI+u1QpUfOnoZv0094VpB19tAKIsgQV65DjHUxlkRryUI6xLcx+JIuLv/JQmV91yDqQTYJpkNrGLFST0fVemuQzfosLF6LKrT/dFlfQdwT2YXrHRIri2AArMtK2tZ9cORH/FsRQDlP1F2eFA13bdaMUtVkzmHrb2e/du9Z89Q3cgGbQFIYScl/apCK0NKyXt8oIo4afZVB8AecK8bZVgonPUYB1lxWLsbaOWo5/JOUVOwRY1+ehmtxs+zCKWm9ldjH9M1O/WVsAUNm2c7l5zqAvxfy7EqJHUlpuPoewszwHTnXOFsWQgsSdUEp0VD5AYtldKdjSPraoN9h3aA1OgqyxIfKiKMxe/1r0+GNRitXxrJwy3LefBHZUUei4YmP0nILjlhpxv/pSgk3pAMzc+28pZowR8P8z94ATIZhsUgMKaZTfLiU6SM98l8YMvzov48TxqDmuS/aoYqLIiToL6Z9ytJMMkh9fusgKTcLIIVmR2UGMHMS7+WpsjsCmm0S+/8h2EIoRkqkwAjs+Lls5mQ77FY486ErAmOEhZ7Ba0cQB5GukDM+tnvVw01QY/HjvAKVZIR3M37uFvbJYcMrJJzmGzBfzRl+9LxgNUxcbAgSO54Z8OVcIkIoVqV6sGnG1E/D1uq43SRngJ0afYaco5sXOk0F2ByhwvryAT5Zq6D4HQqywuu5IUn1Ibq+2kd7d2PKit+P/KJLh+BS25uKkWnAv93oHpTRj/5yXrey3EemeZtdQGt7jS0DuTIWR1K3f5X+VdlCd6lQyCq9uaoCgkD9qde/WZCLpEwX941BXhkcU4YPoGZz50x8YXF4M2VsAu+mxmtAErXh69C4zJgL/fKc0v6esuoTQ6Vx4is+FEwL2hHTFD98mPJdXHzvfdHe2SjmZXuQ11bAkopKCS+gUnzCV5m/4koGHJfDWeiaZh5dRdybz0F8eJosZ8Djd8pR64c6pkCTNwe1WcaYglWBUL8AIsVrh/z/9SoAJlvAyO5ph+6IXIE5BuAZvw+ySUir3j/l+WCopue01lJwnXeW+6f/gIVCODKFsJo8jElkKZrFjME7CVOwV+gdq3rQATtyDkEhFInsMtV6KEUxaoT3TH7WfQNe62YUFpYkvsM5FCzlEkxtxzjkPn+sadgDMvLNFyrRMJhl5KLca2T0OEPRV7xNf9dOBXGpvk2jcV3UItP19+SrqekT8LAHghGpQdoSeBn0oZMaLCx6OU/ig5rDXsycM6fh8pvxfdFNU8h4Y8Nnb0lowbhqfdEOSvcNS4EOD4DqZC1qpT2m0pGYjP6yq1Db/n/Gy+JclMajVKpzljfOy8gJMs58jsrYd3nuhmmlSgBczy1+zJYcnDaOYiUI42X5ThEzqHmIM9T7924RSQzbwXfGwc2nhBWOiqxo5l+gHX/3i+iNa0cJBCsTBQJ7NUCOtDILtGBel1iiKoD8x2Go4Dktf8VTn4qpiFPYCvlgWHormpkun1BuHqGu7ivCx/R94TTcVwHGxY5vK+lX2W/vGe7yCUPUoQ43NF45NNwW3/M5Qj5mqFHYthjJ69CSwRU5GlOe0OG07y1h/M8PESnOmsVC3lCb0oDk8bJdpQS41PhBNjEgTRZ17BwMBtUXMaod4YsHT6qrmtpNuLayNLuiXgmdG5xvk1ryb1q6+RUxB8Wiqasw7zc8UqcGwbXLm/pc1KtwUuIYglD6zn8vvwvoMqyqgRXx3E/zX0htwOw4oTf18do+LgJ9UuYIU0q0c6/ozcEA7eHn8ndaixzt8947QaF/mGQXzvAmWJnLNlBcI4CO7SQfO/TqT2w36oRkILsmX8njLPsUswd7LegM/yY/+JVeim0dNytVepJvEpLtY45gMzXu2WayuUX4WfZa/hS4iicgIr8m4x0FfzrMNRWG0NPPXkA2RrSpv2/BO2JCfCYSJgkllim01pGFZr4tsbSMzFjbQD8N/XwF4NglDo+1LKIcGxfevglRQeqj2jL1/DyrBTz1aNNWdsCyTbpdJIaycroItWVmhCeTd4h4CU3RjXuR2dxIFjLf6t3h1XWUGxgHdSx2wjt7j9DblYLu7yYCYLnZ/Qc+izYjAc7vsdI5kGxLbnTqqmaW99meh2VPR9EWS96bCt/pC7v3RB3Xkn0OI7nhLGbAkWnvJO21MH7/tjatku9yRqppUWe4QgkM3sCkAJiuxyW2fJmFO/15xUuRJkMg2IA1fatGcqtfrVWwoJQ0oYBho6+AgEAFtt0U3SqfjUuBOXODF/286NmLERibQhc6+Y6C9X+0pfO2MqKwQ63RxWH4mqSjW/k7AS4Gyn11dbdkbyPrhiuFhf9L1Pnfp1uVujsvAzaO5dOHfynz44IMC9vsI2ve5RGNhg1fmQocRStS4kK1B/Zf7G0jJa8/6SwIZ12cJp6OTSLZIdhIVa4ErOgMQPKzYJIRPzjtLdS1+/HXnATEXMZkW8y5IbIpKjQqOrRsMcRmnW2G7zvXw+nomu0eFVMWqvUXMuB0tz3Y7tkgkLjIiby5eCdDwp/lErImvBfdRYfZ0tjn140v7FU3riAeLskkorVt3vFy4HW189f1NIEVIgOOyaWKrZfcsyEhP1OfWgmvYkqegucOLkMB/uJBXYFGr4SB6UNlcbEeCt80QwCFoChTFFsOcypmThoImQVNCIVnfVbL47P4rtjB5QSiG4htE2jFwbJDAMPjpRAhjqb9yZaUB+y7/zzWDPUi8pGKhLifV76sB3DjdvULwtrFhNWWS+rgG8BgdYugGnJtZpcEPnmMuzWL8nfM1aZdfeQSPfUkJmW07YvDRlyhzSJGInWmDXKO7mjs1xDpWZRPWUoeqSxh8ygXhWP2J6lg3jhllfnl1ggUY6cAJvoOuyouCQvx+zjtH5pAK9Tzpzr84FZIBXkgeRjWWqwb+7y1OPUTUKgUiOAxg2qD5Mf8EcsAx9j+LofASUQjclKJP2o3gzCpaGPaKieQgohmVwOWvMQK1idJXeyizYQ3OAZCydKQEEdTFmaPaeNbG3oH5Z8/+vU5o+s5eKHfgnl7UUR451vMApdKeJ5yjUQ6t5JC2uZtInIiE+r7yShtboUYvDW1OjpjOoV/NWsJ0xdrbrldjOTNT7ZYKcabgrknWnqCrBbI1czldDPiRdoYc04RSIVOj1sMFboiCvuJxfCdJT6eQtWEP7HZIbZb0cG3drS3jxm8rzFEVFfXxbvKNXItm23nZAZh+ZVa3r/FFBtjTNbh3tbvxkcrs7FWmoI/rgo8JMR9/QDlKjDtZ+KklOCE11DIkSpmbpbRqT+NBKdFzVrS30MtOjpVGPxAhmU/wcczaiSDECJQRjH1P0KqcDamP19qmThSLq+jzft/e8lD7oLbly89ZiJrcAve6PElXlbzUnJA62vh0l3K9tkrXyLMtAoa2S7xlNUHQTfKhZFs1LzuJF0mEHM40FOGefVl8znqAzAw1mRKspK89dOsg5e8cvKdYoOX4vBaukJJs2VGYNwsX4Tavbkidvdz7zLpKXvQFvHVlhek4OipWEsrRs/hBYhuh1AO/v4I50fwAeZbyxIV6zYSupuxBHNoUugQpN4vK5xiEjVd5+ziWx8k92nUv3GedbLFbFsAkIy1ySESJrCUvFbsgmpTmWQf/A0dxpyONwonk6wuRV0pBG5ikZLlmtKqCNuVh3YoaWEeuSmKxeKhkzb5dOfodZrCkJWfyuzHPBkcew7DlVNH8sjpgE4479T44T9QOy2S4KwlkzjsYQMoecJ7Nf4Xr4qlJpTTw/HeorqyGUThYbUWzKYcbsgfKsPifLp7ZHCSKjiLiPgEzmBpgwENup9F+fv408mAXFn0Dl0SJm/ikY9/0lRzVv+C1qrgIl3jrGxHfj/+uht51gtfhBcl0EVWCNPcSLVgDr2dTsUlNEX38adeGc4XalYYhtPra2lI6SaKFOM0+2jiotS3DYuOeteA9evBflgvqdT8ptGB0Gg5mj2doAkh2eS8PUnVC/RD/9SOTLN9EmnfJYJRiTAar7Y6O7KM52Rv2Z5vfQpAn9eA11EVUtGhd7c/S1tYh+l9WdmoH4tXGsg2F+kG+Vgfg3/B0nIXtfvnLcxMnZecfew1gkq3qNJucrZyc+wUSKiNQ55zUJvstTJub0TBgUAAhBbcDJEN/Y/1mm5YoMS9vysS1oS7VbAzTP+zfPlIrIMC5sVn9adwLJNggbq9DVldu7sYAwSH9oO+aYDtua6qmy6PR9uSAXVBtKjrIw7bLiBOEEu4ztpKe2izpKhJife7u1bW5swtk231b0XDSWnTTkvYE7I2kEzVlnWqa36ZJAq9x4xJ5PyuZEfDPDdyppAuh7AGmXkBe1AF8LzviAxiQobwul0w2vsAgwskpew1YP1t2YyzJvTHbhDls4J67fX56sNMjc4MqqR35oyYqRARJQwKvyAgYn+Amr7OVt8KoKIK+LDPgStbcj9MX2D9m9TQ+ypD418Hdwo5+qdGaRjhsTZxpN2QQNVvPcqJMFjjmJcRudfUsk6Qbh1/iWWf6tfZx2l6oE/HWKx0sqVjkUkmYTGriLlNUiHOHsiddoYC278q99zcKkThmbuCHtXjDuZEfOZcH0raKEfiLYP1EbLhdy8/Wt5Yy1qrKyirqhxrmGsq3K0iJWLZxsQFwpgvQV1DoIStrkEfOFfkHLq2Y5sQexhrCDtrScOn/913Jj3xR6TWkn4SkeP+OeqjM0VlzUghAHcq99ofjbpjC1JORjd4DATkuhqj1xiC0L5WXthOTFoyq7AEE4Ut/1PpDVzA4BVXJSckRNLHSEae0HpfteNmlvlnGTKDJIqFYp9hKPsWV/AJAZvTHTOf8s/pbI1zT9+/Ou72au43umMlgR4TVY1nK9RTzTKsherw5eZee4AfYAELJVnRgh++eTMvBRxe5Ohd9E/n7qQtPf/OutzL4kDkuREa1L0oWNwy+yUpTqkj+IZOJyvptxz0oEqHL8ksoHJC8PlOi9O9sTt7an56Ir6CA7xEaKmUK5w16mc2TM1fDptZj3iOO6CGRoQtZxYVgI5hVOoZ0/4T7E9vGwMFl5ATF3sZboh1r46TJYKr6CbmCILUBTHXCu0aw+gMNU4IA6Ln0lml/irL3JLp7YwuhOsA/8GSMlQEp1Sh/dwEfnr9tcWTINBjg4k9ZKPDYg6ze+L+nIsmxVtOvDljXcKPP3iBq0smVaiqXH+CZmXsu92nekHbTBMIN/1d0/wB3u1AsENOBJDzMPRFTqOoX3em3Dm78yOPeyDYDW313Ou34cxJWpdOCxs/llEbiuUT5gtWofetDOFD9rKxqsFtCCw9kDapzD+3HTEINKpZdKuc8OCmXcG65N5F9iwNVnT2F9FJe7OWlcnAsvgo4+J+k+BOoBWCZWBxMuAwCHUnCx6sL9yHS/AcqcfNUEJY2hfT6DKfIItZgVAvk2Snro6q62DkTsEko2W+SFgl3VKXInVVpT4eXpfaWWlQ/ATvRakyom52yl3DUmSHE++cL4O8NrcRMmhw3131V/i2cLDsIwktCLhe0Tg0zj0ulckGKZfWe+if6vDxt6Q027DVDtqHNUVLIYtwqt/IBCcw5v+CChMwL6lAR4YSjC39XSMnejLkztlr/2jFy28syVZ8xVfMZ4yhjU3qMuS10GDh/3pRsaZb+iTH8hkQ8Idjiy+cKPA9buaNkqZIUjRvFh9nII0ButxZpg1Y+TF6B5Ghoe2Mx+CU7EZj0p9IKwkexXENjmx2jPyygH/6US8WB5DEDehG6JSspZku7pcEohDJEW8dQfDQeWZdweVebX2p4tnZem1jhy09qpWGb7UrgGJ4MBt4clJWigKUCM+D+dNaEv2Nu+66Jc8FhtZFEK5bkA9eRBaLTT4UyJwIMEbC4qxtr2GaUlB31zemjj2t9UcxOcUH+XX+1IR96VZmANCxn03oR1/IG+90cHEQ3eSDihg+nmlKS7+HaoRIvtIb1ZClKbQKIK9GqOCw9pH12txp5+6rl6eTiDTidvoJ53MLTi9158JFHpK2SHLVufeVQnvHXdtTLrUxRjsrGDWPHG+8sqPFdT/72fWFRhX7sTkvJ/LsMoueEwGWCHWp1rJcb9Kt9rBLXTRorrhbkBdOIcvhhDltBFH07cWN9UrOfyElbIMN/4DBn2WnlokEblnxWmqwlybwZnKgtlHrl8tf4l/xgJQFUZa/u26WCRYJYhEMSTOO+l5trmyn5n+bi8Ph6FPbyVt/rUl8dol/79Qzu4QotKccAyQ3gokYsK2DUMB8HwXS2IER487TxkeMgV57uRuegGWWYrE42llrKfI3OjQs4eGRIZc+W0aZhNh1N/dNzTRFeDIyesVF2ZXMn4fv5p9eWYGImb0c06eI7XeedWTTKUZFULNnRvU57Oq9pZevAay9Q7qcqvuMeIAim7g9alR2eV4lOguqaGQE207RkzeLi5onqfvKJdOlPN9FlhHL5P3G3sZU0giGEohBn0WeV1Brh7U4yvazu/eXq7mQFePszxohv/zcSe421r3xzTV6CSSS02ybgfJ+9FN9k8eGdb+X7qGH0NjEl8DkQNcX7QzpILWfi8y0o/ujnOjF3Dg582kgR6VRZHYPIBxgmSujUOs+WqX0zgOX3XjnBqTMj6RYtlKiDSiEoE+EJAv3rxvYfD9yUhY6gMbqgzGW3I4jaToRacrNDOwaCrcelAWfp+TxLk1soM0VZUITX81GXTRh1KuGpCLMqtUC+J1lGW8i1wLCz8pj7zRh68BQsJHpmMNManz/VnwthCcseXOZFHaFuTrB5GnPDnhCwHqpkCFysPVf91U3HX4KduzovTZ1EYxlR5bndOC+9QofW7crf3zAtgEfcHrCaXUsQaAm8uSSJdQeFNJ4Rvc+IYP2oAY30GFJ8Sx6dqvgwc4r4lLAtIYxvL7VSE1277GUxtjdws4fsx/dGTpVzHlCvnTWocKWCH0VHnqBeUxCU0/MW2u9YF2F5fOUqVyRMXUpkv0JTbcsTtMBDldmd8upC24M9kuIbwcdlb4mUx95rNoIHlhffN8Y285X96Ax1orTJcdvat2nfp0yuvdYRCrof6gPvk6MHFlHXe34tvejhLdp4fDP4+OR2jpA3u0fnGCfcUpbdYkw9lS16U3HZ1kTB3t5SKwzm4bnzxKDmw8WktOJVip3uQxVmzfuAHj4MqCPRBgQJLpekg5FvKBXbs0si4cLUblN2qKJStwG17lZ1pSmlr6gXFqKnVtCH7CfqFqz1ANHCKpw0S2cxEysaZQTYS58AN8JyKqXOkvpcuvZUUYk46IWqTA565lxfB72tfiyb5x/SsrhoGp53Ct8rhW6h/oTl2uB00WU0W2kaoonKaGO+duFzG2PVPjMqnTS5vnphgupqe2RA0M/C/hW0sUd8J2iKfwVzKzmzOOJKq17Y2zHjGpU7fs/vEwcU/3ksXMGy0hyjqqOmYQHmH+shBx+glGS0EKCM88YiwDR9F0GdQlZsWGKMCVg23+qPj0fRIUPNa5Cmew7DgaPqMz8pGnbY8XTCwSG5PEelUfJ1BdXGU/h99atle7xy9Mq74AzFvLBrbjAv780itsqRjmOHoB8DGvR1ilhZClD8zceoFRa2xhEiJOhePkK5bU0eT2eh12itstXO08oQqbjyKTy8XQ+T0mXFGz/cs8pwFScHX3X9K+VcJxNo7hi4lWaBv3F25QApZndpdZcjOXcPUbMsQgU5oI4Lu6pqAB0S56VMY1yP3pq92Km/tuprII6KNvpOpIDRw2VwvvgInloKq19ukmaTkjC1RK/97EHbW7Cl5IFnjp8X2NH1V+MoK1XWYzfMnKMvfop3i7ZiLbBTFkgkmEt9kzFRIzqSW9Tu9fSy470UO2ODxqfkY5eowaxwzpnXJR6xTXOskl+JRVk1YGCo6hyVHs2yYWav25RFC6cGy6ub0iTDj75IBQXbSw+NCWJg+2yOfR4ur+Akkbw3RqdeUhzQfY4M9zPdWzSjs1O1c5z4UzrtbYOKzqcUHCBMnLemqnu5NRTqXlvWvz2YIG07U5WF+/EHEO3ln84pUntfXJWYVHQJyuK8OUQLZ7qPqf5ox5BkajBYwT57EDtthJSMO9wZklbMPIjl2T6Qt0A53ak+0UCJKNzKZdTTiudhcoJ8dpCs8mt5EygllMeGRPuLnHdGsYfaCa0E+teXnPFyYbhGJqH6CPKnKtcD0sbPeE0Rf0dzb45INSDRUIuyBUnUi3IW4Tx+aoH5RjP0Hv4X7Q8H8hvEElLw1/m0DOLEMu2uv6wYADLoMbVz0VjRT8vIqgtB8bnlJiMk9nZCs2Y/wcijq9BBWKiCJVlCPh3VaUQnMbZFLvF+KHTx9yvXH0IUzSmisHJoy7WRx9dWcGYEzx5a06EUw5UA+AENrWneYOmQg2HAV1ERmOtqZ3d1ODGMb8Kouy1bJ9tpTuPAffHnoykhTBOITtMz7bZDTXCGJZCg4YFPA4vno6dKF5As08ESC4ejBycDfdChu0g0OXIf/dkP1JbD6GybZ5fJ0U+OkSIFbliIuW4rVHm9kAI5zvkTnma3om3sRK4Ekj8CZ2c+lc/VtcaGZfaARUo2tr77zFMg2EJXno1TtZrB3gPgRRfoxU5/7VIDSlLWO9ES12ZYMxP2IvstYe9EB3iNKffo8s/wFjYu1FuiD4kqOxUepKuHt/VpeozDT0exsgm2Kq/HrYialHv4IC8RLbGoNdTRKKejC/KhATuKY7BlZJdx4Zz4Av+hfi4jhUl3pXHbyU/8sWOtyC6zCupRKKSlqByn6eZ4mAxA/8VnOCsN8Y+m99LlenkGLNWyg+3m3Ca68m9ocv7JB70OGhNHVgU6ixOswjxdN69J7csgr0lFUIy54n73zrg854FHmRxqydu66RzffqnbnQUT+BcgymgNBC4XQD0e1fcM+Imuq+l12PYVyxNsqSZdTse8WzU0y8hnLaZgTNe/qtJPvSHp3j4ZcOxyAhsU2i/FVxAIkGmBOm/1zVE+NrjIvdEFp8peh0gpzKJYoCRpe40F/LRgtJFJTC8/d2NKyeHuhW9GcOhcqdsV2vBJNIFrsI7FgvoH3QPvMlELqxJiLaSmiDzPYKO0XSNvreZaNWjurZMcsxlI3NDEgNTONBdqMgkjjGNCrZsLATE+2JiQzSp8f/E0VycuoQ8tYlzxp3ao6WAmenuqoJOenTg8mM84ZvBbxfR8Cl7ho4J/lczBu0HGAtVmMNGDue/Cr6+v2LADE+CzgEHOsRAQvNoMsC3tOLNjziG9fXOtMGXzwcOK24DAJUpvmainULKdgqQbvTqDP8cEtlXkbF9z/emzhJGaeuyjcSMAgyMmJ+BAuMSNWdIUjqcKLG/oI+/gSswT2E81lnK6iKjNfgF84XoN1d+PSFHSmUoIlwqgJMkhy0Mr+S65J74CsCQ1cVmQ/b3OBgTLrAs3mrvzEEcZGg5M3se3RNvDEWXGxUmMAiyB7Sda8wbUyAsGATyuzyLE+k6UnRb9DqpFbE2nlRaASBc/tTehy6Plzb/sThcqYISEGOdPEZncTCNYAP6F9P4/T3oPYELCt2b+28jzjnq096Kiqezc87Bnxu+uAlHLgMlbhaLH24jK1jcYJl3kovf4xTEW/YTd2TCNI0PieD9r4CPNDCOj8HDgjaTynEJNSBzBd6O0sNkMy/2L/txGQznILI+jGn3KnN5SP1OwOl4iWNde8lya6ohdbq8ygp3hB3B3fpKol1UuL+8iaC+LaH7ysvCIHYACgBvutMbkCLHt0QONuzRBqnV9syOg/2wwdPA+MQffic9JoBljCCEMwjGWUUOzOZqlsTmeewgGTWOSYtuc820+jW8oQZrMaMa2JV192MaGVz1FHTDb4K25x7kQtQnCm3zTgeLFgYKNnv16BUOwZQq6U9KSHRtPdqRp9EpgHV36JDoQCjNmhxvHSPnlVrEh9BCa8Z2qkZ6tp+HoFRR4FMp19okDrycDgqX9kqUgiGVljN3a2/5tHuesFc/HSXD7MVKF4VEtgalnbg0pKda1Uu3V5ventkG/PdLYiSfRJF5WU536o39MWjfHyRUmPN3gjANT1i+t7U+uJJPqm60cQYqV1gcUsbcnRTJI6xJ8NPrvZIf9EFCH46StJicNhhpJW7PNYo8QJEftKzJonONtDJKR3ShSMqY7M4M6kYONp2cCO0BjM3XqAKdEt9qHCVecgowPL8oXBWeAXXYscCrKhMePo02CiRJfQ2Y7l7B4vSGo4XoBowcccisnSods9RYe/ydpIBIy9WM///3Adp2TgkM8tPsPcGoVHY2VvEYMOI1l375OwTlbDeyxqfJiNu+Fq0JYOdztl5QEj2XcKWC/khHtL3dLasZqsBlmqjGV5ZAIJMRw1IFYwMyIxxtFhup+i5EqoXZaQmWPCYSniTASBO7+Laxc8+Hqldi6chAWNu4bAE7lZrIBg1RGLl6eB1bIMg1guiDeGSZqSe5KFq6C0iPbhlNdZmkUzBRZHMXTy660fQVGSg8Lhj9py1WPdD4sQUHpSD8bKS+VHClVyzi2JodZ09sfz13mZEfTDvWjHVtdQIDP7TChTvl7lb/6l8KcIBWaRl0pOIP+KVvezhjTmFpEY0C3r/em0e3LQz9nMpsvFML8i/EOA04ZE8lKFsL+Y6AnWBueJ49V4RNo2qgZ7wBaUc80JeggQbIblm7w8Pu80U7eRX1F53X+YTbRWkceKiFYAvwggB78TXTtLU4aZVU+wXf6Vpc6wuKcYUATjspNPG7wXWN5vW9jI7UMat4BOgqH0wpjldT2AWvhahbr5u3JdFl7di/UyiKWtERHdJXIVErNkLK/Jn5PtMPP4hQsO0cGNVAFpkPQPLPRUNCJK5tLklUjcq2QARu4VTYQF5ewct8NcjVHz3SqXn5UlNF78/TIl4RHlJMKtiOhwJdTztUPKNgFfQRbiipT6DH02ns/zmb+utJYNgumUGs+hEKUcRHdD6ArXJ/bT+3OSXgwjU+5dD2fFCNt4CNpImg1di4fue3kK9tO54xWAL6prUpbs6lnRbOk3q9qJZJUsCNkKjYwFww8RLlidyuRAZE5ZY5kK1jecdrRhNNnasjmYspvlv5ZbAKj0KmbMlkL5PgnEh1qCISJ8MjBQr9hjHTdqBNWsEj57Y0jjYzQW7xsl+Q72uiI4XIpBhvZbnGjmUqQNNf59ZX1mMn9Pv2uaV2IPOUkuVp7FX07CfLQzc8wWFCh3Rm3ypPo22Ou/oGss+odF4XOxGv+b9wBozPPtjZ3gmIV36XP1KJ/NWon5nmD0KDM/w/Pr3lqRFaWe660M+0/Wlgaj/TwwiNd9ZXtYvyNFmGAgZMCP4PXECoDQgoSZPbIKTXJg7Ty/2o+I4oKww3OCfMNZGt84OR0lYZhU1dYEn50a2vJTDWfQU97f1a90tieatnpZrwVJ5T9d8jJGG4yBPVMaXEjMXn04cEqG1BzF8z1fp/SlesP6hULIi3dg2UZjPbfm1oiIQaYra2sfy3L9kbrYNv0RVXbBMNJ9jnZfLSfQJkVM1E1hkCkC2KD5FtWbmDDRR7bl9y7a0HuYvSn904SfqadbZyj/14rdGjeu4FFVp9FNebvTb4bZLRsC1T5hH53L3hybj8WfKFDu96GnBqRV1oSSxz2iZtD8XlnrUy5SVY35jOzucT+wC9NSqxwJCW2ecz9Xw2iHeSBFU1anhAbedQjM5xVuH7CCa6PPWnYNcNjKZ3uLyjxtoOhKCY1oWV+IDhJHrsUo2Bl4vHXUrPSiAm/iSKOBavfGf1DxnjUkRB8/NFzmP+ZEIv5a2rWoN1hSRxEfCkaISQ8vvCNo1obfolKMBt213awzqI9EVIvBU+XM7lcU5nDMmdcZ11xyQMctGMg52sspJuJpJciz654A7BVMxCFOOKugWJ0phUSLjhnD1s3+ER+UWFaOMZhPow6FwoDWPxOh2O9gv98jNHKejvA/NJArv0eM+kmxlhssZDTdMnoM/br/JbTWjtCfgwsVUtL4r+/tgY678DQVgZ6kK2SoxuUXXyfWKPenyfc75M8XyXK0fVdEA2RjtBK34whsvVcF5Kro1MO0w4HyLadciPgkS9TDWFRzuQTXtX+sJIlj/Z/BhBoNjd6WLCfZI/X9y6G7ybUGOiWRNVCVaGEQnTxjGckcNmwaknwVVh7xyoSMOphO+3nIyhS4yJ/cHPMQF378v9HlUZ0JR42DFna9lw8kjfciwYtKdRahrGBzlPdA5IdRHXnGvsvvgPR8VW9Fstxz4q4JLnlb7KB0hIyrkM0YhvHfK+YznlgD4ncZBZbQDDmG02ab1erTNT4lPN10NBhACtW5x0fvbtcwdK1r2PPO8FLDkEzUIk1c7p0FwjH6wnNI/YQXgV95n5aasGyWjBzvUk8lnTLb8q//oAVtPVF5g5/eh4Xzs3IZEiU01h5Yorf5Xm/j7b+l22FgpEgqrE9DV3eaA1Frx61ckOwIRCPc4zLTeuiecz76JsFBTG637V5A/f3nRdxAR/gpggq1a14/3JCliEpPGknEAgfXT8WZmOfFGEgHm3qmEHsA/lYxTur1yRs9Q9sKTebcNwTUa6W+732baZ/vDUoXdPXbdgO8xv9+eh4tig7nE98hRHhUjwh09JW/dGE+EGJwJ9MjHhVY/N9Gz8vi/ehzrrxc9cJSLPVbw76XZWeFv5wNpFgCholXnttclX7EjwdkBZvcCGYPcT/cRpzHQDEDxfknDICfPnSmv4/nnSfYcg/UOb92pju0Zqm/9B2x1WoliwZU2PM28wXqhYKEP4qqnKfug4YYiRTc+7c+Vk0rpZ/Rk0Gak5d8CsPb2x5QLJGgrPMBV9Ts5z3/ff0cCNw7u5JuRo+KgcfqAgbeLmc2/8IRcg++h1UqmeviLz+p63d+kRWOJ0e1RrYjwy2z10pVbOJwhZGHWaBYFePXkh2yug5CxYVeFuw0ie7rEcRY4znvBdmmqDMtSJwZ8AjEbPq8T0+zR84np+TooHipAn0CPoD/uWNWjhEdeyMYpnlL8v1uCkk4BgKLmGDlJooMkcuDPJPPk8LoZZTbkJvKthvAffCTRNM8XasGmyiZhBAPgjuK2QVGUSkjXa7dvqt7BWNP/WDFxvObAsoldNcGhfY+C0cMVDFkJO4Mj79vV4zd4KIEVoiDumApQ2q8lDZSNL2lUzIECZC8ScSd2B9vIIyUwxahHTCz60dBQ5Z54Ar3ZuO7NzBe1Bu31WZpaWoUCrDaUYtY09n7AHRJpT6+s28FO+mTVrM8SWIb8v9kt4gSxnvJMk74NB99JvUwqmNsCIajL0okgOl355/qQstYCo+pm8B+Y4bxyYvDMwH0j2DO+vhzpoX5sT5lGxHickGyCykptoPFJC2NVV1DKFgcNVZbnbqvSS0Sj2ZWiH/Odf5KYGCC6JwavgxqDWEPuSQ6EaV71+gjUqjO2eWa8El0K3ejFjowLAar394YVOoYVlkSG7qmSi8Pt3H8HbHfnXHU0KxPMqpAoP/4oUN3KcOvqD07cYb7req9EQrOzAalrsNRnFjaloVW70wQ4u2R4mgB12IThA+eM+3l7kC1RgfLABa3Or/7OdNkahAsDSGJFEBJbTQtpctCaJroXXqPR1ub5IkkrHbTeZSu2cYAIsKIF0U1sZQ3vCBhmQwg5pp1pfT+Q99Jr2KtzOTcXPB5Fo/bR77I1HHu2easn+anTfg6PCqW/8H+YgkA+Gbz+9Zuy4Nsa00t3UukkA/pn62/1K3bIL3yJ/X6vJZweBxg5HJ3ba2rAqkkV2lc/xwm9wzcf0PU3mGZ+vWkIBdm29fjYPHiUY/gyDL1bWiM3X6H3KUTqTv5hCMUEo1wmAsD7ItbDsRIaydCSeJnWgJaDJAIMd1BcAfLqdY8IRyXLOxXnQEsp7HtwQ1trOlqyWJOEvjMx0+WeTDCEWVUxNog5eVh4nrrr2+xD7HCVV9x2dUqalk9otGPfWWJvu/YHUsB7WZ3ZWU/2ruSdBl6fg8IGlYou4+pvX5RKuAR4IdOXNULxrlnnzgc4uZwtyCfg3h1+/kwQh/mcvPNogmilOGhOPTeY+P4XNKByK3M5+0y34FTu+AnuxkODKCnpiS4hJ12vHiIlRyZ+9IKR0Yk+8zVHM77CyHi8NDGwrk+VJH/mJFg37KVrTEt6voVhaIvfmSgkMG7g7SqZJOi0DrIy+K/SiO7R9PiuYKRdwsbz+T1BF694oUbFrB3C2QWls7HE46JhGgq3GwoqCvR7dE0Lscg4JyPnUZpSAqG9MkpWW7MWqv3PZXcI06gSYsC6elnTnvB3tJ0P0WQHwkNLKT/0bTSiDRbRaGlwD7RJoyvnyebXx7bQ3JTHs5FcltB8abOjUkJvKPJNYbew88/9+hfiWKpEFjmpQZDYRH9ndTLrQmnBdty7OMwdNr47Ead9mqOSG7nhmNqrVYxsfShOAfK1Szcnh3+j3Kv7wBweTHwIEQtnf71REHSwrqE3txANVHWZ8NZckfmmx7aQHYrzpLDOMLtLmknN/yPLpR+ZK0NAZsNPdS9RuWtAEnqMUz0pFEj/qsXq58FuXCq/gGJO0dXQrUJZupjMTI8l+lEVJI5DFg+QkV5STMyC/HiaBgCUgQYyvzB1POIMxUNg2pGJtGVl9N6dlvxSGFzZRjvJA43/CRfBtcIwYn5/fXmGGcFof6xkzESv0HUpqRABetnebAKeD0wCmWJQfsRxFh6V6AWe6y+6wsQ0nEaL1fy6hB2w2nzH6VkxrYvf1WjGhJD0f5CvVdviLgyWJergpQsPdu6EkSS6RJgihDV7QdLEzRZdJj+6SA/LGm6g+o6JubANEPD0d0+QVc9lSXrz7FiKJvUyyzub23k2tqTUprxAJ9bOgEsHG0waQ2kQuYUCVHzvwDUw9c0JhlgHE4pIdJ8ZrOY67CrMYBuZcG4UXssScX61TSvvmNkO/lsZmTlznaMNGwtwdrzxC0/s4YzB+HydIX2XardJZS5eqOeM6+m3AwV/6IURmslyOBgNH9hAEIOaTOo2oltQtKujIfQ4gw6x8tx7UTem7t9ktEXV0BZ0yYAPbdH8LWlYukfrd70FLmQmYDQKxZmD3EYH5OhvucDtZuIp9iLeOJs3UhxEmcrMy8PEiuKwDJpB4lxOYlaHhS8IA29aBKi8NNecvkTPg7eKZnFuNxOHL/8p8Y+RD2g3pqMM21MDxvmkrhU79UUh+y7Ocf4dGJH9ZebJ7oJUXICFld4e4DcQAQK95/8eUcAPGll3Hm41BWueTwIvrKeb9pWEBqA6R0RsxmFBMePDGrYCJKvbwOwpM4F1txpmstMphhq7n4nG9uDTQeKBItxKHden7fNLwOWy1sAclPQtJT1omCnI2oaa6FMGz3kmzfeYxFcUE0dyv454X/JckG71xDA1bK8Q+9Hfbuzb9M5lk9e5SzpnEDm5FEQ8Qugf8/t6n7WkyVNbEjdxT8KP29iRDDmLuqWvdtlq9vVKV5uJ7p1LihBMaSDiED2iQXWx+32r5dXvy1eduLSp7lTEVQKhoE8X6DZkH6w3YoeV3yy+EG8m0llvxMOtBGQKjTHF+hlUXPbCcsR1qlFBje8KKAFf2hF5/AJhOjafzZCkDcG6ibNFRPcu1oblVcUe0Rgn0OzQzFoFznhiuabDrHUKT327RYaxnQY/l2dstxWLybzG2SlWhlJbNVrCrOzPSvxC0suag7Qq/jNnziiPSq4aUye00SOR3wZYhimUlivgp0aZZq9XUDU3Fqi/qZwQKRoJ+3zrV4zOPOzZVOcXEj5YBXihL0OYQCjjDeVu8g+JqFMAnedfzUisN7vSYreG/4MKLDXU4S5o1nAjApOt69OYY8VGE/cw0pH5kC2SUfpPd32XWS8aHmpeKTDtZOC6/vCNasoweH8Hs9YZjM9JVDced0cx22IfXEE2Fx2zRXO/kNfScU30ePL6wIkSbjVryFhAebe74gkWCKajDy4tzKWscBb1N+pQqjPzmY1oAjSemAejZHoL8lsJfG+zC3riNyj2QNwZJwn69T+eyXYX6QMUkt4GGxEJlofoiIKG0uLwcVAbCknkldtvQmiTrXmfqUmzl0KkAzvAhB0gQeV850ic9NNcS22pkLO913uG4YY+xltgYa46wo0AhX8zFzOLAMjpADDsqmn61DIn06vyf5jyxgJMGR44Iq+bNmlJXH2PKEjKAWuNYdqmzOs7gb3KLxF1FgFj2f+YeuuBA76C/VX73OpjS318bJrC5KZUStb7giLsyP6dFvPT/DdLAcugw2oOkWA9Uo9lLYhks3EtPSAkWxoqL4z7IfiKWbUxacWA1ucoy/XGUbIzxQh5r2I+8CPadb5eu+TGlH2neOdp2+p24GGW5RQihBg3PMYGIlmggsOolOkb8Hni630URpX89AFzSaXOeE2t9+yRXwIvEf7X53WDcf+q8XC7Nn4cjNzEJwqsa1y6kFwoVxyj9qw3Oz0yG1RpIFLdTWiroabupX6fLu2xZx/lCn0ET6F31XGO+iiE1Db9cdTAXL4oAT5EGJkCufTeXFuttPRtJ0AUEhsNOPp2ZdTD+FcT31EqsaH8POoaZjV1/KpjpxNkhHXl1lad6D6gcIKjwynERav6ZRkMRT06AgfQiY5wM2PKMrMmc4yMn+7nOxMs4xOEN2d58y+5yOJhzM3BzDvnhlIQOw6vlpKs62d+tjJZce6sGy8wBH0tpBZ22dvraSW7zhtJ8YZzg62faxJXVfmXHjb7oXQ3DNSCTrXPufxmu/Hdj5xA81vcezUK1ghZHwSKlL2LKp2IFP72zA8aB1epDsH6ZHQLowu4e2vt+gtaqVnqPac5tZJmYCczYuhayUKVsCJUghduF7hZ/GLPdH0wqobU9Da+u4ZJR8ssD5vhC3jkO5lY6wIhhSGNTInEz0CvN7nybODbTwVhYnpJhLeb6F7DrSS8eG1q3Wo+EKQy7xHyJkPMgjNMCwLL7hg7jUMsXVf1GvVQgzuTw0+1TS/Yvn+EwyEjoSYs/IcbjEyMsVTQIQ5pWC+IpntP8edg4XVq6nKVliwXwumU32lxKz2AN1tqMl4+mo9iIv1a/QwJflljLxop3itgQj9sw/x83Q0yt5KElrR8IniHaq8Md9By7eQ2z1eCHHZqisTAX9eQwU8VnGeV9Gn90JSeeUWcjHiz1MhcYnCPxIbCa/D6MYQvkk46B1AGvTPtGiG7CD4yrPAZD1sGsjnDhTakH7zxSeG9F9lZk09efBkmrnFVoB6GlchRqj8GO1CIZuoNZCF7WlhaJOqrOphZISJHlRWoqkfnQVzEzyqLEjtjiKBQpS2i7y0xuaLFR7K+1IXvrlY6z8sVGFZQVkwwyRL3BZQE+RMSltTZESl7ZrsZB7I17xS7LfPIfdfr8ylIgQ8aV4iwB+397vODrpJYE5Yv9D/UkCAdbS2SXMl3i1cLKqfYqQF33so63SXliKmDMVvhoPr21EezAYBMTCETBEA5fhj/wOQFGe4421q9YDC2W4m9/YWwQGnDeJEzYnf4xMfKydceVTNdlk3pB9MYS/sJ5lOkvBgLQapQeBZ6r0oytngIUgQ9V/J+iVo59maRDDT0iLnR22KGeJeNrmD6bBE3fr/hWwlQ/6qj1NjxyiPc7b/g7O5Gj4cGeyWGbYiTnRcpYh/Yz3rN/F2Lq5/dgshFqmU9YcatOBBU4H1j20fohVkukNkyH4T5CpeJ8teN5jqqEtxWchHzpXPaUfE9yT9315yR+ugq0aDwvK7MjVyNHExKAdV1Ufcguj+kcI3Y7fG7Geykb7/+F9qOZ9XvyDYkQhJkEx+nMMMitPa3Mmw+LrspcmBCwr7FupC5CTSDAy+JBOyAOxvsRs3s5I47rDHyI8RFKNbiINPzFUSq48C4TP/NQxgLYhgFwlwvbWKVkNgE1eY7xCb8lNGVwlOYx1oES1jf8Ega6VRv6QrdGp7HlgAczBxQ42r2suh9KZUPgF0h4bN0mbM2jvuL9q1VJPCr6O133TeR8PFqwdB6+H9dwVTgCbcGL5T3vqZq5CzD9BOG/gQ+xZ96xVU3VZkiWuG2+6IuzyfLinliVtIPTyhS/avwLVredr7So01Z0CNkNLnOZ0khmwbC7WcwhDSrnONHt5R0tJfF1EXayILu8Xg/xqLKYG/iqQLnFr046mINqI6NJeV5MkDcIRsMtsT8XZossI5UZM2J02usqZ9LxLyYlOpkFsrvE2j3BJAMFPmC6apIyYIV0pF/bNw/WK2Qder6dxpzPJfUQWM3MW7H3Qt98X4gcdS94AYB14KgTP99L+vqCXcb9Y19Vg7clb1U5nyk/HGlsCKdVynHcw6WkbepqMW1oc4WZ8EzFAGnkCFmHMJhJiXvgB8C0icQe6GEUvrS41cfyHGM0Y4bwRsgYw5cMigcwW6s15eMg83A+y0GVGfQfEb5ncdaXJbKgzs7HHm4cYWnUXVq5fzdzvdNH0C+2W64yiiLugtSYKPEgzikxkIBmo70TbAg+YAMfXwgr1SqH5sQa9ZwXYZV8Tfuzqf9LfHLw7np9gH/IL5rqRackwL1gBM96rjgUtDIc+hVxxJLPXr+jrYy8N//idy5Sel6CEjbzS5QYZYSr20IvFcwOjY8iLMmxF7YHqaNdB7upDuN51XmIsDbbMfDB4W93Nr0+wBnRHZHP+xxPq0N6k1fGKsr6C+1xlfTof3xioZsMkFV6qwzcF/scOpUIRdEzxlmQh26RxxEAFHHel3qeZP+fbpuJAo+rwWT4a6StTDgeDMSKoFiHF2KJ4cK0NgVtK+uoaz/xS15s4KOLAzGEdMEOPRmH3UylznsBIyTNbZgzUwU2WZfDsly9wzlQQ+JnNt8hXYgXI0pUWq8cNU61CGHeAgX8zY1NmfSblPHYeZt0HoRGyEJJ3nPdKsSWHQPXBnFxxnoqx9hlX/2euJO+e76l6a6R2Uq4Db/AtGatPgMkIJbfZHJv9IKmVv37TMDUA8nTL7ESlxeL2Zpcq2ZYVvPqJU8vhzuP3iIifGSX4D2D8xDWeVtzKNGOXWQpvJayzIc31RT7moj1TWph6uLHfU98xNa+u+0UrBC+QB5CvhRHCEBtS5jWDriDWy2oIE33vx14ngC7HX0wPqQFBaxcLJnKXSjqQ2qEBDfTUc/5E2SWT0VEXBdX5mkdqfYiq+mlwRT5vdbE9Y/6dJ4vKZ9WRkKUgD1x+mSEE+NKwts7hVD6gyrAuqJ08Dj3gfg0XEteqDjU7DAyeXiugBcJ10+ExgcmKvUuKgrCBAvovWzGQytuxbln3337BS3jOKdcuezsHIYZSa5IYbXuhtCmtLK7U5VBrglJRKHcqJ6MFHIzC+QhYzXbo8jEqNLVWzOBeNzL5Yn9Cd46cKg5UAV5YxrhAKQHSicSeLU6dRDkLV8XNDIEeYb90YhxjGlA6ITvlyB0b/f/WI5hIgr5LrD30LoYJM2vbR4Zqoswa8CNl1aRUGV5+Rlsr0j+RE4DhEzTktxrkt0AHFg0tNHqE2dq99q88jmimYhsHgyzEEeFsfY9HR2SsJwTGC5wgKCnEUz+D129giQNWMZqsgYz9TZAyXlNeLWGthdMQD7qzXmLeDh/ylpUWftomDFldJQvwG1Ev4K5im3l2XCJjBlDc1dVbjEghXJCKbqKZyjv1q3UhpiSHrGiN2+DHNG79CpGNH1Xrkj0VM116y06WwYcR53K45vKXuidPzTbOfEF4h8LpPVYWMjWwZt55K6J2AbsCKn+urjr30cCuxcVnDOh0IUW8gZrcQxctfDOpopfQi8d2mgB2P+QNj2AvPreqbURGLOZRl3hCDV7fIpby3yMn6vRJ3P1AthG5L42Ci0l4jKGxuTB8ya29A5aRgd2codzaGbL2C82leIDQ2DBO0RE9auuGoJ7664BiMcxiiYG+33DbALF5AnPqb2GzzuLKciwofVmvDrGBbfLmfE/vUmd6F6A5WUXOdhZRxHPyyMehPNXLhdJ0P5SD5oXrlRTVIIpQBrZpOaYXrh11kApA+VbPd5Ehb9H67gRyBgpEd4SsU8WtRb21bcgOXPBlnHIQhcOS6LQ3HjFouy+fB/ocBE689UB3XNN+VNbffngQRKXUOLdIsx+3R31Q3CE53oMZuOBzCh2GX9zSBOEOGyU7hFPjB8Fdx6ydA/8OjqqKoy6S4IU+xwv6LrsJg0OSp0oJhJ6GcPYscvSm50MYS+aNZ1eHK/adfMo1I9ydkgYallBvNugxbshPwMa2FoIcawRTTntWTd7ksnS7/Hm3ytNQeCPksO/wYJsZAKAy6snZqnm9uFn9unICE5oAlQjKasASWVc5KlYFkOTYAhs8b0wwyUI9YXFk8wSG1sk+fkEbgzDKAxHW+QJ4Qa1IHFqepk2UucoDyuHm6A7vmzKF2OFMCv/+0BE8haBB5ZHBtfpZjyJ1FayaWH6bxPNYkdLmKzbLm323AbH4sjv14Hyl4s1y+/aeA2tUzb1rxo3kxWkTf0Ogd63LE+P3zOlsnrsJ1gtCywhH2SIyvCIziQ6ZXfGsMUV02W0GZiX2gJ1BrvnI1xb9c59AOoiMaubWbsaMij/B7g5xEOQBxaXQPAd0UEHQKifeepbk27dScF1QQNGRB0Sblhj6wydLOmqWXBovBNQn3nYo7Gp4Y8lZIUjRfqmGRgq+8yGunbN7ekglZ7XBdwysOt+F8MIU0giD0mXTsWeAm61aTwvd5FfGw7/wW9Ww091NsZPZGDiI/OBeZ4Gi69mRAIrirJPYNVx7EBPLeZ7nz9nyjWNYhKqqonhPmMpOSdSUIQ1s6xTojhqT3QQiIZHr5RK/MnLQF+G2muy/YTeJsa562SWp53kfGUeFHpgTcyIb+kucWQYS9MMrzvEPi9Vf/basDTSaHAqOqDJ3qyi8ORfZzXvGbv3kbHQRURiQo7fxd0J3b1R9xxx37edogci7VWsbLgpzOOd9RtyF4w4MY9tVZ9B2ToYtbCZmziPGcyo0ikRPRG7rleaCkxD6Tw6smUmeoX5BO2HOqplwoXwUMOs3YGjsasLE1qrENHkGtdVJeaBRLyw7Ta5U5fpHV4VDmhks69jh+f4hDZv2KA7nlKMePsMsXhPLYgx/H4DUMBT3hC+tY9VlAb0NhyTEtepXmeQJ56myl//3DYrqblpghMON4fdWcwVXmXJ5juMfuBaCcU0AWxaZ0M8eH3fq0WE2aPIpsfKcO5kLgi6tJo4ozmxShnOu9eoiohicWQQ/eZfEQ5VudC+3Jbpv6GpKFSJQP6Jrggs2hXzxv0N55nh7E+3gdSWqy8gLvFXszRudyUWSOlRSAnOGkmQE6JlncwdFPNuxUF4LVIc7gANPIwgxLjRTFPCTeSvWmD/FgKzcIFynGPmdYDCsc8fKt9rtqWvAkPn4soilMVJ1f7suW4OOmowvypvSR5lVRh6Xzld+VUghO973WTuBsV7BHzu8wVRfbLo8PCVRsZPx5MrKUj3wWgNSh1WPVEKo4CHs46YsmRyBfOF7kQ43Ok3Qp1/AwKn3+Z/lW7GjlAj72V5bjm2E8GqF9UyTfS6AMnUv/AGCzG3XiD/j8AZzsg+/FcW5B6RTSayYAL3+D5hxLxWcYD68TM8PsUKwyXO0c5pZCx8BxHrwNWmvCanky5bp4bKdY4g0XusKAp8cZDLITrLz5aItalDbG7kaIe7RAq7TNkj1wYJ5KBbEKuJSMYOSfxNjGbJzFChBXysWO/pO+2uPJm1KBgh+LiBntP2eAp5SUkblMBeV76yJY3RIw/BGcJ5OiAYI+G4JIWouqti+eZugIK9DxBcTmHR17RJwZ5TMAhXZ9BvBqhsqYWnz7La5Nh8jDvDdUfjyDmRZP/4gHKw6LnC0vATAVG446y2y/EzmJJ5NXXeDi1DY2o32Aya4KAoudYbr9FvZ2a/7PQy0Kmtxb1G7+xJw8Bt+VVwpvXYJrllfz3KMv1NYWYVLk7Ww32TfG86HZeKoVkDkJgfrkAAMjsKtQ+2GA9TTbQKtOjTdqNaRcM6RrnB0sYTLexK9npsE6oV3rINbGEvx62r0HCBniTzb7PT6toXEJao2x2QgknzGBgpd48xjANHak6lHGzmWeJslOM3pssC3k+m+t0veSrhfwD2bDtGh+1hO0+21aow3dQIfSZYVrwqhvTq8ui72ETmuYYyKJLpESm07JZrt9qH9GX4ej33q83m7ZujUsh4DcI+rWh1970iS0vCwdRPd01hVqhN1yP5ARR5he0IcRDZxXPVf+Bjuh/+ebefzpZFk9VHoDaIqH2MOM8XdmKVHp004EPCIizfDxj5gHOW/hy+Wlg4/+b2Z7SVNsZNGAhWS1OUUFHmLCpLQebl5LrLOvAi+XWBmCc12hlXzqK9unVm9tvt4VfeUYnF+xZf/lvGUjz555P1ooong8JHvudyzwHRQlp+heileCvGEo/kXhPTS+m/iCo91l9lCl2MuGCanjByT89dxu3dVwc9I/+Baklh4mLzFOrW0eGgqqqBff6AiWkpaeeEKwZdk7DTSZ3FKQUOVbusb2B+KTZn+MBh6rdtJUEIzCQrbetJwPjgEu2nE46n9YR8/4rdSmC2UgXqyZMt3UkB7sgO+NpSWNMLF6kpGtbH/SPoOHQgNr1GJnNQ1uBl4OQldcTquiBhc59fYZ7aqMXorRSTY/TgTJ4o9REMpDI3IufHymGuZv1B1JNb3xWOK6uTZLPCs7KU0M64Ui3+j2kAuXiSMYNWe895+c3gafDx6SuWXrPwbXpTKSME0pouVJposMXqwsvW0MlbAZTRxbfBP9kx7pK85IRK0PhOVBqJcnL8rC1MSmQEekC3hSCBrVIOF9TVuCQqvkbVwUEaE2kmr2AlpmtSz9wWFs2P9Xw/+CfJp6Fda5MU3bOHwJQ4y9oUIUMHgXPeB+ExaeFggZDFFYTJcsH55Mk0F9tZNd9uGN+rP9uGE9lfI0ht6P+hCQ7nG9R6lN6oieEj5tuBFDImqSoK1nqsB3djKYn+4gIRyDscyp1Dp1oWFWBfifPYJfKts4YpmLVMKXXIyCFJyIB+W8E5w8wkEXBgutxT9ZuZw5VjFyPD2m6dlMZRAB5of/hLz7d6Uw5RtdWF1MfY2kBAq9uA5vM0DUez6z6+zMN/xy09KYWuwZRonvTxBIEPdkc2Ir82dRblq36JrJnmkPtEpOxYrvmEIA4yT2tf0atAjnTGJ4YI/6ieW2C/QaIXYmmbPgDfBQ3OHnoOwshKPhBMeCxLDVvq9U9FFmDZAxkIxFU2lj3JTc8NElOhrGGhl+5v1qYXXUgF9dS9mPgP5Ybb7iXBIE4XuxYp5h+IxyRxjkeL4dtdc+cQFthUiWCHhbhoL93b3Ti2Oj7IfITU7I6+YZG3QMhCaKiqHzEUl1tCa9exbPc8GtHNlhR9EU+ZiTMiF7gU0ACRqrSgwZG7umbRCCM1nnOlmpgSdUwu+i+stP1B/V6+61zv71/iae6ISi1/pwhxGieczWkMLJDfYUULxabkt7sxd7atj19OAHj1rFQmpdFTwNyHxhC3ZxvUx0kmCqoy0Ns42TUQk5pwp3/JshPP9ol95ZUHllUWIQlDifNcaQeOBzIkSlU/r0/uxj9JhQ7j/QvdQx3UC5N8dYmZ1dQALZyemEj3qzETTzGH7az6GxwNASxPOmGFxbW5JbhjlEJKytFS8gcUG0OBnAkwmoD162aa1EuMTU+XPAx7q92u+1fhMQ5uLraVDtIwReHtcr6+apwRYEMQgMhpesVCKhr/EwPvxfRIo5MGcT1le6VA0eI/gwRMhTaR0hHN5i7xoo6s2urU0rp+G4iWKxZHi2c3MabKLo2m3yTgpiuBh0NgELMuSe7TisCNaKOx9isO5uQjyhh8RGOMhIO0YvGoMDeRv6JMuNL5UlafEMv3jy+BTPtpPfBm90vzW23Elu31pTedI9L6ffs94fSlCx8ajeB8lncuaijn+2P2biZ9meFMtqNncDWZv4IGjjZF/DAGw8vSEXU3a9zRzyO2h9FinfCd+MerSCLuGo7cj9ORhILs8TrU9jsHx+8xbTn4KE7/y0BNHmxrjINNWEymz13xWbIUFLtEl/4bwT54OFX8IBUVQb/QF4Vv7uy4Gk4D6HFrZa62tZHwgOWsvdgFkgNXxdWRLH9Cf5OuisdMascXifuZ8qoQOnLMu5hmg/KzVn1qj95MquXFrib4GPDCWitImyOO9Pcnq6AIpzWrmos9IT47TMieyvE+sqIVZYy1EZZ7+6rRXJUq4LdR3b7K5hYpzXPE97V8MV5eaZF3cZYJ5VaH+8aqbuVULG1qfKyOvuJ2BRmzoZYCc2CyI/oaM8px+2nNoyp0tzC/3c3vyWn8XdkgPR1NSoBfADzBd1hE9GWStRnn6svtpunY7bO04Bsayzv7h1EPhTKUqZ5r/HZ5dafxIkxLEqrBeLcZ/YlZWvb/vhWiNUi0Dm/6gdmvBuwJhJC7QrLGvO7yjCIu7ePkpd7ZPzpFT90Pd4piOiCBhKlyk/hAZZuJd1erAuTMwj/rI9l0m29KTO6cABeP2KUcV+088YkfhM0Ty58m+RkvaxmriWpNAkryyLkqVqLEBka362zJEqSkpkJyLoNEK4CxdUDzfAz+0IYsAAaCubS3Y3oAOJBkYEb8e5vnR4QjJf0cFxGpg2RvhCJHOVV/lI64I8p7DIufgVSZxOUaNsq/VQOGMBMjZhwglB+cHAvzCw7p4IMLybvvfZwpksLx0qrUWODMdOLHpCaXG7wmVtfpGlk/SKqJw+q2qVM1IdUvX0dPanlF9aji33v2UUDo29rq7J/MVuabybsnxN5o7xEFTrs1npwvRh2Wj7JZUcT8NUweMqSxHU8CttG3XBuZywaWMPu9gTUvaVWJOSgRM/ajTd3UI9NW1R6FgijxQnW1ALH2eR6eGWzPNoY0gptX5NEMSh1InfbtmYCw7yRGDtCotxeAFCfHC5W35glN1D6XcNXXMzhvrmKGS/2KLd1+Vf9BRThwlz3c4QWxuuVo3Lb5OTbLai6YWOnX85kUqqUjr0ILcd1I7ZUot0r+fYcsK3231PkNUalW5ZZy1xVZtEm+Dei+3U+PeLyxWr2aii3whDR0v0ETSUoSPfINGyxE89XFeZDVGgQCA4KzNsUhnMhrKtjoOtZwe9MWJh3idh7/+Zh1guKSd8hDLFH+npgggRwSLIiCLz3qjbo4bEv8lXtbnj/oIhxEIu5jRBz3y5ORGeW/4I/7YDi/D8Emzm39wvsYiMKIxaALZg7QctAZgnUZgwj6XSMHIfBhgieXBZQSYMBGNPaerI5vDPtDVWCM+OmyrpQpuXrGWzogHNhqVWRTfc2hG1vSKdniN8J0B4NXZ2e2iPth5pfVfkKqvouzYlhOMLp2nA1ynXT/FAJ+8VxzTy1aPg54fBRjMhthsNx/L7YCGEZI7JssYrSwstcbd0KG2ave/Q5czqL3jJ81Nh5WGj03X0zwlr6cuHme1mchbha8VYimHbR/s2pSvEBx2BJsfIaaq0YEATq5NbhNlv0+M3yQXRdb/jzjTllVxyQVnzIK1mjJh4nmgnwEm0NVsDaEBau9BpUhp3/dsmnJVNSKjO8RLSbPdQiZ9SDqaD2AjMnliXE58p7OonvvZTn6Xm6rs97uodkiOY7BRIcqH7u4ktomxHEYa9/r+EST/gakhiNx61nv4x9Cbhx357EdEICMTqJORFMYNvWVBMObw/j8JqR9qkF4Xjtf8Ol5bA/TEirkHFFC0MdIclSe91DlclVijQ8JiNFD3AtZax2A0W3UMhBSy95qkWVqgdkSwqD8Q7gwkjZktwdgs1FZ5LT92rtQkRGZ96iD65lmB9HQ4GpI1UuK9LbZCE0fi57KP5gXOmj9cFLGOpaCnxQ6lijnz3oWPMkLB5ZaPZiAamIksUVq8YhbhEiY7PHXI7j3mI2+yN5AxI1jbZntRHnv4z9sISyI+Ewqtis8kFu3yVRQRerT2Domjky3DnuEwKvxLoHjSV7yXLNXnxbPBlndNvA6qHCgTWivUl8JGwjATxrzfPgYprzQ4rpeyGk/CLy279xBcLM82cGoYJ2cePXJhSq8dkweytLApIyxhoCP2qVWA4eActUkPPup17wbbQLa3jbloRyc8JG3p72yIwkleY2pDri7qA0NBP4sKuyKGRhuulKKWE6SuVFqeAK9SSN4xal2jbEFMGg8p197u1miWo8NLLDlNGTQ3R133xxYTpoWqOySD11CU1ou2Xd1CUJSe0cto7Aw/hUz1vaRU2gCcpzXH2I+Kwzd04kxGnw8iTHIMwNgfwWq0hYCRuiZsXteQ5AWPkRVMuNAHbqWZHIIK9XhxP3U1g5s5SbgfzVdbyZr9BTuNaK0Ibgjs9bz4E5bi96evVKFJ+Ya/L6chK1+cJB7KU0slGsz6icPmwqII/BALjNe4lkngco3UASYUEPpmcPJRA6RJ+ZRLA2+7FijRGrv6nMRl7AzbBcq/tjFv/PHXr4MI/wCkUY6TH6RQ/9i5CHqBDV7VsdleSfhM6gJCviKykkNyigZuX1ayFqjAIVY+FIpM74COVkJbnyPDnw5QRlkUMOKHHcUoboCJnneUp+Mnz5kAqog+wUmKcw9IO/m34GkWjwsd5FlUYmH09cIbhrnBUR/ss8Z9wj9NPgR+yvNqKRBXKWeI9Kgx8Tib/tNDExejj9+e56e1IgMgcxPNSdjqo5pUPRfMaH5PRmdiEgXjqZksCfoxE5BMnxA1pCXLbQC+8cfpZcRvMmvfLWQMfEyfOCJQ7Z7HdBGQHFGMlNzMov5nIvO9O4xkvdu98IL8s7u190kym197Xzad8tAF3l3NUlEV9zcsSANABRXAMvN9nhkeBVM+6sVJorWa0d7gkd2wm0d1s8CnHL78WllSQJiNGbGfqOyg4arEZVXGYopFnPY4Qsw2BNvKaMW4//YC437iCjmVyum5nxIw4lpLhCASoNlKLirlfplyZ1GFXDuU1iuuTzIhFIrzJfB/EbnTAymNRvr3cgzTkvIz23P//A0x9EdsyIwbbK1Sj0eh01hmenEY+VVa4T0zSrQErFtKPXd7syQ+9C1cxktMS6aIAw1QwrEhl+hzuHCEqmXi/gC8VKYJP/5Jvpr2IERneNJB4inh0Qr4Me0loOjLcfKVtslqevApH4gJAadLirge7rxSZS4hD2N0UxF2X2WFR0MV1NfeMPKf4iIETZsgVKA6CcmvDwsrj7ecbdC4GacQuQVCbS1XySSwyKnlgPuA24FprmNMVf5psigHVMtELKTjs2pkP5KQpSkwKGciJ3tVO20ncsY9SmrK1rYXzdJYnT4vOqzqeKgj46ePnDB2rLfUB3k2E3zDsGMsoKTQR9fBKPh4pILcxvqIGxv2Z/h891hEVLkUudcWmdrsK/mNBo46ykFcsl5pv89WFW2UJIE3MQETE0gNvEG4VJRIKTXlPKh/arJyPg+HQdIL6nn0hrKb1Fbl/KhnPZn9QIKkHk3tN0sHjt1iY2TQHy4EnmEA3RMFHL4MzQC6jgnbpSp0DmaB5gTwQQV8xOWDUj4zUsEjW68kIDuT0bvO0g0hNv+Hz0pFtoVoG+0fySEWMjN7Vc+Nr/vejmRQpuohebVSyzfuXtGW6BBNUf4fiGpRRbi4Fku2QUROi0h8eD84dS6YO0PuoF0eBpDezUI8xnc/fJ0lLGQv9DHACLCpevLG1p+H0uLY3PQ2b/gAabQT06X8q1EMCpUwuLxx2kdkbc4nA4Ibq3X5Xm90ELJkN/SqfdJqv56HgYFzpr00Hofy0V0qQ8n+BlPYPMe6GS0UPuaNxEhfkvbvoftMTWwgJBLo//vsTwDxYBCX3EmfN4KRajYLX4Os0+/8ETrBuR8l9wZXwSOnNsp/2jEz6kKxoS2RKn2BBHZLXqBEbz0v9KVXzoM+j7JZtyqk+7i4KWPgK7WLiSy6lJ3sZEKm66vtBxLPqBb3tH1n9laAQOX49xinMi1C+IKxZ+4mCkfwe0NWoQjjVdAgAQMXUwAZ4//OXvv6aOojI/fy+9ypXepUSOFDqz+9uhypdoSBjmb2HhqOO2yeDCqlbvkslHWiHZfWkWrVZqFGhSsckHZA1j693EYR43W3mO0caxwhrMvlSbhniosqX5IrbmdE37MR5gcTRQ4Qq5+ymIMvYgA53PkLzEECPXaicpWdYJ1qPCniu/G/VHnKqlQPOSlB9HsdgHs3ZqG6wge8mCKk10UBzyr3DZGfsI/e6zoY+dN3JzO/9wTmftHp7EPzd8xQN0lIavL+JkSkmg62/G1186VtgLnGQ7Ct6rmoQ+tSp6n2KlmOdqDfEoCfLmrwvQCYhCUKIgrJhgmH4vNag3bqjAAPR5JSg5WbfLZ8+wG3wcvuCroJWscLnnzs2/VZ9xYH96LFiJS/zlAtarA1uNnBTpXa9jn/tJfRuev++D8mtQH1IEfCQEn7RhSad/tdUWQgT6IZAsFdCsiOikhVC3l58wOBr1F0Y4H11DOChOgkuOEj8baK26jCmcejWDPp2nYMFxttErjP3YmWUUZAVBU1yUHbGsqeKNQ5MLeK1cE6VyR3F+IqwzNfyk4g0lkX7hD+Kva+nEG9sE9njYEv1Ppb7D70CZePZpHvcKpscVPQxDhF/7XwgvgnmD+XGtUJ72eeYFEj4HVi7GLNCC4dUvPLRMMmAZo0lPOec++ocgc4lt0rlmi43y3qSCZN/b7XnvmwyzPVthWW72wPrj0KCd9NIBNKtpWIeB7vgiX7TWiH9UP2hcWlR931CcB5Vx4X6i0/JhJCz9ou3JdRzGkupQI7Czg9BvKfphIJDzUxwvQlkUNDyOEobTAeJEtiFIz+XDgQIsxiztfcwsp1IK2Jto8eDLR7VB0JGOf0P+tEBda/1Dd5IOZBvKleJmznJlmY6WZLHwFU0zI+jVV4K5F1WCfunxAp+hCLVi2hc/iuDgdr4WdU1lxfKqhJMLY96tHDqgmUuNAvg3QepK6DGykx2dVCviupwsfDrevEWHf6tB7qJHrxr+Pf1Gp6KyB/sFzPpir6j6aNfiAWPlaktkHDdA3uued/YEie5zzatcbGAf2bNFB2nx8c3bPFtDndj6vBqBDJ30CbQdisi240aR+2MmIAkOpjwWM9CMH9yj7wFFf3vzFshLAzmgUb4MfI7lprbEWaKJ/yfmLsX/ImXBnK1oT53NRYd5ktXkJw4j8AjtFndrL1WiG+8Jax7MY/R+Mc73WCrJj12fZOs2UByiThqrzTvUxX+lmWwa6IZnW3DZTBpQ6Zo/a1hcC+52m4dz0JaxW+pvzbWeWvJJGhNEBl65wm9LFqYpE059KLvGNWE4rufwmZsJFlYYDl6OrGJ9+0SURxmc+HzU4nK5TUrmFIs3HQrsHb94nn0ZYX+bMSRSpHnbNFNABj4D8k9VVaa8VbSQxbt4Aszm2DdvN7oxjO1ORwnqc12rLklz9+j4Iu/03z+0sUlAxxa75WWdQcN2XdvIVWTtCMnDgD8zugRmBVnyF+WWceHDGligMHaMb0qQviVoJk5UJVECTMAduvzaV/3fLi1XEWmdqgfkKEYcumCpZQgB7SiziyRkJ9EsQQ4mfbSDAhV9FY7RsUBL6Zl/5UWad7Jb82s1ABkzcZmU9yycLOcM7igJY0/GFmaOocbJOamTBGug/Ku5P/6gSDNLeh8F007oQrocTu+lxVpUQlTJCoFVbMVlgjlXDKq8iZZZZoJwnSk/fsSpWRAOq2PMXfy/c7lBupYXxtNIpS2uWhe7etnq8JExx/HHciBBk0Z/U8qJ+8GdE6R3qrxZc5Pagx9lCbE7sM426mNXqPAPn6xYSKd0XaBXvP0BCcK2uXvetXPwIJdkuBt1lzCiO/N495qgqX4IIDKEH8h1lXvJdUXu43/XslOzTgFssT1LtOd3Tj27hqm2+j/oRr5oq1miJaipu5khe7NR0BsRgZOd6IB1LvDX42l9co2x/zdsCDl2OVn20DzqUFUoGYyjSvCx570WngeH25HqqEm96lJ8QhMv95FsReodHuNHbBFutBQjWoDzuLTwRkE0WMLEgm57B1jlglL5i816Ffgh3H9wKUP4ewvfyFFx4xoa0Z+gZJBB5sd40eWWCBSUVra2kwDIM35C2NCEkpKn7clxKh3kHogCv1sgj/6te1UPDTvRxvILjHJJFo4oUmOfNg5zkG0Vx4B/Lt8lv6E2/SaiZZOZy29MlH4C6rzYwqSmtMwf+r85lMZlE0hjQkVami0kfV73GHdpwMOBCWdz/Xd+MVYuCx5Vj5pMf4dtNjcGcHS3633tEttdEcUATWQunLZZGZQeHWCUdYxD1XmTT9r3zVQ1allFMBa51vFw/YsYIjxa258bdcrNKilq+Wj/FkuQk6cNU1YS7UUz2PdDCZ1uJ4ZBLhbS0uAhgubfxOi58d/SC5jBc5srIxXod7sFVEn4eSeYydiBIs0oqFR/HAAbsU4UKWDHqRVaR+cp0BFl2gsgBhkP9ohe9oa2xsiLV1pUU6/2S1a+XwLCqLGj2mDIWt9IfQBBKzFi6YEZnzb+ztpzyDxKyW1OFf64Pc1hbYlZmK6gS2S/G3qj1++qwdvNxGYFPvM2IH8k3Gd9lUs+JwoKc7gx+cRrHL4o0i6/I4eYSsivjjPEPPnw6+hTEpjfdVmj1/Mzw6EmLzNTEfDMp8vQzlDQl9kfk3+HBaP7AKDlO1RRGe91xRkbJT+GGnb1vbJb2pOIeYSeySMDGPMqlDjLosn8QaRA17fqSzq1PNKooYasjRYweornLUi+vkbDNqZF2E798Ryum1vBjcDPFbhuEP+0eURbhlY6UmIA//kYwibaAnOKKauvdujl9KU0hTanOjiWxcObY4H72l1dhXpJPs+OA4PVmutm2sM3EO1DNSRDgKn5MNAZNZDXjalOxXsl75BfsjKQE/9RglrqcCF9nc4AOEi8cfpbZiQ5USCnmxSGYuDu9n/KfZ57WyyE1eiSJnwa2lOsmjrL4P31A8BvnK7eZmLp7TQZjjSogr9oPca0bpYXRZipnR9adlIvhvNzWYIrmVAfdAwuzj604gYi062n24dnK7sVm2WpazeOJfgYHFzJeSrIIECq6I72RmDTS8TojM3AS12TP3iNjseH9dNWj8O9GLCvyPthuQMvEV3uTV/Wx04DzegoJhwEKs6zwZPg6kZPiZ7uYvvOYlONRUMb1tyAu8FOgu6lyk70xFwX/Lf66FlBa04Kho54XaLXihiO/hHzc7HlmCNZrYgjKsys29yaM7lZBaQAurOsfZR4wNV86Pglb0Y2oiwvAG2T0af11m+9b0fccQT+Z0i6VAjGmAxz3R2HKP3IcOK5/MBTvn+nC6dIhzkNfvTn8cRDTC/DSTxVi2TCrze8+EFbRwrBGhmyFj5nSM2juLlVxsMrVt4mj7Cw5oEFueNYM56rBBqjru2AmwNY29ogFpFxjvQ3PkCf87TdGY3JtMhKEQmTxgIU0kdMdAuNc8pB4vwHfo275p4yOZoobeRZCfbRWG3INvo8Dti1cTKIl1AdC4UbI3yNmJj+rkCM/qU1I3IG9HKfLmpV13v6Qp+58F1pkhgtfgwQImXE1QmSblzovgfQXW619LhA+qArJfl3r1NOwhbqP1yQLJdy1TBDZVcZTcaTroM2Ev6fFVYKU1CCC7DTHus41hQ88srCT/lcbA781DUlDDZN5KwieqIEDNnFD6u1mxC6xMIRn/hmfUd4tasbpDerkZBNvxK8qs6BAEV6gttjBtvybSDGvgbEWZMLUef8Uui6UkmFEui6zzb/Izw/8SWwBGwguFRDnEM31qa1BTWDpqCO6bIXlQVtDBhBNeqTtyK1bms5QYMPApAxqueTv5wcND7N08ThuJfNhcHFraqjejRruOSuLvLIO6Pswad+myBjknVGTSTaIl5aZ4uynTUlIPl/9yw6hwza80A/vBoFqLrHx+wNx9bubNyvFOX5ttE0UWOJVb9+CcIDcPr+YV2slfqaIFcGbBj0pCGI8si67RhWdE74PHHwOD6BHu58Z4stHvRC9HO2IRm4T85c0bHJvKntC6XE98/r/cmjssvRanwEDtD4yijLZ8dxF9xP9r3EBEwxGQEcBHA472T3sW5rXpTk0jYyi5mFKVwzZ0I02MjdZt6Cz34vANPiQ0Dub2gTpwNmZe+FaetG0Olx6CF1oSW/1wMhPkS4lqxBXMTMIf+/RvAea+qePBtfdWUk95N1R9hFh0XhpEYxzqVTgY6HVopurS/kPvWSIEbWXwa+XS5KGwa/yGwyQ2jF3fZ1OtYbMyI11LhUPIl7WN0WlLXKdIbWMljCIPwueOcnkDDGf5Q3/BqpS5SeFeVgqtbBDs/uK2QZ+qqvtaF/4vvNWG+r84uu9Al81/jVM6O9oViVT/6XNTd6Qri1NX3iYDrPxIySwGaiQaW0jgjOQAqoPFwQctvCkoe4ecQk3Kd4m+7dD0jJPverecpQhNF+9YqH6IB+ZCxQJH0Jn6JzzgSx48qLMtuLAAqndaE2SIvR81/La7XdC/NfuE9e5I0eFZp+IuRGjq5QkcEPrVTMYTDjkJ8qhxCwolXy284XwSAnPpzn6tAz7xTEvvKpRuOntxVVsZ7OaPwUx0UE0VcfO+FfP9wjO9sFhgxmyQ7UGQGwbrY5JJtw6ZiikOL3FeYhOnU5gMmJfJwofXd6DJp3CZrtJzEiCv93q0MiGLBc03e0m6/aju4xyn0ahlTb9rEsxqUTSkB5All9PoZgkbdY8tzB3a9dyXmga8RnGPdSF42vFhWRKq17gh8WvZUQenEJUHeidhUyjJkw3MsGgrg9g+nnFAF91G363mkDZDWm0184a9rmFVYEpFBa4fszjnJFG0BJ6FLLsAoY6610R2S0nXcgfWmSIDL4jEfCiaafQEsMpRDkcD2CzkB6ILXrfm0HqgXj2dcBoabct/O+jK3zySk9ttd/1Q3zRPR0NYGTKzW/D9ddcV4ngbnlgNoFCUU2/s6Lkq/dCwrA+7zWM6g7ljRzDmRm03YOHV13hjwYjjv1ljbM1pLufdeLes1E6694JF1co1hIJwyl8BdgLkZps/ANe/bde9VK3Ygu9AC87v1d14jf4ggZf68zpyS+HSrxO2EN+LOz/YUjjYLxeYBt87aTAlFLGCIktAa4Ff0vMp6jwDjjmq9achggjYot+lIekKZvKjeDZPuUdsJZDOaIn/VphkKUeLEfD8Kn0cnA7c6tL3nLBghBk7SMiCybwbYP7wLM9hggL6+xwKsmgNGf7MS3BG5plzQZnxU7EvEdKITIvMJDna0+bORGgFjg9N9V8PsMPDISLph+srgOyK2bvM/B3pAjWMOEf+RhYHQzlWRZQFV0Q4yUiFCysqIyv0SYxPyHMKKu0G0TUxQY6OmFx1F9IzvU3EOTWDuU+RviiIpIKdl4w9Gsjn/elmCTcdW5gPn/MDclDIRNY5vyl8dE8VX52ZLn552ucl6AYFqzTqS846fTQS9n1P121c6vgAsVjHynijYnk/8rQQ7IlhMSPMf1J70rw3p+Z2c7seJNqL4Xt8aDqzl4GW6999+yzc13R137xO/TsNwFz9VjCgQ6vJ/2PO+UCvIAC6T14F+FYuSJi3EM1BT1YkCn4Uv/eFEp8yOIy8+0vDXvhkd2aorqU23xQkLYeN+gqbgbf2fTBmVy5uQrBYxwl13qnll/PrzsSW1EO+Y6Zew7CyoT8/ImcwFNs7We/JEBKjLeadRSgGrWIKS0TefQ+mgAKVy5GH73h8o/5l22b69zYNRFEMVpcNnYA3E0ETxuRsnTEnwuBOq1CnSkxiT0L4p5mBNDaFRA8p7iGuqirupjzmDpxcqlXc8UYKqSCuBK/IQTK/74oVBDxwxMX6A5lxYDbGDq3FcLr31U2CyfbIuq8safXEHyKWBXe3+M96q7Q/ZHCIbaiA4uh2bUM0BionQiRXIgFK/2HARjSCLFdyxdacuDAI34WyD/R0Gjwry/wLHCRXPqJonfoloF++eGKs9dU0tWFB4i4YyqbyC6rA9eDQ+3lfkpUjCSBhe1jon/ITwX9iqj7LY7zrvxpjaQGTHew2r+TvtqGF9bfkidAlcKo5Et9bU3wz0pOudhHTngeWotp8o+5rX+YbgBy/TklVKIfpO2j0xW+6oZMdFkfhgv/3/JFepN6zUyYaS4OZoWr1pxuCOU1Db9lCo2z9tY6dqTUX9wleIFQpWyWDiGF/Q2fyo7BFctWKqzHOWq08uUyaqk7HRu3G+SRD+hjShPZkdk0lqxFqRSnC6KXWznNHD+L7vXy5GMkiQ5Id/Mngtk6BXcxYs8h9lUiDsTaWmvl0CG+okcMlwxkMBy3nfKXPopNVGsmTxPSrpcSUahDTw6cQ2KYTLTgtKjlmtj/onTmzZtOnTd5+v7Viimhe+lA9/onoMAhEKIE5Py6IINadZPeohT0q7PXed03lrjEvEcUXGrKwCSgC3RcWiWAYu4iMx82LT4C6XvWFHqDOcm/49HNSOqOOWDBu7fdHPuJHQsMZJ3PZp5LaL7+/mVWvphppG7Ts0yNDDNnzeFxzOoupUaf9jJF707c1ufTRTnhURaoUGxrcSTgk78uKTItTZnXvP5BJFWSRbCbHfDOCzpYpZF3nO5qMnG/7gy0blvw7hZbf9Yu+ZvbtVcwEU+SGhd0QYEP7uMX4WezOMnPsuamY62Q+vgDr6xEiIiMSI8DPOezHhvv87F+PwPNS5E8j1lU6Ur8FiOeBJEJ6WEiBn8KUt7LKkaIixd3p3Zm/qEJUqVioSyYrPGFsdc6KIbjPW20Fx8xsSG0Bx11PYMWEAyDQ98JepiBj3A0HR5sJrcJPYF2wBuiUWnRr9ZlO/HuCu8E3ZKJsDVqNsE7mWlKLqkLhYlV+VI2Ry4Lew8ov6UG/Oc3bkITsCe2O9uXIr7erh/NNp/IfQQzBB5MYX/VwWpAZGUlbvEU7n+93fVvQjkb/j/UgEswxpVj1QprWct00AdnlV+U6Ra0taq/evi2zTDH2WlNBJZuHWa5YXzr0QXh17XUyI5bL6lR2r/g+C7ptOua1mHMgffy9/9MFxHjkW1SpgCfq3XNmlEpGFDmMjE7gmpniV49Jer7adlcXmliDkjEUV4dbi4KjEuDShT0gba2IeBVWrbIlS/uCh1w8Bq4LHd1uPMLtcPJvrRuyTAsyc3th2fy1Lbi+GNjGZH96Ws/1uqoGr5EANKybpRiTqQTP0TdqTCdNGyc8FCGAk5OSdQX/Gmd03ttiB9GtwLdfUsoLERhiXjy1fjZKvdR+Mlf3OifHhucs1yWkM8N3V/lmE3zQ9gUZR37rKMXV3CiBIdAdY1dP0fNvqoI1FkIVL7/RqS+4w8HWX3a15BI6nkagc1oJtch3zXLbQpRBYiQe3/QlnUuaWT5jV08iwJQDVI8yODPbRgtQXpEEl6PM9VR3v2F/hPc0QTPRvK2dYCf8k8+Ybmlv/US/tSzgIdstc1b3mPEXqoyyfOLgbf522y2JmSti/80mnY4u7ctyrHbaR+/W4NCinfm3Jyi1zLE6ZjdadgjXzQYwCb4AYK+M59pMs6qFJQPmeEKIRlRjSbgt6C1tGHCFVD2tRdal/YkpUsbdK5lFX2Sucmktcd0rBL9v70FAOaEYbEUmovX/xxNDIeKLJsWSJ7VIhAeJc5oWIqB//kaoNEPzVqSsMHz5utw4zYfPfwKr7uMo+ngcDktGd5RSTyu+qXLcmqHSIKq/1kXzSHn0iREI1Ms5N6fUuHN5297iyVsk2pvTQUwW3P2K1M7/fuuQxGAt8PJFsuRN7kh8G/N1aDdz0u6XjPmZAWdaFwBK1Lu15xyPP6k8dCksiasBB1mDMM9iWMNqSK3AZfBw7rRilNqLOLnaNdbTrsHbWgGU0lVbZWhqoGTFQilJYQ/w9H2d+rIEM7VNjLQnL8UTMHR0oBH1JoF5NSjWa+FXPEW1mUo8bDPUJ+dlH8Xa1je/XVpwRTz0LN8MzXAR8eaH6D3/5WxsYaH8rLRUQQ4Ntudz6I3yu7Th/MQH4lO2SvfRotUta8nCqSMb8mmrfu8tr1NrWBraUAN4JlNMr61eH46oUx048B/FNiwc2G7m2eNUTCJYlniWECkxDlKEgFYRlta8cpfUlIxNgXx33RUm4iT9qNTnOUXav1kBr037P6pLiBtoRjrsYWeaMMcUY/uVfrHiRvXi7OUBN3zHVauQ19phFGd5XEGrPHyMlLVm84RYwfbDuin+0SP5QT5okyDxrWyhv0mX8copigV63fgQEQ9qbk5aB23yst80223veiH+mhvcGll/7cw74W7VpA8+SgHIpfZpp4Wcd3gObKQBZQzvDiVGX4NWcO5g3pbB2wUNNpMuEiiGtrFAhkuWer0H3o6vPnsI7sgThhTyWfKPTCX+6KJ077n1p61A+CAW3pz30k7mO7RRkPQMdbK6jrqk0FrQkhd1Nmgi6My7VxPSXHXN9VbNIJkmzYl8fdMkL0I934j9LHD8w4DwUVMLEjcSIvOuZlmUyBF6SB1tgvCwqEPgn/HB0AqAiCaz96lX2o6kZWi3aun7n3ak0vF9ViI5dXahZlMXRNepfIR7oq+zOy1Nh8hJKyEiIa+fD4egbRFZcNQVi7QKfUIfv3cHPcnNmGaa8LqNFaHz9SdrefHOa/NFbvm4SKlHGG+wGpkBUdbCOkoE8ZHGgttMGRzbgRPMCpeJZRnIbKePJ7mKFuB2TfpNOUwkHd+zQhARDRLpny1kw0XBAr7z27ZCuvbUKeCJA4srwQWoyCNnrSYjLI0Xz0XXSeCPbg3S5XCQemGVBTmpClkbvBjw0E1+4BVDHZdVxuRTpxvD6r9mqPjl9w55oxxY3oRd22L4PbOO8bLWKwrfXsH3fE+6qche2TOqSVoMmQJFV08w/iePOwLw2b42+nAG6Ax0AqXcf4RSs0+MOigau4ToXSpA+3V7RNh12DrBEyjCYiwRgEagM78K9cTGm+htMUrL0avAtgpJHS7DZlavC5oMLU7iP/zlpcFxiuwuyl5shCP8HU0jb73P11RFwmrspxvSQCer5maULBeE78PjJbaD3yzh06yWrg6hcuhggwj1SdKFiohG3H45b6vQtDSNKxP5NheCza4S1DeUoajKTZfkygvWUDboHy8ffKyyg+esrFyKYqnmSkuXthecrGj26zSY0TdGOqXFI821O/MV8ZOoAlE1sqvvRqtgbg2NPatEGi5GNY3sEVl4UW6d8khf5JNQqCakEVglAVcgwuQ4RbLGLH6bZsFApt3k46xf+421YlRTFSNMGWtgagcXInujmCvjzM/09DMMHhBVA/FSuqc4OMYtl8xK5MFKJPGAmRzc+SP4DKp3RIc7dqOwhiTWZ9z3UAxOF2FXFPzCksx2y/oc145Fgbqy5Xz/tazrYTqFyNRVj/kK9n98DZ7Whty65KRACm1CDNVa3Vqd23DY8zjGj/Yn2AfSkMTxHg5PyycYxDJ2O371sP9/vShjh1xLnQlf32DpzehymCbH8G8bCWR4jPkKxd2rQMtW0ya6hPwhC3dgyf6lYyiTPE37q7Uuu5pGR4JiK+XZ+dNz7jPrrsPWDhlDEgoHUNmuZjKK+7Q1B0xtBPTraT0Dwv7MGuTUXcR3BcCeQmfmcRgBVH8LRw57zYeGbTb832rJ6H3ZajYwRRZ3RHhoywhjWuSj4jhkYanWnGVwv+GsxyGQrwNp4iI2KT1gCMgNZ4RLjOIe8b9K1zgRXpOmxIAeXc2lIp4bn7tUSiY5r6pXIlEcq/5vcpz8XYVXhKpq9hsJw3J6+hvh2db7qoX+6dGSDjGF1LTj3zKWFwuea3yJ1EMuWUALZ5UU16i15ZW2DKrTstmYGXO/rAIaWsygoMjnYRl3KNC0rRrj/kY9R5ZY7eSFEjnv2BRaLyJVad3F6v9nuuxMJpgvNCsQk+ji8X1sdVXtfjUjXmi2sY3nTJcjQPfDhDlPH3lR2v232xHUSj7+RJ0WdzKhwkINPqRs0SscJQ2PYJePkRaVjjArFho8NTHDbPskV0TPGSN5fxvjbf/z/9MkWb4WRDLuWPQul+ZIRmKCe0LlnL5T8xMei+6GZzKh2iqby6+QIpyoZmuNJcgpwZyzzjENJNreLNkatV0O38xK0SOv+Ev/Jb797pFtp8UWvDRWYQg0Bq+Y7OUoTQaxWnG5e1n5Vbp0KdRMb8EOHIpjhjmpJMvv5rcE0nlSveoXwwQfSVqAp/T6M06DJVLhgG/2wnmsmEQc2GL3P4Oc4F/dFBfjrggkepRBFvPUKGL2JhPYnh+CufsE2ZOPNlQO7FBYoVknqzpxp2Qpp5AejVoPEKZ6aYaH9CdOk9GSfj65MNFH2cxaSCOMynttjHTZK3o4DTZUNHjNa2TYS3Fv3BLyT2FTyLbRgQfHtEbMJFmGG6f2VYh/KZhDATV+qGzVbu/nvmx9xqvisHgZiaz1U4XR83OFiL5ns2kdjLOxZt/Sdifq8sHmiZwrEJLGM5WcQspUKZ36QoktooZ2ApMMAD9pI8SY4sQSAIw2FIjmKXMV7kj6k5QheWGf/am23nMd7mfqjnHiqrZ6Vf0qcnv7884UsL25VzBD7QeweuixRJuoseXG1InH56bVNS6X1vyWIRbJIo2uu8Oyjy1U2YqnwBwkHl2fZlSwCa6gvbTWaEPh+CvWMGEdbOEQGbmIpqOzQi+oei37GOCL9XfWtsQnVSEBFhhdQeZ+aq5V/HrVfrPwo07xYO++8J/nYlS99NMu5LQmIxFSb3rBvpUxmSHuzDGX9Pf45+TnB+sS6Ip3qzPxUJLWXVZIVnCPOPPim+sR+4nHTh3FXhEA3cYSVc6FjvbRThUuQ3KMq2V+j+VPZED7lg41H4j0qjnx/BjR2jmCHqz2z/icWcPkoYdk5kSuR18/HWlXzjd+UBR85BIfD6BY04FQ79/1tktzMByrWgw/Wl6v9/hmexG4sIIK6YbqZtQ1UhGAXV4pXSIOJCJg+ebnAyMge4B9Gfy5jg2s+Qds3Otk7KVcREo3RevlkDTkVlw9O0awRDpRPqzYmPdv+vOutLy6l8Klq78xJAPpwzehzJ2LFF0Fm2s6F64v4bvu2PdhPM2HsrRp9bJ8XRpuf1HlzbDRRHBqtzizjNbBYQdkzowI7sWCf3iz8YiCpq7WSu9lbYhr9zbstfr7oHxFWMQ0TbKvjZu4pHCRUu+OjU4FmRgej0Ace3sdHHQJ+R0i7ztjXKhwet6QhsNOZhSceCc28Zk9SFSlYy+LZDZ9IjIHAjdHwuoV9IYGLlF4gmPgymI0HKWBxok8Ec2IYJrC+BRgPAA2sFQ6EE/J9wzbsluuZwZEmMRR9nwcTwQYcibu+fOqGUCFjV5jePf7xd8pKolN2B9/ePd9DSbqYJvf5eiaH0sUZlLAdX4yYbPehgjw1graKc1DUK5YDAzoal5WiKIVSoWO4oF6SLbkA1g5fF4efUmNX8RXIV613ox8q2uEGAvxo6TVUK058+ZfM95SG4zzErteCkDXpxKMhBzBVdZaL0wWmkfU9r1pmszT5QM7IWL8rEpKngHdm3DUDkK8hjNhBmKN7AH7k2TLZi061t/DM2S8Cedj4FVFCv9vBmCbnuS4xNWwv8EPSIUT8ftLirITsvOagz2u0yMLY+bTovudMpDqUqiOdCtIgGg6BYxg8jn/IK8sHNqGHxIbgmKO+hLAeAKYAhcwLuBCYu15a++rwmNGFM2RC91K3McHbIcn27DgDECiSnExpnNkwUnWE7LIDaolrCSG7FUvRCfGpwdGDMjaYg2DaF9kBZ0UnimIXvcuFN+lcHmoG3tm0Aznd0Q0Pb8wz4y/Uy0B0s4aISNQnntG8iKNor1a0VnCsIFI65xMjGd4PeqXhsUU2KatI+MtDRQYjlL9Bq58co+oMB864UHZLjLFbCUR6m3mtJ6bOXZETe/rn+r2tz6tPDmqQrMOXbhNPoSWUVyIjsh2mL0m9Zrk891pxddxTSuDj6KN5hEW+/kjxNvDl9t45aEvU3iNtGKJykLNlbrdQ/UcgpIY5bbqG/iGmEOw3bEB6qc3k6LBNcQjDVy5OiZnQ/lvgDimBtFISLBw8OFKXuVmt8YvgRCjui/zy8/yM+b+p85MXrflUKP8chsJNjiJoCjxoTpgAY8NJDH7P5aYg6Fc9/GyKqNbIayZou1Zyd2vETnC/kdigBKgZGzhuYm5tu5GgrCmhSr1nniNy4TTVMDTAk6ZYdaxHFUT8LfHXz3KyCQGMwyBNbKrwKm0l+Z9olTeQCDc1zJLsy1wuIk8Xip3+pEsxZX1iaaFHmzofiTunUqtw+BRBm9/DEDaWUcZWbZEs7+daUbNVtqa+aWhdRbv9uCvM/ne3NIkQWJOH+QeDNY4Vsu6+f37knoLAFyaPfP5zNsqGhYvFuE2E1kXcN7nOlkmvd8d+ADatSWcillDU5f/yTXR2cQnJnuspjTTSnZL6NLWKu7GcuEU4c0GKXkJ5hYNTMUsnSzp9SnTBy0lmFrsnFfs89mYEk3/A2+fScM8FlKVajjy+iTNbhxwsTJM5GoonLpMlnEVzJ6aqoeH0mfBJ0aQKrFVwm6kdc14MydEoTII9tVnPW0BZybPO0w3AIx3w3HXhY3NAAtOCeFKjlgI295d6KGADD6esQ0/h5V/osqnyXZWke1PssX37843DyWWWKwGXt1h6FKR+hyAhiGtavP1v8Qcv5e4ZqaBP866Qz7VbNOOQgsgz24RrVLMpcQQ5Cbf5tCeVENCGttby2X/8O3fw4mN9s6QbpbkQUw1bf5Kif+NVmL/XHBOgzmYlwx97/nyFi/yxqwbw2CkmMSWqd+xkQa+nfJeHW5xYF5t7cIeLduBfg6hOuJUP9QpP/gMTfAXSoDTV1i692nYpeVspJwQIL8nFryoXKw0xZijXT7YaxA2YK7ukC1r0fh9HO9eGkmEQamNAidl79SBRV2/oTav/Q37WkpJzQY24K5GVS/ey42dv5LTWfOeTgXT32AFF4qzZQPKaT1j6g1tHTvRjhxKaqhGpd0eq7pfF0ocbFcp8/A4Ir1NXYI4cvmcEjCVhay2voqRiiC8PZuTfqpTV6Nh7x/64OWtWwFexPNb5f4sreQSd40OnxG4n35jDwOzTk3Hort7oNrRFao44v6eNh2y3jO4ENGRuZlXcYVNU8J1DNfKPGMfQnjMqPMgTe+LaBZcfiruXpCYNHYouSC05PpGZ+xayuJA6LXwhmOUTe/lxQetRZXB4MX0SffDH8tofbGIEP31y4OuoTp5ArKAAu3HXAWVmg6pS9EinYbDJ19iVY118EUoJErmv5zpASF6ARl3j+sUSI7n/JqYoNvtWzPQxcZUGgfFrJ7qyc2Wm6LcBk+07POXTZJaNBVScE1ZPECgyBvxHNyQIXX4U6PPBT54AJty7glDrfcOb4nMSkGrQ7k9caPuGmPQiDHT5azqC5byzdbPtIoh68k7S6WBLTsa9QESM4hPMXJiXU0N19JpotcvhlhvSF/Q5JWJYqzX0NOfa5/Tn8F9AeAUl0QM8hlf9iK/N3NpMZAdjO2qBCQw2vb6IWHdtOGh4GdY9G64GRyy6PBVzH7CZkSrQdHlSTKnkopnUqw+psyKS8qu0rg/hTBgzWn67YGKdalaUYgeHG+TaFNJ5VbXZwCtv/0oS7LzCWB9k++dx1yQOhFjDb6eCJ9KwswB5COtm+LVoAVIn/0/9hN0YVP/+5mhTny5GUdx3xqbihQ85bybBmFQH8QuLk/UrerkSQGXr7akK2r5SAsWlhmt0Gn4XDgrA7N7m9wat0V2ZoqLz5e0cVdCKg12VHI1bEYejjpEfgK56KNNpUiHJ5fYMX2hL0/H7DUyGBMT+KEDIvZGYed3aybh4Bsph+JIRArCCDDlccwbUdO04+znJjBiF92SP5sOqLGGM4TJwL6GROKVHEG4+zZqehvrU+CUYqrJfmmrmUHMPElh76xLFX0Wp2LxrFlkIHp7ABr3zylskWT4FszBWpX//dgy9h2GMjW+vaXhFVMHZ1MHq8l7CgK7y8Timt2Wdtj0BnSSBQH5GyYNGk+kyW0nQftAJ4jFGtJst0D7GViajk4QQGbHyQNt80zicfaACcGbMFE7T+RDVedZjM7w9ATY4N550s2yuKH9ky4e84nROYCC4MJzThXEmTKzIc+NBwmnMy261rB6sMIZbvmgpTGAoEBcSTPIyJXKxoF2h/j3M58mogq3MVTyVP572SXSisUEg+u5WDY57tWuPjY+mDuwDPKf9eh2s1drDvZOiu3h74VjnOwCk+l1BiKxdyM8uG6AFYEGBSTHmex08naVhnI8ct/rYX2oVUViVcR98JMOTR5SX6e/yvTvKlQB+IvhIhGJi9V41Bvv373naERjzZ7M1E+XV82gfgxj8jE9/l3JChIVIqf0KXk8UIHKZRV6qp5C5+eKXOzNJlU52RDCyU9zRe1UsTzdvG0XnPrGKW006Q4gJq+G2DhA7nwiqdPc9cw6myEluiVHcGwYrH4p4+h022VhSKUQyc2wwcaFVWWUQyv1j8vDWHfFGfQPQM3W5wKrkuKxmc9gKMeRHekZXY99Zd4hq9M6voatAIAr4hes3MWNrlt5BNvC+sH1E9KqRu5iBhBSZiJXNsSAmHxkx7+i3H63oI71TF5BFt3zAIN8sdWUN3n71cD3rXSbenB00h3F4m3sBNFAUeIQaX4ARPYudXqR+g0euSYzRntJomBr2DgoyH+nRAvyQ0PNDUoEDjRL0g6bJ/TaYofjh1iOfqKitcjd8QSum/rCwUP7UbINQdTScddiSbHWTdIqMpTdt7vW565c/Fjq5kVosOzSs6SenRvbFlfRaTW2M/HZGfwFTWpjU6akT0f2+cMEGyUxTZTeFDd42sdOhM2LtD5CyKhW5+wP6PEksv55/R0LfNe0lXZw7Vtbm754t2bvY/8GbcbC3IcHmHSTsbdWZyM2d3s/Y+KqbID4YnxfvcXmhP2VNqd1TQThL1PQF+KJlOexWGT8fPXFn4+NTMYidirakEZ2OY97Iaw+uJC9KlGdmJDkCydlToYUYl23g1dHivKAN3yZeNs+Y/yLSxzHNV0MIhYMzoz9UMkM70hB7FjQv3QamfwPpORdnhu7yZ2NMZ1YbLrrKNUEqUrqDOhlqpGyqEXwlZGibxUn0JkkWv5xAKSEsbvnzPGEt5Nozr5h7ehbf/hlHNPQZnkLNbKAaxY6aT3tx30RskPL3duM/dNdAca1qt7AKLuwVj8YYPDBfYBhftaniOv5rk9Z8/f7Mc67xxSE3HGgYITFVvEZaCtKDKELYBeYLEZHTmd54rZTcpHo4wsSGhzIp6hNEc4yVOd9GJ2aY60fYXGrdHhvrbNgjr4PQui8TgZ5RbJhOUY7Hc5/HRSQO6ihga/eGpkVXtQFcWoBFNZLXFBGSFJBg8Xbe5q1D9otSeEd/EcTlqAHlhmQQ3bRPl9d1dxoasee/D1WqhLeKg4D7c/ZFgLyCOyan+7suVtjMQeTM06XEJCsZqFzMHFW9ONq6qFybYg8aP0UwnBdxUYkTI1bwcxdmB+WbidtzDdHgt18ti+FyrvYaZXUx9dQPWP1TkMrJt3bsnYv9IncKOhkIwZETbxfto4Qi5i4Vp1GermXfosEWKNw7BCUJO4KeqPjrFlbH5V6sNBcWIXj42h/4SMLu9Y8jlMoISLyvvK60D1mWudKLPiKIKvSAh3LEU4BSk38Uh1OSXZk6wVOoxOHhobLO6scK8ZpVvKxd1WCzzokxP5pT4a2T++QxHzsOf0Frszo0mR8c94gbyV6gvDExncjjXfqQl6uMXLOBHGck9R6oA2XdHZAuwJAiBjWE6rFnLz+wwO8KNhwzwTNoEX0NltPT8DddNPpdk1G9TIXuPOlLT2PA9R+OSlp56tABMhucbLP3M+zYmv0QkAJZQ9egCpckdffs6yZ73HsZlG3ACQT4RqJq5qF4v6YUWJJdaUdFiKfPiG2Cn7BMAUei2/mzBtibCmYto1Ybckjusc/lKxNlXaSdMuPtV4koGT8i+Ilxq1TDfd/mUNXa6rfd2RvQTDRPqmJAcLr53e2l2NGJAY3w3hJF1MLAIBfOcLBqmOIcFOZO+2W03l0EAda3qH+TB9VOa2UvX6W2LDCXg01vcCg1UB4zpr8Sl/PX+L61atMWCFEdxYJYRfqDuhhoajd0anP4QA5c4x0xLcq8BlF+7zgswOAaCOJ79mT1ZvTVtKSZw0h2zdPDNPJD8uQMkfciCNZwPShidFU8oz4BJeGcPXgjelYN2RmQjHP2+q/NQy/mxyoabhsN5DAPf1hO7b8J5GKvg52cvUIKKZSNHt1lDyoIvdd+Jsz1ebnej3egiTEJXEqZFmt2Eu446K/aKEIukFokI3IHSPzmfoKaAwreOFrTdid6kMAxETUBG+8/7iieeZs+yDKpSB5iVJCQQUZ2hDirfvYj4GkwzgO6Uf4FwlvWNBzQP1+avVSZgFGtfiENvIpSfKhP3CeSG7oaw4YRnbGY8lGmhPBqUAvn56pU5Nwf3FGTsq/B9rHLCxII+oxN/tVjQ6RC+krX+C3nEkPt5o5wzFDiBa3yONs9Bd3XOotfYR/nAu/MRZWTPKkFIfEXWiN/DvnF7QEQBcX4CmrJXMnDEzbZafoeQsOakpjvkkVyuPbSqi0vSErZnS5B7679tfd73zR3FkqGi7elI3SKtCf3mn0HofFEj8rMUwL/la8XctytpTx9BgsSmut/fC3KkhdXpC2HWkoPT2cMiagDB0RnTVe0t6gYKNphacqMAv8uONZgxzWPDA0jDkU+kgJXvz3URFw+e4zeMRDhGWCTOLLXMSeOPJmvGaMj2cwmYD6DUYUfBubljKMbkvt2uJkLy+6yQtODc2fC/Y5K2RjRJi8SRCE4zCioiO1vCuLiCsbg/GUkVrB7pqaXA0ZWx9bbziNNtByqE/scAVF98QyqaHx0K5qjcCds5vS9FdtCPdilkF3t2sNnJKEm9zTa4Dg60udOmbJynMyBQI+BvW3ykJU3VqMsoylGjC2NdsHCE+zmzwKnYVW4jZWRH7a11odgA5Rab+siePi2eHrcEFIZmVEv8IJ2s137fqQYBZaSl+IVEqoiUcjSO5CPdXvAvcAE1azYHi2uO7giE61rMUtrYjrFuYj94Kitse9eDjB1VYzNcKoMkfSvlkGNjJVxw5z7Gykg/Lf4y1wPQqkYCHIY3XoxePISOJ3EpBaF4+ikV7ZpezAkFp3Z7EOBmON920Za8Bc9NeOrfKtdwQF1J6dxoZs+l7mq2PojqgxB23WqojWSGlHJbO42CuOsoCO/x3Qb8bN7h2kaIsmPwlpr8my7HcK40F51h439RoL7HDgDrt/bamevc9ldsKtkK+/ahinvcaege9PEAqYpVRg70RQwXvVDlgT1A+kSeruew5AOCWeytIc+jb6cPaX2SlD278SjhjdBPxMYMa7AdkHgnZByK0yo5Li5Ff9OUFdZG8E36iIUF8i3ye1PD3XXg7LoI2I138VK57FXwwim4Wq7RRkGo9s8R/eGsi8n/m+f19uyyOKCUROhNWChUVB8M8DWeetchDIPAjAoUVVMnLDUUsL7fHMIT3vGedlYXbzWH/xbEux3A7ujVEBFCm67V50FrQF/87BH2ZtHQ1zjN1Dk2Km5c/c5BVlf9ivCXGFnsEzIAbOaNLbfIZ3i777AweWEmLedeJEC1k0JyfrBjt1IMUNqWMaDnmn/15bT9SGf2RJYyi3a2GsS8T07hLjockSpf0BgZ7M0lf1ygDND5Ycr1WVB/A3G9W7REDebSXLGDAEGHJZy89cGuTzhs3pFD9U8IHeN1urGxX0HPHkmkX+ubikMnMJjKYws4EjK+IvMe78b4Pc/t8bRvNyUZzVXvziIpxUAQM4pGFP7tNSu9thERogyo2DgA5mZNzGt67hUX8rmCzSdXxIMGjrfA9DNmicDv8SG14nMMErorBV0CWqttRrAz9iwZdGiReyJyYwHGAwvEqoYDzR9jgnlBovP14L2TAGT7MfKtPkkTr8r/PEwnDTgci/8ViVPXyZF5F7FhwDU4bXzuOrnReIoyABmFcPj8i5grfYqwpJnqkj4PKkNoGYX9ILsGqVyXTgVcFp7Nvvek9dIHgQgDzIG0V0y9n7p3mawZiSLUhzU6y9vf5r3jmpTVtNrrNXamn9NAtIfpwqiBTj/QT7ck+q3bigRy4unqUKzlPf+KXznTptk0t2ZJXpULPaeBHn9zFvCjPFlTiaxKLj07Kv9yBEO26qhK7xT4+J074w6OHCL84gVg9KmYCQEVT08mvc3C3upMfMidHIHMMs6ZJEC5FONWh89Xm9ugDJEzU/VX446UiyYemmIY74wW+aaKGcPUtmso56EAv1xrlmL51ovVFmSu48txFucT/8mOfM60lzzLm+5WycStaHn/wL6objPQ3kuYX04E3PHwdOM5jAIO6n+4kPT00ere2YsFQ7/L/mbFGdb7MUi8eVmT5t2aQT0/RMgYZ48cl7nMJqLsoWUlooj+D2srLGHKu0wFJtZZSzUmC0XYrlqUhai6VneY43zc8jcQf818TDn/duuJeLWKVNiuh+jRUyAXf/5k5hWvwWj/PG4EYD4duxhf1WSVLpCoGmfiH1DF1AxnQoIRcp707d+VYN1tw4rG6ZuohNNZNH5G+CbK1YwvytkD27XdPCyqjNv0DTb6lTKExKzuXkYaL+Md+5QD2pV2SYgqU81AnX6ygnkI561weqtqJHYho4jNE+fd1IkZviaYDQ6V36aab4p8WAM7VSMC55VBhTJKDVTJpL9SAt6ytuTrfbeoa7EmdwV73EQse48worKzXka+m1hAyz/EkM8UiUSwXf9nLCiAFOA8mJLugjIA/b0BZz128qsWjy6+Crql4p28eH/5F7Ms3h7yjU8VJfgSw0FCALSXnAMwc1dzVOFyXTmhVuINCLs/jjsa8DyqdJulzh6aZrnHv95jEMElRAvW2YuxUaRldrIK5zf8nldxghRHyeYfDkKt7nhiQ2v2WnhSHniQa8Tvar/Q8z8ArdAOGa1ubGxQGG3tyOWMDmvhYJaMYGBucuTqA9mhZb+WJtgTdUkRDcC6JIvp3o7skp9WnaDgqTgEeWJISsLfO7ORj8wd5g3qKt0X3QuwfBo5Yz1BTmdJ1GBLiTNEd8cKqhnAtLNQZ95e2BSO838BCM72HTJmoRym4C7Kc/frahqaeRMavyZqMwD+umgWTOiYr5nPsvy+LHDm8pqiHkJQH+2J/zQ77J0SEERW0TGM4ey1iVX/lSwl4BsVZRMA1UQK6nTVyj6PmeuISQ/A2zj/G0Y8s0VG4fH+PflMUI0U3gw96s7x8EdUP67/ryuiuzOMPXES/bBiOTPZf/vkHfUpouhVfOMuK20sZnd9O7Bez+3j9NEU9+elwi44WBkeoeRqZ+B6Mye2vyraslNunyPb0PjFPBOQNT/B8ze8VzWcufP7jdu2wCdLttYLgE4wAiqltoT2IL5TQHjNJZfdtXxzZ+EJfPRAZd+te7QCzTdFGW8b+snSu5oCe8J1e9sBG2dd9oPD70jcci7jyxygwi6JfmWgBRQEhY4bqDDDQbxksYf1tyX/Qm0TsRXsChFqlqHz/M13ShW477PX7PYfSMz3rN/5FVeCbzvj+W0FT8BE06FX6t2ssKdyKwaUT49xU1joTblDAlB5+18bHSsOubHDHzcmoLcZCWgf7MVZajSZ2VRPDT/MbWKNDR064xBTRjQiy0e5kGp2vLwKS8/G+ajhEdN366i8pRv7qr1U/1BvZJ6knbypIkFhNNzPxT8uExBCw5PsKuwqtpfvi6G/RVKZ7Vp8sBp9BK/sUpO3VT7PaXHG0a+APKanUqt3L8WhR0yRyXSmIvFe/wIOe+fAaM/m/d/dsABSaCVBl7LPBObXHOJK/78Mg35b86/AKsMU9DXLHmFLbbS1jGsANnxpUAAuav31SmL4MKKSKjLZKSqRdAI0h+RG2xSUMUgN6BpwgKJjjBWnQdO99j/zaK1p+BWeyPKdjqt0+SagAYQ3N3MLCCF0dwQmgac3KT6q7AH9UdXZnbyLrXfsZW9x7yCKK6sgejx7vK0RN4rZPpTJ0Asrxg+RAv1sTdpPTEruLuHwT1gJsRdC/K7W6fWn+b3GRt8bu0C8mlkhwSq1HE60MmBtxJy+861uOaGyBe0la2Sr/F5MB8+P02f7VlQ8dKBcHILp3KfM2+JJr/IvrprYrM5zbgmw9stw9vBZdlQw+MVzYdxACgV8NKln8NBx4C4SCwXY1/sgBJYbjmijbh7USqtnq1uGH2CPu6AVZIgsUfSpyVUFg/QRplCuszuPiMTLHAO7DAhavhRSxdlLJYH2VKLykHlIqK42MxQWdRSzRVhbzuUcSbnasIh5eIbpw1iI6JXV+AhskoCPCmLNKQVBuK4E1DZSuBT0wv0r1BJdfb3l1sT1OF0KbCDTenK2SKKzV0lS4tqkC9XM9PxEmZ1BacgQviQ9K2REIuNMj9tRTbKeyCnYGoLFeZcE6WtzRgUmiOdTSB2lhsngtIHeWHKTCVHO53XLI4LmLvvkGVCvgm0jApxnqHytdFUU0T/K+i+PuMrsAraEtTyIN1bzOpzxkfkobVel3mYxfmh/FUsBBcPkmA9zp/FAfU4pu+/2kZwUFnLcpZsDNOLDWa69glI7XdI9gGR6x4K6M2kUUHYj7g9iFzjJd43lAMuL6mOgUkK/D7emo8qDtja7VYKdywkC12VVHDAwtrvmN+98efKIve8djCXcTq+WBYP9wO8KgGW6lgKqRauNFpj13IWQez93/TlyO+AGI/MQxr8nqxWoYkNxcGXV8wN8J+AIzdfAIbVyebd1rgw5nVtOXuXDdOnOJrjp3CX+KeoGjZ06m1aG8Jh4JeGmgNhxZDlAkcfazCbMP3Zirv1kd5N3j1Jc6VgTU3q62CZ9JDfnJlYf9bBcNB2Wc9p3x29AENnaX2rFVJl1clGZL8SOJCOUSCjxBGJTAQ9LsOckr6OABLUW/15MHmtSGhYpY0396QRfjKHWKnGaD5A/e4nf0lEFSsPh3x3iymhj0ZWpNcvPhReqaRCDlATY0bYTwdFxa3y9zLxc/MEk+f2F63i8OVIvipLGNmPmLJ3tC6SOnGGorfK1tKZv01mOSAbquq/uYJ/sBJ8WmXezodKlbVVKc/azfsRrXjVZVGmbtlOj2RiyRfRKUAhZaFizrMHGkpx4nrWmOAEhBbMK7Ew05O0v1kzuarTZdoxh0L0E0Z/dYwibgXWkDy56bOAR6GPGi5nn9ttsqp5g1Y8F0+LF/99H+xfX1rJP6WPr49qz6nyzKj1yQz1fXtj+Xy1Zis/JljRBWSx1uV1e7RgbZBgmm+VLXLyYehWwOh3Cth34h7aRKid9AiUUwHKITv6bQZbC6RPWBP7S8MbYg7XEuzs2wAlXKt9kdlAPqsNNfy3Xzje7GtbrNEHujYgCqNzYlRJGi3dTCEvUTFObvSsX9Oip/9ppXaNx3yY0xJcHAP0GMCsNf7N2w1Vt9YOOagJmd9SWshrLNDcmrUGcYIrT2cqDIjbB4RZhdbXhNN6H0lmr9QiO7jamFAUIrekcHP0lYt/MfA2zZq7FEb098Ke2aueF9l3BNCcl0m6qzA6Qw8xhfmfoWqoeorr//JUvN+Y4dXSRsdGwtQ+lAz0eTiW5zLN0x/p8eU2AFiL7a9RPR/rpegzrVR2nNKItQM07QsPXT1Xvc5ZsAwq2J/MOXcdDDvAgKzIATTxr1s8EFPo4SGZ7IDBmrnaR4JwM329aiMKp0chz3tZr8q0vME19lK8PwNK0Ee4Xcf27PTyVa841R4FuIazOK4TSeDXU4y/VxnQHEt9gTcz+KTVXiLIMXtR2k2fECZNly5aaCa+PndbAC0ezKcDgud+Q8hYqh34b/RT/SMJBxPTaZHQxRvawIZmlF1Dy77xscnL9XtRxzKArxb2fNRsfSs8gPaE7IRBgd8IIbRW2xHTiK9GEwnzaLJeXgR69QrPdx/Ixt3d+eaZzoej+lAtkTscSWuvxkFSGQX58zWAqelxSF2aYJHA2mkA5dFIZoTmrt9FPyaSvic43V7tNSIQeO9+V4GXnbjBx93zsOl2sJZg4xW2A5RtbthjYZqZh7sbvtBNaTJYCaBl8D8zOrXY1P6uheVCXdc7TyVj7+5nUBrPF7T24J4mgJXfm5IeTwv6MRd+m16EdHhvXkUsVZO33gyTYINqQP4kH2JPAHUT8iFpukJ9V9U0s6Ey8IQWsi8uQ3EGzLGJ7GHl3I9xw4Dl0FiaDUkCLE8WT844WBUnD7Yeus8kaVjwq5gA+n1dZ8u+09GsF9rNAHHRYBnxHPjpbOibPgBOl4HvXPCUd06pDKpqO7FRtoGMiVqa/YcKpGewCpZGbDf4r71I2FcqfW/OP7SLqAVfLxbu8YYooBHItXn+s7GikNvh9LP8gJfw3xNbe+qxnIKSq9iF8VXLY9Mwyb0vg/PUaOMYCZ0f/XqKNRzndw0GghsajZUs0muKRpZeWDGsSJAJOkqYusRwoZ9C/rfaKOO6oWV/+7AhGthbPIEip2OcypWz/4Ikzpxeokr9PRJe3RMw5w6oI1yqnoybBsoLqPfzZ6PIQEpYsv/rWjZJiKXGr+rZstluZNTE8hJHf3xFno1G9Jg14gr49CTGyUEtE4BX4mb6DgvkO8L8O33c+vTzFtlDUAu6P053qmJeZi6my2HM4r1rSsWwAGWcxkELYkDALuMtGcVrDkqlnR3HM1fygXItpw/lTY6pbMNw33AhYx4ujZ4ChO+amcaJ7ApewIj8aIyZP3Zq9kfIHEd5NDCZJOzRVbTpb1+Bom91zPvTFSsMHeQCqOWiGnMOYaBCSs/kMpFPMSjME8sl3SOJj9Rs6+YEZ+AJ/lfD+HFuLA5M60vJsQmL31BFEnlcJLAW+LnK7JEBfrBpPc8EdQP1u9uy/raAR6OMPQV4VA4M8I008nU//AvMPlgoDBW0bqIojtjA2n9/3MtKekcOXucbPTcVkXZmL6NEGoOgevYxJDrYST++X29ARQP7dKFmg0eluyneQek4acdbS2tC3RDjWSqfUnQYClJMfsXWToYFCNr9ATqfIBy9gc7lxrGtcxnfPLZf4J7ZsY01T7odagyh4oeweMjcF+JvXor0Z76ghp9ONao5mYVVEOq2u5zhBG5lYD2js0fqRsPaRrQsrwWDwMIr4xZ1BAiLeI2dPNzko7fKIKM5GKdDC/kA5whv+L0ou4NhMol9JSRzsYcd6RHchioyRnOVDq4qVSGF1z4hTKIwLvrlBUGwu0PG/CkFINNZW2hgc/mw3pUqbHdJf+gYIZiGUR+0FgTKJGRS+KXFC4B4OuRYIrc2nI0ESKVPkVb8h98LsRHFM7fiAE+QoKtK+ihhRk+JfFR0OPCf6JZdih6RbzM9Kyaqr6mR5hvjE/Gaiw0SZ8x1/MGWHRbuk9es1z3xLBhnZBcY8ZNS6HHsMru88SCdFGE9J/9niUzJtSZuppfzG1NpiblzKXm36RKfUIBP0VmPPBfDbqdNm/4kIRod2Ho67kJMHM0AiybOqHCttlJ9D2BpA5U8jECQw22XwX3WDKQOIqhie95dwZBG+zKXO66vSbJlaS3sou+sOkkuI5j8559QIo+gKgFv2Fsp/YFqbxd3s46+/PZDUbLvUqOLqg80z1DXX2o/AQgw+Ue346kn9gXsIFmKpQKt15359Iz5Ii4pljlO2MB0QlfndcJVQbAVTWGgU2POEmvZYdyB28Eq794hX2I5mL/STTXYFCF+OUQi6oSnFRY4Z+uVXCnd69WT/A6nYlzGJzrAk1NPDBujLK+AQxdLMTeBdpSzPju70hRPBgXsgmezbNHFaR85z961kgnt9N8rXuLWkzC9Nf9bYo63/Ju7pS2FugbsDlZVaa0YGr0ocpnzizf/1q9KsPUiRXlUEEDPK6Tv4Bkv0Jbvakyo664cCveBgIqJN146zblHmd9aTeXSvIM3r6hnGp3dCLiUCpQTj4YHKd//c35qZaQTE+tL9rmix9Qlj83OEgXZ1OKGGLDSSJiHZ1Ij6ew0TE9fQnPiFUjziKDehfOA5zK4+FB+fFHzUaOfWoTXYfQ3bxQ9ZiDWSQMr98x4IBHWutREjGLd0Ga0a2EtDVQR+ZwVGD8XipMx3sOkt1vwS05u9vTgo+HhxR1iWRk6/WOs7vBkMTpGMhJio0uAJ+fzlJ7OP2qZWmcogF/rJZezMub6rxFBv00uGSDdTHI7IsRpzDtAbMz688NFLlpuDcZjYmDlGvRKhIdnLdKa5H61Jb3Q1OOstuiJFqJ9Ad2yAkqjMJoRbbs2v4jtaH2gOCx9xRRWR3Z4g02M10VSB0sk0nEA8CQx6O2WZ5xLaxo5MWCznvhEDmvt2qqKupHt0Z8IT7hhi6asOaJw+nfnSld29U+mK3LQyzxFt26IBC4mx2LuaY74QUGNF4R/Pvfp3rWmBxOVeTiM43V3mqeNRc41gjznsi4rS7dX+6/vMYaG051whRsmXyzHL2tea8q/vvwBYc2azOFJitIRa4yfPcFabBWH6uKSzwEPSqMcRv4VjvcD2Qonr5D3BLiDohFYjDjIWeS6nzYOPPPJz4g+epp1O8oThZnNeZzlENsl1vMYiJ5hhSX/IYE3SvbxlQ7nLtBW6jE9wvtf+hYcMhIioXQwqVCZYO70ThE27NJRPhKvJaM0V0bsd8xzXZc2qi2kZg7ATlcBQir2mD/awTpB32P3Q7IhHSIqhBuqE2rbpSgKI3F4eT8sGFnqWR+2aUqIGoaKJk157qe6NnnqhrBRhT+S4RZgcrDmA2QN6ZfG+/8i8YZVXIYNQKwyBE+37ZhlaSFFYddQBW+HiqxJhEPEMDzJgAsPeFEQ6Mf7e5DhODojLq3Qncx4YU7URCK4UvQbf1hqW73VsEB19lggsfuJeH/JIaMRIhSmlBAX8q1Q2jESjuR6V+THW5kYOQTkO+HcIDQADXrvC8JNjVfbMYwGS45mwwNznkuCfuBfxtA5OZPnqwzEYP6ANknkXWpNoIu4ChnLLCIz507i8x79JszldPDXYKtSBy093zYubd8V0IVTyFIqA0VqihcbY1LX+SXPij2cF3fv10ENMPcfV2ks2qkeOO0e2JH3HG13UJd0aLGk61VdktwlNtDI6ZpZ9AqftH+qLIHjKKUnki9EarC9amTCv3CD4eGhwDrAJrmjfMlrjjFhaZcEf4eiCy0f+SiR42ws71jTJKOkYBo0rLn7PMWM+JtUWswIdX+uoi+Jm2dStkgF7bNc0Qy4ON3ZnY4suS6DgE7HAeNKXeZxTXfACRJzKbr6a+hBMyHxc3ELWQa2f+EAnjccvH0MV++zz+c1dFjH85xaQbcA5I7IqRq6PVTran2HWd13oo2g9Ggx0Xd7jjh3bmzmS8A5tfz+ucs5IOfcZvf+nLS2x+FqIK1lXrzslDXKjwT9trSxFzzXNLUXNYlJnZOo+vIAI+DSf7v43RaIoooLm/HzppJhOjRGYzz6CgTtXXm4VegAThwHlfzPbJZVkTKu1fzBXwwTYuez7ezBSTreqOqqjksCXKiZ7+CqAujgpJV70mcYxaPPM51VO+pAcsgLlGepsgKo8kXEM0I3VzZDLfa16VeLcgEDNbbVbQnD1L71405INsGppjZeBFz8zBz/cQRkHVpbkXPYDk3vqDGKNnp0n/Oz9lHNjqQVBARshOTOXK7kb4QDr2VppgakU1SWQ2g78FRahW8bHLewki1ji7yfUsZXtqxN1ttTAJqukeEE3lMOf/zqsl1BwAgG4+2KIXNJeDVJMWipAmueAdocpML6P+gdQUIRCeftfbX2uyFNtLEEY/QDy6toTJr3KYql3FvMHdOqhzXQB13/ic9nimiRRJgrF6Wb+SJxUXw84m8BHIiajxr/RjTdtUMfDfnF2ZzsGc7BSPIVbH83WPh+LnXs0oy2gMpvCYMO7mUgY8DOFupQq3W7nphp7TweqnufHA0KqCJTA1G6YA1HT4GkmpuL8MCZlRLobeSWlVRnHnOILhbqXNJpJ2ubRQkqeYtkWCNWwQEL/DJvDG6tFIOoEGhgJM1PotP56xvz48k0rmkeMHSB1EEKBybszyGvg6/s3CYov7BFIR3UCMmK76LnKU6wTN9aYA/z2PtVumW1aZH3MueoXt3MA2lYxObwfWXqc8oMu1Q/KrHObxBoUSTLvPPHPjoRaGFTBU1rHm7XuKfx9TBd9/DoIvVdIZaIxjb1IwLAlz6J3LSeSZhtfOCWUJ8SyWW4BcZ2s0Vgii4ubz56XKbF2FQmLG61v6j6HT09DLHaquUv1Wes6Nv9ywGPOxLbMSiPtMI9Rn3J+tUs/xNTBZgPoE0LzntG07AfygFx5Tzoye2/vwEWoZ1VDNei/bbpb69hAyC3tWnU3Z+LyA0U+5lUkUlYYPu8bKingzViryCWzq6ulA8fxGlLn0VUlUkeYoeT/h0DqTBaEO4TZ2tcuP/KFpVdlotHusf7srY6x2XbD5FeVVQHo2iAHWPUQEDN8SO1lNYzKXx73pmTHJpT6NuVyJXbMqTuEeiMQihz1XkXeOx7CYp5ksvG4L5WzxWs05p4zWdRNQfe9LdiDXxOrG0Bf3K1IZOeTcwMYyDhgto5tW/dfBUB/ks2DWX10FYlrI1eej52kWiSVAfzzjDmFkz0jfLTtkpmSXXX6gBeiobpYh/ryse44nA9dB+uGZXZWEqbK/+Phg/sHsfuzMr661dZ6elsjzgvf5pIBadKXv+O1BNRYlYfoGrT2HNZ+kYd1otwOS4BHzwfDL5RyKno/mobPI88fP7+sGg0Hm3AVKzl9gwAUwl+WkRFxc0TemOyUUNNw4DJyRL7pMDVGEpbvNUzI4iaYJ1TjPYahEENWkEZew79j9H6MfuHwmri+w7/25vDjBwvHytpsWpE1BsP41hO73s56KR6nanvhODIepF+YUnVH6OVjWa3Au+U5jK8fVErn+SMbDLWJ7JZOIX61tVTn0Qo4THtWM5GoaR9bKG1CT1yg+YCjw+z6hQZOUzBLIspW1GRVhcwumH4wnRoAQQVcJqimP0ykG/t8NmDICNLj6/NhHKVkR7a8PU8kwV4l2ZGgYIVEfGQje70raGLrmJDXtFQv6nHGay7rF5p3f9yPLjQNza4pvqu2v74dK88UnIDLqhHGalcE+h6z3ZSWn17nQ+L+q48RPs4GlgcHJ6rUTtJ1e6Y/PXjRhGw9/pVmtyhNqZ7lopdmGzukQXb1w9Gf4wgO9lzbVolYV8oHzj/hojbufKLdmR2fC1fuCUj/nbq2o1kLW7uchfQwoLqWbHo6tbLezVP6Wj6lJ3H6yk528taONnjb+gnnjYDliUXpnqDiCCsSCNnOCSy5n/WNgxMUst4mN+9CFgrgcp+Rp0/resLoIng69Ll3qUrVRGnIC0JxUe4qVCpX6noTte1DDw/TJutwLj9KZOtOkVhkviDLAtVAiaUqDTcGoL2vdA7OhVYNWm88z4Sb6ipN7hXa/3CTdtT+A/9SI5TmEp8EkHMhE0C1qRiWU2aGMrBhnoXO10+ggKO8U5K5TIcCplijF/9qkXaP/dJf7Yb6X8IOOkCH+TsplFx4SlF80pSaUcRTFg4Y2c3ClTdq3+gIo6SVU8mIFal+amr0xruyk9AqaEreLk7KbcgY0uXJk5qLBwltF9gNmBMX0NT1pKdR840mda7Fc5+IdnmxIeddT3CLHlJgdNwOisB/KO7poXHrYNfhma297jbwNtOuliiIRebf3tVMAaoju2JRY3bSH7qNqjSw2fr35PCGNxxeQvV17Lo7L6atYz956QjdPHeOJVhrvvDBONoIcsZjPcK9eJLfQvOKty9V3nErazYkElGUTURJaOQBWFFsr5bcBr5afBdfY3J1722zYTSyUKytbIo/O/BHOZN3VZKEJLdPGyJ6MnLoIHDybz+UsH3Wyoa2YSishUpBfAZ+GWP3toekAmt/Pvro/1bHwR+I4rCtg0RL5gXyC3urljqa37Jmtxi+aO7rSpsTiQ0dUdRyDwDpoo7j4fUAl0jnl7dtzEJI/kwAEF/fwNH/PMtrGFuqSdIlP9PTGhkd+GoGlXkkGrBgdgsvQUkC/LhnL2DqiqFepe184O54g/HESi2Lbh6H5ipBgpFu0m9a9vLh7jVf5WedmoBtcOcEjetJH7Da7j2VLThyuAPqLRxwB3qvpnigCqCq34bglELu6hrkQc0JCX4IcRaJDJa3ERezwRsLdfdgkXw9eqtlb1CrU50NP4NjpFSGh94CNGT8rK8rwr1EZCFIqyYojAkhFSYms5nU4PAEUN0R4bx5EHmkzR9UxrrR+R6i1inMG5+VhNvHhZAhsi+LJPEMgjkOwfurhtw29vGYA8v+bd9F/gwpIxNwNqxcYTj4IoFQdsEIX/H7MidxjomQwAHcIFU/PoKDEyuNHwoluaBJWWsq8O5H0oOzGqWIQolf8tqS/yQeeSNv5RdHU7h7UK+CNRo24s/KOfFELdRoeGWsTOdA8+mPcphssvg2UkCrAOmA+jr5bweX7P0wzkoYLxLPLasrHHp2NhqPc5hRxFQbX0SZ4KVsTkuyXq6nKXUkma0D+AHa8XD8jbOixocuWpsIr9Ft+cVk77ahj3xAVWqJG1szKqJddZleYguGIbc9NEJiyXgD6gG9d4PDt7ru371R7ihmPitqBXDxdEnx8RilZyWmKyDWs/9zrGTSWpdn2qvg2x+0v3Dwjd4TeV6eNfL7xKbH+nSf8/XTc7kHDAAljI6ARdmKJRv5gksAKlEviCRpkN/Ni/4CKOWPvvV45Y6oTDxnD+Cb4+LjZAMrCWwi5F7cX/9zZSpZyzwSmsKoYvdS+l2eIxZWDDIgiT4d2XZDUAspFR+qr+jRjzktkkx2CKHfYrgv3vlGgeI1OR068ylCF26c8DZpbZ9A7iXMTW8rNlk5j6nrNjRKxQGMGqdPwwZFY5qK5s2fSUqQNUTyszkj9Wo66432cmHOnavKTDvYJ8pO5qumPbZXUunvWS7dkDQwdSyCMcmAqnUHLjiJMAThGggtduwU+AxtGu0NapR4k43BwTbtdF/nyPa62X1ElrvOOI7s07CGlKJaGwPjW9qHmfft3O9H3fEqVX9sQmlAJOAbOgWfSMGh1oQspSOs9SZjcqYMXFPy+EsgvzKIaTZ6XwTRZOFcnJUP6jeINgvm4oao2SYgld4W8W0O5wxXOQgVp/doILmuVnZVkLn48+Z36IW4FI5T7/lJNAXYAxuLFxnU9Kx6omo4jnalxlpHzg42AOWNNdcA03N1bAA6vS8JwKjaG8I6GMt/L4suSLf4IBWt/nWSuplwnNkDZnQDPPex0jHAjmLSn8XNSjQeSx1ATnbndwPY5NyWn/jRcfN9Kj+K29c9n4yJnjruaV555wdxqz9v5wvaxmgv7Qo44sgcXLQouSsc04gpyv+6hfsSUy7YBeGKv9AbrcSrIIy9iKSW3PjGbjB5rClA1yxlB55mlo38Mg0MwNHWl1Y+AiTdVGDbNuM9uhpOCi+9DYy3Mk5A8KLzqvp0OtJkrNLHS98xf+BpFJsvVeINBfPxnlFKZ1+2MPkdGfL+o0sVWOu8oF1Kqr1bqPfu8zaySha+7TrvtB7jjhKzZ+2fR7kMVCRfuJ1nMQ1kEkenrsmHxDH8j7RGF0Dj1qyKVv4SS6Xt0fXDmRLf0ADSMMVmqGFMxdWhpy3HaSXax4LBqJjpFcoa0rvYV2qMndyq3KTJsRd3bVdhPjR9gOEBXQI+fj066kDMzrTXrfIdQAydtR4eQdwuXHefacN3rrY7AJiPvG5d/Kdj+ky0SZQW5Yzzi3Ad9PureFUi18yFZKWTSWi3B8POIW3bIDMiwL8JdMwk5DG7GZNgSmgtuaIKofCsxVyJtTNsSeVnLJXtaUuaLaUBxwC2AM09fwxkECizkLpfP1roukC4+Vp5TODIoBPvF8WUjuWHJUDoEIYDST/k3fMPtSroL0bq/OOOmNTEtodqYbX/m3lhfgwbag1eRiJY/6l1iJlowFfIC3c7i3YItDZbeLBpdVeJhGpL8ipuLpUonNBhFXnSMqxlmdXriOwpSPG/WLIKd8ej/VOFayAK1oVBJdXtaRitBAuwILCkJOYi2L8dB5xU4fMHnyMoESQ61EPkUqGxsKoC5R6miXbdupquC24azqKXm3Y55oTsJTrqZ5hT2XDYICsTGrEeTEg3pSW77sC0JdV5hyo2xjfVnbz1V2OZcwA53eEuROaadb4odtAsPhubppt3dIpHenD3RXehpDb/xO4/9UjL1XHvy+b02GO+e9jaYEQIDwxWoYPHKeZFPm2HAHFUYrEX0HNv1GCK9eGSgC9Hw6gymkzyGGHkZ8//piOWuEUNT13sXq2NIBR5J1LW4nNZ4VrYVzV/j38HnSHzgujOg5xxRyUyJCYIFTXwGWHtCCBiX06DcAnvZROgwEN6b+5/hLGklwrkaA6zW/lxDN8a8wiDvUZWfpY0mMw5ic7eyQCq1lutnfy7URBeyqM4vRXHa+HIXIk6EDIYtUjOe3EJAJJXSjqXhjd38bW6zmcYx6hQ3+LzIO7p3trse08I44hq4c41CcwGb7t13AmygN95GmFS0dNGlWKu6XDwh7fQ36mvbdZq8/xRjRI4mf6f7Rww0HwgirqjUZ+SzXaeabsqhRJQY5DPOrNkSfQ4WHns4/4iUcXw3gJ8seuOXTY9LDnhn8b1BI6ZZU0fGIW71gOlAYq6g4LImOq/fj4RQAKSoW0avI6WET0+Lr950KKKlBd/5xC99oZjBpuSGOY6pl17mnMgcO0jTBLtrsWheFuX5Mk9vJmeEdvKUlDtZTTJqfhKMtkcaJAosRHPnWzScY/s0RpGlxj/hKTSg9aecH91Y9hypF6fyIgS2LhJGtJbNQhqdE1EsN6ITX/tFViO5077qwd8kBUJ1C6laA/sQFact2GBMsYlCn0vTgPkn2seXCNZevmvGSMOm1YlWn0jSDXoIiCElW650MUDJZVo+J5blOSAyw0mio++Hm6TKhgLBdER2irFer6aWoPsq+vfksgrZQQquhJ0htWzBTTKUzH/TfXYW9gWONrFCbtKZ0Ta1pwAIRps8Uzde60qnO1waPdKiUOSzK+utMa4z8YGdv0TgX0jszzT738HSYfSQs8AMIO0LJ67L/0K0HnIxDfqG41hEIivPuMl+BbU5C/UkhzE39f0P7oGinp0GiUVDmttMRKaEmwlhAcyOwWaenWZf8OMWblh5EN36aggt5lE0LMVLNw1HQtA3+pxGomf1wUOSH6YjkJwqbHdQTsCyqIDGP6XbaFbRtdod/vVsSlunE2rhavMkzV7aLFmXMNDlr9vpHLDbVQNUkqvEzBlntPtW9t+jf5kizXpKLeRhbJg3OjQBxWcSrq7jTZcCJbRUeOibjXDnB/bD4qMLQjRr1TEDPQy6E+VJp5dAZ6ICR0WJoIXbjs32P9CbdVh1xte70vz2UzElNww1dPiWJ5x5nMr9DGh4GIIp8aGMBR0lyp7cQfnvolWyJ3YxcrWDQylEDBr9Qoi3gJhNUZZfTRvhrBzwfCYCKxQBj3WVTWyWq8srfblW/oAsgV1Lie6asjPUis1Lb/KbiMELEcSgtKQIpT0hytfAsR4Bb7FKlIa+NxePEhQAxMbdfuunHmijwnPNR5EPVuCMY/8CIUR0jiPcY2C9HOpy/rAci/MoNIGwTSQKMBQIp7JT/QbAwwx/2RQZkRZnHT41bebu8040UOAjT4wDhSX0rPFhuC4qMGWBkwu4HnrawRPMrnugBwUSs+mvvocvLFu/C923bLiqHd1AmhQCRzhebf/OcsPgJN92EmX6C6tn5Jsx4kI3Ez6SdBEpZRXcdvXOc8oOhpInQy92RK1okaSdCTxxyHmhSIRMivqBU5LebzjlN8pqAThXPS1M28JIBgEOYtQFwccY83QmcwvNIG/FVPx6PjhznQ1cWjaUP2lT3AQmLw3Q7BbndB9XhRaab/9wTqkCVtSbk9Yo9cLXmGZP9MW5mm3IIjRkXDpAiQEwHqh1IpPf88x74exJ3QliBxx9n8PxCt+ikFhwkRl6g/YXYTfwY0TMG+D58yQQcIzJMHJbav8fuOuicGhaWhfs3g6hIWFq+5g1mkOefz67zjWBcdtQcLNels4QK9SqPiCkO6c4gtNCDbYKVtMxgbozFrcOttzhiQCkP4Pp7z4XID1Hv/K+5dEzDDBJJGf5NG+vmpEa+q3f923XOegwH9Drn16QRMNDG/fXc6qjbBCf4HgVYEnLuAJSDYUs9fLgxDFlV1jrfESz+WkERVpzuTN1HpTLEwYypStqu/StQ9Z132nuJ1JW2f6hvshj96ANdZUSqYCQgxnHRImcGDAPWE/UWxlc/2AJLoPXRL/2TuhTT3NXZ5ZocgIwB6GJ+lbloesuJ7f0ph0D1c2I133Y4wdx1HRLIS2/T9MQPUdHXyk5hEaplGGLvXphfh+pakCGUjRuyiklqZ2k/gxv4Ba1hU40kl8KnuxGhYh+oe8flEq9M2E+YXSqeB5p0Z4aOqlfZMTDIQWAJOX+lZxOOMZJgojTe2bLTr8xF47KmfSdhS+TDt5QyOKZ6PI8u4KdxKsueQTg7ZPujS+e4zSOpWjDZdsIOAFoRxTDyIvGvVoh8/x1RljzvaelQbkad6mLNfx6xZ7gnopGm5wQ5oRFU8yArU5dk9XP66hrfIJMiHq5OYrlYM2Qdk8BMTPXgLCR1JQoce5gYtCYsushQ6JpaxgTX1fAMN3iRpq9waEP2wnuy8kT/u0pnkmeqOzmRoNl+XpUyLecDPHBKvtEO6nxmXZWWJ6nKRwbcPXM9qi2XSY/P3faA83HVMCByO0/uNdA1t9aD2oXTeiqAoPwSDtVdJy76Gyq69ySXDxnjsZ9dWnFid4YYvtO+XuiyUsWEVi2frN3qKsqhFYHYerP/ajOI3icCChFBWtdro/8toCo6ZTuTKqlUtKqmgsNil/14VZssZSF05WEjPpdQorTr/UNeRYmb1aW9vZTu1WjbGOKFpohzhaABI/R1VskjLb34TOHJJyvA7T7jT5ge2ibUvPDSm46CnrJP6Et08uKkHttMBWkc2oWCuXG2WUCawNSnkLckgn8ef6Tr1SBoPBN8gACysZ9/N1cTVbKdVDCbmMULCehGom2m8zzIzWT1EAZj2I/Gz8iOida0Lw2dW7nzdMZqrSn0L1RldhO5MpKDsZEhEZwVWOaxOXBp07uEfL5/g4Rdbj1uej915LYC8qTUt4sfJoHKXPrL8OU11uBpnT1BliYqMVsFfMqu9J8mg/FAz3w74jzteQIdulcSuyrTcwtYK8z6Bdzj4iG9FlBa9coQn1MQK6X2eH41LwBRXIKMX02zeI5/G4RLol194oOBNmWY70BUVFSIxejp/+tAvv+i/KDsRaDD6UwAP99AJnCiVJb3DgzQ/MApN8Vnoy9aBF+W2Q/fSLvknr4ixq7nQ93EZ3BqbY/5+y/FnxZKN7c+SN2DCP1tCc03BKi33kT455J/g0zf8byIl5ppgqM0DYzUkzi38CJk13wFOI/OctMwDkz2n2a2EvWSSJl8i2FCOC83fHaM/GtDuDVEzJV9/zY+uMjAM3mLVve8X+V3zKnxsQXBI/5rAVruOYUv433tN8jqHrEL8M0vp4KApXyu1QzrlWgbNENt0jhoNlGj7ukjWWzSOQIFYyzJIH6fjEs7V37dWVEYo+DHwQaV66qZUPYTwX3PfoglW7jeWJ1ckOLeel3ATf0QWZyV1h7qrJHTmjTvutypk2IXg0UfArEymNfk05bbDWsIgce0KDq1vldavdFsTNNv2W0mIH0CBA9OCo2uDKYNvtDBIM391z0WaMlDj55KeKrh2n26+rvtX7WUg1SeQMyz2Aea0Yr/IEL+wHOLfe2mv+mYISVLfHDSCgmJgTspuHsbPcruFJmhVMxH4v+Eo8MrB9jcaHPFCP1Y6gPg235COcz3SSXxU6rngKkY9Xjr9ncSHuMvl620wKL/FRWwJo7YLFsqWXS3hntx+1OVqc6OF7HJJ4Lyo/J7iepjcZudY7J1HevVFsDxQ3RPjAu+JN+81T7lFVPwETW2NT5FqKcdVWPX28VEkRS3c2UGHGqYOujuWQRf9vXr9XlNpvaEDkjoChNZDvgjFxco190VOHmmrgorlYH6uxOjksGQ7GVrP/nxFf9H0VdCowqxm8NRliQxEc3so6SChl3/F6Ri7/LxOUWGhLZIGWIf1q8lWKyycH8UOiVWiknxcpX/cXbVtI0QZwuXzNHNpFxUgzNWJvJ4ic/7Os/JvKA6HxQvLyxytTnUnq1vQpUMoUwWAOV10y2RziXN9H9FEhsfL82+sqD3x9y/uRWYrzEYyWYb7+7Vq+FoJJ7sf0jR1lylz8wi1W3nk7nzoKBAux9y2NTI2jN2PquxaNVFtjKNevb1Bvf+V3fe1TQat5TkcsIwJ2YAwptzzr5HjDycpTN1VTFFEt96jjdqTiDuG7pbySrVLuDqKPe2zNW7MjelUmbQmkwPsbWSiB6Ik6dACE/Mjsr9+GvVkm11TthZzzaUAGSjuNLD7hAkvtE1asLbCoAYuXWmZJjHCpvryg12Nfw2RPDDIwsF/GqnZFFmqIBHug2qvd8+J9XoOmPqSW3j2weEhihM23rqAoduKazBl0DDF/qV2hjTS+pWkq/FpPsmkW8RxLNgWTTIg9dP6/LIjvVNY6HlOEnDE6xNCrPghNI2CSzq0rKTK3sOp3cmKpBMn97U3Q2+RYbakWaKXgpl1ve1agtOLuX90fn6VsokuCQHhQ8VMiOKZp2S/Z50PLznf4ZltAE72Lmkpkq0Jd7Hdc8gEXZXckUTSoFAyKkRjeju5iEfMFMOgeZWaiiujWGHrUIcQ+V+GtXYGpTykRmuVhktZ5FVoaCqT4QMKYy4i0cBim6dll52aP/vxho7SrHE+loEy5wPFBeBvKAospQ5p1OTQCxIH175f13zkUKEgkwpdMXmmubKGmeOZxG3mvCDFwvNknXBI8HclGa5+Mcg6gU+6hcRGg9H/cukajx4TRVk3REnWlElz1kTEigl0oRAP7MQ6hxKaOgRO3sXCuT29/uEvD5cacor8DKz1T3x2DtuM6HRUrzKdRDS2uobj/mDwuXBEZWSwuqTBi5SvA7xDcgosvvTHB+sQqR/YgSZEABxW07ZKNsklKB/FNsE9aD7F0CY8tzZgueM8JFpnxCzjxNI7lG2wZHQanHI6fo2xdXF2jmWu9AzcpTudJ1G1TnOw0S9AXRtqRghr8tEc711mA0wfkhDP/FckZVKGPgqsIpsa/B4VLotw/wVsH3N1NuFYhXRfpdga5MTr1sGCaF/INAZKY2RV7OJXb1WpGpfGuXxUzPPBSuXv3mwcHuGPkrEgn1wfDV0506efbFpWSFwo3Gpvz2wMMu/xxe8VXY02l64kvfzCjocPn1vuu3cfHD7YOMpgk/BF0EtTYc9eQEOUWgWLWAWPrbZkmA54lCG1ENaJTctNk0tUK+j4F37MajYJD2aHCh3ZXxdq5fHGz0eLwFhQqxcO3j9VPNykywwcgZyV4FbHLOOUborI7qRh3FDTpQrv8NSgI7RAJmgdkJiqUImC/Wi+5oCE/FcjxNDTJSUb0UOJTNpFR4bQLoCM+RnDjAMWIdR0/wjJM3ZeCE0tMY+mPg53Qk6xsaVbOcZzhbS22eFbpi4b0+0cMBHv5BMhSOylfp5q9BMB/p/EfMkOSDhztPrAofLMt9Sd8XwbgMfh2pTRlmMJZ2NiDHmjK+GUcnTsrA6HksSQ89dPWyJEqjkdr/ROW/5LPH+SbShIIgT6i4/lSTYssVf1X5+pzPhxTuwhTrjHS5vaz1e166SzMUwVmi6LXste6ItzxJockQFFmcF5EdLFQu8ow+2csB78SjEKTFuMnSGAmqKxKpxORZ1fsV4v9YCNfWs03sza27QU6nfH1i/aIOj4prEHiuEjiKkUjky8ZlJ3x97IADlgHY2+kBF20+SeCY/q8np3AyNOWiW7wTvWTuDxNTgKHADqCjfdi6OvStTf+QRDfhcBGGK1fCnBHu5U4TBhy+QifnFfl4vje8/mlg+idlN6GcGfroc9rPQLZKIdodYzCTN/97Dcw1LvpQk/ytTdVg2WjJi3ZZ6h/b+LTodRO9eh4pzpvBSQIGI7LYK2MbGbP5ePpe5VE5V7GKwMdgezgNZ2eJsgS1lrvasilPgaLfJ/jgsw5nypaDz4d5pDoYdbQHcYZwqB0NPx1SP/lemKH0velWPo4OxstNzqiaS5z4d35awOwKklgvvwg8g5mz/f9ZGYHzfHXhXOgeXe96zx0Eo62pepz4gdyOGg+QI8i5hMU4+BWAEzhQ7InIgzsMhwzCvUXFWD7hdJb6jDvOiwQWpdOgPatE+dq54jlRENfKnr4ccCfAR1D9JUyewiuWOA/egk+cvomhfld2RCPu4bfHgHTTE2Jrf+BmcmeqvE3W57FLFoAOvwRnm/dunILNsi6TjDGddJ4DTOzFiJRo31euqBnF22mlMEctcHRpJTO4Nv94LSkz0bsUN4qe3LQ1mDlmH1p6v31vqpF4GOr/3vjoOdRJ0wiF/a7khci2Qule7OTwTaN8UGJRBywY0W97IRGQnuahsvVdc9U5FE4CxsAWp910l/nKp2JKz5av1lT9zcLln4ThNle1Z2Yeweo7l0iyJInDNdBnuKVPrhMZ9Yn+AdUjt9XtfGvBrcuUCIiM2gaaA7VtDiGRQJXM4WaXtTJC8JK8ekmTOUsIIFUW0vHR5kYk+pUNSsu8pbpYcIBAhJpDox220Jq/hU4vTpx/VqQbjBOwNsFH7/y2dS8lbGHmbu2pEKc/z8fhWEA2W0rJQytPPhWzIM3zqebRt0Bo0Lo+5m6jbOmWmeqAG7hJQEqBO9L0kzsA1KqzHi7pUU60B0SyFo0QaoHaQTVYi1HjvRDVo5HWhKmrHIuIZUTpF77SoswOVeDl3o91CwbC8ivZznEP8ZwTQpMBLAjANVeCAl3LkzKj4W9aHk5ja5fQcErfIbgDAsMbI9zKEh7gpqV0fEG3lFXBz2BUlunINMgMbfLhUAxPpju6nwg7nmT7JMzXc48ZcP2psIz12ujw67yI19WxREjIu0icBqhY9lPs8I/UVF3DvuSxopwoIJ8yxeklm+cVh0mLsd57E8Mw/IqBMuzSuL0ME+0qM+bp4wYQEcEdI1smTW0iCFjXgutGrL53u9/qfB/cAMROD0T219KEcvcWHky9L9qrVsLDz67UFttNVNblIU6oMpCHjpt4HAGcGSgq3Q8YjT9teQ9BZLzpCdYVWMSV2iMU7w+UCrgjCulFHdCeSAn9Sb+6q+5fzthTaKvIXqdjEwRCr4/N49gfo2jLzeShE/qCJU5aBlmAefcRrvy2w1/WY8sBeOLzvUoDfB64ow3LvkQtgPdkIj9a0uA9KcPMXLcv/7eSiVQPOgQ5Pd5KKoTkIy9Kv4aBau0ZKf7CjJhyM+A5gGKNMsjewDeBIV10f8XdiG/Q56/b+CQ77Oax0zo50KrzB+wDcLgURdEadrKFE5ccijBsHQQHXh5WlGyZzbjbLLTC6BbhLptXwCjydGQZLSaJQ635gRch3bcTodH3wtnXsBxzJexb+ITt7sSEpjBUNSgVG5DgQFHutOwQX4aLKLYcShs8qmhlj0fYnWBd9xdyASlc0nxMMnz6lXmk7T/uv6+OafM+no6bTd0CPMuxlh988KuNyPKZYOsvu4NaX5AP9pvYkdsLpclzRMVDFRS4CBQtxk16u2HEQyOs3XemC9IaLmvlmpySE6MyOPZ4ho/GwmUtq763HEJtECETB6HASQOTK2j8QHx4Xi7LbNIG2jOLmYxuQxWfQgjBO92YZ4NxXZDa7QZbJ8YSp6p1xMD7xlJ4nHIu7GWmA4BaLmHpJbZhJHgZSSokJzFY21glS2rQp7sYOiOjsgqRGxUKhT4zX/lV4ffwnNp4VHKNrKGXmsdSwIsrJksCr2qpcfiUnz0WGFY/nxpGsKMIGISw2W4J3szrUn8MDQjOmj9Bz6rqVmfxKnkif2a1IIEGg/AYyd5DPAoLINFbO1+NnozQZaQjbwxVjciZNInysiHLfIm5afhUlOImI3TLglC+1AgMT4b6LYJHIy7aC2TJdfC3Mzk5EJixAGDH19mDRXVV1jx8XE5PLs4oiQ+lRKjYVl2TOnGabam9Eaq1MKHeM5IuYHRvGMc7XRbjNj4UIlXTCTW86Lq5j5ttX7/9AQvy9AZf7hzKrUg50IoqKeMbMIyxpGUBgaRB0vigZZCzHEJG6nW078VzJnqkktLWhBiZXv8aDLeGMMi/WkdbPb1rrefA9QhcBh3+rwJ5GU/mnOVGyzGkBeeph6oERTB/ZgSEQx948KHfyl+Ph0InCmL+MOQ3X5kwdV+MYvMJnuHnOWL/EBZb6YbTlO/Y+orUuyuV8I9tx6qv0ZhGo8zWcB6hC1aoiIrgd+tvUzaSyBAswcTIqFNvSFfrFz5UzBYRwMSiBLry3wzKJ7yyX/+JJIkzykAjq5MZRDCvLqf/o5x5LVMNYM6AmZGqBD14XIRr/MDMdN47o7WBKp1HKQ90/d8JsqzCWE3+Aem25Hc+hszqB4xUG54zKKLWB9pwkccpPGOjGLwDHYb83EA21z0q5enF78h4Wh8BpLMXAFmiz6JQ5cwKH5V+DHKIQ6h+uOqK8zOoBvoHhncG97A1B8yMh5Uiy8+/TJ9E4fLcZHCcbs4Q0dTGHIt8BjPTGDN2McfKMZjrJEKN9zxuj8nIRZMEp8oQlJRM9Ptv++q5xQbKGSUDaiUDyWm/Ev9ka0nyWHLt+15wNiv5PGAA5R+OlR2OFQ6Takn5PA7UFjILD2CFm4Ku9kuZvu0WNGQl3yUmA6WCcnyTQw/BLGFJCSdQZ8ph+4YSax7l2fAX3+D31e3KK4Pv8dWR1v1rcNo4A1PlkzYwcZ7JP0w4CQQpJWF8T3FZ8btHLrdQWawhyI+xmkQoNEzNUjDeJBDkIR3zm/Khel6XKZhlfgIIRULJxR5pOcDCkbePAClLHj8l1ZO7lnYWBs7xlpE5kMwdSHN4mSAPMTl6o7Fq4Lbx516semp1uQq5PzSnzX+wV2gEkg+OjKfY1GrSPIpBtrPNhTQhY231e7WqQQDhwCdt1Z/J1BvAiGwWFGNHYv/9/zTWJ+yxcq++oxWMHN0muyjhfUiS05tpnY3uIrxYrx98vYqwn9XuaJ05Viudl/VaV6WJVx2p+/VrxgUDnsNNBJWFV1qir8+idCLHtv8Zre8NSNCRXQmc2ke05F/gGSm0G/xwJOwHTRy5pO/ufJzJ/wbaAYg6lj7F5up/gFhQRPkE2C1+7yr8rOUeQmdZOju+oaf5l+Me2fEoggVNhrmYvNd807K6IpwvP6IwzqY/fUxkG9FCnTLZ6Gnum7HIRKpc78MRW4Oy6FJsVoEf/ZbI7rIfk27StOWd+psACUj2cACwoVOsbB1cBCt/Rsh9ALTaInxSd9EQsdlN+CqT5Cpe1FzNqYyoOceMT3nBQ0vKy4DktIULeSGxd/ZZgHUDF4AaUl2zAVp8n3dF32VBNkd9XdehfrldsUdxOHMXfVMdvwbunVDNW4/+Qy2dqsi4a0KOHfBV7srQl0l0xBHjCwlg4stEFXg2IGFEJkSAWvXkLyDw1n7tnr8cKGQJB+aMDofQW8+182Chggdf2jGHBZndE74LUZqyRPs2bJ6rsYL5bOdeQhqAdn5l9ZaA8G60s7E0KAp7iVqv2wTl319oSAHWsVisZKNp8wj4mNB2O6Bfomd/2c16nqKIAyQcQIRRn6trwCxtm2bnZuULXbBccppBkOGKsRl3FdW+5CoUAcnbCn4XXRdP60lH5wyKXNv8lwbOGi5jfmF+z/Cw+fTLVPXYuQtikwyl4s6rCOY5pJz/x5O5wh67xxQwTK4DSV1/EdF44rI6MknIWkYBTCtV2LgQmXE2GVMJktf0fJPwx1EmlgUnqXjeX+ob8fKS0wBQ2dzmGcmmS9MYvTfRSA1yIcmYTqyfWXB18RMpZvavnoGe1o0khBTC7Dx5fApOw78X1KPajHMHBrr/V3nY6zY7iL9IuOGcwgRfrGdJGmVs/JNADdwxxBsP32NxyYjRX7n1kByOLySjTb2c0TZcXdV7PVyujckclOcLiqPW+ojdErnkwFEcnKcgz0A07V1E6mZQuKhaULnLl1tS89Q5CTMZsjzVbYtgphEIvzG1dlqnpTUTq4DIwBmo0Ilj2qzpPp8xAHLuo8cWY3PkSt71J2pRffnwOeUpjRiYrDYPd6qU4UyhQkFJvFrHL+fvUr+FCQ83mN1i/liPPqJLIo8bUirSL3RwRIXBbeGtIrtDvZ9wHmN1FphFG2P3DSNqCgNrcYa3wn++4oQPsi+MnOIQ4TWhUVjgwBNruJjI+8R5lQlGj88tIfz3q9CmJ+labiTV20+YMM8Dy33OLkRgEbXAs/BqfqeKQ+LDbm4M+UwMucpmr4fje3kAzG+K2D5mk9E2ag5xv6fKdste9bsw8vdbUIM7YxUS+KhZ7SFVcuCYbW+k6qgukkFlerkRSJoHiq1QBpdgcLS4R4ggio7h2iXJbeQTmSv1ZWh6RqayLr25jfZUm9wna0c/KhTCx4cBPUTCK1HdyfbzC5Au2aJ6He7yPCO4E16tZzC7GAWI89seExEWAqemgkl3e98SrzyLK+wr0qeHw9VMn890bUWar8jg+eEswropPQmhVKJ68N8fKk9BtSCyIVGhf8DiDwMLCWupiFu12PsCzHJqsyDDGrKMKh+1z3mCFLX8lWt/ofv7tbiaITHeyPf1v6VxPvx3l7FAr3+i3L/aNQra/Wv2pxQHeGg4xMsfLiwp8x3HamsiU44Z13ASeC34Ec4yuIGG6++ovTtweshORMwfNI2NE2fb4nYBUpYEIfsEXZnNVSzmMlq/A/5RF6evF+l82C+vD8J02bzcPuhja2V3TJRu1hMwGJK+0MEQSLkYEl2O9S+MZUeS6jspjefxKRkFMaOKbRFUxsnADJ/LYCu0PZKdE+V+nzE57RNgybaQ+cFaqaWcc1ZEz+8cbFrw7OQWt05qXz8y6BsChP6ruCttJftRg/kjbWqL8j4JUC1r8fI9GewPWpN+9EViyt2bYRv8bzv2Hw0aImcDYCFU/1sXKtQVG/BAGKosFvFTEGydL0WiTZeJfEzsWxt/i4w1syAf37UdcZBxGSeAuazS36S19L+4Iht9lnEyq/yIms6o7YBFcl35WDFIiYDwBdSaMRXcJOmBCxBYrszvMeDutbNpKT8hwnuJy8YTCl9JkE+R5ckWpy9uR4PT2WlBxi9auFYB+3mAYgBLQmjML7VyTHKufT3lRL/Ywy7OO2X3vGtPWYRTW5vUozwZXXey6JdYyNqBvo3mBMmDkrZweg9T2ReTa/yFAzb3iBGRWbA/rNQJXsero0lxYxFgTDc95pKlnt0ZJY5HJa4ox4rxXxc1E3CizB8JKYqfayXPd0xN5Rz0ojzKnOGWO7aHIcz95xEYm4jRz8N1SpZK0HSh6aSe8k11oH6K0H5uEqWcIZ0On/Lq0XwG3Xx2xXRJQuJ+j2JvlddJzyJDEcH9e7FYB1XOdvdfZnDS2PsKb8p4bsdivzYZ07EcpUUEXquKSlp/kkZBe15LmMhfR/niXMFRI8I4Akl38GfsQ3YiLlIQs1PpJiqqMseiFSoy7dai/5HKorAIIE072+/kY2/h1jH/yG/nPhk1EhuILQZahs5lGOMoINJsfnDpdmpzuHYIpqQrF8Lx5pNHUVFlEKTGKZniaI8a9hP7ZqUAb1C3H8z9Hr5CWGppwYlXd8B8taIkT3ofpGBh7VnBZLeXqVYyb9DFcS1DxMi+NAzLW8tV6WKHF3IY6qlT/NqMDJ38MBxBC4jW+uTyOtbtVRT+txOXUHbrKX7KPO9iXiov7fvPspj8QOKhKX9DAcpHPfrjeHuzuP1PDpXXRCUHRyuc1oJ6XbgjzZ8X7KM+uU9pIg2EvCMpIpdeM6YUjXOBLFz3r6nYP2L0C0H6girHTzrGMnc1RlbIxHuCW4kemRXR5t28KF0L/sGQh3pOPB3s7FoWa/v+PxOvZu2YWcAXAirSCTHBAwUNESKXO+2EwiIdSaSr9kvz8IT6bgBXHdt67JMOsHk5a850WwrTWtq4XjnLw1LVwUeY44n0PN8DphSgVq5QZPSaQrEUy+mop0/ACDOMMST4d8wtd1LOr7t26e3Wv+NP6+3yDJEN+16sqfQQ1529SMbTlbUpI9C7NGikYmFxL7YxApC/RLuooPvqHrk0eUomfeUz71+16RY5Zr4GFYNj5fKrAN43ktG6jGyDTB8kmWJJbK5c1p6KGhmWejNBg6c0/zjyUiKDoJyEy/u45M2f9NGmVQO/JkGptzSPBvhmbFHTqzQF+4SE4ReDA9Bc0vqCdCW3UXniU7BVuEaXQA4Hs3yazqFE/9bHLmQEYO54tq1huVUfFz4+cntkytcS6WHYkpyQo0eUB0mz+zA6vVQaS86wTFlRv9/30R5DggQ+CfrKSaqVfUpFllyHKBfAm6f8RRSHjxXxGV357VUemy5jQolVyByTXSO3t3sxjL5ruGgyvYBxY11pdkGka2JXhRJ2h1T+B84UBZj9AkrD1uTD04X6x0FkjKl/cZyI14SRlrSPc75smy10fLR4kK0KSZiw/HqoPTvvAQEVch+9ne0SBUm+QDljS/Co08jnX0CnlpQzxNOvA6vbUpUsBWbfL5IXtdG8zada2c7QSUKtQlDkY7/pxM/ms3XjdlNI+hxQbWtVFGDkIAlXQL/tKyRPZJDWoPH0s13+TrcHbQN8DgWIj6rhMO/tJBRhS21+M1YT2gSQ1nrskTnXo2ypfXBLi/gQW1WOtTRHw4COiHpt5VZpxBWYg2p75TTA6356i9P0FKNp47IS+lYEu0r4U+r6YZ34GFTUOZPFtRa0BGLt99sSlsO+UhclhyRCczk2lf10fz6dQV6zX2dwwT26UzWwa5m5nj1d5l3+V7JwGiPWmQkERTOoceF8/cmBVAQwOuxSm22RgDC0QQKa4rk3ZD7fphlvha+ATgfV7ycpjzCQnc80fKsMJQ7uG/ib1GAn2FbI2TtRrw53pyV6oyC0RXviS5d6sMrL01U+ZGp5k97L1KRsT92M8KLxWry5szQAuLLcnD+liBw8RvzM7fh8B3rRf8KkKHrwBnwKicpNvp+kVKG5b04zVDp4TmZlitx9nyVErKyRIvT0u8aYWxkWVMj1UmjqkkUPZUXtZJY7N0X6yTcHUKInw5oYigg7YQyjxLtlPzj8HTRyIY08MY4dAIIxB+LkMmP2yHSu0llkQrUFoOaKBdIcNv0sI0jn92QiCzWnapTqDtOhXv6nXr8+zvjoTBDyOfPShsX2AZVCmb2cQN+xswcz+WDEiAVb3Lp2m+95Ei+tC0E7qv1rGvqIXLjN8aP+ceY+R5WGAj03ij4aDBQkZPSfy+91prkSZxOw6meE8VIeRy5V57QB+FrsYwLYMx5XLssXdyJBcJ3XTkYqukKq2OtR4EaoHyYJJ5hz8/cmixAwdw03Xcd2P1aG5ak97moWtLPFe0OFTUIzd5uMz6lpFRhP1T8dLmdJfS3KcvocWeWi54ythO0dD6LB+Gw/0ry7MpvTeeZ8e+f8cPkiNrT8yBLn69o/ejTW186QCSn3xDBIcXvk+QE/mhEMdN1UrZJp0S76fPZeX+EIbZyKjlZvvZrwBuwiVDMdcH8OKMX7Iy5oisRBXLk+ZcrYBFB6WJSCjaf7XfzbkjYq4984IhtD31Sh4oP902vch1D2+ihtc5YtTtq9srAsSr/L2tNRXRmln9r8b77t/LeVN5ZLfRIqp29W2CLBxrwpwyQtRZxACMzua8xw45yq8Wuow9RxKg/TdioUqGkxAx1cTz2p0+owDZrHjbvawJ4e50TD39OEv8fMHFjmJeNfMjwUU/tHiUncjM3l/RR8rAH/KcSzcE3W+8MVJDu28k2ZbEY8/Zrl1bjqhc2lgdUpnA26udqyqz3PHD9g+IdwxeRmu+M+SCmXXoce6xJBnyWaBTALGM+LjVUNspbN7BdWi196RyKDRw82GjwhVb7Yg6/A2dU5GGqXmJYcWHMsaOuCgYb+trfJV1N2ZcS43N7Wk/CrYbIwGG88PeSnhCiRKCnvenq8RKXaidqTUUZcMV9q2LGy7TUXReAuWt7cw05UzZntaAvzwipxDx3jHqTolIBxgzuCX3bmU0CMauJgCYb0bPKOag4sSLb7eQi5N6Q6dIe1HDU5vvmGRDf/BXmFmncGeTy/NTMDwVIoJ5fNQiOCoLSYfTMHKhzhobRUGvF/fWOt0TIITGCStNXXECGrkf1d0M7CuZBEBXPx2+Ul1DoDRkqJsKje8j6pzolUSZh5HbDFRFcJaatzmRN9qMi5saHeTLqXo1E8kcJAV7lcTNrHBSnmxadvUV5XnUTXrhDRjUlh50yQEI5aHp4SQbTUmI45a9emUHYLQ98+jEWv5A4LrYRhJWpY+zeDDO83+81/k/6K9Jwut29eoVnVUXHWo7N/OnQl1NWh03NUS6mQNU/h07hZXbhXIxjaaFojnOZvhe4wtPRjo2ebVxaYSBkyHfzjkqu0w3hKU7ruJ3nK4Wt247qh5XastrrkOWojzdA+v7/8q88O33wA4R8DhcsPhDUEg3CbGJiufaIqMm5TfFqw4R1fWuBgRX4ZfCBjxYh3SAaApRycDrpbSsszsv0oT/utmxKZ67T5NjiIgE5CVDyx3kIX98B13+QLkGWKYvArGnA4XUoL+I89wttqqQ3UqSRqqUGZh0fDnCXrbTFOE4RCK8VjC196qIB8D/KkOQlW32gKiD8Vak4/xWEESfuIVJnfcGjZrzgpbTt+3v0m6rh7CBv/Fh7urlZW/v7P/L5UHan6PVpTcSgRpe/pgbLGOha7eABOCtEHYYRj14zZGzEU+H6/kJAgVNQ6cktz4kTUhqq1JmPrMLMYRW9gliQoITZGH5Zj8ZxA+wRBCik7iTukDw5JhPeOGRsrR8t8t+U49RkhN6ZeUmANLPzCw8ixzJbmwKLS9p59iPCtfGPl5hhsiZ4a7zIJVfGDQGYBFNlwljen0x22A208GETN1pr8Lnejh8UUxANaZK9CqBeiwkCmlXFrYAxcDbPJLm8j5ls2G+Feo0G36mmMlH7+VNieg5VOvIRs9frZfIyZHsmpP/Bg9EN/fVfqUDNmidzDtqHCuK8XQ7GW3P0swJ/dhnEv6FzsgyTt7C5wQKvq8tFytvnwnYyb2g3TdoZz+yTtllHoRqc5c4i/T0l0iJ02Q5Jt9gkYo69eaEgNHNi16Aj7kylXI7AUkcGZUJnRL9yIYPYoyTG1TyNqTqaNsvI+qEq/s/CZKWxpErNg5Qn30GGfhycPnVSM4yWig+uzU8NMLsZh8COXG93owhqQsllEOq8p/OkJyJnyQISxZGJeh+LnmAqV59xWGab2yqIdrn0BTTC3QJqcLqKxhmh53CqfviQRY31Qec2Zr8jnK4BNq1f8xw25xXssbW6JwZavwBlNCDWiuxu/jFmi7e6ZyVr+8Fu2zUtNiMEjdXy4sGi6mfK8dahdBhwO+JIfNl1ecwYt++2aYSfq8He6CjDJ9GOrGopV3V42nx7oS9+4O8ImzpjXePnmxG3iA4jqHudRgbx4a0nxuHqCxp1FYU3ZRCQLr0H6WGkKnyobXdKsgEIqTLkIuPolhQ/XSdSsIFA1O3LKh48EkrMvVnC2h3NA+kEtiVnRSCi/t1JZVmIQwWpiRuhq9O3hIaiFqX4CsL3hxu8IR4FiT4GgO2+XKSqV8JEYI+eqEGvzd7rGiv7IvHbV2Kw+HAVkX1Gm2tdGachcMMGTq6xmh33V+g6S3hKKZ0OLZfTExnfg48dvCcs2QbJqe9d5pL1/1ENU/3WpyOmVqfs8pEkQRR5SiORpJreNTDpbBOowM13k55NVj2iqH0Tci+BcO5nrMk5oukFMuqF0z3K/CApt51DEAFwjV0q5TMZXLXURvFQUq8DS6C2ssNq37h5CpHV9H6KhtzJDfI1oURI9WYTZHmMmxP/p/ES8BlPq+e+1lsNpzNueFxKF6qd4x9CS11N0BseJuXlJn/0iFtLxALW11MvzoEmBZpqxtkoore9sPOdtcR/i/O0YWIFHusowawKC3YBxYpBpeUqVJ85+NotCPMdhSoKG/9tajLLwowalMb1PZhfRG41/skvkIKqgYhFRi523ffknUnQ7Xe3k0lEVI6Hb0DtRasBoOsttjLWAJyT0cCREMFTLr9urbwZKNyhC5OSSDFykKWsQoFq0mYHBPipvrKHuxLU2d1f5WAQ1olBslMc0N8ljo+DAXxr/zPVCmvYFDbwSzI3Yjrr+8ek7qXPYPp43M2buFiJiFeTXtMFK0T3lSU4aevsbCRWyMg44Nk/7JtNRas60EiXNKZDqm4rVl7XkL9OVlA0FhLV43x9dHuBoI1GLgervasLBWo0fMRzO3jqR+WT8cyubxYKmwoUNDXvxE9ac4EQuHHfryhxgM9MWZvFmFFEth8TcMYgZqOaua9eqykzDphdtktQZPNroRc0RHD4ys5k2TzcMgctaVYyI7FZkYYsVxpsTpuh4wh7baTXnJaXA70nsGeDHkceojvEFvcVNPLqJ9BRitLN4lKnB+/0TPInx8frGwKpLYvYIFFXf+/DHfZ4HqSDEVeOPD7UCPtBNK29DSKb3zfrP27KjZHy5clVpaVHax8t9CCrgcMZr+3wo2metK+83u+9WoaBYZdj+wZu5rwmC5nYkHrg+fNYNSk33bRlSwLPR/BYzpe9d7xI9rwkAIq5Fg4Nbr+2xITYL1iujq3B19sGxiasXrSJjJrelrsjs7jHF41W+482njXrkDKIvsrENmgBgPFFhVk8htEEwNyPC82osLL08UK5SzIkpzZVlVwyQ/Z7xZ+bu6Ptd6YrCBZuO8eIAybPgNQAao+e3S9tlfIcuxx13BqbcNa8o8yiXhKfzY8Jec3IWI79A8FhoDZq5JPla2/PMYZ5IauzsOu4QVkdNEZ3pi6Iu4od8p0hJMfcWE88R0/xWoRwdu+me8ae6xIQZbVjFK7FbKv/mujqn173RrOGDfLoKKeKUpCiagktWk68z6Oi7nliwsYGhBT0wkFVa2+VM7xcYHgXsyRhWjc2c3fXSpVWl1mMYd7MJSxkKmAAn5bmyTCdipFD1yhMPYnVHUeFTobAHOq6wboA3MqYTdk33QXe8fyzbSOIwIYgnGAJJQkvLjdDpXAtLo2VImmh61C5l58ECDmK8E2WsqUMZgDKhM0U5cbi3etXVHBqgXD2zgF5TOMIn7sxfMeDDSTPUdklZBv3KA040cIfsnYQWOqHczE0Z7Fe2MCMoyXg+ggwsVt513l++Z9VsVPV8P8+rxC03L1A3WYJ2RGmmg7K06kEwhT9/WbHoyOk1ptHSCaJBxKkjbIxRJC3v0d0zzxgG48yhT3NxZ9VDytQNYZKnjdLPAW13SABYsa8o0/iO6y3j2+z1GOZZndsFjU+ftKSAGcM+0mVYDvu/op5Ej01d7CfFMwP90ZCmGr8aKDK954Cv0wqjr3w6VQz1oBqzGJW+A8a8erLPZlI+Sc4EXPGXWLIJUh8cDcPKySBhouqVJiUGKQ7tMnv9heiFjQ8sdLxy5h1cO15qOXrZ5YmTwsJU+3suEP0A9wLpsOfupAcRcYDLm5yrmJn9w+knOJe4Mx4N94dG1I0yoR0MRFXM45kQo13yqw+qF/fxFOqN78/3lByqZhA1XTN7E4HX/Kti6dwg9LhWfgIm6SLMPMd1Qj3mGljY1ofM+m/TYcRbS1zCpjzmMPm/CA2KY5kmhEhsxREN0rvUJMJAUXg6RYpB7NBD8GtECLBKCvwpfDXzlqg7FQIRyHiWQG+yI2APuYFVqlg4Khjrgl4IB9RB3lbcupv3b8SCqsjkR63CkCDLnQnRWc52M34Z4sVflQURKC1Oxu+GkqNKunXXN5QoNIds3c7wyosPA9ElfKqb1gyKI8qBrk+sxf++JOutoQUBOHFLkqeGnGB0fV5ESCm2q/Sk8bGO6K8oZXLNCvF4WGYgk9E5Z0LnX84VjYml2ISY0gTP8bUgftCEd8f2aGNXdVhBidWJrCLbkXOXevFE7HoVYA4SrvrO3IxGboGx4JsPQHQDpki9Ufq//HedIIj510DU7/e3Wt2yWwqPLAmp57nrz6wUJygzl1wbOTdl4fI8RZspv0eibzj1SaImduIpMn2Q5yWB0dM/Q8wHv/3bjvZoUw1vOItTamyZfanB+sTi0+o9QoRZlkdX6yhx3yN/fJO+B3Uwne7G/lJJ/GdwlrZYq04Z6uVSte0fZncAE3GCrU1ygVfu3S5yBztwdVjKrC4RtFOpViXUvwTlY0t9PmvHHPROq/0AuRmL6fzioJ/bydrNHmh0htCYaKdxZASexe0+NyZb/HLS4GdYLHZdgK92pjb6/G54Ze7+r0V1YpZ5mIxDeyoj0grP0ZT7CgU/unF/W4sPMIPnKpkdZoWc4q/5GWdcgmGlOeEKmlxTw4YJLocdlj33ptHw0wDkU+XeI3bpC3Qs1hrqtua5cZS0YxljON1A/b+2bzi+FzxnGS9QlySnrfk1vNkmdTnsvbCdMfemaS1n47W5sFBejBUqfOnGPMWXZv/JsbQdiPgTjxPqfGpxmoVWDOtLdj0J/F6bRdQ1LXVRWuVjkcWqoH+MAKnBg/tw9PhJRgzMGoEVsrTtNaoGCGn6uC+QxtABcg8+00UlgsW3Mb9Y1t/w/eFrCorV7y05ZueWa/C8ifQsACbMxo/FkU+dRfEDT9yR4pdz7N2UxqgJSizo4RJJkUCeHhjVGTVOi2lgK3n34hklZvRhMmc84WqqZlanjyPYhXSmQWmzGfMNc05iTuG0lOBh0idWvr9uufaNsckcbWXy94QrtakUe1oy5xuzsPNGVOhNnFnGPhVhkxTZAeJb8BeThJZjexJ9KGjGbGxgt/8d1Uh6tn0EiY7Ji3h7V7fXXT4MXZSV6j4NW7pZcGdoi7YV8xPv6VBoHAyYdKuniX2YKldMYV+I2PduGUeZf06e6rAzDmaIdkojI9JghZyn4kzPacR0KgGZjgoVHV8PJz8jqaBbAMUgBUXNCXq3jiISAjBrUMFAga8O6UT7RebaXEL04mllq7r2N6Kplnq4K6PbcbgxM5NwiniWidwP2hqL3r4qeHkWmT9ycAUIWgSob7Yov4G9hhMeFrmy32Zaxrqixi6hIHvdzs/wPZFvVReHG27DmOKNYl0WA3Kfsig+/FiBvItrMGbkmhmslSS5QtJy0rp+JAWdKxQGixwF/FcJnhi/WQP+iCOTf72hHXuEW2u2DqGRSgXpvKBh5V3s550aQz9OTagRHXbix8Zk/huZj89rMjFt8Zs84lKLnGDUsP6FYrDzouJJQB9ApZV2Hdoo3ba9WBx7zrw6s/vYeti/vlyMN9yQ8JCZugYc3hVIFst4+68GXttaRUCDC7vPwwHu4tUBf4z8xsa4tzhPr/MVsQo309dcl/8D0kSJw2nt4EJV3AkJ49C4JCRXx+jOAVSzhNDCh90qW9yFZuGFzlh58Ef4dEaaoCNweeX1tNQAcJeD+fOaYNRC4FVFIPDd1sGB4QTP9meeWmnsuDGwDqeo5muxwFEBiBpk88PzK7a9mBp1jGEjaqZ2cji1mf1QgFHuVgRa8RVHyuUr92ywjUJfr8YI2TfALBzLbj4qLWgf1na+Rdq2Iuk/GTAQ1olW2o4aYJiMNJ5KWmeSuH6zuq1IPj3BZnf26LqoSS81ZmzW9IE5UmBbs4+w1bcH8U1IzOyA8Yjs8HjXK4Nw4dsO742AnnLrLr5Ol57jE1mwFUuAx3hCb+H2PnLFFaJfr+Ls4RQTzEM0GU798OHWMNkvXLQ2i7hdQY16k8B6guWON5JrOoejSgkO6Fff0hduME2MWoWgcXR8dQI1K7MeMCIKecKZEnr/L9I4mQkvoaK9LDE/OYKFWQOe//VbPoIQxcdmACjh5pVD8kQhnqWC38RD8jqDOGj0vvKgmUu+ntQ3o0yYICvN/QLZZ/cnbVGXuhLlmATNsqtA7jRTOKu+ycWxDhWYyYQVzNdIQz0dWg5mIswMQQlrqWv+R/hI9yqFlH8CSvVUFJejrPDHxfa/96za049iXIG647K4mmY0YsYwi90n1ml9HiT/odDW6xjA/040pWq3F4t6Ghnnyr3AqY4kllfplTzY3SlDiASV5gpbmuHtfK5v/nH5c+gb5gEiCWIFZyfCBiJhWUx3l+5O2x/EKLR56m4Pbm7+Zhr6yVJFy4VlRdrGMVHL4ZLObTBThoe+U8BGeqqGF9FwFJk+amrlkgrgXjiHoMnFEAUBs1hy1cqV1wY9aWtzi4EZfbLZOK5r2tekSlFLWoKVJAw5Vm4UdEHusXhFJb9Y8fs9zqQGAHoR2m+gA3inHpeJXZvE6QlFmi8IzEOuRZd0GGURIR4P4TSYNErpC4ll6ormLDt/t91g+n+U3wzwKLV/DsnQDKT0hF2y3ja4DNyfrEY/gScCYeKa5lP07iJtDB2ioEDVFR1NoAjWuTtzCM4/FMHfg4kV/+uYtFkBSmLXHP62MYt6Ye7whB+m7G+zHBzHBVV3GZa2UsKjHKNzOMJH+DQRkFl4pvjwesHAdoVOsjpH17NoJzOLkfIcNBcH2BQ0d0YmjuQL2qiJzg9lMk1DcdjPI4pgfMuTSB3tO4dlTbmSKPN4/QsU4Wzw7W/Nwy83YXEJC9JXbG/POcVgHOEEWiJw7b/j5UQGStLiS+B1a6BgE6u7O3JSO2ogqUPNXz3ENNFuBV/RlZrKSsAah9lhv46U2BLjb/dUL9c9ZJcRwPmscrAfM9ch1RIVe6Ss9qjJFtH+nXbkk1SlYKRGs6UUDZ+cLZYjozdJmfkbdkmvxRUIpTD52zwYd85U9OpT1SVVvtjvOVai9hC/xfJv0vhECnRKtr6JomzmpnCeakFUM9IHn2Gqms7ovD0EUnukKulz86/SzFY1lNSn1nUdhSNVUwmLaxJBcq9/EE/h2As9l00QkEczWsQ4MuQVZ4R/4Xk8aFhntWuQagRj0J7V3s+VgEqE8dvexZQQRnIE2eIL4xmsBS1Mm0EtDc+FeVpgyIFqDrcACCCb1AdWsxXpHIUv4XmYkbrC2XIp82OxoVX0bsbLfdu7WG/fl8fz5ekqDjXrbi3D9t7Ckdv3mXOySUpA6cDyzrVgBYvw/ep7bDk/5/GFuWUvQEx4dYMW8swa0tYUntLpIgrkPxTR3mtqSaic/Q3YbeFRyqsDheI6Ux6YeyN5PmOUKABKS8JsGAvphFr5QeeXBlPwK6EZ35g/e1/wyXvf0kXfqXEiIeRhip72VYUXZ7QifIW24QbZ5h3wcDu3d/CuPmWE2FbiI/A0liD+9QOExgM1hHYJUWqX9zArvAMFU1oSWDVwkzp20Gq5zcvv7/RWV4qewbpPAQi0bhpcdqisdrLovGmejxLmQ0hcEP4bh6nOtvRF1j0R8lEp6N3tm6I5auwJZLSjW5f/FNDZatdP3wDC7DiBqhma/VnqqmNnfqVCHOhf3KJ/meXu0IUUiXf5BcXcaZPfJDq4ukJHVEKZKIq1kwjPwUS+ACX7fbwsgpC4w4AhP1jx5xaAUz7ezGbVvgebEjRgyAyfcUcKztfpDWCvwTMMNN5UVw/q3S4DJWKC3wZ+lXl3Doh9Cf9Cq62nfGFI9jHP6Kbu0JPvvVQwd92yCuuWnSQtKiiLnm2k48wAik5f+A45E9vc0qshb/DkWsKNIn26bnoFELwoG8z+oLuoxLjX/di1gr9y1oEpVyfWwv/oKEFVTAdZuQl00sVW1yjOmrVCS652jxtO1IGwyDxKNgmqa3i+Bc5xl/Zeho5rxiw77OoU6f8QlM52pj/83XZeAf7Vtd8kVk2jbt5xgi3fJPI4D0zGvUaVf17PrQ8BnohoMV7N/UFW2u3lKUr6OOw7KUQdz/rNt7YJvXN6ew/qKuHiF8t5fKXvRnT0pqTQvS9VKCRdlM3AJESW3Ou7yoh0SnN9imqbCgLqySOSAgkUKBaJ6Fib08SLbPNVLfMRckwFG/TrHOgnqBWVEyTaxoTm8p6ozizhUdkP7Y59AA61Gtn6Fo+YEPthLO1xQLlERbhupgX3BlDV3xvHdqAI4hDeM1DH4Y56h5+mNfHqVoSbWOjMHFRjahM1Iiu5vJnCy+aOd2pp8v00wCiW4YJNnr6hki+2C2hddpAiKg2eF/if5WjCwMX8wKZIVul2pwBqWBIgRwjbTMfLS6FgdW1TaNUOKL87GYquaGxpbYB7Mo2vQR9n15ktFBbmcPF9R/zEOpJZmKuc2hYwOzhOy+9BHvDsZvxQXmilxFuGg6Fo0EfCnW2k8E4+Xi6qoNiSPLz321tjB51QE0NQHbzDixwCPqzZHLzw+wZPDgO5aR/cgtQRagKU7PFePhpKxTy4lyvb7iBWBZvxEQEKkCOhbAXJgLfLm3cizAOKxu2sXQ0z7nhwHf0CsG69LBbS1EX0y4mwSCtB1EHnNqKHjfbQQY0ZJeMx1YW3QKwPqD3V2myf4IKjvTl0p7+iMjyZVfOMn8zIaYCgFzk2l/PNqJnipMUssv8x1AVFvfg7kk4CxZGJAmGBE/A6An4m7ZUYTTVFSK59h/gDP3ah3ANFmMWmdYIxjDRqgtG5L+mEAvtK7sQGbpYSoQhU9kbES5Po6Embj+5C/eLicxULjyCVbNb/zrQewlILWGfPX9HI7w4PGd2CeWKyW4ib5R5sbBqrGJ/nbWyx0Eh2wUqL4shn8RAP1PozawXZ8BjQhMxHUDSt3xz7+dTpDk1kowC2plM+XkAsEtpiSOd5/Q3sZYP7tEHVDFK78vZl5dO2GT6b/sE0E9ByuObKjRM5QnJwcoCE8mnWuRe/p+tMKit9J+peTsvPHF7E+DhuKEZSUGLRBDritBEHJS1iTh5Ik3d88cLXLFKv4zhyaoWh5dOy7uHaePNopLBt+RjBtHppi327M97N9wxv7+RKi3rVK05T6/47Fvg4VMswHvt4/b7Qlp25SlWVUqwTtuPYlAGEkg8vIyqRjTLcAJS+L5TNHn0+mR+lgO3XXCa8eWv4mSzUCxmtkXvC8M+X42iFyv/OiXxWtpOgb5htFt7efslK70Y8vXXQorYyumkNgs2xAyDMtpOWEq6/WjxpCq0sl0SEobLtWRZOURs/vC/ryboVOY/QxNVmMKd3L0FsyNXg8lqfj9iVtYt3SAZAwConTs67Ny8IfA9kgdY2xMPaaEkF4Yl3u9xqS5RydTVH/RB2AG3rTOLBxaUkYs7nEuo0JBx0AZc7S63oUaIUOvLxmnhvGmqI1oHdiIGXbcGir7iia0r4xkGkn/CKKHthpnDifP+ER4i2Vk/jRSBPU4PiaQXp9oKk5XGr2Q8e8VARpz+x7Bv/b2fXM5C2fsCU/+I/nSR8xwGbp//XuHa7y9CDFudyKD2QcBxMWDPAT4Z0cHCwwFpCy/qNufciApH/avnTiqvTyCOWihoTIuB1YwcgOSi/n8KjlmzQVhY82uQL25ht9pbCHgHTz1MtyP6I+O7OVNiKrgAzNPLPXQD0uM3uriHe1xM0biIyxcDRgdlKPyYQm46Fsrh9FtJLn8v3lqn3v4MuMxHGei/oRhXmTH0Su1Qo5HJ9J44Og6bCBSdo48AWloVMq8Ix3Q1NtF8IoITApyWuxAXDksICHn1R0cmECwK3MDhAoHtRi43IZyDncTOSE79nlz/ir0d8OdktswG2/Mjvu6lxEeQr/cqRkkiR3+utw85dMznZsq4nfKbpoyl9R94NlkTWgslmEBeSENOo9+cuS7+82r8QeXcYSSKDz4RaYQdmXX4nNuhSX0EOKay7ISytp9VBUh9lsfuwbiA5k2huYAtzh4UY/FfHyykdVG+dRbJh/Ua7uCj/wN5Qd8zkna1wpAVNp1TSEmGSIl476QVbOg1bdCX/FMK3ZAoTrYhA5P5t0ISShTFT/36J1GQFtg/NpmKaD6KKnYF6lfmF6eSx5eBN4nBiATHphm/VDNUdtmGNbnIaISP+DRPcAXKbGqIsPB4F38dIjnbrmfG23uNFeFkd/OXfav/Xhx8ZNTNZ4/mI5eOZItV8ql+mygx92KP1kgb8ibWjUX9zmlG+BwW2cW1ViQXEmXLQeTMS0pyfWW1Cns4GMI0/vGc/ESb0qHu5NOPALyC9zctozninaUduoqyVh+hg97CR7EfPexygC0UQP5Kh5RVY8J8ch1SNSDO/Fv+DZxkW0h/rPWQ0pz29IFOXzb0KHlUwqDX6hu23haZ6/qgW5OHmFWZRgHNrH2lgc+xO1zcDZbURlT93bmMf82gTAD1C2CRLzCg9ETu7QmixJZFceA9IyYEo3REcVfLYmZ2UyWcZ46GSnbUDoEEIjrHIgoi5tQrRhk0C8sw8SNoiStx7uJy0Jot7kIwp87kIAR6L5G26XbRmR04S1CrLd8KdWQuArqcmgidmgSkQLLq13KToQmBdpGmFqoiNODwNX6P9PJD0wnQPJ8pG/AiD77N/xHWrJN3imrrkfWPZENhc0iFcrAhR+Rc32yU6iBQQEUQmg5ulweSxXvWRSccqVyDyCBSPNPjY1IJJsM5sCs/fnG8yNj9olq5RUO3yWXgN2a2k8/C4ipS0Qkt0jt0l52w1c8kAFoBu5GuVz7W7c7CwByeWN779JMYqG8JFpfvx1bpujCkLJ3wymEfVcyi/jnQX3oWsWUZO1c7zZQ3KQA/oELwQybbMnF6sOZr6EByWLSTwJ2diagcMuVid5B7DXEl7Q+XCRdLu7sYK6vAvMqxBbhb3mk9AiMNouKGSOOcsHxMgWvy2OAQB3VYMX380acov/XdnlkHrKlcHA3t+4YZm2zQHufAytXSXsqGtRRprW25pO9unniJ5NNC2ZWIwkyeZL5V2s/Ns/JJRpG8vIaEqlj9jQqC4domwRd1rq/gKbPal/LC5P0d8xUauc7lcYeMblu8hMHhpMhzKTbYGk/ny9EXOM8FL1QWZdqLBHdFXA1kKCfWAPU9BYOYh569bX+5MlB34r5fwa4+Ja3IvrHvomTL29cIEIfOjl6ByJrBjMKS1XuAGWDWHWxJXEC0fZm5K8aL+TCYxAVniwzq7rYY5gW7M5h01DX27xb4lF/337ijI/c1QoMgdr1A+5NqFBJxeaoVNw84E4mQcStAc4tDDmWpfvYAPOoMG8s4nAs0NrlF0qk98AQ+wo1fCY4K1MmtvrFnRk5OJb5KOrrfY+s1IwmBnu9h0xzbKt/+hGvmX0SPI2kL2OgRgrLTXqS8II5TFF77q6e/yU4IoHEozvHVxhw1+q1CJ6wWO+jhTMc5sg4fc2oRuiz9UCOt423mOCQ9ZVOmkf/QBBRvTSkTY8YwLl4xGIoKR58Q3mvvTFuJiY0D8Vq8vXhsHuwX328fM/1LQd7LHYV2VwAyZ4/dxBQ05FzvNA7kNrxHeV8bypmYkmp03LXqG9WWFVfGVh49PTjkns73bVmNaGVDO3Q3VNYV/exeAKmhKauc3F69X06Df/oImTTKP4LkQPmjsxBIJtgIv7GeglYIAD4GKHYzPOVPG9nyo1b4trEiZqvoF04rH7Hxi+sfmCFQcVw/msnZ7F47eERiRpz+W/JJAiYJbX6GFf/WcIrlJrqoWwrIToD9E4YE8R+piFRzb1/1QeSOFE7DwI1BAa90wie50u6oYGEhN5AIxnDXI3fJ2SDPoy3Yd0N3g7TSdexnXvg0D0tVQOPbXR91xnlhvyT5T6RH5twJA0F0XlzlvNs5EnfaWah1dv+35con52PaMi/aMNttx5kzP5H0ji5xsiD3tjG6un56vQsw7xUmrFpvH8z5fg00ZeYG6rhvMSx/LYrhUaCgJxwHEbV9aHuS4ccxjVWYeBL90cRXZVKfJUfQieQfIzQFLMkal5QO1e2qJ2gO5O1jWAXasq/eEw3VqngHtfStrf3AEWb/yqvFlZGm9k5lVksM2bSOy7uDOvvWX2sqUk4yfZ4O9mHEFVlVCuaG2owSt34hUGd8QmweB0Ac5NVMIM0HHaion2Lb+hUeIQchlhRyflRQl1i8RXJjgm+AkEninXxBr+aAlY/RwLaW1CwNNv2oLI/206LrfLWx7h6tLzrSC2xLiPDrtXu6UsyZ8TEWyLPmB1uly/nl4qIQ04MZ1tgXUBNi+bo0FUADN+ADq2A3TPcHI6X7UtA2T+EwmsMz7xw0fHNzaRyXO3pNqu3AtH4crlAb14EC1vB9+ZGWQapR8sEg477mZjmD9W305pzKbCYYBke0y+xV3dEngAxk9SJi5u8BIVJSnHzTwnq9QpVN9JjOQp3GkEzrsnmNHyarURqEDeiS8SThD1skwPIH93o2sMds/5mSy39rBmq36UD7t1nT1ORY0RTxGyfsjnzy0tP4QPE2I/voMZ8pEcQ7Ms9t0xGVPAvSVyKFRZRKzwm0xeff6JjlBvT9qpSlJo2D4ipuva7aafE7vCG55u7BoNQz1a3ndCTesIHW2H5eb8r37KKlHaUF0lxETNBGSAbmQpMjgU1x+u+RKPO3YR0FzELqSaJiEUi+yc8Unbc0TWq8ATxLvj0pECvisD5rw+BlInaQikEDDuz01pXogHshTcpakH5JRgD1UnvmtPZhPI0cL8kdun2Vfvs/0FTIvG0MqaUBGU9xfRQlnOW0J1YgjvQHi/7RfDTsCTGX+gTWDXYJ4DDjd/ighJ7Ti6jvwUX0nadYwpQrUx0yHtXXtvKbaFH6Krs5B8fNpNd9esPpqHvAtYC2OURnxKcEMzNw+yzarBRRGAmca4yTygW5vaj1UYe4KLFmi61cMMOvTDsLDgjPNH6j93ic539pzrY9LUT99I3qeWDoctALbzeilxbe4vvSP/DrFFxTR3dz8ebVvOmCkuwjdoHzNxH6xnWNsxDntFAyx+51f31jshc+i4VEOJuD8vI+AeRHdWLRcOP9U5Uo2rAnS1PRw8ZZ3NVE3EWLpjv30yI/ZRCX4qmDx9DU2aogCA75OJ+EK+x2lU323hOV80ZWui0jFIbIhofNq1jGviM/9KXUDxrvorqDLnBsvhreePyzq/Vpb/CJwiA374jWCaZi5I8E5OwzM7w/v0hJrRZkE/zydwsKkUQtMxKDf9nWJfA4+ABhWx7mhu1V/I81dKt//vpU4DogtvffMPGVL2yalEXi6DziOcKCT+ny66f8C0LFY4YFWTUk/UHizYHp1taycKyFHOtKJWE2keEBIJE6HZlimB8ClGrATZUXL5cCwRGPuOFHPthllGXZP527FLcAuhbr+fl1fRVwm3kLkWNbitUyey0VJm9btnRCEm0kH+uHxwku4JJv0Xt+8z7w/JA6HxvhGrkHK8QZjONS2NPE3qOlMnrQjEEj5ktpSyI86S4xEsW/hulgxvwp+U38Q2gKT5Fqdrr7pELDeHVJ+JXNe/6CeU0NT1wgBehA+wyfFB93We4rOaY7zgsqhAC4L5xaeHv/kXLxDXH8ZpYjr6QifJ0tGnz08Y/TupGTl3bxicmaY823EBbydAkSZa7Uddw22fFVifs5eqviXFRd31kC+gxKO1owmtxV8EunNNmALfQxBmHLX5Fi808IsJzmHOzdvn/9BJuD8c8gKvq/saUa5xC3baZa+wFgcH4IHuu3Yosq1eR07SgK008WjCvCkSZje/ChqM2rvwtt+SR6L9oP6IjiOlAcjLZZFKxqsnKbYKFdxJv+splOwKXXKBfWiAzubgnz6DVY0JOiEihNLfTEvLevIgLZA6Fhz87+e6EP6/SBwGMUh/ZHQX34J7Zdm1iVzxoYysM05qloeP5Qd7eBud6MLKbqJOqpNy5FDOwuS/4R3lwl2KHJUdlAylsH6zKQHfse/dx7+sCHu1THQv2uo3u0TztbsKmMZkGOO3F8SQoy3WkUixAtSPOn6aBDlv7FAXYg0MWJH3CqJ5Eop26eGUPBCFEpIowiBAE467heiJPc5U5g/eSoB8d+zhs2ZhmrZjwx867G0qGXWz0NS/CFV79WIfXGpTtljcQMjxMFRvEVAbXvo2G7S+BSAeIaOZvFvO2j6okPgzTeAjqcaUCyVIYnrRY4DtjRCdtTfo/FGO9vHUJw4TkgPq3Tnzsd6lXMy/fil8MbYv5IBgxE0fS5Tps97ANseuhz98ZpM+k3Uzumx5CygFuRv8j7rJPcVFocHxh/pEv1Xto3oLcEOO2tr2etVlok7oxpoH71WzcINOZ/EU6BR7AIz4xKVF+USK1iH04a7zNDldWhxT6YnAMYIJVEApkzX3Qk+LXsV3VTa1bXxkjFV3IkocLroPG6Mb2J+Es47UsrL3Dj54m5ADHsGQj6VhAZzjZyvbAHKt1yVb1n+jsI8sxH0YEF/96smV4Szv9wnbW7Q1DcODvoSL2VEL0nAtN/iJNa4YBgJNLQcPqff69XM2wfRINehX6GaF3ZlhcXyhzpJ2RoNUTMWZtIWT8dSG/qP2c0tm1lSYpi4W/Ei7r9NPN39VpeROv34giLQdyx+EzHnZT3ycmqoaWTP7zDaKai868/m2YP5pNUSyI/+pI66AQGtViAx9DKHXzF+5+ID9cB64ntPxHuIU8cAfCsnKsyDb02R7FfOiKa97kpl2/kCAII/8La0hqQRLmj07H9osyJvAunEWlh1lnIUPNUIQ0+SLi9BI+E/ZzBKTkVaZA5C8HeAbqP+a+2kltjaKe0MUQD19pBnJ58c3FXgt3lxsIR7H6WF7hl5Zektz/14VVCXj2/xBkhc1YVRegdqbcly56j2E4zH8zQr977EgKHkjbUujMwjsAHVWBNRZMqm1auHd2VLWLEfP8mx9cBrlOUWbJFEVowE2n3Vj8VsuRIjJV5ylGXAFc/zP30Lq4G5sFR5uUUK9Gg+1VeuaZ6FsdkyNB4KDKuj3FpewwITcchyVHlk7mFNTiLeUcFvhbwZdPfduF1GdLVVAy0BBKDqPDcss6HfPk5XTZ47SqERq0B5PgkCctD/bb6CBxypLIcAGr2JofeEjgmbfBcPZ3LOX711c8kW7vXpJ9mPBE8d5uqw1FiuE+oHX8SCyqXMbjxK6iIch+OYSDxC+GJMn2kIUxPMBxKh60nHugOEqCJ1d9lH9UJJ/boYjBLQRByuRYkhSChsKtzc2IbbcLMoyZa7DdGckvc3K8VGlp97sNsn9if4sZjgb9dM4TtPEBVqi4s4P4jtBzg5qJfCIyYUFDJupB91puWvMNHzxJm0LppzPo3RSvzubgHOXNfT9GNG5nWkj4sRyMk8SlH0slAh0uXEr99wdJHGLag9to2Nr0FoOTshi7S39tQOGBqlewC0XVFZ6vpf4zd6EfWqnTjWLv8KioMUofz6OiBGh8ymsf/hyUJ17cu4ZxwTvOAnb5rP2yu+UN8G+/2YW4fS60VdKKLQKsaEKc/ujp+MIJKUp/rdEK9XEEzKH3zfV0QEEZSicHzl0ciXqICiEmhzd7W7wIJN7PH3itVvaPNufDi0mTb7H01xMQeTdukNfFT4tq3ku1D9sSMq4+hkZ1/dXkFsAoZlc1Qrv89T8nJikVhI7D7HoJ5om2a5OJaJbjyVexHIRJZyQhEqM7o0SbjE/Javd+6daZvcJdFKZDpDlf+v0fzlLfuhk7/te/30LFhatD2/xlAzURQyQbrporu+qW7+WT3v556hubLwVNgWf2kovMi1PMr1cVx+LxmzXXYj7CQfhCaV2GqDUtPxZ2NgANFOR0fyGoaxk6hD8PQkUaB9kOuKSBd9YAdsIBlL3xde0yoU1Pit77Q+WxW0cX6jdKrozsQitGAk7a9rccQ5q9FAAB14hTmvmqlRp6mR5368LSISDcrSmC5vyHyUCxbg4VWL/N4/NCekzU8rTCTE4t1SrR5FU8GmpWwfF9cer7LuBHH04of+xGyFUD9rypE+3dh4vYLrgnd6ah50917uAkaV020MpjV94e7jAJhGHtPhBwbxVudoTy1fZkVjLp3ESSaky9onllFZLQ1OyCJmbPNwBpDHOBLHGl6XFaKkG7C5zGGJ4qQvybcVvoafFxL7lh19di+arRKVctsutxgh0AuyFHT8bNbhEXvtAYvLlc95GIXWf6wMpPf5wwb/oqQ6C9srp09XGSv4nyxAqM1loY20IkdPRECTX0jkSLqKwv7WjJHgCZp04iW+AnWU0MQzT+n/OpLJ/TCto2Lt8Rbh82+OHm/ip3noQpGKJAhI4WZ8l4u0Rtk583H4MH+NEGFGeHqYsHs1BlVA8D8/jUvfizVXGkOpYfjGVNu2mZHBFmAlyVjghIDOZueMOyW45eGSzzk81iVnNzNfRxGbFrvJ0STyn0F72y1dxnzZu5X8i/cQGiRYx5hJF5rzF5cplQYpZ+om6duFGMNw9cSGEZQaq9MqzPvu66G8HMbmTT4zJZtWYIx7cXKnHkSMIF7mCRm2/dvRcLg9YJnjGTCWxIGP3W54sENs7VIwphrHIEbmcRzo525ZmSULRBJYPou5IRzoXjBBS5f6mgvY5rDVcIBJ3ZChoUgPjOLP0if3KQX/6B1RWOgQAaMrg2Bd+d7oK1kdn1JccSgvYiHaG6cl/9aK6oOtZyVjaH4Yo2OMWM/H751W55d4NdKT8BWSJsgj4Ixi52zgOGTvaolP2qGGe/RRd1bC/lEU2p9saByNd0aDGv665NEwdGQ1ZlH1iqSghe4I28lyhjPRMcijsiSftHaepvbml8uqE6pfA0F13NfN7w6MBEtIT1NeWKTuMfYt0prCbzdth+zLoN58PbvHmoEZGqXiXHBa3S9gd52Wml1xs92tC0mIMh+JgoiKWYfybnRn/NRPvfsT0tkd0zPyIDGP+YNOZ8pCFvkBCY04QZcyQNeC8zWSolqE14UuA5HAfeHNkp00uK1/ZWlViGKmB95VleMGYSeHWlzKstXWUuJAA+MiZ7JYo6vbbSjP/1CmA+pH3aAP43MXgvuqcUk42HDcTOAxXQbUpLupyQUpomZjxBNYYfIl/ZFoauAi55WO3hLC52pk0CLfonztf2RBiNlV1c31Hn73QyYtov10xsYVxk06Zo2kkgoADZK1IMg36I/GtGj/IQ+1Evj25P8AKNuJ6TiMKg3re6cFey95U7LrU+PRXR29lBJmyVpCrm2mlJpy+NFvumxTaGJzy6yiqxxqT8/KK6W5/Txl0JoA083fpOnw3wWnf6dGia1ln68AsLosUsMUpRipp7mTBrMoWtHqjSzXOuyclbAIssqPHHBuKuTwQb1CCKJJtLMfrFlG1/I6RHbJMeKw8xNLE22GqcNF0ybS0ooTISlLn3T+BPtIham3TAjnSmIoTPHorNtK+8//9yJKrMsK1RmsQCjeLVTrnzOiTx00jZ/fpWrVcU9me733p3j1Xm1odzpWjSn4cCKhGdB4PDhH2BrF6aHezbuaz2gjMpACgqaxlDK5eMIJa/cjqEs2iQ0ySEh3tMNob53m2dUxqmgZaYKTT9LeoeK6/zLl7fgjw61U+c4SIAV36IaL0LjQ0ZqKs5QSpplO76QfeAbQbL1J/frV+J5fN2iXjsvNKfnIxz7CHMmYbNNO1CYD4L7/zqSJZq2R8WTRAapnCE4niUltgtvxW5M/8bp3gvEEDJSZdWQPYfklNBEYyaKP7ljJ2S9vmXSqP6N5+L369QyZ2SxQLIVH8afotms9eo8f9pHhpvoy/S5UQ0pnyyDEZU3fc1jwnseyXm/yOJ0xPUe116i0jvplg9A6EL02EVA7U00W3qKkpGVHCtM/T/8CKp1cg7GH9og62ZIVCQPkUKWMLznfdl2j8hSTNH3TI124LCqLxj5oHN8PwRrQUERZEjtyZ6FjM5NCXoPotCARpbUHcTUKrTE9aNIrylXztkKDsL1NoYhh/ZQB32Trp7YPS6DQehd95KgnO3QGxu4TscJXaY/8CzxrSPbTFkVnzjclLSG4tOawfmYHb7oQDH/s3Zqnr2bj1zZM6Uu/HU4n/OB6B80VKrv68qc98VattYd9aPwf4HTlfQzx1TniWvwGNVgLP1VUHEzO7KJqR9ALhaT4GWc+WcLKXIZTFoF8JFznm0dQUYISW24YEQVabYsU3ynHwahLfPGzLNelEHoMg2bFgu7K5zhEPNtZRRuw+JzorQxeAZF8hnNxBZp9f0KJS/XA14amL18Z2+5YDF6L3uGLKMhnP5UIJoH6pxFI1Sy61rByBKNnJPKb1yxv/sC6L/ky6hPgFlI3g8i98Hcw0ZRXKCXqaGE1RfAUfNtgu80PaSBykSN9HewvKaCi1SSoOk8trYftqUbseJrmS/V5d+XzmXaoCM48dzreHHMGwbfcmw3VeyF/bmsTpjSc7Jp6/3YlBbe8k8lqunbH/QxoF7U3+Cco2E6rSP7QM99kkTiDe/Qo+PtBf4ElsP8foZZTK5c5ip3b17jsYKPPcANn7+1EGOgfEWMrn3LjYXBlHAEs/MuAxhXo5lmap0FLadz23Z6udOyWRy7uRcHUNw7A6JqdKtaFJ+a90iNZyB+rpiiU1EzRYZG9uQM13hNSPq/5QAUorKDPN7vkHNUr/xXmLQvQIAJTgoSO7PfnoL3jHKRWXT7m6RXWZInwB8elWiXQi1EX3qYKkbFTWxYK1DsUhS6DvTsKJ+YGNYwOxqftJFWuzlko08LOOWfufptjZZJVaL4ZPH/yaLspgH21SpQwW7iuFqwsU1dtD7fnut65Y/dRYTJszaBKTp2avYIohCwcxXKbw/NScqcJlXshcHGZm23i/meLhDFu7qpJ53OsVB4sJvgx0NraM5UZdSbZ0/N1XveDOBOEW5ifFcXYHNJUCgtY72T1KMO8d5xqNeIMoJv2MB/8+IBmowVIzXA9eKFrUzNJiscInsoQCmJ/6+r2pH2FDp+yeFxT7HuqvEiXcsyLoaXoikUVNa26F3xfw+FTi6ARqsE2NTaY2hfZeGy8ac12yl8w2bSd1Foq7QNKFLB1+ASQKpoonEJwUzRrYROOTDKPfrMOSvw6VvvqrWt9+UGDImqa2+2KgzFz9jMCBb6GZ5z6JKp1QEWH2GFg3l6wxCzVhn0SP5j86xYUYLC78GEwqir0BoFJpzw9QLe2nCTIWFlRt9D1e+YEhIbrqiYu9/BOhTQzSZsaL+txnxUYf6hY61wTbGNv3ofCakWZrV1el8jDAOwTlMShwP/UmHUZE9MR2fhNo7s9QzEo3+swQ4eBbRWJT2KAD0hQ/+e7XKRHfb8CjnjyxN3wMmMFqLoy/oG8CzFP6CVcO2XCDmgStdBoLa4XmsbippBUlHOU6c12ZJmctewFshcRDGNitfSBBr/jl2XgGfc2V1gwJ1y6TtOsjyZSlipt6KRPs4Pgs30YDZ+d5Gx3LKk/Ris9cGYJZzIK7x78KrMlhkpfMydQis2iTil3BwMtk2DHoIQ9S1WQ1LqKBs/jLTJ/hHB9XS7uGYaQlv3y3p1OojvA33QxLI8wSeWyuSf0q0Og4PW4PxA/wSGUFsmvapMGbQ/Rvt3sLjd9XREb1Hcgo0PQnfAtWbersaYa6Fl0ebqkDCYlsG0RVD1fDxFJeFwHqLRVx0he9eghqXDCrTR8vfid5SDaeIlki+I54RsewgPndj5+vL+VCD7BvMsoGoJ0qMfXRbL+RJMqWvIK2M/tquKp9YN1UlU5WD7jFwaZ8QkmpkdYoXSbzg/L73l6nVGDsTJdsvcJMTK/qMihihTmo77hE7CRUC4qgKqv/pLqp469Q2unGbhabggfdmqwPEzzG3XCvWghRBTcZN/obaBKXgujd/cRF8awqscza2Tyrlygzb33QDbYhh3JFtS1Z9XgjzcsoHoYOcbBmZfEJNdbFEzAhcxpWOVkxPqVWwfFWRWhKs2lziTiHxFkIAQBsarL7tUNijH594gIgwRzxAAmhsN66tc3RaJlD5Q3lorbl7pDjzAdzH5HA3VYIB2hSqa+gYTNenRC76vux3VZMkQswW0Z9MmGODk/EYkMiYPCfNquNhzY0Bz4f0V1WMhUorCMsHVq/wYF+glrCKnrT3rbX1CZ4PXhZzMPBE67nePrdx6/fPHK2DxFe5jfXqv3xGPF4uaXFTjkChV2NWWTnP21Cn7nf7rj4vujtAQaiJaLNix4AJCefw2H0hnVnUYj8Ku4a3tZjI/JB3lvSjCv4Cv2yv7A1Cd88OPzCwpVDL1knbsZIroxy3vspyomZe4A/DIbL33myV41UkYt0b0zuSReX+20M8NNBUPiySZTLDw6EbzDxsuKRexTs2gOLcIXWn6EuD4ehlezexf0EsNQHVtVsh/wzMljGKsPyoWFuT8MuvA8lEw8qeTPv9U0jUu8phUAXhENtafq1cxG7g4YQQaIA35SyKufeVguws6EXhTG2MyxJdCZ3gBwjo9nqrorcju23gc/wmAeOt2SX3FW0SUrLPLbqdiHaj0PLQkBrF5E7FGyuY3zFj8lm2fqAFSRfHso2gh09ekqH887FUlG+VT//WEjh6hBCFVa6v/+wl6nVCqnZBVRzRD/NWCpo66IN8vGfjMYNCzMxAY88xwh9bAdqejjO3p1LVugCv5NSeVcI2iBOXnWgdrmG3frTz99FEyHDOfh0NrrB3AwhuJ/qoDBghCfQhyhAlMT6QURcrFGwjgic0+pyaB4ufdLaR8r8clX9GflK9Ne2N1mNoUU5Yk2xIlz372w6mzt6jaI1znoB1dc8xfgGIFX7LwWJ163jsw0m0fXSz2T5G9TwzY4xTNYKmPLy9SBbqVMJLXp4aAMwlU8jmIRGFkJSgTy8yFoZHY5kCxQ4G/kEaakj9Ogp9C5sQMVulEUzAbQX35pZBb+jP0SDbttfl+xmK9U6jcgA9GE3WxxjqItabv1vZ9yM7ofgq4eLGbgGZtQLMEZNvZ3bgCtPyedKaZQgBFJHVUfTU0Y7aovzXiPJnoqC2qIeVLhvhtVKSuVK6VSBxkeY59MNmALSFx4vd+ZhafLKbCdzEIIsshownyp8T5tkQoZH71i3nbLJhl6ixrDe5jSCv8Be/f+JBLsEAl8eKF2P9PPLYykZbitJ0wUZpBnUGG+1GKFpFzVqwL3uIWGr5XzAgQhGCtTZg4za6mkgy2WrQ6RlP10n4CE0M1U4R/aFc2y4kX9e2sao2V65eZ52C5CrBeMpQjy4QoUtxwVnYFXw+6PFXUtXj1YpKIVZB4CAFImHf6plHTrK+X/sTsaQZJ3Tj3gfI7bGJfhdM40tHEEGpMW0XbqYdvVoY78sZqzNMEA5olHu8D1movMHFMYuzQqPlDTv4WakwPOz76zUC10pl63nvQpKvnHS4Mjbf9mQMkxwA9x4ViwBF1tRTewCSlNt0UChlgToP0yUN6g5E/tDjELY6I4JLdoGjkrHTPr5Pp46qObFpMYc4ZoS4q3dWY8UJETlipDXnRRieZhMNPpszOM+ylo6DLJ/wRP0HgmVk2yPDmRvhpBU5BEHV+pj7G9vI6534pwD+E8bHYGg9Od0QOTt6klYNfW4N1ZU918Cc5OuJSY9GBOD+/moLPg0fFC+chIFQvm/wMQZBVC7/tLZvzVFvGoLm8E4qXeDvcVcNEk7AjrzKMLMPLZ1poLvepuEHDGoGbXs+gRhqbsGV2S2RciQLINnlTFBKQ0opg10VEd7oUyfdZ4Pm2/GWQQD8Ss16Bmyp1LPYeP+BE9cW/+M9MkHOTswIbHyfKA09oXyI9R2ijuSoedM3dPEJg30lrGy0PkXqLZwDxGTU4V/JeR6IQHv0kXdlCzxtimtlxDiYbp4zbYm8QB/BzxumdGGximyqWb5nuKMdv3QR09pdpUgyME7ZgaGKAQjdqplfbnJj13oJezdDV0L4YZto6q63yee9msZwigG+4qS9GRRJVz/Yzbrt4QPN7GP4M3dQ5buLFITYTAoyhAzSOEYRN7e5qtaidm51NTkqX6b0J2yiQnVufKRMHyhrQ88c6BHlvRIuAKyNrnF2CJk3eX2A08CW0s2//CfXftHXvhn/H+na3gCMi6kPfVY6p/Mh8c23/maAnB7So55fyP6A86oGwvaCzYyW0yPTtQy/j6DxNWALsTSK2i+pU+G5rqfWT24Kqtpkhv1LZaxyH6UY+KniuFs+oKKN8F0DF62kutJHuiUVCv/BWhTnmPSL2o0NDalQGkm9gdy4eDhvJ4htkI5UD+oJ+ozXrmNz+IaMW1G+CRX/THj2euup5aRXV6yFLeq9UdN7g/4/S6L5ShMaMSyNVn/V7JecKrRM5Khqysb/7HopGHvc+VODW1CWaTjIi0fUOrA0eL5y58n226Mnz4hWKCEGdQbJyBDKG0X5l2DTzplXmSPwOqT10tsj3qsGblBd9eoAWL+FPNE4eCStLjZFNweSsAUoDjYAnntK6pWZGqvrpx+EbDy5Q5R4+3bAppnfv+VMO1ULmTmTsW6zVwM8xCZJao6JXMV+TMJE3i/f6eXt3UVqH+cgeyExrUI8F8hzbviprlHKAFBB8H5nuhO6PY/Z/Pap1K2JqYILAVZxVQQX/GhQQOvgjISxGe9hqeyYajVp7qK/s+zx7yL5UohIpW6oRgW+jE0FU5EyL64uh7MwYaxiu/rPFpzjf2Ml1ryFZ+8JX99eQC5SzGgeqrugUHos2wTTyewQMVJDRGhlFn/jO83M0jHhPkiGGmuarT1vKhGOZovs4EcXuYQv/yHUw9DUVAcXIqM35lsk3Bb6/cRF3IpkB9TJLxtQh/DGUcrsecDGDYA0iEJ0SSseO1NQBZ7qBNcfvjb7TaoHZ5qm8VPbIzRogUuKMajp2D7d9W/IG+y5VaC8moACj2npcdSXVUXIzbCuwx41mdagAImYaXa4sEKd7rzd/XOQ2BWGBkKZ83cyjrkX9J+p4jZrjsq3Fa2HSsdnlpUsPBqtwgboPLnF6uE3fA3ppYVy+cdk9h5qkHhYI9wjKRhx9877nDZLKKyu8cjUQ5QAuoSsVFgV7sK9YUPCsQzwjT+UE5AeX6BHy5ZkEy7yID16SWwiPqs8z7F3iZyuVncMwcMWan975WaHOj0vOVYcdcVGXxnM2jWoJbirbe+TOXsrUeSVaZ+X+FeaED+8DppLBFc1xdOj1GPQJz7RQWEOp1hfFAGtDf86fdvVW7kKBtZABmCwKBPkXre5gu1dYdERKtq8TJlZEzG5fBcn9UNi2QuYlR8JrJnDkxLLVT8eR67euxaj2yq0p3iZzIJFGmRebHl/XJjJviIs43KFsM+o2u7eMOa+9iPXrWrggC4DaeiVx3dkK6GsEFC2VYHab0wMqX/p4z6eJFILWWzxaZ2oEp9zdxlpqexAnPmOjANiitAP19gJXBJ2ehmptAU+Y7q6dFMkIR6josHCGK9/Bsvef5+YAS+0W/ly6G696vXDx4xY0m4wNx/GGyd+0OwH6nVh7pdhjRF6DgK56H+sip2XwtFyxA6XQ2K6KOwkRerfe0d3hk1u3JesAPZWpZO+rkFFG0fRCe9fidyj1Fzu1cbDWOwigGnkAQqkFHxOfu7f7XCpHlZEMe0rJMNR028ScPDGG6kb+mG0pZkX6RGXYWs18Nw5jyA+b+I94z71URr6vN3B90Br9jATaf4Bs6XIUBYhq2icAp0X0uULo2yTEwoq78M5IAQXLqjs/bU5/xNXRbAgxsmt4IIretKPBLzuM9Ow0Jfoe9Di0h+OTTQiInmfhEPfSvQP99mBFj71dXtuZjDjdYNopv9yrwSK55oRh3NYO4eLB0yhv8uXD2zZkPVbETCAObqiqEqqavm3B65R3fKdwBk0vJPNUFSp2Q8prq1YB1PyFVfF1TWbFs0QDWfEFCKNC7B/KjmNy0n5mUpRJ83/BJODE1KVxhQPIRQPvybtQBsHhYdIejTXWXDla872jN6bKYJjcB4Q2uEaS1VDGDjfdyYcofZBr5mJZ+cuQOto0DW9eYKDLQiuc6brpMFh7l69BBoi5mOGlmIoHBL1M4y2waKEvcGpTabtvjJj1Ea3JJc0aUERifGeSrDBYDBJXH1jqZdDY/7onQhIYFyl3kbInF447awBZg8At5P8p4gP8o5NIQ0gjP+bovDFlxXxq5YqF1RNqbGu6AacurJc+8WjpqL00Vrf0n2BU8PrvEKtvVZcq2CtDGuG9cazdwHaYNkyb6WD02FfHer2WKSpG0fKfjlbCMkhLaBZJUp6gqvgnirXP9eoSbb488lHu12qqnOo7YazB2MPoN+AVcRsETzzIFcCVfCxPgvxx+InrGUOsiS2QTQ8+UXDbz5dt2Qn0W/9Mdvrl1uL5ks/WdedKv3EKfy5UMa0obRNwifAcZgHQMGOEWl6yuMldZebh4poQOpDE7/6rucF0ah6OX38lZRXoto3P7WUFSAcSmPg5TF+BxFvTA76lLdhcblbRYvkKOybg9DGw8UPkM12oJ9zSjlvDE0OZj4rquuZ3DDYNiOUpYrP9NtwmvupFi/AyNQ/AK+Jfgkwl91e3c4QW7+gSM/LmZ9eHIcmU4XqollDfhgzznqinRHJp6nGvDiHcWjI0NbL3R/KTc5e1cJ2qiDfH1sabbPpDJgqWF76AMhpEjiBM0ODUsga59c/qI1heB66hhgFK14cN8VPesCoIj26e4sY8cAITd6g+5WeHyw0dxUCYSRs6pdLx5u5wJqz5kRmsBpmxiJY6qMiCembbJbzEYnyS9vNhI5igqEdP1bxgax9FdZkv2gyS85rZ32r6xat+TwpCzdd/VsTtmipspw9NZaMLwtmdADppnAKzOeL9oY+UFEOcfqi7FNCo7TnH/XM+O4P4/1hb8Y9aDIYqafyC+YBsz42BWSFMvOjOo7Xxx+i75VGgYsQVj5ZRJ83+O75mvoJE5A/wXfb4XkWfPllDIVfZiR6swQeOUDysK2g8l0nuQQek5fIti2snd2eGoPxVVvTLp3fgIn3zHaDd2JQTd8TSjojhZkMWl9LbfTomPtkMvnephSdXStVVXcYVlkKtYpsYzIP00AbQW4z2LNhQpGfP2qW3wlRnMQNcu2PBKllC+iV6F6BvEQDE3th6VfE8jS0Imxy4Rtxdp7XT5MYm1UdnUUaWNRwQ15Zs+1gFt4xsHGA5UySPlCqPhLHbcXBaK7ImVD0hU9UtFqJeOaNoE80rtIxQfr00C5HeIQr+goWgLw0Jf99B3d4W/duMhc5keyf6DQzcWV2ybiORYH6CZePjMuYeQZKjiIWgQ73fk4yDJl3pkJs97k5xKz6rlA9cyGUc68SVPTCTef/aYZzntNAofAhuqqiqWuDu17oHVI3DT++O8ETeHJ4E4RAuOHLsDlOD3vAVJihRFAfs7lTyby9Qgmi5FlujBdBMze+tnkBGsbsGjj5BFBGXZdZc4nMZzb8UGdUgbujxta0DUSoPdUxWOvagtMrJb3yPXgoQEc19kXPb6nT5yLNcEvTtZa4CWqRppinOOOrpyPDkl86DBrqsz139D0LHP1+YiS++FBWpI4clPfkfP+UPyuCDR0XpgKe3rirALJI6awryP4EiVCsHLeXusn+T7QjK5wPm5ItHBardlWqU7eoIaBzdAXSqzVPK93cj8lwH/FCWZCttgNMR94IK8LqcuCCNGvcevWO/J8sJvs4ebW4XIOT6rg1UO66gXbDZrSvSgWfpabM9Uki8xBC+Qy0pCYskxoiVZoezJGYwfyPwLWLkt8Fg6T6JjeRDvncRdoZHFRWfW02waJmAZ+1OJD0+1Zea+5YzLqpwwTVM7/JuphL0VNtvyJ6Fa4hkhgOHY5U6FOY1/kMt+k+sGu0vImJ5UTzpSZKyMpcGUj3WMjiA1vIbyBYXtoC6EqHZzYoYCMaIGLqD6B+VGgktKbbKbQ2D56jXzQptkkRwOhwDHIN2tkq52nzlRyUwRcczqEzuCO2EdjH2XIdAH9/r77XVHja0tYPmarBq7MqrfjYmgoncJIN2oGu6E34qgnAinchAscjQZXtKjui7EKjr7XrLeGjTulSUnDcvh8sm+3sWDi5pby/GpW973q3sGUkZHVEfRx/dmjfGQCW37STLIlL18zZlxF0wehNdwv0ENM2cWCjcM/up/rgHnsZSFYEuAPpSbDODLWywlY77GxTqi1V0pFoo395bnJ6dqbFUn9OYDKUclgnvfnUJQHWKchRjiGdVQfazU7vDQAVVaH2yA+ncSPnYXXRaeIOJ0fiBAzvANHwpscXK5SGOmHR/2FcG5blTzb+LFpL4tA8c5MJRyfbZl3Qp5KoITaB4wO9xKEfn9TcA+F0zpD+JMEK7Bbb8T0K69ziYsJg4oqUk6uELFENI3m8TZTwTWWSddHc8Dw8MA7gl+LJzF65QUq06tWl193ZcMG2OJAw7CDe4f/MZKXoGQIZqEhpdYRZqv5Xz4gki7pW+xdw8uXGAN/Zh+MVKwSF4IgTrRUcAUhegO008p/qnlYu+HPDiuPZpD3viawgSdqLRPZIO/X7rnSxRasIl1VrEiZtgXVMVwc+KTUaTIS6X5YBCuOv2ybMcgehFYJMYFvsmV8UGwP6f+epeQBO7q2kqgtmjiokw710xg+HbI0vZNfOV0eqaS0cjUBXQiFa7y+mWiYIeBDzqLLP+K4CllhYGNZIAw98YynQH9ZbANAC2C3g/2TH3R89n1KialKt16VKjpjhTq7UuRFYTDyVs7DrYd3CoieSl9v/1EkOWz1ZLgG8tYYY+g0H0XPvBz9Lu9FjR5PAONGrjwP1cnagPDkl3PL7wSVg3SDdkH9Q3qZceC0FGl5o15982ZQQ8votUu207+k8Q4DpvnkqZX6w1wwECEzdD4zKWi62++D+hcq/IlS922+gZdPTj3X+nuVaMZSICee6FJ/PA1l7LxiC14UXkd/t/wOBx9fgO8CYboyEgf667C+C3w36TYayvig/RxRRNpZkFbFnVBjohLZgG4PDvbMbFZv++fh8kxXtdpCHTFDfZvim8/DMoSS70NWo4vN5o4t6zs+YTM5weCOOBAddQg1DWNYteS2i068Bw/e8RGGS/rS4Sn7QWuwbn1Cm3RiQB7gxx8Zg3GL+nNnL+FBuhNyKPctwm+12e8ALBadbMGGwXwF60TfGVXP5a/lBs6EraIERDAKKWir9g/T4Egte8IjzxbhOwyjr95qIhGV6gHgZQQ+yShFPVURmShv7rDb5mASVUkMrOMJmgYM45OsEZWzZnKNZU/ifGiKLeTGmNQpbdZ4sJBsuGfrj2eQepxzE/+tnsdVy3Wl7K6TWfR87At2NGdDG4/mx745TIlOZUbdzacJ+IsqqEjzibo5sRRYUNm7SRApy36CkWz/2QEPAMsfg0/LbwEpLuGkWSbdztniex+r9SRIt4nk+RfNS5TrW5IK76Wyd08ZAWEjxK7l1F6hnVHqeGgdlWznukQkTLZNqhdAh2uYvrJIrAGMeYJbs11mQir3p09lJluQLrfLGkiIL+/o93i7qBE6MsH0mGadUREwBlO45m/5vP5wGoGxJs937Vf9b0nabp++yxQ/BLdV/dfEmsRlDg/fjMQqO8Xazszw1daEW0qBk/wz1ui67vdMlVlkvljryhkK3Hysq1b9t/c1X7Zp2J79Fcv30hCeUU7zbOw3xBSozEGxgm6bFd0x4us+fA8EbuwllRx1PIAQM8f8fwicUmKP2fySGeCVoiDYUZQxwScl6S1mFMw9J5O6VrMNbk3mtI3s1kZYTVdanVdjCBYZnF8+AIDR+A4hHGJzRbXbvMGFfyP4cCCUpmYiHScp+JcJfyxzpdrUFKvJhiy/KQPr2H3PmBaIjZBAvOQXDnjaZQsasYpulfsY02FyLnLS5YAypqqniXyqLRLB+2fnlcpu/h3idq+hdAX/cfrCTLTJtzR3bQpW83j7oXoTyDxgaUNRKZXJn0w8YMKNnqWkHUs7ntuZdoLNuKWGQEBrEjgh4Z3N0AXuAl5qJk7RIxXKcYXxva7DA0qoG4lu5o+WZBxIHZfxemYvEMro1MBc8dGVI6+BnuJ++EAKkUEG8rQW1M7H1m/S06JLa2KfWzZFX63ygdNVeCoPOaQ9BB8NtjL2oNwfzkCBIea8OdLo64Ebk4Pgpztu7AqS/ktX0boOzkFdjUosaNDN27JUxJ7AAfmUzxe6ZCOL4orwq9GWXAz8x6GRbyhsj9RfipTEMTQtmsOREUeQS+NreFM60kP4nMwYflOMiyMxMPhs8RbMKfDFaLWK0TcvUh9FmDmrs7FchFTZaTKMn26iAdd/WQ0Q2ncgNV60V2pd5gZHrCJpI/sHCJTbqLslrKzNaJZ2dm931yc2LdphelZiwFHABQZGdguCncOCmlg8N3aYLfKb/kLtmrvNGgTO0gseIrj8llQLREbDFS6BdY4Voa/F9Kz798daBiipJAhHMTfa31TB/vpgrV3pXtOTVFLUfWLpqNWaW2XLPeJXlBQngAmVXbC4nI65BQzWKaZ7LyEZL2INeecbUfIdmku6pYdhJVOL0YEfpSAhlKv3zWkVfMv2/u6yT0yI6tfwCCCvpKKnGYFNzNC2H6TBykkLeWtDHAnf/twd5p7XWYbEEYL3H3O59iKNTwflCsd7DHNK4gDZSeyAGADrQG5/paBGV/2LSNplOaZ8K9lo8e8euwmM5DDQlouwR+eL7ztsRx4fMRXxycCLDq/fSff1lQNEcF3ZmxwclFys1nQcW1k2j/pvt0/oANaeUmOGFOQlEUNBZZxtp3k/btCnnOetPXNkGcgt5ExmOn91xw1SnmJ7PHoiYPTCEiVq+sQeE4IhrIgHvXmesecMwuLAlrWvWAtmyPFS+b6sSuNx083rAPq/VZSxj0vI7xFKvv/UZwrDlDFpxGEgyIpt05ieMauU2K5n4f4sr0WDOIr9G7ioltscMDUYWjWk/AhsuM4Jva8t0bYB1jVUfsgv89pij4/W1BmfRPGm3WhEWQwQbL+05msrPEBdTtgAvjj9NGu43nMM50Rgb8v1Fg64TiXPLQt6i+Bw9TT9wcwy/epyX2xHEES92DXdAVttsaDmUyRMPJLMPdoaXgiKHkqEw8bGm6tLkhRqCX6IiQZGhROKHY0vzCOnCI5tqVkwlG5ChlLep0C45uO8nOSEM19OtdwQLrXpV8aW5Z4BcijSDwg66jGY5go8yxRxj8ePGBmqK9/yYlVeTII55iIggwAMgUzWSb4nyVRv52qtnajKpnu8s9XBy+R5j/850nz3KlbpL/Iwmz/eIyDla2MdMkwUYh6biwIzqz/7WtPqRh9+OcYSV5MOrvqku5Lmpf7YqkR6IOqZ3yW36JHlKLNhB2qLgsKWWmbGXxGOCt5z9PZLeT8zfDSoDneA6xo1Mi04yKgLroWSbp51rNbihlmPij7pMJQsb3PZEIexv2ygFhwBzdQYUIP5aMmrhgpGgE1N4A59MEG318CajNCDJT6Ccl9//Dk20J7n0OjFk7udJXGNecJeeszbY00OWy7cYYhuj6D7bD7V7WLffkBh02GiQsszDzhP8sOsUR0BqLnlOys6zg7XkKBuaCXg3mhoF7KIp3PeS5H/TSrSFMD2q+sSJcxbxOfGZS6UwxMXpVkvCj0PGDLeRfosdp8LbeNIaZPQSkGjmIIGEiEaZ/Ufx7ZsbUbo77S77hQgY2YPdRmmb8r3byjVZTROWKPzGz9fVstf96r4hKdDCprxKwMxvg+dgvdCP4sw+V+OcJ0gydwS13xfbeYxh2E+nBqPbjGcgi3yZLZNCsvpvI+pnD7L5QgTVo/FFagSoYIqYitbLvyeEk8GOnuL8XnB2xryyDbw45mT0UwgX0yr3WxGXtnLwPaED6Pfy58HYezcfR3Qb+f2KbBYO1c5lh1XS4p9mnBS5taWZREd1rCDeytMJJvDl/2IYH66/XTMBOmYJ7ALVBYenFVGLdfHFijW96WJgWhBvjitKcWQZ6WFm+t0+n8fcGbPRb/6IbzJ0UO9QU8LZcMhzou37J2FF7uonunR4GupBzcAJgS+HXafB4oQO6qM/TxLhyqUvoCtejKaeRBpd5Sm3+8HSAbN6n33O8ndfPys8l3GNgxOW8n9Oy+pmdUmzrkLkVWEySeWtWX1+MiisC4Xtwr/x+0NE2bzrTCqXodCdD73wz3hGAQo6ny1yNhXQ6Sd/IqfTwRjCStakCphcv3K4S13/J7W8eeGJan08iCQsus+ClQrs0I9jO5w1qLSwwJ5sGmiHEi9yTAu0PbkO9l68IHgY5rfpWEmhCve5fokApB8VXpr7XIBYGewApg+eIEtSeFU/uUfaJ2+LKuxe+d6+YNSQpQ3Qq9tVMKSrOhjFc14o83ebrqI8QtgW9xgq/5p5MZJtcXeMZTZC1sqTVjGbWrT1wXI1VyAV++tQybvhUrwE2DjZDzhXWCrwXoRTcjzy9uSRWno0lu7lhTF5yQt1cJDyzZyLHWgBF6yXT9hg1tiTP3bx/SDE85bq9tDE7Cz9oPgxNGBtst24ult8hKq7Ncp4RD+V6n7jSegMoNRhV02hsX1n35Ew4Hor2yd7vWt8LP7Zc97T6brEf/IVjxiUpdeyxqDaOKmRMt71ynUk0W5uKcKlDuPaZoJdXk6CDpBMkir5xoJc/E0JoE6skQ6L7M1URbrMx6qwrP7KmOQ/mWaHbKbilbZ1NQmAawR4CyhJeWV8+Mo1sc3wygeNCS/Mcl1aPeyy1HPcLHGQh1xydMrF3+liBKe5sceB2xaRqQR9eGR8+DSVh9HfjvzBKNBl4imrCB1hJjovlWz+NGGxwXUhvcPP7MMvzr06Owa9KQTO11feJKXhSqqKOlrlmHWchAbz0oVerF4V8RvJ1D5onfNLi3zB72NvUuX1O2UW3QY3NnycxkjJcqwUExs6BgcvXcb1+CNWJqGQMvu7WKDQ5mT5KT9DbGqZVtcfY58AWNhQAZgYIXfzobPj3st5V8SofFXTkUPybifNcV+UpyJuKgzWm2svkaK+SYvYFB9THgscx9m3U0ul3GULYNEhecal18RdCVWXBAo5hZUDrBFDhk2JbzKZgONVPulra60XwNU6/+Mebnsrf55SJPIdxpWd4SnqCe/RuRrzLIlKzSDL57y4ppD9bks5Nx84QYdsTnGLi3JgyM7dv5RNc3BMQEfH7qb2Llalz6QkvkfqTbR3jHMn72shPBBOzfIGCTgDqiPOKhFdPKCqLdUj/SNta+ZiMeL4S75Zlm60ZVJUUKoB54wV9v4t0gBK5pAIZszptpOEEO24Bos3ADAAM9uUh1QvExBCfb4jRyOKX0jKxbWHpK7ocnb1cKJL4FDVmOR4H2ymMUQ6mStqmVKdQqCm6faGR/SpDCdeJHWi1DEaI1nS+gIKRbDN8CUOWwiOhQ2o8o25qpkT2K5E+ppSylVEUw9loWDQMPVZrp2dKuff7mUNwSfKmc4tZo6aMo1iNCPHnIbCoKfK/MaywveTG7PbU7KxUco2br/vb336NOVe/AHQFJkschh/aWs4NCqPF9GiNZtMXVlqCENvw5RJUobETGB7ZLb4jHjodKPP2DK9if0gIyeQARV9cx2e06JoHJejJ8TL4HQVV3YfzJmK1nYp/c252Eg0EpA6MYFdeV5WuKL6WX6fOcmqW4dcRbQCXDWAQi95aSQiQTx+o1qOTzkGVZ9i+jHSp0XKMXUZBEGvMSpDK92qiwq4Z3Yr2STdkPgm3XlsLFo6fGSCwGtueqsjLEpcV07CiWrWvoUpeZDHcnN8Bd7q78q2ekD4a7YzYjQwlQ+PmX0VNOYyomlCumSQPQLD1BFAxqCHH9JoDLV9vxKAW9KAGiPwuVQibd0Y4lYC5JdgKQ8dTSn7CYUcHiHRLB1hb1KO5rF3e+328e0YyWIjqVeBAS2ane4am4+vy3wCvqY4ZeVb6V33zaswq2OjQslHm/WoLcuz9CFd9IBS96TTmer9W2zjW+0uoYaVpDa1wSVXjwbAow9VtOpftkLCazJRmAl6O64iLrrMVT7wPDf/qM4D8aIHrCDWmDBeYQjV1MkBDe3Y8xIsjBCw8Qct7KFbGGZh6eQuGrEkj/0LrmFrNsR01+Oj+CAAI5BwWRWhGenp43pz8ajTusZ8i3+GSrBY/XA+3fQOPXOFzKPBPTpw9yWF8fyVMdy11dehXWwCpPfeLNDd+o8Rec4ocBHxy5Ct9g/5QTMN5gpvVbhY8TXm8+ha0oD1nVbOH+aDBElUbNpFAhkIbTH7pTJRZx1QD4Ay6E+n3KGQhFiFR2TetGjGErxs64pWbjisb2Dwjh+A1Z0izINkBs4lIlj3LdSPPheuXmdM2xBp17Bb79zXoEdQ8SZ96qZ+Jq0FZPsR/R9ob6KDse5G36hXGX3+lAe0sbdn3Twv2TNZw7kasX0v15d7qey0ahkqC5eg1BQMcetgF59DywyPy/Z29bhBoFdQDaOfwfffAE8Z5puJUO6isWH9n0mePAVsWpExYsXVG4/NIOMrV3bfpM1DkRibW7G2gGxGaza/z8UdHpqdnj0RoUJqzSNV60mOmrSx9ogxyFrL4++99XnF+aXs5l2Fe+YLXSB3ySUTGHEx8u/1cix9EdU5o7cwOh8rt46DAkjaqiWLuutNn2zU9yDTFyIzpqRERXeczdLC1C9cELf7QGiBaH2iB6dhLw/s+mRUOQdDK2sJhcRd2SuMI4BVugTsUaRhP0psIumpm7WC4B2D6KVTkXJ5vkgTD3+6IpmTNEoyYgHgTTMXKQ10vXNpFUyay35txbfJKlBRhO0cRE53HWzbUllc1BCrSkqFkYDb62CZ6XwMluIqBboQdNyLfLvpwSv7PfeQikaKIkZQ0fKnkDfM0HSzqhrCj6HzldMj/iAf85VSSKZ/mZ9FRkTO807e+jA3GmRnd274boX00Beg+RpUgFUMUCArwwHQiVx+p5apHssFggD8oxDGdx07CHabLlUwQxVK834EUEBm1y4TqLIhSB5h22BKXFEK5rQNeoJH6BBdkdGYC5OhSfhGGhgGcHPpkSDvK6+ADch8oJhQ+K5/mXOnnCkaIcHscGw0i3yLmXIDlsop74WNpnaXoSrN8atZ16Ur+q0z7Eqo3wOxZdvqQOaQ+dxjjZu8bTM3QT5JKBt918mip176atgUFTvk4sMBnmvUkoTDmdBwtPVrV1jHjynmfXbs6c5IU4YVq1ljsZlbuDGsutuPP1Pi1DXzMyapoPU/G3GhbpQHyXNfXAc45ZP/T0B+SDp6RK2bQjiHoEohh58VjcaxEmkxXcuQoOwrEGDZZx973Iz0Gx0ojkCZIcs3hd5wf6oiFk+kYQSnMPITXEpuWiUmsPFSnDucInxWSQ+BfuNQUD4jn2IVsXdTRAX02Y/YMdL4vhvnB1hIkooXN9vyAtV3NipJK7pOhUiu69nJ6Sn8o+gVnnhrJz3EG5q44oNqgo0tXy+pMFDRtuWqhugZTqXFxVbCehxptz4z5sw5tEQ1yK4fMQ+JeUjB7z7zZ1Kh75il/S9FuWmpQqwRWKzcJ1oV7BuYUFWGy29yXBdHQh5UbGtHD1xDLiEc+eavgstPynDXbVl15OsCrm28HpJ8JTWvaFzvBge3ff4s0MX7ST0NB7+JkvrUxXHpu+CqfqwVPILbNDYIEdoLWFME2ZMbqDcyKBswXeTVKA2jaZTA2+Kpibv7aHOn35BVVUnlrBJM1hsBPXjp3/hj86i0JNNpT9A5KK9HGLSI5XDsyiLPqmRJvvtWmsnM0wA/UJrFG64az5bUjy9WPiab8Gi41g3mvXPXZPZXCvHU2FXzEKCnXLgiIqrNATlGnILD/niuzBG2aPGg/wW6fscJ949lpXTJKCles66fZmlm1U5sdOc+m3RO+c2dXKT3K5ZTguzDx4+a/LzPkPzN1Nyu110ojcxn3ZQePOUD0Wbsodp9OrAjx2XbmhjIUlMbzdG71LK3/QS8Ul3v63/BipYXjuW+IBQhgbEg+JQXHimfd0zWPNKFsTkiXASnBtkiZiBFKSyjzhKUwz/879wVXdGPVbkXUVlLJaa0aYZQiM0ttYGggexKe454hB2Yk4V8lsbFu7sTEOEKopq7u4oMnVNwgQbXD7WZLdZUugnOgYo/PkwQ1OEXxizzo8xx7rAbohPK+tOSPosTH0O38NDg/jCExfvSu157J6bjb/Hz3mholrcKUra1QZQSNr6iqQfvYYrPA0cz52jyvlTwZjl++FgM6TzB0QVlbdsmWS28Ksf73658ySM01WomUqrlSS3bpUO7+aQ11vfRq+3YOQOB1g6QgAJWVcLButcVAdhmaZKE1B6hgLD2Qfu7TQNNidzXXuNKEk4K2hHRvZ0Ql6MUqaoPnuXEItkPe7i+wO9xEevbmY0KDTxQpZFewx/T7M1K0SsHgpJBqIjL0V0dpnQpBYf0Gp5jNMtax2wdbyQ+kMK6DsXkgwfo4xwCt/TM2mx/3VPoUS9I5X7+lR8ki8F9kjSBJ6Uk5nSduKWR5kt8IxiwhtA8sgnAyj925UuVkONS2XmI3qdhRHgQAK8YmI4ZJ1lO6B5gjuIA6lmChhatakzLDmapL5zh5SkTe89G9Bjirh+S2n5qSDnrdpcQ5C8Z+inlbzXshCTLyb5V6QnqJOoAoJ7bSc+ZOtlwrIGKQPo73ih+znRgybn5yWttL5ygO0mwo7xFL5dCpCKmpQfXAicl99/Ggsil1VzPoNMALUyo/hSEhI8XHiJL+DWpUM5clYo7rErnJIoGdaJdZ6DQB/ZkmlY6D3zN970FrHt6PW/GMzofenheF1QHSLacM+R5ou9xlt/ELYr9ceOfW4Z9gpd4Se8PGddxIbcJ6j6wwl2x+S00zyUTkbg/0fEexSifV0SEDTyh1fT4mP2kT5E8/Pq2lWk4+ZWICA16Op6IK+Tmx7KAVhotKL36zJAROVmu//ElHehwbVoTC9NmZkfmVYYYxyYBLMkJQlhg9pVnuMhScm3bsNwilGdFo+qaD565JbrVxn0r+QAdl1IYDrBaCG5TIk8Px4avOmWp4IVN9Q0bvPXSATtv+efWG3CjnxrYD/BHwyLFGfBoyol/ndVudEGLmEVwhlRyPtLlXysrmoJJmA3B4jRVfkytGybJiW/TN2lWpEs83xux76gUDDFRUgNMH0FvWHQPvhA1reAjUw4sn8Ho2wSEU1DvpY5PEgSuWMMWOFGI9qUvV4oiyqEyvcEkXVVjSqEFIybqvkr0UDcYgwm6fKHRXizh8IFenJ0Z238O8Qb7oW8E4sYAVa9qkY4ZxILmM213e/nE2HX5Xu8gL119+jc5HIAlwPbF/xhfx8oROQnkihGZ+IoAbSseWiShKMTtXnkjM0uPzaP9DvSW1pWnMXiugJpEsteu25Ub6XBTJMP082nngqsbYQ6WBARGyrxOWUVtHMLbBzve+7oXBwY1i+lObtIG57QSAIAzwkMZ0Mq2MvfzcR5bXgSqVpU4y/d3h9h8H2dtwghuBuTzNy1O7IZ9JnvC1fv21uwxEc0mEkkIde41UZgNnIozfXDu9moLbCui2rihy7WA6pTpoLO+CloMy3ILcfXVN4AM1sS3q/B4V6YrXVGTg3goBGbOs9AfoiAdugZ0lP5vtfM9encZ2Mk1pmX4qK2KcdS7sfFYAdmP7w7Wf/rxcb9UkAMLX/2oJkcxOCrrkPGND/xceTqeKbAjTVRRrT0OpCXehZEKftoA3JktCQzWY6HLRLOHfaYJhcGFEEhsQtj5Rry5gZwH1hJUBFSxXhgUI2r0SnjXQjq9qrK4v5k+J/nbopF82QVs6gUFmGYCd72DMu6XjytqRd2uUJ7OSCZRguDEbr5/6uf7c1+Oa7YWK7JxA0QtlJV0EGN4ooXz5Bn9h4x0YUaOxOg+JRLvenhKVXRAleOj9V4gdwkcXfZxxpkC2ctzcT2UJThd1T0XfUJYsA1R/3GHwxrsj7VrRvY7KyzYsJtO7dhFEAwiWjOQSIrOtiaQc+JPYfiRmc1As8s1DyDenhKm94cb50JC5NFbsdekQjzvpjGivm646Vl0Vqfj9gJRtn6psjktjZbK8ovqKcGxeeZkL7STAtnQzbD+s3w8DXzGbzuINvw8EyHveJyu8TTXVi6IFk9JMN76YTpLlWNWT7YRtMuM5w8aS+CBKyL9GLIHC+4VqkImfdU0w6DvzVqyi4wZ/Jt2kjTfRuJSd4rqLE+CBkUe9S5ItjEQJw7+c/L6fWQTTJ8y90j7PgL/NNfiwUnYcld8TSTFd3TlEtVMP12YmhSU5acacr3qSkOpQicLO30iInTMmGWUxhtnWoPmdDjNE0hKA7xzi7bj+PPKAYtsqRo5kVIJNBAIAYJ3uamhlCeCqabcY5PtoVYFgiT9X8GIp6x1RrOpmP65v5ijDkptPD18PvioXefqCZDouKH3V6dMvwpFod016s8mgVuABpF6YqEhfWfOtXGdQIFdUoIVJQXRjbd+QNDb8UdyUHhwISOLb+0fCVptTfe5pt27iCOOpJXVxxL7n16DCExk7y4cCP7Td3Chjj06pcE2veJJgKBhKxiYguiW1n4aXEIFwnEXQDButkuwyK3IXS+UG/8/aF0BFwzDolRdsqt1K+4rcotAjaorx+KcLIsbnxUjx/JKJH/h1F6jUjrYxcCV5JiNnDy3zn7taoU6692TCq/E6Dul5fomY3XBcpFSnneqzs/lwNcbhiLHsUKHZ476Q40mGtdT0VXzam+8fGItlqlrI0hDFhaRDpM1pRuJjUg75dGmuJZfMyht5o9pTVvoF2+kqrfVce5GhdYkgxxQ3iP7CQidSQB08ogzuuloDVrzMqtroMKdGv5QzkbURhOqNW3FmJFKaryE3oOjq0ELLiGRMvM6Q+3jxpQkf6sEYS+jcxtXwFlR6IMdQfwsFqrEfnNBGvslIt+jkLAY0A4gts4LQgiaj07m7p+Ay0siykQU+vnCfx+JPxDVSGzs1BmH5pKVVLo7OIRdhaoTft+u+BISg7HRsa/Idb8rjMUODGrVyz5Mn/3WUO55HqK/gsLsSbqj2WnWfYPbdMg/bMAOuszmWrFj0HSLjLeP82fr9HlJix1ufAAw2d8r7g8UnHwSQ1ER7dFP3Iq53Ol4qFPTEd1rQgnVcRQSfnEtUwHHahDf9QhxWUemBZcBKjEXSilFvXv8j/y9Aa285KD6P3F3aSrZC0V9yD18KTvIhKjv1a7lhg40N5PJTgGnnp1nq6WqItMajERUZM4fG0hFezoW5GrnY8ksPi2IJzwqg4ImN8uPZFaMlfXALyqkLbT3dLgOM8zPcBOVke1iz785+2/bqsXJL+/AwFTr3mHmZZfKyDQmEDdLb6Sqn4ktswSlgfVj9d0WSuEhxucKZAcQZMNVJpzPxe1c1x1LfOflwR8WDvCKPz9ozGzboYP/G0/lTMjyy0fiKALNfLSOtFWHNDtFlXlhU2fMtqlBwCIaBIFF5vNLnEDQkVzXXT9soi8zI1mBtOXoeL9wQCZZ+IgtWKOxG1vuMV39a/hPLMXTWcP8Qf0rEfiLF6B3Ep4SjaUWNwSpekhpQkwNymBZTqZ2snGY5FQo8e47IsnKu3kHbcq11+rJ5Wayr5c3+YginOTeMi1sNBjop4AFmIKy9yNW6ftZ6KsNkftLYSc/Jvu+3Q+6KiSITqNfBRNtXrD/YSuRUCiJJj1L6EigWwLu3InSM+HoiMaSa6zhgIXw4JxrczlYPUs4Vu5mJ2xVRjMGXoTaeV4dUVb46r974paaBa1k7K/wPw4ePIptnfyhaJxYefqaniUVeGOpl39wEEhsQ5raCOf/etnv2vUntZozbhawc1m9dNXd9tIKK15KpsL1HsQ9mcLCHhsU2WzH8c2wGMYEDA21AstyNSTF4Orio3TG4gbtWLnYvnQMuAPhleedujDBHCIy8E08AhpxWKE8fe/4CEf6/dIzonwLHf51jlNaqKJX/S073piJTUCj+R9cd6MaTNSdNSknAQMlQ0KiobkAoC5QOGlW8Z2emRNteVj//NBLJtm2q0DQlUUVWWRHAKQ25EC2b3kPGeAkE7YqwpRLVDpV/krbbqNoaFpiDujFPacQXTyv0t9SCJuR071ev5fS9+yQcebZGMUEbLLQbtGGbAqg+gB6BERV3cYWIrgZngBu1PouxvN12IpwocZk/VUpTbLxI8+NEhhLuL+/f/2HEc4Z0INgS8ELprTVfZUBbaNW3dFPfZLQgbKxGQlnzmFnJ9CGfueF+VURFKaAtz0yuhMoJRWcu5oeQKBRKu4eY0Jotfxqmvn2BqQeo/DUQ1G2+uiTJEA3W3WJ17xdB7r+McaESwgf0/K3kEgNP+zjeNQ+Al//PlyL1h/VWoWHCuwRA9CHOhvTXjTEhzamb11v+Uf6urNqN0VQ6dUWAQ/h02KTannv+0gc7jSSD7ERzPiYVnG2CLN/NPLYDVtj7hsCos+Dbzn3AN9VtFW74/xhAO5AAbRFGNLHI2jUnKxyc1jatVb0oNfviU8iNVqp47NS5941WyYiVy80DBo71BIUGVvC0jzKvLMC746S2aVIqkhVQ7AN+mCCfVUzNwmKvcztpZ3TjYlwENPgTeDRYRpTxT4y4TbVbhSboZ+QUZVShsRjWuEeQsiTLAzPzJsPg4Vf1dpAUW3ls4nptP9KApmBJhVClSYKCOLEQ34mvRe+QuSRKagmJEpNUhnMwEKFynuY759yBT0Uq6c5FpZgW2bYil6tNVWp6yXQvHS7FkuFLSkom+u7q80TgDjZy5bwdaSLh4vC/pJcKY2JOcpfWJhdbMnJoDW6wGhW2K1IkbbMFeIYOsO9CpyoNJ4ojs8EOtJhFkE9bZcN9Op0KNY08AanBXDpZ1yTPRZZ8d78wB06QTDTdJaTE+GrfjBYjEYS74i3cLATUYXb1mYR/St2U29OdRSkwcaQFOQy8rRCQT7Hwl0384EjmmQ78IxHRPcyVBZDene8fkxGgs6kZBkWBEzUf3xdN6EdsNXHr1SoF79BrWR+dr9mkK+OOnL0Bt7wF+DElOG9yvcCRGDXum1X7lMo7Uajf9zuuZ3/IlzaQo5RxQMW1UDTKf0YVNbgxaixkKjTesZXdhNjs6T3fsEW/ueo5C0wis2IWfUAz9vgs0uAsGrK0tl9IMSPTrD7wqm0fWf5fz3zGFJUN1CgY/mKaQEj2ezj3cDASIiSV3cJSXOVXLpdQPT0RAotwzwYdE9tpgNqdM/YMPEMbLFR+8TQ9V+7NPyeaZk7ISICbpdSee9ewzKw84PNyMH5hBGHh0SE8KmwrND3ZLgN5hwPESoDG6uQnkI6SdiaHcCz5xdo+SY+vxfTm7b7TSG0OJSqt22HaJ7h1O02JQG4uA8DFHUE+ttBr7PRPdjAME34wqnRNJ9vlndRStLye44NJoLiYr9/JqC0C8teLdHh+re+TW4myfmfoTGt/RpsXwpNmlJSiBIgkXxom4s5MmiU+HdoKIZb1nAl+u1+Ddo2BFN709FdvnTyLYeamkCYuwY80lYTuWDv9ZqzcGNq7JKcM/H3iT5Rct8OIeapeMguDhGRO6yZAFHyh6yHTuffwh9EolJvfcMObm6QendYD8LqURsBFR3O/KwIG5j33KzK9H/UthkRy9xEkS0UHdukGbmVMfVyGP782Cd8zO47tyuUSnHZOySW/95Rx3euRZ+kWnHFFG7YQTBCczBa6rRnB6QamqWsa0sJcIG1YUwDJomGhkUEGkqV4InxTWMerxp/67B5SBEfkcmwTp5jT3Gq2+4UjrSpg9e+4OKC6DOkpSRUg9VTJMj/XZ5CoBJNPxSSvmMy5Y5XgXCIVKXaHRNZKYIcw+aWNCuaBOT94kkrfqGUmlcdrQjCKSjtozBhVj3qlOYTKY3/WGQ3pZ+3jALMjdVRWQTwKs2PUEa0EimOnZjoU+AmY8VXTAwMbeLEc3WnrpOzOuk6nyGYSe5JkPF4UBOyttaLbUvmnk8wXS/idX+iC6cY2o6hgIXg991TAvUO+3C8zPZ3kadtDzpeE9iaLoJHt4Ee6gPdko3Hb0L6wdQnz9Vu10pd09Djvlpbq1HA8wBMJl+/z9fix+EaWvdCz4+U+dvKxaUKvEgR1K/sGffr9vU4NZW8bkSwRNaOaTTocGEZy+ajjlUP8sImfxkrYB4x0pWJkprSpSQj3rz5zR6fLDLLpJyk6ZNRhUXRlDSCk/SKhFwtjiY06o3TT+HY0j4K0E8dUEHGZhTcNnoGi2EbsSpXLEkpNvzJptwfY7xY0Qvlrt7tgXfn4GeRMG6PG5Hi/irqX8V8RmxyZgkze5mBOM26rgmJB/8pwuq5Zv3C8yx6nIkGwPY0v2OOBqtElYOQYRdW92gvEga5BMWmV4zpWd5CNzMhrM94NguOTvThtsHZjVRnkRKA3Zbj3mL6F2Y/73gXTMGS6lHF3nbFhF9ey6SgcGLeoUA7w2uhXS5U/Au9g7zROB0CEJfZmaeaQ0SQdyoIdc4NP1tadjICUodiuY1Fe+lCXfO3WoRCCcapmbcgNxx/WHfeDmiBWQGy//Rt0E5sVvis9ub+0/xel6kSGpDYBVnlhNtIsQwkdWO9xc0z/Y/Kv8156ZhDhVw6+FV4S+tsp50G42ojzJB9YNGcgzQz2jBWdK0upWJjw1SMfjoLKxEr/B3TngQTegsA3ovBuLCjNC20yzMRAejcC6ynFOhiSfaro1Qb3oUtQ5jwaNe7DDPDGdWZQ7cjlXK/0waaIO9fLX45n0yYP7aTsDmzkQK46LD2qRIACIb34cB7b7F4fs4TsvMtY+nsMqUlgi7RwwVhCnLifoYCzFVFhBZZis12JdegKdO8A0xYzg+hXlNe7MksZ2PAqB34eAcheszwYSTU295d6VPGmMRkpHiFVVDGee3gCmOycGRTS3ujhOhdUN2PXO8DwMaewHk66ZY65alc5QPHlcMgeyXhRieNI6OC7ZoDz2l71i2bS7ymt7xveT5Ddl0HX2rGoH/c+IJ7swmcrvs3qnDOauDEjz2F8t4PKNAV1ibMcsF0r+qpZf1TgUJ6R5NJnpduMvxDUp9UNRR2oGdycpanqqmHdtjUxbJjIF+GXGl3frapSGGzmQpi29UrBo07Yi/BD+HSBGDuKqIfAhGDBPzKQJMdbpgIGvqkV07/j2zRKww7atZulCZDP50ce7cQCAswAxzOawOf2d5ijQORphHh5/Al2ObE+2Nj48EntaG77DgXMS/e5AHgsIjbWCYzKGAAQ3DPEffZcsKYVDcx3QdJzNFTp9e6yVmuniZ5RuhF3/hL0b20NzpnoqZRHC7NrRnTEGVTuG/X0TfWPcQWH46QjA38j5gyJj2JBTh0WfPowqJoOM3IrUCzH3CMRTE4PTz7jmUHG7BJN18ZKyGP/F4jjZGcfMw/wwylbT5c06etmvz4nKkNhnam6/UoH+LFx4SPFH6p1Pq49NVXOFttq/4//0q8FSow7/kigDqLHePUouZMahufl/F9PJcpgnFTtf+TPU3HvKLmTB8D4vGe4GDTA/S4QHeoKmJzdGeZYsNODAUFSW0nl+EAmVF9Hrz1JbFp0Q+SS/q4qzkCXjdLzWgDzzMi7XELi8WmTBQqfjBJnh5f0hZY35eu2JvSQfHKNEZYP+ShlesQvnibgwyZVtpnLess8VzpxAYA68u5kshFg1ZqZTHbVt64lSItFUmFOlZ486SJVhUksM1jbxf5Bm0+mL5VLot0seREBqW+E+MOFoBUi+Jk9nOOOdwZIdN/+3gRda/okW8ovixu2JuiBa/inHRImA6ft8AXYQM6vKd11LHRXaDPDrZSoiBUsPe2+Z3AHHA6JWkcVgL4Chg5XK3IblSCMAuGOjFVZC7yoXpSJdNo9jSa4Oufqii8AiVSfe1PD3B4nbP6v5VsED3PKBUF2R0WRlO1YCk+3Wx38Y2T75ycgvWEIeW/+Fc+TGmlFKW4A+jj40no8RF84L2ebQd2xuTvpgbR6sRQBFrljtUwWmToIM5GrZCi7Ljiekjm1BW1LXHukCjbaUbmqy+eKP2eg2gBYjSYogAmSjFwzANYi6Av1v8jLnURz7FE6+0qLy4wE9dYRa6iXMv48HZkwB9JzoiHGnCOnNXh0myMNx4X9j+lRTx4Zc+vm0UN+BQXY5w0y/6N3HkhDDyojSHIt/eUBRgK7BJ+vE4u4TxD8Uuj8bXIf6ZzZByT9QgzUKLBClgyabv3KVSAI+aojxqRjWyJ/QMRZqYxwLFlkoX5u9q1hseYEyextpq0fD3TBrTHyBBgGH2P54R0mxR4lEP34FPz+JLabtZn9JZk3v+BG1CKdtCX3Eo1jzUuOHG/MxklF+CjbUW91Vm8qy0jrgM7vP70SrYf/57rqiw2iPveQONwExldfMGA3ZxqyMq4RFs2CAhrKdwsJbBEqnJOY6bPqXA9bhce1nyHHOyZOHymZ2LmGGfS65CmH5xxlZTuSQs4iuW7/ssAEfL+K2+Lt4dAAX+HtrdQ8iwCb9aaWFJibxa8QrgvPqYqgUaVCe5BYFN82XSVdrqy9xm7gq9hRBXI2/xRvbNchJxYY9k4g2y+VoNJIhm7RhQKcgfO5bd0xgrci/QPcyIvmkUuzESL2A4MygxT7Wcrm23a/O3u1jDfG/Oa/EAdoUgz91MV78FgiWxuwdIVK0QnKvsVYhhwEGTZizSsoH/FaSHpQaOaH81zYw0Qnp5f+lpjMj5pKFMBw46KaImgaWTtAg+XzmdSzt/WbryCo/Dd6ThG+gBYv2Ut+00Dw63l7zCLHZE6pfUy1ZpAos3AjcSOC9hOcR/dCDnf6Fn1OTI0QM0m5100yoyAZMXuj+2eYFH+ibjH/uXovSiYvYOCTZ+0xVpkwFS96l0qyHwlVeDVfwrI/OkKWocTZjtj2u15hCDymE9xB6RbcVU4NVS0seFR6Mgrx2HuzGJX5wkDAywazQ4BJtRssNWaJE8Knk61B9wwlm/WzJMX5D1lqkufRa6pdw4xgg8P+Db0hy4UV4m9YIe/GlLpdgHvds8a92HneQma2PX6qnFJSPegC93xwM9cuAR3jJvMy8AJKdO8RKkGOHLgOqqJSvNm2rCnaZj26fw9hxbt3X4sedcKsBkza/L79CP7fF51NV0NkSTEW3okWynydLsxzW2Qx2fnQnxKBdBS/jHekCOAJuSsksqeEseMcPg/l4sBtViC3N8GOVcOGifSzRXCrzQy84HueXWYZkZCbDLCtguEVVW7SxXOCxmROYQBglV0/w95NsBzrworT5mtti2cj/xbGNRxkJbLhftkmQRm/BXlZfchD+r1kaYCLAs8rT8cbHZVdxlzRuRxT0mtx+q7gzF8G5KFW9PMNwI4ujnXnmsN3evWJBNwqzYqACC7cPVZ0GkuzMZne91zKSqP+xL9QPOd8Li+WXM9YYxf02rBMK3Ot51dV/5WD0mhxQ54avImjHsigVYfRmR30YiEFU8L6QD0bcuhKzYhafrML5Da+NghkLItoxx+HbZLzwsnrEcB6YaBBBsjg9eK1B1dViuz8iJbfhXMDBk2+OUZphLnHaI9YrnKU2HYI+RD3YdLv5cRNYftMENLQrHJ3xqE0x/7QjohEOz8gEwsqsG4NDJ7+fC2vBvoYTpC88MPvfp6ExcQIYFzybSqEH/5O5SD4/wQe3wJgAIGDjOuMD9zD5g6xy70VrxdZ6giE7ocRNZXL15dadDDBkhP4xNJip2hoMV4yOzp9QqErb7cPSADuJ5VNwYPaR7X2FE87qPWyL5zmE/5bf5vHYSWKD6Hjq5WNzOQTkGN5PDhANZBER3EETiNlzyAi9zF6z69ZF5N4TWcszqC+1kcY0sPZXw9Lg0JnDnI6CoCs4TSLZlgeMYGICxrviA1kmS970qZ5Yp6gMeZvBUy9uAtI+R850wL5AbHz2NYJhjm3UFOFmT7ZHWi1b/QAhSFPdsTbOBUJNnN+TgxOvAa5Oj7iKHEEndzZEjfLVYJ/10aJWd1Vfw+ZXHTVN72e9qVKPBIfQkK2rAU6tFjH+1Be/PAjIxJy03yEnLgXSPJSKcGoq81v6B9KclIjJFBX2zC/QARJUx20/TNfvT5h0LKkTXznahQbJSqvIi0gOf4KaF7V0ylijW3pLJkxTmdHSOBqx3bZ5a71rTGi9cYJsxG+5SNjj6jGwMP0IUuUQQ/lN/9b8Wo3sYrGgKoR7jXZZXGe6vSo3Le0THxy4k6nlBzjJvBwtGs52avXRbWQ9qnTLLiCSYzoxCX1FRQAomeqHRvfbjN29q2OgS5P3h9xYNrET1oAqrRvApkClxHhA1wjc1PsRUbsLdtQVcsJtspjIGxdz54hZuTnjMw48z3DjXnz1m/NameYZ8LFNIhdu3IrLqo7+oNyK3yOHDsTM3gQDNwo5wAfqYyTzd2Y+j1MVf8P/DqyoMDMJo8wIaUTc6PgasDu4vN/2sWTv+dhroOCYi1SUKvkT4WIQHXpMOcBqs/P5qNC2pij0cEE/Xx2f1gbtaizQOu93NOivDIyVJYO0OJzbSHXDQHa8Icav1sJsXSu9tSMRkkT9k5bm/Ya5WOo8ZDCYqE6Bjiuh+Qjte7D7SDrp2IiDqG/NscA37uiXUFefuQqKzNevocd2zptZa47WF2igq6vbe7QZsOMBFqGDWlZfnYvJ3kTHpqW9TyPehMA/nem3nNb0KNCia8X/akuNGpIWFqNBnL2u0/xgr6JzHWWUS1lLhxmAbO4wGNhDbl16IT8GQHBnP8Sl9AHwRZa1PHDTx+W8gytMein5Rful6y9XCe5LsNTxnp6XOFp64v5ze/ImrI+nUNW1E6pFQmDUCEXe2ScEKahUiPZhC7tpA0uHEQ6MC/odFB3UVS8WSSg4AEcdLor54Kn6qsJf6+XAMpnsnSvHPt7CU8+p0yyn6HWcHrUPu69ZTICBa89+Uf2FJNtVgqI6ivnkMUi5ckms3LUKqzwaHyVb5jCTWjw6lnGUL2IidEHEBjoBb7XfQufoUCQaIASdIhuP/GKlXAQlYDMY2h28d2M/G2bGe1mq6gqbQDHGzJtTnv+hNLPRvweKVgcOS1czwHyXXt9jONIAoPp0hkYULrViDZC5Dcd2HlQMRBvcHeCihnYLqjwwjW5qkEDBj4KpoI1mzsTdHy8y1BTLfyyfvCqE/B0QGr+J7jUust6130HyhTWFkHrls9NETLSTrlqSefeOTwOddPWnMmKSARvEth2msTonlOQh0B45YEbFkeV3LVevQo+nwGdBnN/h5N2CTRPX39LeLDw5uWryzoobgPkmPkjOh2AaoSxjkhNxEbucZt1pKnikQoLGxtnOslTPwg+YFfA4xvMemIDorShfbUKYrvlBOp2VBu5gnDHy56RzclP7x2cjKGHw/H08ninxEe8P4K0haEjc2Irgb9cLhHMwIJhGNPajBJuIBwb5bsP1spINAKO7q55y3BrsdYyGogm7zxpbDwcdca6sc6ToRTu6NKwNfWrj9o4XYGoiQxU/AGdbLWIUn9SoRCAfKGlpJtMIgSWiuvIaqgVhiuoN4WgY+8M45S8n1ohjbPggCnr0EtLDUoX4TI1uE+IRrfaLS7u+LQcvanH2DHkrz1fLLcIt6drAQrvGBBLfBcKGmzSjmtpsN/fIWLp62Pt3kDj9JYwAmJ1mZnh/q/hS3QNK2Emo3aN5nn51PYd9zfharHH333QccnAf97dfAnNlOyfjhh/dMb9MDPexyAqM1OszyKepem/zjWf9euBdUDWJtOLRCGd6M37Su0taAHLnGk+m73ZG3VuKHXNIdahmoZDgQoTjtQwbY5xAwnWphACUmk1tF0zbz30Og3ps1GvMEWdUR0uwqJ/BIbX2hmTRZJaKF1QjjjDVyb63K5FqBtqPEJmRHitz0BTfu0z2Kpyn2i9ixiLbeOKnUjTGXrCQhwEdHY2B4Ex0KPnjUgNs/w2EufZ8RF4fK6OHwFoSPk4USHKK+rkCLW7cqcP4tUY2Grg/j4ZwsY9qykaCVy172uOIy/WjNXSFqIoOZ4wzlGowMVM6Cm66anX1yUV3UXM27EGSBS5fF9vVPfDgk6Inqs2MLqKDK3J9svWtJmHC6IxgAv5WJ7858q18dnEfHgPVrG4H+xkSO9Y3c6rQtCfZygPl1rDd5ssQMsorNUkzLehZ5vc9ryEutlM9SOsVBm7CIFyc5jG2nBNZnlv3REOiBVLAaLARA2mXu3fkGYbczOHjS0/y/jqEuFvmblkW7nOGz9EHs1pwwnJVcuw7qvHy2pymSNdI76SdSlFdQvj/bByUon9rg3kGPX8nB0AFr5s40evihKfI/7mYBLbtbLwbg2bMp/BZdPjejL1PE2QknO7WlBcoEPs1b+7iyUQuaUlNcHrfyx0euF4cXHOF/kibz/Gx8f9+u7BwRby8n6gPcq1gm+cVZmVngl1GuIncE7eXHk6Ytya2Mxe/mK0NQgN9YjIYF/kS+rmYGlAiTDMF+zIXVdmLslx0H2DB0b7vPXODp0Rx54vKJQrxX2HoYm7XpQFQNKyyPvCCOiqRVDxA/+GTcndAjcU/fucaZnhinwEcqs4GtDsxhOJ4oK8vQ7Yq8tZ32tXfPfWPnwoOy+Z63clK3KEnhObT+ggHO9m9K0hcNc26Pcp2CySLtTtWc/04a0GyI1ykbZccaMHbjKv11yOgMHOM4K+4CX0A2XloA0XKI4Rvav8APJsrC2TGvecQ9wiMnJazdcTnDjLLeIELawj1mWVFSzx5v/6C4PnncrNkKB5XiWYeDQOTG7pGsbZUrkNiZwPUmQHyid+BZJZTMQbniTmkttMjJe+G/WHNZcNYNFYWbMYS2mmPbZEWPfeF+5Qbqfu7Z67iino7X0N4FzFI8pp50lJ8M0Woi1JZ4gP0rrCxVxoBXgTTZGH52YhJx5JXeoyqHFVNu+4Y29e+mT64lkJbwq4MDas9YNV6afutEt4D8is0zeHfPERsTsGuuVU8OTH/alYyr2hSZTegioyxSsDIlN5kyHvqWKt8u4LqiiaACbYe1WTzbNnzchBykOIU7TR6jXpAuSpcjqzHP23SCLWOV9vmbPHmpS++FZDJmwKahkE0fTIOcHEzs48SxZHVss2dUUY19PISZexo5CULWUnN8s/2kGOpfrroT3a94rydnk38p6uO3wKN6QOpURiTqnwPco97uA8Z1DDngpcdJRdq7NCk/ynbjbtsbQ7eucKeGqD3IiTE86gvaXICrgVugcigh8WKQiM7xKjVLaRR8/Z+isidrY9HoQl+JqEYDl5NgFgV7Oi82BK72HB3Ij9DzAybhQc/Mn17l6K076dRJBzCMReExUSzns5BeHoaMpe5wlcoMIoYCOSS9Xr3YXAVif9pvArq5N8HzcBXkImhA/QQjCbLLyGRRtaoobf+CGRSYF13pF+hH9jytUFqg3clhP63hgZAdjbw5KfC951oyRrs1DAgGpidf9XnrWB5+lEGWf44qZxlO5hbpB8FtetYNcPvkVs6SetgMibSHkt7X7JbiTw8G2j6bSPLypGJhhIIc+RS59NwR+t3lhLp0pnoS1250t/aPhf5bSDcAxeSw02MJEPPck/n9nIFpIfYo07Ira11fbzNYFVBb9368pMcR6HV7/SHchtudZ/6UiybG0YLKerOxAr25apf4A7ubB+2aYSGG6qBe6s52U4twVbQ6ImF52x/neo2YXyyjzxMjsvo2n4Pt4bWqQqz5TAVLHqfgt0FCa64W4cON7ahcViMwuXndZvkMITAtggU2FZmirpOaou7TW4NIcHt9aYp+ob6kvz4hOm4jofIUUAGb+9YeF4iOApp3Ex3mm0vRXtOPlddhBV7bz2iGWe/7TQJ17LDmxJX+IAVWzM8NU4sThV1/aYeFoPXDVlMwDnInuyOyZrPNwir8nl0+12YKwT78z0l9C1WKokBeUmERQUU83K06Hwu6IW+Gtk/87gIyliNkHCHQI0cKP+u/Ue1v7I21zUqFzqkkj8Tf67XZbKVFYbCV+rDTr7Mo9sttoe21uCVAzcPIIWUK9R900Vt4KO6tMkiGsORbJo99BUIUSV98aM30tQFygTuE15pDfKc0Dz46dxyIayCGNflN3tKg0UaIfYMJiSTCbot1Brhf3KTG6dXEEn++RUjcAmarxP6Fv4CNt+OZBmx7iZYJkx072BM/wjVBBPRZnNDC3vfDJbPUMMq20lpfR2qmG7y4pKCeZrbxLvyjxXglqWLmxyNgyaCE8Gkwe6NKv2lAwbYvB6m+y76SXqYI4ZQgBskPTZn59yt8p1eZiZtClqYBkCk8jMb+CSxI6WC66abQfLyOmxW4asSkpjS3aQc4mAaw69JSC1bqefGsLKolwZFLwVbHXgtnqntn0Cqe+owSiBv5qjrhW8FdqFmBaNpDGCgeyTDfXjCCOf7O4Cvafm3scAGmDWKVMOpA8RFCZEby+nPHzmZMpczR0huvCFG9bM47aR18deRdWlyfMaLrt/of2dirnDNBte1OMs0CdZZ/Sqdmu8Y2es/HtArs5wjPIqNmugpxFd3HBSU2xUt0nVMZh6tN81uY9nEqZE4KMjjiIWgzSuHO+LQsOCd+U0hbYuR/7Aoow/ybNV+zItUfNH9ekkenIHWyVEXzvNaEqmdWbi1jgm8cIBPl/YGqHxq+1cJInEMSqOx+5HzFBJ4V9rr0pQNtVEtew5r0mDCjQjT3H6MCsnwE7VVp3DsvPbQXGo4YSiDJWIibFwN6C0fR6+oIndJ0Z1I6cU1bo1Gyjtl1I/SycfTkKj27CvJf+N3hvFALO8/T2CMmJyeB7GFSdFwzDyEBsc8skY9OZrxRgCd/ojQIkMBvDcjth8c9SvqqcVJXoBwB7brfolayb3efkwOTD5wSF0rW58Yo9Scg0ZkZ9N46rBFuRi3hW3p5rZJxwjjry0dqAEx3X7zRS34db46YL2Wy1wf56SRYm6bhgL8srh50wR/yflhEKt3RJ5nhV3cnAQwGW5FOvEMXdIMFjvLynzrnc0WEIdOboirt0zX2GeJGDljsJgM/oqJzfvf5o0cK44Chr5YHiSTLVTMck7G9QZ1451vO+YLrohoSnc8W6hP23Ic4I5DeuT9yIUZAMCS/pxPKsgLl5fkMgtoL2Awkowbr0kzD7xDlf4kyJ8/bMX9kkcssuoAKNa/qDVCL0t2RC0oD97H5iirFceF+ksPju/WgkUBQjm0G0EUufGSrPBkJqEnk3Ye+cm89HbSfH4ldMGdZuLRspbXrWNRc02r7H7NTvmltgk7u2LrSDaV13RKeO3MV/7pz3s89TG3P+I6IomWg55CycGcfeRrSB03qsMox75yudCDw+MS310WlERCWCqb9rJ/wxHoyDRAyBp7SfA0K1IbX1CNruVC7M8q5jnfxAurC/IYMbuWu0OjUQdPv6wTy1ZMbBCT+AxgI+UQfExaBeZyaqCPb5kMMrb7t5jcETwN4x4j8Bp+0gkZinRuDEsCpxAp3qmMuf/pVC2nFJnOMiYdw845Ez4m1kT7WcMNpbKbKYVQ2BCJe7HXyS9p2MTWcc67rjiE8pz16tvUIl2IJy+Xe4SS/oOX+BL8U7Bo3UIvvQiLsrUbJTg6WbpzGkUuWwiZ5Fq0FElfUfs9EmjJc4t1a5nqk6hLmkrBOdlE1NX1wOrEYzdFH0Y4Ba8ebfEzvZRhr6oh75talaMXJCzxtixr8oKa3wwUCwRcEoQdBoLRLRIOyFAHD56ETYrp3lpaLcjPpbKXYQm7on6QqSbSSwI5kdtWnCQCJef7eU8+93BhmF8vuDey353lGkXap0IM06HpoY6M3hUh1s16HwrXUTF2RHRGINw9XjzAWG9NSLXTn662gqHA+FvtUcWbn467ZLa92VYgllXCaPlt/7r7KQWvongB1Ji+XeIprKwOsdDhzlJPsCCkbgm/9K4z8Gi/qxYBTF5ybxBGS0tod1VFelmqT2rdo4nrAg0hXdS1R4RrsYAYxX0eQwT899sFgWga8kJ4ZmGaOSIpmxdyh8vqUqyJ03JHV83Xkq689seVOJIGOSBXRvx05hUobcgJjRMjmyggB0A4h2X8MBhR67PmNkcUvmeU57107FRVb5c8y+hK0pN/FnKCncMEZvgJ9y/NaVslHC0UUF6bPH5gArWQe09rYrcKcnNDxYeheXMBMDjfQ3VStSGDF3Zz4mtIY2KTattr1/+YjdsLa3wW2IoQLkZNUfeRGLKPxd76iLAJ9PiWEgMuu4Ow9NoDjbxErJHGHnw/V/kpbNYlUejQEWRErfqetqSm7/8IgrCEYW1M5fl+xYPSitIlCXCt1FUv3gsr63WDio1NTJxNV2bjse8OnXdRtozAwt/gDwj/3aWNX4NwgMap9UstsYm8tZSxuOf+ZZ0bfq+gZWfeNnPj2JKjO81WQ7RT6rh6bQGO5pmyzT9PE3DNXRdWvLSaosZ7SRSnsDGOAQrS3SvANuYhsMnjs4wOmy7DGtjWprQBsw4akEyW+WcSLPAv3gAtGhpoXxI7LCBi5GT0ySllHxu35Rigo+cfPfKRzyi5/WjBYxRjpqj6/hO5ittEvdb55masrGqCkof2y5YhWEGzBn659GygydEwZvcVxA1oqKirwU4yjNxg4E61oPmRF/a3jp7c7sf2kAApfoAlWUmwlT5S3A0Sh1XIGq9nOe151lkqIOfBlR4RRDDh3Mbd3MjvVdAwL3h+cFwUuK15kSpENnHHczD9Dj0HiIQPJUiW/kqMoVvtQMOIH4Fwywfw8osfT8MRoGYi2X3McXsDSom3s42igGbeMApVq9EC7QGsIghICUpU5SGhiedCfr5fdHaYycPYphUEB1e7/zu5UA7sREqaXtjwEcfuYl6SSxb8NH5JbgZR1koJquexteVQxiZHpjamPz2JX90pyMgwyfEX9S8tN3M38gAOBMlZ3mOy0cGUWOltk4G3ww9+axgsJTxQCSMHdxxa+L9tIm/gI8bBgPUk18iK6Fnm9c/SNSu3Bt4/6xSYa4x/Rmp6dCpMS1ree51tHzVGfcpVxHQ5EdW4Sf6HGuh+nnpxxOHXc4IIbo9MM6Mlt47KhYxnpfiKnF79a+JrwdtIdyZyVF1mZzxOR99agRTfE7l5Ca3PG5h9iL6ah4dLkW6tA4LJST31RH6wuOwdQU1I5A5sp9PTSzcFOhQVW355XLcAbhK5D9FcMVHRzePbGm1a/e2ULB9RV78g2OEdUFaL47j7n0/x4PwVGiy8yImTdpZNgQO1XR8zvWMR9Mndm/wddjivDgovgOUdx27Xx8GReHAP490nXrTxZ0rBjMRCg+jA+hsLAojNivtTWSZoP+ahwUj5qrzXHepLv/n3U29Luj2MkV5lND6S1FPqZSec1Vnkbzy0pbd7Ywh2zgAwkl1cUBtDVjMktu/h1izawwg59yIdNeymsUyWgITRhwNpD6JKj43SDkCw4CDWnXtbCifX+7PLNCsSAdvF9Yuk8B7p6QIL1RV1PvRZ3033HY3HnbRx1IIccrjfLyg09lSreUsWljmwDYz/wsUa0c1LgAr/ZAKBEz0+UoT620qg4aNvSpSDXU2eBpR+Ii+vhsQNRRi7FlGnHUrcUJweUsRTUFU9HjcI1BrDGVm2ZrK0b3MYi3CjIZQAKS1A98qTYmmoOj9Wc3R5EvlusO7oZtMyJmmHdW0QBWncL8cx7PTp08rF5Qge3bCZa5gWOV2SGNmcmUy8wwBQrTsIv4SCkq9u/8JMGgrWKmYdDd9XURR/VS/yoA+kejQwv8JCjOs5IaQgmKBc9N/ObJO2tGqTTOkx582dTuF+G8DKi/BqNvGqMIGZt6acjI4s8/WaRn5D2gdhb44zXrp22uWqJ9DQOQLkcJXsLQ2Fy/9+4XVOB/ugLHUBcaRUAymq9nMe0TbtHJfyv6sXvEu5EzKhZJO4dwFzXy1BUQ/WxN4GKyNS0KY3k0nz/pK38hREoF4YuWEiTsoEWXdOxuoYPjqr4F9qTRYY916sGzBMiAt0QyAorPE69KkrWb3/Y4v8hsMFfywY5LW2UTBY4w2r5IY1NoLLYGbHKV/wlHEy5BCrY54viQY8w8c1rvZArl9D8XEcTqIe0BSZShsjfS9IQLHOyjDuuwjuJD5BaubjLp+Rus94SppNcUSow9ZcGtFSi4crtRNGVuAPZwVqx16dCfZVdqOYaaR/EA9JTdkOPEcXXcd6grEy0foTh6KO6Ky7ioWoIY4DfZfWAI44BVPSDm5FMA6f6xjE5ggiLpOREBJNFnHg7Vam4Bdums6EKGdRov34wqHzAwO30x1T2jYbSZXO84wAIlgp5Equm0xHL6oyhEdBTCYCHHjjbjNGn6Km7a0KFkU1sayilTd/THmGeCuYVBWDPaJ+juadqu8hUln40N3JkxQbH/TE6rXdXwHUl6A2Vnjt3hIG8FMwnTgErbM753HwYAhcXaYmjmLTXZBTu/7OCQWc1y2r60utgUXUNMVbzowj2l/JU9b+wMYi8sL/KFKKDaw0Sj4z5TrdU65V81+1l/AmgMq2JR7D63XrAFvCwK40JpayOd36WlECuVVHd4QQdXwWbC3Pdww9+qt37odr8aFWqlwxfk6hzhVz1iaREWqGq/w3PgEdT/oHE9fYfiI0B1Z8xzCW1pKo92u9I+RJ+C03rWek0FXa5ehOvqaW9ZK7WFe3dLgjhLMSBeXBEVuwryyLrACMmM27fG9e29e8HihXZ7eF1uJBGhd9sSCcpYe6o6qTPHqtJaqwQDUG5Iub0ttBpr7UYGslOhoXUrpkIXhYO6jgAaEZVr71C3+qaXSfOoqbnXgm9Hm5n8gAXr7SgaqZvQCuMluVbQa3q5lkmcBGIo+Rzn08BSNw+sp8G5p5T1D7LobeOChYQVHYbQhltj9mA12aRR7t++z5N/B/4LEeqiETxWG/8Q7bp1Nb1uL6AgE/Yb1G2vCsa2/7ZXOPxwMnGqoT3ESdb22L2gdpfQTpvrWsAcGfuYSqLYezl3nxetIV3L3Z7FNbzv2U07/ql9a/PtGaQR2dMg+/mhpkiggKI/MuETRXhrByqWcxuD1K1j0WdlMcGCr2WoCwraLsL1iPfnfEVdbeDOSWmSLqykSLJQYNUrwAhsxPEJs1Jh/Yugi5r9ArUb5a+teo+DWweek/Z6YjMdjYti/B27yxYEDLTaVj9le88OPwDZoMX4+Ucdt7MAnZuRG4f/AVKiaqqQ5QCcM5/vaUl2sSlEQQboZsQzaLdMCnYmP9AK5eOX6x1U05wY1audWkcZLwohTENAYRGFWya+2YSi2zT5+WN2bY2NN/ZX7sK+ovEjEjvIJKhgeLyszUyiW1hUtVCSKl+ltzLrkbbfCwxjFUn5JiYbu5JBYaUXVmb/pXjJb0HKjFFZxbho1B/ZyfwcDgAqHsY0VV7La9FpjZfsFhU8leH/MTAEX0M/WNCEnFEOUjaHw/GFOyi8Jx88DrcpemDualKqoZlelwQ+l+LfdTnHLzYlpgxZhXx+mOR0kMbaHO+w4ozI+c9On2nrPTTSw2GvSZNvhvATQq+0IHrWGGm4D9lJ1WCpxxVBpzxCdF5foB6Nc02sGX03IAfPeV8pa/QfeEZndpdsxdijqXWuuD5shBGmprchkxBBbxzt26ZLjEZEYGjOEAmYvuw6WJV2K/DYA2NHZNcN3zf6EXAULi5NXDxzHhZ1CEXYCDwkylUHI++dUotP28PPXFR98wQ9TD63uQf++06sxpxQOdnNHCW3hZM33qQHtSSGV5cqVQqcZsim3rdXBLDyFMyW67UXDPRO+2JjmCMfL3XS1yL4wR4VeZkdNiFHsEdjIqYirqB9FKwUpbouGKl3/xKV2mZfKkc4G9+L1Dya06Vvyb2m2pnVB1rvaMGzeI2THcWuZ4rflpn1gPRGzywXOR0+kgNygsHYU9UKH3R7fQMxVbA7M2oUTn1u9zoCvDGryvGyHAkh2dWxf3c35hYCBUdVsXe+zp5B2XZteiSj50APQ8vSdsN8sQoqrx+vnejKvqPCaqlFZV8nfj86OFgup3dIEX+psY2sczH6Rbe+CK7wPdCnBgYz21ZXSGs7Dzsg4VqvVxccS44EsK73eIzh1g0B7vsC60c3+g09ZUZopNUSPGjQfLbkbKocRgzf/XcUuF4ghkl43UdHm2wYczK98PgaQZRvSL5zXQK/D5bQ8yw9OJQ5L0HlDvHJis9sESWI9WQwU42pQ6vGBdzP3FMYmsL5uK7+lrUoBvP9LUlfCZaulndd0G7fbVGwPYMXpUiUfZJikFza1sFw0OIcd6GMBMhWapdvKfxLKlr3hSxIx0EcDtzi0XTpL0MaM2YdBBn44/G91v0Eo06ZHAGzOGKYFhJumH4BOq5fZG47ewUepkFrxLMZWR2jQfHEuncPOKL+Y7nBQLHqO4XzSDTaQshu7FToLuDD+HEWczySVfo2BXvJ13VOJkKvkONCsTzeu6nUw3Xquo2zg3d09Knv88Q92OMQ5wNNnLXZYt4/pF/lLahCIJhiVDkYJpW3wkfEOCFh4qgw2ZcMS0ArUAD8s0xmaQZezfqGtxegiHwYbHBzaNnxGvp0YDpwlFJYw0N3eCtu2EmkOo9gdIv90LTh1TDOGIGsjt911NnXVIK53PXkH/zR53BVU9s9Oty2w38xQvOFygrEuOpcxc7cP/Pb2BuKHSA1qQFX1RlGCS+BEpqQAPr4P1cwmu3kZWUbndIc1tx6934tOg45pc2YOkV8MO3GiNHdprIxq/K3znPlPTMWLf5KlilD/HeTn5uxBtwoWKAdtImC/LEShHDAYZDKrqbNhFpRcLJmqFsIBGeFnI8LBJ1CO1URkHiPaeRiL6zAhP3hcU0mufzdEVj0wd+ISS9S3WFYN8QWb1uIQ6Rgmzfa5rJR68iN4FiGz6t2WZ3Yy/0+mtLpDTG+qEcOv056rc3T2+OBr0n1DSu3Im9uO3ZIN2DuzFpu54tcTGCYhfzOOZwwCe1HW7PtVEzoQScL5OpkRcUGoVtDMybHlA1qanzMicHIaQza3TjOjqm6XPfKUNXJK9z7l2RHjx+M4IbpECA0/2h+wvrLB9VxhhZ7Mm6ogTC/TUKkDnphIWlXiruDAPKUqXROlEMn59qxAdFZwGMYvHXUm8CZUVIWjfwWdz0zTGwkE4i7WhSQ1roS+GxjJ+ZxtcqdspKTkWypZt2AnV++Tu5qYar3JaeUWHrmger0oMu15YjkBUcHoHbne1M0R64eOw1D/F52/gFTN3s2j5gr1EkBltxf/XwiTFXzTH1UJS7r+a6ZtmaUDQYsW3AQdgBL1DanaVvcgGlhvMHxuemzmND63Dp9iDp1hGzVvhZquDQtZpFiwFm93HrCcGUaP7iP/5yQDQCv6KtlhD14YxZOrq26IfZd1hbcY01SBvwApcWiS1uNm0R5jaCkzNzdceGetWGtlMyKp4Cec7cfXgmkJRW7ar9G1ONtUKvu68sL0LK/v151ttJqCmF4RJs+CRVCfoXyTgaAMZNwb8A6umYMQewHilBs/23h9Oyw2Cwfk21hLiUOfay7xEwWppiSUTKlc2/ZVHrN3RK+NFQkLBDt3FUnINddydonREEXK1qTzbdTk7euFXucvJlfzTxZO+TiDTyAslDLb7d6tIxJzFzo0jGKDLaEc0ZT/j6+u8mRjYVZH78kuiKS2NLDJp8IEPBjbpGCr87A0BcZMIUk2DjDiLTgq+Coj5AEic9qjD8u/Ike8/9/Khj+dljxZTh+ca5Lnk+EWOAsl0td/kfFrGK+bciyB4Ba+uk59Mp1g2t5nManV1+lpb+xh3TivTSS0aSo27KSs++QoL8aRJSUD+bCOIZmq0UY9HoYR+HdEaUHhhtCErbhD5SQCDgH9H/SdB9oo+X17oKNH75kYTxg8+WL+N5i5X2DQs6UZ3s6ntcNkHsH5lcZJ6wEhEeaAA6bRkGRcYJxVwbLrbgn0P3yh//w5pd0uB7g6Be6eYliObHvYLuGVBR+2FAPRxlv8CigKaU+XiMPwcWKUXhsHGJA7iH2r6wjGFc5zTSgCVr1wPhkakMcZF0GSbHYid5V2cYVf7g96BUCZCEtBPk7TNInulKnYp666NipTiyYYvMwZFo5xT+aBmobTWtYtK9mfp6sb2zUTzFNKS39CbdGiJgVDT+y0DUaWP3xHuGOySsV9j423OH3+qa+xQdr2L9ofhZNpHe1pPlreoHjgY1d3AYotIcn6TeILXYD6tbNXXqA0tPfxAhDMbn88e2JwvO9uwjJEo0/NOzwywl1p2t28AqZDqMJjQScLibwbndgPfnlQ7QsAIllE/gfcKVoOb/Y+vGLiRj9Nid+GPXXHcbHJdgZtC/loHJWH0byTM8/x3XnPoeIrkCW5fmlkppBhkZ95SSs2LsyEAib3itHqDkLfEJP0y6Q18HBVcRmKkC8bikcqU/3ShDBeG2KO0hUW3xJim2l1w0gdoqP84uSGxF7mHA9K7TzUw7ycpGUBU29boBN+kIBTpg94PmGdqqVua0hMgkzjOc1Iu5P5oSa4p+5h5W3v1C9BitiXvmvDRMcR4t3CH4kbe//84wSqgI/WhUHf8YjHOET2HAbTGH7xenfYON+nPS4jbYgQ0sfnv53ttpczZpOud0xK3Ewy9Jqd+QW9gAjX1eHBSK5J2OmxbcZIJBRcFha5QCVU4XKBbaJl/PbhMm13YgwofbcFXlq22O5XRni3uYdDdjw4NLE5YV/Ki7Bho5QFwZs03yNpT9ceeUfq7cG+2yLrSsHNrKtLvfqEdM5L90eTQ+OC4+JhDEdGiZVRaWyqqd5mi4G/P7dDlDTwbcybT7P3i4LeEhflEoTTFewhcKjj3or6ToEOZ25QA8JODfDojFrVpGv0sb/y0djElcEooR2sXRZkJth5RaZnFCxOr5q7KtjHd5dwY1BXFw4t82WziUO7+7BK17HNFgD1H0ZWTUOVsuzlp0tBH81zT4j6LvAg2FmZCy10swX5DBoL3Qn4FnalwAk/cF+BY5nIDkfihBtAzvqEEsgkB3BXbkSRkEi8KPKaFJ6DQJ2sVLzrhdYWpuYnhRwkARGADe4cQtArUE29asPQi7ypRGjQI8JDghK1D7d4x7QXBhfNWmjVOeGv9WdPvkZe6IApnk+3PV5SxM+Xq4ptzVbDVp/6llOPSuEMrthCzyosBTlRaqGcvbTWU9VIWfDDpksO+gnu5mwU0/LWjiHr5flh5hpkZrFginqyb8SWQM4mtx4a1FcyykEuh/oP9ohL3yLAlO4d46MNFS89tsBcgFbWUqqA9HI/9O9dSXklYaOkyvwk4hxipw1BL+Lud3pI/VUMNssAPgc05lHTOGh804Qwd2MPS5YZIgBE+cD00o94jbd0843j5GU35hdIwqDs0OYGEbdbAJwb5VONzHql50XrkefCNGl6o17cH5dTBfkk3snUcsKHASumU/3nWiVH7aEdv/4qehQp3ibmGdEI42KnqtckXyMZABU6ml0e7Oa7+9+ubdZMreMcaYNCPe7sR919l0X4UOJSX5AsAdicrJm6hLZOqa8dGIe4NE6fhmt7TDdp4R5htFQOC4xlzEK5x0hzqqursaLPQDrtWaIf56ToVy1AF5tTrsy45RNq/Cg8l7L4oTrdvsbIywQEemZVxirL8zYZ7CCJDCfZCVKPrDCTU0fP5rrl5QJoa/TRUzkYHbe78cS2fyL3DuRu8GeAcmHCqZHTIV5X/2CJnYJHlOVbtdYGTksCj8dJkn0qhas0b5znBQ2s2HpVz05TmcO/Mi+9GLOinNSZJDPOrKuN0WEsHqAGQsxCPSZnGQz9o0dsxjSPw9OuswoI6ZVsorF2a88pUE/Kg05XERs08lU5diBL2I5fcjzcgxjLnbTH7JjfX7i6tD6upVphxBuqMxIqYU0OMMZRd5JHFyTEDkPBttGGZevazKZ8mJuZ6fzvtrM9FAPKxKTxr2B8RdQtMJhl9yGvrjSs3TW6YjCVHjiwKGWXTcRdiSvXWC5J8cvvhuokZpkU53/YGsnc0Bm3VRAVriSg/hqGMddl7fnV0SsFVVKtSZ1VeZ4PiPrSnWQ+K3g3cLPqnaL72HBuJa8W+/TxniacVPll9pAopdwbBDAFPqlEuDrOBzsduG+fIzCT+bKNvxXjkv9Yo6IzY1wVq7qOwcxQHVB+ctaYFoo4g2pBy5tqc5jKxQR/DvaJnUuHSBLtaW9RrNF6IjspDN32NnsFdK0jrSa+SrCMZFz05H2hIumJZaNsKSCi+6ykVRLdF+vZ1Vl7Ax1tG2TS826VRNuapkmXydMcs9BKYUKtXfStsOF5QMSj3S8jd48IiVm//ZhePshiV/ATzoNWZW9DU0fSz0UBh7RFNZwUtFkkWAi6YqrTjdGnj16cxqIxkuqsIuIkCw/347/QbVRW3UBXy21XZ8/knVQoc0ByFymG3ZMQY3XMbvrRWmuxC5/SKkhQXekLC5s9hFCzAnEBdvlXP6bjFM6WOJKr9U/BN+Lbcxyiye3A74qh+4hI53kgaClR8ilZ3gW0uY/eIAnQNRPnSjSTqRR/j3YwikAHNFehzrgbDBFyqbNjwVSyqR84bzI26ZMVu5pWsh3FhxBNVl14IYDxdu/Sq15vGXzukR+fy1isvFSSy8PMLAtrEJc3ZVMKAa1uSgfsuH3NFs2KLwloEzCo4EkWbZyGrLYlosH3sVU6sHgZ+KtapwqYDdwzYt/Kc89/RfN1VPJUy2HgNGV0jJboYQH5EsJML969hz565X2fXWJa466qCeOtEl6BalDsm0tmRvO3NQUWmab7jrIroakIkKBh8eq3+kGIyyKMfY6l5PVxSphHZNv/ZcdNAhFETerzvW8577pZdFfBWD5cHTxOg6YwptuTjb4H+pseG4iy0Nxx1VlS1d/Y3dfR5SND3tYHWnC4aYjiBt3OcX0cSXA2MqLV3IyXkvyW8K53thTfQTuYlWg0TQaNbS5RdFJ6zXdLglfaWbehjJXp4m7fM+JQ4bflIvH8zxIVMHI4Z5U+/A8ZYRVWCOiYraS+iisDD1iM8+3yJbpMGF/Sks8wJ5gxdTZk1hGTqRhyUfdr8xymilWUiqmcvmzoO5L02s0j8ftYwv5WI6ni7AepA25uarIalQRQK/iNWrZT1YuowA6PIQH8QjPrcKcd/wLEEhKLo8NBfwNYeXNL/pHxJ179yiVdhPCBqpKPegO0qoIqEoRfK6YT0q1bK6p9RaRyYOQ7IjyD6OQEoR6vJ6PI+vW9ELQj3xxQf5JqRxLKIO5+S4OQWItTNybOk+rM1s3OJpXLs0WCo5AzC2/A65EgWtyxKYhXKzVtbGj3CEO89gJVkBeMYDMAojkqSsumGp2+B//+/tkdQgbapSO7V6cimsHHgV3f45N/VjLEznBazxNvz8HQqcddNR4NLlCQnJOBfvZYIZ6TURJMZF12k3APedaP+wJmPOV8/yHeuHf92ydSHIqVssF/jve/rwqmTEUk2jt9ckG69xh9OM3JFIEDcQ7gIhCHdoLL+b9x9xLjYmxNNzVuntlX/UUyyLOgk+ZQYJdl1FjXSTHpJcn1LwOgnE/YeI5K8B5hH526mXFi/82zZb10lwiMbWvnY8LvYs/6YUYHtDdj1Bfq/autiE62Ljxvx7/TmM6XANUyHZbfk/FjfigQVmeHy2unLZISuddWSwrj6HqBwxe4wZrCr5psN+jItyOFcguk6wt4TzEvdpPzYBPFWaQK6bIekbhWGSg4WrWelYwI0CeyBdrSn/y5TZOxtn1zYMJ1+r+CVTb59vXNHUUQAdg7oVD9Nb+5r51wAPpBp4C9UWEjiQfpFVQN+96HDT6xkEvYAFhVY1cGv6bMNsgdNpDonDpJ9SObd3Gyr6zXH/CItUU8KeMx6b/0VMWUMpf7CwrFSjlbWOBs7dWTbPpg8D4cYgGpCZ1JM/SVgb3HZZj4w4eDNUaRXgxz1EbTinoEcmhAmHlpZ/ruwZoY0QVqu/a9ulB990WleoG5uOjZ8UgMEf4C+wsWl9ryKPm1XRBkT9zfJ/jc73Tx7kqbgM6t6BnipC5R/zwj2M/NN8jH625/JhiYFGyzf+0aLaMYQO2KUx/4/azBGhsD9xofobSL6ykWHejA5faUNANbNXeUU/i8F5poprXGdW1DWTFLN0rw1CWyJ8beCQuyk+TfWGcOH2iHtToQHiO/gatsk72xlRMPzFdh0v7XjEAa+Pmv32vXlAqA9o9U0MBv5qwANNfwOU/xSC6qhfLR6+cfvYObeiosAZSh8l8Ps5CYZqfF09C8XEaFmhliYVJwNTVhQNY1BPUL4gIspxFZWzKKz+oe5nMwbvdOVcpRMo6W67kgnEkcAzrxJsrWVUxbGBOyyKzyR6MskpepbOBeiO258vYF/gNAecoefS6PiwatqLyNK7IVmhiy26tWiiKYmUkaJeA3gWrOvtDn8vlVAF0v6HEMTbSnvhZj6KdnNQWwFeV8ySPbmEVQRdJe5JCboLTUbc0cwLGr/BOZ5yCZ+S4JHEUuQ8qJ8Qi4WU+VmrwT1Lz1cMAk3tQS8W5TmQRRy1ZZr1tG4xdVm1TcTchT8q2b9cYEB4KCqjgfkDGqDgD0SF9XrnYjlf520RWrB3VjiVm0YGRWWFiQTLXOxpALtAVL/asKq356uitla30XqnrDWf8u1WyoTB0+QKZFrZkK8yE5yxTRtlC3Kgg1SXSUAfh80NoJl9cQJ8kJoFhB3+MhsdatKlNYdFwHBI8J+cHd47VNWdaqK8p+mMN8kwmTd3FrhzxRgQyS3LKuKauhMT5fymtTl4+gKyWpWwf2McKRO9SFwAoKmkuckIFGPClR/KRyE45Ce1+Qp3CFc5zcBwRhXc81/eeu1C5UlsnvyRPyPRyeeNex5MOVtMU1Hd4hsyObeM0M6Qx5PjYHlMj1OQv3+epVpZndsgnM3oA8+dLLd/znfUJCUUE00BEUYkHdc5HCpGwQDJHx7/8Mr/FjL46tCEFoLvqZkuXFZvGljOPaSmHI63eh/9Sq+FVl3qb/WW9qM6aGz3N5VW+Te1Uo51v5ZhHnT8OMn34GxDTaKpz1Thn7iAdAsSNNarhoXFe4bzBzf+r0vRzrZL0YdHja8JwI+29wjsHLLlrPqyp9DaMXe0nylf7nEBv7KLHrslOEdxb58C4IIgWO2+iNIJAvyB8UEkw8TF8NVC6xP1OIP2UkRXH/C17NiycZ8JzwIULZwAgvMeN2cE4P0I6y4TcoIcb7ICw8Ttc+tJHuuokOMZsx7mYJWW74E4ZxkvYtEYTMzFZlCQLluSvI4xBQCFhtJ/Y0DkDRFONoIgbsMO07NdzdXNV5ZOVsxsUPfvG5hC0B9ZZt/uPyZBww1ULprIYHinpALVxr0vbSjUFroMpHksqw2i/fZ3k8qcQL9PVOUmoUfG0uQpGKERhsukaS4BBO79rsekLlo59Sd+uLvy7auBOAEjkheDlNhXrvH0akHWyvSbvqFMDwSDuZNxHhCoKyrlAW7Fkf3t64zj3fGMXHlw89ccf22DVVxiTaJyG6rZIBVkzZCaCY7inX/L03Ftn4dGrTQZ7CuGisQGft5wHfKjt+rD5o24pMrc/Hd0eClaHNZlsYK8XhG1sgIhI5SHejos3qc14zr462gVsxkaydeNQYoIpYPaiyDmZtNxf3S7y1ZDObAhETebEnCzRs8NkXEkQZ8RBlPKkUcYQB3po4jgZJdElnOORS75JNOurNPpTRs+TdDCiqjmeoSn60ddy7E88i3ecUpJyAHMANFLs083cQ3lkx9PjZ95YLWgqM1KIRL5ztqN8E+TLy5jI/g75Xdvw6Bc1qiV2xSxA1D+nCHjGjoRxMUlnl5hnVEgyeQnKYG6zPHJA6t/jDVUzoveC93uQ8cotBKoL3o32lLse4tXZ8eg/TQWDVVSzl6fjYLQxaSZJfN+eNOdW1DQjYupxRR4W7QbglzdPPn2lf6LN5lMt7YL1+JKG8cO+dtjppyNbm2xUPT5ashDmJlaqJY0EjF5I+JKRhAOecAQXTA5o42Y5BqP2ByA0S0nqOi1AYVHx6F/4wNSvafJrKlxVeUfZvDCvpLahEwO8g9qdbesOXWy81pbiQGy1/7aAhg2Wwgcl5q1NdoouM1yBTsbi401qFDHgg7cCZ7KsWyPAmMUzo9f4hLA0pY6eaQy/wTT0YZejjJwwZLQJUULD8Z6KoEZ0ZVe5bzn3OAsIAGqSC+0EKrEFXExr6Lb7LOwjgFo2KLOIgqMW2Ij3GM91r5HJ8Oz+5udqmZj+sF25GCr1qILFM2qfmYGw4xRpEJzLnA3cCLzJmeKEHfKG+pexv3MPwrsnwBMnyUbN4hXg549uzZ1MCvbUMcd+46/V+lQ5qhdbTsOEvExiHtUUASHii47ABXiCep8PWigJGW0RwC6HJv39mwey9ebv6wuKHU0BqnS80Nif9fuAl6q78DXLJtA8dJ7thPo1AIIPdhLv/kGN4xT/lX++1iwr0QRYEFlFMVFIdwGMHR7MjK0yTj/bGu2vSiWjGTMGax48DeGO44SrJk2j9uiwLlXwQd9c/69rqhfl2XWgmbn4/6NkDKEcRYp3ZNfcbzOCXSYu47WuxI7TFRU49dG++cXhvHHjHZsfwE1Y9+/cDLbG2UVc/oDG6phIdhURFGAmM/8TvBNyUuU+3gD64QWGil+Yh0UeDz88fRvOyLkev1b425fvLL8yjUtwf7LFT/wHAuHK4FewQMY/eg6XnGc8yaeqsCSwPddkYlOGny8DMDxEwkwNiv1gc5G/HzamO4ZHFh8mx0QuaNs3q1HXrx+T1Y9VHnTBQklQurZHplHzVx4WvIbi7OQFyw2So58/HJAuVlIGboIvlNDD7x7KCjbS14DiWZlG0HBG9hMGcE1RSq+N5X52ir2wBIzcLpsxq6F3+0G4KWVNryRqR/2QBDFPdX6c49AFD5c0xegFTop7+NgZC2rNFjxDQ8a+xjpwQCLjDdcc/+jrodAZQc8/4Ix9SZr1ygoY5IXWfLHEG4idERxQAGw1vQui2KQaeYgySOS1vugiBww9CaRU/obPL0QAPeeieLlZ5iGXrRZ5Z909lph7bO+Rrp5zZ3RZg50A9DmlZKiFee8kTAFJRV4oduSIb4eVKVi21WHzK6+Kubt0jvyJNwcu5K4yIgfakldc1UglZxt8fNK8qpeKq/6dYPRPCLuKrpTZuTZsZeW23rextaZ5v+CIwcc6FyaeVTLxq1eNwVqn5kuZH8PF+Quqxbapnnfa9NtprY7WJcXugj+JTa5ormfD2O9Psn0U83oURYem6twH13e+C6UZAJ7I92MFxq2utTzv9i1PGzNHHNRMpD2XCswFYxV77rky54vdonenoPvJmQ4HHdgPbov9kZH8ElFzOA9o5LuFahDOrpwH6FWCX1mVfneDNPSOMb5gQVJzLAG79dta4OJniHuufwjfkc4NS7oHTKvEptDZ3v7lXF4KbaKmAu9dJpeoNdppQP6bkAKfasSIfXpz59WgbcjLPAVFmKs4LlveQYO/4EdXPN6CtKrMcJztEelDHxB01kX5n6S+IEL1rCeacJ4FouKeDf9PdpDxS/64vTSpJjRK5ze5BRXCLTlGuiw/sEBTnrQBXFyb5N8Cv+h3vLAY1/oNQatanmddAslyD050G8Y0VBOjajVmda7n0tBjIRIEhQl4VGL24YIgBYCSyrPUanx65BmvAJKR+QXUyqC3o7P8hWljMDEgVK0mUZoksbeobUh0vSfZqJWu9IBHJL1oJnSCzc3s1IBNJnBiGkoK+eJYh51toYQfzvX0V1ik3f8TNmmQWE/1/pUi37KqVLNO/tLh3cMXU7Tx+IPXcTdO1LXgwucrH84HWrM8s5K5wY01eh0ODKMDLJuKzrdGDxFarUuAHcsVT36VjZKMCHSWpV7ovzQjom9knVtXwmEFScZZUX79OEVh53qXCrD163gXg16lKDJ6y1i3POBl69Ec4V2QOIi2LdjCzrtzO7chX8cO7RvsaKjcRoCR7hOEmq//ntc3TjS3SIHOR8TrYFGibqm75KkkzsX6GkrmOCoUApr0vXbXRsPtH0LIzpAXUkbmYaoHfaezYjTUVavFvMf/2QvFtU3PojLTwKeHugf02DmW0F7weMxQtoUi5piZSRJM1bSzk5rpUPX0d80FHMY/TafcO6DA3NUv6Mmzv8PRk81gRiroTW1gFpXWKbm1eJZy7wA+Wf1pnQvwdwEfWCX7K0ef8L2jKQwdBHIeXZ2RhEWWi4mW41+kZtAY+5Mn28wzaey70IUWHMGfuqGJlIuK4Epb1XoPhJTk0IbtdvTEVpB05+9/3FXx9KBdxJO0tGfZbj5oINmMCbCr2e50FlzRVDXMW8+f96K8osvHblfuIYDEYa4z4y9EQJzexQ1MdpBKHKOEMHoDJPFERKuQ/f+g3RYYT7vU49MFQUh3TINolAYyjMANEwGXaM/53T+kQQctUAnM+un3WEu0Z5Wg6vwvFV658jKhzbpSvoUwhOGhQF2U0DuiwQS+FI9lsd/Djjx2gfhsQ1lRPnH4UMyhDByxqkEDkEhmM4kfP8Lp5/Bk2rkOFjv36QivXVAYCqUOHxA8rwhzV1uqd9ZVobnXKSnusPZu56iXT8+74PP1SEUrZkFTEcgwcx6nQEVfEky6/aoI1aDBjg9W/0V9f0yBc8RkpCTqv4REsbS66a2dAt3j2XOT63T7CM/wHKvOJwd+epUlDlmcta9NmWUdl+dNeS65A7RogsTw7V+ZKXDKJs1KRK1Ksk4xNMzujUCisj6Z4oIMerlvwdcqEJSTEfxEftXFwF8eMXqroT8ZiKX/M2sobnnmp9zh9pZj7OL7XfPf5a4e3rUqn3lk/gul+XR95ly3pAVMjy2m5UApFeoiDSB9zg3PHjSMrMXOKiA6WIp8IIFQzGMpUsgkns+j4gA8caIsOnlD4ek2nvai1osiJ1HIO7jO3w5iLqsddIQzsmpxt6R65a5PDTnO4tjpkrcGUOFKu1Zyaf5K2/HxLT5VGPwsgZKmBtdzyp4e2tMQe+1TtAgTjlx/ilA9bhw56b+uzgGn6TXdP0J2StPdTpo/g3jZG2IdoOwSagDZbPux+X5GurqQgxHGuXffb0Sph75+XL2dFbNmDn6yRTKhX+Xs5PU13uRbgQAcvet9iCmw2naf7C8/gNHZeMwuqvg0q6RiSxiL89BYehCFYN3W5zb36T76PbJQnp8Qz9JC8jSZKv6dWCijMqjTrFbpkAgH6OKM6yTUKKT1GbxcgLV5yO3kDN+FkslUQY+CdFXQkIl6aPJ3jiLHkiNf+H5W7Vi1qEa3Ap50LxpY4Kcqe/b15+kHt04OIR6E74qQekMXBCo80gUkBWB2xv9OZpp7elJoXkWMB9VmYYhNg7fJoXVODjYV87q1p4X3CTdTxhsIngSdgOBgqJEx7igaNHYGQpTIlE8Z5vNIQ8Gyck/i9nKWsQ4RuoXfeOTkzr5FVgG2mKdcCkooVgOQ0jiYcH0DszIaEOrUK6YUP58TL/61W5WLxeQ4drJHaJMVHMXSRIZ8HFQtV0NjvWW8DFNGUNMAXc4BuJw1BVvZbffn/2vpcO/ee2ZfvYJHkvh4frTx5IGtCoHq9guRT7K9HSTtqBSfy3dk1h3tKe7QAF7J5/0xdaM3VbRe3IVwNlelRCpvk1fEwG7bmByjswFMSQKh9+MVEjSCSSAUf6UcfQuMRBiMZtzBjOfxqFFehup+vumA41Or0x4dlu497pNho3zjEfeAaN9dfvpO7tYFETSC4g8/eKxAuG4zvkUoQT7JR+fncvrgRastJEk13fs5XWVNPjxCnIb9fUdOQyShRYCuo5iR+1WjlJIcb6Jx+pbc+0CCXXpLFwlcmPOJJG2nz5hfrntv13MxxJSPmjg2xXUehfFvucOEygVw8FzrNggA+7Elokv09BNBh8BwvF/YL1cdt2bbwHIUDrhU1d2qBT6KOpCkZWP2C/KLlDWYA1LcFH2Jln61LNIWlu/bL3n8j/RPpsgmDuiCMDldu5MwJRHwX1h4AKl1Mo646/r2arXckeVTgf++My3uEouIDrwC9603IBsgLOl98shPzXeCmSI8c7gcwNh3YCrFWDsh2ZUL3TY4TjvbuR8aHGvb65qQj019X7sVO/eKW1T0s98rby1tXTYZgdlXyG0E+3qy6F8CPaVhUb9EGJHrBshM64XaRobcSgg/ytU0j/gLKT5jDIcXzRqgPIFYZVToIx2JQ7WbdQRpdN8NRHha0GTwCeAx/ZiVV1jNU83+5dsgGqu+GNz+HKRNoZdi9tMVEvF4SD1rw4bnlWd6saIesuatmqIqvCBSGsb4Y4QRgt1IypzY2NLKgNH1G9Is3k5kXu24eOhIfRyE6UTfynfcOSVilYIeXYD0zTMNhcSNNaOqGL5byQDNXjW5IMDOX76b8El45/4/GF8kwhQwn+6dBgJiG4rCk8ceTNLZbm+J6eMtmXN64uBxmPO8aSbXq2sFM5W/zdwuG1QpOfEd60IVoaHnAETc3OyPX2/I1m0QrJEPPfLjTzdMANWQcRwSFUAOjMERGcJbRD3bYJMMjupELrPOsSSZkk1lDWuv1aCKOlinf8MSOnWVoF73DMEaTl2ty/zv6LNDjaeur6gHAwbG6GfuFsvtlN/0kTDCGteveuMtX9G3mWltISNW8kfHzKrku4VQIWT0K4KyE+YeFvG3+5FxjL3MRjo/OFfl4B3U8bjcRkjOjs8ZDyyhnxlLieRnrrBd8jhwHfzn6LNSb3lpExrzV+wQFFSv0ecqdy2WtSbcxvkBMC31sH7M45HrJHyW2ZNvfWosTrZ/2CgO4Fy53yn2yvy1ap4KPT8h5BVCRgCBlt6YlXi5NghhnopOuYx8vcdCpX3UuQvqHzu+qycRbvVPQFgwD5mHhItWgrLSJRUxU7ZkCJJexSYA6JbQ7g2MM4XbRpgUKmT6MC0Li44zdo3fspiDFDu0eepocR/alMrXH0bhpEyJ3riQ8rxw2UnV3H06vYCsrjlhTkqf89B6DKo9lpyOs16hg8eMfjSxTJqejZINvN117EFO4l3zkGtRQwkSollsdOAjC8BZa0VVKLtXnrXASHA5nAQXUPIc2XwA1SvG/rsTLSwG4yeyomAgjDmCgIyOFKwnhVRREvZiRP92tAL4tcvwSFHU+m01EsDGuCiv123A5aoD13FKbZZ6d+uBS5KQT0D+lhYCmZplQycA/1KH6S9ko8yoJUrag6+1XFfenPqK+S3RURl2J5xs5ac2UmqMI4lmlbSYlr89oPe1amXqyWKxERBeRJJvAsxoQQ6tOHh+qXLgHVk9wmsLlGJ+Y2P67L68GbfCDHtYa2HByCCaJk2vBUTutGKK9tBk0zK9CUksSy0ukNBugtR3V0Aa//HkfDE1OIjxun9hxr6epC2czeLIsb8KPr/rbJdbb9YT5IhND60YCkwRAexWNrkH1uDnuzzN8qZfcKdkmRRGOm8dXmDyxBBY7BscBJAQ3MqAmxZ6GU+7u9NvNtgkA0fnr5SW3AabdD9yhFooq7Q5ThM/wq3EOYgIBVYVbLSUwP5WcbC8wiSihZ4aIJIjqaMrp+1YTSocB6dlzDG/GALNakF8YkH6t8Ai6501pD5gS1KGrMPc+Lz30MqWwp9Pi0YL3MBa9z1rGwf/P/ckV/taLYdKjmKciWyIXVqz2H6Gh3ILZ3Wn3vMq8RlnHZSkO43DvA6QYf9MTyy9jX2H3XEZBOHScnvqUKuh22Kt+KmpaS4thvf2alq1q2WuDi77Phkq3mzpHaErxpHxr3ToEPz3w4l1LoTHzZTOvdxf/nZx0fq5aQubA7W89ou1kLQw5yGtxmLrzDMdoeRlK4E9a0ZcRc5jyY/E/nIq+VAQ0GFHEs5QRmgP/B0yDxpDeRFn0e3dUgo25RyPgUNpWy5sLY0v7Oe/gLX0Z8aONy2Bl8yAQXL+EekPUT8JCRR5jiZdJK+F4PbWVcOfkMr2HuQOe9RG/CgskyC++jD/D6Mts99pXr7iCXPvGOm/gwHrZeqh2K8UZDezioYEH+mjSwmmi14k7fm1m9p/Ct9pZxelyR7srEt0MkdviMO9U5iIezZnSNU4ExhMo4psmTpO1diGpKNcHEN6d6F1J6MQYhwXkoKtxC5PSgM/9cOsRZdTL0/JYvB1O/BCsdDYmcbuG3dyRTF5eYGTtLeQynJr+0OhaGQkE1C+v6GkFqS6r/yfFnHJsctsSLa2WPXMUrlbsjuuzwkfb8ZjZ/TcbDtLg7qhJHY/wb8+Qc/ZuSuKB73UUan7kt1ruaauDWOWbTlX5mUxx5c1TaaS3AXy47rB0Zrjj/TADPwNGD7nWr84kQEnq77BV97OYF1GDr2M1Iej+dD3fJ+Eo1mUoNn39A2AHR5ADffig4vycxgo/lvQ2FGeYrxRVCqTVDNpVB41iSs7qNoOHEaU6l8PYm0NoxCnDXgxFvyK7PvSWVtNNCAtQfBKw41RFM4oL7KLAiQAVmGyZ0KcV+aohLlawxaV/MyohAiOL3xoA3nwJnrroaQYI2UHqOXxQ7GAGJxvumjOizk54HIEmtNqZIqubxZy/OSQ5cfZqYxfBTZXa1/DAwT9a8kjNFpVib6TqZy6iwtjxle4Z07ARPppFSd5hhH12edU/FwIwutjYme1NB5xceu7YbMOsJrQf5AkJd7GggBWa4YEjUI1Qc018FvVxbkhJT2/nQnvmsicOJyXNUQQ9pUojv+6EuK8aTltvbFqpb0xz7Q0UhjW6ZHSiSrbtKTBZEF7/GmGv7YiLGhh2a8wd8E37vE2Xr6dQGfQWpM2/wPiYoXEp2HRSC9AsQaSWC2BrLZ95SFqjIOpyut/2uDdBojDeLErR4/HbGTcpdOhY2k+l/HKagHBf+Z2i4FN9e8kIZ3BrGL2dEqfv2IgzuwVnF9H0yw0TvZThohRC73oPqDcJWILlWS4KggslZzWeEvhI5EGmJWwcLESe26uT9TP6eTZRb3jqboYC6qfgs1L6D0uV362TwFLls+JX1mjqKTTAr2Jm7l7VSJS4SoTY1wfRmHA1A8jjkwAKmEyNkVtJb9ImnFelpEISH8BmLGjNaOTpwihQkYG/w9HNO92RKOqZ2skLvYD96zwZeOXXG39EFr48Rm8M5AaDIgQc04GaBNvWFdup4hXWZI/AACwvD/2nFcoK0PAyBcEoIk0sx2pAwHGavAGeUB/24dhLzLZiBKUMZknu0jT3fdmP/HYFtgWU5gBwQET/fc2RdyDF3tW2OtGCoe9OxU16WPU23+UyzSfUE8pmXw5KGGOkwsz8A3P+DbvlpVc/P9kdG/jDv4sxmBVqTt1zJtMdQ+G3+6oaaPwoZx51gS13srmr5rStZQkjqh2EHgLwR0RwY1Woudt+1foPDPxq5+LStPQX3IB+jpu6m9LDpeC5X3NVo68Gy9s8fl9jdjyEDDmq/PCSITm1oC88BjKsFM17ZmVDn/QepKt9L6s7oSvl6VGW5vwLteYFaVGmJJA4jNe+eOqc0m7CLci4+LFu4gOWb6QXH++ILfhqt+RsUOabjjNG5xCBJ4JQ9FBEmNout4JFLxMyyQm/wU2HVb2ePDbx4qsaIXST2d5qj6gGyNhICCfJEGqB+DVOkB0HGgRNDrK47DPjdHtU7PCBja6ZPMp3POUS2RKlgKKqHDE1N/lsPgm8DPMCiYVWhuL0fXuchE7soB/Jc8d7M82aheyiuUumNN/X6TEm5zAQk8zoqn3PnufvLlLI/skOinWuTVN4fx0IWyAGzwnE0YDvP3HaOTfEpTMs4Y5IVuY7ZYQDQgzVeJo77qX5M6vOwiAFx0qkailBBd5MF2CsBEVKX1Y5iYrngETP9xoxORDtn+gygfd35E70fqbwK7aLCsBKvpZFhFpzwpkShT+r7yR/gv3vo1nMfVveaxoJGemrrL+rFHHZhVVGrV9M72vLzoCSNTiA3UXbTGZdvMA0AlhgVQdcfp4pVBoQ/C16KV2qFSW2lp7JHzTcDLtB6nMlRPfwJebQYCzARxsNMz8Jjj1ZVfYJ3Pz7CUgwa5NYUsIHxYWYa1gf1EI3sttYxep7RkbmjpPImm7CLSuRAGYqRS34M0dd61sbh0BfvWj4dBZJiIjW5otw7PP+arB//2TXTjmimp7U8XisbjjEek7WfDNOWaCjbyxwta6j+SS7hqlBd+oODFN/zJH/fcKx+kSzohHBFU/ck0H/u4H2jjVcWZSm+LHeN8mzmiU4HgHx9SsYBIdu91T+Ep9mW0xK/WA5Mne2TBVYX8dNmMWO1Ay0IuICyNdfED5IH62hdsF4w95sCwhkYatfiUH1WvjrPI8W0L3lXwnOga/trF9QGwTJBfLxp1htO5mFzH1HXwMNmsAryvafBftCnps4yD2mN8eBqgbWbz0NXndflj6WBQjxnQRaApfRnti3KpnZdkmc17bZbJkxIvAf3EPL/X6B3vSKHGI9lE62egFGtmhk0Bmz4tuu+h3/Il/xxu4Tf+QgxPh0WwsfSTCnrs1ooo2UE0OkJ0ALSCjfKrr/6rDsq/y6VWYSoEvoJbKI9qQotX7OP94TUZML4Nbp6pMvH5GVqb9afascFu34yjWeO+nIz3w3hWpwFmpUzh/B6CMUesXtLzPARzqn9OMcTRoIdCFGmJBR0T4ZnuUtQY8TVjyf6xRjhxI5nyoDZhQs6AjBDOt+1fED1lhOH2xq3hdMWJqMRIqhWKpxU0y90SQWoY8JpvKFXwkfCQkGrVDOY23RxJ7/H9HNcFPTHL1/qt83L9k0k6fkWO5eIMeUYgg0PhAl39aRz8NPN91wpEhD6lbAS0sb2MB5SlBAyKwTefEcHWwrEv0NU85e6ihcKmLV+C91pr2W2OlIYbEmZ2emwHzrVQWzLWkBmTAgLYD9P8UwgX/L+J5qG9WkSW3EC+u1C4HEAS6Hfh05jdabDjw9ieFDCQeHMa+Vb++sbPTwTPsNF76kscHyvFGiUVdHwYZ1MUqSh8RoMmgCBCC93mcNeXWY+7Ibem6XwYRIz/hXZP5nf1L+5NZiC0E/gVOMAI+J8ypybvvrIDIj2y3lEjpDxYQ4ggnEnS3v0IW9RT1h+pZ2Fu38RpfY0qdlmO0igr7YfuXsB3T4iZa9OH8MLiX1FzLphpreQnY0nFGXaVcKn/aLFYm8hVXlPMPcabPBJOSjYfLs/QpPAq2/zoH34Oj9O1uAV9Ls74+Wyp2ye+A2VUrWwepoq1MB1Q7M78P3WEzwA1XbHmfFFlNIHUQzNRFiIbHHMRaJjDXna2Nd9pfzgNhPSFrqSF0xrxXDuLPP86ssmRHZHIlHRHPCC1J51kpJWRTRqECkgkmM7YRUBdQoU44PA0C/Zj4DMwZ4VHI1J+sRSocbh9c3ucpjG5VDcRMno2RL+1hgybOgsUK0qzKvzbtrtmWIM3E8Tsvy7MsdF8z2PAHW6fAtt8wrp+gfT74iCqaMXbhQ8ahX05JpELKMyk5GzrDguj5nAccW2e+LIZjt48ZcYvZY+wwHQcCfTQoS37bz7kDbuVBWS43PAaohgIF48oq/22aPem2JokM2sdkdhqaiQE4ZCK39DtvqI+kp5MtUD9I+5quqbXQQxvV8Ymox7HbB/gyNlTIPYy6bO7LGOIr8arY+wrwm8rKnFGodH68NedCmXgiNpCabDZQCfFjSo7WgZOkYgoDab9H46l9iHifS1ttfAZUKu9cJleYUCQQlwreJ51WzfcHfUCVPblhMzSgKSrKgx8l6jiVEElxXOLrvTGQ81OozCgM5EtSFiz+68s4HXt7daeHmnguTAKorZYJ/ho1XJWX8abdnEb3ZzaCAX6Mr+MEikm4syiWn/0kvVtaqQUIzHkOeZqosvuOCbyOH4h1wJu2nsN8uiNOjpSdWjb/DQbapZIqrtO2PJXfASiSJGNeZhevy2r7eactfCvDkO+wLT7aE45g9WUQg+7e15G+2wHyqf2/jaYUEqR8QhwfxSAKKrFUt2Xl9X6hUFiwqFyi57xRNoQRZ9vrdybRlc6WU7xOoofZ5mplUsa+v9eGsi1TjRc1JbqxL5K470eTVok4UUYT8A1E3Y+ookXJ3hzxXxrc73CoPyx1NV+q6S5klw0SGALX6PfffJ4WIVvX/7fysKrEuqtdYTtgYm1+xOgnKKxZHE+bgcBT3J68PoOqlBlNeMihJg4T235FwtK8mb11aR0IjtYb7zd0l7XM8opwZ8YG/c6PYNpuPIV6YmysJ8eGjiK8uW8rvDAtvXJokmYwbUKyLun5monvjJ66jJP0SJ4UXFQtI92KEmVwHoXv3QEZKARLKRS/0oIDazxtAs89/JO2LSQofa1mAN4cyfABP7Wqp4Zdr+pottOg++osf2/KdOZV30F1nr1K0I58+Sa5H4E3MPCstOiMShrM9Hje+/0x0Q98jjtxhkACTjpBFvgjjeTUsIpxZtY4CunB0Nm02THlGq1oGeV/ytrwFBNor8ob+LX6OX60wGNIJg+rDgN6crCFUT6ktxovc3dtnQqumo99vca36umehy8rzlZq/ZrkysvuXTFjRARD62NRVSJuOVMz5Su/Y67ORij+cT4bo+/l3obQgY/3TUW/ZSpzPdFu+dO3cYgoiRzFbLpynrJdnHFkGCNqcvQbnqmXy1PyGqbuJzrZBDhFcczqygPy1ZT+NURkv4KuYhhksuJBgAutL4XFgtf7sOde0mA6UUfwQ8wBHWaQ2ojjOBLIY8l7Qr12g1aFrTQwHuXGaPUorUziED7JURnpZmLTUTwYsc7pqwyRDF0oMzE9IrKLyFjmao6Zfv9NfTB5UOJzABwH/qz9Ylj1+hQa3PAGp/toEgdXwzK1xDqqB+qtSfYcrx9tsFgAZxNPHcaQHDgt8Y24bvQspOLiTyEA/VUQKpCbUpy1oafTkjgdFIpAIEaWc/wauXXtP65uXeNHsZPSFMItQo57ovJhfIPHqG2DIWq8ryQ4Aji6SQInd5ooZfm4D10LHyLEgHaoIAtemqNiw6A5XakhzrYM3IW4trSiiF8XnSLeX+cit4K3J97bOOlL2vuuGFYmmifYgJ5939a1I2FmDaOQSUA6dKlOrkBz0KaoVCoW4000OXCOucOHFWVWqWhZg9r2Kx83cq1KT7JSBgaYa2GUhz82iJFL2X/E2lNNHvdbaOEu7Ee8pwyTnyTZLTfIKqTt+5Kt1Qg5o5tUIiMSv5H7/b7MRc6h4cYOmKDaAAMgjXfc/3wYqCVufZb/DsrNMI43/Fum+pKfi2u9qlf+NEuhnmM/2C6IJ9TJju10BuNTs4aXkPUZxWOSAK33yvnf7eHE2U2H3l0nctHxWUbMt1BKWudYXmSEUaN68uKPDtha1mkmaLojvDoalMoXE44bk3nt1QiN3Jm3PkeC/qxAEU1b8ha2IrVhwOttrS4DGLSRYisUGPxja/30g9skxq3t8ULOglb/qFeAkPXXF/trcXNe2h6ITZ0rvarea+WlPCDw68rhNE4pP0sCRl7AjPIMQMWKA7/Iwfzo52YIvldDRGFPUvUznLbMtpjYwCK+obvbcXfVRS69DExZ3WfJHGlYQPVyvr4qXdVHLaboAZEz0Py6bXR18X8olFOGafVSlHIuyQsu0ELpCoXPXWOkpOF3nBGov8883tP4IiYpR1uOC7kvL/7ZbyBdW7iJ1pD1iWCBtLCLAvUaxDz9bgcsZWpqTdhz+lT2yFpCY2uuOeya34ysDsMeX+harylnJJHJBdbqbgR1t/MYvqZ4XGMVhtUH9YHglhCp0ToHT3manQDubcroZ5FZsvGJsUyyciI9DBlAMk4pLpAhGwiM1azQA3mbDBkK9fvFefpyY+OnEFnATabacwTe6voSD6j+Uwh71CtJ2k7avXH+JBJe4msowpq4INO8dc0hE2DJ4dCdRxUI2hPGifP/qVuQnxkuI1Uync65GAaBqIaZOLAnL9unlpB75RvNmvHtPC0wLwZrhULuIetfXA4+ImlM8pt+opaiXLkkLc2u550+Y6Jx3UENUwPqdlFboeaB+a78PzUpbc9SJESVond7eJPf2fiG3b2qvRS5CQvRAvi22X7TpBV61iU2ntZUm01EbpRdeS37mvTPKcqqlGYDiCjm36zwb5ontIFnqXXkQZ+bgtQIfP8aSSZZRhT1479O/Lkdi7ifweczFA2xB8DiuX1y270CjYfYOFWg8IoNII8iLnh39fRltIOPt6lAI5chqnJNl9Vr/dzDGbOR/Dz4DSaKJ5NoFUBIRGmBX0me9MXoXyd1U69T6vp4Kzgh/6HcS62lTbbtTWiE4wjcAth1kPWwoHTcf/kgKYOaDj1QlO07kIWXzch/UAruXf4RZEQSFwzguTvmKZgBq6vUEZ9dMlpDhuNKaVZNqlgAnEvTn+7VWw6hlt5DYxFyKEUCWTiaYrkAllRBpshXhSVXE47VZ53XhtG6bSvyTVS9XnO4namq9bkLJSohxe4i3cALJROw1tBMO8/CI/WDT2gQ0bxSWsd8ZxkmzF5+tkU2FabFjFIvNkDeIIfQsVp4UO+AI7H3GHQu2BPzpf95HhZ/tQQA3Hp3+TLsd+OXRV5eebNswgI4wM6jTH2DDye/ZOgy3IcC5umgkvwyRNy4fVALTbw0vw1pgV31pRZ9zvZ6kd2EObD05h1vHw6tLB0g2W6OSIDjLMcTnWNXCKLFeS+2AiHRx80anpLU5G9fIDusxcm363Uj5+HFfuhg28dNNMOZ+bNnUUozueBZ0WHL2tRa8C889F7PxdduwXdzI2MoOTQK+KOZTUdBosh6f7whX05NYjJCZttcsiMaqCl7uiUHLHcqWZRVusowL7hcg5/xhsujItPshG/P1qSfn6Fjp6OK9DdnwskWqrOSCHXCt8uSCam8OvK8MrwWmwEV2LscodOxX+/5bAGKeJUFeLTLGdRy8g/XVHdh18ndCVvExuzPXM4lhTUQIUaLYffB8m1MHz7fex7DWBCjHBjy2f9RAqBl7ZX+CBX0+GFy4fppFracN54YBII1U/of2Fq0QVTQaDbXb8zPjPj4a9CSV+OOhzWbXv4BKO/jHnRVChSdoU7Ng4CR5bt1YUbOsxBH2C7Xvw2PYNJNI79Zt+G2XbWbPl+EmBZyfnHl6lJr/IrSz1JRCThX+bOQtVRi5nMcdsWnxqI2VOhN9xe4Qmayk5oap3TRUp5jdC+VXGrREZVJDhagnctBjPX5C412uhlwYm6bGNpg5DDElrkImw3F5gCGy+lp8H/wYy/9hmmSmtD8G/AP1taAbkPLEE6t3NqbWdPqfKGRozkrLRIDDNYS+JPngS7NITHV2KAZaJ7vAqW3ManWd78U1e3KWRmI8jurP5/LzQi0a6qyC+4wsN/1ApYzLn2MqGgUSOKd+okyx5RJ5xDkeduRVi1TQRH3DiuFQaLub+YDgJRU5Zyrv4I6M2qyREvELHRZDrMhTfUabDxIXXmrtDMxV8uUQPx+9DYkjLiWXLQkFOwavR3XlKzNW3ELDKJrq/Cy+ZulDDIsR1s+HoN4NqV7a2FxmGOjGAeaWdVUvQTz8sG1WpPrsT3iOYZBGCw0LzgzXAcP3fdCuQXQNhHC5F1wyoDzh9AOX2xnOd3BK8UjZDSCKIM4V5J4FppQy5B7+CUy23i83UtsDZa3ZQAdwMlQW7Egkh+01hUIE8BDf15gKzWn6UiR2yWJX0LDxPmL+G8gyv9xVQeF9evC5r1lwN8seYvBllwot/YfSgN+xk5uHUy/62Cu6XZ7y8haTMWuyPgB8NkbbuLrZ9djEQWyFfoSq2BBbDMnR/JnXP41NP2NXCEtMuOKaeyr/Qhq6vX1ecGCP8+A0Pj6j4ibIO8jdrH6SwiWjlTmYaKl+9qqokjS3DW7087IFVl74629D/4Pw8aun8LOCvktkedTvUhEGYmxW5IqaJnHu9ci3ULDubMVk9xNgB3mwXYMmfmSQDlN24YVA4GlH+iYRTJ/J2RyDlfABcM9vNCClEq64YUJPohl0xFK1pph9vQYGM7yFNHT9VgqBhcq7aPfoE3jMWWyfk3fuFJmnciImfg8z/eh1iJHs6vLVsGBxxkVIE/YWULbUn35dR80N1/FkNThJ4HzQMiEeqLGe2Ah8OCKXbshHwSz8qm2XAWTt0VV/yq+Zl/9s2dWAbX4xIoWfzvvcNdYXq1OiVXLh2xKvgCdn93xS6+l9TVxnyJDxVTHPHXZjy0DoeDUpwcKFBaFAxETtAeoz3JsxejEp9hFi868FrBJ/BlrweKfftOFffT2i8Qdnjnxudeunae5nPLJa5m9oC5zjPym44FfIQmBCmW8FqjLUSdWu1dDCrrTixtbeBQZWTEcAzwWVgW7SZoHEugD9XZlg2qpwJPLaYwPepCYtligupCSCVsRXuX607FZSUTI6nvbYCODQcaYT8dRrKHZkkieaoOdroKYs+KeL0QKk0EASSKuB8b5Ewe/1a5wZ6tHD/CDYlbVELUCXXTG2woXxeFf//gvWPmqW1FRvrdQHiofnmgL0iHQFu3LlCR6DOzRWPiG9/tkm+JVl76s9zOlEYm43VXPN9e1wo57ApnV30uCAf1YrWLM0Txd7CuPGGpa6IJuFkWfOcrbpCe5EOyFDRAnHn/rQR66ay/UVdJwg6GRByv1tLcqleoJNnFhoBQC5bdAgSpUVN7zto0m488qOCjHemCUSHv2FPo9zY8tDkDM23e1wQ1agYKXJEX7KHLquQdfYQWgL9eHvPpvmSL1E4nolNzDBSkDzUMxun4ugXOPk+RPQZT3EMRfiyYW19vC8RI7v5we68r1H+nj5yMlOTqIN6v5t1bC2IJF3GFbUiGmxehpP94NurLdklwioOGNLg/GjfU1Pgkztv0BDkRyVkpTW/ur2YEoIJgh8WSarIew4p5gMZ3kTXD2WFXD+WbFJfhQFkdIEId5OnEnm36YhTpRofSHoUlGlGhZF03vXDXAsqBBRp2d3uM0oN9JFnrOJv7QaDiAqX3eRR0DhHAzddh6phe2rrFtX0+ZRirs2FlKFxZlQLo2b4WMXE91vOrzhyKszg+Ou7MV6QCUvI+PJ7wYeJ2EjLhnVDoM26SANjSJ0DwrbBv5Q+tl+2AYSYorx3fLmX/Wl9nwwyHRrTor1y4m4EFYoxyMDoNZkehle3aAeqo8oLTNfWnFltukdISvc1CLIYZRYje8nCYJSfH7x9N1S8Rpmy+3pb9Qs0Gpm+YPCIUEJAZq1jXtpRzA38RLrHJ8PJuIMvLM4FBf53C+oe3hwSHMHMkajF//31pLSHAzRxS6+2oX8aDnK8NyqAUiq1VGcnCb3nQlHFAvOPln8KQu4o1PFyYh9AMeVS7pLo6Z3YcAnNlLT3/z7brl6o2lu5mf79inaMgZ9TZfsU9y0iZv3KqDboDV5Anx6aeeBgoJlOAW6wLiI/hY2/Rvy9RH6dFnuAgHpbeuBx5B9m9cdB9QWOqKBaNYyQD3OL0wRXD6dgk8fc4hjBBiKpNz1DQuBHy8T2Xx4+dLS7754Ymrtd6xy6AUMvqAnnAEa5QS3QliMQuiobfiLqarpaEWdBmTjKM00uahiz5RPmacbYqB60m2JET25jWgugRiq8z+p9W26sqMCSAIZ6V+5zhYa4ICsz4vzyI4LG8mKsLPfRZRI6gfDQgCnNHLI4jvNgZh8ao8QAw7baSjRtwzGPwmxhg7T7M40UDxkO1/VvtlKIrkHAQNXmWfodaNotl26ZfKMQAd1BS1u8yiagFWOFb9R69FYRFzcmFCVWeh/c3+JXdzZjwpNMiSsbhYqwV4tJWtNc/TcmZ5j207ad0UtSMYQGGEjwz81D8mvE/RTenVQ4SFLT8poSEtsvx1ilqse+na67xcpSjuFXL1qDXuisbUVBerWqNvGN6oBzpg8mvpVbnIc9/E30AMkeBJFRwNZSs4SyVWrJFh9bT6aybpJScbsYmDAiXJKZtUR3g8sb/axfFOLKUJFHwGBFxJ9HFn+R0MvIwRj7lqwxJXWSUvoSbywOMvXU7dNLU+4A+ZUUxiHgbFRm11IPfRxeLF6N1YXmyaRD/OtKCBCNO8Q6ZVfrEPADjVMpf/KIP653mq4XpLap31VVRt0HivZGSrk2XasCE0uPJv33Nz6x1brTrjQP/WwBvQx2g92U0I6Pz+YTJImqFwXz6pB2mmX8/HrvEmjrL5mNJx0Ms9zSR7bhYfS15roSqbcISxT8xQExiZ8sulE4tQUIiTBjrFnuz7k6EbHE3zjRYj0KevM55os82Fulz1v1fmnzpftdgRVXyILIN8PwnUBdNBtqCJ49IyXmHOeGtNwtm4blI73on5uTeLyErgUMZmiEJsmCzmjQAgFIfOp+ijg29mAmOBm1tJ63i5vkf6Es7sEayucoF0vX/oj3CExKc4SZof290DXmNEzwA6zvX6I/0TnVyYvcYU0xGTgQxSUrOFS0nbgR01T8cUA1BibQdbl1AFiKU2wG/yCKoQNlMpFQM0yyAX/jP1p/N3+GDiACkAxjkW0eunPFpu5oOZJhOv3P/NHRc1m979LuuLWWKX1KxPNpW0alfoR1wli5Da/D8rK9n9avyl4AQ+N7YLItIvulCK9YfylO9MwZhEI+1OlbRl5DHeChSZI8Jld14orgTjWzSBBYzuhqg3gjk+mEJimHfRIUFytF4ZQ/YCnkB1f2v2OiXudhaTwfvzwiqEkZ5AhqXHyM6Q2IAMzbDlGRi10iXI80svhMgaHewSx4sdk1qXPcmizm1VlLxhfukixTzK+8HVyWypdOdHq8XPNCIK7h6uGJnoljG74yQwV4RAT0AsKIity6UiHieBGsbizjZETQ9O4Nr9SJ7/B9TRKdKhpbNcQbFuf1mqezg6KEOiQNjLIBWQMI8XVjoOJhjEcfnTgrF/RVAxeGkktaKkyJyUJImERED2ADohRBi/0DJDZoAArUkj4VFioiCRQuTVU+ckch5nOlg2bfC57E+FlExFa3tSvQyTljS0nI4xG/ckN9VQTU5S4rKSrv95ZlHl1GJZISU1lw3nC3mSdDM7b/TNQtWdJ4ocs2WL6rDLIwqPne31wFYkqeWY7M7kp769oLOD28LPFxoKgTmlwt+Wk6FXDdSg+rY1FOmnQUap+6F8dO5LvgF2nW1bzzOZ+Ax5We6VRuOtsPXfxH1uH7iEu1sGU5iJWIGpkcs0Bh2w8ggUh1LQhd5BaFfjIXUS7RRZwIyRfHctw4E0ge5nHKK3S/+B2opZO1V0VuHt53WnkFYvWjYbK9L7szf36Q3Ce9lwKAT0xQnJcNsk4v5OO46yx/zk5vmM9yKIq6Ll9d5jYzBQ1VhMv17nUGHzKeNu200XnDMxPn9ONul25zQggP+wwf8STl4xcq/suC6VlHi42Xby91qQdTz7O6yvVi0EkzIas83/9Qchum5IPwYuy2wEu9M00/zhA9G9SKUjl3+c/VwVBGT1BXnhiz56d4lsGtn/8oXMXIL0Kd2KK0So0T0Slpws+Aa8pTQXdEn+oyIQrHX1Qh0sPo5Slswp0/O8yQT1W0NY51cUrM6h+4/W/JIaC18oRjexjaQA8vHIN8JzodZ+6kNXM1Iji2XOEYl2ENfO2rIjc6rW5UK1gHcDj2jtUPsJfo3DDdGXn8H5vrBquazifYj0f7cEVescex6yU2h3wxJ0qus2izBgR/p+3wzFrhBRxL2eOb1oVp6gAd/6X2IoDgPRwY6so862WBBwxPA4e+hUx99hq6HwuA6RB/eZjQdJINiWlA8X2BksRET+zgLGjb8/XyV4F6fl6P5P4Xru/VYw3yxY+Z1fRGgMBH0eAGXnHOQmQgeHqF7N/5qjeXOInZVK1f63aN+C5h7GI5rOEwV1gTe4ASWGc6L/0XAjBPVLQiBrWwOnLJmvtwFhhcOBLEZ/kjk/0vUfx45wnAQREBk5Ui6j80S36t/INjLmAuSvMrz26jeiIuqnaM8n1/HkOOFn1bzY9Xn/8u/OzDjzEhI+DV6/INfVD8pOIR4pwwHWRkF10F4g5otGzHfFxtVG99oaqD508I9dMDC5KfkqWRV0S9Nzdq75k/B+uNTzBR46kCgLkkALPlVMnMt24cF1ua5NAUrZ2LZwZXouDuLZiy3qVPJXCeKNo7xc33PHk728uaub4MR3VWM1bfNhj50DIVSraUCMA+/u+lWO42Ap4zFhaiMaVXlf5/sBfCa+1fsivXEZXlh/Ih0HbAPt12L7YeopRn+YKeJeNBTUZTBJ7KufF2RixuocyI7TY0UpOVbjjVIp13fGkbjyMCch+uIWmyZnSwyf6GQ+Qa5NBbMDlOlo4hsKHxigeJON50XTIPnE1OWk0Eea4+G/IOrfEaqW55fwbQ9zGjAQJWa0yYgvi7BOg0F9FSt+rjLd1xTQTbJW4xnScHOO7AXY4sRjQ1229k8sxw+y4L1lleIEF0/AMmRD65IVHvOyX/sAhusssGNssMbW3+VoLW+nAUTl2x2lcz26VJRXCQH7PWtECZP7Q5pIeo0cOFNzkajV+i4EWdj418+BzXcQum4n+95UQiXnJQMuZ2QnsWp9cbJkoSNlri2cFkaVazRE1QF1zIIinxOvX9K4ur2qpB3JP7vdCGt+HKmOaGZdqDZXb7kN94yRbIU6UE6G7IvouLJ/UWkkvbmTWCmTnIA8JLNvjN8yUw9MXWrVxI5sr96u4MugjfxVLj+FkCqPsfF4y6utwUSuQlsU0ELfbwh0NqAwPheQ5DgAjk2+ehqHCNS1/HiskEWpVSWlU3yC9K85DdOFnVS0nfVgd4ZP/HwtxaFpuNh0SEY5DMACOSAeDme+saSYlbzsH8LMCK2lbPWJkRPLXj35N1maSIlcTWUgs/bE+4YcxpBuY3HTTSsERL3s7Da9jbapI8TwGZIYXDM7zgNpnpRWz5i8XS23/U3fwrZKIs9cfD9msgs7d7QIpn6X/4fctRY20hCXvkn85/E7xECGkieLqW00c4EP53jf6jPmUsFW8f1MDjjcKtDwnARReh+lbspAOz3e3CtfO4DEFyr+kDPks2IzINPxslz6uyHHrdwAk5uCKpxUmU8dao0R9LmpPPN9cxC3JAGzNzrIp7h+mSPz5roEoth8uUkZlOEPFo5CaqqMEiSvSihPV/YJ3ghGFcsgLVVhbX5JPofYvYDWYE3s+v35DxEFMuWUFlLGESHsAISRr9aFDFG6sLYszu0FXjBXXpl04167pqht8kGX+i7IIhDCdmVhIvDDeOuowByHdUwmw4aQvNSJpQGao0OzyD6Q+h2FbOrG71DA3BNf7EyXTVxk7aoEANKosmE9Plj80h02koD2yvDSEyiSDE7BKDkn6A3JSWknS+O6VunEWIUvOpfxnrGlPn49VlzlLc67vPBIpUiwdS+v2fhc+jWNhGXklP3f4+23/f+fkmpW0KSEj62oa2VdSDPB85jy0EICyxhFKjT348A6KhRfx0s8VPsC1cJK2F0Unz7itIkXlJAttWprFqpyhy/jf0Y9WlSkacCkRDLt/CURVzqMfn4UWVtAhKYxPBmKgpCtGopif4NXF745kgGvedw4P4gEZpZdchIKqXMp2plxyoG+e1t8OaGFGnC0ZKG9FXEbNUbtnGXXDcNBVU5vjYCRfPT7JKwdo/peiMWz62Usq8/92gq7BClmfLBiUrnytCCH5pwbRxyQwG0JLIfGpD8fZRO6HoYkmXlGWPjQsX8BauzU+uDOf86ZOn55y0f7z2qyWukzoDBsvXenk68bBCq96Y5loiRZe229ulvofMxgISbmk5cCHwvtah7WFSS0sqoSDpyF4v6iDoHguMp5C3a2iWyf0+MsgMowSCOK3A5K31s3fVkgSyCRq3qecO053FXSqMa1HqDgxYi+QdgUusxOU1YilzCYyJklTFqMx4SSOoe6bGzACLIxUd7IoKpQDVHTfG19TXR7zjPAYd1y0rZEwg862xtD2c8wgVvBWaRvGGfhKKqDLeH2/zCj/7TtlRCtvwMflnOthcKnRIhdQm0kqK9jPbQzZ3Jd9oFAIj07D6A9+oJgEna4p1QFq4MmiNuK2dV26AzdduqOMw2NGr8fVwSG6HouPYStYyLImm1CGBPfVGIho2aB2ZxvU15zcQGQlUCXYwPn2mMLfNG1tDvrhonp4LXhn4OTgP+ES1BfM+b5ooLe7rReZhqHg2CPovY1o/CTlozAuTHb+4NWlC3QugcL5KNQHxIghvwDtXP8buJACXzY3hKOxYNgjmcTz+C1iagjGmaYQEhbhrOnxwQJc99SifWBj18aqvGgEjwIg4ojSmWUArqn5tYvsrOI9doc08W/hb+XgtTLlAWkvQ0dpP0+43+uXxAF1N57iCdJ4CMuzv0rvFFvDOD6qoL/FSubZ3AQc64tqYYsk8VgDWXZArZHUqLCj4Jpayk43bW1oe/4S1F8f0g8ZKPpyQ6YPEjiR5QSmsTACPhQ7Tom8hvtA2TgFhdAzFat8hpkax54PdX63zZnWRtXVcDi4L3NEt6H3PpvUZEw0RxnaTYAv8wNCRUVyw8WnBgQomN5JZ08AgTNvK8WWcRH4CrCPoBze11uJHIqfmgOOYAyUaYp9sVHeMEzwZTcZisQdlod8QcQa5Nm4zI/B1YyHx1liFUU+Cy0P67Lqu4DFSVDGR6lk+UmgIsQ0j0c6Uk6QYJ7AmV9iY9hytGf1DvB5pxowQl0DjBY6655RgmyQDKfLpEKpAjpMx7wWSYAUDZM7IGDX5SFK3CUVdrQZsuo10rP6mXcf6XHH2Gw7uQBAxxiVt4YQZ4hSyUIchc1+UF47ejxig62mqk4T/JVUMfi9lszFQQAd4t3/bRKGxcUy0CrQHivbWhqNleKsl3xSGBMHsUS006sUfLjGdfQ0srIzGv80wTmB2s82fSkG+KOmsHSoEwFeE8rCfdRDkw3aqh3bA8CBIpR8jKyJiGDJgPqaygcDLVsFuALg5VuUARdDHiKPCJdH0VsVbyudu1eToHuSlh/VkfPymGZsvdW9S4miokNPvQlhOdwWXfP7XJjcbHpu8B5Ien56Sx9uastVEOgJ46tIinD+XlooRTsvaHh6xqSWa7StqXhXvGwphtyihFDtYGFu6l7mIE3knw609e1EnKii8E9hcxBzAL1Zr9s6HWcFBWrARd1BxxF6veylKabf3Z8krV7St9kNYzpFQB2/PjUYdQ5ka4sMS4CNbK5TisOlUKMWL9ba4GiusCHVrFxJyPVn0MYBOHCojF+1CpJR0tb6tq4/GyiIPWNZ/H7v/olWhWZs0E8HliB8Ics5brwSiPJYmcOVAN0nlcoM8VRbnzKca2ecj379BzqXpWVpwAFsjuUm+/NjtnnkYkoZS20snAEdNaZa6lbkr96R7VW0FeqkHPhnOmIAICC5Xu2owTF1t50u06XRN9H6MSaNK1J7oO+wsDuZN21hZkr0fbn3KMjCmrtd3SVgkO4gvXj7rdezdDf3Aezn3gNkhCnNBPYdgwWDl5Ispg76pMiWZsl7DLD8UCokYq8KIQVWFdeOE+OsYCE2lHQcfPeuGJMBajor18h2HRdcbfPXhmPmOLZnm98Q4uugcoJv61bo4aVftL0DMMtYODyitQ7wtKV48JYQHm/j8wV1EDfrFTcYIpLDgDr8BAn4cpRNBRsmdU6lmKwecrITFoKQd8LWMz/tgYVaVw+p4ae4dM2l7dYwM4AyWFEU44/RTCPuV1Bu9eBqrJbdkjOuywZ3jLeZa+YZfmqwQzH4Eawe4z4i0dsQ1jTuThnwzahJao3N7PWm0Q0FUjhHIeSIbwmmoA9qnyZnxZbFcLFByGf2SudtPExvnPKEPSW92RsvVLOjjtyclJ3+nawImmeadazKOJp7tnlTL6BgXglWIM7pSP+L+wBlqMzUHVwcnnhsEuz09uoilgGeILDwivtfkMDOMCB5o6YhDeEEGwF9RcNPXcC6ksIIdrfODSgu9fogZG+/ZuqI+0JLImvBHVYisdM+rgAHpMgbrtD0ZEDdMtcb86XOTrIuSJRU9Ic+BoQA8fMcvgqaVJwEn9rjThI7ykLVRiPvXeUr2CjAu+6HaKtjCt+BEove/NhVbx7v+3y3C+UtCElQMilz+5cigaBcJ9UijNV0uEySmmFj0VgX5E5Ly8SZxYLGXoVyqBolLPLPAa82H1FmaYvsZPGl4NBv1wwFT7Yksqo0+Ft8OjiRiRuppSVyVIgt9HQaAdFqmmb53ccj7d1FVi8Z+O5G0F7fHSR8v//MX5Jvp+XkEc7jz4jvsI+SOddXK/3EZ/LimUOGLhQew03OZWGeRDCR39LyzWGuTiiiRr7C3Up662tUYcDOYGRzmkFQwkeWi1UGB+i3Y+fXpZgDW7/A9J7ajNwpincLY1qm1Ie1H79W3cu78994m74YjG5ibQyZF+ZeIUHspc6dlk8ithmIYxzJ0+iM3ZFAQrZisUgfhJMdVw79QYm5ng9Zy1VStjTDPJq7d9xn1d0/4zk7dcCdaS8DavmPeKq84qIYUCcKjkS8zgFTgfcu7iZOkd2qZ4KTN1BS41VIjb7LT/aSjSAN3ub1n0/xQFj+2Zh3GHG+/49EC3/8JcBlKjkPgou8tX4+B2p/K8EIpzuII/tajRwknGMk8pk+IlQ7PJAGhhTeQfiY1NfNdWE3nFcKm56Ioyrf4wzIGxx2NR2I0Bpxjpnn2sV0h4HoxSugeUHOGrRsyecICHi4toPGoY+Y8Hy5GKUM4MS9lNbtDrj1osPMi6S+XZdBEf+GmgEjlelfEl/LJdu4plliJFCCsTj5AbkgfKmtyPfqE+s1RefupXCjB6lxV5u+WxZdq+CPbAHiqsA+iYafYj700SUIxJeMbyeCgVrkyXk6cPH0dqQPT3EcqDlJPf2DQG7JkdDBZibBb/YpQaqlX3HzCy6oAWTiK6ZAxn6q3/RS+EdI+9s71C5fsEoUgBzxjsfzE/rXivdHns2b8+e8XHRC3pQJW2p+O8pGcMOEcm1OkkIHTQgV4D2eKFqpumIh15CUBg1emfl6K3pEHQsYP+HGI3N3L9TYcjFktFenqD+WwsPR+SqDvAWnab05aNIgCCeTCLpO3uCsUD6AhLd2425/Mhl6O4xZ6mhFYhv61pjvkSDt7ZYYKOyXoRxC4wwF3zdc6QVjHOEIgFOH/Epk0gxcVkpZyVX/C8vCaBhdqn3ynBL5u+gNF/ScSrc5cNepAnldJeJqve+qnOYF0iCV9HRt0gxAT3D9fwQkVodNyQc5vAks3pRzn78nbB2vOKGQSOyc/jbbXFNogLO2ux1UaQbekDHThA36id7YoF41Ub9WgSLyr/YyyU5uP3UgM22Fc+QwH685S7iXXWZ/7GtrVeDJ2mSzfvAYz9Bo1A5wiEDYHSenWGanexfQjG2iqjpelyt10LbIvex4L6uqqZz2UrTske/FCrGn2KItCfasPWXmdu1kbaxj+QZ7Es+u3bFd66VXKh1i1leBQ7oTnsdj9QWvNUsjD1MKsOpYJAPP6LP/6pJ/ZGVJBTYdbOFV2FEZZH9LlfS59nOG3TUF6RAB1KJ6wyLD333Dad+sCyinvv2I6H8eAbUXnN61NSDt/Mvucyjl0MPDRwv5uL2NpK7aKptIWsMkk187zySMxTTfp9JwT+5kekGQNi1BApkAbzwLz3WuP9Im0lK2z0pclu/ZXyUscsVnHtHZlibY6UvESzw469UgdJqd6pZ4UDNTpAEGZ7GkEDaCVaAc7Vx0x9uM55+jPaXYq4UV84Iw4Jg+ZVQQ5uoo0vugtsczwBGc+mhDNr8k9kPtrskRnYRRLcycDDgsNtazqiQxW3zbkND7JLyVZyRF9iTCZzRhBVIZjhVoRtFSm6ksFgCSnltQNefZzNJZgP9/fCluAznDhBtb+8yE04GEI1KynOoEeqHOCGnXACmqlmY+NwnV2BKds7y8lIaD75oz7cqT2dCcoSnKH0GqRZbe4QdGtGt5qhUhhsfJc/499QsXr0pzEpW8iL8HTAuYaHsoChL7enZzDkXquUlziWIX7xt4MPIw0PBJZe/0DsKEe4zHu647pquKYboa1EYml1t9aCpxZPGqrTIjLQXF08MUBT26TEwaTlf8dPxe3StW0GfiSdrlZjXZ1U8rmmm8NfeECCgNxwq/FDnXC3tHzFDiXAsHpcY/zaqgtaF8ffNNzierKiBbFO7at5PqDRnS1P+W0+7wqqQs9yTaqYTsIDR9ZhzdmaVmfu00fjzOwhZoj52262H9t5lqbvE8YtOlca268WbwNGqijguVKON3CB3glQjQqrmefuIAPq+EAMzAcz0FAebTMi/LpGSuJfRcn9Rb/LDJvCtafAZCg1huai5t5FsVHa0Tffh3sJl2d47TW3lv32sOltZ3gTWuo0/iPl4vgTlKfYEKtMx01Irf7pMagEFwIxs/Lb9aeX0EsqvvQgaGx3uu1KB4f8LHj48UOMGW8zM44ni6APsZkQT33TJTLTBnTKpbTZE2KZmEZp26mmjqIWf7kXQlyqhUOAIQ4MAbCMM+imZKC2d36WzAV/oauOEmpGB+ealC5qq/hR/OJLcXwsdWvetoIeJc5t6yqxX2ZH5b1c+KWG1BDE3NZTJlHT6+xa+3JQm277f41CssN4qRfJRRGZ7onQe2hdnQ9s0EzmYUCjQ9Tc0U9Qk4teDjAdC8v2aVwt73M0NixyHMAqKieQtfJXPUMQjjRnGlOGMIu31emZzIoKYwa+LIT+Bboeg5tx+QfbjiZ7J9AX3esVylLh8xNFMPKCqjIBdA4NHq8OBwgdeJbc8+E4yk7kX9ZweI0Qcl+2zn2MUzgPeJyxsd141OJN8Apgj/zLPhfYoo9uiCKYIzYUfszlLMnEsweWilkOr29pINSSLpFHGid9po8cqW6QyV7Jp7RY4oTAOuureFxVURTkFMoudx5D0cK1oy8Tf9SJ5qTvybM+HXaU9N7teHSdG9PSCZzGs1FpdbW/GrZu09pTV6JOZh0atuls9UGgu3MUDVlq8HrczRxa+SOQqWwE2X1W02J6umV7yKQY9FfgTCzHqLBCHA7AKZfex1FF4xONLI0d9jCwd4x4v0gO8C5aK5nA6tjvCtP/+Ui9V3aWw3jIxQ++e3Q2AINQrXqliHaxPJppUWK5vOUFgIY25UkQGKqBdU5f8ItTpV895RnZzwHaGQYOS796sC80eDDN7UTVQaTAkozbMIzn0xTzJnAVbm2n91hMeujwb9Q/7Jaaq6zDasLmUndX66pP+N2BpTnCBOjQLxjm1UvGSmHqjTCyh77w7KMV+Wk8QkRFk3/MfkS49uUQyfuHnQeyxznw1G6knlv31je+bFKwVithOnk30/H7fv4u5IZ11FkFwxlEhmr/JAw2s3+/tYGcnzjbg84lGVG7BY5bOxg54L76C3LBKVwquOessIp7XYDhzypHr+8oRTDb4qMTCuKM+FU2RLREMPB+eZIqdd3EYTAcKcFONGejkqEr6xJ+rL2Dn/OniN8DC+jt0DgaCdkFyK6W4xPunn9+Bn/K4SMfgu/z222ZFMbvTp1QWfAKW+KgkBh//270kBJEM479CXkAIh7EMZQOeDDhu4zqSa3iTqYYoxkzIpGOEr91tQUeSqhTSb5CR8mFBadV/rtTUDqP5Tr6TQVEY3pc5D9ushlzMifNIvmJN/XRhxUYuzhRBpxPbSiDLKx/nywd/agjYZYVgaCRb1X/SbQysOVpGCz5zEkGnXhrxDUBHaJEF8d2FQkfhoyrKdwu0q9Q1D8VGiBjpTeXq5QnTvIMPNBvgLILyOEzgj28KdMCRK8FjtXKErqkq0kByVcCvSH38oSQwc51CnpgsKbIUSqxYOzTKaDeSCvDrkUGPn4Yvlf7bLwPIn+NKKX10AaVveIZt3FnAEqCou29NwAO5axhMXlu6ZxpJx2XNzOziYnNVetx+q9970JHKEidid5fAnh0GCXDX/FlfX2BCuKZDbhyZNALy/X3CxkYWfp4YjTiBxog4eTuc7dw5oppJDz133k/L+Vg1i9VO3h+IYXOzlbU7yQU4bdHXWTwEWQzAi5UEhkGbDEve8LWP3DNZ4pbkTvB8s9pLdRAFCgciSf5Qa33nd5C0xg2wit6eWbLjCIXdsoOrjntgfjBCauNsVSm/GrsRLyPhlFkbFP7GOzSnf8Q67yZOGylTrwt+zgzLrBTXcodBIG2j2wV/G8ElosqVzSMhlYVFg3Xm7yIvzQc9GF4T4mwgukfZogkwJP3zF4Py7ZCbBaREMMLkvnAtKFdGAQdU1LmTxOXhVvB5vvXtz0TwFZQFI2vCLXj9a8vaFzUUtzv6PBCzfPXNMJcCTeIZCtNvLHhVGwqZnBfxxqvPOFC2Gj509dp8pxeJmgyJmIRWl+ErDntqTAC8+c4c4Npp0PVT0wAQZfVxe/FMp13Eae1TtMXQYRrB7rUkljcfxsvk1G15fr1+yaC3DiG1N3j/NxQV2+VWwtH7QbmnjRNGejcW1MJBU9I51Duhavz2AyHd3LZlBHeYTscVM0mpui22GWF2uGGy1WRQaxB0VcxYQu7HuRQS2ClBtvQ4C2WwZmRzv+VbnhSKodG8kZw85vzup1JtKxf6kW32wlEwbQOPEFZ6bq3JYtwmQzJwt2g9VL/l2nHQYuG93Nba4fskzJV08lpNZopUCvG/RpLpj7edhH2TTP6Ip0YwdfHOVW9SPktRegktRjrTMJ3C4fTYVhU+/TjLieUk2d6nJMnFc4dr77lu3KCUn4bnUmDn25LT+FiIiNiINbbT5QSAGS27NBduQFbfTJDj6RdNN/Nu4SlB2A5mPxRKVIsHsnHcheSgt9frbDrTc6bpLv2/4pYhLt6UZoEo9Qpg7Xe2iwqt+MxGDDcywDV8msF3QxkuVNTEbrOmpLT85SoXnhOrgINUcjwvJdM2YPCn5GVEYnhzJkUK/xtFVfPXxHr7j10AZM3CRgAut9azzCjHxJpBlB2TZCygNrrmJ8ZqskxplMJnt9UOlWt8EdDSpgICxmG2etCdkT4VQL5KFNzs/OaCbXujHxHDgYCDxrg1xVo6cELHGMRJ7mi2Y1nDReGXoQSgIF2vHN+1ibCkUSvjlfGfkXQELxoDQ6yib5yUvGs7Ucg0cTbGG9s/FlfBsIkzNzdY/ILqohrGhWJWbpBYcpGLbl42Sg2ppjnnPmqpMx5Czvr5qbCymy/q4lhBEQ+HMGOPHTw96BPTbIVwfJ2EcejyS9RNzpmxwygYNzqO63mI7HUOEoTlpr9zEAG9jWwAW0JvRkViip6gNJotNasBOy1XabL0Ph4U01afdsLV/TOUyM3Zgbr72m0nQ57c3W1uwBDDkQSpzzVu871D8II8b7P+xwVr8Ia2Mk+NmqQJqwRthvtUmX8Izj2l6ESrXopuWsHt1dSYWJlMEKRpCctY64n15lygGTmiGwKCRWphoqHJqQrk5ybc2WMDPCiwPekqAT0s0QpTHxRc1vjnPquZcsN89NeakLVj2sFrLCjDfhtvygu5P8BMrE49aSwy7d4jkq89LH57riU1oRYIXzhVLb4INeqR5COn8h7LLXYP1bUSVT1Bs/HQpgIireWjiGNSTw40HUKtVK62N+s+RRLVvEfmr67ldgISCz7JaFJnuHGPjfEW8TWtQA/lgMEm+meAZuCOvi4VxwN5ZsWeRbSjDbjVGwirOcRDDOdpF+q+xRQ6bdks/IhyeCSx7+SrYr2cMwj4v5N4COGoA5/5TpA5XoOL6sKssarYvX/EPyRdGh4NR4ET3+NlTuDUv/VCaElNbrwAPjacD6wG0z/93nEAoYxWQSP6/L76QsGpWBKfhCV+S8kBcFXwWO8PSJF3NrhPWymCInh95HovopUcbuX2OQtYS0B433HQebx2dxZUfkHRTGv4RiWmDUtLgJL7f84/931L2OvCgzNmX46hV2UD46jxVeYVklLJd/yGRD8GgCEIbWSLRMujn4nbKKrneKIE+HZLn1H2sZoRq/PFl4gZxrOcftn07XAMpa9qj+8z2UgRj/EfGAIIOvDblG+YSLnu0q4IuqYj9fPUB0uAZDKBlkqqIaZ9w8eMzmukZH9Gk8HEWWb4VfqseP4zmNbjnBztLtg+KtxGauFpcBN+YvI2PFQyJnvLqh2MfGMTHubFDbG3RxDr8KnjNq0MzoWbaFMAr7de+piCn/QHt+tuLS7+7nu2DupTRVH51m+awLsZrxhD71JzWiqRgdfbL51Q/27UEgYKgFKy5dzbeurF/PWY/Gr+nkozAODW0tD4p3ugWPuLEsoyRBbXtIVA69idMuRz5YjQrT0om5ayQxmS94+Lxi1i3lOVPxtkjF6jiNfK4RI1wZcRXK17C4ga7XhTshTwogLE/vHQp5h9cvpHeJWSYcR9BgW8q3bzd0gDkhehg3tGsGl4Z1lBivfrOc5qmmhpvQFcbUICqVO+uqviZyBnVQJPUzLEnxHyaP2SOdj1JpOIQg5X6z8edxj+KiE6+zZC6fxkJNbjde7OqiLGC/VUmbv0E33SZvXVP0pRFMLqod9LbeK3QuKAXdkXeG/vTx6lQH3y6ahCJWsGhZ6H5RDMeXc8e8fbGEmYUrPwvVai9/o4o4OAWV1m/IVlT2Dm8UeF8AC6oyUSFZGU1kJxGpmV4zp38rYjXKvm0QnaL7PCVT9TKkWVZgZdFWyHsSKlPPzecHhjfAYvb7fCAeQ1zEwhi4xMxUMhxhH8B4W9KTFYGKftPvFu0E3k2iWUbaqj4H8ATDwGYS48P5z3kv1JOsD6LKGA2icWvK8ka3iaqpQsamkxmppzNl1gjisW8EAKH15LoI43W0LbyN7KWIZmhyTN/Fd2kRIRZRsPOc4Zn3khJZu2WbwCyzQYfW82WrnzxnkFs65j7tke09GOibp9WuUlYNFvDT/OHIRXtQtcn0wEHSSZvCjIqIgvZJN3H2WBD6A4TY84k1LBObFSkTHgyWJftbmHKwyMB6F+wB5gRiFZoq7iQ2irOvj6j3r/i/PO2XP/6YsnkSiBdJ3+jlc7coPwAF8WsvPhuLwkdu+D0uRUJo3J6jki+369BTiEEII8lInHWgnpvuT44YMos8ckIEzg1sa8hoZhzfGQ7zR2thLAYj9ZCXPpIHSQc4APS8l5oqzKz/Ip2eDq/Rha4XLzfyGaoJ37mjYmez+0SV1ziaqlUfGU4FWWPFYJAEoicVONOrOxyDEZXKT3iOZZU+1XsS/rkQOljV7K6Qz02wB823j0lHy0MaC3XyVVFgBgfKtqJ0J4BXafrjF5/itd2QwNJKiyVE1FR1PCbmyKkwGxyqqNsGLD+PT6Trbb2XU8ZPizt8VkolyNY7cVRDnLSuK4cpDlyEQtPM5F5t3IvKns9taRXg5wrEOVgI+geEvCamGZ6wTr7R4kT7KH0kuEZ+mIa3m6xjgiuvzB3lRKrj9zvoktXugU9w9Fwt53rmDlnzZFrKvjUU6LzfpuUYB8Za63CpMQ8lGk8IyteQnXCG5HKQ3XIlUu0O3vdhaGojH9xDGe7trbYpwp838h+ZgBjcptWiOc0oflM0bmd0pXoqbsE7Q8O01+0sEukp3EfYx4qoKjHRljmmA1SSyrRQcTL0QTMJbzm4GIy9J1gnGs7GkhejVPyV4yz6fULL2+BS+YqkU7oHXgLp0w5c6YRXJwEcRO+19yhVBxTnXz6SHqh0GkhootuBka6oZ2YCfbFvqsui0bPBz/j9ySqVSjuiYLH/GFecxRoXK4Mt0r5vLulqVxEfyoNn+q/BWrl7+CD5xVydh4GTBWq97osig7+xrQDnjXFIwxoUP55e/Wv7Yen3fLKlcpAgMLlV0wk0OvrKHVuxeThLHoefGuTfv30UQU6jEMJXJFX4ff/GvQlmyQRbpaHaZxEm8WNSFbM8qgpchO/+OXdnVLieij35m+pF0fx1USJi1etR15fAsDlBU2oNl7TYW7s6L4yehsvMcYWD34XEC3fSM+9vSWHI47CS/H5vfgVg7Tcb1SDFZ5+qNlD8AdS+RtoglJ9CLwzi3/a/tVaeFsarq25ZPgIIfcZIA96qP/DJRLKslQx66tJn1nxJFQCbumIzQpQ62/un2rj+K9ImEHG9rojmCV3yQ3ch1hCbcRQnrfn/97CIWZL9tyHbPMuHrFyCCIVlU0WJ2FduMx49lhNhrbreIXj3cdo+PFM6Nh/oz+f4NBuScEEEEI2qiBBEZuLnDZXIwkg8L6ZHd2tJ6AcnNAGa8n5L0i4CwemAzANa6YeCi2XzTVeOjqnFoTbobzjOsixRPEfpSACwCsmK0R7XTFzjrMnF52aorUJn4/GiP99BzkWlkkJa5bE+5tFcMeL5bj6GGs5m2diibEXQg3eXEchu8WPBu9ljVmg3SNiFitU1FNOhykBlXho3QlLqYhHlPmh5ja1Lw1J6aZZ24YBZHohNfHvr7wjnaQ5o3+s8E8aW+j4WWvQMXSNkZXIMwKDGE8L+31IcF5x0As1Kd0TVqWrQtHt21nSwhyFGf+nJZkOF2R+yutgpcxKYBhAKDI3RbmQsDJHQeV9VSKyvAI/v+AmdKdGrnVtSRejsd4YtnzikciIFgK5dak8/VGmr6VfWCsQKwLVL39JRPGE7mf95EV4oOtfJPWv1V4WnUM4b4tLimTflluqpO77lNP4ImuUyvIYFxysdFjIi7XODoZQHnU5Qh2QQ+Zig1Ls7bjGygj/QBDKLJYEdXVzD8owrilLsTDhJuH1FVIh9ZmMy+T9mQ0nzr00kp1vclP6hH8xFjm6bfdFBJr3c5lNBHa0R/aj1GFNn4Vupz9C0Kan9ijm+fUzDq1eYFHn3NpnKBU12sFM2fGFTaHoLJ5dwYOPXtJxu5hjQNmqL0fcLZDe3A8not5wtlgduNZw78L3fykTo4uF6JZWu/Hzo46CEHfdDboQRi6+TqOy9yv+I9K3I7/yAJPquxSBgkw6/bLH2J2hL/dRHLRNo3CdLy9bbF+6F2l99jxkNTWIs83rgwJoVOpvxo7PkxAabA1UY9KBp01BA7N/vnuG9TZPLacVJPrLlEkRGTCPK3bxWlN6KUuW0vl7GVscFoYQ5vinlqNon/z86vZPOIrWi2nouUnwj9FW64CZbY4SCBDBiWqlxGaOPdjHEhwPT7qiFYNTnQhLMCj9Ri5lW5rbSKG5IUp9ezMw2qmuV/NtJ0vtPgogn9pE03A8w215Q88wDZ+C2OI/0FXAENhGkabcBF5DztFZ5k+P7l0LZqaK/HSSBr2yN16hZUab5KMM92DPpa9NaJx595W1bfG+uzxlPjVcLzy0VGdnZT5ecQvoc6Ix53t2Q7yvJjBX6X2/2sCBsK/W1jLNM1SPIVPdIvf30dqNtAwNQe3/80BpO+GgXAMuqk1A/lbcX412Vb/DRSb0mA+gKjHmMz+kN+0Iy6FdQDJft3bt0ZbN9yNk91SCXZ2Eny/cJ5GLx5KCimRnFr6Vme9Qtt6jLbJpkmsaip/VrU35xZKCu4LAnFTrmYZK8arAfD/euqLQB5pkN/t/bSyD2NNTU1S/LvdklG4DWjrTRNS+zSstdayQO1nSDhElnpYpIp0wnhQLb6C9DKsUFW5wOktD2oi0kBRuZlRjFdnQlKzmxlybIE9389qGeZf0T/3C1aIUyv9EkklbtP5bvVzCQ+jVfKeNahg55GiaDYrJ70jOaeQgHkry8P1wF5yRRkbSxdUoRYrwAi0FpsTL/CR9EyFULFW7Dhk0b8r7LD0DkM/yJVSsfb+uxxwS4ZobWZaD1il1S7Tl/3uSr9JBHkk+ubnpe8ks2cAv/SAxkijn1ZSbbBA2iL5erkuWHn9rRvi2SoBOA+a6O7GXfxvnXyYwj+yWOwsOeW0CnaXpgFnFKbCakEox5lkL37bIubfRfUZGPvx4s3e1PWM6Bohn5TPym8P2JXy84ZV1coY5u8QS3uzhC/RUgZ5ScT24GLuuzRlHCjWBogdX5J5uhAGyQRjd0lAGFH1lKfQ4z1k6IkYiS9dCx54HVRf8N9nXbkI88zbbCYAGd8pAnMCa2gKWToUlB+vNLxGriVg2QhgbKwfndgUYbRMjUNU+XWYgmSQor+Q38gvWoZiTKUfV2c57Dqbg0tyqGvte/GasIH6g9zCg2QX1tjeJ/QDv9t25cbOURyHZIEWfDwuhazp8d1xNDqjV8v1aakFqoCnjeFAwwZmi8o4Kn5splhCBgy2GKHMh8Yy4ZUwR9FXk3SGH9WUprQh7r58hA1FYadbgh3WW3hOrB66Y3WykXd5klKnTK6q7CQ+RkPO6JE21VEBkFsBXf5V8d+1Zm40nYM/ymkVZjtG8avfSqPlWHbPxHr09r/vpjzlSWG0WNE2JZ6dw0c5IUE7vevexLYGi1a2DXU0OcHVlnkexXCAY6ISuhUqkxhAAUAN7whnBKTYTu5vYeXew4o1DjPIBQaFRhFAuljhOGM0WvhmD5/k+6cpjL4JDT4Ik7l4Rrf4hWCJ2mWh1EP9LkND7MmEN5WaW58RS0il6YnzAOvhPerYYNUyjEBZWgZH6gl0KUH7PW3hDqJO8U1h6n+wVy9EsjdZfjAO1cmbkxgok/6SvG0YeZsJkJLi8ZWPfxCS5jrsGG3gFoLXDZGZNiMNL+ItlxIXixMcLTZjxmW+Ogia7TaYaNOfJbAUzXUaW1DyUtoLhmi+TetYk+oXBVO0SqsstKUCQeIAArKOqTR4Q2vHL5nba2zNbOsCtNmQZsGjXCCLGH/IK8jB7muVkiAVkXKRbm1oEd6y8wNYMHr+CxvgoCbz8ZzVjL4vVRu0zap0dTiieS/4MBQmTIrcBrBiPeA4kVcW0af32TViLPIP874uLQG5Gj6S378bSrdPVjyS7LDe4GwFXqbEjF/AO96BBsjFNrEqY2lWXJJ46WsBF6tbzSc01TFlEd1ANBQsNFFkUrU3a8cVQ6mM/7LM+puFHfyo7wfsdaP1tfMvw4sKjfLKzotKKThMEZazxUkFN8fa+xDEKCeTebuXRcifft0Tqr6FUmRWov8v1s1GLEhWVcALDytOCKvSqp28jsSQ0DbyWiYGhtSOv2m3pGhk9aPezetrs5Wua29AVMjN1pF+D+4RZiffUumhdPM7xraMELQ39lhDe6xqhH+SQPLQSFKNetxOAHGOr39I0JBPz2NUZvZsaarl8u8npJfUxs/bJ3B5cvYtQP+sADTWlpQjNMXL/pPKREW78IQpCjfZIkpwRY5DtDEOSSfmVlU5kMtquYASfaR6FL2s55DpYbiy08rTuUIq/TcwyCXfvHTUnUxqbu0F/vCdPuDzHSaZsXJ2voVYxijD0qP2l0ggeQKnwEiS7UfHkuJVtkoYzgUYvb8419diUpDvzb5RzSDmdF8RFsIYrxIy8l8uKM3nXcAuw6R5tLQSC9Y4NCWPFP6A++zmSu9LTTNyS8mrV4Y6ICAHRj06kI5Yg4cWw2V+UJWweOkbIB/VO86TJ2oLHerl1vV4jYx/lxD4MR/rqk5tDxgS3/heQcz4YQLgap53ovNJdMbHpGwQweVZX6xo85DEvi4Q7rZ4y6RF0mGl9VaV2aPXiFjHbWy8/fTnDjKj80b4z63PnVdaCz+KFKv4OTBf54rJwo39vyKlHW2xgAefpESwXcWuU+RDHkB8T2YkCaqxdDtxGqor21poU9HuRg3njlVlKoFU64RPFI2G/m1PB2SGymQQ+Teb9JiS3PgngvLDgwoRaQ1Tz21+M7SWGPh+uFDzcHGIbnTQnOEO6vhx5dDXRtRqosX4VxBEwpcuoRngO/bMwHXDGdfpuhG9ZXJ1XHr+kMJpO2wVLr726BSFJWOEzkJwpexwooj1DzwJ0wVkaFak2+EgDjH2GWOHQ1pIOtrt2X5y8FZdVW5Zhig7vSiOBvpWiEeslq6Tswi/bH/B3I1rTMYSuixljaPk1ADaiQQ5qg5ab3iMWgimfJIfIw5K0NsJ/1Nc0+v9FyftX9MYa0fXunnk//zUoDKtIGyHPD0lDPB7CGTVbp20VC0dLULoRfn4UtQwIPmBZiM5/Mf36aGhTvbboRDXvX0xowuFTp+m9ZnqeqpnaQFRSKNcdLKlVsgoEo9C2GgGZAoFZMFIXAKAmSN3+SPFj1IGXpXE98/3L6fb/sG2jtn/nGhS6LBVbDjFUJW94QKbfRcFf2ORHVVs0C9cd64C4v4dmahy6dphewA0yOY+x9hJi9pHh91tSkzgBvv++mSb7OT67jyfoWpTztdTT0HLpiJCX7BKmjJ6i3iuSCJBTGgEhQzZ+MgMGNEQfdWkSN1f4RgY25trJN9j18omJQCW9FJRITpw3YLnn7hcyAru8HLnaWa7wPyf7fSCxKVXhmb6cIIsrenMQwgxlBXMH9O9gGxR5QqcFx25xyYFwXa8o238y7RHt0OB8wNkhESvwLhPdudHT8L6HQiR0ocEuv+7fwf8I7ks6SqAzja4/OMUzVGfUwIuwAzR9pc+29bxdRPGb01ck7yioZbN53Hij3jDdxH/LN1lLCx8Cx88L8SQZ3QxIpzTYIz20Sp5xLUDgWiTTHKiMlM6O+HAs5WXOzDss3XenhwaqHAHmZILqQIs4EvNd7ebwoGQRbKVl13bSd5szaBECUrLBlDUueSuSB3ai9r/vZt3eODxY8aElND2EWkCIN8yOnBXeD4PUX+0qzoVIDUpDJhJEH150rfWNp/uX64hP0ITrc4Mh6+0p/qc9aJX/vjqnQmGNL7Xj6xI4GMSJUwonUlbiZEGfOaSTfHUBMCHA898fuJ/SukS6M/oUgVC4rrwwzHJLECV6TyHT1ZECypKASJYHNfWWaA6DXfe/gsscqqxW8hp+Xaq60RodNEE2KyiLBMRTjuFzyk3faE3lF+hqtLozJiiKcPykYgxQCyi2aQnd5Ktb3H6l74Q3tZlqo6c7I3CjUJdQ8PYHJhAaXvZ5Y+ISckoY9FhGAER7h01Y/1gfVHpOo2yNQgpt7ZTarw4pQN9joReGEo+8RbA7KbzHGL1ETeT/lb7LHSqAoymnR7xtLw5+Y+KKVIiD8iENpc+lhdGV8pQe9v298pMCVXxzZtMuZ795cdiZ1D9dkni6UNmiP/KNE8Ipn+/VW9EyCjjp0IL4TQXYN65cdVoItoG3YSle0nHnpkE8rl1YiIZOMMmkjtiVy66hiTNAPIXtpddH1eb/RDDur23/rPAAPCsYg4WBmCdfthNDx50i+eIJGIwJZSK2KvBnAwjiKO3DbiJXj93EYyz0VAzQdP9wb/auoRl4M7379yI3ptOe5etMG7uVdMYsdgSyrU7E6KTi0iu4Al8JsccaTPH9tnyrMrZjbZa3T/bpOfLKzo9spYMgCBue1CyqKODHjy6411I2QTuF4hjbSiGNIvkMHh7cGwmYw2AS6ubZHS8OUNxdBNfhjJ9UMNZtP1lsFhovlGopTF8iw4rFMcrxPHv06qE1CuzhNMlgoVwpotkWLuEXQZyQ4/Iltv5MhYzh9JELsrDfN8XTSIqMG1WwG+J18g5MOLUdYtZvYxERy7CVfEnc8AhOCfsEkcsd3mLOV3qB8OYfsUuBl2ldCJY184fyaXck4r49fAbR/E5qcz5fIMQaIY8Qcr06ZwidCWUdGRBhkDwwwxofGkm+hruRJFsOytO5sPPOq+7n1hY7+zEMubHdLYLjiXZ6ySPMB9MWyZ1HN37kcpQmgzg3QgMWa5wLdxc4iNkxU015y5a79V0YpPnnACk8YemqLHpyWKsR6p9G4CMtUe5kgFpwpr7UbTxGHDorKtR/xcI2gNdEB8gj0JKnZML47XKkjytNO/TznClflnZmTh9zQYgxVl1eeOYnXIzLbdsdvltAZpAPyYn+IGxaFPGQUqOWpW3Nly/CfDepV635fVMB+3BS8bLb+O+oQ/W31+nseMQCMxL4lgL+W5D3Ef7Iai8I5yOfX+p3MBGbkbg7Qi9cvyZgtdyV7brlu0W7O4AwaM5EGD8dMMOqOCcjt8hrvXWQmWxc6/VsIcfd0IeTHS40p5WrGy0O+WuSIu3Haqgu1cVlI20Xa5lwmAOI9ozlJ4VH14O0Q8TutIyPPgXNsY6xnmfeyHaiqlX2K8uZedk3Q8KTcOHZeLws/0cwsA8FcT4IWlMX7Zu9PKcp189qyI1q+HRxGq0EH62/mJ3MLXfWgdSGLNs1ICQha1Ms29ac5BiHlk90i9bYGmQuGTlwpcS8+fWgJhlJN3MocotZ/hvB3ANzW9pQZKNsXBHYPSdm9rhcerdYk4XxhhMqw5A/BAvYMuXCCZi9zX278cTUvB0mapowawkx8qLB2QCqRs4c43jvYECTnD9zS3MnmHYbuJlpswjQgr5Qe7XprmeGPXUROJVAEt62MT8btNSgOE56Ivzt8wU9NnBCX0cnZ+8g3jatzO/JmaAp7JCHeKSiO6/Op5vw2FvTjfAXQdzXuDA80BzV8fhRsb9VambnGn3JFdOIpLm7ES+IggfvBqK8a5N15JbN0P5LxH1dYy3oWUsucjKUX+DGkLHpomnfghYmjj1o2KjnUrXxvAlXkcAfn8PRJVH8/pOe59cr0zFnnVZAaBiURfh0Ufg78jbltaIggp6/yuGFTjsxqgqibQLXMJD+GlDNlLqpqsTVC+IGqcEYrUo7I872AsrVHG7zEebk/bxTspdhDqXoB33gcMbPgX48h3ArxhUUisJkYRxXha4MAPUhmRl+SkGOuHGQ1qyEsIyq9AXZIDE5ikzf6IRQMdm+IhU1DBkB6Mr7LsMofHVkmVaOkE4WcYb0C0H3HWLRcKGrheiBy8KJ+0eUvu9KO/dlyHHXt7Fs1Zh1St3BNyk4L4JjQDHMw3V/0uz/iq7gVfswRY6uAF3XqGTbLgrNbDbZJc2U209kmu7ymE+QYrCCMsR8ex0FFhgAbtluZzTobzSN8tCBCW5ZjoxEEeJWn0rvASkF0ohXJVwLhAj2WOE8RuAA/tSIaCBs2P9Ggf5nf3Xx4bLyJg9GJrOgMf3pEd/YETlMT1fh7jS6rOvg8UQZQ3b0GbF8pCyNDgcLAWqdOmwaL1skdcYGhrfalzM9ewPF7NbUIoFCJ/nHQjsnK9bGsZNiU93LxRbn+JpbUon3rFJrKXE2HKwRc8ebsUVKYfYJwZL/WpxXemQmPMTqJ2TkkNYVfgcSrfQKnuubNMeVq/PldeNJ97iaCtrI1Chhm6nYEVwtw5hdTxHOUYxrUJtsCLOf8ntPWISirhelnCEl+5o8v5t4kAXn3SYCqOXc0TwrE96HgChj+DtsiToGiiDZrdhRkNXpkGXXJUnNmd9pv4fHI+aaSBva3ryW+HANd+iM5f24xEj3lY/u4FrdwumeQs+EdK0t2zECqZ4Vfnh2pQ8BoYfTIyb25vVwkKLns50eF2ADkIv8R0v7zvN3R/n52TBy41xNUNQwJI9q++1hj12MjorwW5PrfLpdarwjPhHvSsALv5u7DfILKWa/jWqSMzylUba3XXl4S3iobTWhdQBX11ywwbA7E0+kNn1ZUrWS3hAK91oXX/dHTnqm2DxTcM7FBme42AAKVD72INPnmsJpdlX5sKv1/7qYYwysTeMPF8rsyQ0JiSYn7sMtwiWPO3XeMOgnWQ2v/NZ/fVvlB1Tp9fYBtnJZ2tqFG6WrTZ3TgtHuMVXQkTDYFJLe1dgnVCsBv3jGT//5Koco6oUycuPjnmSwEYjlQLIPVX9aPdItAWjIPodpLlZEtlc/paROP6O5AB5Y75KbvTyHLtEVoRaDS9Faiw7fWN6eN4AaFs4kbt35l17n6Y4mJLBsTLOH4j+f5g5HZm91PTgEoU/x0dhce6B88W3HcQqiI+Rt9+iaiPiJbtV3BGX1bUgGs3i+kmyNd09tbftEYK5Vud/gwV/PRJLk8LAJXCzFlgUWQpoUVgiRqhK7f2pLawkcImy9J+lZvXTkLoshKkQlDwNJVMSXUruRxTxIG+nq55AOmvkVb1or5MoBqCg491HNEu8olJAj5Wk9UAgpWqNx5p6bGqtVH4TB8HkNuean2dH9/MJLOlZgKemfArOKcW07wiFud7zJkeNDOWBJT80xqONBLoIPiiEbzpL05W3/sDIhv2C14s7CTfuzthiqD3G4XqnaXEsXI9xZrV54+8mP3TLK866THaDfI1nkHtK6/+lUYmpjze6Yq7iyq1s8tDDv4H1mx9vmB23vhJCrfTIV8rJQbj/dVlyQn5W0+yWYQOliY8MCHysT9OhddyQfBDGSvxnBG2Pw+8KBPcGjctp7Zyrs80GMNKLm2Kn2cH0aPN4LTzlKfxnWQoeuSwnRurJ/KiezGcj35/5RmmTCdDOb/pPh+SdLOf5qA0ICWPVhSu8M6UjRphe5gb+73pNYB7gEaCQDNZqWkRrVoT7M6y0ILDeiJppChOImZDeYU1Nq6/ge3cLlPFzTj9IXL1D38JyNMIBudASq7ascZOvGYH2AAr+JNDRdGphuqOHege5o1An3TyogW7ZlfHK/TfT/MjZItQtImlD0hl6O7gDrEW3CIerwDAwaOE0ELEtczr5S+5CNLl4MhfQsXrL8aQRGjUbQ/vACAGUgrkuY7pMTkk+92WRlBZz9EBarK2CYAsga16r4gEWa8G2RdtZ2orh5++QmBbReMxyI1bMkAJibdmXx1wtfelC8Wg+8TCsSBgAaVts2uzrVl3w5UNUiYqKe0+EI0y+NiQZ+jXZREbtSJE0CFGZsVNLvq6oFGjfA2gF5r568sf1n6s4bzwDv+TmKUkrj29wqZ9cLYlRVuR8eGIerzW6UNbLgsNM9Mmbve8zoFWVOtoeIF926cPEbBOCKDBr3IuSSRkYhg1slIp3d6e+Wr06BkWV008zm4e90aROo4l0E/2VFQv5gixNJZKj9VekhSl6mQXU2T3DI2BHsN1Mflq71zMrMQs3UXswwbSv3T7BMwRmNzByyU9uhiWNgCpVojHsd5/lJv+IZWgdRGjK3tllITxI6MhGi4PK494AhEiQl4zzauokKvFaPlV5ML/zu/3M7tQ3EvCkYkq/N0JGOaLzNsi/89cxeNsTtYjbgQr8PGW5a+dtPKa+emsNr9/oViVu1v5OOVmZsSB4BPpx3v9rA3JrCuuD3uFOonD3SDkZZoyU1nnGFRyHpB9F5NPTQYXTb3FZtchFfqLr+SvKLw6ugXoQ+/sjQq63WAB9a4encsY49d7bwD9gW9qYZSQ30MbIGho8xqrA9Z8Q1GqOfC8FdnxGcGbOyjVqGNef7G0XEM2kklQE595ASvr90Z8DCIG3ytaUu+YKTH+efnCZJJRfZR78d4DXupz4Njo7GLsk7a1mZCLQYIFPikYZ5heNZz7c8UI5Doer6H/3pn1Igy+c3U0FxbP/ln/EH4I026vfy8v6mUI2hPWWh/h2mvjtDb+pqAAt10dSXJf457VUx6KmRhW2z6+TS4Ht+1EhHevG4x2crYk1v2orHhtQA4L5JlGQakfb1QPQTjrcoUkSoD7PRXw4bB2TX8Ek6FWd8uFusqxv92+zdzwrGyVkr5PKfePM56fbbN8oVZqIcqVim9+Y+6vM1K45iQuA3eQ7n/Edk/t/hzcHCtRBTM41WBbzPXxPdWf039HgznN7qblwOSo6xgWFz+E+nRaQMTCXAtow34pOci96sHEOVaO6BfsTJ+T+l3MBqOeA257b9AUS50OnQlB/MRIwke7BPgZqhVDPyOBEQiaT4kc/UHecoXlNqEQFrXJrmKPJU7RnZxfemYqhDmw242Xu9jm+RnQjXublv6vzn55gkI/2ZiPTa4qOr7NVF/eofZTmuilvEfsjRidVYO+2BgmCFzLQu6vBNRuo5OHmcd5/pdHyhFQnAeUPKifGGL/bN2XYvUNBtgDus9ruyAVD+zZfryJI8f/SXhihB3CHQMfj91dDjS0aXo8TbOyVm1kbv8fxzSWuKXS1DvRU1CQB5vnC7UtXTMWOi/9TaAVwURYOyyYeYH7lljLfdZ8kSGA0J+bv/wWo8OkfWIv6sD7k8ZBjQoAUmBD23EO9jkP6Wty2PY21QSdfgCXfIZWbJEpYlCsBuqvEwUcKEqUUjLRjIIbWW0mimgfq4g/80Zrhsxzs7/JHRq7Wu5KRLRdsNt1WVghd2EMgxI100a+rZvFI0Xb6oqQ1QUkokWvdJi1WrhfIob8BPqyiA7tVp7vhIehg+cPxLeo1+wfK6Kqop7z3Lmw+AmJhS8fTysaO7/b4WeBAllvDb44dYxIXlYoaet0Yf5A8AmMm0XLS8oJkRkQksCoqRdYjHxn2q5UvpufRzDMfwuWLDN7WBILF10+y0MokMKyhMAfp+uzSIgavVM8t7m7EqLSztfqyL76S8u3caIJ7D8rPtE4rayQZwk5r9iZMHQQOtDLu7cmbV3f7dstK0Di3qjUhalSwES1lIegouJKFHASsH3k7wFXi/qfN5mrKOlQefqxDGUD1WecXa97wAis9W4R+cYq0KpwpMiNKUxTKhtazHBlIBXOZxFWFMZHWshTv+ELLKSVCi/M4Q1r7nk4r/cTIMDfCddPwaWWN6pnsgoXXgcRApm5wkBoV5LnaOpfN55lZ/F5qmYYffMLQBehvu2anVUbtHJV7nNny+bEfK1Y2JI8WAtySvdaHOD2U8kT8RSBLp/7w7+LK3PhWQo2LJ4KvvtcT6BsjTQb55eSyBuv4co+mUJv+VLEgtP3dVkdXz1J89rR/eqCXEh//XzcCVPQhUIiW+qEVhKVOkuC6DwdPJ8JaFa2/VBAULUJ6AW3zVWxrN1weCQWd2UEIMTRZj24W/y456VJ9WULQkGrcMZXzOXfbGSjxz/4dUwQqdWL4nUyc4+jbbjcYThJiXDxpHanzheXpeUGqEcBQ+ldlPmMcXJZql9Ma/NFnBLFPeTYYMVBrlesezmRQ/8VU0zUCJR21CHK/qWPWJ73/nmPtHd8ZNs3vo/rpaAD6sOqf0ryeKNHl/ur1Syvcj0h/vO4bIb5CEpLIsGyfySkPovww3xqrfDRzy8Wy90zoMgnJaMS/dpnMFBj3qPnUeU6GEtcqgwo6p18ifdBGdkvlhkX0W4KMsI2m9pZkBlsVh5REoY7T2sDIUf+6HXptBAPgdUcWiNMtf670e9clXh9u1jg9xQe8zBcNl4SCvRlnWWzCLHsrmEk8rmMyWStOEdZjtCV7Pfdd10sZHGnHiPL6bCi3Px71e0QoRWdMKX5QaqBxnOzHrBYnCH4B0l/kZY7Wkgj90rz1ifyT850+/F/fed3wcTz5uzgS5rbCLp8Td+YDO2FIBln+5raBsXNZNSS3jBuuW5/lP6v7Nj8EM/NLJY8oeRwtlYZkSd5fWG02ZAHp0788Jf6YQUlVW9pKvmeZ0yks8W8oDw6aeik8yx8KxHWgJAPXP+3LqCpGutcz5Q7mmXrl9eM5zrt0t1jccalRX+qvIGkjmusCx/lJILG17iI05HFPSeOh1pOACk2MBZ1RLWdpSrVKgVFPHNNZzWetFbC8GQ/xGP2DEhnGNC3UAUwuycP2hcO0z4DCieiMZAjNHGt+vnC/7aPNN2DfgPhUe5uk8mR35k88YeiwRQiBLwGGlNWt1HFirNMXK47FB0t8IYeC6ajX94KRi0S+57P2I4NuzPRRKnws8ibeICRVYH9jTZXgzNsngibDlV/NrzkXIgYKoE2KECCyMMHYtLpmtU75p7IXYO7RcouyTYW3F5iJRoQZ+3q7OMO/GleoqAyW6+MyhPzWs7eehjO/27w4fRHOJjV9PnFWEWjmUc5nksL5gfi7cME9vwFqfG90zzUWMrRRBB15+7EIqpgkfUAMf4Qcj/l/v/CxVkTooSq8ZZd/xLbBajXGOXhXyLnE+YNl9MyBF+fKMAdBL6ikth21DfEcVJDjhO1PPk0a8lhkluTYcZeD2KUznR9XRsOFpdw3LTVpILfFDmoqa+QCNKozrWAwgBcMyyCDEtG76mSZoY1mGP2NOmP4dpybekmodMWWxFKRWgOfDP/mSYJjmiRYA1djE53Bw6seoDLDP9ASQpn39+rWf6pqA+x11CputeHOjUhM08D+yLzE/BnGJe6DG2ijp0ywHGV00mx5IzaQxCK5Vaw9EXpMdo8Ot8ZuYdo871oQLkEtiPt932Z07YSBvYevE9EsAvgtvouWI6rCKDWPg1K5ublnBWFfWiwLiZpn9omAzHpjCKvlJqHwBRA+fdmO+0kirBjZ1R2ec4235dgJRB0Matv7sAYPQBC2i9LUGQRKD1IBRPbQLFiUG0RtgykWnxeFWYU6vaaR5DQZ/tmGSp/xcE2T8iWeTaL4P4kCH/ZQCXau1Nqps3UnZh3DaQe3QuW2uGZwA3aUDppfTCXo7ER0Ym7urv0G1n8uMmQt/7jPf+MiWg2LQFIrNu8Qw4QY4/XDfkXokH4rO/X3QikbC7xs1q61Cx6+8h12kCQWxfJSv9eD2QfCNJtDYQ/wnsV5hKjHIIdtx84LzhDVgfk9D0XTY8f1C0izSbqHb6nt/nyp4NmIZGyj55dhaiXpB3ZQ2Mgv2jQF9qyjO+JiWCoMNziSqq/patklkcM4e6gw8qbktgP6+LJzrJDsaYvROYsEAwXTf6xu1JResNbQHWzYwZbQaciSxFMJXias3NoIHj9kENCD/JTJ2XekGbobAei96SO52O0H2QT/HEBgYED58aeOSP7laau5fusn60w5XgmgYUIqc/EX7VLwCjVPIoTlTmllUYB6fHS8WHhP/cXIud5VjbvWRMn/uNvszyn8BQEK/ypjmTYpAyEyh97ahQgA4QYYa813Yq4acanQW/8QyRt5m+cgmcoH+KzMYsCkNEPuJ+cTDI2k/gj5le8jvzoG/5DVQWQzSgSavXNqdB202bUC92RPiY/z8uSu6SpCs2sWcYhmnddRGmR7YCrnwnKQTvC1nZIfbKZQCeW0WVf4i1yTGFcVI04DxVUPqpGl60AiXsZwykc6iUw0Cc/X+HPZ2QPCrHNbuLpAvpnFcdDsIeyIwKPQtakx4LFgNAtqOpbKLGWP5tTOu3PLdoaJiHMSBjMAViG4f/CtU8FO+N2nkfNiD7hWClevNeF6IyXHyfy3ZHszUJH17DOG83AaEE3N1rSEyNs5SOdJLaK8zN3cMOKGZ9ZFUFt4qkYKaCf2KvYMKFd9vnXU1ccDQyYC4toxRUyaMXWuTTvfbBtOlysPJzp+EkmbCp7aYM2ooEtqdn0H7FpzgFmvZg+sp1Xn+hEc0MiQo+wV2msi2yBKDXF3Yj5f8eCrST5832WY+8GrQWQgonHUM6RqYsNnlNi2/7zQaE8AAfOUNLwPQj9k8+/YIlKbmGnDEl3PPnmDxQdSUbZWD7093h02JAtDx47sqf//EBDxkeqot0Yu+dEb9KvC2U5/Bs5MCaXujeKkDi9q1UvL9NDaIG5MpztuuB1yP96IrGBxrHKf1N0JOhhMLq2DRlmAiX1u++sWO8tqAp74cYyo1raEQ11snwWE2UVVH+RO4berHzTBg9fGLZM7k3jk3EPZD7mj14kDzI2iezEQN3mWU0bYSeJ8Y56va8RSBK5En2slD7T1a1ElAvlTbtQNa+mdTZvl2V+PZAnUJrooC1snefFqt8ZyjXYGGIxXx9AY7vxBuzGrTH9WKVvI608nCDSyZ36kFlgwvKiBaOd0pZatOxoR4pp548nm5D4WAEzWQqHe7S4Azy9PT/RWGPvEaZQWExxmvI+WnACmAH7IO2uGxaPZwvtj8KYvf1AOPuOY1gltbFH3hidPUxLEpAQM4XrvjkTnwrARDJ96ZjPylLKFx+2EUeAZPKJPlWCXUYEG/UA47agfjyZTQr6DFoEXraAxL25L5OBLYZmwrfaudDxEPDU0OZAeYMaEPY6qWEau0qgbgHRCPgixOAL9hgeHUscleJTXA5KpM0CPzIyoRR4ssA92gZJPckKB08Lem28PgUh8KDjI0xLA4WJhmWtC+TikpNNmNdkFlT+L1Uwj8qH5Y9SJDd7R6W1C4mbDWc94OLQuGMW1v3oYIZR+Eo8yaLPBAc2s0mnQEOkUHEqGqwTZSAQL5zaXOevtf88jS1TpCObEO6RkjVhsyO6lnaDA4GlcuYF/JvfJGhU3LqoyU5YrKyAMfBs0pcue3Nfil2QNKKVJzERBpDOKsRVASRFviPVokySUNSf53Xh4VheZJCSR9muMqGlLk34Eng5m5nZjcwfDpKCEXgSq4tpwupwseeapMK3pe8cg1pGgggL2fXTMQ8l84JwO5jg+ZPCdvyntCH7DLfa4mAYj9lylTvyoQN0QqeV2OhhT/ve2H+7LKwA0b2WeV6YPqjjnBZ1Z5W7t71yjUku+uNJ/yxc/Dqq7tswKWJNNnlV00JR2+KubbC1h6vOUGsuM4pMRWyNyEVhBGQ/LLc49n4PSZ0JNw0pPjuOU404cC6bzQqFrCc+TulmB8AVzKKtXYY6H7CvTxNl5tgmvo/N4RP2HtKu+7r32B3ptJtCXxF4YUR6WpI+NB54rl9n6BqnamP/o7V/0rU0tR3iT/bBJI2u415RpcbSI+Fy67qbZ5B3//vcptQ3maB3BzfK8L2uKU+hFU4pXb0VEv2R2Y64l0EDLGbzPYNMXoNwW5DZdhA1DA5/dpFnD9yhOsbLuoQA9Wf2oCrZDNIAQnQ3do4tQ9AtzMymw8vyywSQ2O0J+I7sEu+RABjMxcGwMWw+dHcsfz0n++X6wrLUoeYJt0WAgsxt7d1YFpNLh64URy671qNg2gs98qQJ/W3QhIhBV1V0OEH64UNDO3CpkOx0EYOGqZVS2OEzPyXLgahfSQZO7ItIMjjtDdt5J3OUwXE3dlrp0/CTTNPvOpt+X/qQ992ZbH2VG2/HpkjxpOrgOV+lobFA3bFZGsWaFuRC2Nebf9HjB97ErYeWsec+tJxMRe4V2eDc2KYzDVLZZNnejhh04nw4HR6d+vV7u0xioiA2HPQPssWnzXMuZ33D8ppxg/Gc1n0+woq9ychnvEERFCpEKbfnsJ/6FdYgcxK9DI/SOFUPwG5lhjPjYpqT/wGRGeRI/NmSEMe6zEoWaCE2LooUk8hSerSK3rB7FkCDrDIQFxz6YOQv0A5AJ4tbxYAWLwquefg1I8fpwn6m+dvl3QLizb7ITkpWKgCnr4r1THxTjFWZC8rRYRKE3boC3Kkwa8N58VCR1/dax3ZkaFjOM9+wXxpWveWbGPXqMyHfMvjc7qNXsEvspyCsYB1jGaBCnTyDto1JsA0UNQa4U2vk9tg4GPnqQRE6u4nqkgx6hhnGbv+GdARA/okRBUZalLVfVUMAPfRbuPtJbAAZLAPBD+IvzHCufQEYz1BBhTgFvgRp0LQTXcjvAzVZ916n48UV0HFn/VnxnnnKABy0Q8wDMQDsd87no1AUAw3CZY53qCAhz/1T56S2Cfpz2BDl2BsBCt3sEC8PE/SxV8g4RAYpl11nVK+mzIua9qzEBmVXiK87qT6ekf2C0iK9JRE4G4xgjG8N+MEk/hDdtxBuF0CnPL9A/+mtrE32PtvTyzFRl8GL/fx+JzwIrPQSDppNkz6cNPRBbazCObYs1F0wNg/uq5qBj1MUwZPtaPNtuF+KwQqOfovvurszhHyTUWli9tByiJzbTvas1ZMQGzahORzIGytyBye2vz2YubV+yflb1vVAMq0i5e5/Pak/+yBTfR2d/LEImOzyYSS9eVc+G9YBNjQgLp7kfbJbA7u3K/rLZk0mP8bxGv2ACsjPSWuBfgfi/E+Bli1CS8Dai192GMEA0Rd5KkkN0VgZRk6MN8C2qwP5WbA9VOuaGPy7VOgIXjdk5xf9g0mJGLunQUroLxGFxqlNt5HQ6+Zie/uh3Zh2djQBXUqKHtSunyYE8u33x8DQBVHx4St4ndnVHlrXGq0cBCUoHh6kQk5kyStJVsCcml0IK5GdAEKp1SkqQVxpeyeZV8qq9H+zM+MgFSb73XEzKM5SFK7orGZZ0wwQGGprU41MaX9qAo3brytiiXqkiWAGMM+FICe/JYG4I60vPpazOneWLZA4ipc+3+HhiLuOwHBpIfmtY27r+mMOnwHXXu+Z8vVXorvIATXfzzdSEIzHEFYsxR/Ebr+VVy5abvBh0y+BvLniQQ+ZKRU7v0S8MOx3PLb7RxYd6jPCnIINrLchcUDQt+PiEhRuGYE8baHGzIVU6JQvXkhBTSjl9c0im2lsXrrF+DBjcyHovGhYQoAxv1YMnRXEpHvReoNrvzZBq9fOusudHR+yCgToR2QYfokdRDc6ZF7yZJRv6nYmtxm5YN50EgqWvyP8aBXu9J6k2nKasZ6QtqUPQCSthbJjVEjf8FVAiDBP7QA+0xohkGeqplCaVErghfRa6ZpVbuCp10uDLKWRU91inmQSYlEptdzqureE2Mf83VEWDWIaEz/DPBDes06kjtGvaC2Xk9qDgK5SLvkpjeAZJpWPMTeyaLUcMiDbHns9/2GvUXG1zwJE4lUmkpt1tadINl7m+q4ZmSArzPu/GptebAA5uXmxCmLztfIBkuRoFgVJXc65CKWwd/0ChWHTp2y6OSLJiPtb6KvRnF2sq1o8B3mWy+VqCip0CKTLcDMHvGoIgXOsUHx17Eut53GhVlANDfaQZBOIcjPua82+cG5Mwzv+yRWTTjeYJk01Xnk9/9cQALI19iLAioEXtd9HkpslUxF2TTYZKfZlFDkmqNy7jQaUpuHe/+fEGTu3O6AV3w+8qn34V/sHRlIv4ovwO/15Xdn8+yEUhY1DKndEQXmAgPtcnpEe5ZcFKTgh6NAGH8rnai434+L5QWGoBFYmSJqeEQm6hZVfGf4fiErap7Fp1oD9CuA1p8zX6vzBeYt8pDJsEl4on+xT9YM/JItli+oH+KfJz/7UMhB4XjyXLK1lxVOibsUUp+UPd56tbSBENSND69H01F6a/jXMn0m2SeqmbpYzOOQThnL8pxXhElhFolbbi/qiLjZ1QXMCOuc4/D1J82kniQTHbn/63mZE0dNPIXCxfEDpT/J4xtugPSHnryln3Ayu2UR4+5/cjnV8tA0w7Z2YUHt9a3vFl0NR9ifDVzTgThLdNORnS6PJ+wqjlqznvT5gcnRvE5yNpm/YhWyx9MFJslR7MP4+uE2rKEktqNFAgfMnqoOgVUiugHEEwALd5KH9swDiLWmrL1EDQguJ9oNS//laNOjVBvz0zPmbIU8X1gD0wRblN3kmFrzN97ICRf6ykYFy63W+/f89G/n6TmOJ9P7Fi5PoYdtYSz8pg62qHwrmAh+H/wNTDPnaGQKNq7uL8GAsYUe2OGeTWNvKbQotj7g1cfYjvnepU1FlmALh5gyUKuyrprOLTDWnSZtdIjL+nsl6cV8ZJbSRQqqFuoqNnAUPYT5ZZnFp5EVuope8nkH/1VVHQDmTV+4DP2OC3dHFaPhUC5Jv8s2ss5n/P6dpOAPG6IL5qsHQcH39sPS/Am18oFr8q/dTTrfb+Aaxxqw+Y6jDqoe/R6pdf1lgjS2AuoThaNwFxVG/6ZF91UNwqPgt3NdmM2QJXL20CvJUt98fgdb+aO7K+vyomwffy5eW/QMUiuRqkopiXswFyONrueFi6TKGe2SXt1semnBZbOQ0ig+/f1plLo1P4/q65GFxGy8ngR/uvNMAq4ocQbwmJeyucze2UkFx1LUViSTYds66bEBc2cJyM52z/qoQIvtIASeJUV/WBSrJTeLheYpUCpo9ewZwAyVz/ObJ2VPfRYxAp51C/CyIEkX0ApP8RFtQ0ugRdPQkYr0/sWEvWxyWblRMWFS22KgokKZEeNBzof9nJ7rNAu7HtNsaUWSTQTL7+5yzeu/ZhFailXVwH6jeiVRCVWa42yegoW4khfwB3VuyOaJAdxnNk/zpEv0REICAjgwQoCkpljAbovuRNzrKbxL8YyLGnOT9Jpf2TMssRDw3TJIm7nJkBWnpq36Vtbh7QpFZCVHP3iznwV+l88WcRJJbZmQZ04YNmHsjQ5hhF1C3Beuh4HKepQZa4GdAS4SG2Q0FKZGrFReLjlRJmnLdHOeKDKtjk20UmaVNVEQ/QvQ10fEmDnFjrcr26xfxsoYkyLGKgkt5mDV7F7ZwvZdTVBHI/6+kSTgg4URrG4pYk1PchSCrRK4s9jl+//xphmTxiP48SyxmRCUwgZ/5eINn0jKztjckmS3ukLhHVEqOq6NZYI6hxxqd705dppt79zmfoZMxvQD+cgdC7ZGOKiMOm6yqOjz5UC13zftlovScSws+dNRT40yY1N5ySpFpcBejZVloCO6sZNFRT/JqbMQfDcBdB8ZbrC4SlXUUJjrGed6T1wi/nYa5ql0DrznLlOm8t0cKEAda+LLS6K37WbR+5DNYLUjIPDTRgKZ67y1w7sLFxHMIkNRNBLAg8wZ5mQMqYwg+mTPyT7e7Is8/y2BeL9c84uPnGZunaCZ2IWDj1o4XsONqXty020Eiok/XkIk7hzbDoCZjp3JMHqNvRT4nriIRYr10ZUuo5NUmELwVPk6Tdl72Qu4O6/4N0IH7LheNe89mXO4ztzTfja5ZSQbCnDbIk3TTDeoV8MK28cEIMntRgk0YJmFsX7m7Gq0VtHkkfyRQL2ijXXKNsTmQqzCII5/BvQT8JeIFh9lvshyuCeZR0GemfHjwGY94gO026v+FYiq6GA1Itw/nsLCjtvN8H+iuvbMWEAlyxUHvspONv8Yv1+1lHvGXouwB1EClx3Es7Ak/PyatkMesbHNLMzRnf1CDOoAYwjyDf5ZODkt3BlVvi6IIb1tBVYJ8cAn9ZhCHm3y19M+AAKfGE7fhjPLU0/p7r7eqyrZIFMuxeM3b+eazTAnlhBKMeO+3A2xnp+kFDTbmnOnOAOpWAc8dJdWv9T+9usURHsBPCeQgbE9nWu9t45TvIrknXtwwJCzBLujoyOmSYkeh8sPmnUFawkAJvVpQ5DX63o/J+UNGGSiVgUjQYW5npkAXDlr1NBQUWgiFU+XBsZYkQthdj2iRekWbb9f6N0xMm3VZ05QvXDgEKwk/2Y1qkdS7jXXxEviikP+nIoWaTpffLCP7FA3UzpqvGn2xWmc8uI4wTd8i8rnIb/iIP5ZzqL6UG/XS+MEc8aIgaWcBxuuBBFq+J32QyIWhxzjkTrs9/A91lAFmmK2fIC/XZ1taoAzuJ4OPGHLh3z1q98DnSV4bGw06KsbEQ/B/nde9PUBYqdSVEYObUNBRdvhl3Qwh+Ye7u6/OMPmWEctrN4H3XSTPvAuWwZFwprmD6OsmGfzVTJBNe6Rt/cOHJMcO57oQaptXR9Vk7djG8RV8DIULDBI40AcECCBUsV5qmY2ydfpY5qMboJfuwj3a/SMedNwgDYJeqBSbg9fo/7UjckWeoUU5PFpCCh2MP2d59GZwxIPxDWCJs/p6SN+Dnfg+HJvpF2+sw5orSXqQHy1cpnShnN6eHv/YvB+0CZivxHrIpaZwql2CVFClcBHvHYjRsRNTCQuFVOsgDFd1P3lBkWGrD6ZBGwdMOro1RUHDfbFjj4gJ3sYFsl23VY/Fhn/BiZ5niUhdpZqknybZiZ2WIKhGGqS2H21dKJUBlgZuL+LlMmJXAuP9ECaVudeFPahzXly+Gm2Om8TZncnZ9tz7gwlGWsoQHKp3bX/LZ8L4JzF6QUm+fv8Vg+ORPtoGVA8caN+lCeEE1oJ/krzvFyBOIay2JWwhwEGsVF54Z62SWTCKoJ/2+ezLbYc85BMY1WwMtwvnKm0Mg+ktC+6zCNKj9MhqIk4dqp1YlLaYqTlxEKXxu8QRWNszaaH0uPeBJNmvORYX8vMi6xRlm9z2vkTzNrPdR/UZe1h+aOXke60e4eijniov2s/L+VOAuGLx/721N5w7zmJFmAH53NkMDVgKCY7+hQuJxC4D0qPvded+S33LTWtdiQzINk8qLMVw8mpq1U/cwZMFYjmEOp61f9AbS6Ws80FiSk1r3AAvuQdaOJOa9q1X1NmBuRMvX6Z5RJ3DxEXrycCiHtiRdxU9h2MdCW55Fg3wvnNeCC94QKpR2L4uRc61UT81GApUAX8Sp6uWudHdjpbptsz82bLXVl31mz7sh5G/3WRKFUhjjHlNYYVldNUuuvy65SECXde4eLXmAI42WJuJ0XRNErB4UAFL0tt733YSRpI62XZqTIoavghE1G/FPyk8WQJELZWEUubfy8bV8guEHK0ZSY8qHW8ZsyDaP3gB9hsotqEqyluGebGJY6s//j5y8PXyRfNqv2mVWhVwP1Op6rtrxUikT04Hv9tfsRI1BDVFuN2lzXsRr4IK5ZZ/30CCkcYRzkuu+r/y2BfEvNLZL7TtR25gkAibJkfwUWjPJHsN+L4+MEC+xWaRdToG4byqqmbB1557HypD2HNX90iDCOQWLDqiUmNpu3XrFwtWPiJBuyerN8WjEnaoxBsSkEn5nDSt9vvTuVycHulTEWjoMc/UlpkZP12wtLR9+k3Emi8v4VKOvvb/V223k2mtdPvPOpSWxX/aZFjQnibkBP8WmYe1e5CONYu3mFUIAfEp3hOzyggWY4Q5R0OxBv0QlZfFqJcYh/UjZn93KSutiRkxYVQwJ6B82dxLu9pledfEjRM9cImsI3bnixoAK9xUD0Wfy0qOnLLNj52jNIaNLXIxbowXx+XR9hV7BakLEvgG/HBu39S3PP/TNxHt+sDwL4bYOmNl1mF6pl8qzlHnJwS4a/CIRDIqLVnsJhz5Wt8ZmGRJt5nXxI5chGoqlir+2yaQHOmFAbsZhe4mpp+5Q0es5esfvOKSrAo0a4Tj/5xa3tT9NzZqNPtStOoqb89T5v2AGCBafTkdzylurjThVDYcfpG0uXQn+4slXPRKpSICG39tAkphXIDJhw6fGiDSaq6Z/N8/po1d4nS+fYM4s1zp0QubGYSf3JjOp6Sap2zzhZbvCPhj/6RxR9gD/MCApPw7G/n3pJHu2uiBHD9Q7Gmr06Kz6sB0YwALQmu+xTgg7sJziabzU0bu48UeTI6zR9zl4UP293mGdjvpqekBUa8Bo6lz70NS1adI8fVgbWLiETC0JBfO5GTmKWkoxLXw4erU3lJMEnRfrCsb5iIrQHrA2glm51GL4CtC0LoQozHTTYvwxMzYGuH2TUwzv9rDEGzQuc4T2qw8YigwF+RZzol5MxCYY4QBRpNsjnKFBWCMIsB52Suo5+Bn1u9GnfB4eXUIOrk2ZGnfA9Smxh31thwJerNn9EOp3/LtvuFak752gcvVjOPHhzhfKy0oBaEB/ipMjyfLhBl+MYqvrxxANa/NiC2IrnNlI5+tgyCOSbLZkrEV/uRlZ3GAqmIkHXlP5Gv15z1gffw1eCHjKTwD00dVlqbQtIrEhTphsARyaLgXXvmPQ1g2ujNi4S1m3wOYk9qtD6rKZZ+XsEE89lAOxTu7e67n5puo9nOwwHouBofTzkJuyntH23jrzGa4H+j8Xg1qndh2E6imquOkryKmuSVA1+GM2fDYOd7MhPzI2qeTxJiPlRU66cZwhdL3YH2jjw6bkjQFRRBu6NwON2gUSePAHKL2aijCdTpJIjg6yPsmEgf3jYzo2Tl1m39YhasmO84eT7FTvFuOpX/K/AJ19aQzM2ziITo579xzFfrs0n4KjxG7YZlK2fFYaz239PmV3qkbsuaqKK2ij53GxTxdBpgdsjZF06+rfFXXeSKBFhT5WsPwr+bNwKC/uZTqXRQwd4pzBusImqIC3PkWaku9Mf9fgVn6ePoIlXOgF7jgfqj+qicqDbdFLBj9wp3S+vXTqcr2TrtlozzUiM8R+DmkZFPvdTeYBCjrEnNGEFaHK0cPlmtsYdkz5ARW+8F7vFLCRJ2psgW33OJozsZwhKBTTQGGBCk9t88HPcYiCK8ATJeMkROlhsHqWYCMXUHZLXWANFPzqE4SqRPLGYu3zI2/inJw/0R6M1xXYc1F4XBxAXmh4kb8W4dTuMdhxux2IwGwcPu+OwNQ1loEUIzDShIAHCNcTSjpkthC97f+OlD6u9fvk9eovfsWuLKI3QjvEwaF3vKMfXA51sGMOXWmF1BvLbebxEZsoMWBOm2I9OypyPjo5eE8h299nYs93JaMngb8nzkpJATjcc0U9v60r7LPjePhTQjUZQeqgnv8nyKHuBXdCgZS8Prbz9BbaD7oLjHoXrRRXm9TzhFXWqw1UbKFw2teRw+up1IV/AIzDH5tsSQueezMOFW8sav/YOsZzRN3LhlAzRKm7p2KUpcQ9ZpDG7/4bU6m7PISNR/GM9W0g7XJNRT6+qPKH/cmzYw5vXUjRYD9+74phbITd5J42ZPJtaFACjM1JukeTiuTmgdTgClxdUy7rLpaDbuPF2Qpdh+xLy7w6rkxwVhjhie/TPOxKhInKQXFDJNJkAPjLdMOONFSSEhM3wmKGLjZPepmUyEqGnFIxWJNcwFMpCecSnjCSxzMpA5VHGhQFUAaQm4VMFrJozJEDavGmE2Liwtl2RzvbfPR8ZlWpprhFZdSxL9e616w8haHY23XWtyLgSzLChXBnxpyf1hA1WIo07VqzX28mfQS9SOzYsz4UNDfK01K5bii4zUKZ5i+6xJvG+tELEyRCaXvh0Sd7o3vK2PTQvoPVeYhe64WNl8paFOeeGSN3e0xkDAOzpq9zD5xb3ase0k5XqOPlJ2ZFRRS8fr3r+QWRzgW8ANutSSjQdzSr6Oc0bwlnVVryWoBGZkuJ0J3yIosnHQvaSGrqZA4RYCUn4L01OdEVogUCk/6nhnF/xNggCL8DyG52nOEojW3Jox7NfJ/pAqJGBDaR5bHEGKmWoDOlpEVMEhpvbiZaSgNHp0R8pGjCZoH2VFfCuheqnV8hXlkYcB9Xj0ywxZnOO5ulXExHOKCBl1Q8bu24nE0lUcPIVgM+4CPSgoyqCmnQ0QQTccJBZsY93RsXNBUTmgbteACwgxGPLiLf2VJ8SMEZzh00FXcmDk/YKTaKnZU/8lrlFJ+ifkBXhpdjP5haA/hq1T2PuMvSaHmw7BZ2ghxtSnsWgTWyBr0KL/aYyz7Hmx9RTlap66+I45ajtDJkRqaNiZZUCOwgF05Os2bclsmBHhmx8Ba8Cy1Qi46dhrHLDhI89J2dRMf0eCLE740b8WOafsMXGLr3MbV1VD4VHgiMb9BRhlYX+1d/lo0T9D5J3ys3gXUxJFeLNG6t0XirNu1KYmP7gjtvtAQk0P1vLU8/Wp/rr7XjoMernyYlgVfLHHilLkcr5XGpYkWOx365ktNS7mBBVSVHQJ5NMVtC15hLVs7ZzDb1UxoLFgQg4QRaGOwiQKuQ53Wpqy01LU0vvaAfmheR5utmPCeBqXHtuI8h+r8O8Z12VHzOdXDCdH63ECWA4byOXbgdPf9uUXrh6TtEl9ql3Jt7W7XBawY0SKaWkOyAKKAQleXO2pO0r38osou9afk1Ggq9beLOCPh1CuvbB91YNFy+dSZT3DDr8W/GHi2LG/qhr2Kd/sBp21+SmJBSj73nBl3KD7ApUpTb7Cds5g5IJ6+eMqE9lQOglfy//7fZNekTH7U6CUzI9mZiYCLsM9NBAxmTjielXoqDUOUvwzNj/DkJkLec7M8dcYfyrSHZTZGC4GdRN/bI9N4D9FVppOj2x/2clKm5byeCs4XW3YK2N0Jv2ixb8Rw8lC8cwrtyIQyvNtXKaBdowlu8SmevexiyDWHJVqZseb2jss6k2ytTIOlgArazGIXf0J9h8w6BacNER3LuF4TtfBEFDhl3EcYvFwyBAOnw5RTuf4c/AobU9xyEuLNJwFwF9i0ZG53jfezmYZCmjr8xE9ilp70KJjJSlWFfu3Qau+muLuSHURFcHFWWeP9dzvGo+8ZuUOsjGcOVIN01ny2hinA9kDFiY/5lJmWP5OT28vhk+K9/zw6Y9leGSjvrEa2BKaVaz2JbfH0ljY8ar2a+pbMT+eER7aEUBAnpmOFX/cldjAGo/6bDkNEaayXQXXBucwgtnebZcSPtPUsUi/YC8R/exut+ymCOCg8aYoK4uVufeDgjAMcHvpIk0d43nD2mroRFuMnQatk1Ak7PlXRTIgWil20+U3JI/wsmKUgBSdl253J1R0tiI8Ao9HwomsYDJHb30pu7zE39RfduKTPLoofsd5aQaK9VHANg8k/dsGCCXjGKc+icfYne/8vfWuL5Mvw/rzGzctpOES57GFr6pv4SeH+slR80Q2OXHbdP89QsM5R4vxh2J7abOzFdeseY+Fii+mVB6QdwwvyuKD+30+T0xCgrjjSMcc8lTMC5Uflk6WpgUw4AC7o5rd2QnBXOl+Pp6GJoW4EawG74ho1FUuECHWKWjMr3V/N5GWos+LNnxnz7CFtU3QPJyVXoSmNO7Y7YKRlE3jpxvS2sUZTAL5K6NHl+TR2I9ck8QnhHSd8wAs5CmMhzMHuZNMfFHsklkEZ7at1n08BVmOC12k9g2uuqW5qTk0yYGAkslVu3QHHm/cp60nxLUHhWa0KnppYyAMLPcPvX09jIArDtPlAqyEW5q7A3+/OttW7/rCqARbMsC5mEg4OktV2DUBnRrjoFC9GFpmLFxQeeloAvdVTuDmFPyCtaFP3ZsH4loA3dwyk78TZZIMa8n9/zk3DBH4Md32oNw/FDvjKSBOYChPzJUv+7Znq4Q1FyC7gfcbSZhS2OzmO382QWenIUD3XbvpF61eCKOYQiZ9ZpfMJRK7ULekuo2YVTMZE5lxS5tOlyg6/HkUAAYIrXlk6o1x53tcGHDJ8dO/ryD8R02of/4HF4ER364SUxC7K7MgK9G7KODXnQZdd0yDXw15SMSpFjcA749L4W10Df1DsWD4CxgTnneriTf7L1Tes0htCuQr0k0AEW0/txme9ot/zUy08nH+EWY55jtpnlWB+awAZNnGQxWERd3xDTrcaWU6xosNqtHmTKxYZmDFZXux1gEEqnJejJpEhVnECOszvFOfPD2ZhrahOe+lfFvC0mQEcddVBP42GalIsvedFZTvAdfTC/GJgtTWMBhta7BK0yZGKRVpoTFT06gBtcd+7qy8XodGV12Hg51ziQqeIzHspmmDWgh8HwpHA7lPJ2fP2vR9/8uyDapN8qmA4MotIUadZPoB1gB8XYC0jlnq7ajeXwalFexIDZJKm3QVSPDfleT1DFWaRz7AYVdxVP9i1jbVDE6XRH52On2woaa7U5bdAAnd67XLQoqazowz1c3+H1XIGYNJcZsvWnKBS8tHQSgtsHyZ3JbHQc/N+uBXTogNWUn2GVCB3KYUrFrNgbQDK0m6gW/aJ3iM7Vant6cFsVgddbbxaNZ3AGCQ7N5RGjM05q9lcTWybIEL6mJNzNwiZqhxpCSfOLaTAXUioKU+PReznfXP7AGJRl/PaxxliviqPRily03HDDPOpwdXsv+aWY4igJOPMwNcVa9b94g1B6uXcvSsjEn3vcOmXc8LHH7X5hkUsu2avmY/WnbspAsGNcTqp3E33uKGQeyLBxxsDjoWb2ZcDLhbE8RWIRUrjaLhZH6c7C2fN/2nlKPexBJLm1AN0qCbjLrcrNpCEuj6X0fVw1L5A4MF9F63zUxhCwRdVc7iyz8fRQvCSFV8V+ch2dXB4IxLT7v/mpZlSytxTJrEy8oCYmYByDUNstzYCrDu9E+iboAfEFMVvsN+URrvS5zylHWgWRkMwv9Mv/fFuUapHopUyFcVnYf4tXiijNqutOAu6W9ANtLy3YkbQu22uq1FIaRlCQFnXmFLI8w7Va80KMMaIUBdfh9sbn7hwiIAv4Os09mOpNon5CmvQeJsxzvmQnF0ZYn/1WQ7LtKOch+/zTatPxIDtphpYU4mBXY/p0ZDCRdWw0iixMSTx9nExNGW3ZymuXXV4w0rvq1keZ/iPpLz+rQxpgGFYCcxgOlWOPn8OjorTER0TGDN4B42omILIdPz2lWtmCbdUsxW9Cu5Ih4tcyuKWvKqy5mfTYK4Uz57S6pHBUJJKIofublsCH9C5gs2TAEM7O97ydaOjoCgULVSAJjnvbFO0BZICa7LO7Bxm8hYj6EpWkY+2DWKSzSvkK/HFFGMtnRvcntkf2ZAI/K73H46cWbbNz6HxzF/E4dh++ELzW6fsf/kBRZvBgNvJCBMFlL8HFcEENCgkjkQ2RYl4wCbB9n4ohBO3jXQM42SwVONJVqPA5F8YyyLYQM40KLCadP2Erax9zExBzZRWfZuFkfW9LRk3zIymeZICWvFc4v6Syj3jFB6Ev/KZi12YPvhg4ahzvV24ySRItRu+KEnDn0BBXHACev2Bo3BMbQBVi6dC3AmC6xLA42tuHkaxXsVtN+yya4ShVSO8/efb/rwppunoDbYkkpvi5G4NY4MI3sB5/Ogs9wVOvGwRKZTyb0dUeg5OlDIGs0n2yI2gM1kMsGQuKkzgVm6Dsh5bCPlc6KnZH+HREgnEJq4ZVmL3ehf39tJWNnSzbmiLRf8HZhggrzcaeFwsF+qEvd6/wR2TK84otPL3rt7/gY3yTGoqcsVpyFKXfHxsEx40VdsItApOkr03m1rpJR8tOpEnrBQsMazakbeBwL47VqGmEr+9kCx5EwwhSZDFGhQzLkNwY852rKZnZ6AFCNgxqC/QIAGhpRvXSmS1gIDqXKOCAtRnHLaHQWpRzteXQHiKcbImmjShZRnFqHxt2h4osfusL6uoPMoJW+EDEoMNGsVMwt7jFIW69Mt+UzjB/cYqJ8Rm2+qNoDgyqeiyRI5kwo62CJvnaezazMlsdGoLHx6DLpyRAtnPA9QpyU+OTOb0ZK5jsRbqJC3qduwVcFWs+fRxqmjsuZ4E5jX8dxxnJTiI6LS1ZLEWpkftnyONJMQe+0wqsRLrG3QLwZKlYQNr38NslKLKAUE/+3t+5bvO1rSO7WUN+ELEJUHAY98xaV5l2HFfOC3OeuQradSvneB1SobkIRdAFNAi5A/uhvNiOeypCUE/Yeq6DfGbeVIjOQm2LogkKh/vrovIhtajUN5O0FSTivP7ujF7Dt5kQUllQ0J3RagCWjB8EN2hH5B/U7FpxzgOkYhcLJYC2Da5QBBUBqq+smBUzdpnWugFAef/HovT4wZ/E5ZqFpZLU3XYgf9I/2pV8e6qRS1pizvS58GtOAvVQqTahs3Vb9/qylbZr8TIgqMd2GuvBdGjFGpQYpHFcHHicYDel3KLEnV4H+JE7ymgaLuDVxI3P/7MEhRgHob6Sigi+gv4nCD4nATnLyFz02bnds3o0YfVk4xf/LM3W5VUhIZi8R1nbXmae9AZUv8oKkoyj5M7hW8sBK5YZS9oggT+75/b8fnGmJBqIJLgsQs6RIsiyLlXOzxmVcbtMLdnZ9NfqK82ji0F9aJ7vPsXVmF4UrBaXV6W/w9UmToz3UyG/ze/rf2+tVgiyBIIz0/U4FvUleWdMVV7aqlhlLZPxr8hia3JKw9qrCwzAnCb18XpywdBI7du3suSpnIgP1BAY+35FvkSzqnu9RlOkWowCNqqPUhNP8FGZIXvqMb2NwCWUt5BaTCdjEBEPqHXaqnxYh+u1sM1OZpkzNNV2Ln37pEVXqMU4b+yY3MZ8jfm4GG8cAYgAUxXryxw0ZP/b6ur+A7+6TJ4UvWwBVh58CAXSRUxaKQntSODQC4KopOpcWD7P12kX/+L//xY49WmjWt4tjMoJWyUOqYy/OrGL3myBkCUsrZNBHkZTqI1yL0q/JDr8XxWFOfEFKQ0Ih4v+zWUscgeVehYWGaHp06HPEmeJOHE/BoOiDML2mQGzKvRqsAffYbYMi55LRnFmLt2cWpqkrgP/LDeemeTKDgiBSI/mXHVZFt6EQ4zfQfFVH7pWTwMwYxvLtq02jfiA7tMtrXPMX6697TqDuW1LS/kIriBi8rjWjLe5zSl5W4dr/RWJifuOmmQOuskD91BatkyhZ+bDu292nWQQc8Mt8bNLYkFalgPyEhJSbomgOO1A753aAp54gtIcB6FBvAiFC4YV0DKTjD300YTw6v9uVQIkGqa79j+4/ZL1/i8K3lBREAXxWBE24HrsAxtKkjxA2WD44Tp1SVFp85kn/CEA6Px09LV73s1wgVumFmEBUcbqowYZCV+w+19eDi1d3SwgUubFoQjOfnZfUyV5dNgFrhzwC0K1H3xdMxLCn1lpByIOFxohff4v34fMKFqlqjEk3eiXPn/uDFaTua1bJ0MRCHmp6aedU9wladHvQ2U/NXTIooUWaZCZm/M/JILHTk7KjcQg9vPcpSmM78gLrls6fuXQEOv0mN+kMKXHV3aWjGfhFwku8aOjUwgNs32Q9eGo9cgCvR50GvS1Ql+BE4mLC8WhmxTfapLZKE9XU0USPtK3hIfGaMxH0FSA/27acEhA2Qy3Cm/LnszMDR+GEGcdonv1f8wHsH5R/r2SPBddLyQuYm3p9lG2aZsh7DE7PMaU+L5ciCB7wMKyrlg4veHhOEzCKa6oLjVJwGru0dyyYlzJP/hi/5NPkrIKa9VpLLmBDZCMYiW9YKQVikZwmshTPS1pC8jHsv7iHKT+qTAImOg9cqrYyoW89n/Z8DNafdVdH2svEmIC9167VI4SHHKg5WXVXJs+cpkvpNYoKqXQm/GFjJ10Az7jKv61dTdNCV3PVYaNV+rZBPRa+XYsttJE1YawFmq3k7zxuWvZZucD+94VZf9LJ9zHsy+FIjiPa9hHmlifuupRptcNYw3d87gB3XtVoy+gE0mUw+zf/THBmRKXb/Y0zCB5YnomBzlKezS4oxHdGE1yPhNcuXzE1MeprtusHKZ3Esnw4cqoX33oXu6zOpgwv8YpLApn00R4JzihveyRnhV9ruxtC4jqXQ/Ry2x9Zpeo9k3Qv7a4TOA71oekDIDK4VB34m5lGGpftb0/F4bbsfgM6W/gG02IwJ1LF7dJMYQNjMVCVCy2ScZWxVSzgkFxRbr1TGNZdJXxGW7Wqq5XSc0lk9grpoaZzPDQe0iKCQNVny/qXpcOKg7SiK3Z0UY12iQ4m894+4/3UZRuVOG8gcrFxJO/RmAuODJrnsLdHhTuU5OjgxDrldBxit8qgtigy/oVursn383dUb2SyC6rvznpzdSnXUF3MPKprIJVAyk60hNeqevLpjKY/ErmokYfNc8XO3IM2vSgXlDctcQvHtV6cm/YCqJOtMYCxZWYGEcDRJAdu1rxEJG7QSyLckn3E7ZXHdCoVwZjaI+8K58ZVbofwxq5kcjot8ecJog9gCsWQpIQXr5WE299HDkW3nhVF98tV9bFiJgpd3iGDWB6QOL78pHBG6vEQpciMXNmpZy6Rtd7khf/Rx1oBlXPbd8g5TCFTo6zIpHaOdH8Eh3b6Da58db/6W2uUc7JRle5bg3hXzf6o8ESNUGD+9PDdW81O+RlxI0Mrv/wOISAYX9UVgOXX9O2OqqM44IkIhHdJyiKvmtWEP12uZIQ9Q2StIJQmX0ot23oLFV5qFIORGWdMUtVjEfLyZ5IkHCHuhRNip3iKp1PMUnqsKWX2ef/5cZOwajEkMB32uUlvWYF+1tly/MOGjget1ESx5v0LgFPLAr5LdLuPp+oenjHwwYmMIflKi4HGwpmuaVYt0bkUU/LWZPBdCbFIERe9XTh1oKJZcRSV5TC0uMEtssEpR388L3WPlZM9WmocqbJhbvLX56mnxiNy6Wk5P3wanVd2iS8QRyKvvNO4Vov9fXJlnQp6lMMSAcEujI7/va/Mhw2Y0TM6cB8REw4CTmjjtSP1KAtIxSnrAimHvtO4JukpFkRmFsoQdl1UNV0ib6MbONYc1IWVEQMfcSGO78GAs8INGxV4Ud/EPtlx7iPIgRGhYj00adyceMyPsHqaSlmI2VtrBu3dvK+ivPVEOnRbJaCHxHSm1RyO20z9Uliqi2lGl1yPIONpon3HuF6mU1wI61klWzxJdL8GWwB7ZBmhXQGuUiRvtQaIIBJjRP7MWK9B+Urm2pJNd5O3qpNECORrf4nNYCs16vmvyt9fZ8T/0nb7C2++UF1YDM8mGleepl268Ua3BgEam8Z1UoTnUZ5dxfEDOHFLFYQUMpefBE3+TaU1P7RhJ6IBHQ/Chlv7PJbCxvbes2V+S5qGXw027Z8WYO1Q1ut36WVYlX8NVD0pLCjgaZ6fBBn/GL95wZetv86tY+3p3IURvYQ6kzJMfljKFwyrLNrSkP5tnqNEPQMjWPSE/lLXQEoZrhPCNJ0nniiGO1UbAab2rPTjq5ib/NvQYgGVcfJfyBT/5qpQPuF/QMqvnSI6IcdG58ZG5GDXeJADlXDkutiCX1TmHnKLu3pkeVv1MFm2WIGOMxAb8nwv+aWMaTYpxUGLp9+GkN5wGtolUZ4rCUp0zYZ+QqMJre04ehtLgbHZkmgt2WoJl85u8Yugr2DrZkQNCoR37TtOP4ggXQSLs9JmDW2HV+vTfU+dhLwjHjPScmr2nhCYDZ1dyby0tPSXzRmamwSNYMraSRV57LMgw/7WuR4CfUhOUOX2PcYtN3GbiPYf5LnVoyAoZGKJi+J99qoGyyzWgJR1iwPFzehu/A+skuRGCoWZZeh2ckAz7eggYv1NRlhvo425M9GYaAAkIKpGuiOJGhhF6D9hRwOEZBPmlpiuG83CX4O92IUP4NeRBZ1EXPoBDWX8vXafqjtzlV7Jv0DnNpZadvcbrK2+CmhQcjTWAV58CQAxiSM+vjgLPFYiEAgdPAaA+0YHoDShhhRNVSY/MGECIDA7Jdgy6eI8kVtKk+JQ1eEDYr0C1T2b3nkeBYg+nrldSwGSqu6eQerUI2pnYWpErYm6btzUbnp+AKJWwoywd+Kf5nueXvSwP6DekDtvTZ+pBgTZBgIROuY/MvAKvXwbB9bJNsegC5Xf1OAOHf+TIoMkS6HbM0uoyie7rMtVl9X3159iI8LLelvbqJhzkCv/f4gzduBxGAaRpFTnQ8ccKv2yu9wiVvSzu3/o92Go3xu6XZ83wqQPgmsW4vkV+rqOCjhGJfq//zGxJZ0/qza6ABvIrtOhgKN9p+9SK0jZTPBmJvx7qDpW2p2L43q77TC0z8/lxetW7E7X/4eIyGN8irExFh2IKcqF2gstnNNtoWRtiVBGsDbS3dSuFDZhMooYdkJwFdzNIS2v8qMIWn8GRn79mK+DhOfJ64gl5lobYIn2IP+Cjf6VCHDjnN+UBMxhxS4fxg3StjIDCV/AGhSXXk9TSwB/0A+yaAR3Rp4DdfiLGVU67lXGcR4hPwxXYaohX+c0slGtb8mvvD3AEwDJ/hMlV9hbN8Ubu5ClBf75ZRPVFwnvCYeE/UEBv/qUel4RKN4EgXENObk87mbFasu8hvRJJxDLphyAJcAAMSMDRh4FqOoiy7squA59lWWgDdbOvT9N2p7Ix2DeQIWRXArVUeeGrIroSsS+7ftAv8rLQlmV/6s4kT7yYW5lJekBH5cxafTQTluShYpIw7gn/u8Zcbw75ghTCh48GR+JQfLv18TImDisuz8gazCLfbvdszWlVNzclbeR59w/2mIPor7N7UnU62YHDqQBQ4bMNjBdxEF2/Hnf51Z27PaZEPUtJDy9dao31GJ9rRUtdiciWrEBM8Obw7WmCdycCXaAS65bBf4s7HVTdM5irgOpjXm7kTOn4ILy06lKH5laB0GtdtM06Coam/FN2jvH/McSRGkuMkic7smem/uNKZ1RHt32Acpe9WW9TLCX0MoudeVjXPsGRnPaPVYNJzbsT4WJVlXqW9FahLWZmDIayWilru070DeZPWhI76wNd7evQb6gvs+DYfqaiubzno7FpPusxHBHfZQv/gCHotNB/PFi4gWa+E8+ssiSM9XjJ2nPrFcu8VKxajlk/hWVg+VWz0yOeFeLMbrjhCEgrd2FLxvRrPMq34XkdSnlcEM04AKoTatb3jBvxEaOPg7C028F0V3FDI7IxudaOXOl7ahtQpJ7tLE15m8b9Wl5jqz6ln3PSW0QBPf0tt0z5S/fyazbl+UC4w1mwc9NuZJkWq5nBFriUn++08+Eiolx2tvR9LpT6XMlUdW6/XtThv4RsaeJ8ZJOQD29/55RFNVvXnlspfVE+4uePAb35NI30CESW0J123jU6RuSHmJwJfhBXB1Il/uT98KhrJ95dZq/OFsqQaNmjcEEQmJ5n+GZttSDcXkzKCsI8bkSeuHGv2Zx8fkNlLTduX/4/xjjBD+u2gFIzLKHoyHPK6crR/5ygVUn0uwLyvOQ/WfTXQk5eNoyuFnLUcn17CMueBXaDfzbOocLLZMKfER6rSKrv49o5xRT9YDI/GZAOqASmqGLpNy0UtrrlkUmLomr2AUbEGOtaaC3FOeXYTe8gHgnjcMy0sIszHTznzPgpALZllTJwyc4LrcYuFIRGjbbLDNj3eqU5XU0rEfGw5gHVA4Qym30BcPoVmZsXsBQ3U4A9GiVmgzRxjAgTLPc9HH7LxIwC+/WfzrytEnEN9l6IrzXLRSGqIvZb/ltffoLxRSqvJSd17U+vTKD8KS37ZojuBI2Iqi4bWiPQNfkTHAkKJEUQemunce3UyivKSV5ma0obySNbGdlzLfqsVaIw/qZAgFYNEaH37gt/9gtDXGnwhGPszc2ILsJAyT8NbQKq/swBs5l1jIENWZ5bCwj2WlHy4pkBgOr3KlfBwJKeQIrK24BT44sAW8aQxk53hEl/A6NkodlraQ//njZGpKOO3RdOYlClhLbTO40T3IxZ7c9PU7IqneoX0GFg6+0HdjWUzOkI8du9xrbn57rJho3CEeE5h4qVu52ancx1sUM46hH9E9zA3Q4t743tDAdLgXZm6QlSNk28+JveA7Y76bMgTJtXtZWSt/ajD0jn3zn0F1IeA54Cgi3zINVDhv9+1Df5gfnQpEbIc/W6izQM2E1M7MYuV6R7QkWoMP+hxon0PFy60Fz3sCQ/Z2bCzmQf/3+ulOkp7apdn4nijday0mOPzSlGFz4IWqq1M+Gkb5UUiWNUYBtEObixZcfkA4glAfpFzwV7QcmyS9si031obtEkvtxbVcANZpzcNzsCD90Q3jw5mta56+ppsQJU0AAnC0JR7FmxV8yAGPE4kf0chDFd/FSA4mdVPPZxRFF6/qeKfzmGP2viNy4Cutwh6haQjvYPmMRVhkFaP68gLnjGmTzm7TZbSdGQ80t1tnWU5+QkGNabtD+sqqfcV8NCXG8DnCdFdjpj8W4iFGz8BndvaByED0tSaEFUi9sdyjXUXdo7HMf3x5qL2kt4j+OnCoNIYu5Ogz7HLi2/wUUIUh2ZzgdL2GvYzf3V87erDhTs0GB/6D+1EJs51eZL63A0YYTuS5GxX2FSXjBO74ZFYTjqQyp7E4zQUn5S7IIcMJ12Knl0P0l44BE+2/0yeLD9sgzEPKqWmXiUXwZvM/DDqNZGLnRp53O9AdPpvXy3EWqwbXcwtElxF1tNCrSYtKLGvYkW1O+AAzSl+87OmfOUR74LdwAlO3H3gHzEQaV8b6vd3GKDDT/0XXvhv+HGnAQ6SHF0ewY1ebevbbVUa7ifTBAWU9lvlBeYr9X4w/UeqzZMxqZ8nZxPOvCr4sNFWj6d+VNoZfgxTaGD3nYL0lpPGCSKJAkFQzDHdXhta83Tm3jbaY5QejB8dX/rT+clflte0mmZTEHzJddws/+LepwUThm2ipBgFtjsoc53VPNGzcyJycQhouGhhY9g5TWktHS7kjTuTSoiwj9XS+AsIrXiwvIAPW2Q3YcbZV+FO0aqISlOyqxhKAfy18cRtcPkFHhAWTqvAm0uuz+hNbVupECwFsIArXNZcY4hmttO7L4TPRjkbxXh6ojSRICiJanZJ+uC+7LdHXFUdnizsSQdVM6h1UqJTn4979B/MkkDvfoP35bbX6uWlPbD107mU2+bvvV2opq1XvJ3elmWehvLerEhhaA7DrwN/GdADmpxKW3GaN/sZYLESkkp45iKELMqHiMIOziFYgIomsbA+FUoc7qggq8GFSTULdCDL61fra0jo4Hd/e0DlKCeHRajayLhQ4wF/MDbt4K5OSik9U+jyzq9J5t+rjG3UdwoFYgnJHGEAK54027wQCxdDm+m+9fj4gE7wWHL05N86MDoJCmAc194AXth71DwiF7jnwJCVq7gWQX7qjvTwHWVqzYnyKL/wt8P6u2r/aukzEmauNPqzA3Ky0l79h7aDSAxCb6q2eEcFaSfXDl8s9Jahf803FlTBdeEZ+ZrcyjI/RjvHM1sfTmsoWHVisNvPhh6hoAxOK6dMuY6CHDBmQlD/jg4InCvx8af1iqUEwcDoUZ/CzwkXcF5Hea6JarfEtoG+PkCHV9ICpjgwTps7z9ZE+K6hy10Z7CGSpgfosdjtYaHj9BFw6hIgC/YCnVRmX16XoAMJssoIvT6IWc+Yh1oCKRiu8AxzecPIDqbLovr8ZYeEpE17nZ1N5AaEHJQKW/GiEXvhzhWye8xB8jo0Igs4T9Lutxgo4hhv6XOle0EPzcqeMtm/bCfQefH5iXlSbHoDa1Hp3Mx2nLroM2x56Goz+TxEUC3hFbN6/+FKAHgT0TZENHstLMtT0CkkB2lbML10XVDF+dhyAoDf3ecNgBZA0m6QFY/sy4GOAJGAbBiyOy10broqKyza+RL5pvZjUEd8FfXvmdPcMUlOiTVTVkMiW72HeMC2AhUqcLOUDcT9lyWgpOfsbeWZLFF+ttvV5g90GBtL2J2Jhy++dIKPn6CNWl9wztOBNeOjOXipPoT1hs9CHlm+FBWi0PeOrgjjHbq70qKSdMLHV+Kj8eEnKrd6DDv0hxmGAJVpgtpXwlx5OWZxbSaJzLadjs2RHxltMpunPp+xwK3960O6ejB5u9MfaJfnQDZ7cFG+Ml30zkrgXfMYpN0rQ9lavWeiva8B1JAw1091PHWmYGrTeJ0MVHr55AAWJOrSlBdeE+2RVxJNcUpujBaCIMBbtJRR9KMJuAC0grdSmRFJk5f2jbRneeJxAuDODBCNBhNFsHm33UxLQ0dWfy5eLG5ikXLLocMTtDLbZuSWOtr2g3HljEJjCf0RiRIwIyTAqWJGHlNgVN69Q4QTwdS8f2E4j+/LwU1msK3IIUFcG8kevbvoT8AWCbAlL0CMaafmzYJxan8TwWu2wqRKLu+tr+3I8LkzCj39VXt/k2FcbMZ+ZEX5BDao4YUhaJiEySs0n6ZQjO4QVjj0KmPgcjpMYrxKhhmNdo2XpXjErNKEeDGlnJPmrRawUU/oYfwozHVWDdtQyQQD8vdxuYEoZbUlhkUvigEoXJGshBQoyYzSoYgA4f65w6kFW5ZN8v23EjM27qmo2L+YabgoIzjMl05ZGzKYkqb4+qp+KfYN4WWYxgwKyEXSlqjSYDWqaRWTtvdJijPX1GpvV7yeDndITY+BTYmo5fIitfrFVDWZrgFaHxNLXZp7G2jHjLn7J22/DH2hW1c96ocEBWOOM020F/RTZcTXgF6JjsCB/957mRdtWZrRGyJdwkjNXHZ5icR+Q9GtKYMH3Trz71SioJenbFnYmXeGwnU7nGqYWJk6NY8tGHHQQWdU9pO66wPizfUGlqkNKgTnC2mG+R/DPkAR6NseoxGXVfIwt6zXJXrLIvnww6kCxGfVeKmuyTkPMfrEJcveQXV8PZVpDrb9tFgsaFhuQ9Jei7YW2vYaBul4jRPleT2Y6EGYjU5DdGXSd79QnPIyX+i/5VWVNlQkCEeDWhP2FjL0JLWbN7prvIvnc1ISwEwjfdxWANETRoCz/Wh5zv1ZGFiir5RqITjL2yhNUAjUBV+f0xsKOfSlnoNNINIJcZhzPYBgp5K4rXVEqZX1+yQPDuxUMh0jlVIhI9fBkMzx8yi4LGNjvwo5zop9De9aOQz6vxyBx+PLxe+Gw0lm8DOPGXL2QqF7XyC5UVWsmsGHD+Tyq0MhqNB4CN0uYHM6CHZrfeF7ASuJqIqPpAk5XSDQ5MqzXdVeDrwwl28CISw6YXj44ZYcoA5XqBY9E8fGHn+T0Pkq7zN0GCRU0FAP0Of7LhwBE3dKzvMIdm1RgVbtVNZTKU4IIwn282cYSFmOipgUYSoZfFlWW7Xws31IvUnn4hw/zhNACHcj5EpwmeEFd5waeKMMNdmbyleOxNQykgJzOWkJONPKG43il2R7jzznz9GGGMV5ATDvAaRtDyu86lbqcjmJTgp3HcRAXh+ZmHN5k4+KT7ApN57BbrMiA8dxf0SPH9ByzeTaL3Uhi2wXoB/E4VkNx/8aYTsQU40Gq9tqH9If9qU0H7bokC2Rd6Oli1qGu7etc88PMaAiacGHFy50/ZJYzVEt7YlfmzZExHl480l8sIOShKbHfgSY2/qQCQ4VR5rsE/GfQo/ztG95vQLS7ogHizUCski6zGg5bRWfO8T2NpN84uBvXK8JKGuMhOvo8GFnVTm78LKIGf/6nvEm5qgHceC/4bsb9MA0HVMLX0GogoZlNHdh8CRfaQ1nSnyhhVP2CjeTJr0E24JiUHwWHXYmHSFqEFu5x060qJYrX400Z5FlJUbwnE8mIjc+7psXg3R0ltgIo5wQLQjuLjmbAAp5M6hn2EZiSC/mzoUWA6vNOh72dqc+H9pSwP7w791Y8Q9SjEaAFN6DiMURsHhbfVAO0012cQLTbofrQFS21d/3+hdSX93kOuQq4RZDxauk6eXK5RASm7G1HWWRn+0UY4AXeVX7I4nH7Bm8lI7QRERyUex0gKVJTIw6W9KimkPaqf5ccMFwN/Z6GoOdXCKf2Zb8ZnFWXoc65bGsibDP5WH/V8jRiSqTJDF1oZGprtrJ1ns7FrxQUe3Yf2UfXJmsp4xrOzXIbZnprywp/zsad0LSC+7CCVwum2PSE1qV3pT5504cUAxrQnYm9bLQU83Lu6X/dXf5cKocm6OCeP3ngj/t33eG04WxFmuTJHMYrax0CpJoS4fn6TnLu5Er14d+e25qFMH3W6bTBhh1qe7YoLaffAiLkV79eYG9FATlMVcmHAtykRW4hb6SW8HvE461PM8vOcTN1SU95FK6cKDimVZy3Jrh0JTWVBEemq9MegITgjwxgry/FdHN2l3mxS3MXxaBarozEtUswVWtnwxyDv+g+omSiAFeVI9O0EF9BjaM9gryVFt/gm4QFuPO71IcJs/aXBDMtgER7y2X7tOp7PhEw+GZjmA1+lBonVUyq5oMbINCjK1wR4vb/NevRSMK+pcrHaPepi+2wHvke5ChnvhTXg/Pmtu4HbCraj2hx5H7/T4m+v4D1Y2ivVEttyFldM10si5koajgDA87at+BUIZOVinMR+7b24BA49aa5PhykMD5zEm6WaUIsztDDiZNgwVyWksX1yde+tXGKajLXQUJKGeU4TK/e1WtVig8jTlJOQV3h4Hym17esfXTwehbFoCp0x7jvLh5A/2AWiOR0UPyRNCyFV5Yactk/U2pzaahiwAlTylv8l2Yd1oGoe36KVNrh22WF0vzQIaqdUzMYR/ptTalwmVDwhGk6wPSTihcktl6YscY14z/cJcpyMqyrjeNllr+47MwjTDnARt2CW+O+2yUpS9PrQrV4Itp7YgAMotDphq0nyDBtgDBIymhSmzenGu+MjIFsEZRmoD0ke7OoJEjZwsrtydu1QDUCHLiP9JYeZ9RlTjYAHym1zJCvIwmk3C3mSN284slEmlyGonCAKei3a5G02Wbvk3+bI4Iztx3OpkmkhesDIaAEgvE2V8P9lzxIa1HOfl8SQd7h+QoymhpkuPvkopV5JwLXVP9YcXAzska56aMPUmnf1HQVt750BYBDOHZtZsGPzREzTcfX4O4irvxJLGNVaU4Am3wHuobhQ5fb/O1dvO8x6omDN6sckxuyU/Ontd32kDW3co80wchyipVP9PSp72EIOtPNZOLrKkjbN527MdtsaTAVOQbvJ2tCSbucpNm8eEuEcrv8UdRktZAenjfTIgrxaf2zmslpF1w3FSiAFFVdrAG8jIyAyzXPzjFcBSkSgnwdBTIrftP26rcUMgRFfRyb031XqYpsHZu9vPPu3j9CyRwqLTZxoQ7zA+xxud8PwMxI9nJ+Ye/MHOWR/Qfhke5EnABLPLP/5Cpfmb+iBJ3QUrQdCm1avoPwCWb/KwH26er5QTwIzXM3Z9F8skU8EyZZ/aM99DQxbWoGqlC/4PKG6UM2+fsyJYXG+m04tWCwbscGA8EtDuTuV1ZoK6vBU6nYtHaS2VVlHRBsqXqAxhQseI7G94qVZYxEXj6TcYLJjXrQbRIukokxJjHLO3I3+68OcAKKbR+FDyQvXZe6FkXUXyVz8IMIk0v0ZZv6dHayWcbRmTYjyZUCfUv8trZgXYRrYD9KzScavCw2dVh5KaoZyxi0SpfR4FK3F/elm1lp6kClLGWv+E4LBqGKJZ0xL+FZIWQhr5LezS19N+EO9BZzXD3I33f9YKCy3dW3zPzgGaXa9iIg0JDjqhNhSv+I9DqcZagJg4V4Z5uWuu5aLYqaXOZFk2wTBI0i/Lb7PnJoGbeyWTRPMkE0YFaNRBRuQ525nahmVoK+cvidQW18EFDxlRWFr4/ZjuISv/PT9f7aecSr6QSeH2z6G+HKaH4T1RZz+DIJE34tzHHOQQYkEyevL/AOk3wHEYQQLV4oRbLII4D8H1E9/9n3/0W3e7ZlFcVVf0wgpCG/LvvHFsHXCUwg9Ve5gs9hA60Com4jwJZq85AtBkEtP3Wifc4SNp3byoyAEGVtTxNkv7e1HufNeCMb6nrjoTVgT/GZ2JSw/paopOf2U6uOjj/nq+9Oz4QKpUy80pNxnU1etBLB1wOyZyIeuG8vt9bWut9WamMCx356vevWq8WZZfbCLBTVHDZE3VFE/lKQEiX0FekyJbS261EfxEyO0anWD4V+qYDCty25OFzBblZWoelccAYISHavgd+FNDsr3yBtQeaVv1jsNySt3js0eNLCo918g5i5cLKkxF6LUgOUsYfqs52CGt0EkHC+DHeeyBlLWaGlxoNjbXbCmtqikQS4+PBhVM99Xkw8T9+YGucWIHfd2FL2CP8N0oWXQpYUuKj+6HdOcTLo8whOujC50yGluPiKtlc5owJYdI+NBh8fwTFoWt+NSKafHwLr07LyV8KpktDoOHihAfjq25XHkgn5RKXpunES9d7clwBs6UBihC/GILyngAWo4DTCa496gd3tm7mRduv3yk5yTq4LoABFStjyUPJXASCzEpI1w/vYt+5dyi/gCurgfw0T1fKpQkqgp1khBIihgFyN9oMq7SsTa0eTmU3t63SQeduZtEpDbxDbe8xIf5CvcD0sRtYIyv3qSN6HMrR7IYbI5PE1dhzFIrGfIq6yFqmzG9qfbpnzPj/1chjd71TKsNlO6BRkUY8VzzTzwBx0958fI/gaaO4e0ZErL4S3FkbTdV6uZrmRLa20XToqYVsVYQi9rV3V6UwgJC6cplCVGh2Cd/+eycw2ZW2GsUkTBtYJXs6L7oLDVYAZNos3QkgXHff9g/U+6zNT/KyFCjxNxF0UKeYKLyW2a9yr1xg+1G9gON5CgOoM6RC9iAWGiB2U2D0EG3TXgYXAMASj2dPlZrBX2S4ouab7nx4oLZpnj1loambbiTAnVV2GlbxqBi05f+at/nh4jwdLy67s1Fnh4ghW02VZ9O+qt6JK2s9qefEpNOp+ImuqWzSQ9Yb04tiiHkRkBfKWHbQvzEta6POTTScCntf5pP6VNQ/4dYwkKUeuXyIoUx3BMZSMy3Tomyhg8Tj5T8RZ70GZV0f+p3ohCZdOMdOvqVJctIyh6c0b0ILhSoRSn0wQgH70r52Lindm/NO2TOMspP38LuJvQwbMX4aLY3+9snRbTfikMhfi4vl00rS4T1FIjVf6fQ05jbERY1V5XmJqkjyJNJg5libaNflD/p+4gvRVB4ayVcaIZGDg2P5dVkOomqMYIMFLORNElbpf4eUTxA6PgnP1ZUSzp+pbF42uNsIXCA6wpnKtGcF34BldlU/8B22l1vPEppX3RNZ4aCvRmBUqc7VZcyNYCNcsB4571xfQlxLm0ZjTuz/+2VxIOgq+b5xz/CJJznlplvuYDl3Xn72FBZFmRDzNynbVwwbuUXEBFZvkIImDf0+KdXsHsXRb/A/VPVDjsj+HmbA04HeyFz70YkiyMHfeQw2g31rvxeHIJVdggVvMe/Z3m7FyGXFn0DoKUdPJaDpXqz1pV+e0CdDFD1Q+t9Mxd6hCrpf6GG52v7CGczte71bmzZHwnN3F49UWpd/0R/iFJdt2LAjSyiVD9m3p5y+qPFtaB0u32z8n08SSeL8jM3V0PKsX8oQbc7aST5Nhpp/+nzul08W+W96e4GNTNOarsNnH72t8+O5tfUTYdm+JrSZfFfzP2F4/Mmkts8ssqRhQuxs2KPVFlRBrLvrj06YAPyIzTByEDFErwXF4BU/1gtsdA7tGe6TokWsrLTn0WAbBfNakdTmAorilS9Pg9WF+5ZZvZ+G+1s1wa1p8+XIliIb3/56W6XJwuGl6woTRSDr+0AknMEOXcxFaK8SXUBGQzSgWg4LaG/iH+dI2XCnDJC8GVxo2mDKragRllSmQxI78dQtfzE2aQpZ9JwgcGO25syPOYMZyGWwz5rFK8QqX7ZPOgiO2Eci7f9jUrhOyQp3Vy978wFHJ6CFGb+smBCyp2kaELDzAqFoaIQVjC87pjdhbjdiZWRaP++ViO1FbGGV5ke1yOcITMFAlBAcnAy8OSRcxgbgYomuf934+9hRVvACefPrJ7j7mSOQ3v59QdxylLkuk30lzQWbwSZETVwpX1BGIDp6Jc4dc5fJxS1eBH4NDofUCBpd1K+l8CxV3+Gdh2b/jH+xim76VNE4pSgLaT7eYR5XM2Sc6SBbLwCfAoHNQbzrLRLbNW3k7EFI/jHAYzVgKZ9SNVqa6bqetQoM89Fh6ERadmobMS4buh8FOWyus9OMeSBYpzTWIk84JFRvFKWUOu944KFBAXpVTp/Fy5i0YKs39QtUwi82t7aiyZcnMOoFnjUXtVi+f3+g59oLe7L5fMZXZIeVkZp0v0gdJGjUOlK+h3u0RTgJb94AGx7h1Yc+Tlbv5mWmLDcshGzU8Zl0szabTXoJXSop71IUQN04XDHI3E42Sm55fSv9XtmcxNJY36sftYjpPVS/hTh0nelOoXnAmiZYK535ETTXhJ6k1W76AQczR234qR8qZM4xZJ5hHMPTxM9RV/Khc9PmefTyrN7DzKFBlYUYv7QGYErKdqCKKBinYrMy0wUjSRZj88S8DugYOlgiswSDaKR1UaunAjNHjqADQ27B95i3lrGYcY+Qoa701EBbUsRkGs7eO/dnnpOmN56a6TBe2XvEbrxt7duyHG9OZNoVkxB6+VjEyRcGpGIC2fXWcsKp8r1lW1p2LzSRhhBpFC/gjxgoGX7qT9x447jeuwUXxql1RD/6qNcvEHfjcyo6wwL9P4opdPPl3erL29kaWxHj0F9HIE34XfMufUwOBjMMnEj7ND5KGXiQxl+24z7hmcjYRaboVskpp1KMWROPE3gkUkwEmSGD1sGudo5LI/ihIdq7ZCHWtiX09P4RFliNlnTzb112ITgTu9uxs80ktysVJQWTiccIYed246mPsx/HS29RJbR1GojFkzZE+QmG12vX39IYy82ezvKIg2paqhqvm9rVUU33rLn83zuC+HUyyfg9UzLQjU9ISif5+Zav9Bv/lYUVYMDnhnm+FCAmmniAExcELLxNEgpOXnYYkBCCplOaGWG4G6yTU86F8uZdJHWI1ZfKsKrQAxWa2QTMiEngfRRUl1nRUaUZ9CqN5DCL/1tYY+HScwrW6hm0V4O5PBMeyKYhiny2+lRiZj18GUDauGksgXwO4x0f8v6REW+NHYpWvpjXR9IepIc4fMliKA/ocVomplQeoebBsuZPYTodK6HHVzLVN0IBtuf6euMF6Fo8agMIxAh3GjNMZKyBUEmy4k0kfQI/ssBnycWwxp0KCtfVNk386R7WUoy1mmjLbTGBrxLnGsb1ad/gm+W2D62YT3dQKpEWwgG0CGrjAbf91IZwU7c60rTERGFUXl5it7mENClehtSoMmU2sSYbo6C6GSyZ31cUuKFqxTlz3384mp2ts1NFmVVKzkLEo/4tavqYkoA135cbciMKXA5oyvNg9ruNGXi3HfnigB8XIwoEeuQL32ikRf/xZqwEefCfo65qF3sufM5bDooOeoW3o5FA32GN/AfoLpm/4u/0vibO8Glj2kpMWdpxmIoCDDzeIGRmBeRal6UfvUjQ10ULfNfQyhguAPLP233oKjtSs5KJPwU1levYJegHLxM2wuf7Fr1WJeoyTsvEbv4cUn7c8DNGb983W14ZeGu8oXtgvd+Xb/zl0J1mnHfdhccdQSQKNQQlZ+JZnKPtSMyMDAzcyR0J30/B+K8/P12WtXhriDsbA0OXjEgv7afPvB9S82BcLdZYM4MFDFeKDahCTsAXGKVLLHNDSbh2UGFcLhdtOITVwuNukdu9TDJ2IIXgDzrxGEOp4KDIvK8WQ8tTxbkpLIeWwD9GXH6kywXgU51oD/ICenfr1tjnaP7yxQckKtoN0KoViYWoGQscQWxgDUdCdRFZ4ZaXQdCS1wPAFdThaeDM8td5Bc8nK0yIuPFkDNvq9xlQ+PE20kA7jEIYJTphvxgcvhPgiEzk28hA5iBOQ0uPwpA+SgVc3gdn7KbfFKsN0meZHLxWKG7n1HZIXtDzw65zemClgtVWaqGC+Eh0vF2sL62LeyGPLU8SfLktdsvEPJ0TghTTgC2f+kdqmhBXA+bRE+1y3w8cQbckvIND2jh5CylHeT+FjfebEp3MrzTKmjAgBeg2EYowPXoEL9Xzk/TANgD8F4gmtfTer4GL3bYOy0SceuK4y8H4Mcs8YN5VjJagr4vsq7Nv/Nok6DYG8qKe/EBTho9BhCVQYp2+jiyoVqkOY+eKDS397t+EgiREhM0qbqWL65ISXCMpQ2CP8Hi7QRfse6EiEMBJRelFU187E81tX2Ly0w9wSl9CUkrFIJRWobt98KaxrLeBk6VUQr8XXdZ+8d3XQ7GlCxVXb0bwe014nSqUb7S6jgpqxPQWG1EXS2nZ8yKKJRjGYQjWNmBzAD2euumKmDc6uzputxNXe30qT042Xe8L/WBlNvwfTTnrNNjeZ5Ic2ViSFypKExjaIlmLeHAtdvuqvx7XgJ0XlHWVAqImnq1JMoHykwvvAYA4k7SNkKoehaydkhJoqP1isz2+aaalBHaZm5rmziRx1y7XAIINBn9+Jl8g0bFZSLw8Ro05XU0UyEJ0NJEez1CQU8ibF/0rjp5F8vrDHraW5FeZEWNfS5Fu8Vm7WTehfIKwC1iBuTChg6jFe30cm/ormpu6zLM8ZrN76dkCiAYJRA/Rn9EoVtvJX04X+NnRsAOJGbuKPJnfCXJSr2elbqCgLxhptGPPtdelWMQBkeJwtN//d5FITgvbXSRldSuwFBUXOVfOf7AC9bsUaNakBQBy1lxEqwWxISuJFQdGGGqhL78cjHw9mtXIGnrbptrYVHJeIFys2zapTNonofeE01+M817GC5vXbe9oKAqaijlbYtQGSqPHS2A3Kigtn1mUrXCxmWt+kj2m0is/Yc9D4NFMOcnkkHbC4sxxSYYraJsk0SiWA43ZX35agofZIIYRWl6vXgkkWz4IR2keKqxua9e3SyH+s35jORGWuWsxwUWjVoN73HwTze2cw3rx+Qd4SbbGJUJ2h84ag701a7pBfUNBqSNECZmEf8JBxT2an/SJJ1s7K2illN70YPvuYRMuWNG+LLeAC0YXL5KQ1GDioFzJYVNlrOLdFITzy8MICpQpX/MdyQ0o1Dc2kd6klxvILapxajlED5GFsfCGzMFRnv2c2blncUdCZTPz7POMIsusKEZlaNHEmUpmcIyEqNma4tXsZ8CD3UUvgLI+dWaI7P6uWK7HYRhi6lkCLz0v/CI0ju7wb0CEz5rLpW3NET6FRtklCsmeRCdSB4xENfymmdqibVdTYvVMJ/nNRIFWaXOwWKZ1UNZNZ1sxBz/xA9gDNZ25YBPKGqcThC9jNr2wEVKfv5wcM8WnxdqU3J/CGakmPHwxl8AA76Ggq/r3nhXFK/8FgwmkfdP1yrXwH8kW267TNa2vArP2uhkVxQo20D9NVRhFbMnaGWww/JdUVx48J+hons+ve2y3uVP6y3+wTVZnBuN7bVvcbxzdaijroinYYgbvcO5sfahuQjjLJtCLnz73Ih664gCob4BJ1M9i3h8TuPBqp/oYSSYJz1Zw+Erud3rEiFhiM9LruXHou8xzvP99zvBOZOvldlgiunepfvnx9OpI47mYvSenidQbwJUE08RvJjWU9Qa/My0AyW6EbO+/Vxc/fBJaHe6AOnt+mtLHOJsYFLG76M+ojvXKLiHouuhtcIJ1Ck5l3rlF2nTmSl+Jvw6kKmc0+tnmL/oNXcHdJhrwt8hEXmSxnFJ4YlX8QY0EkDmwcqy1JMrSnuWNErOs68BQmlGJO5Qc4gcPglqo9u7ndyHjJT8Rzo8jKmBfN60O7Sz3DEdxI3wYTvO1onmMZEl3EURMebki6yp1UG7u0CGbukvAsvSnRgqU3QvKwkF+3pO9kdgWYCzwMXf+Vl53C+bIfB7ta5NzXl1n3lx7ceIIQdUl7GvFpJVMBNbwdJ+5KaWdWMYXXsCAT6lKo5fLEqlpGNPOLHvtBw1vJf278jWUE9eMsZ4RYM4fH40HKowu9/mup2sMzzNO6/JQEYyvf1e8LL21crc+XFN7xEjkQ2xECqkzBPpC2Wrlv7OAJYofi0We3qmGhouukLTCPnegXbKQumpwKoKCWiZn1SiexHSYQ9sVfWLOuE0jBbF84Q9Yj6hKYUZBHwliCDWw1RSxgxgmK8Hda3E/lUuslpN4ZUXJ+5j7UlD5XS714RMpzhpuaDjUSNU6kNkJuohzYylXhVwYdUBT3eBVAivhUZiSpdZAFPz88s/1emHjfl6H4LOfWIfGInJb4gVdKEVEbqCnoo6KmTXRIn4XPVyc7q6w7/ALVD710tkeLg+YH9X2V+E50ekP2qy4OAFS3jYpGKFW9gf7Y5m4MW+IVJSMzq+knMEU8a3K7pS76n+En1BUcwJtShe6mYrqdgBoeOlIHQE+RvD+RIuAop+w4qLQ0Bq1fUpA0TB4Dy0rcqbgoBEPSsH+dHkUeoAgMm/oOwVEOKvcSpX5c2+Eo3R36CfIwDow1j3r+utHy8PP4EIf3dJycWVHcLriMNFAgIGW6M3Q3qhuQ18umRkznHnXlJsN/MM0/9hGhnPCjfX1gunp36lFB8Z2cnvZO1rHKP9PdKvai3ccmHFZIGt7nQD5LVOWi5pbLxvC971Pn5VFZZ7jehDMUmJC5PTGyASK3rLs4cc9cbvXB//pYdstzROV/a7mApUzGERE3DCAhnVdEzh4712YBa4KI8/zLAZWwqpMPggdAqwxZSjHOkKGyxXk111GJfL9pRexsJVuIMirep3ryng0plS3S1zJwrHCzWU1QkTZdxDELUlUe4WmbhW+X0sj2h1JG7W+jQu3fApzer4uwQ8VsYr8YR/YUbDBN6li6XZ4ADUp1jD5RNFjeIVusfq2AFVtvSONtfThunEQr2xd3j6yHOBTKNmptcCysSgJGhwthq1laA/gSrddkCetLjv5NXQaXyqpCV8d0pn4wTxKi/TGYtV04WRc/gscrcrwnto+aYj48ygNXcHmMERREHjRSETOl+HRanAy7wp09PnZi68K8s3X5GIOL6YT38x+b4LEdHQNfbO4J2jckn596OBw1uElFvv91KBanq9a7chVeP4bQ/cyVCy4h4oiYXcXC4ay8mdagry9ZN30HgnZAyyptwMu2zXfVPOJ6vSRlon8X5OVhyq6xlRWxnDncVGxmxgpS+6WBSk/OKfHZad79fNYx8klXM8tsxR2m96bfiy8+z5xJijFuQBPJXAbUQrqRGXLFO1XyaC9KyFGq+kjHVLTnaq1Tu+yRRT7f3aXRzPxqxQyPuYoFN5lAW6t9fOCVY4/pl6yjjIwXgaGEdHYros1UsODXENViR3RvaNsmL3M7F8wyOtVbm5W9bthUYlDkZici2yjRToonoDJEFM8bMKpFj/iIrIecbYD4kyRDMjJCR0A8hKils758jmEPXAmQQtmQtz6OOEEfIujKkOUCxKPkA+VwIo6Ut9s+L84n1PuaUIgZ5u3VGJew3KVM2E4+PLgXb/ChC/ULJJ5lmfXWmFNrlHmDdA4/HQ1/IdlJXI4iW8xWpc3CQNSCkLb656YmlntvmI79XQOKKQ5p5yA+fiAprS5z+4OT7nVimChR6TAuY170OG69HQpLFtLUYf1eGHcPRMUVDZqamFKH12JjU0kvYs4jYpdqKIrj9gtvXNnxo/a7S54Q0VnI1D24uaU1btPqcJYkv++PMvSsKuX5w1WYKl82fCBwrRMngUvYhke9ba0SO4QT/qRSPcNJsgpy3jav0cPK/OPyDv1oaGK5qZd8VOwlcubPTIWiYTWimUR18gnnjU3VJeR049wsRlpE31itJtiQ0HXa0TekQa14buSY9RVfiwpkDmlHYCh1YR1NEfD8TEBlCF1u/qp2e0yBZf4ZPeRVYy4Eo+3zFZiSpXqsm+jWvHkdVOjlFMb9ouK+HBhA0AZaeDGtwTV8GdCFybPTq4JnSCBcL6MK6X2H5MsS2wHeNQUSVUGkpifsX75XobmLL5zQIp/RSG7L2o9erUjH+LisI6+NhHf7zfYLCvRfvh2GoJmeFRZ5enNT5lxb+VGERCvF8QPEimCWyIuj633weSCWngKfeUGk2r1tbuNOIAqhJKvg3pWWijPTL4TBocvahGveIUNedFAOhKm7bxe8kKu6h8dR0H5O2too7GsL7z4rVVFKeX8n30Fb03XMJUI9uE93y27pqAx5iWxGQWnl4Hphj+7cdynoae9MB0PAUi5DDN04G/Wgs4eaQfj3Hk0TX6fBl+soz4Al1+Hz4UmyTt48+ge3Vmd+pqyK6U3shF3PVk9WlJIJpAyI7ZB8xUtztCVJbEzf9jFj3v3+3f8ZvZwGJTnJEZvmtP5quWWR+e9HPnJzAbJq2ohrp5pcsfOaade02mIYrMPpvlWriJR0rJhYI9s9OeJw8jBOhAGmePx2M+6hmpVh8++JGX7P7dsh4oTX1OLX74vgK6TUWtQjS0wC3Lab5sR8ojAIrh7S9tvZwJg52TVYzJubc5Mjujhc+dWnXXk2X7z9sI9BIRJhjEOrV77F5dfBU6cQL8RuWFBXKBr9P3SquYA5JvkKbRHhPb/huQAyjTVB9GPvJp+dK4myz5wpkMggdHNqvh6QPYKZQ1LJLBUChs8LnAlAwwZUrscoQoHnlydXJLa8OUy3R3EIsO9s7mrDukY5VBAzF+0w30xnD9HzZU/g3KRg4/w1GAEmRmfstpDXRsnWcBVHnGFzVnxHSJoQTwMp4WjnqfZVgzQVb0rgGzL6OeunCdDGOOZ/AK4Wg3bC1nMRZkEk0ttu25+UmIEy5vJmzRww0YjnxqgsbrFef6HJUTVolHK4CFIhRJ3WSpfovy1IJOBZRMP5iqM1UoNGRrTZeWUNSx9QXDsd/5QaKSesPS7NM5glfw2aJCSQt8kXUy6/PzPqEMwl3oxPwGAJtvj0a8+Ms/RIg6+MjMhYXsaVaeojWqLMOwsTnPOlpyiU/QVHPxgTrzVnJj2YzMn7IAPy1ZkXhQxO8PwgW77Y9a+gq7GUbSIwLEHjwpngKpdBk4KFSgB0dEhsnXo1MPeyeSPvsO8T8nawb53luSLr6F+3NvyB++OzR9TlU9eSywtLtmi2sW4FfjzJrFKBcmatJoB5eYZPkPaDfJih+RoEpB70AlpOVi5NS1N2dPIsfStKuMiaPfZHKmKrXVQMtmVg1+a3pM3cH3xqNz1LAOpe2BNLn0UlvDC3KUUq9kmkF75qpCKYGO3vOCHWGSiAv2NVL9J4CoRPuz4M41b9Eho7nro2/vsC8k+aWpyN8QXaGJKv4Kfvqdbuklas0OwL0FzZpeLYHpfvDSpgmU3fYY+2pA7PpWQ9gI0LEu0E1oFDHekD9NMpn5dLexSaXKE3WcM8M0Q0usfs8vbb4t+5qQ66ZHXRpmO8iEEWoU2iWhryZnxRta3SrWYVVaqTtsfazKr6IgvAibUB1E5z15p+fJT6cRw47A58pG17To/c07Ew4oFBedT0AYlEpGq/IymTOuFw0QZJRvLkTPOzntXcCotTZK8TYqsGctc+yXNyQgdEB9Xgf6U8SWw1rvMxvE/ObqBqlQn1lDiQk7rFIO68l/UdfbfX0ygVxqLq245Ml1IPBmaie+igO9p/3iWBp+4ANrDDstGRGsv1CmHE45SEWoNqXpMZV0NoccXSsI5TpINKyr0CsjKgCuqIBaFF1bhVa2XDfBAO81Js5QzdLGkqHxJcEKUKvJhCtdgMda/vjW8paquE0wyhBq9YnAnehk3Iu6ALN5EBMYKvqeR4xqhO+E/LLW+WEhFU4dvRY/nojOgqs2Lts213QGmVN1NbBQIiGcJDppPneDGByhneI7HMK957TtAWoKqcAn2BzTgqf5D9vY0HknO2YGpNeOs7QoWNUU1C512BkMJZfM4ChLzpeWjRF3bTxeRhqfp4kwLa25jRcF8l518pqEoULZwkoKeBk2/L4CSIDOWOr3xSCZv3TA5iLET7LSggvKCy6bQ8ry+IfA1F4odQJet5qGdApT5RSZD8wemn71FPSuC/XMuDEUWUFTNsPgVuJGBuPErxwuD5tgwNRUYJ8J3omljGET7eBb1kXSOnAOL1AcNwh/twcBMREdmqFh3PM1bKrma7dEGjrbRf7S0VD9venqmihtsHfC01sgGp5dmnUyRGhG6bGs1F0Hms7NjjBjTHAKahbvtkMpl/lR+t7iFEQRD9lSkRXA8myJXhb644JheglrJSFbyIHTWtAzjYNq4DlnzWWEztBLXfvbo+U5kQkijRP7nRJQMt1HHrRT/iuYVuGRF0WqvT9YizhLqWFRqOYtnmArX4an0rIS0zEV8fnxDuJI8VY0GcCgZ95hJgv2iw3s2d5ddEb7OGJAkVDLKp3G0cqZyrrouyr70wIxqDvciT09efDjiW2IjCi/36v3Bl/AV/wGuXvXnLyGBaH8AqNyXPUim3vAEyYPCRnA2npZllBB39Xmp8nPpDKynr9Eu8ztFJSsKJNQ1ljuO3LG62/JcDk3eR8kmR7V5G4DsTHH7s5x9BOjUyzgLjtKUw4KHH8N3Me1hZDk0hYj7oXPe0oVZNW1XBsisDZuaqvvC5ByYlknVAbrLMeCMSoUknztJSBPlXrFUuXSSlgKQer8aDS0IPh2ysjgc7PhvOhJ/exX2DvaI3hiuLdmLS25fBrF4ufFd7AQmdzG2Fo1gCLL96D3KZNN36DV2IC0yP4+i7Jxz34iZybGS1y/FO7Gv8sysEo7g2Hq1UB/nTJDYlG7H59vsv9Tf1GURghJRnzWCG5N4bPihhNaomMOUQUdRNJGKkiEFMlh9vYeihkw7TPQ/dVGnAau+8VWJl2OXUsAldyTPPG/TauJu62G8/Muh2QB+6RuXWA8soXC8cfQtbOqXbpL6y+ia42vAxypzCSzjGXXkSVal1y61cCqM9w+mOEdjgl3rNjulB6b7fQ3Sun4albRGEEfxfIMPOVHypFih4G/k6INpkWH5ytzDJdcp0kM6+38VtPYeXz9huo+kyasZ1TKUScRv6Cfgg8j9xRxibfDnGddncfCf/d7/p4CxhmzIfpxuLCJU5Tou9dUTnFFiwJBOzcJdeIOW/g0C8JBmcODCq/WYFw1qU521SH+lTB8Fv6EmVodT0MZfERLGNs1XDF0syWgtgX0O2EZC2vBIaFra+c1gqL66WV0wObtbxXA81jDAPDc4QNAcbG10l3Y4dERCmPkJGCAHE/Fg5U428omSzBhN+VW6QPWqcEUKp8ch1yBMTyPWNreept5uIVi08eDCdz4SbMhvtjZgT0a6FYbpklsJzW3nyV5P9ep50o5tK4u8EJE9WoKXrz92Yi4zug48tPaHJLCvdDaIG0Lhg+GPA6B37tQk1yeHG9U7oZNJVVMeLl3jbUBlqlpiziNYberUnFBKkxXsriUahAi7KaMJl/CJVAhhRPmMAW6JRW6Q9ydF9PEWm8RRdHvNJa4Z1bJGAQ94qQLbG1oUbeQLE/dYHnYUOJSFRC74G1STXqjyYMJ3zzs8lk0/yhoPGRxDSqJQnOxgqYSQqO32aG5P91uWW7p0z79mWEUQvsXrj96tqpxQ+6nj6W4/S+gcz9IfsxFPL5u5ndMdyCHRv+0UY6sfPxYdy8b78XvrEdbWCZ1TH0xysKrLRVGiMkt7Qogpy+7rqoNHMWUCJqrFMTl4lBGOeufhfpheagrUrft2K1MRaL1wL6sGSwl5n1w1Bj2Kn9r7TtlJRQhFunYdqqfdYPvAwDXvQFGdS5xDtAKh3JYPh63PdZ/04BA+CDJSq5Df7v55s68tVddnyq8nRsPHy7aFRsahN/5WyJx3QtF00W/qzt7rG1m70sDntDyC+xDb/JzKyZ+2df2g4r4ipS+zXxrUukkBQvnRpQ+cyHopSWeAcVGl4rV1tROdTSmQxJnKl2YAFLrKx3YV+EWAXpssq6tw/0ZumckmWUD4pCEa7j9i+uBT3MkjODWlg5pm9XWBztyQEKJshmDoVizwa5B8T7eVuCnEyz0OhsjgIoIzT7dK8ew/2gEIALnXQv9/QV62hMxDnTjOlQ6vbyadbYqRA4tPHLlYDb/QkkqRAH+BjWYGro6jFXmAHdxIDDa83NTKXdTmjV600mcxOjgUD1O5No86p2TUnvLEepTwljewVLLetpOZwugziLKo3qqaJDhS0nnqkVXZa4bfPvFXqsydDgCeV3cZPTOAtH37WoobkYjbfjVZPdDG2q6bPwYY/SIbW1TuciakuLPrv+dLFyjwlSlVDZBmA29P/SzeqzB4uH4HHFxXlHpmIcVEEGWi56SRbgdZ8eIDLwWv7469ISIP7BGZAItkthjH1CIPxAGmmaXSvMSdY9xPqhi8RpvGCpkNk5F8g0nLjZZ+RHuJp0gspSCMcNKhAg/eUKLk5vZ/1jP5GeL0cKFUFbj54xgYmVBkocv8vzvXjGvIfeq5EPB4VAmWKp+U/cGlTgt71jCSzr0rPpGD8JHD1E71zEwnettKPex0J4gLDiHP9VGyDaywWkWclbgp8heWGNHV0mTQK0Uiw7r1pZBA8dA9xC4rpG01r6BcisNUxBpm5+DLnk8h/XEeiYzCK08wbcJVH4i3LTDVa2Gj4fvUyYu39Cy0WvOcnSPThxDu9ia3Czebw2PcM+RSkhLgWUo87nCTkWSry6ycQnW6aUoqqvSjxPsrNQ0ghIFX0isBJ9F6hc2eWZuPJaj9lxGTckJfzljA+E1Q1ydwRqIYCixSY35wYl/rfbITEsZdVdjhV9CXZfFZIcZOcQWs4ZviR2C7C3nJVG83mtgXBG4bt2U7QZwQFAh36CXdwXf+t3lfsmVhLFXMmGe7ILbBuK+hIwsDXx5DVdDjNEsXxU6SZhXt+PhhAVyF+sOxoJ0WrfNemmi78rnsUqFTY23iV4PPRhl50HVgA6gKzkEVijmZLtaIawLjcaFAj9UFp42Ph1s9fj83NmhahJyp40IGXncYK0nzIE9JXVDqKs4PKAMbWQ9co0fK4b8m4HviRksZlrWsOKLMlppPLt4OwpW7lXxO2cSl7vQFYM8xBQPyBboB/vflE5EDW5lmpz1oBdChCE31C3I5K1UpcY8biljJ7sLN+FXIArQBuAtCLpfAFqQENxVu1hz0Z6EoixkEZSsaWIA5ShErfU6jyIBy8OFCsrFPg/lJnoT8aG+mLZcYDb0w08fKizlNSCfYgJ3AE/yJ5Sm4/bp9n5hGNf/PUgzzNPPcosi4nvevwRrukFAiFyhGtijRh/aT4bTnBRUKh6x44pXgmdUgFhGIMGskEnWbzDKD7S2EnvhNI1gFQDPZTJQ8y7qdemVPZ6XDpcehIxSzTzttH0sQgsOiyoykVF7Jfyw2fMhlgttJdNxWNilHBOym+s5qImIfAsp3gVIoVjZ/yrAJFuIKas57s2BpTNB59NHNuSGEU3o9VVNMazcFaHQrzvCYGGe/89pTYJb5OOFuCVaXBrbktA+QEA9W5tYEt7L1N6Rr3mPH/ZVeI7Yr6XbnEt0ry2ypTpw5HQvjD1uiirCzQUZgGxjjJoMbFg+oe2I1e8Ok7YQHrb4Nn3hSpMpw7o5C7embkIKvIOlKNdGTRWOMFrbGMRnaXoOg1R3aoG7xVJFC2VIA29UdBoDpbliQT/iGaJKYGkLj9pi2Ykaqs68iJYqUXBz37qxyzfAdH5RqKmAmz0whjnHPvnu2B0A9ntmIneI0cDEUcMYYFcN+zX4LfeH5xOxSmc6iDkEr/46tFqM9e7lwWnPWJ64cWU2eyApaLUuFOhzMnn6pdi0KswcyYCZ01+2Q4Q2RvfQEEv1ZHGRC/debzdteOSOd9T7j3N11vqIboK8bDNYsMVJ72SnzLPw8yEq+P4TjbL1VmsXkzS66xgGXlUARQ7AYpmtXcnklaFHVMjapCPhNdYBX1GseTb2Cx52AWaCI7IpqknssLJVopkjvYeoPalCUqOtbj0ngf6eF24M2m2zIpinJiDSUinvBvghGR1FAAx2yAs862MUZ9/Cm3A0ic7lsZBw9duDIpiYYJdRTuz0K5AyXsEb0hyuV9w8MaP7XG9FIuqu4nLY0tR0edtgCXAjw7kw67xVWlEeGtW/2JGERjefnjUzIEKLmjTywAFEcH1+vGWC/BC4o1yA2E0ymQKVSHPtaWX/Zpwq+m+ZbajY72SM0CvwcBByYyoZd3Ka/P2n122K8HicTD3TaMnM4hrwPK1//VOjK+WwMEBxpQAsBfh3gnxjrrVbOsnq361SQG5okbzurNKQavtSyK46hiLG5Y1lntVN6RRWeUMgZLTi5fcm0Ro0YbeaZmuhN25gwmoqXxg/OmuxU02BdHk4FUwEsYzGZt5K9vaqZUTo2+K3F2kt4sM2c1QUosbh+kM7bYq4qyD4KtCfK7ZHWcQ/t1g/pSEBnYCkxhU4g0m/yfoE262jja3YNZnaOYoTx5b/Erpoh6f26OMyYHGvbKlN6JrJxkz0NfQbwInF1u61Yz9PzK1JkddXuY8txDj0wEIPZ/vrCtjq/VsdCZtZxA9DbGjkO/2ouzTIC5tm+iNa9IeGxsTmIyuDBGt3bUqNmUbjI4d0LXCwHCJ9E1jh+voy+R9KnocYGVL7UU4NDRSphaD4oOft/z5EH40GSBN4j/Rx8khyMytyHDoKJGBlhdJw+xz0GL7yKNMEiBdsO2e9MBgotTxyBPVn4Uvf+tDWor68GWdXKO+/7YhwBBgFVH98MssvqQ0LHIWlpdSIAktalsUxhZRqj3byQQcTw9tBJTlcLkexz0rAsFKv27ay71eLpqDntpSAnpwAw0uC63YGK9gRMWImTcw1oL/6qB9SI/wUCAR+Sxg/3Fyg8PgmvYwfkdfTRhmx4ew0+WK5lfCfYUASBrZm3kuVmX5YK9dPLZcgCg45WwzYxevLLYFOX0XY9ovr2zynHdL87fj5Nxdb81I9dTb6GykJNFz6Mg62Mq/retMVQa6QJcbav7lQ4uLf9rrj3TX+hxiQS4R4H0wvVuy+NWmxxF5AipyIXFpNKhC3Vu9wCmghAlgUYfFYnx0HTqERAXGJcRBiMCjbHYSkw5Icyo9+eQRej8gDVD0Y4fTWS1jgwwG+QLZQljZtkvkI4+oB6H0QuVO5bEVGhUhG5e30chR49uAZLjonyfowCSepJQTu1gdZxGGyZf8gKCjNW5zOEb4VpE+F720NYlpz/XTRBMqxpgiXx5gYNO2QXvYvqBzfp09C8xCTTsA0mrECWUMGCOjuKz9nNYIenTz+uFKSdU8Rv9tkUSeW0zzCmqkCjSXWbUSVUsk9K9SHQ0c7WvZiLhX5YVxmAdR6z9im3aOrnHYLuMAoTy8lTTFAlLRB3FMTvt42Gawcpfcl7E//8vlqeMyUlmZ18bA4xCqRmAZTr1eDEqp3CqbeoutTCFN/ASHPcM7w1vGsFjOkGDbDfHhWmwVdSjDm+u7RxJvCzG1SVOxsTGGGybCcdFNZ2qmcCoZpaXicd6+vPvKmNT6CMGGT6jXaL3JMPOJBXEqf+1aII1ALHKlnS/E9qoju+sjMQnUxmlJsPVOJzXyoeOrX5wEXunNPadiJb/p8RetULY4I/NkAGUrOEHxlNaQHp/pyOmP3d7Xw4gQB4uesH5a22a1njNtqEB/zWZi6TY6ZCcoHj2uHK6aVy3B1R4BDSrquru/JRliJ6wbJGQvqaWaGZUGgilJ+/btulLpwPsaigyFx/yyNHT+I81eFy8+j61PUsvPXg0zQoovjEHByFbmwv+xuCLh4KcGAFedoNUmPqFsTLMJxlrQATuG9w87pCqtJm+nKqmVqUW5CZ5jzeOZf6Fe7GxHEeXo93N3yT5oEBYZpzknmBmy8oFLUuGuaCrEk+TddopmSfHCXFgkB+mULv5ijyPxhLOvVuEnkTPN4AG0SRVbXRbC0KDZZ/InQQ/ZfQzZde/8Ig7i8KVojhoFzpr8HpMOxNG3HoVBd0/yDVAJ3eXeQ5MSZouIBVA9gcLHN5Hapl7XJ9Ons7RHIYElMJm4kDxotex2P4QZFv0sJCyHXZcWuU3AtcV1S6bYlGnU2PRjzx2jDdSdRjQCug7L/FJg6ud6cohcKZVfMwOId+NafpzU+A9BRxIv0Aamx3EWwBc2R5J40RQzzkcFQSgjvyXqZAoaBbcEYUXxA4YClmAPP8KTaXhUC/Pes/qcbih13oUCX9UjZ2dRewMXZXcJBQTMRtD1mUf3DTvzyceIvA90sXI3D5iXwDAB4wOPL/u43j7/kK/66b6fGX44R4nZ0DKFfa/B+B0IOIydBvDby3rqpGBumSRk6i4JHw01hkWdpRlSMzmR8CjIToxl2nImq0B+UGVBHFNSVckWsR2DF9vc+Cw9YBCajT+XW8jngOEifnjZqaKKC+yhZBGQi3VLnt3qZFQFFM2xT0YnryxfuQtscgt1Os1SQCuejSjOKBHgKzhhmC/molmyD82VWNUs0eNk7TyptHGTIIuA3he/PzZLPyidExgKR62RSPFIzV1sQO7lA/LDynCC/muc8gg4Vh3bRRbXzyShoU83EH4WYJUnOmSNWaixgFB0QFfpxJxbvhXz3vJ3+OsWbvxJkFHnUisuMb6qSGUQ3ZmMsT5NCHOTWSt2REg4Takp1rYyBwiQUdO3hJ+WuxCEnAht77oUXzpEc9K4reFWyKFZeepchpDFeS8rPP5oAlxk+e97+1o+icK3bcyDVNe1CvURkkNWYtrFOfaQb3O+zK9K5cKzVig40djVO7sjSIKyXUxZfCDim+iIBzU79Ox5CqElwZdEQrnUMI+Obo9CS2Zhq02QrzeoNNoz32VeJAw0JcMy0yu7sX6r2MHrLPJQdr7cskMHynSAb51CCCZPihZBWOz/bAXDDCPIA6mNDQxOAzZjsmybtgadbNZVAaZjYSastuK9wuAasoTBC8/T87yWcvDOyU7UooWzLggEshfBuoH1DUg3chKcSxjqJ7SqFyLFPe4Y8VsYw2yfCTo9KD5RQ9slvDq+MKfszujg6LdHbKr6iJ9+LPowPHSi0HTjv0kCEvJu/yXdA4RPvwgWAoP0TQ4A0vsR8p3ZJkwdnMig53ZfSqz+miFs/corQYsXXty5lGlXrcL1e8D8S+yQRNNzdYgq3Yr+gSTmUeHY6UYMaJt7Hs+vUqhrNg11yDg5s0a1dokF3N4i7Spb4bBN48xI7n2LccYujAh/rnl70Ej7JSsJDAxjD6fdBFywn145w2jx+L+mLE/GkOXRZ3o5V7yiT4FkqsLtufGSu0KkS1I73kLb39Fg9Qz0qiXU4tLuXDKA9R2276qJUk6txQAGn+qny9tg4tBW8xqtL4h8vYpa7le4gSEBUJTtPk3MwChsYWEszGt6nBvqM+NydQ+Idvk7qJiBdseOlHjWZ0poKbGiJ5n1UwHDiSfeSq8cBZa6VzEugPeylrGC6GiDYT5vd0BjuTHHpQ+rkIoxg9YVwKMGuEMpsS7EDpqTZLW3t5EqdyyuNRPcFkCdBqhTiN6UAYrelAYcuyT6WRdcKX253dELa/CObtKIRyAyDogOOxOjglg710d9aK/dNs4PTtOO5lt1Nk739i51GthKMHhjMyEIAZ/B8wzpu2ZtCIbcbhaKwUxgnVQrZ/Z1Lknh9NQHE5gvPIPC4na2sHIL0XRxTK2e246JO8dyaNMhWsf9y7EvjHqZiwnov0r+qQBglOiY9NBO8blLIJCp4pbHv5ZNa5WlN2okvbllPGzBYRVcPaEiyiR106HwsxGYwEAgnqfObBeDQdGX50Obo3vTNKAFXhWNtu7GvHQoUzTJzdT2bcOjt1mIfk2wtHvbkP6kGDaMfMeNIcvalhn9nlcpG8sS79TdpiQ1PF9ENmMMeYQj+cJKpxCUnCjsb47yJhjaVpcUqmhh0kHDrM9rv+UgVVptzuAsFFyUdFj0EUH9o0cdTiTvuPUTTMUENjTHUOganwEks+cdQ4yEy1ziXcDlfaazanHMDONEaFqaSWAqZR+VuU/YmiIPx+dSlX10GrETYiykcUXRY+Ii/CI9LMQxhdvy/qPxTbc5iR74TjEHumN4z++zFnmfezaRut8cGP7rnL3TP9Oy2QuzspfGcdjA2KHUiPSXgPRMMxEp6zWbUcBlts14UiqMDI1EgbNjMlqThboAlVi+bty8KI9Y9UZHpgkEHLi2QErx1p34ycdPafJGWGqeQQNtbeim1pC83tiWZHy7C5R96kvvEekVHmr4SwQzt/ZIx9Pd9C1Zrrffw8dzOTRsPdDjvUMERZwq1cBe/WNYLueOBeA9Aor3tcAf1mDm3d3E1RV/KjlU/jDYC7r6yv5MLIP0Zgz00ngyI/c72TMCaPh1JcZzKGG1k38eyGV6QDYmqRuZ/E5oGCpZTiA+sMv2uZepDC6rquKhzCf3PvgTXL/XLVpGMsLO9qG6elOh1NNfLJZav2HmIQ6O4a6j0dBDolMPmR1KQ0apX+wI80nF8syuhGG+mGUAHdybNEt+ofM0VJS3NkWC6f7Rb5PcgmTpepQxDbHlZWl6v2sHpEetJQPtXl8A1RVfal+3k7QYyI7EH0k16PrYA0FYApmh6GOi1g5UGYWSXIFAabLCKOkagmdaZXxFmNI1pxzkRiomJga8I0eznBdqJXvPvvZ1FxipIQhu4p7NWdM4LqJQK7ULMptSpXlGLMSYM9dRsqLw6c9NXraL5+HFjeqCrMODNjaMSdBxTOITuvZUEJrFoLmsJ/D68Dg110F9iEdX5HcXpRQPfBBh0oQhPm1cE/PJOQDndWtJFUi49RXdvrQwHbqSJ085NgUXjLjb01+vB0lF9plpNMv7hISlQ4VH+LY/a97QCRp2Y6XgZnm/GQTGCyPMNSu1IPDmb20bczon/7RTDZXB8BPTfiZOBunjA+oSEWTF46ki+UJ9ePhlbaHJTJ22SohTbT2y+IJpIDuino1V51rqQ8EZeWIRfCVodZQVluaLu+FgkwPG8G2NGmW4ysdZcTQ15ZR78c+Yyabr9z8QfPPP6OEE/TQuQAdCr2Ensc8qQPSJRAPZo4wIsazHbpDXZkn+cfqnhGmG1cVl1dX3wC9G/4mgp2rpGVxmWXlATV9T87BMSz34qc4sFEbeu4RAGc/X6rMPFkoQAwtgP+ou+HrusUXIOZzD4SllVzHUwc9F6SZ5+wB/bqB5SkEGInKZ+ZPSg0zT/q8aRFaZ2OKcuPB8Vf+gQxGjHRewrBzEVJs8/XpwBy8kWukfXBHp+4WB03AJOL4odma5ZURZQrrIb8k4Uu0evwAJSSPBUFn0LWIyqUYbigu6kDkHVha8lQDpCIk7HcGAX95vVDqH+D4XIizG8lWZU4O+DM9uXuMWggxOETJ5QahkRrJmF9YFqUhGX6umHPRL3XnF0zUVjBrIKN8jX1/8f579f5AUUH2rmN+ovv9vqK/IBby6juCYNaY94UpBLJa/UoZs8nBNkW5Kh1/kp8RtIfVf9/Egizp3cBBaVEhhOgg8kE5pA07ZP8ptng5Q3t/ZdKu5RdjqRYaQx9HDGMJxo7nc/Ye4u/CJN/g5udCmC/nxT7pZPOr9X2m/LZ9svUYOVZjT290c0M/qnCuT+QnW6uAHKOHDalwb31FIZt6eHF2labyULLONS9vGTJuJugOJeo8MPC+/vPOfA5Sy1q8VI4JIORGui9vTMiPC6bSw/te91Mlkk7KpTuACTvHfWHzOLZErgPN6Q2jip0/iZMCxqA+DpawmxXHnBC5RulPqg1Zkhy3ZBIUBgURoXysSMiDQ1g5Oe0ybeEtcVnLi3qQ+Q/VUCiIVpPuw/JddetR4qVmIty79x5PZnWi4oo2RumTu5UhvHnydb9FjIQbE+O8HlAVm+hSs2zVpajACN41wdzUgpVs0ASQ2hH5eG3FXjtWbRxYQ3iIbkFZx9MyX6PwR1GxRGwAzohtvz0cMCnnHp+kKWFWthEirJ+WTaPn4WIZ3AGb90l6P3odDK7XHvCn3CzVihnUPqDNLu4g1jEqJThSyfnN4TevamIKPNSpwkhvcRagzE+PxsqHuRaJiB++cKqsdibXUa6EgHFyyy4W/qxKrkwehvpF5vAgoZoQC8UTvLChIAKDfpjbenrdqB/kBloT1rHvpso6OwSxrRt/KbYEeb4ZH0Mk98wWy4rf8uOdBE0pRfWr54Vhe2+MXW2GpcXby1HEbORVagrLkcgwxyp0578L14gGibD7BnbCwS2bkZtpmkbdP6FxRWdf6cQV2sF7G0etqoHNU9SfeC0bFQhuZw2NurhBasfzDahBdDCqDJQ0GJFGfuZ/YSyzMGObbkTwt2fur/IaiVqQdB+dFl4Crs7bPmR3V9IfFLhi99ibP/0olUoHWr+Faxbu/YA9Q2am1MV5uDI86nfF73/OjLqv5BZ7q8veKl9NnlgBJhR6oRvJQaREYJl6Ve57WbRMFquGTkitCvOQEYl02bkxplvezWrysuRhAo38+EYMQJaYDmjfEYkuF1lzPMB4m3zRtatbQfDHui5MoECPLQ2H0IlrzyvSA5UArCuMpWcIiW15+VCcE6KCdjuR2J6PDtNi5qYEEgBgHeIMElJb1RWxc0gjceVAQVOIZkAPpMevdhTsF0aazU6B+t1t6ul4SmbDy7g9y74ncKPDO3XNIOsGcpPLmzuTORp/kbPudHO9WQNXljSTQfOClBdIGmvcGt2i2yQPKERWKfLw9QgomFcyaB1wceY6TjzF7x8BmFRVJ5T9tu943C5tSkwD3vFUpdR19cv+suOSMzuJf3e0FmWNNasUhizJDxYS8Hw72G83QTnX1CUAV5BnYZ4GQ5TXiRfSLJmBCNDILLOQhVc+GGA0qbDkLS7IKEc35vOgQxu9gvQhzNvFli1c7HPV0PBXjyiuL67iAxEe3XnAZBYBURaM6sy+jqt10dRP3EoEwSmvQSRlCEmj4Jo+zKTpv5F5ooNYKvdeGg3jsFcO2HAy/JgRPiSN3k7e4PKu4ouA32zqUA0XK6GK5jxisiaKiByAKEdr4IWLcrr5VjeWFbHPb/Cvg3soP0makrmZSFCzOGK4mvihgx5CMDjfoSrsDg/zRHMtiEPGNh6xq/CuO2UFNFpj0NzzqtguSxfTlVxc2jZtyqtLDmNTcuV48HNFQqW7Em3Tg3Y2+N6mky9Z9A1/1Ciipv3EKp7X5pyJ8PkaviVMDTBMFklKcQSsYY93e3xocnqIM+z81yPAc/wAZgYzQGGQ+MYN3ONJJbEHgZ9RA4a5ONa0ENU2SBOPSwjBHRdabTfG3QubN0dPi4mGbDogeHzelgc+jbxA1zmeHrkpWf0gpxIjafFBJ+R15rr8bXiBwEJ+JCjceKiz+I7MUIZS8U0OXM6ie28/BFyewUQbLyaJkZh+Tj5XIAgjKcp3wlmUkIUdl64Aln6IX+cQr9ru9x0t2mUxReFhWqOyQKsu91mdL2Wn294cEy4r97JvYOYkhqBKnXwNKDGCS/coXdmb/QKzgr3DSmL/Ih/Vm66lfAmIyWa44Afe3Cfw+LPz8KMa/Ygo9L81QX4EPAUXK+FtV9Qafclh3r8EWtPDZ5sK4HqiIE/9oR/Gw9JO2iRnyX/0C+EEKwAatRhfJ2F/mrEkbnUwsAn/R+sLhxTPf+u6MhseZ29SlvR9RhWx86w8XG6sS+6Dzqy+4YNAHNCwNBVWiU9EBfzgFR6GgdMaqO4dYv47wmAGh77EsyYwtOaAO4nwOIhI5Q0/WqQdSJaVljUFcHy83jwr0JJEFDBvQDJPZTB/v9AGvwRZ8PPgnwcRyhKCDjgI+FS/USNzVQYNhMcroy+t7c3AMTNFjNfHZqrBCh3E7Q99pffAYVOmfoXQsbFGYL0/W1gvAl+KQ5Q8u54csm87aa2yy/vWDbC2FH8JPIszwp/6rsuj6Zu3L53qv3zSzPiDDuwd8OK0cr1JJgJiUpTpA8ZQvZJy/ALUArcFrHUMkntKea9oF6PF9DLI+ZeLXeZYB3uozv9TOdaCKvHRrzI+CCy46O9cGuN0zjUV9dqGbv+zYsihAt+zT3KxnWNqSXgukYzOyhhnC6fFsHNDnhwWqIUV7fVTjHNmstmkzW0oI8IUZrY0OVUUR/QZamBYuTNM/8S5YNtFs33a2r8+8l7q+AcOufXFHLyRzRGc0Cg2pABvdJwqFv9pPMkTfYIKiwCxcR8i/WzizE3wDgZwkXlIQ1QaKmJqkdu3G3CtCBs+xet4xPrFHaop/JcpjTLfTc6BltqS/PZL9S341cIJCwdUdkH/3pheItR7BcOB9KGNuUih1xHpTJgkIFW2DWLliwZrAdVbFXj/Wt7cv8xwfzNY0Cb9RW0JaBJvIVizVsgRW0stVteJyYCQyCpPNGMHVDU6ZDZM+LOBD9Hqzrwsm3kyOrlarUKdY2qcRSDH+kggv3WBN/ICp52oTpZl8gjuQTaBb+JC1d4gFC+H/u9P/i5bRnLD1X4taNu92A4790bkGjCzzdZZdAc3XTfAljahv9csGaKKe/QFAJvPqxq8kDVK95sOGPhfJ7lfcfbH0aUHbEfoVZZ2giG7tLmTN8Ttp8fw1IUhdPWHr8Vb4IxZmKCyK9lCPPIvvwvcL69j+ZlAlikvlIwRDkP5fJp8POUabB5cTY+Z/vFQJvZgu5jVnDtNLzeYV88AZDYHC98AC3GqNAdZElDncKZtHyag8XppukHlp004Le9VpPeVdcDnA2qZawABK1aBJMvtZ/44y9JETZKxKJTsE7wCmsTFL+ITJM0x/JjppGk7SurhoXsmkfYdTny00jX2hORWr3VPaTyYbM6C3oBZOPdX19sosr/lHLCN2cfOHrpcJW/FTQcy3LQncCfHOBE4lvrOzU1Ik+4g25uXkU8cIPjEz/WvnCWpKSqz7byx7vRmcrZy2oUdCmlQS4Nd5WA12mzctwby0gG9yHR/uDK6h0fsfHGSRXoutrvABwcnFK6PCCENR5KzwvqIE5azorB82EubzOMWUkhl0JZXB7TYTkZKJTcUVtx0iWP1SkN0DyoqpIOTdfDzFib5Ej4M6qfMNeEcQO548J8EncB7tLTLH5STWnu2GGHSuCsOs3koxagilORjoc+Q+Or2O5LPcSgTOwqhGnppOjwRruaoS2PTkyVUe2eppYcyr1DSl+iRkBhdc/wR7YQoopRoNd7MF/wo8lD5tCZLJEib0Mp6FgoTEJia97KDtNgeVRx7Ebc5d+5WiJC/pVO286VZ43qkKmwme06H8VMxpsfq/zofGpQ8CtaJkMbrTAuUXYVBbAT3ivRnaoH7VPV46u8Ta2kp19DDpkjjJTzJnfz9lhL3y7LEC/XjU7fwUS2+xaIcAHZ49l0WKQs9QNwO/9+Ta0rCXeW02clIe/daLp80UEik9rGx0csUWW4K5y5wW1U2o5BLa9DwEL457mL5x7cRiwZHOYtjInl6pRQirocm3i0AZVtFnqF5sE6kdIass311jt9I7R2lJzWHYIiuTy8FncJW4T6vbt+9UB4Ba7v4QMh7idcNCaSHUz57pC/4wZrRy4Tk4yVVl1BsecmACWRt/ODSesxOz6eD4kVRwvbSmziEHQaOT6hskP2uXrS/44WbyPookVKpVOdp8j0yWhzTEMXewHzAzwAz+NqgPBIyJYncFOmcb+tyk0daOZRdZTGOTiEW6B3su5+1wod0msahIxNBaSk50fi6LhRY07V509MgFuSXXbDnCCWtcgMxKkbY30vGTa64nBYD8oy5aRJLZR8TuvikJJCWd9tIgYrwKW4KgOYwdybsgdTrKIJRQZBAA/pMP78Be5Z82gbkMBUZCbbLNSrre9Kn7+fHErbFq7DjKLuegFPnlt3R4R/43M69lqHp7VFAAEbxqkvoynk5gREgiqy0KW4t7jSwYVurzA5QMJLHUe/RJ3gchraLL8RLqTkX4ZjIxQdYVM2AEzYDLhOhZV/16RIxZXNHxPPzp/yqCOqgdXwHcypw4wjQujhVGW+gEEjtN5iFCzEa0G0hsNXBNqoBeBHM/DjctjvLMmZYVxGdnaYdbOQ/X2+q/89eEnAnKxvAgeiDixTpQWA5LaaQN7h+H3de3rersC/iTqFEJKUy1UJlFYU6UNH1WscxzC3/dlt5VhiW8rpO7ZmVrdl9Spoge+hWrghDp1vJ45tyzBTegTna3PWGuMCUa1Mj1m07tHosFTXV0JzDPyANgoxwrMM7zvd4DAuAJhm+42mbJv3HQ7y6CFS4deQkjVb2ArrlAGWGV7NTgGHDKCwX8n3YH2MzNgyVjwrOMfO6XL7H2N4bAqkCVodXpFeGhVbFJqGKsU3zH6wZdhUKQc8b8gkEcGg5zr6g1hPzCJvUR8TelmJ4pt+XwSipuBL7FhjI3YLLaKHCe9XWm9GZVtCYJPxpQubVReDAdQKRkNSKVxQI/6PAZ1gJ3vjINq+aYoJuMWP+FwvU07q8p086RGqkZgWWGErXY0fciOv1fqEgxz7dBGeKHbLjV1H64G8Gku/mjwe9K/B1pH3s7Qb5zc5GesfrN8TZtFH38Q1V1PC1WSWlZBR3Mbh7b7z6PHS+GguG27AKn7T5q6xkjCiQNgMbIykF58eeX0yW4yRTguywRYCDfERoUmQJCmbI3ohrpxt5ce+0HbNPqkvb/b/uHbFF8WQvAqvSurBCxUSUwgvA0zQojBPVXWNHMVUZ1AVVx0Gk0Lto/y1ptgUGRLcUq/TaRAFtcZTdDGhVSfGcrUbwbzlIr+dJpS/A8UtYPse9jgMRiIOF9HiHdzVXSYaIBPcCYCgIX99llyGTxSCKhY+dDVQlWPnIJp6UacGkxBMToDzslTw4fnKGPlZw5oiJlF1zYUOLEA0DEEd+4ENn/WRtYTL5o92fcGHptM2AN++mmTjcNJAuGLLsrEF5jiU2Rj5dqNc+Vrk7ixE7mIjFAngHp0DWFelRLJa6tfNm8jb3+JCWkbt3gc3hmwOrS+K/W5bqQ9gRBhNff584Z9pBcwbQu5jqMY2gouj/MvX1BkNz91m6E3QIJBusDSjrpw8BEE6DxP4BQ5+rfltcusARXsMso5B/idRgFQs0i+vqSADdm589c+i3gFHBleASaL9+exMaNK9ZGaq9H3jglbra5iz6gskJMvBLMYYnU6bwlto9ECiluz60/hsyGX4Fk+1vRx6sqxRtXDYL7H+QB4UdjSxEGaYJnifpotV8UIHxwdnTVGCLZs9vuwP30kbQGAhzv65pTgNJynlVqQUhp6Zl8ToNXLiOsahinGABTNw+3MzrDiDlfZnMMz8w3zhnkMcFEzzmpd3OlEpiqPsaS4DA0++t7EYZdu6pLupOazZhTbC3+aRA/lVvXTYH+RX6U+lFUN9PtsJpjaD6JmTPPMbzXdBLycPfvPJXT/ut2qPy5kbgFgU2UbVcw+RwsZeH36LauL9SD3bxKty+YAuaXbtZGcGixgP4RAgfukUGR2td79Q4cpeKk0YOZplGVBgFAr/3/lau1mnw38DEGvwblDxCeyhUFK4NuTASijQoeogcSHaHTQEVGheYF374246ZFtTt7LfqkNrE9B+9j8jNkTVY3KcPo2TKJ2vuJPjXUFMLpDycB9JoLnHZfX0aN3Dz/4WOkTDJ2TGYB26gsQqd7sDwySvX7Y7sAT+dbJsyOWG4pQMErGIdhiM7zvjdewi5V4EhDB0NbR4GSUXkBp3JdaYT23Xke8V6geQ96tGgTntv1wgJmArFWxur83FVi4lfQu+A96lPuybGRmRG7/+4SYyRBm20YRwZGgYEE/e5ywHWM9t4FH7wKUGkYe9C20zShzPcvakizBqHGMleaUWUn28tzJauWyLak787D+K/cy+nHpwPCvr4l7TMX4FLsT15oI6kp+78AJwToEwtiLGFUguTNTi3gSerpxx/5WG/71n2jliG0HjdS//rRyx5zg9JSkdU5+vhGLJw3k3CXtLMYG5jMKcg+vbnZ0OuJMOr0YEdYGnpUs6xnPWT70Nhi+81Z+07vw3qaEo1fXBkYpQmSpJH6mDA2mE0TEpdYswpi/hNsQdjLLrK9O7HAaFxipUoAR/6GTVZpuJpEKxHu7YjB9VEZsvIs9R/hVwqtjNPoNrft2UGG6jxq4C0z0KJP/wJUxM8KdQmH0C+l2QxnJ7bxcsAIQ4Zxe1PKxiFysVfmE/XemTYozZkLz+qdMFn8fGfLvipsI1JUMkyc1iXOWFH1wCrrzMZkmTk/5ocvuPqlrIZVFkChYIQtBgRT8H414i0S9vVxdqKWViBzP6/COC8Aw6mDsn7OIwvE7yVkI/V/ximh/tJ/AHxuDw+a3GI/Nq1LsAtfUKfiuxMR+15jENiOFUTBDx+GJhtAojUGXRECtEs5Rm4NmV9qWtLnkFwQxIDeWGHb/3cGiAHpW7CI54JXEdIIqGGz30pi7XpmWU3d0XFkzfE+T690wc9n5qAWXc2yDt5LKp0/Kc3T6XCCiN4BdzK7dPggqWzhNonMWF5SyF6oNBo+qeNUGv77yMYgdBTmoAhLhYcl84xoxqNQf/A6+9HZDYq4/rYNSGe+9pA0yzzd+k3sR7GzBNNkqoXqA7DiwgX6scQw8uXm5vMOP49GqtCxY59hwpe6rJy3LxxrUAv3f/aevFX9vsyZDV0AMcnYb10VbF54OLFC9h/Tx9v8IOj+MqFpy2uSjjacwAyxInFxFVCzoD2w8hCgrDqhoWZ0cKdc/nEJbmcIEaT83G+QmOktr+nCPQ3cMlHz4BJ6o/TKbWhE017TZDDuTLEIqwbS4ULY4lV48lNyeC7K+9CUs9NzYxrpEDVY+mhxmhKCJKNAvJ8KUR6Lf25GX6ZYrOvzsVyEzrXkAYBRCHIrdzP+HW7gdPsciyHesOQAASdRTXQ1ETFW+WfPU+l79d4/WEW1Pf0xootx9busodMgbO/+5+dP90JRlJXx+BwhpWgxYufCDqLL+12E8sAgeHtNprnq8Iisdkw0iBZzQjMAihshDtNwoT1tQ9wmcQjs33BL7TGibgR0fe8bp3eiVB/mueZIDX64/wwqn+kzCgnYdxpkqlW6R1iwPM9RWLLFxltSUhI9TvWHisIcV3NRU+ZfSfKhL6RvjD3MhR7ogAkXQP3kNCXEp1SFwGIw58rnj+RFPR3Y1rhIDeiunf+FOw2HdoR6xpvnUsEaTZAyRmDFTg9v+5s5py8oo3qLsgKin2GkJhmfQrVXXij3klZJ7aaySiuj1BezMEOWneg/P638RhyGMCaQRqevN1jW+tHfffLlIgiLj9rMPd5zMQUwnhNYyWWM3VB+y1xNQ38EqD6jY8eWFYaQp+j23LjOxsTIwTVkqOjnInbxVeo63Scii7KzF6jtvhkiv7HrvybEdFzP5O7LPkxnnJvyxptSmDO604lQZMDXo9w0arAI62jO9HUA2iXTIDawcXjiSctFPG8WpmXjPaRhFAz/BCuevU0eD9AGWCra1TQ7quGc1ERfVGf2reIRh6cXsW2bvU84Mr0i3vNpnrX33pR99jT7UkIIxLlS0kG9enfGGwCI10/DQ1VZVPrT/ULl149lQ6Y+dBZ1ghCZmQzweuqR2+7J84xG/V2o9/i04XMBOHpeQiC00TtoW1x0hcjvcNo/nU346fBaY1IDWJY6AlcB1sYhQued5+uNtSPKyjwlzmEzG0e9VzQarPoWxhZc/WeKlEkE7/ArwC2+BAFU+8ikgjOIfYgUXCgVqLf8l7uoYYmYFd5qobDfbOy2Qo1cPB8piKFV2LYFcwLi8eqaIY2j2jqI9m0mRIMNHKicAcIC5OBgn5yJM4kawrcEu/ocGtisFJxeHQOcoDs+MTEEIHo8N8bXJOavXyXUtjVDlL+u30mAzxm6LyrCgSXABaQgVq5dM0DYzJPs3xzg9D7WcrJypOxVTJ7afbK9EveY2/Yj7zydsbgbBZyPwpvptvTdtCX4iN4zaXB+GUp6Oi3Gx+2AQiQ4lZI63lvc7khNfU2IqnLyDkbFMMxeFcqCBT4zsnTIhX2AZv1zt32ZybNLB7i2PFiQgiolJaD5OZP7+Fx6G97d/2NmKeW+GuCsU3iMnM3j2oe/b4A1QNntbjVh3O9ha2UoRKcpsEqiXBOu2duYxBs5wKUPtBKh/B+vxba2I9QmK4NHkWgqNSEMxXNKEpbRe8l/Et2mZnGVCNcr9aa91XwccHPT+JVcTu7LqLYbBGjhnzQfz0I009bZFSIK+T0uVTl1b8s74Kg7mh2xQleXJoTzZOjFIh2iPoQU9HTnCyqp5AKYUrXD2lxkv1YsJyMy0hpt/ClrW2fpGj6n+zYQXQO3hV4N9Ro3KmQEcMeUib8G/yMu6VsudoM9XsDFCE36q/uvM73G3dgK9pOwgC/ObtDNd6eVrhQnUttxG1Bq1lEqrfelesfOI5FXTSYNMz2BTuMsjwjtC6tNHr/yz2GFws+mPm1Qry7r2WYuD9sTaNfbUtQ2DtmtveM/N6GLsjKqDf2ZIro0/rR40Czh6zZOYfM8GHUQmmfYsM76cnL8W5UOgndLHtipaZHpzqqPc5H8ut+qCO1dptF3SydZrGykQddRYIzCPIPrkzAsUb5mKVhm7wEKdrM14APGC1SI4rVrQ9693slWA4d+m2jIVrIUmehRubRH/+ZN7eCQqiD3o2/N4QhdAhZEMwMvme2LCTlOCJItMfjLNIIHCO5YyDUsTD6bP5Qzp2i0RnJfdKxKx6TCHHBMj1bmuVMExJ453t0vo6A8Z4G70hiWC1AUgJi1+xfs+tew/7y/pUPPSMYHUjIszYDCblUooYzrScWAiIAkZ9V3uWy+Q/9WEhxfdFfyuSPUz1iBdYp9X6vC6soQcTqVTDGVFFvgY8u9+AyuyPrRmt2YW9MkMELxHLVRXlFc0zyqGpscuk6gHJ7NVSAWA+aMu2UV92ymin5+x2b3VKoZMGu9+7P3Ms5c9cGIPttcQc7rG+KD9HdhDCJ09M2sAi0Mo6HA25JvZ0JlTIQJCtdJffLW+9UApYyrcUfWdPA1S9niUUGYvOCulyi0tu6naok0VtUwtpNvsTsVtvhv1c7L9FFtzUBwrcF4b8+B1AdOyAbaL3NWa02J7d8eY8sii+tQX+ZpyWS4jWZluyFsuegsfmP5fNL5kjGtMuBkrvkcDRwv3spDfDdBk8xEL1W/FlpInDgioi2sGsOHTl/jvN2zl+/Bzfcah5/ZZZQES3RmV2bWWhIT9n3XMF6L0GbAQSiFrDjzUcFOxOVm31No4HrJikPFmD7OudRx/rKQNUCvVrlNCy3igzTRYK7GTZ6GfjtYXyKrh2JYSRWwN9npu82P9BSBkyRcrGJu1l8MMAzLQS+stCodCI0SLGI1ic5edDHO8KE/RwKjji908CvqHHiygK6bZPXTSK6NoOgFoY5SegHnHuO7n4HpNjFCMw0tWoRIv5Cqnw5Rna1awgc2mlloY4SewtOVnzLnyacwtuxVCFz8WBt0VaHIHhbSL8plo9Ux4WqM9B7buQ7yLotdFVU4Zi3f6AcopERDL7uCbknjrEXBjtu8d9aAwBOO2MTQCn5hAxWoWQuaPJLBvN+AS3BxRPGc4EWy6umsAcPis7qpB5uw880BKNakMcoWyDPSlrq0UoceYU2WJME8+AlPYsAyqaZatZ7pOUUo4VfgYnKpyAzavbYf5illRMXKZNX38mrAzj12WJVsqsL6alOwHijTB3QoyH49fOPtoS4oCNebae2bFOJprYgRZZokqM3o6WwwAkkZP5GFSWJIPIk8AwqKhmo5gJmZPkeyXrknNCWxxXgfSvIR3MyKNgAcyNdExgvL+Y/52UXb/QkXRP2ymo8igkyj+VetM52edZdrXpBfFbQjOboXIasM5e/qqJbwydiJ+cdKgs9RcJVzWcQnrP+2Ee+UpQJXl6NJJxQVz8C3NtrmRfhaIfh4Lpqaz7wl6Qul2JGaZReBYpvtQ0QBikezgQSumgsFKiuFPaPUf3uSflJCNPcjsA4k6pKuCsAAcvz/XBY+v7vrBzw225EGM807Ao06B6m0RPRfz0oR1OfZulCzaYLuBXIugaHhO+fZa9j0ykMa81h2/OcwxCMs6R2M4t+kn8KcbPy06Rmc+lKYm7tqLJcPXHagSh1HpCvXiK2XJSBsZW3LiIXGTQaHvmL/0GpvsfJE30RbJZs72hzN1ErtD8xTSO9PnGuaM9nVGdU+mh2Ku13yytzCUdIL95Av7CPuXHFw/zBNw6lykL/JsCUm6+FICGdlYcDSUlUe9f+PgCT3kquTeC7WrwVIcQcf4XM+UASqf/13+W+9iPhtScXClYzumEv0LcTjVP6Hb0IfvdIkNE26X9zvZO5LJ6KcGHK6y5lJCHvF02evJYFBNnAd4Nbuqhlaz9K1EbM44K0S9mFvXglncfomK36gzZvaIwkEtgv1Y5j7BpRJcNxreJ+aekR+LhNyYPnf2zDUW8mohdbIJd1rEhsRyl+iHuHQiB5dzLzqDP8MXpPDcy/Mns4Esj9HfuzFliWQ5O8SiEbxaQKgaLbY9zFa8bxXIUcbmNYY9F5E43yQhzzHqBGNxhGi8YlzV0F1awuFVPK4N6DcvrvYXv5fNZezr2axLcBc1Bgv7pepZHT03XTXD3RSHlr6xCIl0EgnUdh9FX9QHfz1nU5glg25/4tpOZ/PmQsGZSauRUKpo519NnCjkzxV6LTfuGtAYqxwUvgpfzh8tgovxgt8DfaMzbMj8zX/M50bQT97f5pWdAiHRz1in2UYti0sIAZ96+hJUGzHZQLlOZwhE9dnQnXyWM64hsUJx0h+afQLDTAD1yLOcdtQDicQ8KXDOcLo8ApE/Eg+MQlMwpOn8djuebKPSEJ/pCPzr6a837tlEx+TM0Tp1ZJ0xwY+89zRWHZzNOeE93vmPNRkH9Kr1j9fZt2LoQA9mSOQzLCkH3Ba+yqhLzctcRdOz77fulQkh35WzdUOhvudU0OpS17b4bdBuixn91UW05jy4/gjDGYAMZQ5zRejMZbjfgBz2xcNGXR6VcwtHxCPINXc9Y4nez5sqlnPXg8emfJGbjU+KgtWqjnKruBBC35YKeTrjtmaFPdqC7vW8hMJIGx7j5InUojL30ikDb+SzOI7fIj+gtQTTNca80Za4gWtFYGj52vyNQS8RF0J+Axv2GPaU+mVbzAkXjaXcbyVO8u3iiadmHKUWCbgDvkaGy925i5yq4MY/di3tJuqLuaKz+p6dKpdHSObrgsQ50JpBTxOzVWrU4Uk/gOwQEVi0yraz7dscDsuZGYgYKvIcUwzO733KLg4UFBUZ1c+LMQn6kRnsRjoUnprjj3mTz5d5+FrXkQ9NoH4nmddoQbXuJmb9ZOj0mzXKBwOAkCAgkgZkwr9z0u+NRE1G3lD/+10mWEoQq78PgCFc4LrlU8myxLTf06xNS7L/HFGMLL3R7KDT9C506LdUx0kbxxEDsN4Lv9aQmHKl6sae+CJsPKRaB7zdv+00TyykbL86PjW2yEDSeRq+KI8u5Zj8ATlJKOMqlrwjHO0lDztFlOskQgo0xGwomz5QetUmyw2JkG7AvJnPPv9PdMrAahAIJ8sgeuc5Qcs9nVf0qlZa42WPAVyy6HWIfz4pP4EPyNjDAj0ceTrb1iV/wgntkFPBw6KYg3zyQuoVqj0+0sdvuBFsl1uBtf5D30nwthIskCGxFb6bLzaObUhgjg4WiYf09Z/L6P4ja0TupnWwRsu0tgbHzVcmk6QZvHg9wbnVOYbEuMZL+Y9AjmreIYoKM4KFa+jAWDuddKxKFus2F1DKHRyHY928kppKpb6vfa1qhJaTuytiVkVO84jLhFTA1N1BjDRK6EBHRZ1kLoqInDe8IOcKzEYNvq2XPI+JHqTG2e4G/m+qHfJQ7otkpIPpRc4HF8BJEG7RY2yjpvI0UJHGKb3t5+fnyfpYvJUXI3fPU51y690jURMe5JuLOnwjgbNAuY1dV5kmgrD8eBlS0CYTc+z41WGxDFt1k7w8iPa0DdJFFgCK0z31P20vXfcVZoj0EQn1Z6Oa1/1k9EfApy3jsng9rbDbsl4L0zYB56WgJzeje1FR8txZUU0WnoWFnw5HOv8f6+UAl2IGlDipT4btr+QWGxaO1M4bLqdc5Hb25IX6Qi0+I5c31i59ZkfGO12RGy/kJgr/Pzso6iVrl/W4bv7enJG4mLxXZiGOJudYIS36iHGC6hF8EE0kJXsNNpOcjNaVvQ+R2w/jHzgYSd2I1nVAsIdY841cLQoHs5styyipofppzpDy4K+IlkfcWqo4+mGj3zib4wApuszlRR7pqvnVcp6+d3AgwMG5w3rv+lETErsB83vcz1vTUlOxXpulwC7j3oJyD+Hl8YWE/ui1BG5tntWSGTqysDKs9ppVYm7vb38eUk32q96eS/+cGXEhGksU5qNVeoS7l8Bixc0Zz2qwVws7y9A+w/kdTXGZQG0JyTO9juz6qpxdJbJJXb+UWVhZlMaZWvcEsaZwJzDmZnRjvS2Zn/VKbPaipuw6CtSsS9i6QtrOpaYPdy0wyXkUoxVxEbhTS+2EQl7qYB+jQ6Z2jBxVFRXMew7dLxvF+U+nvi0v7mtAlWa2vg4H5u/fOuLMDakM8P+C7ZS+4OWYJFReQnU/7a966zoAYStG6m6HNEUkQuryUKgwl2ITPBJHYT80P6qQKBEbz/xaooiAG69GV8uMMCMmIK/F2TRQHpym7w3TpPT0avFyzRJyS6gknNfeOoWqkYIVrYEiEcc6vct3WO/rvdimgwFmbCHCOANisLsMNFi7AB/OF6VWyGSppqgiXSTa/gpM1wCGY4+Q5zEFNmsdOxKta2TSfTfgtSp/NxpK30F8Jn+MOu4CkrXGw68+HKBtTKrRgStkQEQRA6SIZty8Y1VDRn+V/0lhPMozxaOFN6uPNGRAScJ2aPQIv/a9hn3nxafZSLeuDdhIJsZTHF25m3Xp50TwkEhEIUgG0HhsMWMMTJZyq+jYYg1ksbnwn3iMmyPtFxtk6uHH/IDQZu4peLww9L7qFO3uyVrNRQzdImfAfdaIryE/HjGheyrGKrDPCzunitRd3Y7DM+9rOof5kdeNobXB4yNffl5iXAnpRFT251lEMJFH4MMLg8OYtwORG24vsNNjMguYZZwkTxEywaMmGEOkJwfAzMnt7dTXV7/v1npH4zctBsW/ayckqDtGLOj7G5lFM9W2X+zK+mgt1QMV8SiPRGKmzWWEo6bfPTrAXzAvkQqyR9vCy0yeHDrEjTrTZyuOAwnjnIC4T9BwjmVykZMUH5T96fG4OIbtQbfpfnb6RONOeBMNxZ96QzmAracR9OIp9LrqJXGMv8dSAubcqzn1B4804wluM0Lyq4KZfOwfe7FoIkZwWk7diIyc9x5RgULO27ewFKk+U5sGJ3Z2xWnD2KEkVA8IRzP69yEMROFe4bC2VXI5nfjJucHcGZebzBExPjZjbiY+R7h5lSD95vKAYkdduElSHBWzxNUPXcDKa7tcYe3Tmv8RSTkRZwj4cT/gPgsi8jaSwskc065FKMM2cUQn6BAzmS8EoGMn3P1iXXWmjv/baHABcgEn5wIlkhG+3L9Kkjli/H5WTML6+gGg4UFWNEQoijFdLVTG2wkTr7Cs+01p8A3EVm/4JfeMMief5hqZwEeLIwUkVJ6+R1kFfWhqQ771Mfx5vp2pN2Z8Ufqv9J3hwAqcXfvLROhSWFEqSVbpJ4EMI2T3nMe3yNOs+xhxKB/Ltlo3HI0hLDiGs3xouz33rA43PFHxsqagTCKA3fgbKWjqJLcM4oyJ8mqLzhJkvwdYDzFZEEdyFhsT5ePzasYhLZzjCy8AYjSHUHJxnhaT+fbt4n9xuUy3Exy1G6LeRKfQxAo8h9vXSpqNmtjbmgniBWzgFODhVNA4NWmdHp3vstJdzsGJehYE1t7DTrlyBggVMSBTToCj95BX7Na3v0l/3zVwNKc8c8EsKUE8dlKl5epxkjPAUknVr37PmJsK9WZ3Eqgk92AMBPgtgj/dWaNnTKD3OqKMVIaoZEMMSjrqYBgMowTTp+i9XFLci/E6nkqCGl5k2qCKaPozOM+v8ue6m7IgPTam9sytgwQ2svjyVCuBixryIhmluoq83rVkod7N+X2VQsEAotprnDVs7Lj7BtFZnmd6N+rV4dcl/yh26LeFBqpMzjBC3oE5Mn/RTrERhCOPTbAS4jbm+6zBrWXLsKDit7urZpM7BJZKY3HcRKL1bgYXSunAsoxDh+r2rsTHMrHfyKvr7KMLiofcGh8N7XNAXFbKfCPncm0mfZIWm4ohMomW//Rw2UhWsffXdljIc8+rFIDycUNLBKbDtMLRLl4ml3gwdnvb0A6HYxRaWRsEU0cw6uR/jp8OdSdwNnqYo4Mc0j7/v3wAzzTrVTYK4n14843xUFaMEJIsutQX+qumgoQqCUOmyRhVnV7L0y6oq3zxpkSnvSylOzy+sWpAeDthZQ2Y1O8LVFYQYsfwVBJoC7Jw63gHnowna0Sy2xqaTR6tABgCBAbnu8VwlFLJhz82hscFj0CpnIxzG/tFSxgP5+VcqB/m+S0FAt7p0x/utjRLa2Sx58xKONQnsTj3pMmiEWrKHoLuUiTK1iFkW5nOPuwChm7Eic5rUDTvPUVe+5U48wEQrP1ZZnU8V9Hc/L2Fh+VFSGFqokgzIWR/52/6tdguEoZwTjGMPRFJF0ug0m8DhU2XrsiHpRWdk6unPZDxMa9rxkkg3G2Y4WU/zJU5NarYBZpOz9F9V4h8ppLavtZsJnP1CxYALfrJbgump6/QveZi6MfxdM+aQnwDf0ehnX7X8NgPqMwu8KUlU1pMucqr0XNWna5etamOMLUyGg2FyK8q7BcN3o6DcumiK4aIXLZgAnT6xL5Q6b+4ApmCu1bTQNDTz1BuxD+uJEIHh1NiLYrRZ1uMR1QjRmR8lIJireABs2PZZ1g8AQm0nFLWYgrAYzujx3miYZ3QnbqIN2LPNAHb+lh34zXmLd8z7h5G8rHGI19m/QKW9LcdE2acdcN9ac407/Y0yQp4vPlIw9CfASfnlO4zx0GfiUtKRNTrr3MBO2lWO+mTLHBAdsR8ZhdbhplMC7hmDfAF21QpOQI3FVuESxRLCSafRvm9JFJrs1fWhy0Zr0Yurz1+BL58hiwZqZ2Hb2zeFl5SQokv5iC16GbIfJmR+pikfpvH3oG8TdKNvkiz1QHezTR9WFRaIMmkKJcvw81TeLtDAEC8uTyo71YeuWH+iTiR4dbh57kI82BsmK7pSRsYZ3D089TA8vVt37V4Sbvyuk9ie7hYgAnwNvlyrNJYO6ZY8IJBDNnTkzD0ZE9qKQl1EBvop+uo1TUJyDqGmw/ig4FyyQ9zL1Kxvlxq4dfgL27B7LuyW6q02Zjt/ZBq6nbCUBE+XCOZtZ2dax5WlLAro1NA+jqPGeWcvkFt95BTPivA7EkSVytX9AzdwMKvFjkkJS8TTRlkwV0PyLnOGTXYNvaflfK3dCkA8JDEnTiVBNVb5YWARPTQOfyIXq7HMxiH6qy+d5KaqqiS6w2ffrPieCTFwFqSIYyqFP3kCUdCdpnMWStiBpZ4T7tBUZ4Q0eGe05ny3J67R42Yh1m85eKU1RkZ1QAaLcaruPI00AgG0v/QLtJiyk6+1ugJ0O0DFeS7OZoOXg7280XRPeWvJCepVpayB9mvm+PtZi0KsJM/wuh665GwcPX/+/rac+4xsCTfQLAPWfJGI2SpD42+QxtDbpoJTx4Whfp66/RJeP41+xqYwXBxGrK5vKb5t0HILFjJGfI93Z2+kdtp1gqcIkyQ+UG/I1dakUqXAuH/pN71LYs/T1bXMms8k/qOFFgo4OEs8i6PFrcjPb9D9cx7IGn/tQIQ0I8P2Sam5nRaIFd7N5UEotZdsaV8ej8QJDaw5L+egvQTMny3aRAiDew0Cn3SkY8FCJp78NVXyqN0NmSoFC673CRM8xTJPz5AhSG+tHy7Ri9FH8xsdkOc4bL+wR6Y0CQEGgXVHws1I/7JhI54k/nw+H9cTozY0MqCHor6UdsRssVSKCZsrq30TNhemO6UUUA+2m+zmGK+NWynDt5UsNbMTorsqXeHWBhp92luWm/hSytDpKHBMTppatpNuIb75Tk8eoNNAklgYmj6lh1LE9Cc4g2IMEph1/RN2x2NJsD9o6bXPr3GRArAfpEZjGb60OIERfGGKAPIjjd+QuGKETwIWOFmoMgJ3nnCXvlWykRfyfkfwo9lvc+Wjoza7L4E9BGDo3GmGzH2r8ReQp2Ilh/jC0Rtk6npY/SDyzfoOw27z2erEGpcFw/jrVGoeOPY4Rezi5r71dk8ivGndpHNiqpl6X1kn7BHfzj44mAHd+DMYFKvcHo4eytULJtj3oaHXllVlxq5KGeCDEidoNnGAPad5pt52HYb6zydpcV1+dOHIMkyUAoSv4i6r3bR3IBZTXviQ6H/x6heCldESgyLDi10tjrHfKcgBNS6jz/ZbLK0r5EJtRJm20K/2gMmjUmVPFvvO/wDrpNJITRt9qCNq13gF12COYSI+dyBav8U6ksne71hivQ9wtt8koPtTwGUYzghCXoVW6LiVoitzMwrTxTtimOf9xTqcDA6mkC1EHhsfE2kgKhySZTIjMvzSEImPs5aLz5WBF+vM3Yp8QrYZIjBcT1XXfN+ja+2ILmZhGpB7yS0ztYSWZiGnp4dcAlSRAkhP+Gut6gzQeX7G80Ou0cCvmcxnnfOQeB5PWTT4PjT2R4QDa5pXk88vElgUZ8OMZNglJcNCtFN65Hvc48r3WSJvWXswT9mKFhvte5f9f2Mjy9RAo19ajHltOO5bfmsZ47sBNue+UbPoL+j818v3hkS3HjzFM0wF0/ix6VrVA/hLXiP80YAhmhzI0xzdLRT+GiUfQu48sB7ZKVsFxMHcSOoCHDQwJnyjLMZ5YskFzo/Z46fFNOcxtJ8OPAEF89H/eBEa8dHjxGArDMJFSyxGPDdz3FbYiU7DRl3XATVLhlfoUD6cHtR7XsnBvICkP6QzJ8E3DqV0IkPktr9CjeJaNbEYRqs9mq4/gkFHvlsQWEa9/bVkd+2KESwXfEMnVPR7htsv2YjR4xHjnbtATl4VftpAoM95iiBEQnojWa9Lhqt2SZe24OoDm1hemTek5kGb4CRr1bPAaqtgXcpJd2GP5mNTgQNf9stD8m5WAHhIxLYusuuiQy6GWq0S368wchKIXcMI4YrNxCDQ64KRi3Z6aqBvAfWbWw6rLTmt8ZhQBnBtBKqf/PGMqzuGgl6yXN29KwUjCJHxcgydOgppRBosOqt3yzptO4CXYzvrVF+NRTIyivv7pOw+bGMkPy5NiXRIOGRn6QXOG6q2E87/zHFHGN2iqds43MHGIIFO2NEcvyoYa+CknM9+0CWirvlsnhsxCwqTTX1b7yd9/a1Lcn57BI7N3dlyM6Q90kzj8GxUDwDt/ppdaRZK8P8hVFXUpcc1FVJ4ELqLmD7hdiJOEWwjjBzEEbLb4TeXENletsySCpfSmjIj3NmrVK2ju8LrbkQnLTPSjm7cJ0VPIBFK5iO5m7dbtIaUoJhQj8I96++VGe//obFdeY6cAvn8F63ZMA0vh8sEcqLbATnOCO9SyT/TcJziXm5LwVEzxJ3e6s1AfNe0sKhx/PKTMQJc/r0lIDyksjHLOxbFAqEowuw98g5FSt8MFvuOt/TsvjoS/uVYUY7mhRP+0nyhWSU/6HWTg3JhelXu/6N1Yr9Hfv7wz64npVZadBQECxSfL8BKFssGRLdJ2+RdXRkAHAbYiC1JCw/AWE1gnAAtL69M9Q6uHLMLCP4c6xUxGaaCuzIj6kWzMPGjWap72rCPYGLdaiTbAUfViMg8beQNzf2gLRvGxcHpbh0Dv2dpCS3exdoMRpDH7A9OgG0XpwvdL5imgzjmFJNoyp8sge/gWGKs+KzdP89w5XdD/mMwdKSVG85I3FBLb9WU8mlRVpVlI5KtgNnMfPQyELI5HU05/zHV7aB467syG5FSanfVn6m56o2///Nc/8xw0TcAKZwDJDIxkKe/oMd7Ev3W7zNUwoPflRmgtmf0m8y8MzrbpEJGlXITGqLFwVsHaJHRBlG6/TS1DYGxrum9MW1OVKXZhQgVzgB7f+NdeMKdHh3CKjrWrp6wPIToi5ZW8cZZ+yKkuTG/js1kUva+N+XBHxAx+DSHG3zIZ7Hrx3zge6N9OTzjv8ruyNfmZTSgSZhmTeK6WWUNQAhihpDzgjD06qvVkFsnGXM9rnVs9ojOSavAI2Rb/SZY4L3ksOjvtH9eIVH0UtdD03OW2+GoaocK2Kwm75I5rnS4LVQL7Ww0vC4598mAcWuzmjmfM+gJto3m4SgqrpEqigkxeQv9FgRzZjtedJwRpCoIYFIl6CKSBIge1060rdGhVC6qZ+rr1IgYlTiGLEIyyoilcaxjB0DEvBkSVBIRim1jMZDYe/qYVHxx0t+xtMyneNWd5Q9+332N0vJMcURft3MMEWKOdpQ8EGnYsFdCQxJKpSd5sGhf2xtf2BYOQmZLK2xJ0WheAbArLWOMrgDiuV5gQLOJtP60PosNLfZWBlDv2SV1YzzQvcsbbL9ManQcscpQ1LJzgVxpdCqEhYDukkejyAjRbINPsAmo57a4/2JQjz8LEKQ3f3/Vt07lWaaYB+O9u6lEV56K9rTymoZq87uqW1uKGJq5rCvDrtRlqOez9u03F8epx0kff6LIYTRNVzPPLg3rbuPzrnY7AoGbLBje5h4KoWpUDwgGSHQU8aDFIIwVMDKa95u/dCWZIiZ4iREHgp6YSVZLyHcmZ4Rr1XSoI5DD8OLfDtSzUtLUUqnzY8u6Fd2SfD7/vMwHubVZ+pwTEQMyhVuGBosWlMbzjjAEI6zmzy2n+eRERZt+LHxhGiml9TZktGfQP2+9870czNk9DDZFczN525bOMvesJxz33P5sE+Svb5hY5fBkAGxhitPQ6Qz/RA/8eEL3arjqNXvS5uCml/vQpUBhZ9F2YWrmFe0P1lSJUUopIpo+wWbmVAVB9LNY1nuHAAsdYwoj4phobTICloG+hXZzPjhS3VAXG9A31z2jCRYyMnyWhKdzwkTu5nwSxesBv/qtsINz/Qc19+qUZIwi9+L8h4VBwpDlyie4NZ/64LnUDmbmbeT6do7E5g2nCZ1Z9Lq1kz16bAzuPVgNUD1Na34WUZLFqKKg+FRfqNVsBtxMo5z70YYCEOyAD7fNYxm5Xk3Fqrg4lNRw+QmnBRuzZ404l43W5JejopfHR38XHK/FKebpvswxczFbE7zhdAL2D2K2/aDTKbucsR2Vd1KFtaPr7vTPMzcOpLPogtBWfEX9lH1YaM0kqA9mMHtiWiLpNo09+POXTNLWbz5oxOp5BoviyDMKlwkRGV+NQHTkNUyMLR7Jw0kVe3qpvsLXsPtuoDcU+8QYH6IQJ/F/dF5NGVu0vAYdGZfjF+1sjWsNCwJNBXo2aNwLYV5ZfmelqIX06VuXEbAb1HgyhXF4h+9JBS22ROlScdk5pHiSia4jU8gJdkgV03tvQPzkK4d2BWhZiTym8lKQUjFgRLKSb/aHlhy0EFU+vNNmGhSz9XgEJANnuv3slpwo6otHqbzsfZVwrkQrJLf5f5P+UjSMzoUJVS2L58UtibNk3eqZ5Qpx4VvMOuikMnFuRE3Svv7Y2aY1q4/lhbDMVrpR4Q0Ir6eRkc4jssMUwWa746DMkqlU7YJwBQu6ICZ80qST/QodYBkJnJ2T8hMuLEt6byF+G7schRB8B9+IDb88od+5vJW8fTt8o29SYdNdiQnHvjzCuIUJlpRUQuaOYepqZsj5/A5B8OBi5J5qNGTTVqe9mx2OdYvvI2Xy7/HH0QZ9rPtNWtzeJKeQ0cGhw6cNX/64v1p3lbUrrRTMfnIVg6m4GPwcb947wKejA4I3JnrWclcSLGSsAW1k/1Y02Xi/wWOQtbj61fjVp9Wc7fo2mTtPMrzmTxR6X05+WRyanb/a1sk98cR7dqZWUDtQeIhqoopHPoz84mxOAB/6H2vo9/JjLRM2Y6FybtkMzPMZ8YTmSTllFiUnT90zRojq2RXW7wjcRwaDlgqpveEcfNNyjggB7qGUPz0Gs/JRpZR9VHK56iYX+fVjBqS6P4D8JD5WP5Y8Jnp3ow//YkNttVfi4wqXbcL+mJiXc8n65JxKjae5Uxas2PIeTTkHY8kIUi47PeWeFIhhfe+HyZMh3XLcn3AyyRA30lGYSyrgj6LXDyzr9oj50NN2HcabEcYgaOfg4KVbLCRKAK3pFYYJIJW/909b5nGJeBr7jh0BNQ4vAQipawQcibM99Ng/dxXAI028rRY4bLP2lAcjSJJhnCaSYGGkxXkhvsR0ywBEebaPCfiVHk0sz5Fe2CMZ6U4GIOrxaZ+KZGTkDf0hNagwdKJzusRWpSnhOGQmSQyFY+ruN7TNf8RpFg/Eg1V2Ayp7QKC3Enu5ByPjowbYxuVe0AuOnt2n0VN+amosjf0O9oyWy2H9RKY0tIWhN2pQNQ2A0ErDiGqTo75w3TEp7oiyrLsNvlYE9cdgV8CeUhd87lqVi6Zz2PgR55aPjH5rGYCG4SyAL8xFwKvBiO5Fn+3fO24MIOZCmZ3VCuh55nML4l85RGQUyKigRXK9uT7Uhy+UxybeQK7sGvWgGCtFpf6aOEuW0ZV5wl30FJy0THL+ozv5b8tsMVEQ9hrhOSCwKSN5cvV3ayZih/5gmejezzwCOwDiwakIYDb6y9pj58fCY0El7MRipSAskkFcf+D3EpQvklxpi4LGmzYKfR6yD0YQYxNtobUymEDCVhaEFUAAp6SY8yx436n1xkEjfl5oD+asKf91RaxtqrsPMiA/7ZC8Wxyjj+e5DzTN1MsjAqF2VmTDSVmHcJDN5E26IYccU9xiixoH1J4xbH0ejGu4mdDtibRhLDzFT4aXrZHB/PAsNS/MN2B7SSk1rwnWNKwABsf114xlOvPt2ajvEUsv6r9silk0fy65HbX+t/O3Jqu3mRL3+H0BFRhpoxZB6Y3K/mdZFsN4SS3XydVcj7UIj5fhYviIFF3Iti13V5V9xn1JYButqL0W6rYtZDocg+FwprDBXo8k9+F36UrGUnZSY+eoGwQeK5r+ARrB1yBfwLbvG3QtvlzfeaLAmn0BLQ7f0ZA/Mfq1oy31R0vmM1h2e9dfHxZbStac2l++Mk50wClrnjznfUnjEwFr5oRWaeRAsbLUmPuXSuGUbrGUiOInEc1l77qcYv2gogiZxKtgQgd8tD8VimEwMKxn9KTEL7/LQoJjYYD9L8c5KiVLqrLlJGo8GJUoK4K60u3Cl5LDE5ibKIzzpu+oaAvTCgzbwn+OXVJywwbTkih0bltUQfARs23FTeqCzKN1RXYALPQAsbIRXv9fIhhnm34aBOpWlYm/dWPlquGBOW9KNTUr1Pz0QS3HSIUV4DaKQbKwLvZSgtC27ixaMGYXYhxF1BwJ66eJmN3wtkIASKUQu4vfQYuEKPxSD+W6HP8/n0GDlVv8Db6Stt+Uv0fQGunsrskgdmQk25tdhNDXAoVcP/Il2I/YTPMhiEsrqwZot4mQnDiBfUNDsTSqDjWsggd+2ynZkQgagV0r1beDKozi+MfutBPe8cFylrFVI32G0cUiEfu2mjDO/sXhY6/bg7AfCHDc8COaRE6Y5D6TvaKPze8WETu1dA4FJtx62KhjGSca6VuowWRlQFBtO7uxVY89Rf+HJ4fBXFTXWJVeXuMODWZXB3mZcg9++7WTPYk+Rq+9FhU5z33ua6kcnao50shOqon3Xk1+7IhUwsd+F8WuOweG8gboW6BJ0TQA10thbnBgynuIefF89f1c8Z4gs70UHLM22XtLtZ/WfeGD6VTumy2daEnVr9FX/180C+93YjWMepk6LsZ5yQe1gg+Ff4L6LnB/IRMpdZDya0JilEqaQeEGl6V+Yj4ubUxoz8pmAw/X5UIPSljGItzjkEF2iq7x1mrDX2g462StpmCM59PMsPvbSc5BX0MdL3vHbsoH4oSvWrAehzLZXvZLVQmQ6E6iHQYUcoCuk78A1WGuR3Qshi9Aa0j3dHFUaorATC8QlvS12ClcWSOEi4aicZ78+GIBYDSG+1uXm5gdFgviPfUJnNQ4qteVI7pqaW3yzuW33/NMpngp0tC5ioPiV5CeyFrO6NpU5qM8RzhNbvfYPTzjt31UgXfb52yL2SMofvF1D6o9ljq5IItBfmAkJzvM2LFojudNQE+JNsk5whHnzu8h/x2+btKDsuln7uW0LXvH0VKga5OXFUeLAoYdInt1zya+vJUhY0QQpqXyQ/GoUFtZm8vv+pqC1I55K2tzVPor8L5XqZQi6x5JQGxIMOH9uplZxMPYnC+I2+WwFyNfnoVFvfp5WwY+9f4sbnKqLMNIeliVTVrGbiNNRKj27wgaySoKq7rtcJnI9mHtWILhGpfURO7bRf2vpQOTZJcXktYuEwIZUlaRQDKkXi0INfs5N0WEzJPCbHI7qSeCMsZYVqmanTdSwYhycYagBAYtTDUdIRbRzoVYvktVusFLXTUb02tR3/sCzeFNaTsW/9X4+uR/9hepArJ5U/Bz0dPxSwsK4a7LRN3XeDi4P7vo8I3dr66BEP/MYYIW1iqq42/KntUwpYBBdCGOqqN1q89lsGt4BUFxyuQGDHHH7D2TeUETrFSZVdeoeYBw5bS/NkwtLTjZzDEvh23NCBB4i7UrhW0tG78ZfTgiS72PcVaDd27tytYICx4IRVkw0yrlLTeNKuw24QoZOo0Qo3vvjKQrLDFQmFLPBvyV9MbvrZ9081EPAutBF1nhJSbmSz0VfPZ/W8A6yiEKclG5/iR++vjW3PhVEf1hjkBc3wR9HwgZzIMv0lF+Ha5bsBMgOggqnfZCgoA6DP/BVIhsoMlfHmirscEQEtXYrOTPAWmz64VyTSdYmtnELWPKQZ0Cos0MQV4cpmkFDoAlcmLuW5dseUqT6Kg80NQpRKPMf493HFuRQ7/Xwdrmzid2ABH6b/QBtPRWIs8vGhb9PszRZkXJ3kOHG+eLvxszgAOQgtGR//5Cf3wkOktr8V/iDf8UZpRjFedWcfwM30JaWP0T3SP0HMhyyHwMUW4qhBdtBe61eJXDAU5Tt92xgEk1lz2eGFMwHFHwsmLm2ulVlH9ifokxeVV58VivrPioBB1gv2W+ptzOj08tLa08NVwWE6tUEVcEX53pg+c4huhzwdyNLwkEl7pEUOOhZuKUXfHsmbgriOlUINi02+Vj5cB8F0P4opMGLd4zpDn0dXJ+N30FaEZlhGNJJ+ggCSml9RIPwE4b3oLkHsLyfWZwwRPd5QkoxFo2P8YSlZ4AYv1dpHGtetiN6Le8i+MA/RMPmJGeJ83CQszH0+zjn0NUVoToj+VdaJ5t71t8r5Ixwmzn7BGWtOybPqXGL1FO597kmJ9Tpn3dPu4pQL1txSaz4WZKbsdERJ5DzvQXGbhoiYYIuJ5Qfm8GaxTcgdESWC487Eazm4V4yRQqLMwm8jU5gFLEduplFO0KPDkXQyJv2rj3eleasumHD9dWbGiXblgvzqwi9pt8MSmW8g6h5I7LkZa6JAgqNLzeME6aED121Faqtx0O+UjhWbhXg4a0bCTD4haPOVj1TBKtAOfhzNt4OcoUAmhzT9r7ndXSJF37fF9SOOCcKCVx5Q+tJtxvjYbew0WWnWKcjw55g2kF0NKrKXuB68/e8OZ81TqMnwLtp5CXr4VPhvzfdWsJPHopxY5rHMFhU/2X4h42OPxFoxo13xtD3TtwQMk5k28h1Yu0k9HLvQ0kNEZKS9skFDqyUW+cbzoccmxczUq5FhjNcLL9tQyOVM2A07rRnZOBFcM/P2cn+tsKS+xuj9sAYyCCA/5fG2aGyf3+IAErvd/UPQkFGbF73ewvkek9esbSSeXb0BUpoI7osOy/bpml+XFNYuM/hqSoWOC5jokMQf0Bz73Loco47CMQd6o8RtwiOmrT3A4uD94KqVkEcJzTR6P+P5NBERdfBLhSkWNThVXZ76EVLVkEBY2vEHfe4hIDh6sQICkDLnwIYeFZpPzF3sMU9aHsuRRIinEMKanABmcr338ESpQLuPHl+9zjxGb5y0OIWxC+ct5lbPs41x0NKW0XDYw8EocfB2xuqVJ1DOVWM8W5tOiwDrWzLUW9DatT925aRWahox8ixYkt4CkP+hSh8SSLqvqTIaSBwsT1sxxgCDq478vbB+Zgeg5xhAXRadt2iITbPk4qUI0HdjJJmXBZ2pYT0FsbFlHN/rBwWV4oFLx/XFmqWXYQ+I+XNfYxi/6nH6S1jOovJCdSmnMLLcZxFBDjJbIBgWbA+6ixoHWWGptKRQUw6SGv57cX+s2Y+FnujHEHuJv8M0m/qFYCkJ+w/fWBnDV2rzXswT18gvcB4A9ZPEgneo9CSpV/GZ3vIsqBEgqgtrnLjsklZZ3saZIP19k3b9E4iiERfJOuJIAMOspZeQG/ZZOoUSferBACMKBEJfD7aBb+ii7EOPrfujn8T50C32hfb5k6bWrnMZcVn1lw42Vkv1BSFrKZVMt+qZbbGajecVNrZu0gVO4K6bumYHiDaxqn+fl0K407i++DUESp5A1x4M5kmgAB9w9OlG9ViVRbWttq5gi7JTvOLVrqHfVFaQHpN+zmNuWH8VyIXD9e/3oEeBbxefnk4noMD8vn2b+CQbgDVg5w3jXqT9rB2arMq7coSwG3inFfd5cnAqfpxbvA+pI57eEih9satYw+/8lUlOlKKDho/ds5PW6iMf87+M7NJQ+EhuVy17IxCQ4df6WTE66NnQqOKxGmKde4rIOsYgTDCoHVtSscrMt5o1WJhJaMcoyAmNrQ6w8L9YKgTxEGzn4RRexdc8fygm3Z/Xfc/v1Dd9VY0EcDrepygw3jJ2vgdoyZ0Ct4lSeZ9foMbRhj1fcldVsZQYBoAl9SfgAtiRTlIoMo3QmGsacr7WmJduV8WFLejKDebDB22vVNOuOoMl+TkVQgbSpi5RA8gMtHGvYGtLOyfjfUyQnY6SlvEks1+x6ztsheZZViScehoxYbTynmL8GibqlJ/auQC1vl04atiC3RJg1IqmdDy03mLPHhB5LrMsaTJX/AxhaKlmvZvokK5mm4dL76m5WhKzWhoXLCfTvw81IVCltc6omwIGAr1OrZ1xJHfNN36Zj63gWI/Y084mKi79pS52DM4KoBLrqnZzb6C43fwOUkHW3wJqz9db3caeAIidpuR+lL/oILMYr3vwlCEpLFx7awYFYM7j5pWe96QpNyPGXqx8XD5MkeEO7umW9zzn91ASLgqXME5/Z5/VID6nrx4p3h9rJ451cZRWBoC6jGuUJ4IB6SSyGhOUPn+NqLB2k+sm95rvZw0wDhyNHFwnyIRZ70l40EuBwql3aO4viu1NnwPAmvhu4Y2wse0Y9koi5pHCThDGadKGFpNgDR50ulTrRuPLSf0jJSc4kd5ihugYT9VNxfyaGlhpzsuOh+zsgD5CrHNeE6VC7K9GcKC/zF0qBtXg1mtJ99y2bKwrbBsHKJ3VG8xvRew0T9bygwfaLGRiYrKxIrMHQDbMRZHQef3A5CpUyW9ftD3bFtB6715ojsqry12dC0ICGqQQcWpAjyfsejvD3CE2baCYQF6YB5FW7jY4ocFDwsu8l2pccKJdM7xiWnkwNeA04Xb4MYL60GOvMu11osgUilWwsSjKEV/IHKJd3rsmStATt2hG86ayDVb95ze6uLRwFGP8IKJEesBoM148vcDonAMOMr9ToZq7hk2isSgccM2ZacesYwKnF858eAq56FyxPOf86ytd4p4C+uLrVApWhLKAsq1ygYhpD5V4JNDnI+ZM9R0RsoiFaEMr1lDygOHbrl+lkX2eYzrGsYsW+Fyc0LR54KBYYt+Ufc5EnszYSoZ3pbOkyltZoK3juSjvcClQErFJnEkGU7uxSpck1gMHMTynTHDUVDuaSeMEhS/Uu9N2Rva7c7LE7sl3K9XzXPaV5qrSz3HdWcj6trhwDwdeauCQEEas+50zkEKAUCRPg5iVMph0EKSj6uXYPsQ4ZnMNC1aNmebUM5w0IFYKPRU5hmJYjo46vB1Gck1PEwJG8mve/kURvDcGk+HNFCZxSMUQSLESV6XZ1ElhWIxvQrrLhuacb++CxrX4V1Im4JvWzOJtjnSZs0TozKbUGHJ95mZ1+Xsb2Cg0i+moC8pbeVoVJuQTYpdFnsF3l6rRg07uUeruo1+OqEQ+NcDsJi7DXYEcqmU/WJemDekly5Z3uu3MBcVxVsCMPeljScGU3wCBimZVZ4JpdybV2EiER36HBKQSGn6LenEfkQtDtekbhF/KEyTatstHouWoW8Q/aCttvHReC5JR98vxRWF7eBkZfUKexEAwpcjuOz5NZN/TE56TWUj4iku/mTstfJL/jv4QvDno36mM+Rd9tDOD3ySzBMeV14NK2yhz+anFToQPoo9zMadqYqApKulaD2g5kVqRidDnJYSW9Y5YfkfciAk28FDzJDeR0QO/szxkdOywjX2JOGufehmdVLIh5hp8EPi+Sb8IiMrOm7Vjv07JZ+qyodwq5y6q+98EHXZfijtXZG9WHhn/ck1ICzIv6CD06ZoPLNkuMT0EAFhMliUOmsNVf/VjLIuJ9Rq62c/PZMKa2iuO1QpiY8Y3mxpVF2lQgaGXZpT/yxf7F6CdgNSzSXqagg9NZ+18U2DDd5P+9i+Lb6wfycb+e60Yk4XVLr9wlmYK7hAAMAbJ4kFohU6aaDmHjSPLoo7cqIh0vib6ya6epCj5rW48YQKo9lKbN7lggb3FVulK0h+xQ9l22yiZhKgfZfakbZc/jVc2tUyfuWzQOmkb4wz//XW6ybcipRC2xtDPIX6bSLkYI5ksx8pp7yJJZgTSISiviKm2QauLLXPfRAqCOWAz01rsRg3nb4tB1xq0eB1GIqLwkYpXU6A4v7TjWhmrVo7zKooWdfq+7pjliHIYx9hq0KzP3+miqQTcZMHTqIu/R95B+gKhIMo3rs6FLURl/qHT+90zxHNol+vYhX5si0TWSYSXcK71Pzu3PQ9T7SNbwcii90VED5sNxz523ScIaZn8Mly4b4FMYekBavKt2HFjJ4pmQdERZPpzHdrSl5PquD+M6mKFkEVtwdwm5j8dH9yP7+7DRmQAs+RAguD25WOnS9A+g3G5wVkn15ex/pbsVMLEbquGd4HJhktIXWfo1hxn6RWoADKVVpc9Dj/XpxKVQ2HDGYc9M4xiGFB9lENHXMlYGZ/MlcQ3vXhmfSDQqiMXAFTjNfECsLGrsCP0s3Z6MRsVY08SPJ8msPdefSjvgaG/o+k/Gp4JfEGzqEIe+YJooNvDRlkMJr8XRDlwBjNelWLPoPNdeDUaZkocwjttkZsvqzSOKwj3opKUTvwTw2D9wk8fG9WMJ+Vs1QufMGs5XGG70H3VsBbbE2KVEhJQIITtICnMxRdd6/TBMTzUbLzFiFwjhzW2qAm2toHwX4iJyGHbwx8yGZk5CJ5BM8tfNZbOIElNBfGR4whwsZZPtPojSJ+xPq6FmKwxD1grHe0jEQjI5y8gO0zxkVA+LOq1QgXI5f9R9YoTXqIzkmAuBf9hjmfiw/MaiMofj2KGWH9PNeBe6LulJe0bVbCRFO5/fzpxjSdu2BpyEFQdOMfkRBAVJnv8uofvgYvxSvEO7oi2CgOdmn9ZGNTy+hS+d1MZewF3KZqfwarqlGtI9KYWj7h10sbWaHd2Gm7oG2ppqNyFdtswbSmgD7sDhWVBDwyvMdO9xtCwgx36ajMAFy8aqxJ9ldwaVInp6nhVFVZDCJE9eHHR680R6QUzbfMou3ZplhyWH2utPyYsuTGTDsdgxr0h9S057QTU9RHYNfAndTc1tJFtM8Wunl7un/i4vQBh54Ce4WcKm5EeQYu2eW2tZBVh/hf72TS7jZ5Li4wPT1zl5/VqBK6Slx+xWLoMgduv6dCSL1Ng4+x45Wa+BT3piXu2yp+4NssC1CN2CGLOP0MtdcRDsoe1xsrr4ln6AfzxWADiePVf4y+YPHJWbMUpMkOH5OZAsavhtPzA5rYtJwumygqipU+jqk78qhHGrnHjBHuHjeoH7EoPWzX537m+9pGrzq8Pd4pFUVM4PxqVhSezrnRyqARcnrD5vefQBwc1reoId3I7HUn0N+PLqk1hwBoj7UgtzC1nPSuIIAc+IHkxEN9AEY5MlViB45qpsAGpkOyl9kHIcrWxR7DiFCVWQt7/9/3RamqJyPa/VGeWmUffxc+3m8VF3z4BzvsphLFITOLlLD65kjigzM8bTr9C6jR0Xz86VvI4E9SzBexadsDvHonCYxGfykonWsLaV3BOuYCHBfm3dCrbbK0HMD0lL4OPu1AuaQyDwhXzI2FD7ot5CIESvP5TRBm/x3OrUA/hBobmp7lokOJy80ABCOjqv/BX+yi60YYK66jBA3IuNGORjFewxBA+mAASHUe+qi8NqUHX55A0jhjE38+mkRtiVq9F/2Ed9TyNAu+M7ZgTMh93GVqu9Yg4mYi2YIgCFQrtEabCb8DBlgYLpsR5nJEKRGFSVfOqla58q7S4cnZBCU+tM/rM4sNyoSfjRkttbVfeP4xPGrOxP655fBhviKpvfGCCUDZrgu7ohceDn5+enbZtCIHqx7ljUSj7Z9aml5Z/wO4wgP0fUjQl7FgUBWHYz+eT4b9Qx2CjQ8AUrCt4hIYF8j4g83YFfvNbvTasoxGklPTlhLfZUbRsGxcRylWx0EGJOP2UYq6YTFBzrLz2cIoujFsGCfwq9tXpUvIccfPFW+yRp114V4BHoAUp9mEOIhxW4Xs/LVsa5VAUm5owsPR0Gc+gpyuJvyqLxsgr6+Z6YapyfJstDHsVFCq6WwC1kunTot6czjyFmokHH1nxfvc/KE+IdMSJ5fErBk/LcV+qasMKNKvdYfBbR/mNWgNaYg3sQ9KEXUUv2AmDLnPPEg43FZOcS/1/Sxyr0l2aaJsqCPxCRIXDwZYLFm/uehXn/OgWBCJjOeJYWxg00XgAhRKZcPyp7dmfPu4ToF+SkL1qiHJdvpjpKiuv6yzkesJIr2x7r0/7HFLAYSUUAYzTR2suvBBLQuWRpk4hNHctSL9D2slbNQZv9QzarQ06ftoslulFSsjipuWeXmNvqPLo9vvrROsUpaGrsuey604SyhAcI9bb07K27wC1NkpbJ0pUi+8/fvapGGzy9K29CzuP9k1mekd09X8cYetxo4zf3gO4Syati4v49J0oYoYx1uHyGz1oM7iY3Lr0lD7D2ChSHLAfsunyzgKWg4sE2/WKizNaWHlu2VSKiPeR9Ye6PG7uB7V0/x4iXD43ZqUjDYYFEXleYBY7WsnwUPzv9ENWBYPeuOxL7Yo/GAsrT0VZDG8mk2eprkdev9/lloyf9Ri+kwdxYeQnaKe/SU0erEgzDQeGdCSEXyYlYrfgloLmBdWOA0YDCPdQiIc065UEIUvfetyWZPaC1TXO6n00aI0ldJE5mnoQExUnd6F5jXK7R/5SaN3GQVkONykOUNhLDHvZgpdrIaaJY+UFyAbr+qYevZgOc1asadIBPwh6zAQY6/u5Uh4HmmzVk3J6rNluob2DEVvTrK7Kc8S7v7LJYuMaQQiYHSPY9uMfI5PRmuXgio2+620ipC8qCAuWdxzaDDYW72QlOwoFtLrLp3P0py/YWoldjnuhyvGQGIM2CF5fwZvJW/uv87mLPUUrw3GZbTTShq0LUVWJldXIljq77FKNxT36y2sHYt+OM+4q8wwKDXsd97qpe0BnsNkt/lB6OVyF7o9dR5X2uEjwnOKwAHCsolNaXEQJ8DnUQLvnV4NYuRXZB4qILjNYCwfrcsqhmGTrrqeddwb/UCAKdmAe9JXsfuHXuRvn8JMTCZx1QJ4wmg/SLN1eG45Fam4oJUX/SboqGbhLCrldd8S4qmIxXdqGEnpE/FYrP6KEFx2rRSV6QRTMUHFx7787vR65ejH1nYpXoolrTXgAyphHLQ6rCoqbjWfSMR0Tfp2HQ1znwFEBW+XMbHtpfUXA7uzte+4MPy2/tomI3Xwz21m364i7cfyMZbcgZm9Dn2dG7UA87yrtyl+BpvkIalaI++b83UAoriO9aSNe2H9jFJnx2nTTPBhTiZ6DDM8/5oDdZEvehKwMwxi2jcxtZ5FCeCcfkaEfMqE48/aUKUdeE+zT1C6/dkCjGfBUqdmKyRfuAa07S9cQXfQtyU97OZRR+GnupsgB5KZi1sXu9ghc6gI0wA2mN1vIGzVZwBqjZaqzJVYkS3kGrN3+Nc9DNX7JPeH57x8PzdlPCyseGVq12U5Q64fRhu2/sP0EbvioFTKFDcS7xFg6e2n6haBfe8Y9MXpbo4vn5yZUreAIOFwvdVV9Hi11Kt2VdEaKD1Riru1Svs5ExxMJk+Neg2xV9Bx9vxg+L2u5jlXYZ81FXbmhscR3svA7i9Vin+iTmBOAud1QtNTOzgfsS8PAFgf3AbnuwYsppThGj+2Fhy/KM5K7CTSmMdvxxPivwqjfwDbzqan1JO7z5/QWOfDocrwVw4lpvEJDE9P0NOoiYjgGyl/U7YgZcO0z1bH2hhcTAiTfot9vQihZxfhOPrUQzxuG/Z9eL7r3EbmNPnCUhj4VFOY34XmlHQLAvWXi0weKSbqrfkhIGobzri2IhgGhZ0M9Ny0oPQHb2a4BE2dGsDPz/sVYpuONNlS3wWAHAuAi7pXiI0DNUsTbHHeoHwHmlGbVnZ+9Nc+bIf+3OV8vooak+0RIw/P9Og5bA2luyZp98Fpk+lvDHhGz9s3gUx+u5rdSXGhSf1zzmDEPDjnK//6uIFYafjENN5a62pyUoJlszxFqEo8KIqA92QLU4yUpRgQUFfQp7WnMdNFaoaY/6SMm9UGcc7m2649AQqtjaXYOrEJFYo1Qi29uBmLbMgRx9URNDiq/uAbW5v7CH2MWNiZfLgyxcVFn3McHetQ9aey0R1V4NcZXrtXKUcbv4eOMZn05BI5TBfv4RbdGrhUbWNSFhDqSsM4zXnY1e40EuHYpKXyCALLB+X+cpQGqnwFajl+Hcy5qMBRxj3gdgSDtMBUJppKqKTf/dF4ez/9HTjAAa4oD7hBLxmM2iO+wewS5ya20G661KqN0yQrX/IlpPzwq7YKtqYibahTLe17sjiuL1XPBJe9xw+WOhWwoDAYDYhrsfGjZw9C1+yam8vq4dMLMFfXUjFnRrVLk9/uNLbQlvuIsLfBWnVqOe7qkN/Fh1qnIKqLjh7HtkhGL3jggljdPNspatR4hdqKAJhSCc8ZMFRmM/u0Z3vlCMofd6eegVtU4KcO/Khf6kXogsMnSeixL/QliTmqonzPZUHAeoFE8Ixdl6ozdKMQsLcK8cC/eXhLSgLwIxJhhznQmoGhA4tI15FYy90arI684DRNGh4ACV70BEQVbxZYICp2oubce9/qB8pAt0wpewhah0xVdve7tItFfwuGKnMciy3/o0uIexwjclOpKFjm1crV40OVRdg/jovQPADwG/7T5idA0gXDnUaKrnLfuPCoJLj0bRdW/z0EJZbNKYvNS5WnimcZM4dqsbkIysq5TaAkW8GoI1KeOGsPb6zfMDyffnyBg+DIT8NjihmFgnMkIemhhkcXjx7gZxDvuagRY52GpV2Wb6oiRi/7geB9/N1gCdn9hIr8/AbPpmiQCKZUnikM8BlU0CZlt0WP5QI/hgmRpOq4aZ8MjRs4IuSDhKshLj+Mn71kCTOFkLXE0cm3w2xMRuhAO05AyXI6rLcHnKj/ldhsZsabQnRVSXqPh6concrcl3PSgxRGpZiJqqaH8EwrGKRy+0O3SggQy1Y7P9hw8N/EBntM8ZwEOSWfQoysWz9rMQ596Y5R69dVDiGKq5GRSmWgwck2dvHccQIi8CksOZbVGH07RHgC6CeXajM/DEWJw6Dwg9D5T8ZbsHzK7lfD6w6CVep33eWAkcW2kUl0OgvmtMfLRaSHmxi1OpojNm5rORdm2o99LXd3oIverWdU2EuAsa5Y+HkxrjLq3bJA1x0Fgr6QHEy027CQuYLlmsx4aNw3Irox9g+r6LSnJaDRTJ6oQ/VnEz0FOre3l7toyWw9o2rUyyK/2XJgMeVI20KOFuncWqASRzDCJ9YFKIEx8UXsQGRQCr6ax95HXYqVvyFvZlno6Py87TQ0DhiuAmtZLjMbKeSwJLhSziscR5oVxFzLSy7beBbhru8ndBlb827HsNxOyggOQaBF2D5/nMd5tZn1+zLw8FIqlsz1o58yf3kic0qXajcKNbndnN5pCiwH7buyt10Sh+ydox5HffmBvJP0/GhP4L2JUtfRko9AS0f/8hvUfBkGhNnIQyK/UBl0GJ08o5B6wXDpuvwXLvrGjz9LLyciaGiHVEny2c7HPNZuxjji9rwD7nOI4murp+7952JItI3LcW1FQUoeK6RpM8bmduwmF65hyyZmjPNi5imKHxnNchOCrE2xyOlZwejqGXQhLG29M79/t2Nb7s2F2OO2qvFWNDQpb3xoZW90punFdtwqTleBPLm0/z8AhYxO/XB7kK+U0aioCmN3G168n1GSXQqpQfinzCu7ilM1QJhAVeKvuQ2wyAwsifTWBv46696dBJyHQMc/hrW4iHkGRwmGG2U668vZYaG8yT+q02W53wg4Cg6ZaQHouP5nrG44DOx/ZOsDxe277pM28g4EC9ZwPeo6DSgunzv0jfjN/z+PC2U+CnzwI4JLUcC9iI5k7J/gfUu4bgO4UpiAnB4GgzmVSIUsLujQcuAvlMtPcSU7aFJUvjs+ExWQuY8jFexWLoI9dxKAHCJDXIQGpqJiOCLYPYTIwY61u+ICxmEuklq/3Ie6qN4P6E8rxuNjG8GLlbW9jU3UJ/9W4VkSQoazkOL/bjpf+xipr+iWPm3ULLJ1k1jZKNaPKX959TZKDQst69QzNCU23O3BxXdBbKuQc2dqQC7xvI5DtPMF5OA4lwZFrIYofWBusKTdw9OodEAC65ZsBlB1sAevS7lNjdlPszJVj4zDbt60xLSlIReXVqSsSVWGKd7qLBjgPGFzEf75FtpEG7sGq+PhQc1jmlMK0bRBZQos23yi+TYlvDDBdx8A0LJN6lL7xncjK+BF+hSDjvnAwI7mXjx3OreZANOb7d54Iq1QfZdwia0FpnKJNy3VcOFSYSht5WzW8/NZrjHYhX5jyp55NZOAXS3B3AQRuv270kdZ1N7J57OpsJhyoVOjnj4yYJG18QBXUEZm38iUvt7PWDILgXnTPSuCVlPWvRHSw2On8HoZ6bIOsVX3X+DM4TdGIA0+OIO/KwTY49hYBa1H/WNUwfwO1PkzZuKj1qJ4cZO6jw2QIZjPAyHgHigHICqQLcv0iFQxs5O1js3AAtPME+wvIKT+OFphmq1VZ799csxHgfx9tRTxhG4DZJX1m2igOhBY7nYztIpaeQ18wiuajkuDIj91bCA7k838wzzhW+biTUc+iJZdIYqbLTJmqA2YVofjZimwvH8GCtL54HQxmyY66ShDGkuRr3t6xvHEEyrk9w0L40LKUTMfbFWECR7wFOP1IEYd0wab1GgFGXyLr8Olvs3uc2RQhn4qADRtmqPU/DczlTaVaTW1Y7wVs86llMHy1X1Rov7NATpgkCI1mdCfynJM2+TyQIknzP3Jp44azU/YrgvvqIIZqMUHcuROV56FvzMdEkAdCcSb3daMADKvBgDNNVt5c+01SRXW5cau51+j1EcA46PQQUP5ccSc1FbqK3QU05wQsSwZ6QL0DeVFeeRWPSKJr+zRbvcE8engRH/ziGXSCKyU/jxEKQDXIu5YTpx4Jm4uR/wHAOZnQVhHEJbL6Y61mkmcBWgKd/LM2CVDXBAB8zFwhcr6CXNhW/rbq92GXxjMpFg+Y5sx5kMyYHBxVgF8pdKph/5A1RYMzbHfE/XRmO9rbi558GViRaAatr5/BccF6ojod0zZXXltEm0MscINfyx04Tx0S8guQzQ7jbkq6WIIIfKRu7s34b1Y02lKOXfeh68+xJyT0Q9r2h3QC74yK0VSKIByPOIqYz87jc+oh7PbXZ0pEMJ9ENUg0fd21ltU7xNRhEHDziJzRMZF/zaqraLLNe11qtdUpgntUBiAiXQGsBDucZnnK/5mRnW2qv5EYJmcdA6mTPoabJxedrvoPjrF8zfOxfsGDtKg3Bia+vFC/fm9vR6c5v/c7hYf83NFwJCMjlF3Ji3R4ftLMQBIDwC9RKUGY/DVdQvX5/53ocM53HzClPLHWXqc1w7W5qoyYER17e4IZujirmRmpOhymyvFItxMcDDbXGI6TCCfVKXs40N4krT4ewUvO0qRmosQ5BTKKD2ZFKx7RokY4BkT4rKbJ+mM9g8OrgnpUKk12xmhDpKPazfGLNTGxmmE/knlVGnAxcYJBG8vS1ceuLjl1+pJ3PkGBwk/q+PCA7SQxdg83uSGZk1woKPoAcgNSbbtLTSStXtxPqtZQlVJhHPKSMqpSXUCK0VUEWOiZ7Bar+zxS5ElWgakjQ+UoNQEhzZYV53i9lWIHKbaJDzottn64Y/Hd8qQvwOmHivdnpDYN2mMrAN3ahffej2+RupqSjjWBDOLoP0eZVT8j17a/wDa5r6phF8jAz/fT3chwkdsW8NrRi5ZW3i8FsDX9kx1b5NOlhTzi2kMFgf12CJZqiNlNj/iPNpuuX1xA/cn2MCSzM8nD8lLZRpTwy7FxuTS6sWrXrGMjFZaIfgvv2bDEtJREk5J58UxtFY2lBftv5TLluk2NWC2XznF4lB+jS3vUNfq7f/ceARLDc0eSf4ddb1SnnpuBK9hj1AjHSuOvn6G4YIRRRkZ7qgor+H/cF5xTbTaLcMtYnwTyhpJ9qhlHb5DkB2OpWfDm8/Y+FIOY7HXIzfE0bQfVusZBPE1q0ZgMElxuelLcTu0h9dK4gtdSp+/KxNmdcOXtCKvT07YNuymVf0DlwoKv8mzmj0btLv6EPOgVlTq3GTPgoayHqQ7qPtXOQQLeeZe+sdRv6JLRJuGqacnvf95TY/j3M0/1UWsem7oy5mC/lkX+0SduiMqkyIQGuVHbc4ALM0TgVknH6xUwuaNMomR8hTFPZtU+3QKugMkpSW+wOmuIIJg0ucbTLdTaMSbfvJuk/hzloEinbWOlUlJfuClUsvcXTfZ+mZxOvVv88p/ldRZ7P1ytpW4J9p1lmwc5GveEry/Ubyyol93enW5xnbr3Q2hIoewLq5jGxt1D00+qvzQ5FulfjUI/yknQBt2kcR4GxBvV+uUTZ4Y9JWucnnc5PcQ6Zgf5YLPumWvmNmoo733ZOPBdr2dQCyFb6Z/5uXCpwcyjYEZN1dKUfbf66Z+V2dpX/8CwJ1pfzMUC5A3CcHZVh5TJOKo8MCZKOY/JvI6nXOgusJgq01yJgVXflywTFdgT/v44qj0wznuDvMGXCr6thWTTxB7r9uTjm5WavCS0uLh0f6g69Xt0352WV6gvJ1ldaDRTc6kkzApwUiasYhMbjcGsfQgftuWc1jpOPKJcMzzUF0l5y+bQ4N4v4uu6+CNsFa5myVga0lG8EEy1ALv/M9M3etFD/diOnHQROKvoZmo3wP9yCssjM/MyU6fG2LSDzMfQDWJ+HuXi4HAgCt2K2Ri9iJKB3kyNoimUuUGT1JE8FqD0hhOd6dA0QukBCQE5y3XGZR1Dc+zvl+SpRe4kddvWQqk5opCyrgmV/9ObwS3AX7J7KRNBmN9jMsaw5eSpNMzijepo4fazmUGCp90/KqkfsvHvI590/jrpnHShTEKGGar/H7i8ac/ZPVZMGQ7aJkpaApHTxiOrf7STixdLeRwG6QLfO/vl480Vg7Nq8umCQFhxCL5g7PRje09lmfaKcF3S5d1L2JwOaaY/n228WYE2jCmCe1+CVqT6mUhRTyEvy8RO32hxRHVkrF2sljJF+mkMFinC8fPhDXTJNdv/BhAv6VRMBknyzdy5+hZh2SYM2EBDMM135RUQjviRF+RUI4aR+ory1PVWHXCihYQgk/SinYYVAKH7YBgovhwWBJkiHvAH0s+sxNJQz9/0BL5nB+LNAHrRwPdH+Gb6xInAzIG487QNcYJfE6cWuLQrmgAGPy1Gt37BYoT+JjVeoRQZPCDqrZQ/HtreSThTwfyI2BAEw6GreYuXF+A4xV4HJu3SyFiIbCA5AU95xUWB372fG5A0OZIPcSJgGYQDzLESJYTg9lrFU0/3L39z4bbOkxjJkNeFJm8HRaY5kJ+Z3BboRWlhvZXGGE+Ug/o+F5NBftx+x500jnHCAQnDwsqkyuBlLuky17IckPAszs3A7+qPirJaNO5Xb9dheUVLMNR+11xDo0JAItCud7cKyGOQ5RP84M9c3G+NPHR/Mm3fv9q1JLWK+ONyj0D9M1uLazOwKG1x4j9PA06RgcbyxD8Fp+6cc70BryexCw3w7XZlwI7yDtrnu6ueIlURQN8lwZAMrORgWZPGk/rWp6OCQLP6s0m9GFTgvRYE9qijtEq/d6Xd3Ui2jRkGH/Wrul3+Hqp3EQVgm0fbvY+3r//SHe+wzFQZmBWzc4bBnY+fQSx5Flzdz80nhLhVwszwfQxbIsvFMi4A3j57GFiY/Sj3gwl71u2vywVPoGgb3FtNmlZfktZB5KEvNcYmXm3CnGx6XqQ5BLFiakPqpH9A79krpALyRrYsK86Uyrb8BdlXKhTwFaWUxxOOHo1gfPAK7TbNVxxHrKzFdUCfGVzmJnydajUD691VSjVF5+jK5i+1vpcFMNGp9xABnl+Xn1qk2W6YmL/WYU5AWK+MEbBuIhQavMi7vdRoDPQqaNWr8aQdlClcnRyySPrN8yMDjs5ON+aSFruYb+nUmyU08h6Ba0YDt0bzd5YN92YS8EwdrV+FLX0BBnDhSDTEQQnKLos87ilqgqFfVAUYwXyk/nLdK/a7ApqaaRC+g2cKZWFoj6UufrUPpcGCJjvTrcYOw5Jp4vxWPCXyafvQlHkTySUv1yaW/Oy1B1aQNyv5+m/mc9T7mHvFgx9rcDpAoIp4ZrQ04KLqcdiWsMxToMG6MPxzDlqQbalxvsEQF42ticZamlkEjFm14a/hFc0h1h5HxR9eBzyw1tWURPo55FvxGR+KLRR15k10irajmSdXfXkPceq+rVvbeHmB+EKJChgwDKWlnZ0lLpq3Wym71Ogz755I4Dw8RX2DdpAinvLOVz7XJxjNXNzN0fv0f+wHAtg5NouimVqqdMIeSO/nMEK0fFbekinYTYRpVL363aaSkQhSAL0LwOXT16lH8n/0NzYPHooYuaI5ciFeiaDURGz485Ei8uMG4XwpR3KD9qotG/T5IEXTLocQoyTkcCj0u82K68KAg8pLfW6ABs5vmZSAyhms7KHbG68qOPUR0HA+h/s4eU5KG7Ym19QYEAXP4jmfziNptE2i5mvVST6eITnYbuwd3tbL8rrh2m8ZJgdBfKXjPC/ChjttgS22HaZNBtGs/IDjqDSsUDXQe8C9yhJr9rSnPYLwS/D2MFSIh8RKdTttdBKbklTSXiz7o1hAg0jx7sSOeHiISR7H+B9Q0zoDMhVPqwfYA+0Q9wz9S3BTCt/hfNHFR3pve/z9/ofPWfyfeDrxP7P+UvDs6ppYgeYCeWq/5mVhbQJwBuKybKvE4zQKrJ4M7aeqrNE0lC790H9MnSDUb2A6jhTMh1XtgDXLjWozbK1ugrMvMtMqV+CUqdRd7vaui9ZSR7qbuQriJk/8S0HUkq8OxkKMYbAdxKDARmPDHDFc+QuV8Ne2P7yGh0O7oE4T/SnmElD7hAsfBXrbUBRi+cFdL9WrwlVPEyttg4bbejIJyqFaB7tW3SneCgUQeQHIOiSHVSwkGvYnuJTHTZvZLQEGgJMSxbe48m+v5xH8OBXIfenfWZc1nMZ/7n8kPx7qshqKZtKeKuPHLYTnKw5+E0cpjHKQ5wrHij6P+n/ANZAZhEFsCwQ+p8qvwzObir8SBhhQra3t2ZfQ/IHs73oOCX25Tih2NX/WCXjdwcdu3DcRQ6jfWzzzOmtBN35lS7r0pXJ5tesFheyP14MGE4lBL2CFfbZu2scAI9q03WQfpt5zxx9nSxiebskCcjl1jSS3UlcWn3DyVNaFgzSZ3OU3OJjL8qGLlxJQbzLlA22AylAAjR0vbkeUaxyiWzZZP5rZnrbafAx0yPJj3c/a5pF6T+KBnSLfgbYA9y7aWuyKDqeLMnAGKU6bAJfWVCeKkqUMxNHvEwJ/U7yGKHuOVScGE9EIl/Ea2FUjFnsx0iv4ssKE3N/tknXFmKom/Sxo48IjPxv2vycgt6dqn9s/WIxVVrG3hQ/LDRc7z90SQ9EzU+MvQm0o3kYGU1iN1bsZS/4I745dK3Md9uSyKahMRfQv7cmpwV18QFzgPKlivET3tHwf04r6XlavLD0pkJi7UpM213kfXc+RLdGTIKK9r6c3lbZDte4uP2FdWEHd+FAZW8awbvBYBDenbe9VBQ4B1/q3lH+0zzEYSlxIbLXyxHIK0lyw9SQHp0pjUowE35TSz6b/hw4HzP14Ns4zA4i3RWqI1TAgrSCNiQs2n4yLQoDX4UEP4QFzApzxlUnYXAycQPbc/NpJqCEoNX8/Yy5FPd1bWJ6EdRe5YR5jMnmjqgv/C0F146Or7NcB+08mkHWzLsNKb3Au6mgYKtGZFDiRIH/iQ86E9X3EIvulGwc4AsWCwWlm75rKpbWZMg4fYCZCNgzAcsLvoX8+xFU3yvD020QgOR0lSwXYSuShWVHVFg68We+g3JCeFD3/KFNZfJd572mENZb9WCbyOMm71FIfK2z9eeSjl9WtzYICEMNOPK6sbhOM8lAiYsMA+JlBwNkAzXm2aiWqMl7aWbkpIX5lIefP+Z9X4colJWFqYUPt6F1k1ix28TpIcJ2zEYdno/QZDjC78wfdZQ+p9UQpgKrVkx7ZGzeWfEQvblCBPNch1D4xdDOsa/c5UA9hnI3grqlmAySY99fTJ19EXGdqcT0bYHiTePNa28HMGFa8fFVAQG2+wjD5pJGgi4CgE7BzBnTn6UjnmvtKjLcfcLbfWs5ux0SrExNHxWbJfeJEnHE/Ggtx/YjrQWDaT6peBykHEG4rbBXvIO0EC+j3hhXyss2RpOM232PTj2L7aLxbgfzBP7wizYzRwfO01Ukq+8vI3owt22kU2/Nmd3fm7kiT2D0oYlBU48rkz4kSjb6RFGLeo4iFtFMJP9glvfN039bYKZ4tcfc0w52HAAl8J7bZ8+lZXOUkj9aWPO1qt5zwLRYh/oilgxBTN0NYdNY6cNzcUV66/xWoiBgxs7vlNpty5NP0rd0wTXSWfMsEi0aH0PTS3HlUeCP2stgJI9C7D0tAqHELqhVo2C2HpLq7WiMS5gwsiqazWVoQsvjuYgm+VPE3aHq1mSgmoul155CalpyJrMb+trJqrGwrbt4+OehLQnH18lLWnSY6OIzUwUopCA9FL2UFegxZh/65RX8rUAvCLdxgS5wd2Ki3MdcBiV3zAJotT9no3a/SEl6O7XVps9m9vxiKx4NAOH1bwxrMQnw1If4AenefxQ63p1C6owW1h9sHGhj4skE2VOt23tDk9xkJkjSW3s1N8Hbo39ms+LPeiz0u4BU/xW9yQjnzZHeL/j4LL+oW7V+XUMgKSLNSi4MIi+Cm+J2bppiNsfKBY6L5bYtY4nKzULRCM6c4QEb76YzRZDAKi7zEe/hd2afOjwq39ZTtYGetnBNJ5n7V3757uiWcwt2iPbz0WbfsS3NUbV5T2yAxKuSjvVo4Vc8Hf3srzPBwc6VzX+gKS3t50H0bWZovhrrVxjXXGGc1/dJL8mAIncN2WgU06vI7ZqMtfcNCw7Iv1O32oybIaBmAdzoztIGGFCQyVWIqFiWR//2Yqj7cccpxqULsqBM7oX5Iiq75fj38FolhZ/ShellaLRRV2djDBu7QJ/zsMAMeef6UlyWiTlqzxfKDmH6PlOBOZMANMiF9IKWu5SRY3FvlwZ8UhfedZ/ojtGzvhAuOaLM5E9hbiGBBIuvgQWg21sbK/qzW9WsQf9Dx5ASbSCv1NZ52z7DMmbFOUsl/ZCWlW4izP8Ijp8Wjw7YP2wraoWTDYepj9O2AEkLSQIOGuoW1IfHyZndCUMANsyZOhUQCfjYsh1my4K4Z6cSZgYOjAL3ikMNuriRtlxU6a4biK4J4OEYZQhQnZAS8qmhF3epHpn/I+eQ3rGm5Kn7X8DvRZpdJMEMrMv6qejfQqS426d6ncpbzAjJjTGbMpJQGiJgQIoQwONHAgAvGAD1pxX4btGumId/laOEWxF/4xUmUMWDlb+hWGfAsEFiumIhGRMVQb/crQcX0tPzvRKSz5JX3oxi2wt5VKFJe204qmnPJXwYB4B5xlGrGv3OBOAQ/wa9La2W2+cOwebVZudrZ2LSyzAAD56b7GAUk8iKSjzdC4PT3IaGDFrcOGJ2GJpihQAhG+5EWauJ+ez1ZvSoAciRhMiLAZ7OBdagXzouSOR8PTOckAJmQlzVsTgMsGOz7mkc6/z5+JTL+I/gsOBWjlhPvmUqywshtEEhZ21sWX+YNLYQBZwme4PakMbSAoJOh7u17rSM5nky4wxGXIHs4KcsSCwRljO6yeezMemEu7d2jxvRrQTKpwk6sCoHMHMICqTevuZ1EVwth9shBPQIaPwzYDNU4y4aO05Z9kINbTe1K7QBM8GQ+ZtbilCBWeEXWZXfF/VN4uRx11FmYg/ArY7aM+N86NpQNjIJXLaC+wGkLY9sXl7orACvBNWxRdTN9TIFZgOYAyvwj4F/ySlMX89r1J6xkIUw59Z6HQcMWGj/oyW7akzlFAu3CGGkSD5HOCAkPSebu6i7fLVcjTrv7gkSfXna1g5jecG2++PSMhBBteFaRkCloH2EUhjPyacUSr7n63SEbAAWgK4L8o5eui9ZctxY/kqU2wlItaphf//FQyfI40qJA8L3u2xM20Ff0gV5yOAHOmGnNzxZDBWlQIMMFFDA9hB08KeJWZLz3STPn53u73GqzYr3FrmDe7jwgxRTDm/cRDxc3atSJkx34dhjxI2QlrqQI894iYbwgInygrSTCxP4iUhTP1TeDS9PfvxcfU2xqMv1wzro7CsIEE/ff7PPeJe1kh3kfPyJJgOMyZobqf8S13C4oIBFkcV52Pj1cfmx5Lhf74lClNVKXN4I0uXh8Ii3dGOAxlR7L8yIRFBwDiFqOg50EwCpL1coyJSAclslesTpheDBxa4OZDsI6rAFggB1c7VMDlf2TAkpn49z9kuHfSbivgSq2N/yV6p5CEPpIdJQh8Md57DXL85Y2cMTgJmr7RA9bQVbky0fe2de124oGTaSoKQ19mkfM22cHbO08Hfwwsy2IBqvX8ukOAJNgPwnes65GbaH+/GMw6oQFkTHx8Hf7zSdPxtv7mRF61C3ftk1gJlKgb/lOxg72AXYMQCi58vCfjMtjZNtSdmxs3xnhGkKzfmKGKmw7FeeasozhY2ZB2Mz/uhE/lEaf1+FALPTkOB+f+eyTMosLHqRca1pRavj2NXMO1FMajKxpzQumImRQAfj5sBcdePmTJ3ksI+5AveaWoSEOhm9iqMl/ZhbQ899zIyg7Tc6CyrGMwG4nFqDl5rLHUSQpEP6JNl6cjOopb8foNP+t9fimjo/oBqwF/XIcKMmpIasVrf3lEV9EVRW/98OoV1QGWJf/8gNIMpSx83Ix9qgOaZhsdqMD4MkGr9EcT3NL3kvacNvMNTyCq+/LmC0jcQ6uOTfsVDI+AUoNJKvH9UVcJuvSMKDLYTmUVR29YZq4Cslg0Pb1mAj6y73FoHk3plSRCtYZQGYGZnIi7j0Y7xp04CriPjyg5bdQKsHinSkX+7b2xaUvHN1LepopeWTu9M/10SYTwMSlNDVaU+dwNdvCoaPW6iiByMvev448l171md/tcc6MDG+vytVOn7oTH1BaoYy4Gx5ET8GQi1PAqEEMCbjjmEfDXN1a2zMqwiQQpHgXwFm1pe7otG/3oaXxkNwS5Vg7o/VhpANQsqpIEIJz9W04QV94I6cmK3OmatC6lRdXDZCLpYEUZr8mMxmr+SXJ8ykGo499B0jbsUGjTlN+kq7YZs6E/kRFednqq0guNshiwVqI7FrRT7W4EFG6h1jf3Ul4JTuwtzRuYtIYJ1EZF08e1J/uLgqRl4ND5O82+vTkXxzFX3ahKBl82SVhPNaC/Zv7Xql28IRVVshOmgJ8JwiTubDr5l0zDBwiH8Sew1Q/Qf5prwMz+p8yNK8kPgUpHGhltLm3jfUTur4CNZ84fxeyJ78G9AjIza0viCRo8BUyrxUIUL9RaMhnmEmcfQWqH72A2Xy8dZbs0UYde/Zg4ojTXn7bwquwpjF1FnGKQa683K1kQh6twH9pE81LOEvRrDHgwRxcp1TdpuWkPq0ncxcaPpz2VguvS13GCejg/00Yun+xD/4yeEeDVHWssy+xeEK0rxVqgjxM7f/Zigl+Q5ia4A/VOcPi5Z3U6RYnyHK52zaFrJXlIwUTB8tA10sNrv36YayV2UWgZSUUnHZB5UburuJo7vAQx+RWgpRpiMsppdYfbB0I/QPlzoIjEPhoYsq6XiCaFx504sZ4P6oa+GJl/GOaobKMizOkyhUqrDkBd2m8CF91bRrHnNKXK9iUv8tJA2sm5N/F2od1wzY9gMEimwGmR1woPJOqD2J6n9b1ZoDzzK3cqwdMEMNWhC74jXK3evoKCetFl1LJWWZzkLohNJvZKtFMD3QFFWXTKtYZq4a07o1QtSMU0sKrf+QWZVtUC8idUuNYrVgi4Bt6/G3fbA8UnpES+NmD8ZXAX/4N0/Mbi8U18Oiba+6aQpqGO0khcvsN1PEQvckZF+y/hnUo4JDaLXzxivBQZIP6CfQan0mhqlHMw+RFjVoWvGQ15ubLJYEnHyYGOHgYCEISL0K9rN8SMXBj2munbeDk7OuV2LXvvh4ywCX0Qs+qoBNu0yy0yXwduXKXy7stIMaxP47IAq3unyqU/C/m5K3MuU3jt17CLEM3L2ndBzXORZ80nlKjAGoT1lHevpEa7TXMYSOSj5KQZo8jWcAqVXVWzCrp5WncBCeVrf7fYCHe4js4BgbYiq881j79OR6AfHob6RL9ToaXNuBt+89VxqwzsAPM47cGwwe27E0lLQLV/XnPM4/jFAxPpMbBvAuEfZIOstSTWvtRV22/9g0/imL0gDPykYy1wAMWIafcIgH5DOEukFfC1KsSbw8SfBWh7JK9c9dcxm+gaSkOtParRC+eZw0pmasF1J6HVgcBbqdYzR/PbdtuM9R+z+BFpoiTPbmWkkrrJfOf9U1HT3JXl+B0x5ppuPkRuWWpOd0+drQ3EUDe7GKBUbHuwa96sxNOBOZUURuh6lBZJTD3REs57B2f+8pOYXW6DJy/OyLN+dsOR/ESxUlicJQjjZVlFXvjiqgPsbhCx4h+CVOfkwxZXnxo+d02XTymmKvQzXqlniSUWqD1pCgP7HxDWkYS5MNyrGXgzGBfrQF4o13KJFeq/CZmd6yRUyEEhiw/LJuXEDp7vuHoE4STWC3r7vQzPsxde6h8g8qT5N7dmK/lawxrXs6lMCDKnVzTw8iJjR3iGKIdqbJ3/W0CSAicp4T5LiBdMcEtTRpDtXMWE73Dh4WEK05mJugaQQwe6e4+El6ZCqWZhHNl72M7GC9UOxNsMtFZyKQ3H7uYB1sKjig3VN+TpcZzqUb1J60J6iXw0PkSLQYelZytCqwCQuuOgBPYKNhAMp5aLXL0MfqgsFLNTIXd3gUJ+6XvsvCBqt7F2DEsSyrEWdY9Ojv9u4LGL7B/rs9yNyuaAKoA3RQlEGkQoUCP3pb0ksPvu3zrjY3EkEBCOHVQtc10o/OlKaYRZD1/x4Pn1UQuutemzcpGX15uBtnM853WYrEW4hDpG/TlaSbSmk1kDEe2V5uUmt3+EA6vp/nala5qel+u6i+yLbodW/5yR/h6JTzw7B78XM7AJ2i8Bh6a0KenLm7GNNaxkF7aTXz8jxs41W3e0XGZ+boVrePNX+bTMTEzDerZe0XBhFaWPVe9pylqVIXoKIycKEnqtH6kWU7kHKEutFRdzQwLlLOEsBi3ZvOpNoB8XmzxCPFOPb/8djKUazw3lOiKwjYrm+AQDk6unx/mF0qqZhaSrNZ9LsD/Fq+BHslra2wlNDl/b3CMlAxhpahOBKZ+Kj60NscdKeFPP7MmAyk38nGbVVVFKsvjE+OB1b9n9rgGMPkeBundL3JSRHM/yL5oZpy5iy/EEBwxGLeOohNmA3/luh/Y9tBiK2P9UbNsdaHmb8BMpptTiNm2Q3p0lPQwzelcNzZI4OpGQco3STMO0/k1W4GAj21SwyWGvDXqgmwpDwqqbXAefB2N+LjGnJyb2+ErM+nH2b9XIorK0+WRD5jiISbLT81MqDD38FpeJ2zQ9ITyPFPGgryKlng4UQf4Fgzi/q/twDDD+QJUyJKg7NgWlhxZZgbxJsaK9fDi+7m6LjRtb6m+eCTCr40x0i3CSocYdobnfNX/qd70Fl7y5Xip5CydUweufyVaL2xe2J+Fx8HNpGEglx86s/aM6ow7IXOsIj4xeNcapOeILD74zJ74UDM0kLK4gvyI1TZ+s2ssg79CfdXApLFu16WbCF+VCsC3tJIbwsCeuMSeKEPkXC1SH2Vnf6d15wZx6ZeooaLww/zrQ2UyUYNQGo2Q1RseqjLqehPfWCbwCHjLP+bElSQSpWco1GCLR5TiFHnHp5NQrj1dRx2riEABYmzb/Y8OKnjAmh2JBpKiea5Tdpd4Enqq5GgtvI2aPOkCHJ807hNTS44SdS5/cjw0PKp/3G34ILFkw9v/SyYBscSNBDjPyQdzB/l3marPAvjQRfuzuhjWWNFCvxX3djK6vyU0CcXRhMM4qcxRmIt8XRbI5QeGYn7VpJrG8eAHjY2+SWuwGOal2vWlBo7NPinftb2r2UWX9r1cl3u8kqiVQPXdIZrinuws7HqElc5Tr2tbE00PnAURE7/mO/uPZ9f66YYFv4gOXV808SVR3ELLEmq8S6SboTZSk68UKLCYqkhJNU78tbIwdgnMW9LLGQyhTmLdCcrNOlWmNx/QAQhMXOzphVrAtA36y1hl+mdjoX5A926gL/7f62L7ay7Sv9iOraunMXm5rWGwcegHYw8toB6iPArm7+EVYw/PQQdIsITzeDyeTuuOYTSKR7MvLK0h7EDNt70VgkWVWduZmNrXDvzIepB7cWbupvQE+Xuq/tqzoCzqo3bAw7ToXBEb5dA91NKsneql+73+dzcRyxbKaUaDLFPL4Rr5pbFQ67JO5F2CEHUTOWy/LMOFTRkM/Emg0tkeMlaqhj8UrU9CV0G1DfikAlkUbaA+6wulZNdGKMhxlOJO5dobOIA4n/PByvn/Fy5TgBZMnS/XOlNkn1Gd4Cm5YNPWIODSIqJUmh71QEvPgtZcftLQCZT2Qq4VRHzH5oINCJNXCnJ2/EpGbU9KM2VJuniMalQLlMyyWLfzNa6IMdwuVFUwL721yC0/eKMg/r7zG5eiz9ORk/hOvIEkEYc68BIovBN7RI4OSEtY3NgCFOa9rDR0KpTXMnAdcXWxegLj50TZhsWVSgzXMelG0o6vKq0s7tTF1+Ua1JboilBbQPm80/b/UBj6SKjvwpYInYje3tHHBg/2L4LnCFi+I6MCX5HWU/0CMc1n2glRgrwSxVAi3h2NiH643lUuvLnITy0W6xQXl/4ljxndwwYhpeVJ+PjvhGcUkOD3Eg7SrKHGtEJ31iSwywX7Ke2vIuGOs4IEdwqT9lg39XVjX1CpD4+BQvKQMJtUXSXsfSJRaXI9ZI/x9NwwK6ASUi0e9M3lgkATBVThpZZjvR9KvjZ6qjFxhDgehurAAaf250bBfYBZCfN6s6rDB1lnWifuWCLxpkRdD12aZaZ2PZExQ1sGJ+HwQ2tO01alGOjYMX37B/kJlpUa8MYMWD91rf3euw1ii3Sx4umwQbzZQpvUKdjx0QZFFUD+KPByi/ZqG36PBP6NskWsiXMIyQD2yFKRScxaINsTBIIm+1VopMHLk6FPtlD7KxW+RomT2fiJLsEegmfEeJzI55YHAxkBn+l+hkBC1KvomMMzXCtTfESCvqsnqyskHc3WMewLhXi52Sx+BsbbR5Hj9lhVW4j5RsCK5/oftv4x38y9yGNAjza16G8a/oQyz74S/kwRDvM2NUHdq2CdrXvPQ45nBeMLNzo2wmJqvwnmk0Wp2repzPYu3VF+OoOatWyL1z+5DQsLzHjbelt0cjAjtYEfx7fMO9q29+0vZxPccMhvrgoV9g7q0j9fHrKfh/SdPAFg+IPSHPiYpd2c+/qc9noVO4BJaJYL2nHTf15DxqxpthtfD0YmzEQW8g7HaV4y3JOEjFJ/KZMDPdgQrCqet2s7Q5AU5svgXvOU7Epl0b4hNfRHwJIjE+9AFud/CQzEquSOH+TnTEHwKhnxqkmXgOV/O7NWYlcnMpraEPPUUh0nVWPbaRnKYnLORK7xT4dKkEB8l4zE3orpLyLTy9x+8m0R5vk2f9wpUS8G/oyKE9Nv2X5aUnRTO19oaN01edufVulZcr/mT0y440yG8JPJEMGUi9to400e9VDNIeLAt5PunY6g1HbFEMqELNXPAb6Vga0MF6boSbWNdveEJNtNFjOFKKzAtVWIdFsKRGpvYoYUXNDUe/B4eHb+dpdw+98/SmhZ6jeWK3ItiExx+RQOD5lqSl9m+VRW+VfNaeEF7hwkulS/+KLGCpDStbqmNrDFNqOhv6rwzGiaB5GTQu2csazdx2CgluTgiWT6FTNRhBuxo/RBvXlQsFLC030iEe1gEkRJc7OJ+VzoGxrdqiwv4k4HsqyeXQDdTCtOK5guwz/D6dMczFD+CxjdOhO3519Q80pEhsx/OTAs/KtX7FDf9fA2Gj0bH12xDqaw68Sv3AVZG8yOe4X2KY9R6tDy+YGYJhsEogXhfGRwiNdjEqbsL5LYpw4ARxno9wvFIXhdkmjHHhOaeGTfABPF5tzmRnfIbGbLW4TZXmJoi/OGI1xeeghWw8g9bBB7+ND7PWEdcbgrE0ka1lQUkT8GH7rdg6M3TYsAWPmO3Z60zXiHcgzJj/zEGaZP6+/gTRIWZeKRm1yJ9EWQNyjeMla5E3H3ef/W3mWoTBBZQZUje4sIb81Sd3uoJwpGEx0hypi/6NArh5bXucLqG8AUkfwOOxEo3GUQ9Y+T5DbyROplb/rDeXozaH0iRM5NapE+8E0FsGjWs1rNDauRXi/KV2+wA0CG3ETMDfzAnQ+zw4eoaoQmOpD+N7way9Yubm2ZG/UePnmZjvk51mjZVpEML7NdGS/hes4v+XTMJ4jjee5MezHBVYvGLBc+4zw2A/2rLiAhLZunzniJYwRARUrOgiL26p8adVSL+VeDCaeXQG+iMcQyRYgZoqhFG72gVI58FJIlFu79YBPOqqqhjpq2kw51OqFwGH0wBreRASWdmlwF5TxfpnRdxvxB37sbHrL8larhRuKrMNh7jDM1d2aV2FvJPKQEbGBoUK0UXva26Xz7tGEF2ciN68Ddc1V8z1x+aloHUIbaH8IVxGb3mir2PisVO0BpQQy7L5E/CgG5s/u54Vk8ojfQXZH8tnUWb8l+nkkH354IVtDvX0/KW0oRF/QRSsJEG7jsWjXYySbNob8hJ7aWUmMYMGD2WziDF/rWZGOnUWMFulRc76o9k28wD+IgDbES0vcpDrV4lf1cMV0FNrtCEMWdyGRXR5MpA+r4B2iOgbX19OSR2nNXM/Nh3nJytwZkjthhFJGhSGezXG/wS9Yo5Z4Dhv5hh0c9UuAb7NERbZn2shuCsqMgakQLOhSSh1Xs51IaiSPhRkz44MIJFp0VVNkDInyBLQoe8zy0uaBWMhI/Dcg2EKnmxXpSYn2Mx7QRGh8AmxURecFDvSUw7/ht+8ZSb5hbit2W+Ql21K2wzh4cTVqn9hej5aZq6huiVV6AbKE/sbo22LgsgcSTXBiA4U085dMNCU6e0aQaZado2sptYp9v0NOwEeYLTfbfFXOipZaF1qMHyYnVG+Kn534x4d84Y22NqRtO9mNpvPjtZuG9lo04NO7cjNwUtVkRJ4e8T8JbMCz4H5hOQxwUuMedN2YNzpNpJNsvZxyjZkIOBvjw75PuJ6LrbV1Eh2FyCXxlfVJGkgZtohD+cWTNZkuyL/jE93qCga0aGkqd6xExLREbBfWXtRNS3Au4y95roGNjy6b0xJSF+Ovpqh8WYDD7C+/JPAyjv78jDhULJf1wevH0wjhVNUiO6cbAOBoVHm+L1IsdXTApJszQyUXz0FfHBnQw3unYXPoSQ5NbWDQ2hWNjyj8rcn3c9ZuJ01THI8HLKeapeLO4iUfdvIUOs67RJu2PKIzxBg6D6fy5DgocRor0LIeL2/xuHhIrl5Ux2zfGQFxVLsuj8fVLrSoRNxN3UOjojUl921Vi07/gFl821rV9woTppDUgwOIVZM1zO2dSrXT4kIDW7Lq5nbxQr7b00wXdNyRMMsy9IEENQirpuNN2RYQaGb2jn4TunSFdH2aoiYQ1vZbrwRwVRzcVzWpnGu+bFneCAhxvH48cjI/z1Kq0mLbjPypPr/KE6foZf8KcAScfh1DVbFXTSTUTQqO7JNTN7LS1TMaI8Xwdw81SkqFxpNsBByYlaxqyaggRksiaoaK5qFifc/4RIuEj+q4PfNwTFejGeE8ZeTuIfRykuXUNzrQ1kIMkutUKgD5KmCtHzSbiuah5XZ/tpaK77H7qRRse2YbUVHcIL2UPEM5LfrTzjH+JRGeVyg7uPDptM/04WohPatyRm+TmS6jgeojHdxgerB/owIw+3/cutmh8AdPetpCCY1XenzyQfMFHQ4tgbzSVWmsAwZDg/UXtF2a4wHD4gGKcMJANczMkMiRuO1zRd83ZVL00ruLNLqcJivswb4NaCOXQlrWPLFT7U/zlUadj1oD8IOTbHgb6lc2a1pNcgt3WWDkcIZb8yHgpslE6p/Eg8RUfgI/S62X6nZZjz14VMgNcbl0ClooLA0pkWrscCZLE5YicKwE3hwTfd0uqcrgz86UGpYRd54Lv1dGibt6KLQtUlcXGqJnLewhqpPAAMm9qeJ1rOnaxDfNKEU+p8cOnztMQrd70bsO9fVqAzhu9aIpMQ37iYIGFZkL01F/inghGLbFptMrAC5GOl9y0KGibZfra5omSkZh7t+7hgNHhFq1IUMzr+JKh5YOXU6ziqZHBW28E94hhol8Ltz/K1z61W6YA8DmLNxCZbjMMCsFoepjjAcWGbw7S9IJT2sz6IKxsRrCDNohUE+wOvEZkBqlKHGF9tzeFmbiAR7C67OyCaf6FNdHmMZ1N+1EZsi5CvdK0ctvRZrF+obLdktsdgNCJSR6sy4ErcFmYTOkIMYEfnqI5mTA5Zc++vAtcYiUe23vnG9GU0xTGvxY8P5nrKLDfYKLePMi4BlqLinPk7oLC/61JccFfvjnSCNrYVbsMWOdnWHjI2ilPnQjJtbqV67gZ0B4t41LdKSwEKpsLZD9RuN0izortAqmysQxOPeH8as5d3wa1zz+ag/YK620D81wbPKjqKBAkodMqdq0X9zj/TiHGHFGrrWT+GTI0n0x8s3HaGzwMzGw0WLvrokr6IWv7EKa9pScJZCfLGW1Qi0KFUgR3XqsqmPlwZuKG+hMrTXM1SE0w7zhpoI/2OpeI7zfjQMD1o7CO+aFicynlIbKc6mil1FACztmL7GbxQh0ZeFGoRd76B9az53OG68EoeQ27VqZzaVnpNFssQPG/abDTZ90OCuKMw8SJMhXfDG8NsAlpRiMWPwYqTxgUV+Y6DKWoC0RVw3MlDEv9O3nhV2LiHvyRLqTgmlnTIWhAb3oZ5/sA3DTcdSm1Sdv/mr/0CRF/HX9ZXqmlh/s3SHlwRZk/H/XYHDYLScGb3bRMwtd4zGqegOzo2nNOfeCLWsVRgf2vd7xLamYvLgyDT7QJyuIV8aWU8HmPDelx6wOsapeowp92xob2tYI1opdipQLOpwaUyvjGiJcxXkd4wNW7TY2ZO+BMxyNDPrKtViqtEw5y0cvuo+KcZS1FTqneLO86j4TEVevcqFf9fxsFIW9e+hJvB/iDitwnvWdoF1uOYs25oMItN8G5qoVtvyQDaWW1qCBM2wT/QpanJKpSsLnz6EZ89bUoh9uy03L14/5Rjj9Q1rP5d7joqFvBGptqD66TT1B7sGPhvcZ9oCnPtePTF/KHeVGmlY3tE52mDtX/dLBwvcPXZmzCiOtZy4fdcMj0BSt9JzCb4atdyMECu3SmHCrYUPOaQTsFU3DJOPMLGD6QLfeVyxUtEI1TU3aJBqoPi7exCNWgHIfSUnsQVWV7hiZPkCpoXaZqr0z3a83Kgw8PD06lxcuJAqTH1NQq+yHf49033g/0+5RXLiRGKd+TfxXXomSxl4UbR7DPsegnq4vARB2HCLIF/LCTjJIfAC3f+JHt4pydLgW6+QzwgqOTKYOir21s/V6mkBaz0/9BvJVRA9wlU4Lg6eV+m6mjYUXN4=]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fnaturerun%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fnaturerun%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fnaturerun%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fnaturerun%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fnaturerun%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fnaturerun%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R(根据深度优先搜索的白色路径定理,R必定存在)，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode* p = nullptr; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if ((result = SerachBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.push_back(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(scankey, make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.push_back(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;; ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); current-&gt;keyptrmap.erase(current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); ptr-&gt;p = current-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = current; root-&gt;keyptrmap.push_back(make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = stackforback.top().first-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; scankey-&gt;first = q-&gt;keyptrmap.front().first; q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;keyptrmap.front().first; ptr-&gt;p = ptr-&gt;keyptrmap.front().second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(current-&gt;keyptrmap.end(), temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;keyptrmap.end() - 1; current-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则同样交换g和p,r的颜色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则同样交换g和p,r颜色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fnaturerun%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fnaturerun%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fnaturerun%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fnaturerun%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fnaturerun%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fnaturerun%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，但是仍然可以继续化简，注意到代码四第25行k==0为真时完全可以继续执行k=next[k],最后会在21行执行next[++j]==0,效果和第25行为真时执行next[++j]=0完全相同，故25-28行可统一写为k=next[k],从而得到形式最为简洁的代码五 1234567891011121314151617181920212223242526272829303132333435package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 这(代码五)就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fnaturerun%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fnaturerun%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fnaturerun%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fnaturerun%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fnaturerun%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fnaturerun%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fnaturerun%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fnaturerun%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fnaturerun%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fnaturerun%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fnaturerun%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
