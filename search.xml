<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
