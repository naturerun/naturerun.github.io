<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/NTRWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
