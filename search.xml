<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode* p = nullptr; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if ((result = SerachBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.push_back(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(scankey, make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.push_back(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;; ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); current-&gt;keyptrmap.erase(current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); ptr-&gt;p = current-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = current; root-&gt;keyptrmap.push_back(make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = stackforback.top().first-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; scankey-&gt;first = q-&gt;keyptrmap.front().first; q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;keyptrmap.front().first; ptr-&gt;p = ptr-&gt;keyptrmap.front().second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(current-&gt;keyptrmap.end(), temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;keyptrmap.end() - 1; current-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
